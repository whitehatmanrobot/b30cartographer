  /* [retval][out] */ BSTR __RPC_FAR *retval);


void __RPC_STUB IDualGroup_get_Pragma_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualGroup_put_Description_Proxy( 
    IDualGroup __RPC_FAR * This,
    /* [in] */ BSTR Description);


void __RPC_STUB IDualGroup_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualGroup_get_Description_Proxy( 
    IDualGroup __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *retval);


void __RPC_STUB IDualGroup_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualGroup_get_Path_Proxy( 
    IDualGroup __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *retval);


void __RPC_STUB IDualGroup_get_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualGroup_put_Path_Proxy( 
    IDualGroup __RPC_FAR * This,
    /* [in] */ BSTR path);


void __RPC_STUB IDualGroup_put_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDualGroup_get_Rows_Proxy( 
    IDualGroup __RPC_FAR * This,
    /* [retval][out] */ IDualColRows __RPC_FAR *__RPC_FAR *retval);


void __RPC_STUB IDualGroup_get_Rows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][id][helpstring][propputref] */ HRESULT STDMETHODCALLTYPE IDualGroup_putref_Rows_Proxy( 
    IDualGroup __RPC_FAR * This,
    /* [in] */ IDualColRows __RPC_FAR *rows);


void __RPC_STUB IDualGroup_putref_Rows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDualGroup_get_Attributes_Proxy( 
    IDualGroup __RPC_FAR * This,
    /* [retval][out] */ IDualColAttributes __RPC_FAR *__RPC_FAR *retval);


void __RPC_STUB IDualGroup_get_Attributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][id][helpstring][propputref] */ HRESULT STDMETHODCALLTYPE IDualGroup_putref_Attributes_Proxy( 
    IDualGroup __RPC_FAR * This,
    /* [in] */ IDualColAttributes __RPC_FAR *attributes);


void __RPC_STUB IDualGroup_putref_Attributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualGroup_put_ClassString_Proxy( 
    IDualGroup __RPC_FAR * This,
    /* [in] */ BSTR ClassString);


void __RPC_STUB IDualGroup_put_ClassString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualGroup_get_ClassString_Proxy( 
    IDualGroup __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *retval);


void __RPC_STUB IDualGroup_get_ClassString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualGroup_put_IsTable_Proxy( 
    IDualGroup __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL GroupId);


void __RPC_STUB IDualGroup_put_IsTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualGroup_get_IsTable_Proxy( 
    IDualGroup __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB IDualGroup_get_IsTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualGroup_get_Keys_Proxy( 
    IDualGroup __RPC_FAR * This,
    /* [retval][out] */ IDualColAttributes __RPC_FAR *__RPC_FAR *retval);


void __RPC_STUB IDualGroup_get_Keys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IDualGroup_putref_Keys_Proxy( 
    IDualGroup __RPC_FAR * This,
    /* [in] */ IDualColAttributes __RPC_FAR *pdattribs);


void __RPC_STUB IDualGroup_putref_Keys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualGroup_Read_Proxy( 
    IDualGroup __RPC_FAR * This,
    /* [in] */ VARIANT varReadParm,
    /* [optional][in] */ VARIANT varReadMask,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB IDualGroup_Read_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualGroup_Write_Proxy( 
    IDualGroup __RPC_FAR * This,
    /* [in] */ VARIANT varWriteParm,
    /* [optional][in] */ VARIANT varWriteMask,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB IDualGroup_Write_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDualGroup_INTERFACE_DEFINED__ */


#ifdef __cplusplus
DEFINE_GUID(CLSID_DMIGroup,0xDA6FAB61,0xDF21,0x11CF,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

class DECLSPEC_UUID("DA6FAB61-DF21-11CF-8844-00AA006B21BF")
DMIGroup;
#endif

#ifndef __IColGroups_DISPINTERFACE_DEFINED__
#define __IColGroups_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: IColGroups
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [hidden][uuid] */ 



DEFINE_GUID(DIID_IColGroups,0xDA6FAB62,0xDF21,0x11CF,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("DA6FAB62-DF21-11CF-8844-00AA006B21BF")
    IColGroups : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct IColGroupsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IColGroups __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IColGroups __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IColGroups __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IColGroups __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IColGroups __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IColGroups __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IColGroups __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } IColGroupsVtbl;

    interface IColGroups
    {
        CONST_VTBL struct IColGroupsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IColGroups_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IColGroups_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IColGroups_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IColGroups_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IColGroups_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IColGroups_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IColGroups_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __IColGroups_DISPINTERFACE_DEFINED__ */


#ifndef __IDualColGroups_INTERFACE_DEFINED__
#define __IDualColGroups_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDualColGroups
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][dual][oleautomation][hidden][uuid] */ 



DEFINE_GUID(IID_IDualColGroups,0xB9C1FDE1,0xE152,0x11cf,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("B9C1FDE1-E152-11cf-8844-00AA006B21BF")
    IDualColGroups : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ VARIANT varGroup,
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT RemoveItem,
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveAll( void) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT varGroup,
            /* [retval][out] */ IDualGroup __RPC_FAR *__RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__Item( 
            /* [in] */ VARIANT varGroup,
            /* [retval][out] */ IDualGroup __RPC_FAR *__RPC_FAR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDualColGroupsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDualColGroups __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDualColGroups __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDualColGroups __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDualColGroups __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDualColGroups __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDualColGroups __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDualColGroups __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IDualColGroups __RPC_FAR * This,
            /* [in] */ VARIANT varGroup,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Remove )( 
            IDualColGroups __RPC_FAR * This,
            /* [in] */ VARIANT RemoveItem,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveAll )( 
            IDualColGroups __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IDualColGroups __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IDualColGroups __RPC_FAR * This,
            /* [in] */ VARIANT varGroup,
            /* [retval][out] */ IDualGroup __RPC_FAR *__RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__Item )( 
            IDualColGroups __RPC_FAR * This,
            /* [in] */ VARIANT varGroup,
            /* [retval][out] */ IDualGroup __RPC_FAR *__RPC_FAR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IDualColGroups __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval);
        
        END_INTERFACE
    } IDualColGroupsVtbl;

    interface IDualColGroups
    {
        CONST_VTBL struct IDualColGroupsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDualColGroups_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDualColGroups_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDualColGroups_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDualColGroups_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDualColGroups_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDualColGroups_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDualColGroups_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDualColGroups_Add(This,varGroup,retval)	\
    (This)->lpVtbl -> Add(This,varGroup,retval)

#define IDualColGroups_Remove(This,RemoveItem,retval)	\
    (This)->lpVtbl -> Remove(This,RemoveItem,retval)

#define IDualColGroups_RemoveAll(This)	\
    (This)->lpVtbl -> RemoveAll(This)

#define IDualColGroups_get_Count(This,retval)	\
    (This)->lpVtbl -> get_Count(This,retval)

#define IDualColGroups_get_Item(This,varGroup,retval)	\
    (This)->lpVtbl -> get_Item(This,varGroup,retval)

#define IDualColGroups_get__Item(This,varGroup,retval)	\
    (This)->lpVtbl -> get__Item(This,varGroup,retval)

#define IDualColGroups_get__NewEnum(This,retval)	\
    (This)->lpVtbl -> get__NewEnum(This,retval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualColGroups_Add_Proxy( 
    IDualColGroups __RPC_FAR * This,
    /* [in] */ VARIANT varGroup,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualColGroups_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualColGroups_Remove_Proxy( 
    IDualColGroups __RPC_FAR * This,
    /* [in] */ VARIANT RemoveItem,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualColGroups_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualColGroups_RemoveAll_Proxy( 
    IDualColGroups __RPC_FAR * This);


void __RPC_STUB IDualColGroups_RemoveAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualColGroups_get_Count_Proxy( 
    IDualColGroups __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualColGroups_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualColGroups_get_Item_Proxy( 
    IDualColGroups __RPC_FAR * This,
    /* [in] */ VARIANT varGroup,
    /* [retval][out] */ IDualGroup __RPC_FAR *__RPC_FAR *retval);


void __RPC_STUB IDualColGroups_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualColGroups_get__Item_Proxy( 
    IDualColGroups __RPC_FAR * This,
    /* [in] */ VARIANT varGroup,
    /* [retval][out] */ IDualGroup __RPC_FAR *__RPC_FAR *retval);


void __RPC_STUB IDualColGroups_get__Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDualColGroups_get__NewEnum_Proxy( 
    IDualColGroups __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval);


void __RPC_STUB IDualColGroups_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDualColGroups_INTERFACE_DEFINED__ */


#ifdef __cplusplus
DEFINE_GUID(CLSID_DMIGroups,0xDA6FAB63,0xDF21,0x11CF,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

class DECLSPEC_UUID("DA6FAB63-DF21-11CF-8844-00AA006B21BF")
DMIGroups;
#endif

#ifndef __IComponent_DISPINTERFACE_DEFINED__
#define __IComponent_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: IComponent
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [hidden][uuid] */ 



DEFINE_GUID(DIID_IComponent,0x445360E0,0xDF26,0x11CF,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("445360E0-DF26-11CF-8844-00AA006B21BF")
    IComponent : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct IComponentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IComponent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IComponent __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IComponent __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IComponent __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IComponent __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IComponent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IComponent __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } IComponentVtbl;

    interface IComponent
    {
        CONST_VTBL struct IComponentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComponent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComponent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComponent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComponent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IComponent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IComponent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IComponent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __IComponent_DISPINTERFACE_DEFINED__ */


#ifndef __IDualComponent_INTERFACE_DEFINED__
#define __IDualComponent_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDualComponent
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][dual][oleautomation][hidden][uuid] */ 



DEFINE_GUID(IID_IDualComponent,0xB9C1FDE2,0xE152,0x11cf,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("B9C1FDE2-E152-11cf-8844-00AA006B21BF")
    IDualComponent : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put__id( 
            /* [in] */ long CompId) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__id( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_id( 
            /* [in] */ long CompId) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_id( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR CompName) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Pragma( 
            /* [in] */ BSTR Pragma) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Pragma( 
            /* [retval][out] */ BSTR __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR Description) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ BSTR __RPC_FAR *Path) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Groups( 
            /* [retval][out] */ IDualColGroups __RPC_FAR *__RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_Groups( 
            /* [in] */ IDualColGroups __RPC_FAR *colGroup) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExactMatch( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ExactMatch( 
            /* [in] */ VARIANT_BOOL bMatch) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Languages( 
            /* [retval][out] */ IDualColLanguages __RPC_FAR *__RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Read( 
            /* [in] */ VARIANT varReadParm,
            /* [optional][in] */ VARIANT varReadMask,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Write( 
            /* [in] */ VARIANT varWriteParm,
            /* [optional][in] */ VARIANT varWriteMask,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDualComponentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDualComponent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDualComponent __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDualComponent __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDualComponent __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDualComponent __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDualComponent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDualComponent __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put__id )( 
            IDualComponent __RPC_FAR * This,
            /* [in] */ long CompId);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__id )( 
            IDualComponent __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_id )( 
            IDualComponent __RPC_FAR * This,
            /* [in] */ long CompId);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_id )( 
            IDualComponent __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            IDualComponent __RPC_FAR * This,
            /* [in] */ BSTR CompName);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IDualComponent __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Pragma )( 
            IDualComponent __RPC_FAR * This,
            /* [in] */ BSTR Pragma);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Pragma )( 
            IDualComponent __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Description )( 
            IDualComponent __RPC_FAR * This,
            /* [in] */ BSTR Description);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Description )( 
            IDualComponent __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Path )( 
            IDualComponent __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Path);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Groups )( 
            IDualComponent __RPC_FAR * This,
            /* [retval][out] */ IDualColGroups __RPC_FAR *__RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Groups )( 
            IDualComponent __RPC_FAR * This,
            /* [in] */ IDualColGroups __RPC_FAR *colGroup);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ExactMatch )( 
            IDualComponent __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ExactMatch )( 
            IDualComponent __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bMatch);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Languages )( 
            IDualComponent __RPC_FAR * This,
            /* [retval][out] */ IDualColLanguages __RPC_FAR *__RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Read )( 
            IDualComponent __RPC_FAR * This,
            /* [in] */ VARIANT varReadParm,
            /* [optional][in] */ VARIANT varReadMask,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Write )( 
            IDualComponent __RPC_FAR * This,
            /* [in] */ VARIANT varWriteParm,
            /* [optional][in] */ VARIANT varWriteMask,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        END_INTERFACE
    } IDualComponentVtbl;

    interface IDualComponent
    {
        CONST_VTBL struct IDualComponentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDualComponent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDualComponent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDualComponent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDualComponent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDualComponent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDualComponent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDualComponent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDualComponent_put__id(This,CompId)	\
    (This)->lpVtbl -> put__id(This,CompId)

#define IDualComponent_get__id(This,retval)	\
    (This)->lpVtbl -> get__id(This,retval)

#define IDualComponent_put_id(This,CompId)	\
    (This)->lpVtbl -> put_id(This,CompId)

#define IDualComponent_get_id(This,retval)	\
    (This)->lpVtbl -> get_id(This,retval)

#define IDualComponent_put_Name(This,CompName)	\
    (This)->lpVtbl -> put_Name(This,CompName)

#define IDualComponent_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define IDualComponent_put_Pragma(This,Pragma)	\
    (This)->lpVtbl -> put_Pragma(This,Pragma)

#define IDualComponent_get_Pragma(This,retval)	\
    (This)->lpVtbl -> get_Pragma(This,retval)

#define IDualComponent_put_Description(This,Description)	\
    (This)->lpVtbl -> put_Description(This,Description)

#define IDualComponent_get_Description(This,retval)	\
    (This)->lpVtbl -> get_Description(This,retval)

#define IDualComponent_get_Path(This,Path)	\
    (This)->lpVtbl -> get_Path(This,Path)

#define IDualComponent_get_Groups(This,retval)	\
    (This)->lpVtbl -> get_Groups(This,retval)

#define IDualComponent_putref_Groups(This,colGroup)	\
    (This)->lpVtbl -> putref_Groups(This,colGroup)

#define IDualComponent_get_ExactMatch(This,retval)	\
    (This)->lpVtbl -> get_ExactMatch(This,retval)

#define IDualComponent_put_ExactMatch(This,bMatch)	\
    (This)->lpVtbl -> put_ExactMatch(This,bMatch)

#define IDualComponent_get_Languages(This,retval)	\
    (This)->lpVtbl -> get_Languages(This,retval)

#define IDualComponent_Read(This,varReadParm,varReadMask,retval)	\
    (This)->lpVtbl -> Read(This,varReadParm,varReadMask,retval)

#define IDualComponent_Write(This,varWriteParm,varWriteMask,retval)	\
    (This)->lpVtbl -> Write(This,varWriteParm,varWriteMask,retval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualComponent_put__id_Proxy( 
    IDualComponent __RPC_FAR * This,
    /* [in] */ long CompId);


void __RPC_STUB IDualComponent_put__id_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualComponent_get__id_Proxy( 
    IDualComponent __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualComponent_get__id_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualComponent_put_id_Proxy( 
    IDualComponent __RPC_FAR * This,
    /* [in] */ long CompId);


void __RPC_STUB IDualComponent_put_id_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualComponent_get_id_Proxy( 
    IDualComponent __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualComponent_get_id_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualComponent_put_Name_Proxy( 
    IDualComponent __RPC_FAR * This,
    /* [in] */ BSTR CompName);


void __RPC_STUB IDualComponent_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualComponent_get_Name_Proxy( 
    IDualComponent __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *retval);


void __RPC_STUB IDualComponent_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualComponent_put_Pragma_Proxy( 
    IDualComponent __RPC_FAR * This,
    /* [in] */ BSTR Pragma);


void __RPC_STUB IDualComponent_put_Pragma_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualComponent_get_Pragma_Proxy( 
    IDualComponent __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *retval);


void __RPC_STUB IDualComponent_get_Pragma_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualComponent_put_Description_Proxy( 
    IDualComponent __RPC_FAR * This,
    /* [in] */ BSTR Description);


void __RPC_STUB IDualComponent_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualComponent_get_Description_Proxy( 
    IDualComponent __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *retval);


void __RPC_STUB IDualComponent_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualComponent_get_Path_Proxy( 
    IDualComponent __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *Path);


void __RPC_STUB IDualComponent_get_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualComponent_get_Groups_Proxy( 
    IDualComponent __RPC_FAR * This,
    /* [retval][out] */ IDualColGroups __RPC_FAR *__RPC_FAR *retval);


void __RPC_STUB IDualComponent_get_Groups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IDualComponent_putref_Groups_Proxy( 
    IDualComponent __RPC_FAR * This,
    /* [in] */ IDualColGroups __RPC_FAR *colGroup);


void __RPC_STUB IDualComponent_putref_Groups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualComponent_get_ExactMatch_Proxy( 
    IDualComponent __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB IDualComponent_get_ExactMatch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualComponent_put_ExactMatch_Proxy( 
    IDualComponent __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bMatch);


void __RPC_STUB IDualComponent_put_ExactMatch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualComponent_get_Languages_Proxy( 
    IDualComponent __RPC_FAR * This,
    /* [retval][out] */ IDualColLanguages __RPC_FAR *__RPC_FAR *retval);


void __RPC_STUB IDualComponent_get_Languages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualComponent_Read_Proxy( 
    IDualComponent __RPC_FAR * This,
    /* [in] */ VARIANT varReadParm,
    /* [optional][in] */ VARIANT varReadMask,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB IDualComponent_Read_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualComponent_Write_Proxy( 
    IDualComponent __RPC_FAR * This,
    /* [in] */ VARIANT varWriteParm,
    /* [optional][in] */ VARIANT varWriteMask,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB IDualComponent_Write_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDualComponent_INTERFACE_DEFINED__ */


#ifdef __cplusplus
DEFINE_GUID(CLSID_DMIComponent,0x445360E1,0xDF26,0x11CF,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

class DECLSPEC_UUID("445360E1-DF26-11CF-8844-00AA006B21BF")
DMIComponent;
#endif

#ifndef __IColComponents_DISPINTERFACE_DEFINED__
#define __IColComponents_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: IColComponents
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [hidden][uuid] */ 



DEFINE_GUID(DIID_IColComponents,0x445360E2,0xDF26,0x11CF,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("445360E2-DF26-11CF-8844-00AA006B21BF")
    IColComponents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct IColComponentsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IColComponents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IColComponents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IColComponents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IColComponents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IColComponents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IColComponents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IColComponents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } IColComponentsVtbl;

    interface IColComponents
    {
        CONST_VTBL struct IColComponentsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IColComponents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IColComponents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IColComponents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IColComponents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IColComponents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IColComponents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IColComponents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __IColComponents_DISPINTERFACE_DEFINED__ */


#ifndef __IDualColComponents_INTERFACE_DEFINED__
#define __IDualColComponents_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDualColComponents
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][dual][oleautomation][hidden][uuid] */ 



DEFINE_GUID(IID_IDualColComponents,0xB9C1FDE3,0xE152,0x11cf,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("B9C1FDE3-E152-11cf-8844-00AA006B21BF")
    IDualColComponents : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ VARIANT AddItem,
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT RemoveItem,
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveAll( void) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT varComp,
            /* [retval][out] */ IDualComponent __RPC_FAR *__RPC_FAR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__Item( 
            /* [in] */ VARIANT varComp,
            /* [retval][out] */ IDualComponent __RPC_FAR *__RPC_FAR *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDualColComponentsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDualColComponents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDualColComponents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDualColComponents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDualColComponents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDualColComponents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDualColComponents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDualColComponents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IDualColComponents __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IDualColComponents __RPC_FAR * This,
            /* [in] */ VARIANT AddItem,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Remove )( 
            IDualColComponents __RPC_FAR * This,
            /* [in] */ VARIANT RemoveItem,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveAll )( 
            IDualColComponents __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IDualColComponents __RPC_FAR * This,
            /* [in] */ VARIANT varComp,
            /* [retval][out] */ IDualComponent __RPC_FAR *__RPC_FAR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IDualColComponents __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__Item )( 
            IDualColComponents __RPC_FAR * This,
            /* [in] */ VARIANT varComp,
            /* [retval][out] */ IDualComponent __RPC_FAR *__RPC_FAR *retval);
        
        END_INTERFACE
    } IDualColComponentsVtbl;

    interface IDualColComponents
    {
        CONST_VTBL struct IDualColComponentsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDualColComponents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDualColComponents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDualColComponents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDualColComponents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDualColComponents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDualColComponents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDualColComponents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDualColComponents_get_Count(This,retval)	\
    (This)->lpVtbl -> get_Count(This,retval)

#define IDualColComponents_Add(This,AddItem,retval)	\
    (This)->lpVtbl -> Add(This,AddItem,retval)

#define IDualColComponents_Remove(This,RemoveItem,retval)	\
    (This)->lpVtbl -> Remove(This,RemoveItem,retval)

#define IDualColComponents_RemoveAll(This)	\
    (This)->lpVtbl -> RemoveAll(This)

#define IDualColComponents_get_Item(This,varComp,retval)	\
    (This)->lpVtbl -> get_Item(This,varComp,retval)

#define IDualColComponents_get__NewEnum(This,retval)	\
    (This)->lpVtbl -> get__NewEnum(This,retval)

#define IDualColComponents_get__Item(This,varComp,retval)	\
    (This)->lpVtbl -> get__Item(This,varComp,retval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualColComponents_get_Count_Proxy( 
    IDualColComponents __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualColComponents_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualColComponents_Add_Proxy( 
    IDualColComponents __RPC_FAR * This,
    /* [in] */ VARIANT AddItem,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualColComponents_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualColComponents_Remove_Proxy( 
    IDualColComponents __RPC_FAR * This,
    /* [in] */ VARIANT RemoveItem,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualColComponents_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualColComponents_RemoveAll_Proxy( 
    IDualColComponents __RPC_FAR * This);


void __RPC_STUB IDualColComponents_RemoveAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualColComponents_get_Item_Proxy( 
    IDualColComponents __RPC_FAR * This,
    /* [in] */ VARIANT varComp,
    /* [retval][out] */ IDualComponent __RPC_FAR *__RPC_FAR *retval);


void __RPC_STUB IDualColComponents_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDualColComponents_get__NewEnum_Proxy( 
    IDualColComponents __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval);


void __RPC_STUB IDualColComponents_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualColComponents_get__Item_Proxy( 
    IDualColComponents __RPC_FAR * This,
    /* [in] */ VARIANT varComp,
    /* [retval][out] */ IDualComponent __RPC_FAR *__RPC_FAR *retval);


void __RPC_STUB IDualColComponents_get__Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDualColComponents_INTERFACE_DEFINED__ */


#ifdef __cplusplus
DEFINE_GUID(CLSID_DMIComponents,0x445360E3,0xDF26,0x11CF,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

class DECLSPEC_UUID("445360E3-DF26-11CF-8844-00AA006B21BF")
DMIComponents;
#endif

#ifndef __IMgmtNode_DISPINTERFACE_DEFINED__
#define __IMgmtNode_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: IMgmtNode
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [hidden][uuid] */ 



DEFINE_GUID(DIID_IMgmtNode,0x165125A0,0xDFC2,0x11CF,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("165125A0-DFC2-11CF-8844-00AA006B21BF")
    IMgmtNode : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct IMgmtNodeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMgmtNode __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMgmtNode __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMgmtNode __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMgmtNode __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMgmtNode __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMgmtNode __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMgmtNode __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } IMgmtNodeVtbl;

    interface IMgmtNode
    {
        CONST_VTBL struct IMgmtNodeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMgmtNode_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMgmtNode_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMgmtNode_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMgmtNode_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMgmtNode_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMgmtNode_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMgmtNode_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __IMgmtNode_DISPINTERFACE_DEFINED__ */


#ifndef __IDualMgmtNode_INTERFACE_DEFINED__
#define __IDualMgmtNode_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDualMgmtNode
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][dual][oleautomation][hidden][uuid] */ 



DEFINE_GUID(IID_IDualMgmtNode,0xDDAE04C0,0xE3C7,0x11cf,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("DDAE04C0-E3C7-11cf-8844-00AA006B21BF")
    IDualMgmtNode : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RPC( 
            /* [retval][out] */ BSTR __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RPC( 
            /* [in] */ BSTR szRpc) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Transport( 
            /* [retval][out] */ BSTR __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Transport( 
            /* [in] */ BSTR szTransport) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NetWorkAddress( 
            /* [retval][out] */ BSTR __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_NetWorkAddress( 
            /* [in] */ BSTR szNetWorkAddress) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ BSTR __RPC_FAR *szPath) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__Path( 
            /* [retval][out] */ BSTR __RPC_FAR *szPath) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Components( 
            /* [retval][out] */ IDualColComponents __RPC_FAR *__RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_Components( 
            /* [in] */ IDualColComponents __RPC_FAR *lpComponents) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventFilter( 
            /* [retval][out] */ IDualEventFilter __RPC_FAR *__RPC_FAR *pdispFilterObject) = 0;
        
        virtual /* [helpcontext][helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_EventFilter( 
            /* [in] */ IDualEventFilter __RPC_FAR *pdispFilterObject) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDescription) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Version( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrVersion) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsConnected( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *bRetVal) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Language( 
            /* [retval][out] */ BSTR __RPC_FAR *bstrLang) = 0;
        
        virtual /* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Language( 
            /* [in] */ BSTR bstrLang) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Disconnect( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Read( 
            /* [in] */ VARIANT varReadParm,
            /* [optional][in] */ VARIANT varReadMask,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Write( 
            /* [in] */ VARIANT varWriteParm,
            /* [optional][in] */ VARIANT varWriteMask,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ BSTR __RPC_FAR *bstrPath,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetComponentByClassString( 
            /* [in] */ BSTR __RPC_FAR *bstrClassString,
            /* [retval][out] */ IDualColComponents __RPC_FAR *__RPC_FAR *lpdualComponents) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDualMgmtNodeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDualMgmtNode __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDualMgmtNode __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDualMgmtNode __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDualMgmtNode __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDualMgmtNode __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDualMgmtNode __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDualMgmtNode __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RPC )( 
            IDualMgmtNode __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_RPC )( 
            IDualMgmtNode __RPC_FAR * This,
            /* [in] */ BSTR szRpc);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Transport )( 
            IDualMgmtNode __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Transport )( 
            IDualMgmtNode __RPC_FAR * This,
            /* [in] */ BSTR szTransport);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NetWorkAddress )( 
            IDualMgmtNode __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_NetWorkAddress )( 
            IDualMgmtNode __RPC_FAR * This,
            /* [in] */ BSTR szNetWorkAddress);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Path )( 
            IDualMgmtNode __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *szPath);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__Path )( 
            IDualMgmtNode __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *szPath);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Components )( 
            IDualMgmtNode __RPC_FAR * This,
            /* [retval][out] */ IDualColComponents __RPC_FAR *__RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Components )( 
            IDualMgmtNode __RPC_FAR * This,
            /* [in] */ IDualColComponents __RPC_FAR *lpComponents);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EventFilter )( 
            IDualMgmtNode __RPC_FAR * This,
            /* [retval][out] */ IDualEventFilter __RPC_FAR *__RPC_FAR *pdispFilterObject);
        
        /* [helpcontext][helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_EventFilter )( 
            IDualMgmtNode __RPC_FAR * This,
            /* [in] */ IDualEventFilter __RPC_FAR *pdispFilterObject);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Description )( 
            IDualMgmtNode __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDescription);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Version )( 
            IDualMgmtNode __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrVersion);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsConnected )( 
            IDualMgmtNode __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *bRetVal);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Language )( 
            IDualMgmtNode __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *bstrLang);
        
        /* [helpcontext][helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Language )( 
            IDualMgmtNode __RPC_FAR * This,
            /* [in] */ BSTR bstrLang);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Disconnect )( 
            IDualMgmtNode __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Read )( 
            IDualMgmtNode __RPC_FAR * This,
            /* [in] */ VARIANT varReadParm,
            /* [optional][in] */ VARIANT varReadMask,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Write )( 
            IDualMgmtNode __RPC_FAR * This,
            /* [in] */ VARIANT varWriteParm,
            /* [optional][in] */ VARIANT varWriteMask,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            IDualMgmtNode __RPC_FAR * This,
            /* [in] */ BSTR __RPC_FAR *bstrPath,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetComponentByClassString )( 
            IDualMgmtNode __RPC_FAR * This,
            /* [in] */ BSTR __RPC_FAR *bstrClassString,
            /* [retval][out] */ IDualColComponents __RPC_FAR *__RPC_FAR *lpdualComponents);
        
        END_INTERFACE
    } IDualMgmtNodeVtbl;

    interface IDualMgmtNode
    {
        CONST_VTBL struct IDualMgmtNodeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDualMgmtNode_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDualMgmtNode_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDualMgmtNode_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDualMgmtNode_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDualMgmtNode_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDualMgmtNode_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDualMgmtNode_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDualMgmtNode_get_RPC(This,retval)	\
    (This)->lpVtbl -> get_RPC(This,retval)

#define IDualMgmtNode_put_RPC(This,szRpc)	\
    (This)->lpVtbl -> put_RPC(This,szRpc)

#define IDualMgmtNode_get_Transport(This,retval)	\
    (This)->lpVtbl -> get_Transport(This,retval)

#define IDualMgmtNode_put_Transport(This,szTransport)	\
    (This)->lpVtbl -> put_Transport(This,szTransport)

#define IDualMgmtNode_get_NetWorkAddress(This,retval)	\
    (This)->lpVtbl -> get_NetWorkAddress(This,retval)

#define IDualMgmtNode_put_NetWorkAddress(This,szNetWorkAddress)	\
    (This)->lpVtbl -> put_NetWorkAddress(This,szNetWorkAddress)

#define IDualMgmtNode_get_Path(This,szPath)	\
    (This)->lpVtbl -> get_Path(This,szPath)

#define IDualMgmtNode_get__Path(This,szPath)	\
    (This)->lpVtbl -> get__Path(This,szPath)

#define IDualMgmtNode_get_Components(This,retval)	\
    (This)->lpVtbl -> get_Components(This,retval)

#define IDualMgmtNode_putref_Components(This,lpComponents)	\
    (This)->lpVtbl -> putref_Components(This,lpComponents)

#define IDualMgmtNode_get_EventFilter(This,pdispFilterObject)	\
    (This)->lpVtbl -> get_EventFilter(This,pdispFilterObject)

#define IDualMgmtNode_putref_EventFilter(This,pdispFilterObject)	\
    (This)->lpVtbl -> putref_EventFilter(This,pdispFilterObject)

#define IDualMgmtNode_get_Description(This,pbstrDescription)	\
    (This)->lpVtbl -> get_Description(This,pbstrDescription)

#define IDualMgmtNode_get_Version(This,pbstrVersion)	\
    (This)->lpVtbl -> get_Version(This,pbstrVersion)

#define IDualMgmtNode_get_IsConnected(This,bRetVal)	\
    (This)->lpVtbl -> get_IsConnected(This,bRetVal)

#define IDualMgmtNode_get_Language(This,bstrLang)	\
    (This)->lpVtbl -> get_Language(This,bstrLang)

#define IDualMgmtNode_put_Language(This,bstrLang)	\
    (This)->lpVtbl -> put_Language(This,bstrLang)

#define IDualMgmtNode_Disconnect(This,retval)	\
    (This)->lpVtbl -> Disconnect(This,retval)

#define IDualMgmtNode_Read(This,varReadParm,varReadMask,retval)	\
    (This)->lpVtbl -> Read(This,varReadParm,varReadMask,retval)

#define IDualMgmtNode_Write(This,varWriteParm,varWriteMask,retval)	\
    (This)->lpVtbl -> Write(This,varWriteParm,varWriteMask,retval)

#define IDualMgmtNode_Connect(This,bstrPath,retval)	\
    (This)->lpVtbl -> Connect(This,bstrPath,retval)

#define IDualMgmtNode_GetComponentByClassString(This,bstrClassString,lpdualComponents)	\
    (This)->lpVtbl -> GetComponentByClassString(This,bstrClassString,lpdualComponents)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualMgmtNode_get_RPC_Proxy( 
    IDualMgmtNode __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *retval);


void __RPC_STUB IDualMgmtNode_get_RPC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualMgmtNode_put_RPC_Proxy( 
    IDualMgmtNode __RPC_FAR * This,
    /* [in] */ BSTR szRpc);


void __RPC_STUB IDualMgmtNode_put_RPC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualMgmtNode_get_Transport_Proxy( 
    IDualMgmtNode __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *retval);


void __RPC_STUB IDualMgmtNode_get_Transport_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualMgmtNode_put_Transport_Proxy( 
    IDualMgmtNode __RPC_FAR * This,
    /* [in] */ BSTR szTransport);


void __RPC_STUB IDualMgmtNode_put_Transport_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualMgmtNode_get_NetWorkAddress_Proxy( 
    IDualMgmtNode __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *retval);


void __RPC_STUB IDualMgmtNode_get_NetWorkAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualMgmtNode_put_NetWorkAddress_Proxy( 
    IDualMgmtNode __RPC_FAR * This,
    /* [in] */ BSTR szNetWorkAddress);


void __RPC_STUB IDualMgmtNode_put_NetWorkAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualMgmtNode_get_Path_Proxy( 
    IDualMgmtNode __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *szPath);


void __RPC_STUB IDualMgmtNode_get_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualMgmtNode_get__Path_Proxy( 
    IDualMgmtNode __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *szPath);


void __RPC_STUB IDualMgmtNode_get__Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualMgmtNode_get_Components_Proxy( 
    IDualMgmtNode __RPC_FAR * This,
    /* [retval][out] */ IDualColComponents __RPC_FAR *__RPC_FAR *retval);


void __RPC_STUB IDualMgmtNode_get_Components_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IDualMgmtNode_putref_Components_Proxy( 
    IDualMgmtNode __RPC_FAR * This,
    /* [in] */ IDualColComponents __RPC_FAR *lpComponents);


void __RPC_STUB IDualMgmtNode_putref_Components_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualMgmtNode_get_EventFilter_Proxy( 
    IDualMgmtNode __RPC_FAR * This,
    /* [retval][out] */ IDualEventFilter __RPC_FAR *__RPC_FAR *pdispFilterObject);


void __RPC_STUB IDualMgmtNode_get_EventFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IDualMgmtNode_putref_EventFilter_Proxy( 
    IDualMgmtNode __RPC_FAR * This,
    /* [in] */ IDualEventFilter __RPC_FAR *pdispFilterObject);


void __RPC_STUB IDualMgmtNode_putref_EventFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualMgmtNode_get_Description_Proxy( 
    IDualMgmtNode __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrDescription);


void __RPC_STUB IDualMgmtNode_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualMgmtNode_get_Version_Proxy( 
    IDualMgmtNode __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrVersion);


void __RPC_STUB IDualMgmtNode_get_Version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualMgmtNode_get_IsConnected_Proxy( 
    IDualMgmtNode __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *bRetVal);


void __RPC_STUB IDualMgmtNode_get_IsConnected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualMgmtNode_get_Language_Proxy( 
    IDualMgmtNode __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *bstrLang);


void __RPC_STUB IDualMgmtNode_get_Language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDualMgmtNode_put_Language_Proxy( 
    IDualMgmtNode __RPC_FAR * This,
    /* [in] */ BSTR bstrLang);


void __RPC_STUB IDualMgmtNode_put_Language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualMgmtNode_Disconnect_Proxy( 
    IDualMgmtNode __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB IDualMgmtNode_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualMgmtNode_Read_Proxy( 
    IDualMgmtNode __RPC_FAR * This,
    /* [in] */ VARIANT varReadParm,
    /* [optional][in] */ VARIANT varReadMask,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB IDualMgmtNode_Read_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualMgmtNode_Write_Proxy( 
    IDualMgmtNode __RPC_FAR * This,
    /* [in] */ VARIANT varWriteParm,
    /* [optional][in] */ VARIANT varWriteMask,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB IDualMgmtNode_Write_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualMgmtNode_Connect_Proxy( 
    IDualMgmtNode __RPC_FAR * This,
    /* [in] */ BSTR __RPC_FAR *bstrPath,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB IDualMgmtNode_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualMgmtNode_GetComponentByClassString_Proxy( 
    IDualMgmtNode __RPC_FAR * This,
    /* [in] */ BSTR __RPC_FAR *bstrClassString,
    /* [retval][out] */ IDualColComponents __RPC_FAR *__RPC_FAR *lpdualComponents);


void __RPC_STUB IDualMgmtNode_GetComponentByClassString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDualMgmtNode_INTERFACE_DEFINED__ */


#ifdef __cplusplus
DEFINE_GUID(CLSID_DMIMgmtNode,0x165125A1,0xDFC2,0x11CF,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

class DECLSPEC_UUID("165125A1-DFC2-11CF-8844-00AA006B21BF")
DMIMgmtNode;
#endif

#ifndef __IColMgmtNodes_DISPINTERFACE_DEFINED__
#define __IColMgmtNodes_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: IColMgmtNodes
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [hidden][uuid] */ 



DEFINE_GUID(DIID_IColMgmtNodes,0xF1DC8AE0,0x36FE,0x11D0,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("F1DC8AE0-36FE-11D0-8844-00AA006B21BF")
    IColMgmtNodes : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct IColMgmtNodesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IColMgmtNodes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IColMgmtNodes __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IColMgmtNodes __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IColMgmtNodes __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IColMgmtNodes __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IColMgmtNodes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IColMgmtNodes __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } IColMgmtNodesVtbl;

    interface IColMgmtNodes
    {
        CONST_VTBL struct IColMgmtNodesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IColMgmtNodes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IColMgmtNodes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IColMgmtNodes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IColMgmtNodes_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IColMgmtNodes_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IColMgmtNodes_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IColMgmtNodes_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __IColMgmtNodes_DISPINTERFACE_DEFINED__ */


#ifndef __IDualColMgmtNodes_INTERFACE_DEFINED__
#define __IDualColMgmtNodes_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDualColMgmtNodes
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][dual][oleautomation][hidden][uuid] */ 



DEFINE_GUID(IID_IDualColMgmtNodes,0x2C7E6961,0x3714,0x11d0,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("2C7E6961-3714-11d0-8844-00AA006B21BF")
    IDualColMgmtNodes : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ IDualMgmtNode __RPC_FAR *pdNode,
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ BSTR bsPath,
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveAll( void) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__Item( 
            /* [in] */ BSTR bsPath,
            /* [retval][out] */ IDualMgmtNode __RPC_FAR *__RPC_FAR *ppdMNode) = 0;
        
        virtual /* [helpcontext][helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref__Item( 
            /* [in] */ BSTR bsPath,
            /* [in] */ IDualMgmtNode __RPC_FAR *pdMNode) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ BSTR bsPath,
            /* [retval][out] */ IDualMgmtNode __RPC_FAR *__RPC_FAR *ppdMNode) = 0;
        
        virtual /* [helpcontext][helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_Item( 
            /* [in] */ BSTR bsPath,
            /* [in] */ IDualMgmtNode __RPC_FAR *pdMNode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDualColMgmtNodesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDualColMgmtNodes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDualColMgmtNodes __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDualColMgmtNodes __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDualColMgmtNodes __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDualColMgmtNodes __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDualColMgmtNodes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDualColMgmtNodes __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IDualColMgmtNodes __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IDualColMgmtNodes __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IDualColMgmtNodes __RPC_FAR * This,
            /* [in] */ IDualMgmtNode __RPC_FAR *pdNode,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Remove )( 
            IDualColMgmtNodes __RPC_FAR * This,
            /* [in] */ BSTR bsPath,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveAll )( 
            IDualColMgmtNodes __RPC_FAR * This);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__Item )( 
            IDualColMgmtNodes __RPC_FAR * This,
            /* [in] */ BSTR bsPath,
            /* [retval][out] */ IDualMgmtNode __RPC_FAR *__RPC_FAR *ppdMNode);
        
        /* [helpcontext][helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref__Item )( 
            IDualColMgmtNodes __RPC_FAR * This,
            /* [in] */ BSTR bsPath,
            /* [in] */ IDualMgmtNode __RPC_FAR *pdMNode);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IDualColMgmtNodes __RPC_FAR * This,
            /* [in] */ BSTR bsPath,
            /* [retval][out] */ IDualMgmtNode __RPC_FAR *__RPC_FAR *ppdMNode);
        
        /* [helpcontext][helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Item )( 
            IDualColMgmtNodes __RPC_FAR * This,
            /* [in] */ BSTR bsPath,
            /* [in] */ IDualMgmtNode __RPC_FAR *pdMNode);
        
        END_INTERFACE
    } IDualColMgmtNodesVtbl;

    interface IDualColMgmtNodes
    {
        CONST_VTBL struct IDualColMgmtNodesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDualColMgmtNodes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDualColMgmtNodes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDualColMgmtNodes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDualColMgmtNodes_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDualColMgmtNodes_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDualColMgmtNodes_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDualColMgmtNodes_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDualColMgmtNodes_get_Count(This,retval)	\
    (This)->lpVtbl -> get_Count(This,retval)

#define IDualColMgmtNodes_get__NewEnum(This,retval)	\
    (This)->lpVtbl -> get__NewEnum(This,retval)

#define IDualColMgmtNodes_Add(This,pdNode,retval)	\
    (This)->lpVtbl -> Add(This,pdNode,retval)

#define IDualColMgmtNodes_Remove(This,bsPath,retval)	\
    (This)->lpVtbl -> Remove(This,bsPath,retval)

#define IDualColMgmtNodes_RemoveAll(This)	\
    (This)->lpVtbl -> RemoveAll(This)

#define IDualColMgmtNodes_get__Item(This,bsPath,ppdMNode)	\
    (This)->lpVtbl -> get__Item(This,bsPath,ppdMNode)

#define IDualColMgmtNodes_putref__Item(This,bsPath,pdMNode)	\
    (This)->lpVtbl -> putref__Item(This,bsPath,pdMNode)

#define IDualColMgmtNodes_get_Item(This,bsPath,ppdMNode)	\
    (This)->lpVtbl -> get_Item(This,bsPath,ppdMNode)

#define IDualColMgmtNodes_putref_Item(This,bsPath,pdMNode)	\
    (This)->lpVtbl -> putref_Item(This,bsPath,pdMNode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualColMgmtNodes_get_Count_Proxy( 
    IDualColMgmtNodes __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualColMgmtNodes_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDualColMgmtNodes_get__NewEnum_Proxy( 
    IDualColMgmtNodes __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval);


void __RPC_STUB IDualColMgmtNodes_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualColMgmtNodes_Add_Proxy( 
    IDualColMgmtNodes __RPC_FAR * This,
    /* [in] */ IDualMgmtNode __RPC_FAR *pdNode,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualColMgmtNodes_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualColMgmtNodes_Remove_Proxy( 
    IDualColMgmtNodes __RPC_FAR * This,
    /* [in] */ BSTR bsPath,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB IDualColMgmtNodes_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE IDualColMgmtNodes_RemoveAll_Proxy( 
    IDualColMgmtNodes __RPC_FAR * This);


void __RPC_STUB IDualColMgmtNodes_RemoveAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualColMgmtNodes_get__Item_Proxy( 
    IDualColMgmtNodes __RPC_FAR * This,
    /* [in] */ BSTR bsPath,
    /* [retval][out] */ IDualMgmtNode __RPC_FAR *__RPC_FAR *ppdMNode);


void __RPC_STUB IDualColMgmtNodes_get__Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IDualColMgmtNodes_putref__Item_Proxy( 
    IDualColMgmtNodes __RPC_FAR * This,
    /* [in] */ BSTR bsPath,
    /* [in] */ IDualMgmtNode __RPC_FAR *pdMNode);


void __RPC_STUB IDualColMgmtNodes_putref__Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDualColMgmtNodes_get_Item_Proxy( 
    IDualColMgmtNodes __RPC_FAR * This,
    /* [in] */ BSTR bsPath,
    /* [retval][out] */ IDualMgmtNode __RPC_FAR *__RPC_FAR *ppdMNode);


void __RPC_STUB IDualColMgmtNodes_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IDualColMgmtNodes_putref_Item_Proxy( 
    IDualColMgmtNodes __RPC_FAR * This,
    /* [in] */ BSTR bsPath,
    /* [in] */ IDualMgmtNode __RPC_FAR *pdMNode);


void __RPC_STUB IDualColMgmtNodes_putref_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDualColMgmtNodes_INTERFACE_DEFINED__ */


#ifdef __cplusplus
DEFINE_GUID(CLSID_DMIMgmtNodes,0xF1DC8AE1,0x36FE,0x11D0,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

class DECLSPEC_UUID("F1DC8AE1-36FE-11D0-8844-00AA006B21BF")
DMIMgmtNodes;
#endif

#ifndef __INotification_DISPINTERFACE_DEFINED__
#define __INotification_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: INotification
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [hidden][uuid] */ 



DEFINE_GUID(DIID_INotification,0x5847E2F7,0xA2E4,0x11D0,0xB8,0x4F,0x00,0xA0,0xC9,0x24,0x79,0xE2);

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("5847E2F7-A2E4-11D0-B84F-00A0C92479E2")
    INotification : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct INotificationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INotification __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INotification __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INotification __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            INotification __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            INotification __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            INotification __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            INotification __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } INotificationVtbl;

    interface INotification
    {
        CONST_VTBL struct INotificationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INotification_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INotification_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INotification_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INotification_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define INotification_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define INotification_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define INotification_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __INotification_DISPINTERFACE_DEFINED__ */


#ifdef __cplusplus
DEFINE_GUID(CLSID_DMINotification,0x5847E2F8,0xA2E4,0x11D0,0xB8,0x4F,0x00,0xA0,0xC9,0x24,0x79,0xE2);

class DECLSPEC_UUID("5847E2F8-A2E4-11D0-B84F-00A0C92479E2")
DMINotification;
#endif

#ifndef __IEvent_DISPINTERFACE_DEFINED__
#define __IEvent_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: IEvent
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [hidden][uuid] */ 



DEFINE_GUID(DIID_IEvent,0x20A41620,0x33EB,0x11D0,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("20A41620-33EB-11D0-8844-00AA006B21BF")
    IEvent : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct IEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEvent __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEvent __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IEvent __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IEvent __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IEvent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IEvent __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } IEventVtbl;

    interface IEvent
    {
        CONST_VTBL struct IEventVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __IEvent_DISPINTERFACE_DEFINED__ */


#ifdef __cplusplus
DEFINE_GUID(CLSID_DMIEvent,0x20A41621,0x33EB,0x11D0,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

class DECLSPEC_UUID("20A41621-33EB-11D0-8844-00AA006B21BF")
DMIEvent;
#endif

#ifndef ___DDualint_DISPINTERFACE_DEFINED__
#define ___DDualint_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: _DDualint
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [hidden][helpstring][uuid] */ 



DEFINE_GUID(DIID__DDualint,0xF45FB441,0xC9DA,0x11CF,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("F45FB441-C9DA-11CF-8844-00AA006B21BF")
    _DDualint : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _DDualintVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _DDualint __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _DDualint __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _DDualint __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _DDualint __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _DDualint __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _DDualint __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _DDualint __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } _DDualintVtbl;

    interface _DDualint
    {
        CONST_VTBL struct _DDualintVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _DDualint_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _DDualint_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _DDualint_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _DDualint_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _DDualint_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _DDualint_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _DDualint_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___DDualint_DISPINTERFACE_DEFINED__ */


#ifndef ___DualDMIEngine_INTERFACE_DEFINED__
#define ___DualDMIEngine_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: _DualDMIEngine
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID__DualDMIEngine,0x45D155A0,0x3CAD,0x11d0,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("45D155A0-3CAD-11d0-8844-00AA006B21BF")
    _DualDMIEngine : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Version( 
            /* [retval][out] */ BSTR __RPC_FAR *bstrVersion) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventMgmtNodes( 
            /* [retval][out] */ IDualMgmtNode __RPC_FAR *__RPC_FAR *ppdMgmtNode) = 0;
        
        virtual /* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NotificationMgmtNodes( 
            /* [retval][out] */ IDualMgmtNode __RPC_FAR *__RPC_FAR *ppdMgmtNode) = 0;
        
        virtual /* [helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE get__Version( 
            /* [retval][out] */ BSTR __RPC_FAR *bstrVersion) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE EnableEvents( 
            /* [in] */ IDualMgmtNode __RPC_FAR *pdMgmtNode,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *bRetval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE DisableEvents( 
            /* [in] */ VARIANT varMgmtNode,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *bRetval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE EnableNotifications( 
            /* [in] */ IDualMgmtNode __RPC_FAR *lpdMgmtNode,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE DisableNotifications( 
            /* [in] */ VARIANT varMgmtNode,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct _DualDMIEngineVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _DualDMIEngine __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _DualDMIEngine __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _DualDMIEngine __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _DualDMIEngine __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _DualDMIEngine __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _DualDMIEngine __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _DualDMIEngine __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Version )( 
            _DualDMIEngine __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *bstrVersion);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EventMgmtNodes )( 
            _DualDMIEngine __RPC_FAR * This,
            /* [retval][out] */ IDualMgmtNode __RPC_FAR *__RPC_FAR *ppdMgmtNode);
        
        /* [helpcontext][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NotificationMgmtNodes )( 
            _DualDMIEngine __RPC_FAR * This,
            /* [retval][out] */ IDualMgmtNode __RPC_FAR *__RPC_FAR *ppdMgmtNode);
        
        /* [helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__Version )( 
            _DualDMIEngine __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *bstrVersion);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnableEvents )( 
            _DualDMIEngine __RPC_FAR * This,
            /* [in] */ IDualMgmtNode __RPC_FAR *pdMgmtNode,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *bRetval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisableEvents )( 
            _DualDMIEngine __RPC_FAR * This,
            /* [in] */ VARIANT varMgmtNode,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *bRetval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnableNotifications )( 
            _DualDMIEngine __RPC_FAR * This,
            /* [in] */ IDualMgmtNode __RPC_FAR *lpdMgmtNode,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisableNotifications )( 
            _DualDMIEngine __RPC_FAR * This,
            /* [in] */ VARIANT varMgmtNode,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        END_INTERFACE
    } _DualDMIEngineVtbl;

    interface _DualDMIEngine
    {
        CONST_VTBL struct _DualDMIEngineVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _DualDMIEngine_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _DualDMIEngine_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _DualDMIEngine_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _DualDMIEngine_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _DualDMIEngine_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _DualDMIEngine_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _DualDMIEngine_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define _DualDMIEngine_get_Version(This,bstrVersion)	\
    (This)->lpVtbl -> get_Version(This,bstrVersion)

#define _DualDMIEngine_get_EventMgmtNodes(This,ppdMgmtNode)	\
    (This)->lpVtbl -> get_EventMgmtNodes(This,ppdMgmtNode)

#define _DualDMIEngine_get_NotificationMgmtNodes(This,ppdMgmtNode)	\
    (This)->lpVtbl -> get_NotificationMgmtNodes(This,ppdMgmtNode)

#define _DualDMIEngine_get__Version(This,bstrVersion)	\
    (This)->lpVtbl -> get__Version(This,bstrVersion)

#define _DualDMIEngine_EnableEvents(This,pdMgmtNode,bRetval)	\
    (This)->lpVtbl -> EnableEvents(This,pdMgmtNode,bRetval)

#define _DualDMIEngine_DisableEvents(This,varMgmtNode,bRetval)	\
    (This)->lpVtbl -> DisableEvents(This,varMgmtNode,bRetval)

#define _DualDMIEngine_EnableNotifications(This,lpdMgmtNode,retval)	\
    (This)->lpVtbl -> EnableNotifications(This,lpdMgmtNode,retval)

#define _DualDMIEngine_DisableNotifications(This,varMgmtNode,retval)	\
    (This)->lpVtbl -> DisableNotifications(This,varMgmtNode,retval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE _DualDMIEngine_get_Version_Proxy( 
    _DualDMIEngine __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *bstrVersion);


void __RPC_STUB _DualDMIEngine_get_Version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE _DualDMIEngine_get_EventMgmtNodes_Proxy( 
    _DualDMIEngine __RPC_FAR * This,
    /* [retval][out] */ IDualMgmtNode __RPC_FAR *__RPC_FAR *ppdMgmtNode);


void __RPC_STUB _DualDMIEngine_get_EventMgmtNodes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE _DualDMIEngine_get_NotificationMgmtNodes_Proxy( 
    _DualDMIEngine __RPC_FAR * This,
    /* [retval][out] */ IDualMgmtNode __RPC_FAR *__RPC_FAR *ppdMgmtNode);


void __RPC_STUB _DualDMIEngine_get_NotificationMgmtNodes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE _DualDMIEngine_get__Version_Proxy( 
    _DualDMIEngine __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *bstrVersion);


void __RPC_STUB _DualDMIEngine_get__Version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE _DualDMIEngine_EnableEvents_Proxy( 
    _DualDMIEngine __RPC_FAR * This,
    /* [in] */ IDualMgmtNode __RPC_FAR *pdMgmtNode,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *bRetval);


void __RPC_STUB _DualDMIEngine_EnableEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE _DualDMIEngine_DisableEvents_Proxy( 
    _DualDMIEngine __RPC_FAR * This,
    /* [in] */ VARIANT varMgmtNode,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *bRetval);


void __RPC_STUB _DualDMIEngine_DisableEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE _DualDMIEngine_EnableNotifications_Proxy( 
    _DualDMIEngine __RPC_FAR * This,
    /* [in] */ IDualMgmtNode __RPC_FAR *lpdMgmtNode,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB _DualDMIEngine_EnableNotifications_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE _DualDMIEngine_DisableNotifications_Proxy( 
    _DualDMIEngine __RPC_FAR * This,
    /* [in] */ VARIANT varMgmtNode,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB _DualDMIEngine_DisableNotifications_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* ___DualDMIEngine_INTERFACE_DEFINED__ */


#ifndef ___DDualintEvents_DISPINTERFACE_DEFINED__
#define ___DDualintEvents_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: _DDualintEvents
 * at Mon Dec 01 17:04:01 1997
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][uuid] */ 



DEFINE_GUID(DIID__DDualintEvents,0xF45FB442,0xC9DA,0x11CF,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("F45FB442-C9DA-11CF-8844-00AA006B21BF")
    _DDualintEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _DDualintEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _DDualintEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _DDualintEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _DDualintEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _DDualintEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _DDualintEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _DDualintEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _DDualintEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } _DDualintEventsVtbl;

    interface _DDualintEvents
    {
        CONST_VTBL struct _DDualintEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _DDualintEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _DDualintEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _DDualintEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _DDualintEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _DDualintEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _DDualintEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _DDualintEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___DDualintEvents_DISPINTERFACE_DEFINED__ */


#ifdef __cplusplus
DEFINE_GUID(CLSID_MOTDmiEngine,0xF45FB443,0xC9DA,0x11CF,0x88,0x44,0x00,0xAA,0x00,0x6B,0x21,0xBF);

class DECLSPEC_UUID("F45FB443-C9DA-11CF-8844-00AA006B21BF")
MOTDmiEngine;
#endif
#endif /* __MOTDMIEngine_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\iterator.h ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/


#if !defined(__ITERATOR_H__)
#define __ITERATOR_H__

//TODO get rid of this array
#define UNIQUE_LANGUAGE_ARRAY_SIZE 50

class CIterator
{
	CLanguage**			m_ppNextLanguage;
	CGroup**			m_ppNextGroup;

	CString				m_UniqueLanguageArray[UNIQUE_LANGUAGE_ARRAY_SIZE];

	CComponents			m_Components;

public:
					
						CIterator( CString&  );
						~CIterator()				{;}

	BOOL				NextComponent( );
	BOOL				NextLanguage( );
	BOOL				NextUniqueLanguage( );
	void				NextGroup();
	void				NextRow();
	CGroup*				GetNextNonComponentIDGroup( );		// on current compnent	

	CComponent*			m_pCurrentComponent;
	CGroup*				m_pCurrentGroup;
	CLanguage*			m_pCurrentLanguage;
	CRow*				m_pCurrentRow;

	CCimObject			m_PrototypeClass;				// saved for use in instance spawning instances

	CGroup				m_Group;
	CComponent			m_Component;

};

#endif // __ITERATOR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\eventprovider.h ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/


#if !defined(__EVENTPROVIDER_H__)
#define __EVENTPROVIDER_H__

#include "dmipch.h"		// precompiled header for dmi provider


class CDmiEventSink;

// Provider interfaces are provided by objects of this class 
class CEventProvider : public IWbemEventProvider , public IWbemProviderInit
{
private:
	
protected:
	LONG				m_cRef;         //Object reference count
    

public:
							CEventProvider();
							~CEventProvider(void);

	//Non-delegated IUnknown Methods
    STDMETHODIMP			QueryInterface(REFIID, void**);
    STDMETHODIMP_(ULONG)	AddRef(void);
    STDMETHODIMP_(ULONG)	Release(void);

	STDMETHODIMP ProvideEvents(

	  IWbemObjectSink* pSink,
      LONG lFlags
	);

  	/* IWbemProviderInit methods */

	STDMETHODIMP Initialize (
				LPWSTR pszUser,
				LONG lFlags,
				LPWSTR pszNamespace,
				LPWSTR pszLocale,
				IWbemServices *pCIMOM,         // For anybody
				IWbemContext *pCtx,
				IWbemProviderInitSink *pInitSink     // For init signals
			);


	friend void				EventThread(void *);

	CString					m_csNamespace;
	IWbemObjectSink*		m_pISink;	

	HANDLE					m_hStopThreadEvent;
	HANDLE					m_hInitComplete;
};

	
#endif // __EVENTPROVIDER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\iterator.cpp ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/

#include "dmipch.h"			// precompiled header for dmi provider

#include "wbemdmip.h"

#include "Strings.h"

#include "CimClass.h"

#include "DmiData.h"

#include "Iterator.h"


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CIterator::CIterator( CString& cszNetworkAddr )
{	

	m_Components.Get ( cszNetworkAddr ) ;	

	m_pCurrentComponent = m_Components.m_pFirst;

	m_ppNextLanguage = &m_pCurrentComponent->m_Languages.m_pFirst;

	m_ppNextGroup = &m_pCurrentComponent->m_Groups.m_pFirst;

	m_pCurrentGroup = NULL;

	m_pCurrentLanguage = NULL;

	m_pCurrentRow = NULL;
}



//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
BOOL CIterator::NextComponent( )
{
	if(m_pCurrentComponent)
	{
		m_pCurrentComponent = m_pCurrentComponent->m_pNext;	
	
		if(!m_pCurrentComponent)
			return FALSE;
	
		m_ppNextLanguage = &m_pCurrentComponent->m_Languages.m_pFirst;
		m_ppNextGroup = &m_pCurrentComponent->m_Groups.m_pFirst;
		return TRUE;
	}

	return FALSE;
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CIterator::NextGroup()
{
	BOOL	bHadToFill = FALSE;

	m_pCurrentComponent->m_Groups.Get( m_pCurrentComponent->NWA ( ) ,
		m_pCurrentComponent->Id ( ) );

	m_pCurrentGroup = *m_ppNextGroup;

	if (m_pCurrentGroup)
		m_ppNextGroup = &m_pCurrentGroup->m_pNext;
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CGroup* CIterator::GetNextNonComponentIDGroup( )
{		
	// just pass any nulls returned along to the upper layer

	NextGroup();								
	
	
	if(m_pCurrentGroup)							
	{
		// skip component id group
		if ( COMPONENTID_GROUP == m_pCurrentGroup->Id() )		
			NextGroup();
	}

	return m_pCurrentGroup;
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
BOOL CIterator::NextLanguage( )
{
	m_pCurrentComponent->m_Languages.Get ( m_pCurrentComponent->NWA () ,
		m_pCurrentComponent->Id() );

	while (TRUE)
	{
		m_pCurrentLanguage = *m_ppNextLanguage;

		if( m_pCurrentLanguage )
		{
			m_ppNextLanguage = &m_pCurrentLanguage->m_pNext;
			return TRUE;
		}
		
		if( !NextComponent( ) )
			break;

		m_pCurrentComponent->m_Languages.Get ( m_pCurrentComponent->NWA () ,
		m_pCurrentComponent->Id());
	}

	m_pCurrentLanguage = NULL;

	return FALSE;
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
BOOL CIterator::NextUniqueLanguage( )
{
	while (TRUE)
	{
		if( !NextLanguage( ) )
			return FALSE;

		if (!m_pCurrentLanguage)
			return FALSE;

		for(int i = 0; i < UNIQUE_LANGUAGE_ARRAY_SIZE; i++)
		{
			if( (LPWSTR) m_UniqueLanguageArray[i])
			{
				if ( m_UniqueLanguageArray[i].Equals ( 
								m_pCurrentLanguage->Language() ) )
				{
					break;
				}
			}
			else
			{
				m_UniqueLanguageArray[i].Set(m_pCurrentLanguage->Language() );
				return TRUE;
			}
		}
	}

}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CIterator::NextRow()
{
	m_Group.m_Rows.Get( m_pCurrentGroup->NWA () , 
		m_pCurrentGroup->Component() , m_pCurrentGroup->Id() );

	m_pCurrentRow = m_Group.m_Rows.Next();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\exception.h ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/


#if !defined(__EXCEPTION_H__)
#define __EXCEPTION_H__

class CException
{
private:
	ULONG			m_ulWbemError;	
	
	WCHAR			m_wszData [ BUFFER_SIZE ];

	LONG			m_lDescription;
	LONG			m_lReason;


protected:
public:
					CException( ULONG ul, const int nDescription , const int nReason)
							{
								m_ulWbemError = ul;
								m_lDescription = nDescription;
								m_lReason = nReason;

								m_wszData[0] = 0;
							}

					CException( ULONG ul, const int nDescription , const int nReason , LPWSTR pszStringData )
							{
								m_ulWbemError = ul;
								m_lDescription = nDescription;
								m_lReason = nReason;

								wcscpy( m_wszData , pszStringData );
							}					

	ULONG			WbemError()						{ return m_ulWbemError; }
	LONG			DescriptionId()				{ return m_lDescription; }
	LONG			OperationId() 				{ return m_lReason; }
	LPWSTR			Data()						{ return m_wszData; }


};

#endif // __EXCEPTION_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\maindll.cpp ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/







//***************************************************************************
//
//  MAINDLL.CPP
// 
//  Module: CIMOM DMI Instance provider 
//
//  Purpose: Contains DLL entry points.  Also has code that controls
//           when the DLL can be unloaded by tracking the number of
//           objects and locks as well as routines that support
//           self registration.
//
//
//***************************************************************************




#include "dmipch.h"		// Precompiled header for dmi provider

#include "WbemDmiP.h"

#include "Strings.h"

#include "ClassFac.h"

#include "CimClass.h"

#include "DmiData.h"

#include "AsyncJob.h"		// must preeced ThreadMgr.h

#include "ThreadMgr.h"





//////////////////////////////////////////////////////////////////
//		PROJECT SCOPE GLOBALS

long				_gcObj=0;			// count of objects
long				_gcLock=0;			// count of locks
long				_gcEventObj=0;		// count of objects
long				_gcEventLock=0;		// count of locks
CRITICAL_SECTION    _gcsJobCriticalSection; // global critical section for synchronizing job exection.

//////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////
//		FILE SCOPE GLOBALS

HMODULE				_ghModule;

extern "C"
{
const CLSID CLSID_DmiEventProvider = 
		{ 0xb21fbfa0, 0x1b39, 0x11d1, 
			{ 0xb3, 0x17, 0x0, 0x60, 0x97, 0x78, 0xd6, 0x68 } };
							// {B21FBFA0-1B39-11d1-B317-00609778D668}


const CLSID CLSID_DmiInstanceProvider = 
		{0xde065a70,0x19b5,0x11d1,
			{0xb3, 0x0c, 0x00, 0x60, 0x97, 0x78, 0xd6, 0x68}};
}



//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.  Good place for initialization.
// Return: TRUE if OK.
//***************************************************************************


BOOL WINAPI DllMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pvReserved)
{
	if ( DLL_PROCESS_DETACH == ulReason )
    {
				
        return TRUE;
    }
    else
    {
        if (DLL_PROCESS_ATTACH != ulReason)
            return TRUE;
		else
		{
			DisableThreadLibraryCalls(hInstance);			
		}
    }    

	_ghModule = hInstance;
		
    return TRUE;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void** ppv)
{
    HRESULT hr;

    if (CLSID_DmiInstanceProvider == rclsid)
	{

		CClassFactory *pObj = new CClassFactory();

		if (NULL==pObj)
			return ResultFromScode(E_OUTOFMEMORY);


		hr = pObj->QueryInterface(riid, ppv);

		if (FAILED(hr))
			delete pObj;

	}
	else if (CLSID_DmiEventProvider == rclsid)
	{
		CEventClassFactory *pObj = new CEventClassFactory();

		if (NULL==pObj)
			return ResultFromScode(E_OUTOFMEMORY);


		hr = pObj->QueryInterface(riid, ppv);

		if (FAILED(hr))
			delete pObj;
	}
	else
		return E_FAIL;


    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.//
// Return:  TRUE if there are no objects in use and the class factory 
//          isn't locked.
//***************************************************************************
STDAPI DllCanUnloadNow(void)
{
	
	return (0L == _gcObj && 0L== _gcLock) ? S_OK : S_FALSE;
    
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during initialization or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************
STDAPI DllRegisterServer(void)
{   
    WCHAR		wcID [ BUFFER_SIZE ];

	CString		cszCLSID;
	CString		cszName;
	CString		cszModel;
    HKEY		hKey1,
				hKey2;
	char       szModule[MAX_PATH];

	// 1. register the class and instance provider

    // Create the path.		 
	
    StringFromGUID2( CLSID_DmiInstanceProvider, wcID, BUFFER_SIZE );

    cszCLSID.LoadString ( IDS_CLSID_PREFIX  ) ;
	cszCLSID.Append ( wcID );    

    // Create entries under CLSID

	cszName.LoadString ( IDS_PROVIDER_NAME );
	cszModel.Set ( BOTH_STR ) ;


    RegCreateKey( HKEY_CLASSES_ROOT, cszCLSID.GetMultiByte(), &hKey1);

    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (const BYTE *)cszName.GetMultiByte(), 
		lstrlenA(cszName.GetMultiByte())+1);
	
    RegCreateKey(hKey1 , "InprocServer32" , &hKey2);

    GetModuleFileName(_ghModule, szModule,  MAX_PATH);    

	RegSetValueEx(hKey2, NULL, 0, REG_SZ, (const BYTE *)szModule, 
		lstrlenA(szModule)+1);


    RegSetValueEx(hKey2, "ThreadingModel" , 0, REG_SZ, (const BYTE *)cszModel.GetMultiByte() ,
		lstrlenA(cszModel.GetMultiByte())+1);


    RegCloseKey(hKey1);
    
	RegCloseKey(hKey2);

	// 2. register the event provider

	// Create the path.		  
    
	StringFromGUID2(CLSID_DmiEventProvider, wcID, 128);

    cszCLSID.LoadString ( IDS_CLSID_PREFIX  ) ;
	cszCLSID.Append ( wcID );

    // Create entries under CLSID

	cszName.LoadString ( IDS_EVENTPROVIDER_NAME );

    RegCreateKey(HKEY_CLASSES_ROOT, cszCLSID.GetMultiByte(), &hKey1);

	RegSetValueEx(hKey1, NULL, 0, REG_SZ, (const BYTE *)cszName.GetMultiByte(), 
		lstrlenA(cszName.GetMultiByte())+1);

    RegCreateKey(hKey1,"InprocServer32" ,&hKey2);

    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (const BYTE *)szModule, 
		lstrlenA(szModule) +1);
		

    RegSetValueEx(hKey2, "ThreadingModel" , 0, REG_SZ, (const BYTE *)cszModel.GetMultiByte() , 
		lstrlenA(cszModel.GetMultiByte())+1);
		
    RegCloseKey(hKey1);
    
	RegCloseKey(hKey2);

    return NOERROR;
}



//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************
STDAPI DllUnregisterServer(void)
{

    WCHAR		wcID [ BUFFER_SIZE ];
	char		szID [ BUFFER_SIZE ];
    CString		cszKeyName;
    HKEY		hKey;
	CString cszLoggingKeyStr(LOGGING_KEY_STR);	// 1. unreg class and instance provider;

    // Create the path using the CLSID
    
	StringFromGUID2(CLSID_DmiInstanceProvider, wcID, BUFFER_SIZE);

    cszKeyName.LoadString ( IDS_CLSID_PREFIX  ) ;
	
	cszKeyName.Append ( wcID );    

    // First delete the INPROCSERVER_STR subkey.

    if ( NO_ERROR == RegOpenKey ( HKEY_CLASSES_ROOT, cszKeyName.GetMultiByte(), &hKey ) )
    {
        RegDeleteKeyA(hKey, "InprocServer32" );
        CloseHandle(hKey);
    }

    if ( NO_ERROR == RegOpenKey ( HKEY_CLASSES_ROOT, "CLSID" , &hKey ))
    {
		wcstombs(szID, wcID, BUFFER_SIZE);
        RegDeleteKey (hKey, szID );
        CloseHandle(hKey);
    }

	// 2. unreg the event provider

	// Create the path using the CLSID

    StringFromGUID2(CLSID_DmiEventProvider, wcID, BUFFER_SIZE );

    cszKeyName.LoadString ( IDS_CLSID_PREFIX  ) ;

	cszKeyName.Append ( wcID );    

    // First delete the INPROCSERVER_STR subkey.

    if ( NO_ERROR == RegOpenKey ( HKEY_CLASSES_ROOT, cszKeyName.GetMultiByte() , &hKey ) )
    {
        RegDeleteKeyA ( hKey, "InprocServer32" );
        
		CloseHandle(hKey);
    }

    if ( NO_ERROR == RegOpenKey ( HKEY_CLASSES_ROOT, "CLSID", &hKey ))
    {
		wcstombs(szID, wcID, BUFFER_SIZE);
        RegDeleteKey (hKey, szID );

        CloseHandle(hKey);
    }

	// 3. unreg the logging

	// first delete the sub keys

    if ( NO_ERROR == RegOpenKey ( HKEY_LOCAL_MACHINE, cszLoggingKeyStr.GetMultiByte() , &hKey ) )
    {
        RegDeleteKey ( hKey, "Logging" );

		RegDeleteKey ( hKey, "File" );
        
		CloseHandle(hKey);
    }

    if ( NO_ERROR == RegOpenKey ( HKEY_LOCAL_MACHINE, NULL , &hKey ))
    {
        RegDeleteKey (hKey, cszLoggingKeyStr.GetMultiByte() );

        CloseHandle(hKey);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\mapping.cpp ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/



#include "dmipch.h"			// precompiled header for dmip

#include "WbemDmiP.h"		// project wide include

#include "Strings.h"

#include "CimClass.h"

#include "DmiData.h"

#include "Mapping.h"

#include "WbemLoopBack.h"

#include "Trace.h"

#include "Exception.h"


#define CREATEINSTANCEENUM_BUG 0



//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CMappings::CMappings()
{
	m_pFirst = NULL;
	m_pCurrent = NULL;
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CMappings::~CMappings()
{
	CMapping* p;

	MoveToHead();

	while(p = Next())
		MYDELETE ( p );
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMappings::Add(CMapping* pAdd)
{
	if(!m_pFirst)
	{
		m_pFirst = pAdd;
		return;
	}

	CMapping* pPrevious;
	CMapping* pCurrent;

	MoveToHead();

	while(pCurrent = Next())
		pPrevious = pCurrent;

	pPrevious->m_pNext = pAdd;
	pAdd->m_pPrevious = pPrevious;
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CMapping* CMappings::Next()
{
	CMapping* p = m_pCurrent;

	if(!m_pCurrent)
		return m_pCurrent;

	m_pCurrent = m_pCurrent->m_pNext;

	return p;
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMappings::Get( CWbemLoopBack* pWbem, CString& cszNameSpace, 
					CMapping** ppMapping , IWbemContext* pICtx)
{	
	MoveToHead();

	while(*ppMapping = Next())
	{
		if( cszNameSpace.Equals ( (*ppMapping)->m_cszNamespace ) )
		{
			(*ppMapping)->AddRef();
			return;
		}
	}

	*ppMapping = new CMapping;

	if (!*ppMapping)
	{
		throw CException ( WBEM_E_OUT_OF_MEMORY , 
			IDS_GETMAPPING_FAIL , IDS_NO_MEM  );
	}

	(*ppMapping)->Init( pWbem , cszNameSpace, pICtx );

	Add(*ppMapping);
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMappings::Release(CMapping* pRemove)
{	
	ASSERT( pRemove );	// Assert if NULL pointer
	if (0 != pRemove->Release())
		return;

	MoveToHead();

	CMapping* pCurrent;

	while (pCurrent = Next())
	{
		if(pCurrent == pRemove)
			break;
	}

	CMapping* pPrevious = pCurrent->m_pPrevious;
	CMapping* pNext = pCurrent->m_pNext;
	
	if(pPrevious && pNext)
	{
		pPrevious->m_pNext = pNext;
		pNext->m_pPrevious = pPrevious;
		delete pCurrent;
		return;
	}

	if(pPrevious && !pNext)
	{
		m_pFirst = pPrevious;
		pPrevious->m_pNext = NULL;
		delete pCurrent;
		return;
	}

	if(!pPrevious && pNext)
	{
		m_pFirst = pNext;
		pNext->m_pPrevious = NULL;
		delete pCurrent;
		return;
	}
	
	if(!pPrevious && !pNext)
	{
		m_pFirst = NULL;
		delete pCurrent;
		m_pCurrent = NULL;
		return;
	}
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CMapping::CMapping()
{	
	for(int i = 0; i < ITERATOR_COUNT; i++)
		m_Iterators[i] = NULL;
	
	m_bFoundClass = FALSE;	
	m_lRefCount = 0;
	m_pNext = NULL;
	m_pPrevious = NULL;

	m_pWbem = NULL;
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CMapping::~CMapping()
{
	for(int i = 0; i < ITERATOR_COUNT; i++)
		MYDELETE(m_Iterators[i]);
}




//////////////////////////////////////////////////////////////////////////////
//
// Public Members
//
//////////////////////////////////////////////////////////////////////////////


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::Init( CWbemLoopBack* pWbem , BSTR bstrPath, IWbemContext* pICtx)
{
	m_pWbem = pWbem;

	m_cszNamespace.Set( bstrPath );

	AddRef();	
}





//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::NextDynamicGroup( CCimObject& Class, CIterator* pIterator, 
								IWbemContext* pICtx)
{
	CGroup*		pGroup;

	Class.Release();

	pGroup = pIterator->GetNextNonComponentIDGroup( );

	// if failed to get a group then no more groups on this component so move 
	// to next while is used in case next component does not have groups.

	while (!pGroup)
	{		
		// get the next component

		pIterator->NextComponent(  );		
		
		if(!pIterator->m_pCurrentComponent)
		{
			// no more components on this node
			return;						
		}

		pGroup = pIterator->GetNextNonComponentIDGroup( );
	}		
	
	cimMakeGroupClass( pIterator->m_pCurrentComponent->Id ( ) , pGroup, 
		Class , pICtx);
}



//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::NextDynamicBinding( CCimObject& Class, CIterator* pIterator ,
								  IWbemContext* pICtx )
{	
	CGroup*		pGroup = NULL;

	Class.Release();

	pGroup = pIterator->GetNextNonComponentIDGroup(  );

	// if failed to get a group then no more groups on this component so move
	// to next while is used in case next component does not have groups.
	
	while (!pGroup)
	{
		// get the next component

		if(!pIterator->NextComponent( ) )
		{
			// no more components on this node

			return;
		}

		pGroup = pIterator->GetNextNonComponentIDGroup( );
	}	

	cimMakeGroupBindingClass( Class, pIterator->m_pCurrentComponent, pGroup , 
		pICtx );
}



//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::NextDynamicInstance( CString& cszClassName, 
								   CIterator* pIterator,
								   IWbemContext* pICtx , CCimObject& Instance )
{
	CRow*	pRow = NULL;

	Instance.Release();

	if(!pIterator->m_pCurrentComponent)
	{
		// enum done or no components on node

		return;								
	}		
	
	if( pIterator->m_PrototypeClass.IsEmpty() )
	{
		// Note if this fails not a dmi cim class	
		
		m_pWbem->GetObject( cszClassName, pIterator->m_PrototypeClass,
			pICtx );
	}
	
	if( cszClassName.Equals ( COMPONENT_CLASS ) )		
	{										
		// We have a component class

		if(! pIterator->m_pCurrentComponent )
			return;
		
		
		CRow	Row;

		pIterator->m_pCurrentComponent->GetComponentIDGroup( &Row );

		cimMakeComponentInstance( pIterator->m_PrototypeClass, 
			*pIterator->m_pCurrentComponent, Row , Instance);

		pIterator->NextComponent( );

		return;
	}

	if( cszClassName.Equals ( LANGUAGE_CLASS))
	{
		if(! (pIterator->NextUniqueLanguage( ) ) )
			return;

		cimMakeLanguageInstance( Instance, pIterator );

		// get ready for next pass

		return ;
	}

	if( cszClassName.Equals ( LANGUAGE_BINDING_CLASS))
	{
		if(! (pIterator->NextLanguage( ) ) )
			return;

		cimMakeLanguageBindingInstance( Instance, pIterator);

		return;
	}

	if( cszClassName.Equals ( COMPONENT_BINDING_CLASS))
	{
		if(! pIterator->m_pCurrentComponent )
			return;
		
		cimMakeComponentBindingInstance( pIterator->m_PrototypeClass, 
			pIterator->m_pCurrentComponent, Instance);

		pIterator->NextComponent( );

		return;
	}

	dmiGetNextGroupOrRow( pICtx , cszClassName, pIterator);
	
	if( !pIterator->m_pCurrentGroup || !pIterator->m_pCurrentRow)
		return;		

	if( cszClassName.Contains ( BINDING_SUFFIX ))				
	{
		// We are dealing with a binding
		
		cimMakeGroupBindingInstance( Instance, pIterator);			

		return;
	}

	cimMakeGroupInstance( pIterator->m_PrototypeClass, 
		pIterator->m_pCurrentRow, Instance );
}



//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::NextDynamicBindingInstance( IWbemContext* pICtx, 
										  CCimObject& Instance, 
										  CIterator* pIterator )
{
	CRow*		pRow = NULL;

	Instance.Release();	

	if(!pIterator->m_pCurrentComponent)
	{
		// enum done or no components on node

		return;								
	}
	
	dmiGetNextGroupOrRow( pICtx , CString( ( LPWSTR )NULL ), pIterator);

	if( !pIterator->m_pCurrentGroup)
	{
		// error, or enum done

		return;
	}

	cimMakeGroupBindingInstance( Instance, pIterator);		
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::NextDynamicGroupInstance( IWbemContext* pICtx , 
										CCimObject& Instance, 
										CIterator* pIterator )
{
	CRow*		pRow = NULL;

	Instance.Release();

	if(! pIterator->m_pCurrentComponent)
		return;				// enum done or no components on node
	
	dmiGetNextGroupOrRow( pICtx , CString( ( LPWSTR )NULL ), pIterator);

	if( !pIterator->m_pCurrentGroup)
		return;		
	
	cimMakeGroupInstance( pIterator->m_PrototypeClass, 
		pIterator->m_pCurrentRow, Instance );
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::GetDynamicGroupClass ( long lComponentId , 
						CGroup& Group , CCimObject& DynamicGroup ) 
{

	// Get the prototype class

	cimMakeGroupClass ( lComponentId , &Group, DynamicGroup , NULL) ;
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::GetGroupRowInstance ( CRow& Row , CCimObject& Instance )
{
	CGroup		Group;
	CBstr		cbGroupCimName;
	CCimObject	Class;

	Group.Get ( Row.Node() ,  Row.Component() , Row.Group() );

	MakeGroupName( Row.Component() , &Group , cbGroupCimName);

	m_pWbem->GetObject ( cbGroupCimName, Class, NULL );

	cimMakeGroupInstance( Class, &Row, Instance );
}



//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::GetEnumClass( IWbemContext* pICtx , CCimObject& Class )
{

	CVariant	cvValue;
	
	cvValue.Set ( DMIENUM_CLASS );

	Class.Create( m_pWbem, cvValue , pICtx );

	Class.AddProperty( STRING_PROP , VT_BSTR | VT_ARRAY , READ_ONLY );

	Class.AddProperty( VALUE_PROP , VT_I4 | VT_ARRAY , READ_ONLY );
	
	cvValue.Set ( (VARIANT_BOOL) VARIANT_TRUE );

//	Class.AddPropertyQualifier( STRING1_PROPERTY , KEY_QUALIFIER_STR, cvValue);
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::GetComponentClass( IWbemContext* pICtx ,
								 CCimObject& Class )
{	
	CVariant		cvValue;
	CVariant		cvClassName;
	CString			cszAttribute;
	
	CCimObject ccimParamsClass;
	CCimObject ccimLanguageParamsClass;

	cvValue.Set  ( (VARIANT_BOOL) VARIANT_TRUE );
	cvClassName.Set ( COMPONENT_CLASS );

	Class.Create( m_pWbem, cvClassName , pICtx );	

	Class.AddProperty( NAME_STR, VT_BSTR, READ_ONLY );
	
	Class.AddProperty( DESCRIPTION_STRING, VT_BSTR, READ_ONLY );
	
	Class.AddProperty( PRAGMA, VT_BSTR, READ_ONLY );
	
	Class.AddProperty( ID_STRING, VT_I4, READ_ONLY );

	Class.AddPropertyQualifier(ID_STRING, KEY_QUALIFIER_STR, cvValue);	

	
	MakeAttributeName( MANUFACTURER_ATTIBUTE_ID  , MANUFACTURER_STR  , cszAttribute);

	Class.AddProperty( cszAttribute , VT_BSTR, READ_ONLY  );

	
	MakeAttributeName( PRODUCT_ATTIBUTE_ID , PRODUCT_STR  , cszAttribute);
	
	Class.AddProperty( cszAttribute , VT_BSTR, READ_ONLY );
	
	
	MakeAttributeName( VERSION_ATTIBUTE_ID , VERSION_STR  , cszAttribute);
	
	Class.AddProperty( cszAttribute , VT_BSTR, READ_ONLY );

	
	MakeAttributeName( INSTALLATION_ATTIBUTE_ID , INSTALLATION_STR  , cszAttribute);
	
	Class.AddProperty( cszAttribute , VT_BSTR, READ_ONLY );

	
	MakeAttributeName( SERIAL_NUMBER_ATTRIBUTE_ID , SERIAL_NUMBER_STR  , cszAttribute);
	
	Class.AddProperty( cszAttribute , VT_BSTR, READ_ONLY );
	
	
	MakeAttributeName( VERIFY_INTEGER_ATTRIBUTE_ID , VERIFY_INTEGER_STR  , cszAttribute);
	
	Class.AddProperty( cszAttribute , VT_BSTR, READ_ONLY );
	

	GetAddParamsClass( ccimParamsClass, pICtx );
	Class.AddMethod(  m_pWbem , pICtx , ADD_LANGUAGE, ADDMOTHODPARAMS_CLASS, ccimParamsClass);
	
	GetLanguageClass( pICtx , ccimLanguageParamsClass );
	Class.AddMethod(  m_pWbem , pICtx , DELETE_LANGUAGE, LANGUAGEPARAMS_CLASS, ccimLanguageParamsClass);

	Class.AddMethod( m_pWbem , pICtx , ADD_GROUP, ADDMOTHODPARAMS_CLASS, ccimParamsClass );


	CCimObject ccimInParamsClass;
	GetEnumParamsClass( ccimInParamsClass, pICtx );

	CCimObject ccimOutParamsClass;
	GetEnumClass ( pICtx , ccimOutParamsClass );

	Class.AddInOutMethod( m_pWbem , pICtx , GET_ENUM, GETENUMPARAMS_CLASS , ccimInParamsClass , DMIENUM_CLASS , ccimOutParamsClass );



}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::GetComponentInstance( CString& cszPath, 
									IWbemContext* pICtx , CCimObject& Instance)
{
	CCimObject		Class;
	CComponent		Component;
	LPWSTR			pComponentId;
	LONG			lComponent;
	CVariant		cvValue;
	CAttribute*		pAttribute = NULL;

	// verify Key is correct
	if ( !cszPath.Contains ( COMPONENT_KEY_SEQUENCE ) )
	{
		throw CException ( WBEM_E_INVALID_OBJECT , IDS_GETCOMPONENTINSTANCE_FAIL , 
			IDS_READKEY_FAIL , cszPath );
	}

	m_pWbem->GetObject( COMPONENT_CLASS, Class, pICtx );

	pComponentId = wcschr( cszPath, EQUAL_CODE );

	pComponentId++;

	swscanf( pComponentId, L"%u" , &lComponent);

	Component.Get ( m_pWbem->NWA( pICtx ) , lComponent );

	CRow	Row;

	Component.GetComponentIDGroup( &Row );

	cimMakeComponentInstance( Class, Component, Row , Instance );
}



//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::GetComponentBindingClass( IWbemContext* pICtx , CCimObject& Class )
{	
	CVariant cvValue;

	cvValue.Set ( COMPONENT_BINDING_CLASS );

	Class.Create( m_pWbem, BINDING_ROOT , cvValue , pICtx );
	
	// Add the standard microsoft association class qualifier	

	cvValue.Set ( ASSOCIATION_VALUE );
	
	Class.AddClassQualifier( ASSOCIATION_QUALIFIER, cvValue );		

	// Add the Parent Referance property
	
	Class.AddProperty( OWNING_NODE , VT_BSTR, READ_ONLY );			
	
	AddStandardAssociationQualifiers( Class, OWNING_NODE );	
	
	// Add the Child Referance property

	Class.AddProperty( OWNED_COMPONENT , VT_BSTR, READ_ONLY );					
			
	AddStandardAssociationQualifiers( Class, OWNED_COMPONENT ) ;

}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::GetLanguageClass( IWbemContext* pICtx , CCimObject& Class )
{
	CVariant		cvValue;	

	Class.Release();	

	cvValue.Set ( LANGUAGE_CLASS );

	Class.Create( m_pWbem, cvValue , pICtx );

	Class.AddProperty( LANGUAGE_PROP, VT_BSTR, READ_ONLY);

	cvValue.Set ( (VARIANT_BOOL) VARIANT_TRUE);	

	Class.AddPropertyQualifier( LANGUAGE_PROP, KEY_QUALIFIER_STR, cvValue );
}

// TODO: merge MakeLanguageInstance with Getlanguage instance

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::MakeLanguageInstance( CVariant& cvLanguage, 
									IWbemContext* pICtx , 
									CCimObject& Instance )
{
	CCimObject		Class;
	
	m_pWbem->GetObject( LANGUAGE_CLASS, Class, pICtx );

	Instance.Spawn( Class );

	Instance.PutPropertyValue( LANGUAGE_PROP, cvLanguage );

}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::GetLanguageInstance( CString& cszPath, IWbemContext* pICtx ,
								   CCimObject& Instance )
{
	CCimObject		Class;
	CComponent*		pComponent;
	CLanguage*		pLanguage;
	LPWSTR			pLanguageString;
	CVariant		cvValue;
	CAttribute*		pAttribute = NULL;
	BOOL			bFound = FALSE;
	CComponents		Components;

	// verify Key is correct
	if ( ! cszPath.Contains ( LANGUAGE_KEY_SEQUENCE ) )
	{
		throw CException ( WBEM_E_INVALID_OBJECT , IDS_GETLANGINSTANCE_FAIL ,
			IDS_READKEY_FAIL );
	}

	m_pWbem->GetObject( LANGUAGE_CLASS, Class, pICtx );

	Instance.Spawn( Class );

	pLanguageString = wcsstr( cszPath, START_KEY_VAL_SEQUENCE );

	if ( !pLanguageString )
	{
		throw CException ( WBEM_E_INVALID_OBJECT , IDS_GETLANGINSTANCE_FAIL ,
			IDS_READKEY_FAIL);
	}

	pLanguageString += 2;

	Components.Get ( m_pWbem->NWA( pICtx ) ) ;	

	Components.MoveToHead();

	while( pComponent = Components.Next( ) )
	{
		pComponent->m_Languages.Get ( pComponent->NWA () ,
			pComponent->Id() );

		while (pLanguage = pComponent->m_Languages.Next())
		{
			if ( wcsstr ( pLanguageString, pLanguage->Language() ) )
			{
				bFound = TRUE;
				break;
			}
		}

		if (bFound)
			break;
	}
	
	if ( bFound )
	{
		Instance.PutPropertyValue( LANGUAGE_PROP, 
			CVariant ( pLanguage->Language() ) );

		return;
	}

	throw CException ( WBEM_E_INVALID_OBJECT , IDS_GETLANGINSTANCE_FAIL ,
			NO_STRING , cszPath );

}



//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::GetLanguageBindingClass( 
									   CCimObject& Class, IWbemContext* pICtx)
{
	CVariant cvValue;

	cvValue.Set ( LANGUAGE_BINDING_CLASS );

	Class.Create( m_pWbem, BINDING_ROOT , cvValue , pICtx );
	
	// Add the standard microsoft association class qualifier	

	cvValue.Set ( ASSOCIATION_VALUE );

	cvValue.Set ( ( VARIANT_BOOL ) VARIANT_TRUE );

	Class.AddClassQualifier( ASSOCIATION_QUALIFIER, cvValue );		

	// Add the Parent Referance property
	
	Class.AddProperty( COMPONENT_STR, VT_BSTR, READ_ONLY );			
	
	AddStandardAssociationQualifiers( Class, COMPONENT_STR);	
	
	// Add the Child Referance property

	Class.AddProperty(LANGUAGE_PROP, VT_BSTR, READ_ONLY );					
			
	AddStandardAssociationQualifiers( Class, LANGUAGE_PROP) ;
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::GetGroupRootClass( CCimObject& Class, IWbemContext* pICtx )
{
	CVariant cvValue;

	cvValue.Set ( GROUP_ROOT );

	Class.CreateAbstract( m_pWbem, cvValue , pICtx );
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::GetBindingRootClass( CCimObject& Class, IWbemContext* pICtx )
{
	CVariant	cvValue;

	cvValue.Set ( BINDING_ROOT );

	Class.CreateAbstract( m_pWbem, cvValue, pICtx );
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::GetDeleteLanguageParamsClass( CCimObject& Class, 
											IWbemContext* pICtx )
{	
	CVariant		cvValue;

	Class.Release();

	cvValue.Set ( LANGUAGEPARAMS_CLASS );

	Class.Create( m_pWbem , cvValue , pICtx);

	Class.AddProperty( LANGUAGE_PROP, VT_BSTR, READ_ONLY );

	cvValue.Set ( (VARIANT_BOOL )VARIANT_TRUE );

	Class.AddPropertyQualifier( LANGUAGE_PROP, KEY_QUALIFIER_STR, cvValue );

}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::GetAddParamsClass( CCimObject& Class, IWbemContext* pICtx )
{
	CVariant		cvValue;

	Class.Release();

	cvValue.Set ( ADDMOTHODPARAMS_CLASS );

	Class.Create( m_pWbem , cvValue , pICtx);

	Class.AddProperty( MIF_FILE, VT_BSTR, READ_ONLY );

	cvValue.Set (VARIANT_TRUE);

	Class.AddPropertyQualifier( MIF_FILE, KEY_QUALIFIER_STR, cvValue );
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::GetEnumParamsClass( CCimObject& Class, IWbemContext* pICtx )
{
	CVariant		cvValue;

	Class.Release();

	cvValue.Set ( GETENUMPARAMS_CLASS );

	Class.Create( m_pWbem , cvValue , pICtx );

	Class.AddProperty( ATTRIBUTE_ID, VT_BSTR, READ_ONLY );

	cvValue.Set (VARIANT_TRUE);

	Class.AddPropertyQualifier( ATTRIBUTE_ID, KEY_QUALIFIER_STR, cvValue );
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::GetNotifyStatusInstance( CCimObject& Instance, 
									   ULONG ulStatus, IWbemContext* pICtx)
{
	m_pWbem->GetNotifyStatusInstance( Instance, ulStatus, pICtx );
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
BOOL CMapping::GetExtendedStatusInstance( CCimObject& Instance, ULONG ulStatus, 
										 BSTR bstrDescription,
										 BSTR bstrOperation,
										 BSTR bstrParameter,
										 IWbemContext* pICtx )
{
	return m_pWbem->GetExtendedStatusInstance( Instance, ulStatus, 
		bstrDescription, bstrOperation, bstrParameter, pICtx );
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::GetNodeDataInstance( CCimObject& Instance , IWbemContext* pICtx)
{	
	CNode		Node;
	CCimObject	Class;
	CVariant	cvValue;

	m_pWbem->GetObject( NODEDATA_CLASS, Class, pICtx );

	Instance.Spawn( Class);

	Node.Get( m_pWbem->NWA( pICtx ) );

	cvValue.Set ( Node.Version() );

	Instance.PutPropertyValue ( SL_VERSION, cvValue );	

	cvValue.Set ( Node.Language() );

	Instance.PutPropertyValue ( SL_LANGUAGE, cvValue );	

	cvValue.Set ( Node.Description () );

	Instance.PutPropertyValue ( SL_DESCRIPTION , cvValue );
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::GetNodeDataClass ( CCimObject& Class, IWbemContext* pICtx )
{	
	CVariant	cvValue;
	
	cvValue.Set ( NODEDATA_CLASS );
	CCimObject ccimParamsClass;

	Class.Create( m_pWbem, cvValue , pICtx );

	cvValue.Set ( VARIANT_TRUE );
	Class.AddClassQualifier( SINGLETON, cvValue );

	Class.AddProperty( SL_VERSION, VT_BSTR, READ_ONLY);

	Class.AddProperty( SL_LANGUAGE, VT_BSTR, READ_ONLY);

	Class.AddProperty( SL_DESCRIPTION, VT_BSTR, READ_ONLY);

	// Create an AddMethodParams class 
	GetAddParamsClass( ccimParamsClass, pICtx );

	Class.AddMethod( m_pWbem , pICtx ,SET_LANGUAGE, ADDMOTHODPARAMS_CLASS, ccimParamsClass );
	
	Class.AddMethod( m_pWbem , pICtx ,ADD_COMPONENT, ADDMOTHODPARAMS_CLASS, ccimParamsClass );	
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::GetNodeDataBindingInstance(  CCimObject& Instance , IWbemContext* pICtx)
{
	CCimObject	Class;
	CVariant	cvValue;

	m_pWbem->GetObject( NODEDATA_BINDING_CLASS , Class , pICtx );
	
	Instance.Spawn ( Class );
	
	cvValue.Set ( NODE_PATH ) ;
	
	Instance.PutPropertyValue ( OWNING_NODE, cvValue);
	
	cvValue.Set ( NODEDATA_PATH ) ;

	Instance.PutPropertyValue ( OWNED_NODEDATA, cvValue);

}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::GetNodeDataBindingClass (  CCimObject& Class, IWbemContext* pICtx )
{
	CVariant cvValue;
	
	cvValue.Set (NODEDATA_BINDING_CLASS );

	Class.Create( m_pWbem, BINDING_ROOT , cvValue, pICtx );
	
	// Add the standard microsoft association class qualifier	

	cvValue.Set ( ASSOCIATION_VALUE );
	
	Class.AddClassQualifier( ASSOCIATION_QUALIFIER, cvValue );		

	// Add the Parent Referance property
	
	Class.AddProperty( OWNING_NODE , VT_BSTR, READ_ONLY );			
	
	AddStandardAssociationQualifiers( Class, OWNING_NODE );	
	
	// Add the Child Referance property

	Class.AddProperty( OWNED_NODEDATA , VT_BSTR, READ_ONLY );					
			
	AddStandardAssociationQualifiers( Class, OWNED_NODEDATA ) ;

}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::GetDmiEventClass( IWbemContext* pICtx , CCimObject& Class)
{
	CVariant	cvValue;

	cvValue.Set ( DMIEVENT_CLASS );	

	Class.Create( m_pWbem, cvValue , pICtx );

	Class.AddProperty( COMPONENT_ID, VT_I4, READ_ONLY);

	Class.AddProperty( EVENT_TIME, VT_BSTR, READ_ONLY);

	cvValue.Set(VARIANT_TRUE);

	Class.AddPropertyQualifier( EVENT_TIME, KEY_QUALIFIER_STR, cvValue);

	Class.AddProperty( LANGUAGE_PROP, VT_BSTR, READ_ONLY);

	Class.AddProperty( MACHINE_PATH, VT_BSTR , READ_ONLY );
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::SetDefaultLanguage( IWbemContext* pICtx , CCimObject& InParams)
{
	CVariant		cvLanguage;
	CNode			Node;

	// Get install info
	InParams.GetProperty ( LANGUAGE_PROP, cvLanguage);
		
	Node.Get ( m_pWbem->NWA( pICtx ) );

	Node.SetDefaultLanguage ( cvLanguage );
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::AddComponent( IWbemContext* pICtx , CCimObject& InParams)
{
	CVariant	cvMifFile;
		
	// Get install info
	InParams.GetProperty ( MIF_FILE, cvMifFile);

	CNode	Node;

	Node.Get ( m_pWbem->NWA( pICtx ) );

	Node.AddComponent( cvMifFile );
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::AddGroup( CString& cszComponentPath, CCimObject& InParams, 
						IWbemContext* pICtx)
{
	CVariant		cvComponent , cvMifFile;
	CCimObject		Object;
	CGroups			Groups;

	// Get install info
	InParams.GetProperty ( MIF_FILE, cvMifFile);

	m_pWbem->GetObject( cszComponentPath , Object, pICtx);

	Object.GetProperty ( ID_STRING , cvComponent );

	CComponent Component;
	
	Component.Get ( m_pWbem->NWA( pICtx ) , cvComponent.GetLong ( ) );

	Component.AddGroup( cvMifFile );
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::AddLanguage( CString& cszComponentPath, CCimObject& InParams,
						   IWbemContext* pICtx)
{
	CVariant		cvCompoentId, cvMifFile;
	CCimObject		Object;

	// Get install info

	InParams.GetProperty ( MIF_FILE, cvMifFile);

	m_pWbem->GetObject ( cszComponentPath , Object, pICtx);

	Object.GetProperty ( ID_STRING , cvCompoentId);

	CComponent	Component;

	Component.Get ( m_pWbem->NWA( pICtx ) , cvCompoentId.GetLong( ) );

	Component.AddLanguage( cvMifFile );
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::DeleteLanguage( CString& cszComponentPath, CCimObject& InParams,
							  IWbemContext* pICtx)
{
	CVariant		cvCompoentId , cvLanguage;
	CCimObject		Object;
	CLanguages		Languages;

	// Get install info
	InParams.GetProperty ( LANGUAGE_PROP, cvLanguage);

	m_pWbem->GetObject(cszComponentPath, Object, pICtx);
	
	Object.GetProperty ( ID_STRING , cvCompoentId);

	CComponent Component;

	Component.Get (  m_pWbem->NWA( pICtx ) , cvCompoentId.GetLong ( ) );

	Component.DeleteLanguage ( cvLanguage );
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::ComponentGetEnum( CString& cszComponentPath , 
								CCimObject& InParams, 
								CCimObject& OutParams, IWbemContext* pICtx)
{	
	CVariant		cvParent, cvAttribute, cvEnum;
	CEnum			Enum;
	CCimObject		GroupInstance;
	CCimObject		OutParamsClass;
	LONG			lCount , lComponent , lAttribute;

	CString			cszEnumClassName( DMIENUM_CLASS );	
	
	CObjectPath Path;

	Path.Init ( cszComponentPath );

	lComponent = Path.KeyValueUint( 1 );	

	InParams.GetProperty ( ATTRIBUTE_ID, cvAttribute );		

	CString cszT;

	cszT.Set ( cvAttribute.GetBstr() );

	swscanf (  cszT , L"%u" , &lAttribute );

	Enum.Get ( m_pWbem->NWA( pICtx ) , lComponent , COMPONENTID_GROUP , 
		lAttribute );	

	lCount = Enum.GetCount();

	cszEnumClassName.Append(lCount);
	
	m_pWbem->GetObject( cszEnumClassName, OutParamsClass, pICtx );
	
	// construct return instance

	cimMakeEnumInstance( OutParamsClass, Enum, OutParams );					
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::DynamicGroupGetEnum(CString& cszGroupRowPath,
								   CCimObject& InParams,
								   CCimObject& OutParams,
								   IWbemContext* pICtx)
{	
	CVariant		cvParent, cvAttribute, cvComponent, cvGroup , cvEnum;
	CEnum			Enum;
	CCimObject		GroupInstance;
	CCimObject		OutParamsClass;
	LONG			lAttribute;
	CString			cszEnumClassName( DMIENUM_CLASS ) , cszT;
	
	m_pWbem->GetObject( cszGroupRowPath, GroupInstance, pICtx );

		// Check Object type is a DmiGroup class

	GroupInstance.GetProperty ( PARENT_NAME, cvParent );

	CString				cszGroupRoot ( GROUP_ROOT );
	
	if ( ! cszGroupRoot.Equals ( cvParent.GetBstr() ) )
	{
		throw CException( WBEM_E_INVALID_OBJECT, IDS_GETENUMOFGROUP_FAIL ,
			IDS_NOTGROUP , cszGroupRowPath );
	}

	GroupInstance.GetProperty ( COMPONENT_ID , cvComponent );

	GroupInstance.GetProperty ( ID_STRING , cvGroup );

	InParams.GetProperty ( ATTRIBUTE_ID, cvAttribute );

	cszT.Set ( cvAttribute.GetBstr() );

	swscanf (  cszT , L"%u" , &lAttribute );

	Enum.Get ( m_pWbem->NWA( pICtx ) , cvComponent.GetLong ( ) , cvGroup.GetLong ( ) , 
		lAttribute );

	m_pWbem->GetObject( cszEnumClassName, OutParamsClass, pICtx );
	
	// construct return instance

	cimMakeEnumInstance( OutParamsClass, Enum, OutParams );				
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::ModifyInstanceOrAddRow( IWbemContext* pICtx , CCimObject& Instance)
{
	CVariant	cvComponent, cvGroup , cvQualifierValue(VARIANT_TRUE); 
	CRow		Row;	
	CAttributes		Keys;
	BOOL		bFoundRow = FALSE;
	CSafeArray	csaKeys;	
	CBstr		cbQualifier;
	LONG		lFlags;
	int			i;

	STAT_TRACE ( L"Called CMapping :: ModifyInstanceOrAddRow " );

	Instance.GetProperty ( COMPONENT_ID , cvComponent );

	Instance.GetProperty ( ID_STRING , cvGroup );

	// Get the keys for the row
	lFlags = WBEM_FLAG_KEYS_ONLY;	
	
	Instance.GetNames ( cbQualifier , lFlags , csaKeys );

	if( !csaKeys.BoundsOk())
	{
		throw CException ( WBEM_E_FAILED , IDS_PUTINSTANCE_FAIL,
			IDS_GETNAMES_FAIL );
	}

	for( i = csaKeys.LBound(); i <= csaKeys.UBound(); i++)
	{
		CVariant cvValue, cvDmiName, cvAttribute;

		Instance.GetProperty (csaKeys.Bstr(i), cvValue);

		CBstr cbValue;

		cbValue.Set ( DMI_NAME );
		
		Instance.GetPropertyQualifer( csaKeys.Bstr(i), cbValue , cvDmiName);
		
		cbValue.Set ( ID_STRING );

		Instance.GetPropertyQualifer( csaKeys.Bstr(i), cbValue , cvAttribute );

		CAttribute* pAttribute = new CAttribute;

		pAttribute->SetId( cvAttribute.GetLong() );
		pAttribute->SetName( cvDmiName.GetBstr() );
		pAttribute->SetValue( cvValue );

		Keys.Add( pAttribute );		
	}	

	Row.Get ( m_pWbem->NWA( pICtx ) , cvComponent.GetLong ( ) , cvGroup.GetLong ( ) ,
		Keys , &bFoundRow );	

	// Get the values for all the attributes in the row.	
	
	// Note all properties of a group that are dmi attributes have a 
	// dmi_name property

	cbQualifier.Set( DMI_NAME );		

	lFlags = WBEM_FLAG_ONLY_IF_TRUE | WBEM_FLAG_NONSYSTEM_ONLY;	
	
	CSafeArray	csaNames;	
	Instance.GetNames ( cbQualifier, lFlags, csaNames );
	
	if( !csaNames.BoundsOk())
	{
		throw CException ( WBEM_E_FAILED , IDS_PUTINSTANCE_FAIL,
			IDS_GETNAMES_FAIL );
	}

	// Fill out the temp row will attributes

	for( i = csaNames.LBound(); i <= csaNames.UBound(); i++)
	{
		CVariant cvValue, cvDmiName, cvAttribute;

		Instance.GetProperty (csaNames.Bstr(i), cvValue);

		Instance.GetPropertyQualifer( csaNames.Bstr(i), CBstr( DMI_NAME ),
			cvDmiName);

		if( bFoundRow )
		{
			// if we are doing an update make sure that only writable 
			// attriubtes have different values and the attributes exist
			// have changesUpdate an existing Row.  the sl database is
			// not updated until commitrow is called

			Row.UpdateAttribute ( cvDmiName , cvValue );
		}
		else
		{
			CAttribute* pAttribute = new CAttribute;

			Instance.GetPropertyQualifer( csaNames.Bstr(i),
				CBstr( ID_STRING ), cvAttribute );

			pAttribute->SetId( cvAttribute.GetLong() );
			pAttribute->SetName( cvDmiName.GetBstr() );
			pAttribute->SetValue( cvValue );

			Row.m_Attributes.Add( pAttribute );
		}
	}	

	if (!bFoundRow)
	{
		// add the new row
		CGroup	Group;

		Group.Get ( m_pWbem->NWA( pICtx ) , cvComponent.GetLong ( ) , cvGroup.GetLong ( )  );

		STAT_TRACE ( L"Calling AddRow" );
		Group.AddRow ( Row );
		STAT_TRACE ( L"Called AddRow" );
	}
	else
	{
		// do the actual row update

		Row.CommitChanges ( ) ;
	}

}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::cimMakeComponentInstance( CCimObject& PrototypeClass, 
										CComponent& Component, CRow& Row ,
										CCimObject& Instance )
{
	CVariant		cvValue;
	CAttribute*		pAttribute = NULL;


	Instance.Spawn( PrototypeClass );
	
	// put the component properties that correspond to dmi component info
	cvValue.Set ( Component.Name() );
	
	Instance.PutPropertyValue ( NAME_STR, cvValue );

	cvValue.Set ( Component.Description() );

	Instance.PutPropertyValue ( DESCRIPTION_STRING, cvValue  );

	cvValue.Set ( Component.Pragma() );

	Instance.PutPropertyValue ( PRAGMA, cvValue );

	cvValue.Set ( Component.Id() );

	Instance.PutPropertyValue ( ID_STRING, cvValue );

	// now set the componentid group attributes	

	Row.m_Attributes.MoveToHead();

	while(pAttribute = Row.m_Attributes.Next())
	{
		CVariant			cvValue;
		CString				cszCimName;
		
		MakeAttributeName( pAttribute->Id() , pAttribute->Name() , cszCimName);

		cvValue.Set( (LPVARIANT) pAttribute->Value() );		

		Instance.PutPropertyValue ( cszCimName, cvValue);
		
		cvValue.Set( pAttribute->Name() );

		Instance.AddPropertyQualifier( cszCimName, DMI_NAME, cvValue);

		cvValue.Set( pAttribute->Id() );

		Instance.AddPropertyQualifier( cszCimName, ID_STRING, cvValue);

		cvValue.Set( pAttribute->Description() );
		
		Instance.AddPropertyQualifier( cszCimName, DESCRIPTION_PROPERTY, cvValue);

		cvValue.Set( pAttribute->Storage() );
		
		Instance.AddPropertyQualifier( cszCimName, STORAGE, cvValue);

		cvValue.Set(pAttribute->Type());
		
		Instance.AddPropertyQualifier( cszCimName, TYPE, cvValue);

		if ( pAttribute->IsEnum() )
		{
			cvValue.Set ( VARIANT_TRUE );
			Instance.AddPropertyQualifier( cszCimName, ENUM_QUALIFER_STR , 
				cvValue );
		}

	}
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::cimMakeComponentBindingInstance( CCimObject& PrototypeClass, 
										CComponent* pComponent,
										CCimObject& Instance )
{
	CVariant		cvValue;
	
	Instance.Spawn( PrototypeClass );
	
	cvValue.Set ( NODE_PATH );
	
	Instance.PutPropertyValue ( OWNING_NODE, cvValue);	
	
	MakeComponentInstancePath ( pComponent , cvValue );

	Instance.PutPropertyValue ( OWNED_COMPONENT, cvValue);
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::cimMakeGroupInstance(CCimObject& Class, CRow* pRow, 
									CCimObject& Instance )
{	
	CVariant	cvValue;

	MOT_TRACE ( L"\t\tCIM Spawn Component %lu Group %lu Row %lX" , pRow->Component() , pRow->Group() , Instance);

	Instance.Spawn( Class );

	// look into rows and return appropreate values, we only need to fix the 
	// attribute values, the group scope values are correct from the spawn

	CAttribute* pAttribute;

	pRow->m_Attributes.MoveToHead();

	while(pAttribute = pRow->m_Attributes.Next())
	{
		CString		cszCimName;

		MakeAttributeName( pAttribute->Id() , pAttribute->Name() , cszCimName);
		
		Instance.PutPropertyValue ( cszCimName, pAttribute->Value() );
	}
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::cimMakeGroupBindingInstance(CCimObject& Instance, 
										   CIterator* pIterator)
{
	CVariant	cvValue;

	Instance.Spawn( pIterator->m_PrototypeClass );

	// set the COMPONENT_STR property value
	
	MakeComponentInstancePath( pIterator->m_pCurrentComponent , cvValue);

	Instance.PutPropertyValue ( COMPONENT_STR, cvValue);
	
	// set the GROUP_STR property value

	MakeGroupInstancePath(cvValue, pIterator);					

	Instance.PutPropertyValue ( GROUP_STR, cvValue);
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::cimMakeLanguageInstance(CCimObject& Instance, 
									   CIterator* pIterator )
{
	CVariant	cvValue;

	Instance.Spawn( pIterator->m_PrototypeClass );

	cvValue.Set ( pIterator->m_pCurrentLanguage->Language() );

	Instance.PutPropertyValue ( LANGUAGE_PROP, cvValue );	
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::cimMakeLanguageBindingInstance(CCimObject& Instance, 
											  CIterator* pIterator)
{
	CVariant	cvValue;

	Instance.Spawn ( pIterator->m_PrototypeClass);
	
	// set the COMPONENT_STR property value
	
	MakeComponentInstancePath( pIterator->m_pCurrentComponent , cvValue );
	
	Instance.PutPropertyValue ( COMPONENT_STR, cvValue);
	
	// set the language property value

	MakeLanguageInstancePath(cvValue, pIterator);				

	Instance.PutPropertyValue ( LANGUAGE_PROP, cvValue);
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::cimMakeGroupClass( long lComponent , CGroup* pGroup, 
								 CCimObject& Class, IWbemContext* pICtx)
{

	ASSERT(pGroup);

	
	BOOL bHasEnum = FALSE;	// Assume the group doesn't have enumerated attributes
	CVariant cvValue;

	CAttribute *pAttribute = NULL;

	CBstr cbGroupCimName;
	MakeGroupName( lComponent , pGroup , cbGroupCimName);

	cvValue.Set ( cbGroupCimName );

	Class.Create( m_pWbem, GROUP_ROOT, cvValue , pICtx );

#if CREATEINSTANCEENUM_BUG
#else
	if ( !pGroup->IsTable() )
	{
		cvValue.Set ( VARIANT_TRUE );
		Class.AddClassQualifier( SINGLETON, cvValue );
	}
#endif

	cvValue.Set(pGroup->Component());
	Class.AddProperty(COMPONENT_ID, cvValue, READ_ONLY );

	cvValue.Set(pGroup->Id());
	Class.AddProperty(ID_STRING, cvValue, READ_ONLY );

	// Add the standard group properties (standed required and options DMI 
	// group properties)

	cvValue.Set(pGroup->Name());
	Class.AddProperty(NAME_STR, cvValue, READ_ONLY);

	cvValue.Set(pGroup->Pragma());
	Class.AddProperty(PRAGMA, cvValue, READ_ONLY);

	cvValue.Set(pGroup->Description () );
	Class.AddProperty( DESCRIPTION_PROPERTY, cvValue, READ_ONLY);

	cvValue.Set(pGroup->ClassString());
	Class.AddProperty(DMI_CLASS_STRING, cvValue, READ_ONLY );

	// Add the dynamic CIM Group Properties (DMI Attributes)
	pGroup->m_Attributes.MoveToHead();
	
	while(pAttribute = pGroup->m_Attributes.Next() )
	{
		CBstr		cbCimAttributeName;
		BOOL		bReadOnly = TRUE;
		CString		cszCimName;		
		
		MakeAttributeName( pAttribute->Id() , pAttribute->Name() , cszCimName);

		cvValue.Set( EMPTY_STR );
		Class.AddProperty(cszCimName, cvValue, pAttribute->Access() );

		cvValue.Set( pAttribute->Name() );
		Class.AddPropertyQualifier( cszCimName, DMI_NAME, cvValue);

		cvValue.Set( pAttribute->Id() );
		Class.AddPropertyQualifier( cszCimName, ID_STRING, cvValue);

		cvValue.Set( pAttribute->Description() );
		Class.AddPropertyQualifier( cszCimName, DESCRIPTION_PROPERTY, cvValue);

		cvValue.Set( pAttribute->Storage() );
		Class.AddPropertyQualifier( cszCimName, STORAGE, cvValue);

		cvValue.Set(pAttribute->Type());
		Class.AddPropertyQualifier( cszCimName, TYPE, cvValue);

		cvValue.Set ( VARIANT_TRUE );

		if ( pAttribute->IsEnum( ) )
		{
			Class.AddPropertyQualifier( cszCimName, ENUM_QUALIFER_STR , 
				cvValue ); 		
			bHasEnum = TRUE;
		}

		BOOL bIsKey = pAttribute->IsKey( );

#if CREATEINSTANCEENUM_BUG

		bIsKey = TRUE;
#endif

		if ( pAttribute->IsKey( ) )
		{
			Class.AddPropertyQualifier( cszCimName, KEY_QUALIFIER_STR , 
				cvValue ); 		
		}

	}  // end while (attribue loop)

	// If the group has enumerated attribute, add the GetAttributeEnum method to it
	if ( TRUE == bHasEnum )
	{

		CCimObject ccimInParamsClass;
		GetEnumParamsClass( ccimInParamsClass, pICtx );
		CCimObject ccimOutParamsClass;
		GetEnumClass ( pICtx , ccimOutParamsClass );
		Class.AddInOutMethod( m_pWbem , pICtx , 
							  GET_ENUM, GETENUMPARAMS_CLASS , ccimInParamsClass , DMIENUM_CLASS , ccimOutParamsClass );
	}

}
 

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::cimMakeGroupBindingClass( CCimObject& Class, CComponent* pComponent,
								   CGroup* pGroup, IWbemContext* pICtx )
{
	CBstr	cbBindingName;
	CVariant cvValue;

	MakeGroupBindingName(cbBindingName, pComponent, pGroup);

	cvValue.Set ( cbBindingName );
	Class.Create( m_pWbem, BINDING_ROOT, cvValue , pICtx );
	
	// Add the standard microsoft association class qualifier		

	cvValue.Set ( ASSOCIATION_VALUE );
	
	Class.AddClassQualifier( ASSOCIATION_QUALIFIER, cvValue ) ;				
	
	// Add the Parent Referance property

	Class.AddProperty(COMPONENT_STR, VT_BSTR, READ_ONLY );					

	AddStandardAssociationQualifiers( Class, COMPONENT_STR);
	
	// Add the Child Referance property

	Class.AddProperty(GROUP_STR, VT_BSTR, READ_ONLY );							
			
	AddStandardAssociationQualifiers( Class, GROUP_STR) ;
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::cimMakeEnumInstance( CCimObject& EnumClass, CEnum& Enum,
								   CCimObject& EnumInstance )
{
	CEnumElement*	pElement = NULL;
	LONG			lIndex = 0, lCount=0;

	EnumInstance.Spawn( EnumClass );

	lCount = Enum.GetCount () ;

	CSafeArray t_StringArray ( lCount , VT_BSTR ) ;
	CSafeArray t_IntArray ( lCount , VT_I4 ) ;

	Enum.MoveToHead();
	
	while (pElement = Enum.Next() )
	{
		CVariant	cvStringValue;
		CVariant	cvIntValue;

		cvStringValue.Set ( pElement->GetString() );
		t_StringArray.Set ( lIndex , cvStringValue ) ;

		cvIntValue.Set ( pElement->GetValue() );
		t_IntArray.Set ( lIndex , cvIntValue ) ;

		lIndex++;
	}

	CVariant t_StringVariant ( &t_StringArray ) ;
	CVariant t_IntVariant ( &t_IntArray ) ;
	EnumInstance.PutPropertyValue ( STRING_PROP, t_StringVariant );
	EnumInstance.PutPropertyValue ( VALUE_PROP, t_IntVariant );

}

////////////////////////////////////////////////////////////////////////////////
//
//
////////////////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::dmiGetNextGroupOrRow( IWbemContext* pICtx , CString& cszClassName, 
									CIterator* pIterator)
{
	if (! pIterator->m_pCurrentGroup )
	{
		// section for first time through
	
		if ( !cszClassName.IsEmpty ( ) )
		{
			CComponent	Component;		
			dmiGetComponentAndGroup ( pICtx , cszClassName , 
				pIterator->m_Component , pIterator->m_Group);

			if( pIterator->m_Group.IsEmpty() )
				return;

			pIterator->m_pCurrentGroup = &pIterator->m_Group;
			pIterator->m_pCurrentComponent = &pIterator->m_Component;
		}
		else
		{
			pIterator->m_pCurrentGroup = pIterator->m_pCurrentComponent->m_Groups.m_pFirst ;
		}
	}

	// NOTE: rows::MoveToHead called called by the cgroups::next	

	if ( pIterator->m_pCurrentGroup )
		pIterator->NextRow();		
}



//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::GetInstanceByPath( LPWSTR pwszPath, CCimObject& Instance, 
								 CIterator* pIterator, IWbemContext* pICtx)
{
	CObjectPath		Path;
		
	Path.Init(pwszPath);

#ifdef _DEBUG
	DEV_TRACE ( L"Path - Class = %s", Path.ClassName() ) ;
	for (int i = 0; i < Path.KeyCount(); i++)
		DEV_TRACE ( L"Path Key %lu %s = %s", i, Path.KeyName(i), Path.KeyValue(i));
#endif // #ifdef _DEBUG

	// get prototype class to spawn instance

	m_pWbem->GetObject( Path.ClassName(), pIterator->m_PrototypeClass,
		pICtx );
	
	// try to get instance of component

	CString cszClassName ( Path.ClassName() );
	
	if( cszClassName.Equals ( COMPONENT_CLASS ) )		
	{
		CComponents		Components;
		
		Components.Get ( m_pWbem->NWA( pICtx ) ) ;	

		Components.GetFromID(Path.KeyValueUint(0), 
			&( pIterator->m_pCurrentComponent) );

		CRow Row;

		pIterator->m_pCurrentComponent->GetComponentIDGroup( &Row );
		
		cimMakeComponentInstance( pIterator->m_PrototypeClass, 
			*pIterator->m_pCurrentComponent, Row , Instance);

		return;
	}
	
	// try to get instance of Language

	if( cszClassName.Equals ( LANGUAGE_CLASS ) )		
	{
		cimMakeLanguageInstance( Instance, pIterator);

		return;
	}
	
	// must by dynamic group or binding class

	dmiGetComponentGroupRowFromPath( pICtx , Path , pIterator );			
	
	// try to get instance of binding			

	if( ( cszClassName.Contains ( BINDING_SUFFIX ) ))				
	{
		cimMakeGroupBindingInstance( Instance,  pIterator);

		return;
	}

	// must be a group so get instance of group
	
	cimMakeGroupInstance( pIterator->m_PrototypeClass, 
		pIterator->m_pCurrentRow, Instance);					
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::dmiGetComponentGroupRowFromPath( IWbemContext* pICtx ,
											   CObjectPath& Path, 
											   CIterator* pIterator )
{
	CString	cszClassName;
	
	cszClassName.Set( Path.ClassName() );

	while (TRUE)
	{
		dmiGetComponentAndGroup ( pICtx , cszClassName , 
			pIterator->m_Component , pIterator->m_Group);
		
		pIterator->m_pCurrentGroup = &pIterator->m_Group;
		pIterator->m_pCurrentComponent = &pIterator->m_Component;

		if( pIterator->m_Group.IsEmpty() )
		{
			throw CException ( WBEM_E_INVALID_CLASS , IDS_GETCOMPGROUP_FAIL , IDS_NOGROUP );
		}

		// handle scalar groups
		
		if(VARIANT_FALSE == pIterator->m_pCurrentGroup->IsTable())
		{
			// scalars can only have a row id of 1

			if ( !Path.SingletonInstance () )
				throw CException ( WBEM_E_INVALID_OBJECT , 0 , 0 );

			pIterator->NextRow( );			

			return;
		}

		// handle tabular groups

		CAttributes PathKeys;

		PathKeys.ReadCimPath( Path );

		while( TRUE )
		{			
			pIterator->NextRow();

			if( !pIterator->m_pCurrentRow ) 
				break;

			if( pIterator->m_pCurrentRow->m_Keys.Equal ( PathKeys ) )
				return;
		}

		throw CException ( WBEM_E_INVALID_OBJECT , IDS_GETCOMPGROUP_FAIL ,
			IDS_BADROW ) ;
	}
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::GetDynamicClassByName( CString& cszClassName, CCimObject& Class,
									 CIterator* pIterator, IWbemContext* pICtx)
{
	CComponent	Component;
	CGroup		Group;	
	
	dmiGetComponentAndGroup ( pICtx ,cszClassName , Component , Group);
	
	if( cszClassName.Contains ( BINDING_SUFFIX))
	{
		cimMakeGroupBindingClass( Class, &Component, &Group , pICtx );

		return;
	}

	cimMakeGroupClass( Component.Id ( ) , &Group, Class, 
		pICtx );
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::AddStandardAssociationQualifiers( CCimObject& Class, 
												LPWSTR wszPropName)
{
	CVariant	cvValue;
	
	// Add the qulifer that makes this an association referance	

	cvValue.Set ( REFERANCE_QUALIFER );

	Class.AddPropertyQualifier( wszPropName, SYNTAX_QUALIFIER, cvValue );	
	
	// Add the other standard association qualifers

	cvValue.Set ( VARIANT_TRUE );

	Class.AddPropertyQualifier( wszPropName, KEY_QUALIFIER_STR, cvValue );	
	
	Class.AddPropertyQualifier( wszPropName, READ_QUALIFIER, cvValue );
	
	Class.AddPropertyQualifier( wszPropName, VOLATILE_QUALIFIER, cvValue );
}


/////////////////////////////////////////////////////////////////////////////////////
//
//
//
/////////////////////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
BOOL CMapping::MakeGroupBindingName(CBstr& cbCim, CComponent* pComponent, 
									CGroup* pGroup)
{
	CString cszCimName;
	
	cszCimName.Set ( COMPONENT_STR );
	cszCimName.Append ( pComponent->Id() );
	cszCimName.Append ( SEPERATOR_STR );
	cszCimName.Append ( GROUP_STR  );
	cszCimName.Append ( pGroup->Id() );
	cszCimName.Append ( SEPERATOR_STR );
	cszCimName.Append ( pGroup->ClassString() );
	cszCimName.Append ( BINDING_SUFFIX );

	cszCimName.RemoveNonAN ( );

	cbCim.Set(cszCimName);

	return TRUE;
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::MakeAttributeName( LONG lId , LPWSTR lpwszName , CString& cszCimName)
{
	cszCimName.Set( ATTRIBUTE_STR );	
	cszCimName.Append( lId );
//	cszCimName.Append ( SEPERATOR_STR );
//	cszCimName.Append( lpwszName );

//	cszCimName.RemoveNonAN ( );
	
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::MakeGroupName( CComponent* pComponent, 
							 CGroup* pGroup , CBstr& cbCim)
{
	MakeGroupName ( pComponent->Id() , pGroup , cbCim) ;
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::MakeGroupName( LONG lCompId, CGroup* pGroup , CBstr& cbCim)
{		
	CString cszCimName;

	// NOTE: per logan this guarentees uniqeness

	cszCimName.Set ( COMPONENT_STR );
	cszCimName.Append ( lCompId );
	cszCimName.Append ( SEPERATOR_STR );
	cszCimName.Append ( GROUP_STR );
	cszCimName.Append ( pGroup->Id() );
	cszCimName.Append ( SEPERATOR_STR );
	cszCimName.Append ( pGroup->ClassString() );
	
	cszCimName.RemoveNonAN ( );

	cbCim.Set(cszCimName);
}


// TODO: caution only 10 iterators per mapping now, needs work

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::GetNewCGAIterator(IWbemContext* pICtx , CIterator** ppNewIterator)
{	
	*ppNewIterator = new CIterator( m_pWbem->NWA( pICtx ) );

	if(! (*ppNewIterator))
	{
		throw CException ( WBEM_E_OUT_OF_MEMORY , IDS_GETITERATOR_FAIL ,
			IDS_NO_MEM );
	}
	
	for(int i = 0 ; i < ITERATOR_COUNT ; i++)
	{
		if (m_Iterators[i] == NULL)
		{
			m_Iterators[i] = *ppNewIterator;
			break;
		}
	}
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::MakeComponentInstancePath( CComponent* pComponent , 
										 CVariant& cvValue )
{
	WCHAR wszValue[256];

	swprintf(wszValue, BINDING_COMPONENT_VALUE_CONSTRUCT, COMPONENT_CLASS,
		pComponent->Id() );

	cvValue.Set((LPWSTR)wszValue);
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//  Out Params:
//
//
//	Note:
//
//***************************************************************************
void CMapping::MakeGroupInstancePath(CVariant& cvValue, CIterator* pIterator )
{
	CBstr		cbGroupName;	
	CString		cszRowPath;
	CString		cszKeys;

	pIterator->m_pCurrentRow->m_Attributes.MoveToHead ( );

	CAttribute* pA = NULL;
	BOOL		bFirst = TRUE;	

	while ( pA = pIterator->m_pCurrentRow->m_Attributes.Next () )
	{
		if ( bFirst )
		{
			cszKeys.Set ( L"." );

			bFirst = FALSE;
		}
			
		else
		{
			cszKeys.Append ( L",");
		}
		
		

		CString cszCimName;
		WCHAR	wszT[256];
		
		MakeAttributeName ( pA->Id() , pA->Name ( ) , cszCimName );

		cszKeys.Append ( cszCimName );

		if ( pA->Value().GetBstr() )
		{
			swprintf( wszT, L"=\"%s\"", pA->Value().GetBstr());
		}
		else
		{
			swprintf( wszT, L"=\"%s\"", pA->Value().GetBstr());
		}

		cszKeys.Append ( wszT );
	}

	MakeGroupName( pIterator->m_pCurrentComponent, 
		pIterator->m_pCurrentGroup , cbGroupName);

	
	cszRowPath.Set ( cbGroupName );	

	cszRowPath.Append ( cszKeys );

	cvValue.Set( cszRowPath );
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::MakeLanguageInstancePath(CVariant& cvValue, 
										CIterator* pIterator)
{
	WCHAR wszValue[256];

	swprintf(wszValue, LANGUAGE_INSTANCE_VALUE_CONSTRUCT , LANGUAGE_CLASS,
		LANGUAGE_PROP, pIterator->m_pCurrentLanguage->Language() );

	cvValue.Set((LPWSTR)wszValue);
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::DeleteInstance( CString& cszCimPath , IWbemContext* pICtx)
{
	CObjectPath	Path;
	CString		cszGroup , cszRowKeys;
	CVariant	cvClass , cvId;
	CCimObject	Instance;
	LONG		lComponentId;

	Path.Init ( cszCimPath );

	CString cszClass;
	
	cszClass.Set ( Path.ClassName() );
		
	if( cszClass.Equals ( NODE_CLASS )
		|| cszClass.Equals ( LANGUAGE_CLASS) 
		|| cszClass.Equals ( BINDING_ROOT )
		|| cszClass.Equals ( BINDING_ROOT) 
		|| cszClass.Equals ( GROUP_ROOT )
		|| cszClass.Equals ( COMPONENT_BINDING_CLASS)
		|| cszClass.Equals ( NODEDATA_BINDING_CLASS)
		|| cszClass.Equals ( LANGUAGE_BINDING_CLASS) )
	{
		throw CException ( WBEM_E_INVALID_OPERATION , IDS_DELINSTANCE_FAIL ,
			IDS_BADCLASS ) ;
			
	}

	if( cszClass.Equals( COMPONENT_CLASS ) )
	{
		// Deleting a component 

		lComponentId = Path.KeyValueUint(0);			

		if ( 1 == lComponentId)
		{
			throw CException ( WBEM_E_INVALID_OBJECT ,
				IDS_DELINSTANCE_FAIL , IDS_NOTON1 );
		}

		CComponent Component;

		Component.Get ( m_pWbem->NWA( pICtx ) , lComponentId );
		
		Component.Delete ( );

		return;
	}	

	
	// At this point we must be dealing with as row instance 
	CComponent		Component;
	CGroup			Group;
	CRow			Row;
	CAttributes		Keys;
	BOOL			bFound;

	dmiGetComponentAndGroup ( pICtx , cszClass , Component , Group);	

	Keys.ReadCimPath ( Path );

	Row.Get ( m_pWbem->NWA( pICtx ) , Component.Id() , Group.Id ( ) , Keys , &bFound );

	if ( FALSE == bFound )
	{
		throw CException ( WBEM_E_INVALID_OBJECT ,
			IDS_DELINSTANCE_FAIL , IDS_NOTON1 );
	}

	Row.Delete ( );
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::DeleteDynamicGroupClass(LPWSTR wszClassName, 
									   IWbemContext* pICtx )
{
	CVariant	cvPath;
	CComponent	Component;
	CGroup		Group;
	CString		cszClass;

	cszClass.Set ( wszClassName );


	dmiGetComponentAndGroup ( pICtx , cszClass , Component , Group);

	Group.Get ( m_pWbem->NWA( pICtx ) , Component.Id() , Group.Id () );

	Group.Delete ( );
}


// TODO: figure out which calls required connected mapping and connected dmi
//  engine and if necessary and make clear which arc connected ops and which
//  are not

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CMapping::dmiGetComponentAndGroup ( IWbemContext* pICtx , CString& cszClassName , 
										CComponent& Component , CGroup& Group )
{

	LPWSTR		p;
	CString		cszBuff;
	int			nReturn;
	LONG		lComponentId , lGroupId;
	
	// Put the component Id into a formate we will definately recognize in it
	// own buffer

	cszBuff.Set( cszClassName );				

	// truncate the string at the first underscore

	cszBuff.TruncateAtFirst( 95 );						

	nReturn = swscanf( cszBuff, SCAN_COMPONENTID_SEQUENCE , &lComponentId);

	if ( nReturn == 0 || nReturn == EOF )
	{
		throw CException ( WBEM_E_NOT_FOUND, 
			IDS_GETCG_FAIL , IDS_SCAN_FAIL , cszClassName) ;
	}

	// now get the group id	
	
	p = wcsstr ( cszClassName, GROUP_STR );

	if ( NULL == p ) 
	{
		throw CException ( WBEM_E_NOT_FOUND, 
			IDS_GETCG_FAIL , IDS_SCAN_FAIL ,cszClassName) ;
	}

	cszBuff.Set( p );				

	cszBuff.TruncateAtFirst( 95 );

	nReturn = swscanf( cszBuff, SCAN_GROUPID_SEQUENCE , &lGroupId);

	if ( nReturn == 0 || nReturn == EOF )
	{
		throw CException ( WBEM_E_NOT_FOUND , 
			IDS_GETCG_FAIL , IDS_SCAN_FAIL ,cszClassName) ;
	}

	// load the component group pair

	Component.Get ( m_pWbem->NWA( pICtx ), lComponentId );

	Group.Get ( m_pWbem->NWA( pICtx ), lComponentId, lGroupId );		

	// check the class string is correct
	CBstr		cbTemp;

	MakeGroupName ( &Component , &Group , cbTemp );

	// we use contains not equals here incase we are dealing
	// with a binding.

	if ( cszClassName.Contains ( cbTemp ) )
		return;

	throw CException ( WBEM_E_INVALID_CLASS , IDS_GETCG_FAIL , IDS_BADCLASSNAME );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\mapping.h ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/


#if !defined(__MAPPING_H__)
#define __MAPPING_H__


#include "Iterator.h"

#include "ObjectPath.h"

#define ITERATOR_COUNT	10

class CMapping
{
private:
	CIterator*			m_Iterators[ITERATOR_COUNT];

	LONG				m_lRefCount;
	BOOL				m_bFoundClass;

	LONG				m_lGroupCount;

	CWbemLoopBack*		m_pWbem;

	void				cimMakeGroupBindingClass( CCimObject& , CComponent* , 
											CGroup* , IWbemContext*);

	void				cimMakeGroupClass( long compid , CGroup* , 
											CCimObject& , IWbemContext* );

	void				cimMakeEnumInstance( CCimObject& , CEnum& , 
											CCimObject& );
	
	void				cimMakeGroupBindingInstance(CCimObject&, CIterator* );
	void				cimMakeGroupInstance(CCimObject&, CRow*, CCimObject&);
	void				cimMakeLanguageInstance(CCimObject&, CIterator* );

	void				cimMakeLanguageBindingInstance(CCimObject&, 
											CIterator*);

	void				cimMakeComponentBindingInstance(CCimObject&, 
											CComponent*, CCimObject&);	

	void				MakeGroupName( CComponent*, CGroup* , CBstr&);
	
	void 				MakeGroupName( LONG, CGroup* , CBstr&);

	BOOL				MakeGroupBindingName(CBstr&,CComponent*, CGroup*);	

	void				MakeAttributeName( LONG  , LPWSTR  , CString& );

	void				MakeGroupInstancePath(CVariant&, CIterator*);
	void				MakeComponentInstancePath( CComponent* , CVariant& );
	void				MakeLanguageInstancePath(CVariant&, CIterator*);

	void				AddStandardAssociationQualifiers( CCimObject&, LPWSTR);


	// for dynamic class iterators
	CIterator*			New();	

	void				dmiGetNextGroupOrRow( IWbemContext* , CString&, 
								CIterator*);

	void				dmiGetComponentGroupRowFromPath(  IWbemContext* ,
								CObjectPath& , CIterator*);		

	void				dmiGetComponentAndGroup ( IWbemContext* , CString& cszClassName , 
									CComponent& Component , CGroup& Group );


public:	
						CMapping();
						~CMapping();


	void				cimMakeComponentInstance(CCimObject&, CComponent&, CRow& ,
							CCimObject&);	

	void				Init( CWbemLoopBack*  , BSTR, IWbemContext*);
	
	void				GetNewCGAIterator( IWbemContext* , CIterator**);

	void				GetDynamicClassByName( CString&, CCimObject&, 
									CIterator* , IWbemContext* );

	void				GetInstanceByPath( LPWSTR, CCimObject&, CIterator* ,
									IWbemContext*);

	// Dynamic Cim Class Iterators
	void				NextDynamicBinding( CCimObject&, CIterator* , 
									IWbemContext*);

	void				NextDynamicGroup( CCimObject&,CIterator* , 
									IWbemContext*);

	void				NextDynamicInstance( CString&, CIterator*, IWbemContext* , CCimObject& );

	void				NextDynamicBindingInstance( IWbemContext* , 
								CCimObject&, CIterator*);

	void				NextDynamicGroupInstance( IWbemContext* , 
								CCimObject&, CIterator*);

	void				GetDynamicGroupClass ( long , CGroup& , CCimObject& );

	void				GetComponentClass( IWbemContext* , CCimObject& );			

	void				GetComponentInstance( CString&, IWbemContext* ,  CCimObject&);


	void				GetComponentBindingClass( IWbemContext* , CCimObject& );		


	void				GetLanguageClass( IWbemContext* pICtx , CCimObject&);

	void				GetLanguageInstance( CString&, IWbemContext* , CCimObject& );

	void				MakeLanguageInstance( CVariant& cvLanguage,  IWbemContext* , CCimObject& );

	void				GetGroupRootClass( CCimObject&, IWbemContext*);		

	void				GetBindingRootClass( CCimObject& , IWbemContext*);	

	void				GetLanguageBindingClass(CCimObject&, IWbemContext*);

	void				GetAddParamsClass( CCimObject&, IWbemContext* );

	void				GetDeleteLanguageParamsClass( CCimObject& Class , IWbemContext* );

	void				GetEnumParamsClass( CCimObject& Class , IWbemContext* );

	void				GetNodeDataInstance( CCimObject& , IWbemContext* );

	void				GetNodeDataClass( CCimObject& , IWbemContext* );

	void				GetNodeDataBindingInstance( CCimObject& , IWbemContext* );

	void				GetNodeDataBindingClass ( CCimObject& , IWbemContext* );

	void				GetEnumClass( IWbemContext* , CCimObject& );

	void				GetDmiEventClass( IWbemContext* pICtx , CCimObject& Class);

	void				GetGroupRowInstance ( CRow& , CCimObject& ) ;

	// Node Methods
	void				AddComponent( IWbemContext* , CCimObject&);
	void				SetDefaultLanguage( IWbemContext* , CCimObject& );

	// Component Methods
	void				AddLanguage( CString&, CCimObject&, IWbemContext* );

	void				AddGroup( CString&, CCimObject&, IWbemContext*);

	void				DeleteLanguage( CString&, CCimObject& , IWbemContext* );

	void				DynamicGroupGetEnum( CString&, CCimObject&, 
								CCimObject& , IWbemContext* );	

	void				ComponentGetEnum( CString&, CCimObject&, CCimObject& ,
									IWbemContext* );	

	void				ModifyInstanceOrAddRow( IWbemContext* , CCimObject&);	
	
	void 				GetNotifyStatusInstance( CCimObject&, ULONG, IWbemContext*);	// from CIMOM

	BOOL				GetExtendedStatusInstance( CCimObject& Instance, ULONG ulStatus, 
								BSTR bstrDescription, BSTR bstrOperation,
								BSTR bstrParameter, IWbemContext* pICtx );

	void 				DeleteDynamicGroupClass(LPWSTR, IWbemContext* );
	
	void				DeleteInstance( CString& , IWbemContext* );	


	LONG				Release()				{return (InterlockedDecrement(&m_lRefCount));}
	void				AddRef()				{InterlockedIncrement(&m_lRefCount);}

	CString				m_cszNamespace;

	CMapping*			m_pNext;
	CMapping*			m_pPrevious;	
};


class CMappings
{
private:
	CMapping*	m_pFirst;
	CMapping*	m_pCurrent;

public:
				CMappings();
				~CMappings();
	void		MoveToHead()			{m_pCurrent = m_pFirst;}
	void		Add(CMapping*);
	CMapping*	Next();
	void		Get( CWbemLoopBack* , CString&, CMapping**, IWbemContext*);
	void		Release(CMapping*);

};

#endif // __MAPPING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\motobjects.cpp ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/





#define	 WATCH_MOT_REF_COUNT	1

#include "dmipch.h"		// project wide include

#include "WbemDmiP.h"		// project wide include

#include "Trace.h"

#include "Exception.h"

#include "DmiData.h"

#include "MOTObjects.h"
//////////////////////////////////////////////////////////////////
//				SMART POINTERS 



CEnumVariantI::CEnumVariantI()		
{ 
#if	WATCH_MOT_REF_COUNT
		MOT_TRACE ( L"\t\t\tMOT ======== Enum Variant wrapper %lX construct" , this );
#endif

	p = NULL; 
}


CEnumVariantI::~CEnumVariantI()	
{ 
	Release ( );
}									

ULONG CEnumVariantI::Next( CVariant& va )
{
	ULONG			ulRet = 0;

	va.Clear();

	if (FAILED( p->Next( 1, va, &ulRet ) ))
	{
		throw CException ( WBEM_E_FAILED , IDS_MOT_ATTRIBUTES_FAIL , 
			IDS_NEXT_FAIL );
	}

	return ulRet;
}


void CEnumVariantI::Release(  )
{
	if ( p ) 
	{ 
		LONG l = p->Release() ;

#if	WATCH_MOT_REF_COUNT
		MOT_TRACE ( L"\t\t\tMOT ======== Enum Variant wrapper %lX Release = %lu" , this , l );
#endif

		p = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////


CUnknownI::CUnknownI()
{
#if	WATCH_MOT_REF_COUNT
		MOT_TRACE ( L"\t\t\tMOT ======== IUnknown wrapper %lX construct" , this );
#endif

	p = NULL;
}

CUnknownI::~CUnknownI()
{
	Release ();
}


void CUnknownI::Release ( )
{
	if ( p ) 
	{ 
		LONG l = p->Release() ;

#if	WATCH_MOT_REF_COUNT
		MOT_TRACE ( L"\t\t\tMOT ======== IUnknown wrapper %lX Release = %lu" , this , l );
#endif

		p = NULL;
	} 
}

CDEnumColI::CDEnumColI( )
{
#if	WATCH_MOT_REF_COUNT
		MOT_TRACE ( L"\t\t\tMOT ======== IEnumCol wrapper %lX construct" , this );
#endif

	p = NULL;
}


void CDEnumColI::Release( )
{
	if ( p ) 
	{ 
		LONG l = p->Release() ;

#if	WATCH_MOT_REF_COUNT
		MOT_TRACE ( L"\t\t\tMOT ======== IEnumCol wrapper %lX Release = %lu" , this , l );
#endif

		p = NULL;
	}
}


void CUnknownI::GetEnum( CEnumVariantI& Enum )
{
	Enum.Release ( );

	if ( FAILED ( p->QueryInterface( IID_IEnumVARIANT, Enum ) ))
	{
		throw CException ( WBEM_E_FAILED , IDS_MOT_ATTRIBUTES_FAIL , 
			IDS_QI_FAIL );
	}
}

CDAttributeI::CDAttributeI()
{
		p = NULL;  

#if	WATCH_MOT_REF_COUNT
		MOT_TRACE ( L"\t\t\t\tMOT ======== IAttribute wrapper %lX construct" , this);
#endif
}


void CDAttributeI::CoCreate ( )
{
	if ( FAILED ( CoCreateInstance (CLSID_DMIAttribute, NULL, EXE_TYPE,
		IID_IDualAttribute , (void**) &p ) ) )
	{
		throw CException ( WBEM_E_FAILED , IDS_GETCOMPONENT_FAIL , 
			IDS_CC_FAIL );
	}

}


void CDAttributeI::Read ( LPWSTR wszPath )
{
	SCODE			result = WBEM_NO_ERROR;
	CVariant		cvMask, cvPath;
	VARIANT_BOOL	vbRead;

	cvMask.Set( (LONG)READ_CONN_SP ); 
	
	cvPath.Set( wszPath );

	result = p->Read( cvPath, cvMask, &vbRead);

	if ( SUCCEEDED ( result ) &&  vbRead == VARIANT_TRUE )
	{
		return;
	}

	CString cszT ( result );

	throw CException ( WBEM_E_FAILED , IDS_MOT_READ_FAIL ,
		IDS_READ_FAIL , cszT );		
}


void CDAttributeI::GetDmiEnum ( CDEnumColI& DECI )
{
	SCODE			result = NO_ERROR;
	VARIANT_BOOL	vbResult = VARIANT_FALSE;

	DECI.Release();

	if( FAILED ( result = p->get_IsEnumeration( &vbResult ) ))
	{
		throw CException ( WBEM_E_FAILED , IDS_GETATTRIBENUM_FAIL , 
			IDS_GETISENUM_FAIL , CString ( result ) );	
	}

	if ( vbResult == VARIANT_FALSE )
	{
		throw CException ( WBEM_E_INVALID_OPERATION , 
			IDS_GETATTRIBENUM_FAIL , IDS_NOT_ENUM );	
	}

	if ( FAILED ( result = p->get_Enumerations( DECI ) ))
	{
		throw CException ( WBEM_E_FAILED , IDS_GETATTRIBENUM_FAIL ,
		IDS_GETENUMS_FAIL , CString ( result ) );
	}
}


void CDAttributeI::Release (  ) 			
{
	LONG	l;

	if ( p ) 
	{
		l = p->Release(); 

#if	WATCH_MOT_REF_COUNT
		MOT_TRACE ( L"\t\t\t\tMOT ======== IAttribute wrapper %lX Release = %lu" , this , l );
#endif		
		p = NULL;
	}


}



void CDAttributesI::Release ( )
{
	if ( p ) 
	{ 
		LONG l = p->Release() ;
	
		p = NULL;
	}
}

void CDAttributesI::Item ( LONG lAttribute , CDAttributeI& DAI )
{
	CVariant cvItem;

	cvItem.Set ( lAttribute );

	DAI.Release();

	if ( FAILED ( p->get_Item ( cvItem , DAI ) ))
	{
		throw CException ( WBEM_E_FAILED , IDS_GETATTRIBENUM_FAIL ,
			IDS_MOT_ATTRB_ITEM );
	}

}


void CDGroupI::QI ( CVariant& va )
{
	if ( FAILED ( va.GetDispId()->QueryInterface( IID_IDualGroup, (void**) &p )))
	{
		throw CException ( WBEM_E_FAILED, 
			IDS_MOT_GETGROUPS_FAIL , IDS_QI_FAIL );
	}
}


void CDGroupI::CoCreate ( )
{
	if ( FAILED ( CoCreateInstance (CLSID_DMIGroup, NULL, EXE_TYPE,
		IID_IDualGroup, ( void ** )  &p) ) )
	{
		throw CException ( WBEM_E_FAILED , IDS_GETGROUP_FAIL , IDS_CC_FAIL );	
	}
}

void CDGroupI::Read ( LPWSTR wszPath )
{
	SCODE			result = WBEM_NO_ERROR;
	CVariant		cvMask, cvPath;
	VARIANT_BOOL	vbRead;

	cvMask.Set( (LONG)READ_CONN_SP ); 
	cvPath.Set( wszPath );

	result = p->Read( cvPath, cvMask, &vbRead);

	if ( SUCCEEDED ( result ) &&  vbRead == VARIANT_TRUE )
		return;

	throw CException ( WBEM_E_FAILED , IDS_GETGROUP_FAIL , IDS_READ_FAIL , 
		wszPath);	
}


void CDGroupI::GetRows ( CDRowsI& DRSI )
{
	DRSI.Release();

	if(FAILED ( p->get_Rows( DRSI ) ))
	{
		throw CException ( WBEM_E_FAILED , IDS_MOT_FILLROWS_FAIL , 
			IDS_MOT_GETROWS_FAIL  );
	}
}


void CDGroupI::GetAttributes ( CDAttributesI& DASI )
{
	DASI.Release( );

	if ( FAILED ( p->get_Attributes ( DASI ) ) )
	{
		throw CException ( WBEM_E_FAILED , IDS_MOT_ATTRIBUTES_FAIL , 0 );
	}
}


void CDGroupsI::Release ( )
{
	if ( p )
	{ 
		LONG l = p->Release() ; 

		p = NULL;
	}
}


void CDGroupsI::Remove ( LONG lGroup )
{
	LONG	lCount1 , lCount2;
	SCODE	result = NO_ERROR;
	CVariant cvGroupId ( lGroup );

	if ( FAILED ( p->get_Count ( &lCount1) ))
	{
		throw CException ( WBEM_E_FAILED, IDS_DEL_GROUP_FAIL,
			IDS_GETCOUNT_FAIL );	
	}

	if (FAILED ( result = p->Remove( cvGroupId, &lCount2 ) ) )
	{
		throw CException ( WBEM_E_FAILED, IDS_DEL_GROUP_FAIL,
			IDS_REMOVE_FAIL , CString ( result) );	
	}

	if ( lCount2 >= lCount1 )
	{
		throw CException ( WBEM_E_FAILED , IDS_DEL_GROUP_FAIL, 
			IDS_COUNT_NOT_DEC );
	}
}


void CDGroupsI::Add	( CVariant& cvMifFile )
{
	LONG	lCount1 , lCount2;
	SCODE	result = NO_ERROR;
	if ( FAILED ( p->get_Count ( &lCount1) ))
	{
		throw CException ( WBEM_E_FAILED, IDS_MOT_GROUP_ADD_FAIL,
			IDS_GETCOUNT_FAIL );	
	}

	if (FAILED ( result = p->Add( cvMifFile, &lCount2) ) )
	{
		throw CException ( WBEM_E_FAILED, IDS_MOT_GROUP_ADD_FAIL,
			IDS_ADD_FAIL , CString ( result) );	
	}

	if ( lCount2 <= lCount1 )
	{
		throw CException ( WBEM_E_FAILED, IDS_MOT_GROUP_ADD_FAIL,
			IDS_COUNT_NOT_INC );
	}

}
void CDRowsI::Release ( )
{
	if ( p )
	{
		LONG l = p->Release() ; 

		p = NULL;
	}
}


void CDRowsI::Add ( CDRowI& DRI )
{
	LONG	lRowCount1 = 0, lRowCount2 = 0;
	SCODE	result;

	if ( FAILED ( p->get_Count ( &lRowCount1) ))
	{
		throw CException ( WBEM_E_FAILED, IDS_ADD_ROW_FAIL,
			IDS_GETCOUNT_FAIL );	
	}
	
	// Add the new row
	if ( FAILED ( result = p->Add( DRI, &lRowCount2) ))
	{
		throw CException ( WBEM_E_FAILED , IDS_ADD_ROW_FAIL,
			IDS_ADD_FAIL , CString ( result ) );	
	}

	if ( lRowCount2 <= lRowCount1 )
	{
		throw CException ( WBEM_E_FAILED , IDS_ADD_ROW_FAIL,
			IDS_COUNT_NOT_INC );
	}
}


void CDRowsI::Remove ( CAttributes* pKeys )
{
	SCODE	result = 0;
	long	lCount1 , lCount2;
	CRows	Rows;

	Rows.Read ( p );

	CRow* pRow;

	int i = 1;

	while ( pRow = Rows.Next() )
	{
		if ( pRow->m_Keys.Equal ( *pKeys ) )
			break;

		i++;
	}

	CVariant cvRowId;

	cvRowId.Set ( (long)i );

	if ( FAILED ( p->get_Count ( &lCount1) ))
	{
		throw CException ( WBEM_E_FAILED, 
			IDS_DEL_ROW_FAIL , IDS_GETCOUNT_FAIL );	
	}

	if ( FAILED ( result = p->Remove( cvRowId , &lCount2 ) ) )
	{				
		throw CException ( WBEM_E_FAILED,
			IDS_DEL_ROW_FAIL,
			IDS_REMOVE_FAIL,
			CString ( result ) );
	}

	if ( lCount2 >= lCount1 )
	{
		throw CException ( WBEM_E_FAILED,
			IDS_DEL_ROW_FAIL, IDS_COUNT_NOT_DEC );
	}

}


BOOL CDRowI::Read( LPWSTR wszPath )
{
	CVariant		cvMask , cvPath;
	VARIANT_BOOL	vbRead;

	cvMask.Set( (LONG)READ_CONN_SP ); 
	cvPath.Set( wszPath );

	SCODE hresult = p->Read( cvPath, cvMask, &vbRead);	

	// fail silently on puropse

	if ( vbRead == VARIANT_FALSE)
		return FALSE;

	return TRUE;
}

void CDRowI::CoCreate(  )
{
	if ( FAILED ( CoCreateInstance ( CLSID_DMIRow, NULL , EXE_TYPE , 
		IID_IDualRow , ( void ** )  &p )))
	{
		throw CException ( WBEM_E_FAILED , IDS_ADD_ROW_FAIL , 
			IDS_CC_FAIL );	
	}

}

void CDRowI::GetAttributes ( CDAttributesI& DASI )
{
	// Don't Orphan a previously assagned Interface pointer

	DASI.Release( );

	// Get the row's set of attribute interface pointers 

	p->get_Attributes ( DASI );
}


void CDRowI::GetKeys ( CDAttributesI& DASI )
{
	// Don't Orphan a previously assagned Interface pointer

	DASI.Release();

	// get the keys and their values

	p->get_KeyList ( DASI );
}



void CDLanguagesI::Release () 
{

	if ( p )
	{ 
		LONG l = p->Release() ;

		p = NULL;
	}
}


void CDLanguagesI::Add ( CString& cszLanguageMif )
{

	LONG				lCount1 = 0 , lCount2 = 0;
	SCODE				result = WBEM_NO_ERROR;

	if ( FAILED ( p->get_Count( &lCount1 ) ))
	{
		throw CException ( WBEM_E_FAILED, 
			IDS_LANGUAGE_ADD_FAIL, IDS_GETCOUNT_FAIL );	
	}

	CBstr cbLanguage;

	cbLanguage.Set ( cszLanguageMif );

	if ( FAILED ( result = p->Add( cbLanguage , &lCount2 ) ))
	{
		throw CException ( WBEM_E_FAILED , IDS_LANGUAGE_ADD_FAIL,
			IDS_ADD_FAIL , CString ( result ) ) ;
	}

	if ( lCount2 <= lCount1 )
	{
		throw CException ( WBEM_E_FAILED, IDS_LANGUAGE_ADD_FAIL, 
			IDS_COUNT_NOT_INC );
	}

}

void CDLanguagesI::Remove ( CString& cszLanguage )
{
	LONG		lCount1 , lCount2;
	CVariant	cvIdx;
	int			idx;
	BOOL		bFound = FALSE;
	SCODE		result = NO_ERROR;


	if ( FAILED ( p->get_Count( &lCount1 ) ))
	{
		throw CException ( WBEM_E_FAILED, 
			IDS_MOT_DEL_LANG_FAIL, IDS_GETCOUNT_FAIL );	
	}

	MOT_TRACE ( L"\tMOT...\tAbout to delete language, language count\
is = %lu" , lCount1);	

	for ( idx = 0 ; idx < lCount1 ; idx++)
	{
		CBstr		cbTemp;

		cvIdx.Set( (LONG)idx );

		if ( FAILED ( p->get_Item ( cvIdx , cbTemp ) ) )
		{
			throw CException ( WBEM_E_FAILED, IDS_MOT_DEL_LANG_FAIL, 
				IDS_GETITEM_FAIL , CString ( idx ) );				
		}

		if ( cszLanguage.Equals ( cbTemp ) )
		{
			bFound = TRUE;

			break;
		}
	}

	if ( bFound )
	{
		if ( FAILED ( result = p->Remove( cvIdx , &lCount2) ))
		{
			throw CException ( WBEM_E_INVALID_PARAMETER, 
				IDS_MOT_DEL_LANG_FAIL , IDS_REMOVE_FAIL , CString ( result ) );
		}	
/*
		MOT_TRACE ( L"\tMOT...\thave deleted language without error\
language count returned is = %lu" , lCount2);
*/
		if ( lCount2 >= lCount1 )
		{
			throw CException ( WBEM_E_FAILED,IDS_MOT_DEL_LANG_FAIL, 
				IDS_COUNT_NOT_DEC );
				
		}

		//next line is purely debug

		p->get_Count( &lCount1 );

//		MOT_TRACE ( L"\tMOT...\tlanguage count is now %lu" , lCount1);

	}
	else 
	{
		throw CException ( WBEM_E_FAILED, IDS_MOT_DEL_LANG_FAIL,
			IDS_LANG_NOT_FOUND , cszLanguage);

	}

}

/////////////////////////////////////////////////////////////////////////

void CDComponentI::QI ( CVariant& cvComponent )
{
	// don't orphan if previously assigned

	if ( p )
		p->Release();

	if ( FAILED ( cvComponent.GetDispId()->QueryInterface ( 
		IID_IDualComponent, (void ** )&p ) ))

	{
		throw CException ( WBEM_E_FAILED, IDS_MOT_COMPONENTS_READ,
			IDS_QI_FAIL );
	}
}


void CDComponentI::CoCreate (  )
{
	// don't orphan if previously assigned

	Release( );

	// Get the uninitialized Interface pointer to a mot
	// dmi component object

	if ( FAILED ( CoCreateInstance (CLSID_DMIComponent, NULL, EXE_TYPE,
		IID_IDualComponent, (void**) &p ) ) )
	{
		throw CException ( WBEM_E_FAILED , IDS_GETCOMPONENT_FAIL , 
			IDS_CC_FAIL );
	}
}

void CDComponentI::GetGroups ( CDGroupsI& DGI )
{
	// don't orphan if previously assigned

	DGI.Release ();

	// get this component's group collection

	if ( FAILED ( p->get_Groups( DGI ) ) )
	{
		throw CException ( WBEM_E_FAILED, IDS_MOT_GETGROUPS_FAIL ,
			IDS_MOT_GETGROUPSO_FAIL );
	}
}

void CDComponentI::GetLanguages ( CDLanguagesI& DLSI )
{
	SCODE	result = NO_ERROR;

	// don't orphan if previously assigned

	DLSI.Release ();

	// get this component's language collection

	if ( FAILED ( result = p->get_Languages( DLSI ) ))
	{
		throw CException ( WBEM_E_FAILED, 
			IDS_LANGUAGE_ADD_FAIL ,
			IDS_GETLANG_FAIL , CString ( result ) );
	}
}

void CDComponentI::Read( LPWSTR wszPath )
{
	SCODE			result = WBEM_NO_ERROR;
	CVariant		cvMask, cvPath;
	VARIANT_BOOL	vbRead;

	cvMask.Set( (LONG)READ_CONN_SP ); 
	cvPath.Set( wszPath );


	result = p->Read( cvPath, cvMask, &vbRead);

	if ( SUCCEEDED ( result ) &&  vbRead == VARIANT_TRUE )
	{
		return;
	}

	CString cszT ( result );

	throw CException ( WBEM_E_FAILED , IDS_MOT_COMPONENT_READ_FAIL ,
		IDS_READ_FAIL , cszT );		
}


void CDComponentI::Release ( )
{
	if ( p ) 
	{
		LONG l = p->Release(); 

		MOT_TRACE ( L"\t\tMOT ======== Components wrapper %lX Release = %lu" , this , l );
	}

	p = NULL;
}
////////////////////////////////////////////////////////////////////////

CDComponentsI::CDComponentsI()
{
	MOT_TRACE ( L"\t\tMOT ======== Components wrapper %lx created", this );

	p = NULL;
}

CDComponentsI::~CDComponentsI()	
{ 
	Release ();
}

void CDComponentsI::GetUnk ( CUnknownI& Unk )
{
	// don't orphan if previously assigned

	Unk.Release ();

	// get this component's collection enum 

	if ( FAILED ( p->get__NewEnum( Unk ) ))
	{
		throw CException ( WBEM_E_FAILED, IDS_MOT_COMPONENTS_READ, 
			IDS_MOT_GETNEWENUM_FAIL );
	}
}

void CDComponentsI::Remove ( CVariant& cvId )
{
	LONG				lCount1 = 0 , lCount2 = 0;
	SCODE				result = WBEM_NO_ERROR;

	if ( FAILED ( p->get_Count ( &lCount1) ))
	{
		throw CException ( WBEM_E_FAILED, IDS_DEL_COMPONENT_FAIL ,
			IDS_GETCOUNT_FAIL );	
	}

	if ( FAILED ( result = p->Remove( cvId, &lCount2 ) ) )
	{
		throw CException ( WBEM_E_FAILED, IDS_DEL_COMPONENT_FAIL ,
			IDS_REMOVE_FAIL , CString ( result ) );
	}

	if ( lCount2 >= lCount1 )
	{
		throw CException ( WBEM_E_FAILED, IDS_DEL_COMPONENT_FAIL ,
			IDS_COUNT_NOT_DEC );
	}

}


void CDComponentsI::Add ( CVariant& cvFile )
{

	LONG				lCount2 = 0, lCount1 = 0;
	SCODE				result = WBEM_NO_ERROR;

	if ( FAILED ( p->get_Count ( &lCount1 ) ))
	{
		throw CException ( WBEM_E_FAILED,
			IDS_MOT_COMPONENT_ADD_FAIL , IDS_GETCOUNT_FAIL );
	}

	if ( FAILED ( result = p->Add(cvFile, &lCount2) ))
	{
		CString cszT ( result );

		throw CException ( WBEM_E_FAILED, 
			IDS_MOT_COMPONENT_ADD_FAIL , IDS_MOT_ADD_FAIL , cszT );
			 
	}

	if ( lCount2 <= lCount1 )
	{
		throw CException ( WBEM_E_FAILED, IDS_MOT_COMPONENT_ADD_FAIL,
			IDS_COUNT_NOT_INC );
	}
}


////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////


CDMgmtNodeI::CDMgmtNodeI()
{
	p = NULL;
}

CDMgmtNodeI::~CDMgmtNodeI()
{ 
	if ( p ) 
	{ 
		LONG l = p->Release();		
	} 
}


void CDMgmtNodeI::CoCreate(  )
{
	if ( FAILED ( 
			CoCreateInstance (CLSID_DMIMgmtNode, NULL, EXE_TYPE, 
				IID_IDualMgmtNode, (void**) &p ) 
				) )
	{
		throw CException ( WBEM_E_FAILED , IDS_GETNODE_FAIL , IDS_CC_FAIL );	
	}

}


void CDMgmtNodeI::Read ( LPWSTR  wszPath )
{
	SCODE			result = WBEM_NO_ERROR;
	CVariant		cvMask, cvPath;
	VARIANT_BOOL	vbRead;

	cvMask.Set( (LONG)READ_CONN_SP ); 
	cvPath.Set( wszPath );

	result = p->Read( cvPath, cvMask, &vbRead);

	if ( SUCCEEDED ( result ) &&  vbRead == VARIANT_TRUE )
	{
		return;
	}

	CString cszT ( result );

	throw CException ( WBEM_E_FAILED , IDS_GETNODE_FAIL ,
		IDS_READ_FAIL , cszT );		


}


void CDMgmtNodeI::GetComponents( CDComponentsI& DCSI )
{ 

	SCODE result = 0;

	if ( FAILED ( result = 	p->get_Components( DCSI ) ))
	{
		CString cszT ( result );

		throw CException ( WBEM_E_FAILED, IDS_MOT_COMPONENT_ADD_FAIL ,
			IDS_MOT_GETCOMPONENTSO_FAIL , cszT );
			
	}

	MOT_TRACE ( L"\t\tMOT ======== Components wrapper %lx obtained Interface pointer from node" , DCSI );
}


void CDMgmtNodeI::GetLanguage( CBstr& cbLanguage )
{ 
	cbLanguage.Clear ( );

	if ( FAILED ( p->get_Language( cbLanguage ) ))
	{
		throw CException ( WBEM_E_FAILED , IDS_READNODE_FAIL , 
			IDS_GETLANG_FAIL );
	}
}

void CDMgmtNodeI::PutLanguage( const BSTR bstrLanguage )
{ 
	SCODE	result = NO_ERROR;

	if ( FAILED ( result = p->put_Language( bstrLanguage ) ))
	{
		CString cszT ( result );

		throw CException( WBEM_E_FAILED , IDS_MOT_SETDEFLANG_FAIL  , 
			IDS_MOT_PUTLANG_FAIL, cszT );			
	}

}


void CDMgmtNodeI::GetVersion( CBstr& cbVersion )
{ 
	cbVersion.Clear ( );

	if ( FAILED ( p->get_Version( cbVersion ) ) )
	{
		throw CException ( WBEM_E_FAILED , IDS_READNODE_FAIL , 
			IDS_GETVER_FAIL );
	}
}


void CDMgmtNodeI::AddComponent ( CVariant&  cvMifFile )
{ 
	CDComponentsI DCSI;

	GetComponents( DCSI );

	DCSI.Add ( cvMifFile );
}

void CDMgmtNodeI::DeleteComponent ( LONG lId )
{ 
	CDComponentsI		DCSI;
	CVariant			cvId;

	cvId.Set ( lId );

	GetComponents( DCSI );

	try
	{
		DCSI.Remove ( cvId );	
	}
	catch ( CException& e)
	{
		// for some reason the release order is important even though
		// ref count goes to zero, If we don't through out of here there
		// is not problem
		Release ();
		DCSI.Release ();
		throw CException ( e.WbemError() , e.DescriptionId() , e.OperationId() );
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\objectpath.h ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/


#if !defined( __OBJECTPATH_H__)
#define __OBJECTPATH_H__

class CObjectPath
{
private:
	LPWSTR	m_pClassName;
	LPWSTR	m_pBuffer;
	LPWSTR	m_pKeys;
	LPWSTR*	m_KeyValue;
	LPWSTR*	m_KeyName;
	LONG	m_lKeyCount;
	BOOL	m_bSingleton;

public:
			CObjectPath();
			~CObjectPath();
	void	Init(LPCWSTR);
	UINT	KeyValueUint(int i);
	LPWSTR	KeyValue(int i)		{return m_KeyValue[i];}
	LPWSTR	KeyName(int i)		{return m_KeyName[i];}
	LONG	KeyCount()			{return m_lKeyCount;}

	LPWSTR	ClassName()			{return m_pClassName;}

	BOOL	SingletonInstance()	{ return m_bSingleton;}
};

#endif // __OBJECTPATH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\objectpath.cpp ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/




#include "dmipch.h"			// precompiled header for dmip

#include "wbemdmip.h"

#include "ObjectPath.h"

#include "Exception.h"



//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CObjectPath::~CObjectPath()
{
	delete [] m_KeyValue;
	m_KeyValue = NULL;

	delete [] m_KeyName;
	m_KeyName = NULL;

	delete [] m_pBuffer;
	m_pBuffer = NULL;

}

CObjectPath::CObjectPath()
{
	m_pBuffer = NULL;
	m_KeyValue = NULL;
	m_KeyName = NULL;
	m_lKeyCount = 0;

	m_bSingleton = FALSE;
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CObjectPath::Init(LPCWSTR pwstrPath)
{
	LPWSTR		p, q;
	LONG		i = 1;	

	m_lKeyCount = 0;
	m_KeyValue = NULL;
	m_KeyName = NULL;


	// NOTE: this parser does not account for white space in path string.
	// nor does it check path syntax
	
	p = ( LPWSTR )pwstrPath;

	// determine len of path

	while(*p)								
	{
		p++;
		i++;
	}	
	
	// alloc buffer

	m_pBuffer = new WCHAR[i];			

	if (!m_pBuffer)
	{
		throw CException ( WBEM_E_OUT_OF_MEMORY , 
			IDS_GET_OBJECTPATH_FAIL , 0 );
	}
	
	// copy path to buffer

	p = (LPWSTR)pwstrPath;							
	q = m_pBuffer;

	while(*p)
		*q++ = *p++;

	*q = NULL;
	
	// set the m_pClassName ptr 

	m_pClassName = m_pBuffer;				

	// insert the null terminateing the ClassNaem

	if ( q = wcsstr ( m_pClassName , L"=@") )
	{
		// special case paths to singleton classes

		m_bSingleton = TRUE;

		*q = 0;

		return;

	}


	q = m_pBuffer;							
	while (*q)
	{
		if (*q == 0X2E )					// a "."
		{
			*q = NULL;
			break;
		}

		q++;
	}

	m_pKeys = ++q;				

	// count keys	
	
	while (*q)								
	{
		if (*q++ == 0X3D)						// a "="
			m_lKeyCount++;
	}

	m_KeyName = new LPWSTR[m_lKeyCount];
	m_KeyValue = new LPWSTR[m_lKeyCount];

	if(!m_KeyName || !m_KeyValue)
	{
		throw CException ( WBEM_E_OUT_OF_MEMORY , 
			IDS_GET_OBJECTPATH_FAIL , 0 );
	}

	// point into buffer

	q = m_pKeys;							
	i = 0;
	m_KeyName[i] = m_pKeys;

	while(*q)
	{
		if(*q == 0X3D)					// if = char
		{
			// null term and move to next char

			*q++ = 0X00;				
			
			if(*q == 0X22)				
			{
				// if open qoute
				
				m_KeyValue[i] = ++q;
				
				while ( *q )
				{
					if ( *q == 0X22 )
					{
						*q++ = 0;

						break;
					}

					q++;
				}
			}
			else
			{
				// if val
				m_KeyValue[i] = q++;
				
				while ( *q )
				{
					if ( *q == COMMA_CODE )
					{
						*q++ = 0;

						break;
					}

					q++;
				}

			}

			i++;

			// if next char is comma more keys follow 
			if ( *q == 0X2C )
			{
				*q++ = 0;

				m_KeyName[i] = q;

				continue;
			}
			else
			{
				break;
			}

		}

		q++;
	}
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
UINT CObjectPath::KeyValueUint(int i)
{
	long l = 0;

	swscanf( *m_KeyValue , L"%u",  &l);	

	return l;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\services.h ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/


#if !defined(__SERVICES_H__)
#define __SERVICES_H__


LPWSTR GetObjectPathFromMachinePath(LPWSTR pString);

// Provider interfaces are provided by objects of this class 
class CServices : public IWbemServices , public IWbemProviderInit
{
private:
	CString				m_cszNamespace;
	

protected:
	LONG				m_cRef;         //Object reference count
    IWbemServices*		m_pGateway;

public:
						CServices(BSTR ObjectPath = NULL);
						~CServices(void);

	//Non-delegated IUnknown Methods
    STDMETHODIMP			QueryInterface(REFIID, void**);
    STDMETHODIMP_(ULONG)	AddRef(void);
    STDMETHODIMP_(ULONG)	Release(void);

    //Implmented IWbemServices Methods
	STDMETHOD	(CreateClassEnumAsync)(THIS_ BSTR Superclass, long lFlags, IWbemContext*, IWbemObjectSink FAR*);
    STDMETHOD	(GetObjectAsync)(THIS_ BSTR ObjectPath, long lFlags, IWbemContext *pCtx, IWbemObjectSink FAR* pSink);
    STDMETHOD	(CreateInstanceEnumAsync)(THIS_ BSTR Class, long lFlags, IWbemContext*, IWbemObjectSink FAR* pSink);
	STDMETHOD	(OpenNamespace)(THIS_ BSTR Namespace, long lFlags, IWbemContext *pCtx, IWbemServices FAR* FAR* ppNewContext, IWbemCallResult FAR* FAR* ppErrorObject);     
	STDMETHOD	(DeleteClassAsync)(THIS_ BSTR Class, long lFlags, IWbemContext *pCtx, IWbemObjectSink FAR* pSink);
	STDMETHOD	(DeleteInstanceAsync)(THIS_ BSTR ObjectPath, long lFlags, IWbemContext*, IWbemObjectSink FAR* pSink);
	STDMETHOD	(ExecMethodAsync)(THIS_ BSTR, BSTR, long, IWbemContext*, IWbemClassObject*, IWbemObjectSink*);
	STDMETHOD	(PutInstanceAsync)(THIS_ IWbemClassObject FAR*, long, IWbemContext*, IWbemObjectSink FAR*);

    //Unimplmented IWbemServices Methods
	STDMETHOD	(CancelAsyncCall)(IWbemObjectSink *pSink) 																					{return WBEM_E_NOT_SUPPORTED;}
	STDMETHOD	(QueryObjectSink)(long lFlags, IWbemObjectSink **ppResponseHandler)															{return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD	(GetObject)(THIS_ BSTR ObjectPath, long lFlags, IWbemContext* pCtx, IWbemClassObject **ppObject, IWbemCallResult **)		{return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD	(CreateInstanceEnum)(THIS_ BSTR Class, long lFlags, IWbemContext*, IEnumWbemClassObject FAR* FAR* ppEnum)					{return WBEM_E_NOT_SUPPORTED;}
	STDMETHOD	(QueryObjectSink)(THIS_ IWbemObjectSink FAR* FAR* ppSink, IWbemClassObject FAR* FAR* ppErrorObject)							{return WBEM_E_NOT_SUPPORTED;}
	STDMETHOD	(PutClass)(THIS_ IWbemClassObject FAR* pObject, long lFlags, IWbemContext *pCtx, IWbemCallResult **ppCallResult)			{return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD	(DeleteClass)(THIS_ BSTR Class, long lFlags, IWbemContext *pCtx, IWbemCallResult **ppCallResult)							{return WBEM_E_NOT_SUPPORTED;}	
    STDMETHOD	(CreateClassEnum)(THIS_ BSTR Superclass, long lFlags, IWbemContext *pCtx, IEnumWbemClassObject FAR* FAR* ppEnum)			{return WBEM_E_NOT_SUPPORTED;}
  	STDMETHOD	(PutInstance)(THIS_ IWbemClassObject FAR* pInst, long lFlags, IWbemContext *pCtx, IWbemCallResult **ppCallResult)			{return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD	(DeleteInstance)(THIS_ BSTR ObjectPath, long lFlags, IWbemContext*, IWbemCallResult **)										{return WBEM_E_NOT_SUPPORTED;}
	STDMETHOD	(ExecQuery)(THIS_ BSTR QueryLanguage, BSTR Query, long lFlags, IWbemContext*, IEnumWbemClassObject FAR* FAR* ppEnum)		{return WBEM_E_NOT_SUPPORTED;}
	STDMETHOD	(ExecQueryAsync)(THIS_ BSTR, BSTR, long, IWbemContext*, IWbemObjectSink FAR* )												{return WBEM_E_NOT_SUPPORTED;}
	STDMETHOD	(ExecNotificationQueryAsync)(THIS_ BSTR, BSTR, long, IWbemContext*, IWbemObjectSink * )										{return WBEM_E_NOT_SUPPORTED;}
	STDMETHOD	(ExecNotificationQuery)(THIS_ BSTR, BSTR, long, IWbemContext*, IEnumWbemClassObject ** )									{return WBEM_E_NOT_SUPPORTED;}	
	STDMETHOD	(ExecMethod)(THIS_ BSTR, BSTR, long, IWbemContext*, IWbemClassObject*, IWbemClassObject **, IWbemCallResult**)				{return WBEM_E_NOT_SUPPORTED;}
	STDMETHOD	(PutClassAsync)(THIS_ IWbemClassObject FAR* , long , IWbemContext *, IWbemObjectSink FAR* )									{return WBEM_E_NOT_SUPPORTED;}

		/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (
		/* [in] */ LPWSTR pszUser,
		/* [in] */ LONG lFlags,
		/* [in] */ LPWSTR pszNamespace,
		/* [in] */ LPWSTR pszLocale,
		/* [in] */ IWbemServices *pCIMOM,         // For anybody
		/* [in] */ IWbemContext *pCtx,
		/* [in] */ IWbemProviderInitSink *pInitSink     // For init signals
	);

	CWbemLoopBack		m_Wbem;
};


#endif // __SERVICES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\services.cpp ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/



//***************************************************************************
//
//  DmiIServ.CPP
//	(DMI IServices)
//
//  Module: CIMOM DMI Instance provider
//
//  Purpose: implements the required IWbemServices Meth_gDebug.ODS for 
//           the dynamic DMI Instance provider
//
//
//***************************************************************************


#include "dmipch.h"

#include "WbemDmiP.h"		// project wide include

#include "Strings.h"

#include "CimClass.h"

#include "DmiData.h"

#include "WbemLoopBack.h"

#include "Services.h"

#include "AsyncJob.h"		// must preeced ThreadMgr.h

#include "Trace.h"

#include "DmiInterface.h"

#include "Mapping.h"

#include "Threadmgr.h"		// For CThreadManager class



//////////////////////////////////////////////////////////////////
//		FILE SCOPE GLOBALS


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CServices::CServices(BSTR bstrPath)
{

    m_pGateway = NULL;
    m_cRef=0;

	extern CDmiInterface* _gDmiInterface;
	extern CConnections* _fConnections;
	extern CMappings*	_gMappings;
	extern CThreadManager* _fThreadMgr;

	DEV_TRACE ( L"CServices::CServices(%s)", bstrPath );

	// If this is the only instance of CServices, then initialize the critical section. 
	// We want to make sure that we only initialize the critical section only once.
	if ( !_gcObj )
	{
		InitializeCriticalSection( &_gcsJobCriticalSection );
	}

	InterlockedIncrement(&_gcObj);
    
	if ( !_gDmiInterface )
	{
		_gDmiInterface = new CDmiInterface;
	}

	if ( !_fConnections )
	{
		_fConnections = new CConnections;
	}

	if ( !_gMappings )
	{
		_gMappings = new CMappings;
	}

	if ( !_fThreadMgr )
	{
		_fThreadMgr = new CThreadManager;
	}

    return;
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CServices::~CServices ( void )
{

	DEV_TRACE ( L"CServices::~CServices()" );

	// If the object count is 0, meaning that CIMOM is unloading us, then
	// release the critical section.
	if ( !_gcObj )
	{
		DeleteCriticalSection( &_gcsJobCriticalSection );
	}
	m_pGateway->Release () ;
	
    return;
}

//***************************************************************************
//
// CServices::QueryInterface
// CServices::AddRef
// CServices::Release
//
// Purpose: IUnknown members for CServices object.
//***************************************************************************
STDMETHODIMP CServices::QueryInterface(REFIID riid, void** ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid )
	{ 
        *ppv=this;
	}
	else if ( IID_IWbemServices == riid )
	{
		*ppv = ( IWbemServices * ) this ;
	}
	else if ( IID_IWbemProviderInit == riid )
	{
		*ppv = ( IWbemProviderInit * ) this ;
	}

    if (NULL!=*ppv) 
	{
        AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CServices::AddRef ( void )
{

	return InterlockedIncrement ( & m_cRef );

}

STDMETHODIMP_(ULONG) CServices::Release ( void )
{
	extern CDmiInterface* _gDmiInterface;
	extern CConnections* _fConnections;
	extern CMappings*	_gMappings;
	extern CThreadManager* _fThreadMgr;
	
	if ( 0L != InterlockedDecrement ( & m_cRef ) )
        return m_cRef;

    if ( 0L != InterlockedDecrement(&_gcObj) )
		return _gcObj;

    // refernce count is zero, delete this object.
	if ( _gDmiInterface )
	{
		// note this clean up needs to be here ( while 
		// cimom trhead is still around ).  cleanup does
		// not work if you put it in process detatch

		_gDmiInterface->ShutDown ( );

		delete ( _gDmiInterface );

		_gDmiInterface = NULL;
	}

	
	if ( _gMappings )
	{
		delete ( _gMappings );

		_gMappings = NULL;
	}

	if ( _fThreadMgr )
	{
		delete ( _fThreadMgr );

		_fThreadMgr = NULL;
	}

	if ( _fConnections )
	{
		_fConnections->ClearAll ( );

		delete ( _fConnections );

		_fConnections = NULL;
	}

    delete this;

    return WBEM_NO_ERROR;
}



//***************************************************************************
//
//	Func:	CServices::OpenNamespace
//	Purpose:Allow provider an opportunity to get a pointer to the Mo Server
//          and to open an appropriate context.  
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
SCODE CServices::OpenNamespace(	BSTR bstrPath, long lFlags, 
							   IWbemContext* pICtx, 
							   IWbemServices FAR* FAR* ppNewContext, 
							   IWbemCallResult FAR* FAR* ppErrorObject) 
{
    SCODE result = WBEM_NO_ERROR;
    return result;
}

//***************************************************************************
//
// CServices::CreateClassEnumAsync
//
// Purpose: enumerates the CIMOM DMI classes.  
//
//***************************************************************************
//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
SCODE	CServices::CreateClassEnumAsync(BSTR SuperClass, long lFlags, 
										IWbemContext* pICtx, 
										IWbemObjectSink* pISink)
{	

	STAT_TRACE ( L"CIMOM called CreateClassEnumAsync( SuperClass is %s , \
Flags = %lX )", SuperClass , lFlags);

	
	// Check for requried Params
    if(pISink == NULL)
        return WBEM_E_INVALID_PARAMETER;

	if(lFlags != WBEM_FLAG_DEEP && lFlags != WBEM_FLAG_SHALLOW)
		return WBEM_E_INVALID_PARAMETER;

	if ( CAsyncJob::SystemClass( SuperClass ) )
	{
		pISink->SetStatus ( NO_FLAGS , WBEM_E_NOT_FOUND , NULL , NULL );
		return WBEM_S_NO_ERROR ;	
	}

    // verify CIMOM loopback gateway is available
	if(m_pGateway == NULL)
	{		
		pISink->SetStatus ( NO_FLAGS , WBEM_E_FAILED , NULL , NULL );
		return WBEM_S_NO_ERROR ;	
	}

	// If WBEM is sending the machine name, extract the object name from it
	CString cszObjectPath( SuperClass );
	if( cszObjectPath.Contains ( L":") )			
	{
		cszObjectPath.GetObjectPathFromMachinePath( (LPWSTR) SuperClass );
	}


	// Allocate a new job context and check for system classes.
	CAsyncJob* pJob = new CAsyncJob();

	// init the job context with the pertinant data
	return pJob->InitCreateClass ( m_cszNamespace , SuperClass , pISink , 
		lFlags , pICtx , &m_Wbem );		
}



//***************************************************************************
//
// CServices::GetObjectAsync
//
// Purpose: Creates an instance given a particular path value.
//
//***************************************************************************
//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
SCODE CServices::GetObjectAsync(BSTR ObjectPath, long lFlags, 
								IWbemContext* pICtx, 
								IWbemObjectSink FAR* pISink)
{

	STAT_TRACE ( L"CIMOM called GetObjectAsync( ObjectPath is %s )" , ObjectPath );

    // Check for requried Params
	if( ObjectPath == NULL || pISink == NULL )
        return WBEM_E_INVALID_PARAMETER;


	// If WBEM is sending the machine name, extract the object name from it
	CString cszObjectPath( ObjectPath );
	if( cszObjectPath.Contains ( L":") )			
	{
		cszObjectPath.GetObjectPathFromMachinePath( (LPWSTR) ObjectPath );
		cszObjectPath.Set( ObjectPath );
	}

	// If WBEM is asking for DmiNode, say we don't support it
	if( cszObjectPath.Contains ( DMI_NODE ) )			
	{
		if( cszObjectPath.Equals ( DMI_NODE ) )			
			return WBEM_E_NOT_FOUND;
	}

	if ( CAsyncJob::SystemClass( ObjectPath ) )
	{
		pISink->SetStatus ( NO_FLAGS , WBEM_E_NOT_FOUND , NULL , NULL );
		return WBEM_S_NO_ERROR ;
	}

	// No need the to check flags.  For GetObjectAsync the CIMOM docs state 
	// lFlags is reserved
	
	// verify CIMOM loopback gateway is available
	if(m_pGateway == NULL)
	{
		pISink->SetStatus ( NO_FLAGS , WBEM_E_FAILED, NULL , NULL );
        return WBEM_S_NO_ERROR ;
	}

	// Allocate a new job context and check for system classes.
	CAsyncJob* pJob = new CAsyncJob();

	// init the job context with the pertinant data
	return pJob->InitGetObject ( m_cszNamespace , ObjectPath , pISink ,
		lFlags , pICtx , &m_Wbem  );		
}


//***************************************************************************
//
// CServices::CreateInstanceEnumAsync
//
// Purpose: Asynchronously enumerates the instances.  
//
//***************************************************************************
//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
SCODE CServices::CreateInstanceEnumAsync( BSTR ObjectClass, long lFlags, 
										 IWbemContext* pICtx, 
										 IWbemObjectSink FAR* pISink)
{

	STAT_TRACE ( L"CIMOM called CreateInstanceEnumAsync( ObjectClass is %s , \
Flags = %lX )", ObjectClass , lFlags );	

    // Check for requried Params
	if(ObjectClass == NULL || pISink == NULL)
        return WBEM_E_INVALID_PARAMETER;
	
	if( MATCH == wcscmp(ObjectClass, EMPTY_STR))
		return WBEM_E_INVALID_PARAMETER;

	// Check flags are acceptable
	if(lFlags != WBEM_FLAG_DEEP && lFlags != WBEM_FLAG_SHALLOW)
		return WBEM_E_INVALID_PARAMETER;

	// verify CIMOM loopback gateway is available
	if(m_pGateway == NULL)
        return WBEM_E_FAILED;

	// If WBEM is sending the machine name, extract the object name from it
	CString cszObjectPath( ObjectClass );
	if( cszObjectPath.Contains ( L":") )			
	{
		cszObjectPath.GetObjectPathFromMachinePath( (LPWSTR) ObjectClass );
	}

	// alloc new job context
	CAsyncJob* pJob = new CAsyncJob();

	// init the job context with the pertinant data
	return pJob->InitInstanceEnum ( m_cszNamespace , ObjectClass , pISink , 
		lFlags , pICtx , &m_Wbem  );		
}

 

//***************************************************************************
//
// CServices::
//
// Purpose: 
//
//***************************************************************************
//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
SCODE CServices::DeleteInstanceAsync(BSTR ObjectPath, long lFlags, 
									 IWbemContext* pICtx, 
									 IWbemObjectSink FAR* pISink)					
{

	STAT_TRACE ( L"CIMOM called DeleteInstanceAsync( ObjectPath is %s , \
Flags = %lX )" , ObjectPath , lFlags );


    // Check for requried Params
	if(ObjectPath == NULL || pISink == NULL)
        return WBEM_E_INVALID_PARAMETER;


	if(MATCH == wcscmp(ObjectPath, EMPTY_STR))
		return WBEM_E_INVALID_PARAMETER;	
	
	// verify CIMOM loopback gateway is available
	if(m_pGateway == NULL)
        return WBEM_E_FAILED;

	// If WBEM is sending the machine name, extract the object name from it
	CString cszObjectPath( ObjectPath );
	if( cszObjectPath.Contains ( L":") )			
	{
		cszObjectPath.GetObjectPathFromMachinePath( (LPWSTR) ObjectPath );
		cszObjectPath.Set( ObjectPath );
	}

	// alloc new job context
	CAsyncJob* pJob = new CAsyncJob();

	// init the job context with the pertinant data
	return pJob->InitDeleteInstace ( m_cszNamespace , ObjectPath, pISink ,
		lFlags , pICtx , &m_Wbem );
}

//***************************************************************************
//
// CServices::
//
// Purpose: 
//
//***************************************************************************

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
SCODE CServices::PutInstanceAsync( IWbemClassObject FAR* pInst, long lFlags, 
								  IWbemContext*pICtx, 
								  IWbemObjectSink FAR* pISink)
{

	STAT_TRACE ( L"CIMOM called PutInstance( Flags = %lX )" , lFlags );

    // Check for requried Params
	if(pInst == NULL || pISink == NULL)
        return WBEM_E_INVALID_PARAMETER;

	// Check flags are acceptable
	if(lFlags != WBEM_FLAG_UPDATE_ONLY && lFlags != WBEM_FLAG_CREATE_ONLY 
		&& lFlags != WBEM_FLAG_CREATE_OR_UPDATE )
		return WBEM_E_INVALID_PARAMETER;
	
	// verify CIMOM loopback gateway is available
	if(m_pGateway == NULL)
        return WBEM_E_FAILED;

	// alloc new job context
	CAsyncJob* pJob = new CAsyncJob();

	// init the job context with the pertinant data

	return pJob->InitPutInstance (  m_cszNamespace , pInst , pISink , 
		pICtx , &m_Wbem );

}

//***************************************************************************
//
// CServices::
//
// Purpose: 
//
//***************************************************************************

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
SCODE CServices::ExecMethodAsync(BSTR ObjectPath, BSTR Method, long lFlags, 
								 IWbemContext *pICtx, 
								 IWbemClassObject* pInParams, 
								 IWbemObjectSink FAR* pISink)				
{

	STAT_TRACE ( L"CIMOM called ExecMethodAsync( ObectPath is %s , Method is %s )",
		ObjectPath , Method );

    // Check for requried Params
	if(ObjectPath == NULL || pISink == NULL || Method == NULL)
        return WBEM_E_INVALID_PARAMETER;

	// Check flags are acceptable
//	if(lFlags != 0 )
//		return WBEM_E_INVALID_PARAMETER;
	
	// verify CIMOM loopback gateway is available
	if(m_pGateway == NULL)
        return WBEM_E_FAILED;


	// If WBEM is sending the machine name, extract the object name from it
	CString cszObjectPath( ObjectPath );
	if( cszObjectPath.Contains ( L":") )			
	{
		cszObjectPath.GetObjectPathFromMachinePath( (LPWSTR) ObjectPath );
		cszObjectPath.Set( ObjectPath );
	}

	// alloc new job context
	CAsyncJob* pJob = new CAsyncJob();

	// init the job context with the pertinant data
	return pJob->InitExecMethod ( m_cszNamespace , Method , ObjectPath , 
		pISink , pInParams , pICtx , &m_Wbem );	

}

//***************************************************************************
//
// CServices::
//
// Purpose: 
//
//***************************************************************************
//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
SCODE CServices::DeleteClassAsync(BSTR Class, long lFlags, 
								  IWbemContext *pICtx, 
								  IWbemObjectSink FAR* pISink)
{

	STAT_TRACE ( L"CIMOM called DeleteClassAsync( Class is %s , Flags = %lX )",
		Class , lFlags );

    // Check for requried Params
	if(Class == NULL || pISink == NULL)
        return WBEM_E_INVALID_PARAMETER;

	if(MATCH == wcscmp(Class, EMPTY_STR))
		return WBEM_E_INVALID_PARAMETER;	
	
	// verify CIMOM loopback gateway is available
	if(m_pGateway == NULL)
        return WBEM_E_FAILED;

	// alloc new job context
	CAsyncJob* pJob = new CAsyncJob();

	// init the job context with the pertinant data
	return pJob->InitDeleteClass (  m_cszNamespace , Class , pISink , lFlags ,
		pICtx , &m_Wbem );
}

HRESULT CServices :: Initialize(

	LPWSTR pszUser,
	LONG lFlags,
	LPWSTR Path,
	LPWSTR pszLocale,
	IWbemServices *ppNamespace,         // For anybody
	IWbemContext *pCtx,
	IWbemProviderInitSink *pInitSink     // For init signals
)
{
    SCODE sc = WBEM_S_INITIALIZED;  

	STAT_TRACE ( L"CIMOM called ConnectServer( Path is %s)\n" , Path );

    // Do a check of arguments
    if(Path == NULL || ppNamespace == NULL)
	{
		ASSERT( Path );	// Assert if NULL pointer
        return WBEM_E_INVALID_PARAMETER;
	}

	m_pGateway = ppNamespace ;
	m_pGateway->AddRef () ;

	m_cszNamespace.Set( Path );

	pInitSink->SetStatus ( sc , 0 ) ;

	m_Wbem.Init ( m_cszNamespace ) ;

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Version.rc
//
#define IDS_GETOJECT_FUNC               1
#define IDS_CREATECLASSENUM             2
#define IDS_CLSID_PREFIX                3
#define IDS_PROVIDER_NAME               4
#define IDS_EVENTPROVIDER_NAME          5
#define IDS_LOGGING_KEY                 6
#define IDS_GETOBJECT                   7
#define IDS_CLASSENUM                   8
#define IDS_INSTANCEENUM                9
#define IDS_DELETECLASS                 10
#define IDS_DELETEINSTANCE              11
#define IDS_PUTINSTANCE                 12
#define IDS_EXECMETHOD                  13
#define IDS_GETOBJECT_FAIL              14
#define IDS_CANT_GETINSTANCES_DMIEVENT  15
#define IDS_CANT_GETINSTANCES_DMIENUM   16
#define IDS_OBJECT_NOT_FOUND            17
#define IDS_EXECMETHOD_FAIL             18
#define IDS_INSTANCES_ONLY              19
#define IDS_SYSTEM_CLASS                20
#define IDS_BADMETHOD                   21
#define IDS_PUTINSTANCE_FAIL            22
#define IDS_ONLY_CHILDRED_OF_DMIGROUPROOT 23
#define IDS_GET_OBJECTPATH_FAIL         24
#define IDS_MOT_ENUM_READ               25
#define IDS_MOT_GETENUMVALUE            26
#define IDS_MOT_GETENUMSTRING           27
#define IDS_MOT_ATTRIBUTES_FAIL         28
#define IDS_MOT_GETNEWENUM_FAIL         29
#define IDS_QI_FAIL                     30
#define IDS_NEXT_FAIL                   31
#define IDS_MOT_ROWREAD_FAIL            32
#define IDS_REQUIRED_PROPERTY_MISSING   33
#define IDS_MOT_GETGROUPPATH            34
#define IDS_INVALID_ROWPATH             35
#define IDS_MOT_LANGUAGES_READ_FAIL     36
#define IDS_MOT_GETLANGUAGE_FAIL        37
#define IDS_COMPONENT_READ_FAIL         38
#define IDS_CC_FAIL                     39
#define IDS_MOT_READ_FAIL               40
#define IDS_MOT_GET_COMPIDGROUP_FAIL    41
#define IDS_MOT_GETROW_FAIL             42
#define IDS_MOT_GETGROUPPATH_FAIL       43
#define IDS_ROWOBJECT_NI                44
#define IDS_MOT_FILLROWS_FAIL           45
#define IDS_MOT_GETROWS_FAIL            46
#define IDS_MOT_GETVALUE_FAIL           47
#define IDS_MOT_GETGROUPS_FAIL          48
#define IDS_MOT_GETGROUPSO_FAIL         49
#define IDS_NO_MEM                      50
#define IDS_MOT_COMPONENTS_READ         51
#define IDS_GETFROMID_FAIL              52
#define IDS_MOT_COMPONENT_READ_FAIL     53
#define IDS_MOT_COMPONENT_ADD_FAIL      54
#define IDS_MOT_GETCOMPONENTSO_FAIL     55
#define IDS_MOT_COMPONENT_COUNT_FAIL    56
#define IDS_MOT_ADD_FAIL                57
#define IDS_MOT_SETDEFLANG_FAIL         59
#define IDS_MOT_PUTLANG_FAIL            60
#define IDS_LANGUAGE_ADD_FAIL           61
#define IDS_GETLANGS_FAIL               62
#define IDS_GETCOUNT_FAIL               63
#define IDS_ADD_FAIL                    64
#define IDS_MOT_GROUP_ADD_FAIL          65
#define IDS_COUNT_NOT_INC               66
#define IDS_MOT_REMOVE                  67
#define IDS_MOT_GETLANGS_FAIL           68
#define IDS_GETITEM_FAIL                69
#define IDS_COUNT_NOT_DEC               70
#define IDS_MOT_DEL_LANG_FAIL           71
#define IDS_DEL_GROUP_FAIL              72
#define IDS_DEL_ROW_FAIL                73
#define IDS_GETISTABLE_FAIL             74
#define IDS_DEL_COMPONENT_FAIL          75
#define IDS_LANG_NOT_FOUND              76
#define IDS_NO_ON_COMPONENT_IDGROUP     77
#define IDS_GETGROUPS_FAIL              78
#define IDS_REMOVE_FAIL                 79
#define IDS_ADD_ROW_FAIL                80
#define IDS_GETATTRIBUTES_FAIL          81
#define IDS_GETROWS_FAIL                82
#define IDS_INVALID_COMPID              83
#define IDS_GETATTRIBENUM_FAIL          84
#define IDS_READNODE_FAIL               85
#define IDS_GETVER_FAIL                 86
#define IDS_GETLANG_FAIL                87
#define IDS_GETPATH_FAIL                88
#define IDS_GETCOMPANDGROUP_FAIL        89
#define IDS_NOT_COMPIDGROUP             90
#define IDS_GETATTRIB_FAIL              91
#define IDS_READ_FAIL                   92
#define IDS_GETGROUP_FAIL               93
#define IDS_UPDATEATTRIB_FAIL           94
#define IDS_SCALAR                      95
#define IDS_GETCOMPONENTS_FAIL          96
#define IDS_GETISENUM_FAIL              97
#define IDS_NOT_ENUM                    98
#define IDS_GETENUMS_FAIL               99
#define IDS_GETNODE_FAIL                100
#define IDS_GETCOMPONENT_FAIL           101
#define IDS_GEN                         102
#define IDS_EVENT_INIT_FAIL             103
#define IDS_HANDLENOTIFICATION_FAIL     104
#define IDS_GETMAPPING_FAIL             105
#define IDS_GETENUMCLASS_FAIL           106
#define IDS_SCAN_FAIL                   107
#define IDS_GETCOMPONENTINSTANCE_FAIL   108
#define IDS_GETLANGINSTANCE_FAIL        109
#define IDS_READKEY_FAIL                110
#define IDS_GETENUMOFGROUP_FAIL         111
#define IDS_NOTGROUP                    112
#define IDS_GETNAMES_FAIL               113
#define IDS_GETCOMPGROUP_FAIL           114
#define IDS_NOGROUP                     115
#define IDS_SCALAR_ID_REQ               116
#define IDS_INITMAPPING_FAIL            117
#define IDS_MAPPINGCONNECT_FAIL         118
#define IDS_BADROW                      119
#define IDS_GETITERATOR_FAIL            120
#define IDS_DELINSTANCE_FAIL            121
#define IDS_BADCLASS                    122
#define IDS_BADPATH                     123
#define IDS_GETCG_FAIL                  124
#define IDS_BADCLASSNAME                125
#define IDS_ATTACH_FAIL                 126
#define IDS_NOPATH                      127
#define IDS_CONNECTSERVER_FAIL          128
#define IDS_CONFIGURE_FAIL              129
#define IDS_GETNWA_FAIL                 130
#define IDS_GETNODEI_FAIL               131
#define IDS_GETNI_FAIL                  132
#define IDS_NO_LOOPBACK                 133
#define IDS_GETNICLASS_FAIL             134
#define IDS_GETEVENTI_FAIL              135
#define IDS_GETEVENTC_FAIL              136
#define IDS_GETICREATIONI_FAIL          137
#define IDS_GETICRATIIONC_FAIL          138
#define IDS_GETIDELI_FAIL               139
#define IDS_GETEXSTAT_FAIL              140
#define IDS_GETIDELC_FAIL               141
#define IDS_GETCDELI_FAIL               142
#define IDS_GETCDELC_FAIL               143
#define IDS_GETCCREATIONI_FAIL          144
#define IDS_GETCCREATIONC_FAIL          145
#define IDS_ASYDISP_FAIL                146
#define IDS_DELCLASS_FAIL               147
#define IDS_ADDPROP_FAIL                148
#define IDS_ADDPROPQUAL_FAIL            149
#define IDS_ADDCLASSQUAL                150
#define IDS_ADDMETHOD_FAIL              151
#define IDS_GETPROP_FAIL                152
#define IDS_GETPROPQUAL_FAIL            153
#define IDS_PUTPROPVAL_FAIL             154
#define IDS_CREATECLASS_FAIL            155
#define IDS_CREATEDCLASS_FAIL           156
#define IDS_SPAWN_FAIL                  157
#define IDS_BAD_METHOD                  158
#define IDS_NO_DEL_THIS_CLASS           159
#define IDS_ROWREAD_FAIL                160
#define IDS_GETID_FAIL                  161
#define IDS_MOTCONNECT_FAIL             162
#define IDS_MOTCONNECT2_FAIL            163
#define IDS_COMMITROW_FAIL              164
#define IDS_PUTVALUE_FAIL               165
#define IDS_CREATENEWD_CLASS            166
#define IDS_TO                          167
#define IDS_DERIVED_FROM                168
#define IDS_ONLY_WITH_CIE               169
#define IDS_NOTON1                      170
#define IDS_DMIINTERFACEERORR           171
#define IDS_EVENT                       172
#define IDS_COMPONENTADDNOTIFY          173
#define IDS_COMPONENTDELETENOTIFY       174
#define IDS_GROUPADDNOTIFY              175
#define IDS_GROUPDELETENOTIFY           176
#define IDS_LANGUAGEADDNOTIFY           177
#define IDS_LANGUAGEDELETENOTIFY        178
#define IDS_MOT_ATTRB_ITEM              179
#define IDS_SAFEARRAY_FAIL              180

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\motobjects.h ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/


#if !defined(__MOTOBJECTS_H__)
#define __MOTOBJECTS_H__


#include "dual.h" //dmi engine control header

#define READ_CONN_SP	2


//////////////////////////////////////////////////////////////////
//				SMART POINTERS 

class CEnumVariantI
{
	IEnumVARIANT*	p;

public:	
	
					CEnumVariantI();
					~CEnumVariantI();
	ULONG			Next( CVariant& );
	void			Release ( );

	operator		void**()			{ return (void**)&p; }
};




/////////////////////////////////////////////////////////////////////////

class CUnknownI
{
	LPUNKNOWN		p;
public:


					CUnknownI();
					~CUnknownI();
	void			GetEnum( CEnumVariantI& Enum );
	void			Release ( );

	operator		LPUNKNOWN*()		{ return &p; }
};

class CDLanguagesI
{
	IDualColLanguages*	p;
public:


					CDLanguagesI()		{ p = NULL; }
					~CDLanguagesI()		{Release(); }

	void			Release ();

	void			Add ( CString& );
	void			Remove ( CString& );

	operator		IDualColLanguages*()	{ return p; }
	operator		IDualColLanguages**()	{ return &p; }
	operator		void**()				{ return (void**)&p; }
};


class CDEnumColI
{
public:
	IDualColEnumerations*		p;

						CDEnumColI();
						~CDEnumColI()				{ Release ( );}

	void				Release ();

	operator			IDualColEnumerations*()		{ return p; }
	operator			IDualColEnumerations**()	{ return &p; }
	operator			void**()					{ return (void**)&p; }
};


class CDAttributeI
{
public:
	IDualAttribute*			p;

							CDAttributeI();
							~CDAttributeI()		{ Release ( ); }

	void					Release ( );

	void					CoCreate ( );
	void					Read ( LPWSTR );
	void					GetDmiEnum ( CDEnumColI& );
	
	operator				IDualAttribute*()	{ return p; }
	operator				IDualAttribute**()	{ return &p; }
	operator				void**()			{ return (void**)&p; }		
};


class CDAttributesI
{
public:
	IDualColAttributes*		p;

					CDAttributesI()			{ p = NULL;  }
					~CDAttributesI()		{ Release (); }
	void 			Release ( );

	void			Item ( LONG lAttribute , CDAttributeI&  );
	operator		IDualColAttributes*()	{ return p;}
	operator		IDualColAttributes**()	{ return &p;}
	operator		void**()				{ return (void**)&p;}		
};


class CDRowI
{
	IDualRow*		p;
public:
	

					CDRowI()			{ p = NULL;  }
					~CDRowI()			{ if ( p ) { LONG l = p->Release() ; } }

	void				Release ( )	{ if ( p ) p->Release(); p = NULL; }

	operator		IDualRow*()			{ return p; }
	operator		IDualRow**()		{ return &p; }
	operator		void**()			{ return (void**)&p; }		

	void			CoCreate ( );
	BOOL			Read ( LPWSTR );	
	void			GetAttributes ( CDAttributesI& );

	void			GetKeys ( CDAttributesI& DASI );
};


class CDRowsI
{
	IDualColRows*	p;
public:
	
					CDRowsI()			{ p = NULL; }
					~CDRowsI()			{ Release (); }

	void			Remove ( CAttributes* );
	void			Release ( );

	void			Add ( CDRowI& DRI );

	operator		IDualColRows*()		{ return p;}
	operator		IDualColRows**()	{ return &p;}
	operator		void**()			{return (void**)&p;}
};


class CDGroupI
{
	IDualGroup*		p;
public:
	
					CDGroupI()			{ p = NULL; }
					~CDGroupI()			{ if ( p ) { LONG l = p->Release() ; } }
	void			QI ( CVariant& );

	void			CoCreate ( );
	void			Read ( LPWSTR  );

	void			GetRows ( CDRowsI& );

	void			GetAttributes ( CDAttributesI& );

	operator		IDualGroup*()		{ return p;}
	operator		IDualGroup**()		{ return &p;}
	operator		void**()			{ return (void**)&p; }
};


class CDGroupsI
{
	IDualColGroups*	p;
public:

					CDGroupsI()			{ p = NULL; }
					~CDGroupsI()		{ Release(); }

	void			Release ();

	void			Add	( CVariant& );

	void			Remove ( LONG );

	operator		IDualColGroups*()	{ return p; }
	operator		IDualColGroups**()	{ return &p; }
	operator		void**()			{ return (void**)&p; }

};








/////////////////////////////////////////////////////////////////////////
class CDComponentI
{
private:
	IDualComponent*	p;
public:
	
				CDComponentI()		{ p = NULL; }
				~CDComponentI()		{ Release ( ); }

	void			QI ( CVariant& );
	void			Release ( );
	void			GetGroups ( CDGroupsI& );
	void			GetLanguages ( CDLanguagesI& );
	void			Read ( LPWSTR );
	void			CoCreate ( );

	operator		IDualComponent*()	{ return p;}
	operator		IDualComponent**()	{ return &p;}
	operator		void**()			{return (void**)&p;}
};

////////////////////////////////////////////////////////////////////////
class CDComponentsI
{
	IDualColComponents*	p;
public:

					CDComponentsI();
					~CDComponentsI();

	void			GetUnk ( CUnknownI&  );
	void			Remove ( CVariant& );
	void			Add ( CVariant& );
	void			Release ( )			{if ( p ) p->Release(); p = NULL;}

	operator		IDualColComponents*()	{ return p;}
	operator		IDualColComponents**()	{ return &p;}
	operator		void**()				{return (void**)&p;}
};


////////////////////////////////////////////////////////////////////////
class CDEnumI
{
public:
	IDualEnumeration*	p;

						CDEnumI()					{ p = NULL;  }
						~CDEnumI()					{ if ( p ) { LONG l = p->Release() ; } }

	operator			IDualEnumeration*()			{ return p;}
	operator			IDualEnumeration**()		{ return &p;}
	operator			void**()					{return (void**)&p;}
};



/////////////////////////////////////////////////////////////////////////
class CDMgmtNodeI
{
	IDualMgmtNode*	p;

public:
					CDMgmtNodeI();
					~CDMgmtNodeI();

	void			GetComponents( CDComponentsI&  );
	void			GetLanguage( CBstr&  );
	void			PutLanguage( const BSTR );
	void			GetVersion( CBstr&  );

	void			Release ( )			{if ( p ) p->Release(); p = NULL;}

	void			AddComponent ( CVariant& );
	void			DeleteComponent ( LONG );

	void			CoCreate ( );

	void			Read ( LPWSTR );

	operator		IDualMgmtNode*()	{ return p;}
	operator		IDualMgmtNode**()	{ return &p;}
	operator		void**()			{return (void**)&p;}

};

#endif // __MOTOBJECTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\strings.h ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/


#if !defined(__STRINGS_H__)
#define __STRINGS_H__

#define LOGGING_KEY_STR	L"SOFTWARE\\Microsoft\\WBEM\\PROVIDERS\\Logging\\WBEMDMIP"
#define FILE_STR					L"File"
						
#define LOGGING_STR					L"Logging"

#define ATTRIBUTE_STR				L"Attribute"
// The provider string is always in WCHAR format

#define INPROCSERVER_STR			L"InprocServer32"
#define BOTH_STR					L"Both"
#define THREADINGMODEL_STR			L"ThreadingModel"
//#define LOGGING_STR					L"Logging"
#define FILE_STR					L"File"
#define DEF_FILE_NAME_STR			L"C:\\wbemdmip.log"
#define	CLSID_STR					L"CLSID"



#define INSTANCE_CREATION_CLASS		L"__InstanceCreationEvent"
#define INSTANCE_DELEATION_CLASS	L"__InstanceDeletionEvent"
#define CLASS_CREATION_CLASS		L"__ClassCreationEvent"
#define CLASS_DELETION_CLASS		L"__ClassDeletionEvent"

#define TARGETC_PROPERTY			L"TargetClass"
#define TARGETI_PROPERTY			L"TargetInstance"



#define NODE_CLASS					L"DmiNode"

// DMI_NODE corresponds to the name of the class the contains the NetworkAddr
// string in the WbemDmiP.MOF
#define DMI_NODE					L"DmiNode"
#define NODE_PATH					L"DmiNode=@"	
#define NODEDATA_PATH				L"DmiNodeData=@"

// DMI_NODE_ADDRESS corresponds to the property name of the property
// in the DMI_NODE class that contains the value of the nodes' address
// in the WbemDmiP.MOF
#define DMI_NODE_ADDRESS			L"NetworkAddress"

// EVENT_FILTER string corresponding the the sytem class __EventFilter
#define EVENT_FILTER				L"__EventFilter"

// Substring used to determine if a given class name is a system class
#define SYSTEM_CLASS				L"__"

// STATUS_CODE string corresponds to the property of _NotifyStatus 
// and _ExtendStatus
#define STATUSCODE_PROPERTY			L"StatusCode"

// Other _ExtendedStatus properties
#define DESCRIPTION_PROPERTY		L"Description"
#define OPERATION_PROPERTY			L"Operation"
#define PROVIDER_PROPERTY			L"ProviderName"
#define PARAMETER_PROPERTY			L"ParameterInfo"

#define PROVIDER_NAME				L"WbemDmiP"


#define SINGLETON					L"singleton"

#define BINDING_SUFFIX				L"__Binding"

#define NAME_STR					L"Name"

#define	ENUM_QUALIFER_STR			L"Enum"

// Class names of the dynamic dmi classes 
#define GROUP_ROOT					L"DmiGroupRoot"
#define COMPONENT_CLASS				L"DmiComponent"
#define LANGUAGE_CLASS				L"DmiLanguage"
#define LANGUAGE_BINDING_CLASS		L"DmiLanguageBinding"
#define ENUM_BINDING_CLASS			L"DmiEnumBinding"
#define BINDING_ROOT				L"DmiBindingRoot"
#define ADDMOTHODPARAMS_CLASS		L"DmiAddMethodParams"
#define LANGUAGEPARAMS_CLASS		L"DmiLanguageMethodParams"
#define GETENUMPARAMS_CLASS			L"DmiGetEnumParams"


// DMIENUM_CLASS
#define DMIENUM_CLASS				L"DmiEnum"
#define DMIENUM_CLASS_PREFIX		L"DmiEnum%u"
#define STRING_PROPERTY				L"String%u"
#define STRING1_PROPERTY			L"String1"
#define VALUE_PROPERTY				L"Value%u"

#define STRING_PROP					L"String"
#define VALUE_PROP					L"Value"

// NODEDATA_CLASS a class that contains information specific to
// the node and is used for exec'ing methods on the node
// the class is needed because the DmiNode is MOF defined and
// and connot support methods
#define NODEDATA_CLASS				L"DmiNodeData"

// NODEDATA properties
#define SL_DESCRIPTION				L"DmiSPDescription"
#define SL_VERSION					L"DmiSpecificationVersion"
#define SL_LANGUAGE					L"SLDefaultLanguage"


// COMPONENT_BINDING_CLASS a class to bind each instance DmiComponent to DmiNode
#define	COMPONENT_BINDING_CLASS		L"DmiComponentBinding"

// DATA_BINDING_CLASS a class to bind the singleton instance of NODEDATA_CLASS
// to the singleton instance of DmiNode
#define NODEDATA_BINDING_CLASS		L"DmiNodeDataBinding"


// NodeData Methods 
#define ADD_COMPONENT				L"AddComponent"

// Component Methods
#define ADD_LANGUAGE				L"AddLanguage"
#define DELETE_LANGUAGE				L"DeleteLanguage"
#define ADD_GROUP					L"AddGroup"
#define DELETE_GROUP				L"DeleteGroup"
#define SET_LANGUAGE				L"SetDefaultLanguage"

// Group Methods
#define GET_ENUM					L"GetAttributeEnum"


// GETENUMPARAMS_CLASS properties


#define ATTRIBUTE_ID				L"AttributeId"


// DELETELANGPARMAS_CLASS properties
// LANGUAGE

// COMPONENT_CLASS properties
#define DESCRIPTION_STRING			L"Description_String"
#define PRAGMA						L"Pragma"
#define	ID_STRING					L"Id"
#define MANUFACTURER_STR			L"Manufacturer"


// THE DmiEvent Class
#define DMIEVENT_CLASS				L"DmiEvent"
#define EVENT_TIME					L"EventTime"
#define	MACHINE_PATH				L"MachinePath"

// QUALIFIER Designations
#define DMI_ATTRIBUTE				L"DmiAttribute"
#define DYNAMIC_QUALIFIER			L"Dynamic"
#define PROVIDER_QUALIFIER			L"Provider"
#define	ASSOCIATION_QUALIFIER		L"Assoc"
#define ASSOCIATION_VALUE			VARIANT_TRUE
#define SYNTAX_QUALIFIER			L"syntax"
#define ABSTRACT_QUALIFIER			L"Abstract"
#define KEY_QUALIFIER_STR			L"key"
#define READ_QUALIFIER				L"read"
#define WRITE_QUALIFIER				L"write"
#define VOLATILE_QUALIFIER			L"volatile"
#define REFERANCE_QUALIFER			L"ref"
#define IN_QUALIFIER_STR			L"in"



#define ENUMERATION					L"Enumeration"
#define LANGUAGE_PROP				L"Language"
#define	PRODUCT_STR					L"Product"
#define	VERSION_STR					L"Version"
#define	INSTALLATION_STR			L"Installation"
#define	VERIFY_INTEGER_STR			L"Verify"
#define	SERIAL_NUMBER_STR			L"Serial Number"


#define ACCESS						L"Access"
#define STORAGE						L"Storage"
#define TYPE						L"Type"
#define DMI_CLASS_STRING			L"Class"

#define COMPONENT_ID				L"ComponentId"
#define GROUP_ID					L"GroupId"



/// System CIM Classes
#define CLASS_NAME					L"__CLASS"
#define NOTIFYSTATUS				L"__NotifyStatus"
#define EXSTATUS					L"__ExtendedStatus"
#define PARENT_NAME					L"__SUPERCLASS"

#define CIMTYPE_QUALIFIER			L"CIMTYPE"
#define INPARAMS_QUALIFIER			L"in_params_class"
#define OUTPARAMS_QUALIFIER			L"out_params_class"
#define METHOD_QUAL_VAL				L"method"

#define CONNECT_PREFIX						L"DCE|TCP/IP|"
#define SCALAR_STR							L"scalar"
#define COMPIDGROUP2_POSTFIX				L"|1|scalar|"
#define COMPIDGROUP_POSTFIX					L"|1|scalar"
#define VERSION_ATTRIBUTE_PATH_STR			L"|1|1|scalar|3"
#define LOCAL								L"local"

#define MIF_FILE							L"MifFile"
#define DMI_NAME							L"DmiName"

#define COMPONENT_STR						L"Component"
#define SEPERATOR_STR						L"__"
#define OWNING_NODE							L"Node"
#define GROUP_STR							L"Group"
#define OWNED_NODEDATA						L"Data"
#define OWNED_COMPONENT						L"Component"

#define	BINDING_COMPONENT_VALUE_CONSTRUCT	L"%s.Id=%lu"

#define LANGUAGE_INSTANCE_VALUE_CONSTRUCT	L"%s.%s=\"%s\""

#define SCAN_INT_SEQUENCE					L"%d"
#define SCAN_COMPONENTID_SEQUENCE			L"Component%u"
#define SCAN_GROUPID_SEQUENCE				L"Group%u"

#define COMPONENT_KEY_SEQUENCE				L".Id="
#define START_KEY_VAL_SEQUENCE				L"=\""
#define LANGUAGE_KEY_SEQUENCE				L".Language="

#define EMPTY_STR							L""
#define EQUAL_STR							L"="
#define PIPE_STR							L"|"
#define ONE_STR								L"1"
#define AT_STR								L"@"
#define ULONG_FORMAT_STR					L"%lu"
#define	NONE_STR							L"none"
#define	EMPTY_QUOUTES_STR					L"\"\""

#define CLASSVIEW_CLASS						L"ClassView"

#endif // __STRINGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\threadmgr.h ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/


#if !defined(__THREADMGR_H__)
#define __THREADMGR_H__

#define MAX_JOBS 2
#define WORKER_THREAD_START		0
#define WORKER_THREAD_END		0
#define WORKER_THREAD_COUNT		1


class CThreadContext
{
public:

	CRITICAL_SECTION	m_csJobContextAccess;

	//HANDLE		m_hRun;			// mutex to run thread
	BOOL		m_bExit;
	HANDLE      m_hExecuteEvent;
	CAsyncJob*	m_pJob;			// bucket for job being executed
};

class CThreadManager
{
public:
	CThreadContext	m_TC[WORKER_THREAD_COUNT];
	
				CThreadManager();
				~CThreadManager();

	void		StartWaitingJob(int);
	BOOL		JobWaiting();
	void		Close();
	void		Init();
	BOOL		AddJob(CAsyncJob*);

	HANDLE		Run()								{return m_hRun;};

	friend		DWORD WINAPI  WorkerProc(void *vp);
	friend		DWORD WINAPI  SchedulerProc(void *vp);

	BOOL				m_bExit;

private:
	ULONG				m_ulThreadId[WORKER_THREAD_COUNT + 1];	
	HANDLE				m_hThread[WORKER_THREAD_COUNT + 1];	
	HANDLE				m_hScheduler;
	ULONG				m_ulJobsWaiting;
	CRITICAL_SECTION	m_csJobBucket;
	HANDLE				m_hRun;			// handle of mutex that forces running of work threads
	CAsyncJob*			m_JobArray[MAX_JOBS];				// bucket for jobs waiting to execute

};

#endif // __THREADMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\threadmgr.cpp ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/




#include "dmipch.h"			// precompiled header for dmip

#include "WbemDmiP.h"		// project wide include

#include "CimClass.h"

#include "DmiData.h"

#include "AsyncJob.h"		// must preeced ThreadMgr.h

#include "ThreadMgr.h"

#include "Trace.h"

///////////////////////////////////////////////////////////////////////
// CThreadManager manages Four threads
//	1) schedular thread (determines if work needs to be dispatched to
//													either work thread);
//	2) work1 thread (does work by calling mgr func)
//  3) work2 thread (does work by calling mgr func)
//  4) work3 thread (does work by calling mgr func)
// All data for the 'work' is owned by the manager.  the member funcs
// that do the work are owned by the manager
//
// a jobarray contains pointers to job contexts that need to be completed
// all jobs in the array are queued, not being executed.  A job being
// executed is moved to the work1job or work2job pointers depedning which
// work thread is executing the job.
// 
// multiple threads are needed because the MOTDMIEngine is syncronous
// also because of the architecture of CIMOM a provider must call hmom
// that in turn calls the provider. (a have noticed this three deep so
// far). before the provider job can continue the calls it spurred from
// cimom must return
//
//
///////////////////////////////////////////////////////////////////////


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************

DWORD WINAPI WorkerProc( void* pTC )
{

	// CoInit required because mot is ApartmentThreaded while the DMIP
	// is FreeThreaded.

	//CoInitialize ( NULL );

	STAT_TRACE ( L"Worker thread ( %lX ) started" , ( LONG ) pTC );	
	
	while (TRUE)
    {
		// Wait for the signal destined for this particular thread
		WaitForSingleObject( ((CThreadContext*)pTC)->m_hExecuteEvent, INFINITE );

		// was the event signaled to exit thread?

		if ( ((CThreadContext*)pTC)->m_bExit )
			break;

		EnterCriticalSection ( & ((CThreadContext*)pTC)->m_csJobContextAccess ) ;

		if( ((CThreadContext*)pTC)->m_pJob)
		{
			((CThreadContext*)pTC)->m_pJob->Execute();		

			delete( ((CThreadContext*)pTC)->m_pJob);

			((CThreadContext*)pTC)->m_pJob = NULL;
		}

		LeaveCriticalSection ( & ( ((CThreadContext*)pTC)->m_csJobContextAccess ) );
		
	}

	STAT_TRACE ( L"Worker thread ( %lX ) exit" ,  (LONG ) pTC );

	return( 0 );

}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************

DWORD WINAPI SchedulerProc( void* pTC )
{
	STAT_TRACE ( L"Scheduler thread start");

	while (TRUE)
    {
		WaitForSingleObject( ((CThreadManager*) pTC )->Run(), INFINITE );

		// was the event signaled to exit thread?

		if ( ((CThreadContext*)pTC)->m_bExit )
			break;

		// Now we need to consume all the jobs as addJob may get called 
		// multiple times before we ever processed one event. The event does
		// not have a count of how many times it got signalled. So, we need
		// to make sure we get all the jobs processed. 

		while ( ((CThreadManager*) pTC )->JobWaiting())
		{
			
			for(int i = WORKER_THREAD_START; i <= WORKER_THREAD_END; i++)
			{
				if( NULL == ( (CThreadManager*) pTC )->m_TC[i].m_pJob ) 
				{
					((CThreadManager*) pTC )->StartWaitingJob(i);

					break;
				}
			}
		}

	}

    /* Repeat while RunMutex is taken. */

	STAT_TRACE ( L"Scheduler thread exit");

	return( 0 );
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CThreadManager::CThreadManager()
{
	Init();
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CThreadManager::~CThreadManager()
{
	Close();

	// TODO change this to wait for threads to close
	// during registration regsvr32 gpfs if threads are not given time to 
	// clean up

//	Sleep ( 1000 );  
}

//////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CThreadManager::Init()
{
	DWORD dwThreadID;
	m_bExit = FALSE;

	m_ulJobsWaiting = 0;

	m_hRun = CreateEvent(NULL, FALSE, FALSE, NULL );

	InitializeCriticalSection ( &m_csJobBucket );

	// entering the bucket's cs will cause Add job to wait
	// until init is complete.

	EnterCriticalSection ( &m_csJobBucket );

	for (int i = WORKER_THREAD_START; i <= WORKER_THREAD_END; i++)
	{

		m_TC[i].m_bExit = FALSE;
		m_TC[i].m_pJob = NULL;

		InitializeCriticalSection ( &m_TC[i].m_csJobContextAccess );

		m_TC[i].m_hExecuteEvent = CreateEvent(NULL, FALSE, FALSE, NULL );		
		
		m_hThread[i] = chBEGINTHREADEX( NULL, 0, WorkerProc , (void *)&m_TC[i], 0 , &dwThreadID );

		if ( m_hThread[i] == (void*)NULL )	
		{
			// failed to create thread , this is global nothing to do

			ASSERT ( FALSE ) ;

			return;
		}
	}

	for ( i=0;i<MAX_JOBS;i++ )
		m_JobArray [ i ] = NULL ;

	m_hThread[WORKER_THREAD_END + 1] = chBEGINTHREADEX( NULL, 0, SchedulerProc , (void *)this, 0 , &dwThreadID );
	if ( m_hThread[WORKER_THREAD_END + 1] == NULL)
	{
			// failed to create thread , this is global nothing to do

			ASSERT ( FALSE ) ;

			return;
	}

	LeaveCriticalSection ( &m_csJobBucket );

	return;
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CThreadManager::Close()
{	
	
	// 1. first exit all worker threads
	DWORD dwErrorStatus;
	for(int i = WORKER_THREAD_START; i <= WORKER_THREAD_END; i++)
	{
		m_TC[i].m_bExit = TRUE;;

		SetEvent ( m_TC[i].m_hExecuteEvent );		
		// Wait for the signal saying that the worker thread has terminated
		dwErrorStatus = WaitForSingleObject( m_hThread[i], INFINITE );
		CloseHandle( m_hThread[i] );

		DeleteCriticalSection ( &m_TC[i].m_csJobContextAccess );

		CloseHandle(m_TC[i].m_hExecuteEvent);
	}

	// 2. now exit scheduler
	m_bExit = TRUE;

	SetEvent ( m_hRun );		
	// Wait for the signal saying that the scheduler thread has terminated
	dwErrorStatus = WaitForSingleObject( m_hThread[WORKER_THREAD_END + 1], INFINITE );
	CloseHandle( m_hThread[WORKER_THREAD_END + 1] );
	CloseHandle( m_hRun );

	// 3. clean up data

	DeleteCriticalSection ( &m_csJobBucket );
}


//////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
BOOL CThreadManager::JobWaiting()
{
	BOOL	bRet = FALSE;

	EnterCriticalSection ( &m_csJobBucket ) ;

	if(m_ulJobsWaiting > 0)
		bRet = TRUE;

	LeaveCriticalSection ( &m_csJobBucket );
	

	return bRet;

}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CThreadManager::StartWaitingJob(int i)
{

	EnterCriticalSection ( &m_csJobBucket );

	BOOL t_LocatorJobSlot = FALSE ;
	// walk through job array an find waiting job then put it 
	// in availbale threads bucket.  Note if the worker threads
	// bucket is not empty (though it should be) the job is 
	// left in the to do array.
	for (LONG j = 0; j < MAX_JOBS; j++)
	{
		if(m_JobArray[j] != NULL)
		{

			EnterCriticalSection ( &m_TC[i].m_csJobContextAccess );

			if (m_TC[i].m_pJob == NULL)
			{
				m_TC[i].m_pJob = m_JobArray[j];
				m_JobArray[j] = NULL;
				--m_ulJobsWaiting;

				LeaveCriticalSection ( & m_TC[i].m_csJobContextAccess );

				SetEvent(m_TC[i].m_hExecuteEvent);
				t_LocatorJobSlot = TRUE ;
				break;
			}

			LeaveCriticalSection ( & m_TC[i].m_csJobContextAccess );
		}

	}

	LeaveCriticalSection ( &m_csJobBucket );

	if ( ! t_LocatorJobSlot )
	{
		throw ;
	}

}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
BOOL CThreadManager::AddJob(CAsyncJob *pJob)
{
	BOOL bResult = FALSE;

	EnterCriticalSection ( &m_csJobBucket );

	// walk through job array an find spot for job
	for (LONG i = 0; i < MAX_JOBS; i++)
	{
		if(m_JobArray[i] == NULL)
		{
			m_JobArray[i] = pJob;			
			m_ulJobsWaiting++;
			bResult = TRUE;
			break;
		}
	}

	LeaveCriticalSection ( &m_csJobBucket );

	// Let the scheduler run by signalling the event m_hRun
	SetEvent( m_hRun );

	return bResult;

	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\trace.h ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/


#if !defined(__TRACE_H__)
#define __TRACE_H__

void	STAT_TRACE ( LPCWSTR ,... );
void	DEV_TRACE ( LPCWSTR ,... );
void	ERROR_TRACE ( LPCWSTR ,... );
void	MOT_TRACE ( LPCWSTR ,... );
void	STAT_MESSAGE ( LPCWSTR ,... );

class CDebug
{
	LONG		m_nLogging;

	CString		m_cszLogFile;
public:
				CDebug();
	
	LONG		LoggingLevel()		{ return m_nLogging ; }
	void		ODS(LPWSTR);
	void		ODS_MESSAGE(LPWSTR);
};

#endif // __TRACE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\wbemdmip.h ===
//***************************************************************************
//
//  DmiP.h
//
//  Module: CIMOM Instance provider
//
//  Purpose: Project Header
//
//***************************************************************************

#if !defined(__WBEMDMIP_H__)

// Use the following macro to make it easier to call _beginthreadex.  We use
// _beginthreadex because it doesn't close the thread handle automatically when
// the thread terminates.  This way, we can wait for the thread's handle to be
// signaled when the thread terminates and close the handles to ensure proper 
// termination and clean up of threads.
typedef unsigned (__stdcall *PTHREAD_START) (void *);
#define chBEGINTHREADEX( lpsa, cbStack, lpStartAddr, \
	lpvThreadParm, fdwCreate, lpIDThread)	\
	  ((HANDLE)_beginthreadex(				\
		 (void *) (lpsa),					\
		 (unsigned) (cbStack),				\
		 (PTHREAD_START) (lpStartAddr),		\
		 (void *) (lpvThreadParm),			\
		 (unsigned) (fdwCreate),			\
		 (unsigned *) (lpIDThread)))

//#define TRACE_MESSAGES	// Turning this on, will cause the STAT_MESSAGE
							// ODS_MESSAGE macros to be enabled. 
//#define TIME_STAMP		// Turning this on will generate time stamps
							// in the wbemdmip.log file.
				

#define SYSALLOC(a)			SysAllocString( a )
#define FREE(a)				SysFreeString( a )

#define	BUFFER_SIZE				256
#define STRING_DOES_NOT_EXIST	0

#include "resource.h"



#define MYDELETE(a)				{ if (a) {delete (a); a = NULL;} ;}
#define ARRAYDELETE(a)			{ if (a) {delete [] (a); a = NULL;} ;}
#define RELEASE(a)				{ if (a) {LONG l = (a)->Release(); (a)=NULL; } }

#include "datatypes.h"


/////////////////////////////////////////////////////////////////////
// because the string ops don't return TRUE
#define MATCH						0
#define NO_FLAGS					0
#define NO_STRING					0
#define EMPTY_VARIANT				0

#define DOT_CODE					46
#define	EQUAL_CODE					61
#define PIPE_CODE					124
#define UNDER_CODE					95
#define COMMA_CODE					44
	
#define	FIRST_CHAR					0
#define	SECOND_CHAR					1

#define COMPONENTID_GROUP			1

// attributes ids of the component id group attributes
#define	MANUFACTURER_ATTIBUTE_ID	1
#define PRODUCT_ATTIBUTE_ID			2
#define VERSION_ATTIBUTE_ID			3
#define INSTALLATION_ATTIBUTE_ID	5
#define	VERIFY_INTEGER_ATTRIBUTE_ID	6
#define SERIAL_NUMBER_ATTRIBUTE_ID	4



#define NO_LOGGING					0
#define ERROR_LOGGING				1
#define STATUS_LOGGING				2
#define MOT_LOGGING					3
#define DEV_LOGGING					4



#define DMIEVENT_I				1001
#define DMIEVENT_C				1002
#define ADDMOTHODPARAMS_I		1003
#define ADDMOTHODPARAMS_C		1004
#define LANGUAGEPARAMS_I		1005
#define LANGUAGEPARAMS_C		1006
#define GETENUMPARAMS_I			1007
#define GETENUMPARAMS_C			1008
#define DMIENUM_I				1009
#define DMIENUM_C				1010
#define COMPONENT_BINDING_I		1011
#define COMPONENT_BINDING_C		1012
#define COMPONENT_I				1013
#define COMPONENT_C				1014
#define NODEDATA_BINDING_I		1015
#define NODEDATA_BINDING_C		1016
#define NODEDATA_C				1017
#define NODEDATA_I				1018
#define LANGUAGE_BINDING_I		1019
#define LANGUAGE_BINDING_C		1020
#define LANGUAGE_I				1021
#define LANGUAGE_C				1022
#define BINDING_ROOT_C			1023
#define BINDING_ROOT_I			1024
#define GROUP_ROOT_C			1025
#define GROUP_ROOT_I			1026
#define DYN_GROUP_I				1027
#define DYN_GROUP_C				1028
#define CLASSVIEW_C				1029
#define CLASSVIEW_I				1030
#define DMI_NODE_C				1031
#define DMI_NODE_I				1032

#define READ_ONLY				1
#define	READ_WRITE				2
#define WRITE_ONLY				3

#define DEF_LOGGING_LEVEL		NO_LOGGING 



#define EXE_TYPE				CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER



/////////////////////////////////////////////////////////////////////
//			FORWARD ClASS DECLS



/////////////////////////////////////////////////////////////////////
//			GLOBALS

extern long					_gcObj;
extern long					_gcLock;
extern long					_gcEventObj;
extern long					_gcEventLock;
extern HMODULE				_ghModule;
extern CRITICAL_SECTION		_gcsJobCriticalSection;



#endif // __WBEMDMIP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\wbemloopback.h ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/



#if !defined(__WBEMLOOPBACK_H__)
#define __WBEMLOOPBACK_H__


class CCimObject;

class CWbemLoopBack
{
private:
	IWbemServices*		m_pIServices;

	IWbemClassObject*	m_pIGroupRoot;
	IWbemClassObject*	m_pIBindingRoot;

	BOOL				m_bConnected;

	CString			m_cszNamespace;
	CString			m_cszNWA;

	void			Connect( IWbemContext* );
	void 			GetNetworkAddr( CString&, IWbemContext*);

	// some cached objects for performance enh
	CCimObject		m_NotifyClass;
	CCimObject		m_ExStatusClass;
	CCimObject		m_NullObject;

public:

	void			Cache( LPWSTR , IWbemClassObject*  );
	BOOL			IsCached( LPWSTR , IWbemClassObject**  );
	void			GetObject(BSTR, IWbemClassObject** , IWbemContext*   );
	void 			CreateNewDerivedClass(IWbemClassObject **, BSTR, IWbemContext*  );
	void			CreateNewClass(IWbemClassObject**, IWbemContext*  );
	
	void 			GetNotifyStatusInstance(CCimObject&, ULONG, IWbemContext*  );
	BOOL			GetExtendedStatusInstance( CCimObject& Instance, ULONG ulStatus, BSTR bstrDescription, BSTR bstrOperation, BSTR bstrParameter, IWbemContext* pICtx );

	void			GetInstanceCreationInstance ( CCimObject&, IUnknown*, IWbemContext*  );
	void			GetInstanceDeletionInstance ( CCimObject&, IUnknown*, IWbemContext*   );
	void			GetClassCreationInstance ( CCimObject&, IUnknown*, IWbemContext*   );
	void			GetClassDeletionInstance ( CCimObject&, IUnknown*, IWbemContext*   );
	void			GetExtrinsicEventInstance ( CEvent& , CCimObject& EventObject );	

	void			AttachServer(BSTR );

	void			Init( LPWSTR );

	CString&		NWA ( IWbemContext* );
	
					~CWbemLoopBack();
					CWbemLoopBack();
};

#endif // __WBEMLOOPBACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\wbemloopback.cpp ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/


#include "dmipch.h"		// project wide include

#include "WbemDmiP.h"		// project wide include

#include "CimClass.h"

#include "Strings.h"

#include "Exception.h"

#include "Trace.h"

#include "DmiData.h"

#include "WbemLoopBack.h"

//////////////////////////////////////////////////////////////////////////
//
// Each Instance of CWbemLoopBack is a connection to an IWbemServices
// in the path used in the call to attach server.
// to use CWbemLoopBack you must first call AttachServer then the 
// wrapped cimom service you desire.
//
// meant to be used for the provider calling back into cimom for
// imperative data.
//////////////////////////////////////////////////////////////////////////


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CWbemLoopBack::CWbemLoopBack()
{
	DEV_TRACE ( L"\t\tCWbemLoopBack::CWbemLoopBack()" );

	m_pIServices = NULL;
	m_pIBindingRoot = NULL;
	m_pIGroupRoot = NULL;

	m_bConnected = FALSE;
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CWbemLoopBack::~CWbemLoopBack()
{

	DEV_TRACE ( L"\t\tCWbemLoopBack::~CWbemLoopBack()" );

	RELEASE( m_pIGroupRoot );
	RELEASE( m_pIBindingRoot );

	RELEASE( m_pIServices );
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************

void CWbemLoopBack::Init ( LPWSTR pPath )
{

	m_cszNamespace.Set ( pPath );
}

void CWbemLoopBack::Connect ( IWbemContext* pICtx )
{
	if ( m_bConnected )
		return;	

	AttachServer( m_cszNamespace );
	
	GetNetworkAddr( m_cszNWA, pICtx );

	m_bConnected = TRUE;
}

void CWbemLoopBack::AttachServer(BSTR bstrPath)
{
	HRESULT			result;
	IWbemLocator	*pILocator = NULL ;
	
	STAT_TRACE ( L"\t\tAttachServer(%s) to CIMOM loopback", bstrPath );

	if(!bstrPath)
	{
		throw CException (  WBEM_E_FAILED , IDS_ATTACH_FAIL , IDS_NOPATH );
	}
	if ( FAILED ( CoCreateInstance (CLSID_WbemAdministrativeLocator, NULL , 
		EXE_TYPE , IID_IWbemLocator , ( void ** )  &pILocator) ))
	{
		throw CException ( WBEM_E_FAILED , IDS_ATTACH_FAIL , IDS_CC_FAIL );
	}

	if ( FAILED ( result = pILocator->ConnectServer ( bstrPath , NULL, NULL, 
		NULL, 0L, NULL, NULL, &m_pIServices) ))
	{
		throw CException ( WBEM_E_FAILED , IDS_ATTACH_FAIL , 
			IDS_CONNECTSERVER_FAIL , CString ( result ) );
	}

	

	RELEASE(pILocator);

}


// on failure this function leaves pbstrNetwork Addr empty
// likely cause of failure of this func is missing dminode instance
// for the current namespace
//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CWbemLoopBack::GetNetworkAddr( CString& cszNWA, IWbemContext* pICtx )
{
	HRESULT				result = NO_ERROR;
	CCimObject			DmiNodeInstance;
	CVariant			cvNWA;
	CBstr				cbClass ( NODE_PATH );
	
	
	if(FAILED(result = m_pIServices->GetObject( cbClass, 0L, pICtx, DmiNodeInstance, 
		NULL)))
	{
		throw CException (WBEM_E_FAILED, IDS_GETNWA_FAIL , 
			IDS_GETNODEI_FAIL );	
	}

	DmiNodeInstance.GetProperty( DMI_NODE_ADDRESS, cvNWA);

	cszNWA.Set( cvNWA.GetBstr() );
}

CString& CWbemLoopBack::NWA( IWbemContext* pICtx )
{
	Connect ( pICtx );

	return m_cszNWA;
}

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CWbemLoopBack::GetNotifyStatusInstance( CCimObject& NotifyInstance, 
											ULONG ulStatus, 
											IWbemContext* pICtx )
{
	Connect ( pICtx );

	if(!m_pIServices)
	{
		throw CException ( WBEM_E_FAILED , IDS_GETNI_FAIL ,
			IDS_NO_LOOPBACK );
	}

	
	NotifyInstance.Release();

	if ( m_NotifyClass.IsEmpty ( ) )
	{
		if FAILED( m_pIServices->GetObject( NOTIFYSTATUS, 0L, pICtx, 
			m_NotifyClass, NULL ))
		{
			throw CException ( WBEM_E_FAILED, IDS_GETNI_FAIL,
				IDS_GETNICLASS_FAIL );
		}
	}

	NotifyInstance.Spawn( m_NotifyClass );

	CVariant	cvValue;

	cvValue.Set ( (LONG) ulStatus );

	NotifyInstance.PutPropertyValue ( STATUSCODE_PROPERTY, 
		cvValue );
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
BOOL CWbemLoopBack::GetExtendedStatusInstance( CCimObject& Instance, 
											  ULONG ulStatus, 
											  BSTR bstrDescription,
											  BSTR bstrOperation,
											  BSTR bstrParameter, 
											  IWbemContext* pICtx )
{
	Connect ( pICtx );

	if(!m_pIServices)
	{
		// we are in deep trouble if this occurs
		CString cszT;

		STAT_TRACE ( L"Failed to get __ExtendedStatus instance" );
		STAT_TRACE ( L"CIMOM loopback interface not established" );

		return FALSE;
	}
	
	Instance.Release();

	if ( m_ExStatusClass.IsEmpty () )
	{
		if FAILED(m_pIServices->GetObject( EXSTATUS, 0L, pICtx, m_ExStatusClass, NULL ))
		{
			// we are in deep trouble if this occurs
			STAT_TRACE ( L"\tFailed to get __ExtendedStatus instance" );
			STAT_TRACE ( L"\tFailed to get __ExtendedStatus class");

			return FALSE;
		}
	}

	Instance.Spawn( m_ExStatusClass );

	try 
	{
		CVariant cvTemp;

		cvTemp.Set ( ulStatus );

		Instance.PutPropertyValue ( STATUSCODE_PROPERTY, cvTemp );			

		cvTemp.Set ( bstrDescription );

		Instance.PutPropertyValue ( DESCRIPTION_PROPERTY , cvTemp );			
		
		cvTemp.Set ( bstrOperation );

		Instance.PutPropertyValue ( OPERATION_PROPERTY ,  cvTemp );			
		
		cvTemp.Set ( PROVIDER_NAME );

		Instance.PutPropertyValue ( PROVIDER_PROPERTY ,  cvTemp );			

		cvTemp.Set ( bstrParameter );

		Instance.PutPropertyValue ( PARAMETER_PROPERTY , cvTemp );
	}
	catch ( CException& e )
	{
		CString cszDesc;
		CString cszOp;

		cszDesc.LoadString ( e.DescriptionId ( ) );
		cszOp.LoadString ( e.OperationId ( ) ) ;

		ERROR_TRACE ( L"\tGetExtendedStatus() failed" );
		ERROR_TRACE ( L"\tjob ( %lX ) failed " , this );
		ERROR_TRACE ( L"\t\te.Code = %lX" , e.WbemError ( ) ) ; 
		ERROR_TRACE ( L"\t\te.Description = %s ", cszDesc  );
		ERROR_TRACE ( L"\t\te.Operation = %s ", cszOp );
		ERROR_TRACE ( L"\t\te.Param = %s ", e.Data() );

		return FALSE;
	}	

	catch ( ... )
	{
		ERROR_TRACE ( 
			L"Unknown error caught, GetExtendedStatusInstance() failed" );

		return FALSE;
	}

	return TRUE;
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CWbemLoopBack::GetExtrinsicEventInstance ( CEvent& Event, CCimObject& Instance )
{
	CVariant cvCompId;

	Connect ( NULL );

	cvCompId.Set ( Event.Component () );

	CVariant cvEventTime;

	cvEventTime.Set ( Event.Time() );

	CVariant cvLanguage ;

	cvLanguage.Set ( Event.Language() );
	
	CVariant  cvPath;

	cvPath.Set ( Event.NWA () );	
	
	CCimObject Class;

	if ( FAILED ( m_pIServices->GetObject ( DMIEVENT_CLASS , 0L , NULL , 
		Class , NULL ) ))
	{
		throw CException ( WBEM_E_FAILED, IDS_GETEVENTI_FAIL , 
			IDS_GETEVENTC_FAIL );			
	}

	Instance.Spawn( Class );
	
	Instance.PutPropertyValue( COMPONENT_ID, cvCompId );
	Instance.PutPropertyValue( EVENT_TIME, cvEventTime );
	Instance.PutPropertyValue( LANGUAGE_PROP, cvLanguage );
	Instance.PutPropertyValue( MACHINE_PATH, cvPath );

	// need to put property on rows here
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CWbemLoopBack::GetInstanceCreationInstance ( CCimObject& EventInstance,
												 IUnknown* pIDispNewInstance,
												 IWbemContext* pICtx  )
{
	CCimObject			EventClass;

	Connect ( pICtx );

	if(!m_pIServices)
	{
		throw CException ( WBEM_E_FAILED , IDS_GETICREATIONI_FAIL ,
			IDS_NO_LOOPBACK );
	}
	
	EventInstance.Release();

	if FAILED ( m_pIServices->GetObject( INSTANCE_CREATION_CLASS , 0L, pICtx,
		EventClass, NULL ))
	{
		throw CException ( WBEM_E_FAILED, IDS_GETICREATIONI_FAIL ,
			IDS_GETICRATIIONC_FAIL  );
	}

	EventInstance.Spawn( EventClass );

	CVariant cvValue;

	cvValue.Set ( pIDispNewInstance );

	EventInstance.PutPropertyValue ( TARGETI_PROPERTY , cvValue );

}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CWbemLoopBack::GetInstanceDeletionInstance ( CCimObject& EventInstance,
												 IUnknown* pIDispOldInstance,
												 IWbemContext* pICtx  )
{
	CCimObject			EventClass;

	Connect ( pICtx );

	if(!m_pIServices)
	{
		throw CException ( WBEM_E_FAILED, IDS_GETIDELI_FAIL ,
			IDS_NO_LOOPBACK );
	}
	
	EventInstance.Release();

	if FAILED(m_pIServices->GetObject( INSTANCE_DELEATION_CLASS ,
		0L, pICtx, EventClass, NULL ))
	{
		throw CException ( WBEM_E_FAILED, IDS_GETIDELI_FAIL ,
			IDS_GETIDELC_FAIL );
	}

	EventInstance.Spawn( EventClass );

	CVariant cvDisp;

	cvDisp.Set ( pIDispOldInstance );

	EventInstance.PutPropertyValue ( TARGETI_PROPERTY , cvDisp );
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CWbemLoopBack::GetClassCreationInstance ( CCimObject& EventInstance, 
											  IUnknown* pIDispNewClass,
											  IWbemContext* pICtx  )
{
	CCimObject			EventClass;

	Connect ( pICtx );

	if(!m_pIServices)
	{
		throw CException ( WBEM_E_FAILED, IDS_GETCCREATIONI_FAIL ,
			
			IDS_NO_LOOPBACK);
	}
	
	EventInstance.Release();

	if FAILED(m_pIServices->GetObject( CLASS_CREATION_CLASS ,
		0L, pICtx, EventClass, NULL ))
	{
		throw CException ( WBEM_E_FAILED, IDS_GETCCREATIONI_FAIL ,
			IDS_GETCCREATIONC_FAIL );
	}

	EventInstance.Spawn( EventClass );

	CVariant	cvDisp;

	cvDisp.Set ( pIDispNewClass );

	EventInstance.PutPropertyValue ( TARGETC_PROPERTY , cvDisp );

}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CWbemLoopBack::GetClassDeletionInstance ( CCimObject& EventInstance, 
											  IUnknown* pIDispOldClass,
											  IWbemContext* pICtx )
{
	CCimObject			EventClass;

	Connect ( pICtx );

	if(!m_pIServices)
	{
		throw CException ( WBEM_E_FAILED , IDS_GETCDELI_FAIL ,
			IDS_NO_LOOPBACK);
	}
	
	EventInstance.Release();

	if FAILED(m_pIServices->GetObject( CLASS_DELETION_CLASS,
		0L, pICtx, EventClass, NULL ))
	{
		throw CException ( WBEM_E_FAILED, IDS_GETCDELI_FAIL , 
			IDS_GETCDELC_FAIL );
	}

	EventInstance.Spawn( EventClass );

	CVariant cvDisp;

	cvDisp.Set ( pIDispOldClass );

	EventInstance.PutPropertyValue ( TARGETC_PROPERTY , cvDisp );
}



//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:  the IWbemClassObject** param must be initialized with a valid
//	Interface pointer or null.
//
//***************************************************************************
void CWbemLoopBack::CreateNewClass(IWbemClassObject** ppINewClass,
								   IWbemContext* pICtx)
{
	SCODE				result = WBEM_NO_ERROR;

	// make the loop back is connected
	
	Connect ( pICtx );

	// Don't orphan a previously assigned new class Interface

	RELEASE (*ppINewClass );

	// check to see if we've cached the null object already

	if ( m_NullObject.IsEmpty () )
	{

		// get the null object and put it in the cache
	
		if ( FAILED ( result = m_pIServices->GetObject ( NULL, 0, pICtx, 
			m_NullObject , NULL) ))
		{
			throw CException( WBEM_E_FAILED , IDS_CREATECLASS_FAIL , 
				IDS_GETOBJECT_FAIL , CString ( result ) );		
		}
	}

	// give the caller a clone of the cached null object

	( (IWbemClassObject*) m_NullObject) -> Clone( ppINewClass );

}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CWbemLoopBack::CreateNewDerivedClass(IWbemClassObject **ppINewClass, 
										  BSTR bstrSuperClass, 
										  IWbemContext* pICtx)
{
	SCODE				result = WBEM_NO_ERROR;
	IWbemClassObject*	pIEmptyClass = NULL;	

	Connect ( pICtx );

	DEV_TRACE ( L"\t\tCCimClassWrap::CreateNewDerivedClass () \
calling GetObject ( %s )", bstrSuperClass );

	Connect ( pICtx );

	ASSERT(m_pIServices);  

	RELEASE ( *ppINewClass );

	if ( ! IsCached(  bstrSuperClass, &pIEmptyClass) )
	{		
		if ( FAILED( result = m_pIServices->GetObject ( bstrSuperClass, 0, 
			pICtx, &pIEmptyClass, NULL) ))
		{
			throw CException( WBEM_E_FAILED , IDS_CREATENEWD_CLASS ,
				IDS_GETOBJECT_FAIL , CString ( result ) ) ;
		}
		
		Cache( bstrSuperClass, pIEmptyClass );
	}

	result = pIEmptyClass->SpawnDerivedClass ( 0, ppINewClass );

	RELEASE(pIEmptyClass);

	if ( FAILED( result ))
	{
		throw CException( WBEM_E_FAILED , IDS_CREATENEWD_CLASS ,
			IDS_SPAWN_FAIL , CString ( result ) );	
	}
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CWbemLoopBack::GetObject(BSTR bstrPath, IWbemClassObject** ppIObject,
							  IWbemContext* pICtx  )
{
	SCODE				result = WBEM_NO_ERROR;

	Connect ( pICtx );

	// AttatchServer must be called prior to CreateNewClass

	ASSERT(m_pIServices);  

	MOT_TRACE ( L"CCimClassWrap::GetObject() name = %s", bstrPath );

	RELEASE ( *ppIObject );
	
	if( FAILED( result = m_pIServices->GetObject ( bstrPath, 0, pICtx,
		ppIObject, NULL) ))
	{
		throw CException ( WBEM_E_FAILED, IDS_GETOBJECT_FAIL , 
			IDS_GETOBJECT_FAIL , CString ( result) );
	}
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CWbemLoopBack::Cache( LPWSTR wszClassName, IWbemClassObject* p )
{
	if ( MATCH == wcsicmp( wszClassName, GROUP_ROOT) )
	{
		m_pIGroupRoot = p;
		m_pIGroupRoot->AddRef();
	}

	if ( MATCH == wcsicmp( wszClassName, BINDING_ROOT) )
	{
		m_pIBindingRoot = p;
		m_pIBindingRoot->AddRef();
	}

}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
BOOL CWbemLoopBack::IsCached( LPWSTR wszClassName, IWbemClassObject** pp )
{
	if ( MATCH == wcsicmp( wszClassName, GROUP_ROOT) && m_pIGroupRoot)
	{
		*pp = m_pIGroupRoot;
		m_pIGroupRoot->AddRef();
		return TRUE;
	}

	if ( MATCH == wcsicmp( wszClassName, BINDING_ROOT) && m_pIBindingRoot)
	{
		*pp = m_pIBindingRoot;
		m_pIBindingRoot->AddRef();
		return TRUE;
	}

	return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dmi\source\trace.cpp ===
/*
******************************************************************************
******************************************************************************
*
*
*              INTEL CORPORATION PROPRIETARY INFORMATION
* This software is supplied under the terms of a license agreement or
* nondisclosure agreement with Intel Corporation and may not be copied or
* disclosed except in accordance with the terms of that agreement.
*
*        Copyright (c) 1997, 1998 Intel Corporation  All Rights Reserved
******************************************************************************
******************************************************************************
*
* 
*
* 
*
*/







#include "dmipch.h"	// precompiled header for dmi provider
#include "WbemDmip.h"


#include "Strings.h"

#include "Trace.h"

void _SetupLoggingInfo(HMODULE);


//////////////////////////////////////////////////////////////////
//		DEBUG STUFF

static CDebug				_gDebug;

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void DEV_TRACE ( LPCWSTR pFormat, ... )
{

	if ( DEV_LOGGING > _gDebug.LoggingLevel() )
		return;
 
	WCHAR	wszBuffer[256];
	int		i = 0;

	va_list valist;

	va_start( valist, pFormat );     

	vswprintf ( wszBuffer, pFormat , valist );

	va_end( valist );              

	_gDebug.ODS ( wszBuffer );

}


//***************************************************************************
//	Func:
//	Purpose:
//	Returns:
//	In Params:
//  Out Params:
//	Note:
//***************************************************************************
void STAT_TRACE ( LPCWSTR pFormat, ... )
{
 
	WCHAR	wszBuffer[256];
	int		i = 0;

	if ( STATUS_LOGGING > _gDebug.LoggingLevel() )
		return;

	va_list valist;

	va_start( valist, pFormat );   

	vswprintf ( wszBuffer, pFormat , valist );

	va_end( valist );              

	_gDebug.ODS ( wszBuffer );

}


#if defined(TRACE_MESSAGES)

//***************************************************************************
//	Func:
//	Purpose: To store the thread messages sent by SendThreadMessage() and
//			 HandleMessage() functions.  The output will be written
//           to \\wbem\logs\message.log file and helps you to see if your
//			 threads are getting all messages and processing them properly.
//	Returns:
//	In Params:
//  Out Params:
//	Note:
//***************************************************************************
void STAT_MESSAGE ( LPCWSTR pFormat, ... )
{
 
	WCHAR	wszBuffer[256];
	int		i = 0;

	va_list valist;

	va_start( valist, pFormat );   

	vswprintf ( wszBuffer, pFormat , valist );

	va_end( valist );              

	_gDebug.ODS_MESSAGE ( wszBuffer );

}

#endif // TRACE_MESSAGES

//***************************************************************************
//	Func:
//	Purpose:
//	Returns:
//	In Params:
//  Out Params:
//	Note:
//***************************************************************************
void MOT_TRACE ( LPCWSTR pFormat, ... )
{
 
	WCHAR	wszBuffer[256];
	int		i = 0;

	if ( MOT_LOGGING > _gDebug.LoggingLevel() )
		return;

	va_list valist;

	va_start( valist, pFormat );   

	vswprintf ( wszBuffer, pFormat , valist );

	va_end( valist );              

	_gDebug.ODS ( wszBuffer );

}

//***************************************************************************
//	Func:
//	Purpose:
//	Returns:
//	In Params:
//  Out Params:
//	Note:
//***************************************************************************
void ERROR_TRACE ( LPCWSTR pFormat, ... )
{
 
	WCHAR	wszBuffer[256];
	int		i = 0;

	if ( ERROR_LOGGING > _gDebug.LoggingLevel() )
		return;

	va_list valist;

	va_start( valist, pFormat );   

	vswprintf ( wszBuffer, pFormat , valist );

	va_end( valist );              

	_gDebug.ODS ( wszBuffer );

}


/***************************************************************************
 * NAME:
 *   _SetupLoggingInfo
 *
 * ABSTRACT:
 *   This function drives the full path name of the MIF file from the path of
 *   the executable.
 *
 *
 * SCOPE:
 *   Private
 *
 * SIDE EFFECTS:
 *   None.
 *   
 * ASSUMPTIONS:
 *   Assumes the .MIF file is in the same directory as the executable.  
 *
 * RETURN VALUE(S):
 *   Returns full path and name of the MIF file used for this instrumentation.
 *
 ****************************************************************************/ 
static void _SetupLoggingInfo( HMODULE hModuleHandle)
{
	char aCimomPathName[_MAX_PATH + 1];	  // Holds the provider file name
	char *pModulePathName = aCimomPathName;
	char *pcNamePtr;          // Pointer into file name 
	int iLength;              // iLength = path + name 
	
	iLength = GetModuleFileName(hModuleHandle, pModulePathName, _MAX_PATH);
	if ( !hModuleHandle )
		return;
	pcNamePtr = pModulePathName + iLength;	// Pointer to end of file name 


	while (pcNamePtr > pModulePathName)
	{
	
	  if (*pcNamePtr == '\\')
	  {
	     *pcNamePtr = '\0';
	     break;
	  }
	  pcNamePtr--;
	}
	if ( strlen(pModulePathName) < _MAX_PATH)
	{
	  strcat(pModulePathName, "\\Logs\\WBEMDMIP.log");
	}
	else
	{
	  strcat(pModulePathName, "?");
	}
	char cszFile[ MAX_PATH ];
	
	HKEY hKey1 = 0;
	CString cszLoggingKeyStr(LOGGING_KEY_STR);	
	DWORD dwSize;
	DWORD dwType;
	DWORD dwLogging = 0;

	// If the WBEMDMIP entry does not exist, create it
	if ( ERROR_SUCCESS != RegOpenKeyEx( HKEY_LOCAL_MACHINE , 
			cszLoggingKeyStr.GetMultiByte(), 0 , KEY_QUERY_VALUE , &hKey1 ) )
	{		
		RegCreateKey( HKEY_LOCAL_MACHINE, cszLoggingKeyStr.GetMultiByte() , &hKey1);
	
	}
	// Set the logging values
	dwSize = sizeof ( DWORD );
	// If logging is not set, set it to default of 0
	if (ERROR_SUCCESS != RegQueryValueEx( hKey1 , "Logging" , NULL ,
		&dwType , (LPBYTE)&dwLogging , &dwSize ) )
	{
		RegSetValueEx(hKey1, "Logging", 0, REG_DWORD, (BYTE*)&dwLogging , 
			sizeof ( dwLogging ) ); 
	}

	// If the logging file does not exist, set it to \\wbemdmip.log
	dwSize = MAX_PATH ; 
	if ( ERROR_SUCCESS != RegQueryValueEx( hKey1 , "File" , NULL ,
		&dwType , (BYTE *)cszFile, &dwSize ) )
	{
		sprintf ( cszFile, "%s", pModulePathName );
		RegSetValueEx(hKey1, "File" , 0, REG_SZ, (const BYTE *)cszFile, 
			lstrlenA(cszFile)+1);
	}
	
	RegCloseKey(hKey1);
	
	return;

}   // _SetupLoggingInfo() 


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
CDebug::CDebug()
{
	HKEY	hLogging;
	DWORD	dwType;
	DWORD	dwLogging;
	DWORD	dwSize = sizeof ( DWORD );

	// Set up DMI provider logging level and logging path
	_SetupLoggingInfo( GetModuleHandle( "cimom.exe" ) );

	// init logging values to default
	m_nLogging = 0;
	
	// determine what if any level of logging we should be doing

	CString cszLoggingStr(LOGGING_KEY_STR);
	if ( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE , 
			cszLoggingStr.GetMultiByte() , 0 , 
			KEY_QUERY_VALUE , &hLogging ) )
	{
		
		
		if ( ERROR_SUCCESS == RegQueryValueEx( hLogging , "Logging" , NULL ,
			&dwType , (LPBYTE)&dwLogging , &dwSize ) )
		{
			if ( NO_LOGGING < dwLogging  && DEV_LOGGING >= dwLogging)
				m_nLogging = dwLogging;
			else
				m_nLogging = NO_LOGGING;

		}		
	}

	if ( NO_LOGGING != m_nLogging )
	{

		// determine logging file name
		char cszLogFile[ MAX_PATH ];
		WCHAR wcszLogFile[ MAX_PATH ];

		if ( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE , 
			cszLoggingStr.GetMultiByte() , 0 , KEY_QUERY_VALUE , &hLogging ) )
		{	
			
			dwSize = MAX_PATH ; 

			if ( ERROR_SUCCESS != RegQueryValueEx( hLogging , "File" , NULL ,
				&dwType , (BYTE *) cszLogFile , &dwSize ) )
			{
				m_nLogging = NO_LOGGING ;
			}
			else
			{
			  mbstowcs( wcszLogFile, cszLogFile, MAX_PATH );	
			  m_cszLogFile.Set(wcszLogFile);
			}
		}
	
		if ( MATCH == _access ( cszLogFile , 00 ) )
			remove ( cszLogFile ) ;

	}

	RegCloseKey ( hLogging );
}


//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CDebug::ODS(LPWSTR lpwstr)
{
	if ( NO_LOGGING == m_nLogging )
		return;

	ofstream		ofs;
    SYSTEMTIME		st;
	char			szLogString [ BUFFER_SIZE ];
	char			szFile [ MAX_PATH ];
	BOOL			b;

	WideCharToMultiByte( CP_OEMCP, 0, lpwstr, -1, szLogString, 256, NULL, &b);

	GetLocalTime(&st);

	WideCharToMultiByte( CP_OEMCP, 0, m_cszLogFile, -1, szFile, 256, NULL, &b);

	ofs.open( szFile , ios::out | ios::app);

#if defined(TIME_STAMP)
	ofs << "(" << st.wHour << ":" << st.wMinute << ":" << st.wSecond << ":" 
		<< st.wMilliseconds << ")\t" << szLogString << "\n";
#else
	ofs << szLogString << "\n";
#endif 

	ofs.close();
};



#if defined( TRACE_MESSAGES

//***************************************************************************
//
//	Func:
//	Purpose:
//
//
//	Returns:
//
//	In Params:
//
//  Out Params:
//
//	Note:
//
//***************************************************************************
void CDebug::ODS_MESSAGE(LPWSTR lpwstr)
{

	ofstream		ofs;
    SYSTEMTIME		st;
	char			szLogString [ BUFFER_SIZE ];
	char			szFile [ MAX_PATH ];
	BOOL			b;


	WideCharToMultiByte( CP_OEMCP, 0, lpwstr, -1, szLogString, 256, NULL, &b);

	GetLocalTime(&st);

	WideCharToMultiByte( CP_OEMCP, 0, m_cszLogFile, -1, szFile, 256, NULL, &b);

	ofs.open( "c:\\wbem\\logs\\message.log" , ios::out | ios::app);
	
	ofs << szLogString << "\n";

	ofs.close();
};

#endif // TRACE_MESSAGES

//////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\adsiclas.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:adsiclas.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the CADSIClass which encapsulates an ADSI class
//
//***************************************************************************

#ifndef ADSI_CLASS_H
#define ADSI_CLASS_H


class CADSIClass : public CRefCountedObject
{

public:
	//***************************************************************************
	//
	// CADSIClass::CADSIClass
	//
	// Purpose : Constructor 
	//
	// Parameters:
	//  lpszWBEMClassName : The WBEM name of the Class being created. A copy of this is made
	//  lpszADSIClassName : The ADSI name of the Class being created. A copy of this is made
	//***************************************************************************
	CADSIClass(LPCWSTR lpszWBEMClassName, LPCWSTR lpszADSIClassName);
	virtual ~CADSIClass();

	//***************************************************************************
	//
	// CADSIClass :: GetWBEMClassName
	// 
	// Purpose : Returns the WBEM  Class name of this Class
	//***************************************************************************
	LPCWSTR GetWBEMClassName();
	//***************************************************************************
	//
	// CADSIClass :: GetWBEMClassName
	// 
	// Purpose : Sets the WBEM  Class name of this Class
	//***************************************************************************
	void CADSIClass::SetWBEMClassName(LPCWSTR lpszName);

	//***************************************************************************
	//
	// CADSIClass :: GetADSIClassName
	// 
	// Purpose : Returns the ADSI  Class name of this Class
	//***************************************************************************
	LPCWSTR GetADSIClassName();

	//***************************************************************************
	//
	// CADSIClass :: SetADSIClassName
	// 
	// Purpose : Sets the ADSI  Class name of this Class
	//***************************************************************************
	void SetADSIClassName(LPCWSTR lpszName);

	//***************************************************************************
	//
	// CADSIClass :: GetCommonName
	// 
	// Purpose : Returns the CommonName attribute name
	//
	// Parameters:
	//	None
	//
	// Return Value:
	//	The the CommonName attribute name
	//
	//***************************************************************************
	LPCWSTR GetCommonName();

	//***************************************************************************
	//
	// CADSIClass :: SetCommonName
	// 
	// Purpose : Sets the CommonName attribute name for this class
	//
	// Parameters:
	//	The CommonName attribute name for this class
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetCommonName(LPCWSTR lpszCommonName);

	//***************************************************************************
	//
	// CADSIClass :: GetSuperClassLDAPName
	// 
	// Purpose : Returns the SuperClassLDAPName name
	//
	// Parameters:
	//	None
	//
	// Return Value:
	//	The the SuperClassLDAPName name
	//
	//***************************************************************************
	LPCWSTR GetSuperClassLDAPName();

	//***************************************************************************
	//
	// CADSIClass :: SetSuperClassLDAPName
	// 
	// Purpose : Sets the SuperClassLDAPName for this class
	//
	// Parameters:
	//	The SuperClassLDAPName for this class
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetSuperClassLDAPName(LPCWSTR lpszSuperClassLDAPName);

	//***************************************************************************
	//
	// CADSIClass :: GetGovernsID
	// 
	// Purpose : Returns the GovernsID attribute name
	//
	// Parameters:
	//	None
	//
	// Return Value:
	//	The the GovernsID attribute name
	//
	//***************************************************************************
	LPCWSTR GetGovernsID();

	//***************************************************************************
	//
	// CADSIClass :: SetGovernsID
	// 
	// Purpose : Sets the GovernsID attribute name for this class
	//
	// Parameters:
	//	The GovernsID attribute name for this class
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetGovernsID(LPCWSTR lpszGovernsID);

	//***************************************************************************
	//
	// CADSIClass :: GetSchemaIDGUID
	// 
	// Purpose : Returns the SchemaIDGUID attribute name
	//
	// Parameters:
	//	None
	//
	// Return Value:
	//	The the SchemaIDGUID attribute name
	//
	//***************************************************************************
	const LPBYTE GetSchemaIDGUID(DWORD *pdwLength);

	//***************************************************************************
	//
	// CADSIClass :: SetSchemaIDGUID
	// 
	// Purpose : Sets the SchemaIDGUID attribute name for this class
	//
	// Parameters:
	//	The SchemaIDGUID attribute name for this class
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetSchemaIDGUID(LPBYTE pOctets, DWORD dwLength);

	//***************************************************************************
	//
	// CADSIClass :: GetRDNAttribute
	// 
	// Purpose : Returns the RDN attribute name
	//
	// Parameters:
	//	None
	//
	// Return Value:
	//	The the RDN attribute name
	//
	//***************************************************************************
	LPCWSTR GetRDNAttribute();

	//***************************************************************************
	//
	// CADSIClass :: SetRDNAttribute
	// 
	// Purpose : Sets the RDN attribute name for this class
	//
	// Parameters:
	//	The RDN attribute name for this class
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetRDNAttribute(LPCWSTR lpszRDNName);

	//***************************************************************************
	//
	// CADSIClass :: GetDefaultSecurityDescriptor
	// 
	// Purpose : Returns the DefaultSecurityDescriptor attribute name
	//
	// Parameters:
	//	None
	//
	// Return Value:
	//	The the DefaultSecurityDescriptor attribute name
	//
	//***************************************************************************
	LPCWSTR GetDefaultSecurityDescriptor();

	//***************************************************************************
	//
	// CADSIClass :: SetDefaultSecurityDescriptor
	// 
	// Purpose : Sets the DefaultSecurityDescriptor attribute name for this class
	//
	// Parameters:
	//	The DefaultSecurityDescriptor attribute name for this class
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetDefaultSecurityDescriptor(LPCWSTR lpszDefaultSecurityDescriptor);

	//***************************************************************************
	//
	// CADSIClass :: GetObjectClassCategory
	// 
	// Purpose : Returns the ObjectClassCategory attribute name
	//
	// Parameters:
	//	None
	//
	// Return Value:
	//	The the ObjectClassCategory attribute name
	//
	//***************************************************************************
	DWORD GetObjectClassCategory();

	//***************************************************************************
	//
	// CADSIClass :: SetObjectClassCategory
	// 
	// Purpose : Sets the ObjectClassCategory attribute name for this class
	//
	// Parameters:
	//	The ObjectClassCategory attribute name for this class
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetObjectClassCategory(DWORD dwObjectClassCategory);

	//***************************************************************************
	//
	// CADSIClass :: GetNTSecurityDescriptor
	// 
	// Purpose : Returns the SchemaIDGUID attribute name
	//
	// Parameters:
	//	None
	//
	// Return Value:
	//	The the SchemaIDGUID attribute name
	//
	//***************************************************************************
	const LPBYTE GetNTSecurityDescriptor(DWORD *pdwLength);

	//***************************************************************************
	//
	// CADSIClass :: SetNTSecurityDescriptor
	// 
	// Purpose : Sets the SetNTSecurityDescriptor attribute name for this class
	//
	// Parameters:
	//	The SetNTSecurityDescriptor attribute name for this class
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetNTSecurityDescriptor(LPBYTE pOctets, DWORD dwLength);

	//***************************************************************************
	//
	// CADSIClass :: GetDefaultObjectCategory
	// 
	// Purpose : Returns the DefaultObjectCategory attribute name
	//
	// Parameters:
	//	None
	//
	// Return Value:
	//	The the DefaultObjectCategory attribute name
	//
	//***************************************************************************
	LPCWSTR GetDefaultObjectCategory();

	//***************************************************************************
	//
	// CADSIClass :: SetDefaultObjectCategory
	// 
	// Purpose : Sets the DefaultObjectCategory attribute name for this class
	//
	// Parameters:
	//	The DefaultObjectCategory attribute name for this class
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetDefaultObjectCategory(LPCWSTR lpszDefaultObjectCategory);

	//***************************************************************************
	//
	// CADSIClass :: GetSystemOnly
	// 
	// Purpose : Returns the SystemOnly attribute name
	//
	// Parameters:
	//	None
	//
	// Return Value:
	//	The the SystemOnly attribute name
	//
	//***************************************************************************
	BOOLEAN GetSystemOnly();

	//***************************************************************************
	//
	// CADSIClass :: SetSystemOnly
	// 
	// Purpose : Sets the SystemOnly attribute name for this class
	//
	// Parameters:
	//	The SystemOnly attribute name for this class
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetSystemOnly(BOOLEAN bSystemOnly);

	//***************************************************************************
	//
	// CADSIClass :: GetAuxiliaryClasses
	// 
	// Purpose : Gets the list of auxiliary classes for this class
	//
	// Parameters:
	//	pdwCount : The address where the number of elements in the returned array will be put
	//
	// Return Value:
	//	An array of strings which are the names of the auxiliary of this class
	//***************************************************************************
	LPCWSTR *GetAuxiliaryClasses(DWORD *pdwCount);

	//***************************************************************************
	//
	// CADSIClass :: SetAuxiliaryClasses
	// 
	// Purpose : Sets the list of auxiliary classes for this class
	//
	// Parameters:
	//	pValues : The values of this property
	//	dwNumValues : The number of values
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetAuxiliaryClasses(PADSVALUE pValues, DWORD dwNumValues);

	//***************************************************************************
	//
	// CADSIClass :: GetSystemAuxiliaryClasses
	// 
	// Purpose : Gets the list of System auxiliary classes for this class
	//
	// Parameters:
	//	pdwCount : The address where the number of elements in the returned array will be put
	//
	// Return Value:
	//	An array of strings which are the names of the System auxiliary of this class
	//***************************************************************************
	LPCWSTR *GetSystemAuxiliaryClasses(DWORD *pdwCount);

	//***************************************************************************
	//
	// CADSIClass :: SetSystemAuxiliaryClasses
	// 
	// Purpose : Sets the list of System auxiliary classes for this class
	//
	// Parameters:
	//	pValues : The values of this property
	//	dwNumValues : The number of values
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetSystemAuxiliaryClasses(PADSVALUE pValues, DWORD dwNumValues);

	//***************************************************************************
	//
	// CADSIClass :: GetPossibleSuperiors
	// 
	// Purpose : Gets the list of possible superiors for this class
	//
	// Parameters:
	//	pdwCount : The address where the number of elements in the returned array will be put
	//
	// Return Value:
	//	An array of strings which are the names of the possible superiors of this class
	//***************************************************************************
	LPCWSTR *GetPossibleSuperiors(DWORD *pdwCount);

	//***************************************************************************
	//
	// CADSIClass :: SetPossibleSuperiors
	// 
	// Purpose : Sets the list of possible superiors for this class
	//
	// Parameters:
	//	pValues : The values of this property
	//	dwNumValues : The number of values
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetPossibleSuperiors(PADSVALUE pValues, DWORD dwNumValues);

	//***************************************************************************
	//
	// CADSIClass :: GetSystemPossibleSuperiors
	// 
	// Purpose : Gets the list of System possible superiors for this class
	//
	// Parameters:
	//	pdwCount : The address where the number of elements in the returned array will be put
	//
	// Return Value:
	//	An array of strings which are the names of the System possible superiors of this class
	//***************************************************************************
	LPCWSTR *GetSystemPossibleSuperiors(DWORD *pdwCount);

	//***************************************************************************
	//
	// CADSIClass :: SetSystemPossibleSuperiors
	// 
	// Purpose : Sets the list of System possible superiors for this class
	//
	// Parameters:
	//	pValues : The values of this property
	//	dwNumValues : The number of values
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetSystemPossibleSuperiors(PADSVALUE pValues, DWORD dwNumValues);

	//***************************************************************************
	//
	// CADSIClass :: GetMayContains
	// 
	// Purpose : Gets the list of May Contains for this class
	//
	// Parameters:
	//	pdwCount : The address where the number of elements in the returned array will be put
	//
	// Return Value:
	//	An array of strings which are the names of the May Contains of this class
	//***************************************************************************
	LPCWSTR *GetMayContains(DWORD *pdwCount);

	//***************************************************************************
	//
	// CADSIClass :: SetMayContains
	// 
	// Purpose : Sets the list of MayContains for this class
	//
	// Parameters:
	//	pValues : The values of this property
	//	dwNumValues : The number of values
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetMayContains(PADSVALUE pValues, DWORD dwNumValues);

	//***************************************************************************
	//
	// CADSIClass :: GetSystemMayContains
	// 
	// Purpose : Gets the list of System MayC ontains for this class
	//
	// Parameters:
	//	pdwCount : The address where the number of elements in the returned array will be put
	//
	// Return Value:
	//	An array of strings which are the names of the System May Contains of this class
	//***************************************************************************
	LPCWSTR *GetSystemMayContains(DWORD *pdwCount);

	//***************************************************************************
	//
	// CADSIClass :: SetSystemMayContains
	// 
	// Purpose : Sets the list of System May Contains for this class
	//
	// Parameters:
	//	pValues : The values of this property
	//	dwNumValues : The number of values
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetSystemMayContains(PADSVALUE pValues, DWORD dwNumValues);

	//***************************************************************************
	//
	// CADSIClass :: GetMustContains
	// 
	// Purpose : Gets the list of Must Contains for this class
	//
	// Parameters:
	//	pdwCount : The address where the number of elements in the returned array will be put
	//
	// Return Value:
	//	An array of strings which are the names of the Must Contains of this class
	//***************************************************************************
	LPCWSTR *GetMustContains(DWORD *pdwCount);

	//***************************************************************************
	//
	// CADSIClass :: SetMustContains
	// 
	// Purpose : Sets the list of Must Contains for this class
	//
	// Parameters:
	//	pValues : The values of this property
	//	dwNumValues : The number of values
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetMustContains(PADSVALUE pValues, DWORD dwNumValues);

	//***************************************************************************
	//
	// CADSIClass :: GetSystemMustContains
	// 
	// Purpose : Gets the list of System Must Contains for this class
	//
	// Parameters:
	//	pdwCount : The address where the number of elements in the returned array will be put
	//
	// Return Value:
	//	An array of strings which are the names of the System Must Contains of this class
	//***************************************************************************
	LPCWSTR *GetSystemMustContains(DWORD *pdwCount);

	//***************************************************************************
	//
	// CADSIClass :: SetSystemMustContains
	// 
	// Purpose : Sets the list of System Must Contains for this class
	//
	// Parameters:
	//	pValues : The values of this property
	//	dwNumValues : The number of values
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetSystemMustContains(PADSVALUE pValues, DWORD dwNumValues);

protected:
	// The WBEM name of this class
	LPWSTR m_lpszWBEMClassName;

	// The Common Name (cn) of this class
	LPWSTR m_lpszCommonName;

	// The LDAP Name of the super class
	LPWSTR m_lpszSuperClassLDAPName;

	// The GovernsID attribute
	LPWSTR m_lpszGovernsID;

	// The SchemaIDGUID attribute
	LPBYTE m_pSchemaIDGUIDOctets;
	DWORD m_dwSchemaIDGUIDLength;

	// The RDN Attribute for this class
	LPWSTR m_lpszRDNAttribute;

	// The Default Security Descriptor Attribute for this class
	LPWSTR m_lpszDefaultSecurityDescriptor;

	// The Object Class Category
	DWORD m_dwObjectClassCategory;

	// The NT Security Descriptor Attribute for this class
	LPBYTE m_pNTSecurityDescriptor;
	DWORD m_dwNTSecurityDescriptorLength;

	// The system-only attribute
	BOOLEAN m_bSystemOnly;

	// The Default Object Category
	LPWSTR m_lpszDefaultObjectCategory;

	// The list of auxiliary classes and its count
	LPWSTR *m_lppszAuxiliaryClasses;
	DWORD m_dwAuxiliaryClassesCount;

	// The list of System auxiliary classes and its count
	LPWSTR *m_lppszSystemAuxiliaryClasses;
	DWORD m_dwSystemAuxiliaryClassesCount;

	// The list of possible superiors and its count
	LPWSTR *m_lppszPossibleSuperiors;
	DWORD m_dwPossibleSuperiorsCount;

	// The list of System possible superiors and its count
	LPWSTR *m_lppszSystemPossibleSuperiors;
	DWORD m_dwSystemPossibleSuperiorsCount;

	// The list of may contains and its count
	LPWSTR *m_lppszMayContains;
	DWORD m_dwMayContainsCount;

	// The list of System may contains and its count
	LPWSTR *m_lppszSystemMayContains;
	DWORD m_dwSystemMayContainsCount;

	// The list of must contains and its count
	LPWSTR *m_lppszMustContains;
	DWORD m_dwMustContainsCount;

	// The list of System must contains and its count
	LPWSTR *m_lppszSystemMustContains;
	DWORD m_dwSystemMustContainsCount;

};

#endif /* ADSI_CLASS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\adsihelp.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:adsihelp.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the CADSIHelper class. This is
//	a class that has many static helper functions pertaining to ADSI
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef ADSI_HELPER_H
#define ADSI_HELPER_H

class CADSIHelper
{
public:

	// Deallocates an array of BSTRs and its contents
	static void DeallocateBSTRArray(BSTR *pStrPropertyValue, LONG lNumber);

private:
	static HRESULT ProcessBSTRArrayProperty(
		VARIANT *pVariant, 
		BSTR **ppStrPropertyValues,
		LONG *pLong);
};

#endif /* ADSI_HELPER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\adsiprop.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:adsiprop.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the implementation of the CADSIProperty which encapsulates an ADSI property
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
// CADSIProperty::CADSIProperty
//
// Purpose : Constructor 
//
// Parameters:
//	None
//***************************************************************************
CADSIProperty :: CADSIProperty()
	: CRefCountedObject()
{
	m_lpszWBEMPropertyName = NULL;
	m_lpszSyntaxOID = NULL;
	m_bMultiValued = FALSE;
	m_lpszAttributeID = NULL;
	m_lpszCommonName = NULL;
	m_bSystemOnly = FALSE;
	m_pDirectoryObject = NULL;
	m_bORName = FALSE;
}

//***************************************************************************
//
// CADSIProperty::CADSIProperty
//
// Purpose : Constructor 
//
// Parameters:
//  lpszWBEMPropertyName : The WBEM name of the property being created. A copy of this is made
//  lpszADSIPropertyName : The ADSI name of the property being created. A copy of this is made
//***************************************************************************
CADSIProperty :: CADSIProperty(LPCWSTR lpszWBEMPropertyName, LPCWSTR lpszADSIPropertyName)
	: CRefCountedObject(lpszADSIPropertyName)
{
	m_lpszWBEMPropertyName = new WCHAR[wcslen(lpszWBEMPropertyName) + 1];
	wcscpy(m_lpszWBEMPropertyName, lpszWBEMPropertyName);

	m_lpszSyntaxOID = NULL;
	m_bMultiValued = FALSE;
	m_lpszAttributeID = NULL;
	m_lpszCommonName = NULL;
	m_bSystemOnly = FALSE;
	m_pDirectoryObject = NULL;
	m_bORName = FALSE;
}


//***************************************************************************
//
// CADSIProperty :: ~CADSIProperty
// 
// Purpose : Destructor
//***************************************************************************
CADSIProperty :: ~CADSIProperty()
{
	delete [] m_lpszWBEMPropertyName;
	delete [] m_lpszSyntaxOID;
	delete [] m_lpszAttributeID;
	delete [] m_lpszCommonName;

	if(m_pDirectoryObject)
		m_pDirectoryObject->Release();
}


//***************************************************************************
//
// CADSIProperty :: GetWBEMPropertyName
// 
// Purpose : Returns the WBEM  property name of this property
//***************************************************************************
LPCWSTR CADSIProperty :: GetWBEMPropertyName()
{
	return m_lpszWBEMPropertyName;
}

//***************************************************************************
//
// CADSIProperty :: SetWBEMPropertyName
// 
// Purpose : Sets the WBEM name of this property
//***************************************************************************
void CADSIProperty :: SetWBEMPropertyName(LPCWSTR lpszWBEMName)
{
	delete [] m_lpszWBEMPropertyName;
	if(lpszWBEMName)
	{
		m_lpszWBEMPropertyName = new WCHAR[wcslen(lpszWBEMName) + 1];
		wcscpy(m_lpszWBEMPropertyName, lpszWBEMName);
	}
	else
		m_lpszWBEMPropertyName = NULL;
}

//***************************************************************************
//
// CADSIProperty :: GetADSIPropertyName
// 
// Purpose : Returns the ADSI  property name of this property
//***************************************************************************
LPCWSTR CADSIProperty :: GetADSIPropertyName()
{
	return GetName();
}

//***************************************************************************
//
// CADSIProperty :: SetADSIPropertyName
// 
// Purpose : Sets the ADSI name of this property
//***************************************************************************
void CADSIProperty :: SetADSIPropertyName(LPCWSTR lpszADSIName)
{
	SetName(lpszADSIName);
}

//***************************************************************************
//
// CADSIProperty :: GetSyntaxOID
// 
// Purpose : Returns the ADSI Syntax OID of this property
//***************************************************************************
LPCWSTR CADSIProperty :: GetSyntaxOID()
{
	return m_lpszSyntaxOID;
}

//***************************************************************************
//
// CADSIProperty :: SetSyntaxOID
// 
// Purpose : Sets the ADSI Syntax OID of this property
//***************************************************************************
void CADSIProperty :: SetSyntaxOID(LPCWSTR lpszSyntaxOID)
{
	delete [] m_lpszSyntaxOID;
	if(lpszSyntaxOID)
	{
		m_lpszSyntaxOID = new WCHAR[wcslen(lpszSyntaxOID) + 1];
		wcscpy(m_lpszSyntaxOID, lpszSyntaxOID);
	}
	else
		m_lpszSyntaxOID = NULL;
}

//***************************************************************************
//
// CADSIProperty :: IsORName
// 
// Purpose : Returns whether the property is m_bORName
//***************************************************************************
BOOLEAN CADSIProperty :: IsORName()
{
	return m_bORName;
}

//***************************************************************************
//
// CADSIProperty :: SetORName
// 
// Purpose : Sets the m_bORName property of this property
//***************************************************************************
void CADSIProperty :: SetORName(BOOLEAN bORName)
{
	m_bORName = bORName;
}


//***************************************************************************
//
// CADSIProperty :: IsMultiValued
// 
// Purpose : Returns whether the property is multi valued
//***************************************************************************
BOOLEAN CADSIProperty :: IsMultiValued()
{
	return m_bMultiValued;
}

//***************************************************************************
//
// CADSIProperty :: SetMultiValued
// 
// Purpose : Sets the multi-valued property of this property
//***************************************************************************
void CADSIProperty :: SetMultiValued(BOOLEAN bMultiValued)
{
	m_bMultiValued = bMultiValued;
}

//***************************************************************************
//
// CADSIProperty :: IsSystemOnly
// 
// Purpose : Returns whether the property is SystemOnly
//***************************************************************************
BOOLEAN CADSIProperty :: IsSystemOnly()
{
	return m_bSystemOnly;
}

//***************************************************************************
//
// CADSIProperty :: SetSystemOnly
// 
// Purpose : Sets the SystemOnly property of this property
//***************************************************************************
void CADSIProperty :: SetSystemOnly(BOOLEAN bSystemOnly)
{
	m_bSystemOnly = bSystemOnly;
}

//***************************************************************************
//
// CADSIProperty :: GetSearchFlags
// 
// Purpose : Returns the SearchFlags property of the property
//***************************************************************************
DWORD CADSIProperty :: GetSearchFlags()
{
	return m_dwSearchFlags;
}

//***************************************************************************
//
// CADSIProperty :: SetSearchFlags
// 
// Purpose : Sets the SearchFlags property of this property
//***************************************************************************
void CADSIProperty :: SetSearchFlags(DWORD dwSearchFlags)
{
	m_dwSearchFlags = dwSearchFlags;
}

//***************************************************************************
//
// CADSIProperty :: GetOMSyntax
// 
// Purpose : Returns the OMSyntax property of the property
//***************************************************************************
DWORD CADSIProperty :: GetOMSyntax()
{
	return m_dwOMSyntax;
}

//***************************************************************************
//
// CADSIProperty :: SetOMSyntax
// 
// Purpose : Sets the OMSyntax property of this property
//***************************************************************************
void CADSIProperty :: SetOMSyntax(DWORD dwOMSyntax)
{
	m_dwOMSyntax = dwOMSyntax;
}

//***************************************************************************
//
// CADSIProperty :: GetMAPI_ID
// 
// Purpose : Returns the MAPI_ID property of the property
//***************************************************************************
DWORD CADSIProperty :: GetMAPI_ID()
{
	return m_dwMAPI_ID;
}

//***************************************************************************
//
// CADSIProperty :: SetMAPI_ID
// 
// Purpose : Sets the MAPI_ID property of this property
//***************************************************************************
void CADSIProperty :: SetMAPI_ID(DWORD dwMAPI_ID)
{
	m_dwMAPI_ID = dwMAPI_ID;
}

//***************************************************************************
//
// CADSIProperty :: GetAttributeID
// 
// Purpose : Returns the Attribute ID of this property
//***************************************************************************
LPCWSTR CADSIProperty :: GetAttributeID()
{
	return m_lpszAttributeID;
}

//***************************************************************************
//
// CADSIProperty :: SetAttributeID
// 
// Purpose : Sets the Attribute ID of this property
//***************************************************************************
void CADSIProperty :: SetAttributeID(LPCWSTR lpszAttributeID)
{
	delete [] m_lpszAttributeID;
	if(lpszAttributeID)
	{
		m_lpszAttributeID = new WCHAR[wcslen(lpszAttributeID) + 1];
		wcscpy(m_lpszAttributeID, lpszAttributeID);
	}
	else
		m_lpszAttributeID = NULL;
}

//***************************************************************************
//
// CADSIProperty :: GetCommonName
// 
// Purpose : Returns the Common Name of this property
//***************************************************************************
LPCWSTR CADSIProperty :: GetCommonName()
{
	return m_lpszCommonName;
}

//***************************************************************************
//
// CADSIProperty :: SetCommonName
// 
// Purpose : Sets the CommonName of this property
//***************************************************************************
void CADSIProperty :: SetCommonName(LPCWSTR lpszCommonName)
{
	delete [] m_lpszCommonName;
	if(lpszCommonName)
	{
		m_lpszCommonName = new WCHAR[wcslen(lpszCommonName) + 1];
		wcscpy(m_lpszCommonName, lpszCommonName);
	}
	else
		m_lpszCommonName = NULL;
}

//***************************************************************************
//
// CADSIProperty :: GetDirectoryObject
// 
// Purpose : Returns the ADSI object pertaining to this property
//	It is the user's duty to release it when done
// 
// Parameters:
//	None
//
// Return Value:
//	The ADSI object interface pertaining to this property	
//***************************************************************************
IDirectoryObject *CADSIProperty :: GetDirectoryObject()
{
	if(m_pDirectoryObject)
		m_pDirectoryObject->AddRef();
	return m_pDirectoryObject;
}

//***************************************************************************
//
// CADSIProperty :: SetDirectoryObject
// 
// Purpose : Sets the ADSI object pertaining to this property
//
// Parameter : The directory object pertaining to this property
//***************************************************************************
void CADSIProperty :: SetDirectoryObject(IDirectoryObject * pDirectoryObject)
{
	if(m_pDirectoryObject)
		m_pDirectoryObject->Release();
	m_pDirectoryObject = pDirectoryObject;
	m_pDirectoryObject->AddRef();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\adsihelp.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:adsihelp.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the implementation the CADSIHelper class. This is
//	a class that has many static helper functions pertaining to ADSI
//***************************************************************************
/////////////////////////////////////////////////////////////////////////



#include <windows.h>
#include <activeds.h>

#include "adsihelp.h"


//***************************************************************************
//
// CADSiHelper::ProcessBSTRArrayProperty
//
// Purpose: Processes a variant containing an array of BSTR or a single BSTR
//
// Parameters:
//	pVariant : The variant to be processed
//	ppStrPropertyValue : The addres of the pointer to a BSTR array where the list of BSTRS representing
//		the ADSI paths of the derived classes will be put
//	lNumber : The number of elements in the retrieved array.
//
//
// Return Value: The COM value representing the return status. It is the responsibility
//	of the caller to release the array that is returned, as well as its contents. The varinat
//	passed in is not cleared
//
//***************************************************************************
HRESULT CADSIHelper :: ProcessBSTRArrayProperty(VARIANT *pVariant, BSTR **ppStrPropertyValues, LONG *lpNumber)
{
	HRESULT result = S_OK;
	VARIANT vTemp;
	if(pVariant->vt == VT_BSTR) // When the number of values is 1
	{
		*lpNumber = 1;
		*ppStrPropertyValues = new BSTR[*lpNumber];
		(*ppStrPropertyValues)[0] = SysAllocString(pVariant->bstrVal);
	}
	else if (pVariant->vt == (VT_VARIANT|VT_ARRAY) )
	{
		SAFEARRAY *pSafeArray = pVariant->parray;
		*lpNumber = 0;
		if(SUCCEEDED(result = SafeArrayGetUBound(pSafeArray, 1, lpNumber)) )
		{
			*ppStrPropertyValues = new BSTR[*lpNumber];
			for(LONG index=0L; index<(*lpNumber); index++)
			{
				if( FAILED( result = SafeArrayGetElement(pSafeArray, &index, (LPVOID)&vTemp) ))
				{
					// Reset the count to the actual number retrieved
					*lpNumber = index;
					break;
				}
				(*ppStrPropertyValues)[index] = SysAllocString(vTemp.bstrVal);
				VariantClear(&vTemp);
			}
		}
	}
	else
		result = E_FAIL;
	return result;
}

//***************************************************************************
//
// CADSiHelper :: DeallocateBSTRArray
//
// Purpose: Deallocates an array of BSTRs and its contents
//
// Parameters:
//	pStrPropertyValue : The pointer to the array to be deallocated
//	lNumber : The number of elements in the array.
//
//
// Return Value: None
//
//***************************************************************************
void CADSIHelper :: DeallocateBSTRArray(BSTR *pStrPropertyValue, LONG lNumber)
{
	for(lNumber--; lNumber>=0; lNumber--)
		SysFreeString(pStrPropertyValue[lNumber]);

	delete[] pStrPropertyValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\adsiclas.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:adsiclas.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the implementation of the CADSIClass which encapsulates an ADSI class
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
// CADSIClass::CADSIClass
//
// Purpose : Constructor 
//
// Parameters:
//  lpszWBEMClassName : The WBEM name of the Class being created. A copy of this is made
//  lpszADSIClassName : The ADSI name of the Class being created. A copy of this is made
//***************************************************************************
CADSIClass :: CADSIClass(LPCWSTR lpszWBEMClassName, LPCWSTR lpszADSIClassName)
	: CRefCountedObject(lpszADSIClassName)
{
	if(lpszWBEMClassName)
	{
		m_lpszWBEMClassName = new WCHAR[wcslen(lpszWBEMClassName) + 1];
		wcscpy(m_lpszWBEMClassName, lpszWBEMClassName);
	}
	else
	{
		m_lpszWBEMClassName = NULL;
	}

	// Set the attributes to theri default values
	m_lpszCommonName = NULL;
	m_lpszSuperClassLDAPName = NULL;
	m_lpszGovernsID = NULL;
	m_pSchemaIDGUIDOctets = NULL;
	m_dwSchemaIDGUIDLength = 0;
	m_lpszRDNAttribute = NULL;
	m_lpszDefaultSecurityDescriptor = NULL;
	m_dwObjectClassCategory = 0;
	m_dwNTSecurityDescriptorLength = 0;
	m_pNTSecurityDescriptor = NULL;
	m_lpszDefaultObjectCategory = NULL;
	m_bSystemOnly = FALSE;

	// Initialize the property book keeping
	m_lppszAuxiliaryClasses = NULL;
	m_dwAuxiliaryClassesCount = 0;
	m_lppszSystemAuxiliaryClasses = NULL;
	m_dwSystemAuxiliaryClassesCount = 0;
	m_lppszPossibleSuperiors = NULL;
	m_dwPossibleSuperiorsCount = 0;
	m_lppszSystemPossibleSuperiors = NULL;
	m_dwSystemPossibleSuperiorsCount = 0;
	m_lppszMayContains = NULL;
	m_dwMayContainsCount = 0;
	m_lppszSystemMayContains = NULL;
	m_dwSystemMayContainsCount = 0;
	m_lppszMustContains = NULL;
	m_dwMustContainsCount = 0;
	m_lppszSystemMustContains = NULL;
	m_dwSystemMustContainsCount = 0;
}


//***************************************************************************
//
// CADSIClass :: ~CADSIClass
// 
// Purpose : Destructor
//***************************************************************************
CADSIClass :: ~CADSIClass()
{
	// Delete the WBEM Name. The ADSI Name is deleted in the base class destructor
	if ( m_lpszWBEMClassName )
	{
		delete [] m_lpszWBEMClassName;
		m_lpszWBEMClassName = NULL;
	}

	// Delete the attributes
	if ( m_lpszCommonName )
	{
		delete [] m_lpszCommonName;
		m_lpszCommonName = NULL;
	}
	if ( m_lpszSuperClassLDAPName )
	{
		delete [] m_lpszSuperClassLDAPName;
		m_lpszSuperClassLDAPName = NULL;
	}
	if ( m_lpszGovernsID )
	{
		delete [] m_lpszGovernsID;
		m_lpszGovernsID = NULL;
	}
	if ( m_pSchemaIDGUIDOctets ) 
	{
		delete [] m_pSchemaIDGUIDOctets;
		m_pSchemaIDGUIDOctets = NULL;
	}
	if ( m_lpszRDNAttribute )
	{
		delete [] m_lpszRDNAttribute;
		m_lpszRDNAttribute = NULL;
	}
	if ( m_lpszDefaultSecurityDescriptor )
	{
		delete [] m_lpszDefaultSecurityDescriptor;
		m_lpszDefaultSecurityDescriptor = NULL;
	}
	if ( m_pNTSecurityDescriptor )
	{
		delete [] m_pNTSecurityDescriptor;
		m_pNTSecurityDescriptor = NULL;
	}
	if ( m_lpszDefaultObjectCategory )
	{
		delete [] m_lpszDefaultObjectCategory;
		m_lpszDefaultObjectCategory = NULL;
	}

	DWORD i;
	// Delete the list of Auxiliary Classes
	if ( m_lppszAuxiliaryClasses )
	{
		for(i=0; i<m_dwAuxiliaryClassesCount; i++)
		{
			delete [] m_lppszAuxiliaryClasses[i];
			m_lppszAuxiliaryClasses[i] = NULL;
		}
		delete[] m_lppszAuxiliaryClasses;
		m_lppszAuxiliaryClasses = NULL;
	}

	// Delete the list of System Auxiliary Classes
	if ( m_lppszSystemAuxiliaryClasses )
	{
		for(i=0; i<m_dwSystemAuxiliaryClassesCount; i++)
		{
			delete [] m_lppszSystemAuxiliaryClasses[i];
			m_lppszSystemAuxiliaryClasses[i] = NULL;
		}
		delete[] m_lppszSystemAuxiliaryClasses;
		m_lppszSystemAuxiliaryClasses = NULL;
	}

	// Delete the list of possible superiors
	if ( m_lppszPossibleSuperiors )
	{
		for(i=0; i<m_dwPossibleSuperiorsCount; i++)
		{
			delete [] m_lppszPossibleSuperiors[i];
			m_lppszPossibleSuperiors[i] = NULL;
		}
		delete[] m_lppszPossibleSuperiors;
		m_lppszPossibleSuperiors = NULL;
	}

	// Delete the list of System possible superiors
	if ( m_lppszSystemPossibleSuperiors )
	{
		for(i=0; i<m_dwSystemPossibleSuperiorsCount; i++)
		{
			delete [] m_lppszSystemPossibleSuperiors[i];
			m_lppszSystemPossibleSuperiors[i] = NULL;
		}
		delete[] m_lppszSystemPossibleSuperiors;
		m_lppszSystemPossibleSuperiors = NULL;
	}

	// Delete the list of may contains
	if ( m_lppszMayContains )
	{
		for(i=0; i<m_dwMayContainsCount; i++)
		{
			delete [] m_lppszMayContains[i];
			m_lppszMayContains[i] = NULL;
		}
		delete[] m_lppszMayContains;
		m_lppszMayContains = NULL;
	}

	// Delete the list of System may contains
	if ( m_lppszSystemMayContains )
	{
		for(i=0; i<m_dwSystemMayContainsCount; i++)
		{
			delete [] m_lppszSystemMayContains[i];
			m_lppszSystemMayContains[i] = NULL;
		}
		delete[] m_lppszSystemMayContains;
		m_lppszSystemMayContains = NULL;
	}

	// Delete the list of Must Contains
	if ( m_lppszMustContains )
	{
		for(i=0; i<m_dwMustContainsCount; i++)
		{
			delete [] m_lppszMustContains[i];
			m_lppszMustContains[i] = NULL;
		}
		delete[] m_lppszMustContains;
		m_lppszMustContains = NULL;
	}

	// Delete the list of System Must Contains
	if ( m_lppszSystemMustContains )
	{
		for(i=0; i<m_dwSystemMustContainsCount; i++)
		{
			delete [] m_lppszSystemMustContains[i];
			m_lppszSystemMustContains[i] = NULL;
		}
		delete[] m_lppszSystemMustContains;
		m_lppszSystemMustContains = NULL;
	}

}


//***************************************************************************
//
// CADSIClass :: GetWBEMClassName
// 
// Purpose : Returns the WBEM  Class name of this Class
//***************************************************************************
LPCWSTR CADSIClass :: GetWBEMClassName()
{
	return m_lpszWBEMClassName;
}

//***************************************************************************
//
// CADSIClass :: GetWBEMClassName
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass::SetWBEMClassName(LPCWSTR lpszName)
{
	if ( m_lpszWBEMClassName )
	{
		delete[] m_lpszWBEMClassName;
		m_lpszWBEMClassName = NULL;
	}

	if(lpszName)
	{
		m_lpszWBEMClassName = new WCHAR[wcslen(lpszName) + 1];
		wcscpy(m_lpszWBEMClassName, lpszName);
	}
}

//***************************************************************************
//
// CADSIClass :: GetADSIClassName
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR CADSIClass :: GetADSIClassName()
{
	return GetName();
}

//***************************************************************************
//
// CADSIClass :: GetADSIClassName
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetADSIClassName(LPCWSTR lpszName)
{
	SetName(lpszName);
}

//***************************************************************************
//
// CADSIClass :: GetCommonName
// 
// Purpose : See Header
//
//***************************************************************************
LPCWSTR CADSIClass :: GetCommonName()
{
	return m_lpszCommonName;
}

//***************************************************************************
//
// CADSIClass :: SetCommonName
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetCommonName(LPCWSTR lpszCommonName)
{
	if ( m_lpszCommonName )
	{
		delete[] m_lpszCommonName;
		m_lpszCommonName = NULL;
	}

	if(lpszCommonName)
	{
		m_lpszCommonName = new WCHAR[wcslen(lpszCommonName) + 1];
		wcscpy(m_lpszCommonName, lpszCommonName);
	}
}


//***************************************************************************
//
// CADSIClass :: GetSuperClassLDAPName
// 
// Purpose : See Header
//
//***************************************************************************
LPCWSTR CADSIClass :: GetSuperClassLDAPName()
{
	return m_lpszSuperClassLDAPName;
}

//***************************************************************************
//
// CADSIClass :: SetSuperClassLDAPName
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetSuperClassLDAPName(LPCWSTR lpszSuperClassLDAPName)
{
	if ( m_lpszSuperClassLDAPName )
	{
		delete[] m_lpszSuperClassLDAPName;
		m_lpszSuperClassLDAPName = NULL;
	}

	if(lpszSuperClassLDAPName)
	{
		m_lpszSuperClassLDAPName = new WCHAR[wcslen(lpszSuperClassLDAPName) + 1];
		wcscpy(m_lpszSuperClassLDAPName, lpszSuperClassLDAPName);
	}
}

//***************************************************************************
//
// CADSIClass :: GetGovernsID
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR CADSIClass :: GetGovernsID()
{
	return m_lpszGovernsID;
}

//***************************************************************************
//
// CADSIClass :: SetGovernsID
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetGovernsID(LPCWSTR lpszGovernsID)
{
	if ( m_lpszGovernsID )
	{
		delete[] m_lpszGovernsID;
		m_lpszGovernsID = NULL;
	}

	if(lpszGovernsID)
	{
		m_lpszGovernsID = new WCHAR[wcslen(lpszGovernsID) + 1];
		wcscpy(m_lpszGovernsID, lpszGovernsID);
	}
}

//***************************************************************************
//
// CADSIClass :: GetSchemaIDGUID
// 
// Purpose : See Header
//***************************************************************************
const LPBYTE CADSIClass :: GetSchemaIDGUID(DWORD *pdwLength)
{
	*pdwLength = m_dwSchemaIDGUIDLength;
	return m_pSchemaIDGUIDOctets;
}

//***************************************************************************
//
// CADSIClass :: SetSchemaIDGUID
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetSchemaIDGUID(LPBYTE pOctets, DWORD dwLength)
{
	if ( m_pSchemaIDGUIDOctets )
	{
		delete[] m_pSchemaIDGUIDOctets;
		m_pSchemaIDGUIDOctets = NULL;
	}

	m_dwSchemaIDGUIDLength = 0;

	if(pOctets)
	{
		m_dwSchemaIDGUIDLength = dwLength;
		if(m_pSchemaIDGUIDOctets = new BYTE[dwLength])
		{
			for(DWORD i=0; i<dwLength; i++)
				m_pSchemaIDGUIDOctets[i] = pOctets[i];
		}
	}
}

//***************************************************************************
//
// CADSIClass :: GetRDNAttribute
// 
// Purpose : See Header
//
//***************************************************************************
LPCWSTR CADSIClass :: GetRDNAttribute()
{
	return m_lpszRDNAttribute;
}

//***************************************************************************
//
// CADSIClass :: SetRDNAttribute
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetRDNAttribute(LPCWSTR lpszRDNAttribute)
{
	if ( m_lpszRDNAttribute )
	{
		delete[] m_lpszRDNAttribute;
		m_lpszRDNAttribute = NULL;
	}

	if(lpszRDNAttribute)
	{
		m_lpszRDNAttribute = new WCHAR[wcslen(lpszRDNAttribute) + 1];
		wcscpy(m_lpszRDNAttribute, lpszRDNAttribute);
	}
}


//***************************************************************************
//
// CADSIClass :: GetDefaultSecurityDescriptor
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR CADSIClass :: GetDefaultSecurityDescriptor()
{
	return m_lpszDefaultSecurityDescriptor;
}

//***************************************************************************
//
// CADSIClass :: SetDefaultSecurityDescriptor
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetDefaultSecurityDescriptor(LPCWSTR lpszDefaultSecurityDescriptor)
{
	if ( m_lpszDefaultSecurityDescriptor )
	{
		delete[] m_lpszDefaultSecurityDescriptor;
		m_lpszDefaultSecurityDescriptor = NULL;
	}

	if( lpszDefaultSecurityDescriptor)
	{
		m_lpszDefaultSecurityDescriptor = new WCHAR[wcslen(lpszDefaultSecurityDescriptor) + 1];
		wcscpy(m_lpszDefaultSecurityDescriptor, lpszDefaultSecurityDescriptor);
	}
}

//***************************************************************************
//
// CADSIClass :: GetObjectClassCategory
// 
// Purpose : See Header
//***************************************************************************
DWORD CADSIClass :: GetObjectClassCategory()
{
	return m_dwObjectClassCategory;
}

//***************************************************************************
//
// CADSIClass :: SetObjectClassCategory
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetObjectClassCategory(DWORD dwObjectClassCategory)
{
	m_dwObjectClassCategory = dwObjectClassCategory;
}

//***************************************************************************
//
// CADSIClass :: GetNTSecurityDescriptor
// 
// Purpose : See Header
//***************************************************************************
const LPBYTE CADSIClass :: GetNTSecurityDescriptor(DWORD *pdwLength)
{
	*pdwLength = m_dwNTSecurityDescriptorLength;
	return m_pNTSecurityDescriptor;
}

//***************************************************************************
//
// CADSIClass :: SetNTSecurityDescriptor
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetNTSecurityDescriptor(LPBYTE pOctets, DWORD dwLength)
{
	if ( m_pNTSecurityDescriptor )
	{
		delete[] m_pNTSecurityDescriptor;
		m_pNTSecurityDescriptor = NULL;
	}

	m_dwNTSecurityDescriptorLength = 0;

	if(pOctets)
	{
		m_dwNTSecurityDescriptorLength = dwLength;
		if(m_pNTSecurityDescriptor = new BYTE[dwLength])
		{
			for(DWORD i=0; i<dwLength; i++)
				m_pNTSecurityDescriptor[i] = pOctets[i];
		}
	}
}

//***************************************************************************
//
// CADSIClass :: GetDefaultObjectCategory
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR CADSIClass :: GetDefaultObjectCategory()
{
	return m_lpszDefaultObjectCategory;
}

//***************************************************************************
//
// CADSIClass :: SetDefaultObjectCategory
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetDefaultObjectCategory(LPCWSTR lpszDefaultObjectCategory)
{
	if ( m_lpszDefaultObjectCategory )
	{
		delete[] m_lpszDefaultObjectCategory;
		m_lpszDefaultObjectCategory = NULL;
	}

	if (lpszDefaultObjectCategory)
	{
		m_lpszDefaultObjectCategory = new WCHAR[wcslen(lpszDefaultObjectCategory) + 1];
		wcscpy(m_lpszDefaultObjectCategory, lpszDefaultObjectCategory);
	}
}

//***************************************************************************
//
// CADSIClass :: GetSystemOnly
// 
// Purpose : See Header
//***************************************************************************
BOOLEAN CADSIClass :: GetSystemOnly()
{
	return m_bSystemOnly;
}

//***************************************************************************
//
// CADSIClass :: SetSystemOnly
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetSystemOnly(BOOLEAN bSystemOnly)
{
	m_bSystemOnly = bSystemOnly;
}

//***************************************************************************
//
// CADSIClass :: GetAuxiliaryClasses
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR *CADSIClass :: GetAuxiliaryClasses(DWORD *pdwCount)
{
	*pdwCount = m_dwAuxiliaryClassesCount;
	return (LPCWSTR *)m_lppszAuxiliaryClasses;
}

//***************************************************************************
//
// CADSIClass :: SetAuxiliaryClasses
// 
// Purpose : See Header

//***************************************************************************
void CADSIClass :: SetAuxiliaryClasses(PADSVALUE pValues, DWORD dwNumValues)
{
	DWORD i = 0;

	// Delete the list of possible superiors
	if ( m_lppszAuxiliaryClasses )
	{
		for ( i = 0; i<m_dwAuxiliaryClassesCount; i++ )
		{
			if ( m_lppszAuxiliaryClasses [ i ] )
			{
				delete [] m_lppszAuxiliaryClasses [ i ];
				m_lppszAuxiliaryClasses [ i ] = NULL;
			}
		}

		delete [] m_lppszAuxiliaryClasses;
		m_lppszAuxiliaryClasses = NULL;
		m_dwAuxiliaryClassesCount = 0;
	}

	// Set the new list of values
	m_dwAuxiliaryClassesCount = dwNumValues;
	m_lppszAuxiliaryClasses = new LPWSTR[m_dwAuxiliaryClassesCount];
	for(i=0; i<m_dwAuxiliaryClassesCount; i++)
	{
		try
		{
			m_lppszAuxiliaryClasses[i] = new WCHAR[wcslen(pValues->CaseIgnoreString) + 1];
			wcscpy(m_lppszAuxiliaryClasses[i], pValues->CaseIgnoreString);
		}
		catch ( ... )
		{
			if ( m_lppszAuxiliaryClasses )
			{
				m_dwAuxiliaryClassesCount = 0;

				for ( DWORD dw = 0; dw < i; dw++ )
				{
					if ( m_lppszAuxiliaryClasses [ dw ] )
					{
						delete [] m_lppszAuxiliaryClasses [ dw ];
						m_lppszAuxiliaryClasses [ dw ] = NULL;
					}
				}

				delete [] m_lppszAuxiliaryClasses;
				m_lppszAuxiliaryClasses = NULL;
			}

			throw;
		}

		pValues ++;
	}
}

//***************************************************************************
//
// CADSIClass :: GetSystemAuxiliaryClasses
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR *CADSIClass :: GetSystemAuxiliaryClasses(DWORD *pdwCount)
{
	*pdwCount = m_dwSystemAuxiliaryClassesCount;
	return (LPCWSTR *)m_lppszSystemAuxiliaryClasses;
}

//***************************************************************************
//
// CADSIClass :: SetSystemAuxiliaryClasses
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetSystemAuxiliaryClasses(PADSVALUE pValues, DWORD dwNumValues)
{
	DWORD i = 0;

	// Delete the list of possible superiors
	if ( m_lppszSystemAuxiliaryClasses )
	{
		for ( i = 0; i<m_dwSystemAuxiliaryClassesCount; i++ )
		{
			if ( m_lppszSystemAuxiliaryClasses [ i ] )
			{
				delete [] m_lppszSystemAuxiliaryClasses [ i ];
				m_lppszSystemAuxiliaryClasses [ i ] = NULL;
			}
		}

		delete [] m_lppszSystemAuxiliaryClasses;
		m_lppszSystemAuxiliaryClasses = NULL;
		m_dwSystemAuxiliaryClassesCount = 0;
	}
	
	// Set the new list of values
	m_dwSystemAuxiliaryClassesCount = dwNumValues;
	m_lppszSystemAuxiliaryClasses = new LPWSTR[m_dwSystemAuxiliaryClassesCount];
	for(i=0; i<m_dwSystemAuxiliaryClassesCount; i++)
	{
		try
		{
			m_lppszSystemAuxiliaryClasses[i] = new WCHAR[wcslen(pValues->CaseIgnoreString) + 1];
			wcscpy(m_lppszSystemAuxiliaryClasses[i], pValues->CaseIgnoreString);
		}
		catch ( ... )
		{
			if ( m_lppszSystemAuxiliaryClasses )
			{
				m_dwSystemAuxiliaryClassesCount = 0;

				for ( DWORD dw = 0; dw < i; dw++ )
				{
					if ( m_lppszSystemAuxiliaryClasses [ dw ] )
					{
						delete [] m_lppszSystemAuxiliaryClasses [ dw ];
						m_lppszSystemAuxiliaryClasses [ dw ] = NULL;
					}
				}

				delete [] m_lppszSystemAuxiliaryClasses;
				m_lppszSystemAuxiliaryClasses = NULL;
			}

			throw;
		}

		pValues ++;
	}
}

//***************************************************************************
//
// CADSIClass :: GetPossibleSuperiors
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR *CADSIClass :: GetPossibleSuperiors(DWORD *pdwCount)
{
	*pdwCount = m_dwPossibleSuperiorsCount;
	return (LPCWSTR *)m_lppszPossibleSuperiors;
}

//***************************************************************************
//
// CADSIClass :: SetPossibleSuperiors
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetPossibleSuperiors(PADSVALUE pValues, DWORD dwNumValues)
{
	DWORD i = 0;

	// Delete the list of possible superiors
	if ( m_lppszPossibleSuperiors )
	{
		for ( i = 0; i<m_dwPossibleSuperiorsCount; i++ )
		{
			if ( m_lppszPossibleSuperiors [ i ] )
			{
				delete [] m_lppszPossibleSuperiors [ i ];
				m_lppszPossibleSuperiors [ i ] = NULL;
			}
		}

		delete [] m_lppszPossibleSuperiors;
		m_lppszPossibleSuperiors = NULL;
		m_dwPossibleSuperiorsCount = 0;
	}

	// Set the new list of values
	m_dwPossibleSuperiorsCount = dwNumValues;
	m_lppszPossibleSuperiors = new LPWSTR[m_dwPossibleSuperiorsCount];
	for(i=0; i<m_dwPossibleSuperiorsCount; i++)
	{
		try
		{
			m_lppszPossibleSuperiors[i] = new WCHAR[wcslen(pValues->CaseIgnoreString) + 1];
			wcscpy(m_lppszPossibleSuperiors[i], pValues->CaseIgnoreString);
		}
		catch ( ... )
		{
			if ( m_lppszPossibleSuperiors )
			{
				m_dwPossibleSuperiorsCount = 0;

				for ( DWORD dw = 0; dw < i; dw++ )
				{
					if ( m_lppszPossibleSuperiors [ dw ] )
					{
						delete [] m_lppszPossibleSuperiors [ dw ];
						m_lppszPossibleSuperiors [ dw ] = NULL;
					}
				}

				delete [] m_lppszPossibleSuperiors;
				m_lppszPossibleSuperiors = NULL;
			}

			throw;
		}

		pValues ++;
	}
}

//***************************************************************************
//
// CADSIClass :: GetSystemPossibleSuperiors
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR *CADSIClass :: GetSystemPossibleSuperiors(DWORD *pdwCount)
{
	*pdwCount = m_dwSystemPossibleSuperiorsCount;
	return (LPCWSTR *)m_lppszSystemPossibleSuperiors;
}

//***************************************************************************
//
// CADSIClass :: SetSystemPossibleSuperiors
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetSystemPossibleSuperiors(PADSVALUE pValues, DWORD dwNumValues)
{
	DWORD i = 0;

	// Delete the list of possible superiors
	if ( m_lppszSystemPossibleSuperiors )
	{
		for ( i = 0; i<m_dwSystemPossibleSuperiorsCount; i++ )
		{
			if ( m_lppszSystemPossibleSuperiors [ i ] )
			{
				delete [] m_lppszSystemPossibleSuperiors [ i ];
				m_lppszSystemPossibleSuperiors [ i ] = NULL;
			}
		}

		delete [] m_lppszSystemPossibleSuperiors;
		m_lppszSystemPossibleSuperiors = NULL;
		m_dwSystemPossibleSuperiorsCount = 0;
	}

	// Set the new list of values
	m_dwSystemPossibleSuperiorsCount = dwNumValues;
	m_lppszSystemPossibleSuperiors = new LPWSTR[m_dwSystemPossibleSuperiorsCount];
	for(i=0; i<m_dwSystemPossibleSuperiorsCount; i++)
	{
		try
		{
			m_lppszSystemPossibleSuperiors[i] = new WCHAR[wcslen(pValues->CaseIgnoreString) + 1];
			wcscpy(m_lppszSystemPossibleSuperiors[i], pValues->CaseIgnoreString);
		}
		catch ( ... )
		{
			if ( m_lppszSystemPossibleSuperiors )
			{
				m_dwSystemPossibleSuperiorsCount = 0;

				for ( DWORD dw = 0; dw < i; dw++ )
				{
					if ( m_lppszSystemPossibleSuperiors [ dw ] )
					{
						delete [] m_lppszSystemPossibleSuperiors [ dw ];
						m_lppszSystemPossibleSuperiors [ dw ] = NULL;
					}
				}

				delete [] m_lppszSystemPossibleSuperiors;
				m_lppszSystemPossibleSuperiors = NULL;
			}

			throw;
		}

		pValues ++;
	}
}


//***************************************************************************
//
// CADSIClass :: GetMayContains
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR *CADSIClass :: GetMayContains(DWORD *pdwCount)
{
	*pdwCount = m_dwMayContainsCount;
	return (LPCWSTR *)m_lppszMayContains;
}

//***************************************************************************
//
// CADSIClass :: SetMayContains
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetMayContains(PADSVALUE pValues, DWORD dwNumValues)
{
	DWORD i = 0;

	// Delete the list of possible superiors
	if ( m_lppszMayContains )
	{
		for ( i = 0; i<m_dwMayContainsCount; i++ )
		{
			if ( m_lppszMayContains [ i ] )
			{
				delete [] m_lppszMayContains [ i ];
				m_lppszMayContains [ i ] = NULL;
			}
		}

		delete [] m_lppszMayContains;
		m_lppszMayContains = NULL;
		m_dwMayContainsCount = 0;
	}

	// Set the new list of values
	m_dwMayContainsCount = dwNumValues;
	m_lppszMayContains = new LPWSTR[m_dwMayContainsCount];
	for(i=0; i<m_dwMayContainsCount; i++)
	{
		try
		{
			m_lppszMayContains[i] = new WCHAR[wcslen(pValues->CaseIgnoreString) + 1];
			wcscpy(m_lppszMayContains[i], pValues->CaseIgnoreString);
		}
		catch ( ... )
		{
			if ( m_lppszMayContains )
			{
				m_dwMayContainsCount = 0;

				for ( DWORD dw = 0; dw < i; dw++ )
				{
					if ( m_lppszMayContains [ dw ] )
					{
						delete [] m_lppszMayContains [ dw ];
						m_lppszMayContains [ dw ] = NULL;
					}
				}

				delete [] m_lppszMayContains;
				m_lppszMayContains = NULL;
			}

			throw;
		}

		pValues ++;
	}
}

//***************************************************************************
//
// CADSIClass :: GetSystemMayContains
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR *CADSIClass :: GetSystemMayContains(DWORD *pdwCount)
{
	*pdwCount = m_dwSystemMayContainsCount;
	return (LPCWSTR *)m_lppszSystemMayContains;
}

//***************************************************************************
//
// CADSIClass :: SetSystemMayContains
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetSystemMayContains(PADSVALUE pValues, DWORD dwNumValues)
{
	DWORD i = 0;

	// Delete the list of possible superiors
	if ( m_lppszSystemMayContains )
	{
		for ( i = 0; i<m_dwSystemMayContainsCount; i++ )
		{
			if ( m_lppszSystemMayContains [ i ] )
			{
				delete [] m_lppszSystemMayContains [ i ];
				m_lppszSystemMayContains [ i ] = NULL;
			}
		}

		delete [] m_lppszSystemMayContains;
		m_lppszSystemMayContains = NULL;
		m_dwSystemMayContainsCount = 0;
	}

	// Set the new list of values
	m_dwSystemMayContainsCount = dwNumValues;
	m_lppszSystemMayContains = new LPWSTR[m_dwSystemMayContainsCount];
	for(i=0; i<m_dwSystemMayContainsCount; i++)
	{
		try
		{
			m_lppszSystemMayContains[i] = new WCHAR[wcslen(pValues->CaseIgnoreString) + 1];
			wcscpy(m_lppszSystemMayContains[i], pValues->CaseIgnoreString);
		}
		catch ( ... )
		{
			if ( m_lppszSystemMayContains )
			{
				m_dwSystemMayContainsCount = 0;

				for ( DWORD dw = 0; dw < i; dw++ )
				{
					if ( m_lppszSystemMayContains [ dw ] )
					{
						delete [] m_lppszSystemMayContains [ dw ];
						m_lppszSystemMayContains [ dw ] = NULL;
					}
				}

				delete [] m_lppszSystemMayContains;
				m_lppszSystemMayContains = NULL;
			}

			throw;
		}

		pValues ++;
	}
}

//***************************************************************************
//
// CADSIClass :: GetMustContains
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR *CADSIClass :: GetMustContains(DWORD *pdwCount)
{
	*pdwCount = m_dwMustContainsCount;
	return (LPCWSTR *)m_lppszMustContains;
}

//***************************************************************************
//
// CADSIClass :: SetMustContains
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetMustContains(PADSVALUE pValues, DWORD dwNumValues)
{
	DWORD i = 0;

	// Delete the list of possible superiors
	if ( m_lppszMustContains )
	{
		for ( i = 0; i<m_dwMustContainsCount; i++ )
		{
			if ( m_lppszMustContains [ i ] )
			{
				delete [] m_lppszMustContains [ i ];
				m_lppszMustContains [ i ] = NULL;
			}
		}

		delete [] m_lppszMustContains;
		m_lppszMustContains = NULL;
		m_dwMustContainsCount = 0;
	}

	// Set the new list of values
	m_dwMustContainsCount = dwNumValues;
	m_lppszMustContains = new LPWSTR[m_dwMustContainsCount];
	for(i=0; i<m_dwMustContainsCount; i++)
	{
		try
		{
			m_lppszMustContains[i] = new WCHAR[wcslen(pValues->CaseIgnoreString) + 1];
			wcscpy(m_lppszMustContains[i], pValues->CaseIgnoreString);
		}
		catch ( ... )
		{
			if ( m_lppszMustContains )
			{
				m_dwMustContainsCount = 0;

				for ( DWORD dw = 0; dw < i; dw++ )
				{
					if ( m_lppszMustContains [ dw ] )
					{
						delete [] m_lppszMustContains [ dw ];
						m_lppszMustContains [ dw ] = NULL;
					}
				}

				delete [] m_lppszMustContains;
				m_lppszMustContains = NULL;
			}

			throw;
		}

		pValues ++;
	}
}

//***************************************************************************
//
// CADSIClass :: GetSystemMustContains
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR *CADSIClass :: GetSystemMustContains(DWORD *pdwCount)
{
	*pdwCount = m_dwSystemMustContainsCount;
	return (LPCWSTR *)m_lppszSystemMustContains;
}

//***************************************************************************
//
// CADSIClass :: SetSystemMustContains
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetSystemMustContains(PADSVALUE pValues, DWORD dwNumValues)
{
	DWORD i = 0;

	// Delete the list of possible superiors
	if ( m_lppszSystemMustContains )
	{
		for ( i = 0; i<m_dwSystemMustContainsCount; i++ )
		{
			if ( m_lppszSystemMustContains [ i ] )
			{
				delete [] m_lppszSystemMustContains [ i ];
				m_lppszSystemMustContains [ i ] = NULL;
			}
		}

		delete [] m_lppszSystemMustContains;
		m_lppszSystemMustContains = NULL;
		m_dwSystemMustContainsCount = 0;
	}

	// Set the new list of values
	m_dwSystemMustContainsCount = dwNumValues;
	m_lppszSystemMustContains = new LPWSTR[m_dwSystemMustContainsCount];
	for(i=0; i<m_dwSystemMustContainsCount; i++)
	{
		try
		{
			m_lppszSystemMustContains[i] = new WCHAR[wcslen(pValues->CaseIgnoreString) + 1];
			wcscpy(m_lppszSystemMustContains[i], pValues->CaseIgnoreString);
		}
		catch ( ... )
		{
			if ( m_lppszSystemMustContains )
			{
				m_dwSystemMustContainsCount = 0;

				for ( DWORD dw = 0; dw < i; dw++ )
				{
					if ( m_lppszSystemMustContains [ dw ] )
					{
						delete [] m_lppszSystemMustContains [ dw ];
						m_lppszSystemMustContains [ dw ] = NULL;
					}
				}

				delete [] m_lppszSystemMustContains;
				m_lppszSystemMustContains = NULL;
			}

			throw;
		}

		pValues ++;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\adsiinst.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:adsiinst.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the CADSIInstance which encapsulates an ADSI instance
//
//***************************************************************************

#ifndef ADSI_INSTANCE_H
#define ADSI_INSTANCE_H


class CADSIInstance : public CRefCountedObject
{

public:
	//***************************************************************************
	//
	// CADSIInstance::CADSIInstance
	//
	// Purpose : Constructor 
	//
	// Parameters:
	//  lpszADSIPath : The ADSI Path to the object
	//***************************************************************************
	CADSIInstance(LPCWSTR lpszADSIPath, IDirectoryObject *pObject);
	virtual ~CADSIInstance();

	//***************************************************************************
	//
	// CADSIInstance::GetDirectoryObject
	//
	// Purpose : Returns the IDirectoryObject interface on the Directory object 
	// It is the responsibility of the caller to Release() it when done.
	//
	//***************************************************************************
	IDirectoryObject *GetDirectoryObject();

	//***************************************************************************
	//
	// CADSIInstance :: GetADSIClassName
	// 
	// Purpose : Returns the class name of this instance
	//***************************************************************************
	LPCWSTR GetADSIClassName();

	PADS_ATTR_INFO GetAttributes(DWORD *pdwNumAttributes);
	void SetAttributes(PADS_ATTR_INFO pAttributes, DWORD dwNumAttributes);

	PADS_OBJECT_INFO GetObjectInfo();
	void SetObjectInfo(PADS_OBJECT_INFO pObjectInfo);

protected:
	// The Attribute list
	PADS_ATTR_INFO m_pAttributes;
	DWORD m_dwNumAttributes;

	// The object info
	PADS_OBJECT_INFO m_pObjectInfo;

	// The IDirectoryObject pointer
	IDirectoryObject *m_pDirectoryObject;
};

#endif /* ADSI_INSTANCE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\adsiinst.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:adsiinst.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the implementation of the CADSIInstance which encapsulates an ADSI instance
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
// CADSIInstance::CADSIInstance
//
// Purpose : Constructor 
//
// Parameters:
	//  lpszADSIPath : The ADSI Path to the object
//***************************************************************************
CADSIInstance :: CADSIInstance(LPCWSTR lpszADSIPath, IDirectoryObject *pDirectoryObject)
	: CRefCountedObject(lpszADSIPath)
{
	m_pAttributes = NULL;
	m_dwNumAttributes = 0;
	m_pObjectInfo = NULL;

	m_pDirectoryObject = pDirectoryObject;
	m_pDirectoryObject->AddRef();
}


//***************************************************************************
//
// CADSIInstance :: ~CADSIInstance
// 
// Purpose : Destructor
//***************************************************************************
CADSIInstance :: ~CADSIInstance()
{
	// Free the attributes
	if(m_pAttributes)
		FreeADsMem((LPVOID *) m_pAttributes);

	if(m_pObjectInfo)
		FreeADsMem((LPVOID *) m_pObjectInfo);

	if(m_pDirectoryObject)
		m_pDirectoryObject->Release();
}

IDirectoryObject *CADSIInstance :: GetDirectoryObject()
{
	m_pDirectoryObject->AddRef();
	return m_pDirectoryObject;
}

//***************************************************************************
//
// CADSIInstance :: GetAttributes
// 
// Purpose : See header for details
//***************************************************************************
PADS_ATTR_INFO CADSIInstance :: GetAttributes(DWORD *pdwNumAttributes)
{
	*pdwNumAttributes = m_dwNumAttributes;
	return m_pAttributes;
}

//***************************************************************************
//
// CADSIInstance :: SetAttributes
// 
// Purpose : See header for details
//***************************************************************************
void  CADSIInstance :: SetAttributes(PADS_ATTR_INFO pAttributes, DWORD dwNumAttributes)
{
	// Go thru the attributes and release them
	if(m_pAttributes)
		FreeADsMem((LPVOID *) m_pAttributes);
	m_pAttributes = pAttributes;
	m_dwNumAttributes = dwNumAttributes;
}

//***************************************************************************
//
// CADSIInstance :: GetObjectInfo
// 
// Purpose : See header for details
//***************************************************************************
PADS_OBJECT_INFO CADSIInstance :: GetObjectInfo()
{
	return m_pObjectInfo;
}

//***************************************************************************
//
// CADSIInstance :: SetObjectInfo
// 
// Purpose : See header for details
//***************************************************************************
void  CADSIInstance :: SetObjectInfo(PADS_OBJECT_INFO pObjectInfo)
{
	// Go thru the attributes and release them
	if(m_pObjectInfo)
		FreeADsMem((LPVOID *) m_pObjectInfo);
	m_pObjectInfo = pObjectInfo;
}

//***************************************************************************
//
// CADSIInstance :: GetADSIClassName
// 
// Purpose : See header for details
//***************************************************************************
LPCWSTR CADSIInstance :: GetADSIClassName()
{
	if(m_pObjectInfo)
		return m_pObjectInfo->pszClassName;
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\adsiprop.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:adsiprop.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the CADSIProperty which encapsulates an ADSI property. The syntax of an ADSI Property
// is based on the values of the following 3 attributes:
// Attribute Syntax : This is an OID
// OMSyntax: This is an integer
// OMObjectClass : This is an octet string
// For all the syntaxes in the AD, the value om Attribute Syntax is enough for our purposes of
// mapping to a CIM Syntax since values of instances of these properties come mapped to the same
// ADS_TYPE if the value of their OMSyntax is same. Except for the syntaxes Object(OR-Name) and DN_With_Binary
// which have the same value for OMSyntax and Attribute Syntax, but are differentiated based on the value
// of the OMObjectClass. Hence instead of storing the value of OMObjectClass (which is an LPBYTE value) for
// every attribute, we just store one BOOLEAN value isORName which tells us whether the syntax is OR-Name or DN_With_Binary.
// Call it a hack, optimization whatever.
//
//***************************************************************************

#ifndef ADSI_PROPERTY_H
#define ADSI_PROPERTY_H


class CADSIProperty : public CRefCountedObject
{

public:

	//***************************************************************************
	//
	// CADSIProperty::CADSIProperty
	//
	// Purpose : Constructor 
	//
	// Parameters:
	//	
	//	None
	//***************************************************************************
	CADSIProperty();

	//***************************************************************************
	//
	// CADSIProperty::CADSIProperty
	//
	// Purpose : Constructor 
	//
	// Parameters:
	//  lpszWBEMPropertyName : The WBEM name of the property being created. A copy of this is made
	//  lpszADSIPropertyName : The ADSI name of the property being created. A copy of this is made
	//***************************************************************************
	CADSIProperty(LPCWSTR lpszWBEMPropertyName, LPCWSTR lpszADSIPropertyName);

	//***************************************************************************
	//
	// CADSIProperty :: ~CADSIProperty
	// 
	// Purpose : Destructor
	//***************************************************************************
	virtual ~CADSIProperty();

	//***************************************************************************
	//
	// CADSIProperty :: GetWBEMPropertyName
	// 
	// Purpose : Returns the WBEM  property name of this property
	//***************************************************************************
	LPCWSTR GetWBEMPropertyName();

	//***************************************************************************
	//
	// CADSIProperty :: SetWBEMPropertyName
	// 
	// Purpose : Sets the WBEM name of this property
	//***************************************************************************
	void SetWBEMPropertyName(LPCWSTR lpszWBEMName);

	//***************************************************************************
	//
	// CADSIProperty :: GetADSIPropertyName
	// 
	// Purpose : Returns the ADSI  property name of this property
	//***************************************************************************
	LPCWSTR GetADSIPropertyName();

	//***************************************************************************
	//
	// CADSIProperty :: SetADSIPropertyName
	// 
	// Purpose : Sets the ADSI name of this property
	//***************************************************************************
	void SetADSIPropertyName(LPCWSTR lpszADSIName);

	//***************************************************************************
	//
	// CADSIProperty :: GetSyntaxOID
	// 
	// Purpose : Returns the ADSI Syntax OID of this property
	//***************************************************************************
	LPCWSTR GetSyntaxOID();

	//***************************************************************************
	//
	// CADSIProperty :: SetSyntaxOID
	// 
	// Purpose : Sets the ADSI Syntax OID of this property
	//***************************************************************************
	void SetSyntaxOID(LPCWSTR lpszSystaxOID);

	//***************************************************************************
	//
	// CADSIProperty :: IsORName
	// 
	// Purpose : Returns whether the property has a syntax of Object(OR-Name).
	//***************************************************************************
	BOOLEAN IsORName();

	//***************************************************************************
	//
	// CADSIProperty :: SetORName
	// 
	// Purpose : Sets the m_bORName property of this property
	//***************************************************************************
	void SetORName(BOOLEAN bORName);


	//***************************************************************************
	//
	// CADSIProperty :: IsMultiValued
	// 
	// Purpose : Returns whether the property is multi valued
	//***************************************************************************
	BOOLEAN IsMultiValued();

	//***************************************************************************
	//
	// CADSIProperty :: SetMultiValued
	// 
	// Purpose : Sets the multi-valued property of this property
	//***************************************************************************
	void SetMultiValued(BOOLEAN bMultiValued);

	//***************************************************************************
	//
	// CADSIProperty :: IsSystemOnly
	// 
	// Purpose : Returns whether the property is SystemOnly
	//***************************************************************************
	BOOLEAN IsSystemOnly();

	//***************************************************************************
	//
	// CADSIProperty :: SetSystemOnly
	// 
	// Purpose : Sets the SystemOnly property of this property
	//***************************************************************************
	void SetSystemOnly(BOOLEAN bSystemOnly);

	//***************************************************************************
	//
	// CADSIProperty :: GetSearchFlags
	// 
	// Purpose : Returns the SearchFlags property of the property
	//***************************************************************************
	DWORD GetSearchFlags();

	//***************************************************************************
	//
	// CADSIProperty :: SetSearchFlags
	// 
	// Purpose : Sets the SearchFlags property of this property
	//***************************************************************************
	void SetSearchFlags(DWORD dwSearchFlags);

	//***************************************************************************
	//
	// CADSIProperty :: GetOMSyntax
	// 
	// Purpose : Returns the OMSyntax property of the property
	//***************************************************************************
	DWORD GetOMSyntax();

	//***************************************************************************
	//
	// CADSIProperty :: SetOMSyntax
	// 
	// Purpose : Sets the OMSyntax property of this property
	//***************************************************************************
	void SetOMSyntax(DWORD dwOMSyntax);

	//***************************************************************************
	//
	// CADSIProperty :: GetMAPI_ID
	// 
	// Purpose : Returns the MAPI_ID property of the property
	//***************************************************************************
	DWORD GetMAPI_ID();

	//***************************************************************************
	//
	// CADSIProperty :: SetMAPI_ID
	// 
	// Purpose : Sets the MAPI_ID property of this property
	//***************************************************************************
	void SetMAPI_ID(DWORD dwMAPI_ID);


	//***************************************************************************
	//
	// CADSIProperty :: GetAttributeID
	// 
	// Purpose : Returns the Attribute ID of this property
	//***************************************************************************
	LPCWSTR GetAttributeID();

	//***************************************************************************
	//
	// CADSIProperty :: SetAttributeID
	// 
	// Purpose : Sets the Attribute ID of this property
	//***************************************************************************
	void SetAttributeID(LPCWSTR lpszAttributeID);

	//***************************************************************************
	//
	// CADSIProperty :: GetCommonName
	// 
	// Purpose : Returns the Common Name of this property
	//***************************************************************************
	LPCWSTR GetCommonName();

	//***************************************************************************
	//
	// CADSIProperty :: SetCommonName
	// 
	// Purpose : Sets the CommonName of this property
	//***************************************************************************
	void SetCommonName(LPCWSTR lpszCommonName);

	//***************************************************************************
	//
	// CADSIProperty :: GetDirectoryObject
	// 
	// Purpose : Returns the ADSI object pertaining to this property
	//	It is the user's duty to release it when done
	// 
	// Parameters:
	//	None
	//
	// Return Value:
	//	The ADSI object interface pertaining to this property	
	//***************************************************************************
	IDirectoryObject *GetDirectoryObject();

	//***************************************************************************
	//
	// CADSIProperty :: SetDirectoryObject
	// 
	// Purpose : Sets the ADSI object pertaining to this property
	//
	// Parameter : The directory object pertaining to this property
	//***************************************************************************
	void SetDirectoryObject(IDirectoryObject *pDirectoryObject);


protected:
	// The WBEM name of this property
	LPWSTR m_lpszWBEMPropertyName;

	// The ADSI interface for the object representing this property
	IDirectoryObject * m_pDirectoryObject;

	// The Syntax OID
	LPWSTR m_lpszSyntaxOID;

	// Used to differentiate between the syntaxes Object(OR-Name) and DN_with_Binary
	// See the beginning of this file for a detailed explanation of this.
	BOOLEAN m_bORName;

	// Whether it is multi valued
	BOOLEAN m_bMultiValued;

	// The Attribute ID
	LPWSTR m_lpszAttributeID;

	// The Common Name
	LPWSTR m_lpszCommonName;

	// Whether this property is SystemOnly
	BOOLEAN m_bSystemOnly;

	// Search Flags
	DWORD m_dwSearchFlags;

	// MAPI ID
	DWORD m_dwMAPI_ID;

	// OM Syntax
	DWORD m_dwOMSyntax;
};

#endif /* ADSI_PROPERTY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\attributes.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef ATTRIBUTES_H
#define ATTRIBUTES_H

// The Key used in the registry for logging
static LPCTSTR DSPROVIDER = __TEXT("DSProvider");

// Names of the LDAP class attributes
static LPCWSTR ADS_PATH_ATTR				= L"ADsPath";
static LPCWSTR LDAP_DISPLAY_NAME_ATTR		= L"ldapDisplayName";
static LPCWSTR COMMON_NAME_ATTR				= L"cn";
static LPCWSTR GOVERNS_ID_ATTR				= L"governsID";
static LPCWSTR SUB_CLASS_OF_ATTR			= L"subClassOf";
static LPCWSTR SCHEMA_ID_GUID_ATTR			= L"schemaIDGUID";
static LPCWSTR MAPI_DISPLAY_TYPE_ATTR		= L"mAPIDisplayType";
static LPCWSTR RDN_ATT_ID_ATTR				= L"rDNAttID";
static LPCWSTR SYSTEM_MUST_CONTAIN_ATTR		= L"systemMustContain";
static LPCWSTR MUST_CONTAIN_ATTR			= L"mustContain";
static LPCWSTR SYSTEM_MAY_CONTAIN_ATTR		= L"systemMayContain";
static LPCWSTR MAY_CONTAIN_ATTR				= L"mayContain";
static LPCWSTR SYSTEM_POSS_SUPERIORS_ATTR	= L"systemPossSuperiors";
static LPCWSTR POSS_SUPERIORS_ATTR			= L"possSuperiors";
static LPCWSTR SYSTEM_AUXILIARY_CLASS_ATTR	= L"systemAuxiliaryClass";
static LPCWSTR AUXILIARY_CLASS_ATTR			= L"auxiliaryClass";
static LPCWSTR DEFAULT_SECURITY_DESCRP_ATTR	= L"defaultSecurityDescriptor";
static LPCWSTR OBJECT_CLASS_CATEGORY_ATTR	= L"objectClassCategory";
static LPCWSTR SYSTEM_ONLY_ATTR				= L"systemOnly";
static LPCWSTR NT_SECURITY_DESCRIPTOR_ATTR	= L"nTSecurityDescriptor";
static LPCWSTR DEFAULT_OBJECTCATEGORY_ATTR	= L"defaultObjectCategory";

// Names of properties in WBEM/LDAP classes
static LPCWSTR ADSI_PATH_ATTR				= L"ADSIPath";
static LPCWSTR OBJECT_CLASS_PROPERTY		= L"ds_objectClass";

// Names of the LDAP property attributes
static LPCWSTR ATTRIBUTE_SYNTAX_ATTR		= L"attributeSyntax";
static LPCWSTR ATTRIBUTE_ID_ATTR			= L"attributeID";
static LPCWSTR IS_SINGLE_VALUED_ATTR		= L"isSingleValued";
static LPCWSTR MAPI_ID_ATTR					= L"mAPIID";
static LPCWSTR OM_SYNTAX_ATTR				= L"oMSyntax";
static LPCWSTR OM_OBJECT_CLASS_ATTR			= L"oMObjectClass";
static LPCWSTR SEARCH_FLAGS_ATTR			= L"searchFlags";
static LPCWSTR RANGE_LOWER_ATTR				= L"rangeLower";
static LPCWSTR RANGE_UPPER_ATTR				= L"rangeUpper";

// Names of the LDAP instance attributes
static LPCWSTR OBJECT_CLASS_ATTR				= L"objectClass";
static LPCWSTR DISTINGUISHED_NAME_ATTR			= L"distinguishedName";

// The OIDs for various LDAP syntaxes
// These values are used to map LDAP Syntax to CIM type
static LPCWSTR DISTINGUISHED_NAME_OID		= L"2.5.5.1";
static LPCWSTR OBJECT_IDENTIFIER_OID		= L"2.5.5.2";
static LPCWSTR CASE_SENSITIVE_STRING_OID	= L"2.5.5.3";
static LPCWSTR CASE_INSENSITIVE_STRING_OID	= L"2.5.5.4";
static LPCWSTR PRINT_CASE_STRING_OID		= L"2.5.5.5";
static LPCWSTR NUMERIC_STRING_OID			= L"2.5.5.6";
static LPCWSTR DN_WITH_BINARY_OID			= L"2.5.5.7";
static LPCWSTR BOOLEAN_OID					= L"2.5.5.8";
static LPCWSTR INTEGER_OID					= L"2.5.5.9";
static LPCWSTR OCTET_STRING_OID				= L"2.5.5.10";
static LPCWSTR TIME_OID						= L"2.5.5.11";
static LPCWSTR UNICODE_STRING_OID			= L"2.5.5.12";
static LPCWSTR PRESENTATION_ADDRESS_OID		= L"2.5.5.13";
static LPCWSTR DN_WITH_STRING_OID			= L"2.5.5.14";
static LPCWSTR NT_SECURITY_DESCRIPTOR_OID	= L"2.5.5.15";
static LPCWSTR LARGE_INTEGER_OID			= L"2.5.5.16";
static LPCWSTR SID_OID						= L"2.5.5.17";

// The name of the top classes
static LPCWSTR TOP_CLASS					= L"ds_top";
static LPCWSTR LDAP_BASE_CLASS				= L"DS_LDAP_Root_Class";

// Some WBEM class names 
static LPCWSTR UINT8ARRAY_CLASS				= L"Uint8Array";
static LPCWSTR DN_WITH_STRING_CLASS			= L"DN_With_String";
static LPCWSTR DN_WITH_BINARY_CLASS			= L"DN_With_Binary";
static LPCWSTR ROOTDSE_CLASS				= L"RootDSE";
static LPCWSTR INSTANCE_ASSOCIATION_CLASS	= L"DS_LDAP_Instance_Containment";
static LPCWSTR CLASS_ASSOCIATION_CLASS		= L"DS_LDAP_Class_Containment";
static LPCWSTR DN_CLASS						= L"DN_Class";
static LPCWSTR DN_ASSOCIATION_CLASS			= L"DSClass_To_DNInstance";

// Some othe literals common to the project
static LPCWSTR LDAP_PREFIX				= L"LDAP://";	
static LPCWSTR ROOT_DSE_PATH			= L"LDAP://RootDSE";
static LPCWSTR RIGHT_BRACKET_STR		= L")";
static LPCWSTR LEFT_BRACKET_STR			= L"(";
static LPCWSTR AMPERSAND_STR			= L"&";
static LPCWSTR PIPE_STR					= L"|";
static LPCWSTR SPACE_STR				= L" ";
static LPCWSTR COMMA_STR				= L",";
static LPCWSTR EQUALS_STR				= L"=";

// Prefixes for class names
static LPCWSTR LDAP_CLASS_NAME_PREFIX							= L"DS_";
static const DWORD LDAP_CLASS_NAME_PREFIX_LENGTH				= 3;
static LPCWSTR LDAP_ARTIFICIAL_CLASS_NAME_PREFIX				= L"ADS_";
static const DWORD LDAP_ARTIFICIAL_CLASS_NAME_PREFIX_LENGTH	= 4;

static LPCWSTR WBEMPERFORMANCEDATAMUTEX		=	L"WbemPerformanceDataMutex";

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\assocprov.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:assocprov.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the DS Class Provider class. This is
//	the base class for all DS Class Providers. Note that an instance of the CLDAPClassAsssociationsProviderInitializer
//	class has to be created to initialize the static members of the CLDAPClassAsssociationsProvider class. Hence exactly
//	one instance of the CLDAPClassAsssociationsProviderInitializer class should be created for this
//	class to function properly.
//
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef DS_CLASS_ASSOC_PROVIDER_H
#define DS_CLASS_ASSOC_PROVIDER_H


class CLDAPClassAsssociationsProvider : public IWbemProviderInit, public IWbemServices
{

public:

	// Create the object 
    CLDAPClassAsssociationsProvider () ;
    virtual ~CLDAPClassAsssociationsProvider () ;

	////////////////////////////////////////
	//IUnknown members
	////////////////////////////////////////
	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;


	////////////////////////////////////////
	//IWbemProviderInit members
	////////////////////////////////////////
	virtual HRESULT STDMETHODCALLTYPE Initialize( 
            LPWSTR wszUser,
            LONG lFlags,
            LPWSTR wszNamespace,
            LPWSTR wszLocale,
            IWbemServices __RPC_FAR *pNamespace,
            IWbemContext __RPC_FAR *pCtx,
            IWbemProviderInitSink __RPC_FAR *pInitSink) ;

		
	////////////////////////////////////////
	//IWbemServices members
	////////////////////////////////////////
    virtual HRESULT STDMETHODCALLTYPE OpenNamespace( 
        /* [in] */ const BSTR strNamespace,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult);
    
    virtual HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink);
    
    virtual HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE GetObject( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE GetObjectAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE PutClass( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE PutClassAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteClass( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE CreateClassEnum( 
        /* [in] */ const BSTR strSuperclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
        /* [in] */ const BSTR strSuperclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE PutInstance( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteInstance( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE ExecQuery( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE ExecMethod( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ const BSTR strMethodName,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ const BSTR strMethodName,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);




protected:
	// Checks whether a containment is valid
	HRESULT IsContainedIn(LPCWSTR lpszChildClass, LPCWSTR lpszParentClass);

	// A helper function to do the ADSI LDAP provider specific initialization.
	BOOLEAN InitializeAssociationsProvider(IWbemContext *pCtx);

	// The IWbemServices pointer stored from Initialize()
	IWbemServices *m_IWbemServices;

	// Creates an instance of the association class
	HRESULT CreateInstance(BSTR strChildName, BSTR strParentName, IWbemClassObject **ppInstance);

	// Does enumeration of instnaces of the association class
	HRESULT DoEnumeration(IWbemObjectSink *pResponseHandler);

private:

	// The Log File name
	static LPCWSTR s_LogFileName;

	// Indicates whether the call to Initialize() was successful
	BOOLEAN m_bInitializedSuccessfully;

	// The COM Reference count
    long m_lReferenceCount ;

	// The class for which instances are provider
	IWbemClassObject *m_pAssociationClass;

	// The path to the schema container
	LPWSTR m_lpszSchemaContainerSuffix;

	// The IDirectorySearch interface of the schema container
	IDirectorySearch *m_pDirectorySearchSchemaContainer;

	// Some literals
	static LPCWSTR CHILD_CLASS_PROPERTY;
	static LPCWSTR PARENT_CLASS_PROPERTY;
	static LPCWSTR POSSIBLE_SUPERIORS;
	BSTR CHILD_CLASS_PROPERTY_STR;
	BSTR PARENT_CLASS_PROPERTY_STR;
	BSTR CLASS_ASSOCIATION_CLASS_STR;
	BSTR POSSIBLE_SUPERIORS_STR;
	static LPCWSTR SCHEMA_NAMING_CONTEXT;
	static LPCWSTR LDAP_SCHEMA;
	static LPCWSTR LDAP_SCHEMA_SLASH;
};


#endif // DS_CLASS_ASSOC_PROVIDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\classpro.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:classpro.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains implementation of the DS Class Provider class. THis is the
// base class for all DS class providers
//
//***************************************************************************

#include "precomp.h"


// Initialize the static members
BSTR CDSClassProvider :: CLASS_STR			= NULL;
CWbemCache *CDSClassProvider :: s_pWbemCache = NULL;

//***************************************************************************
//
// CDSClassProvider::CDSClassProvider
// CDSClassProvider::~CDSClassProvider
//
// Constructor Parameters:
//		lpLogFileName : The name of the file used for logging. The log file
//		name will be used in creating the log file path. The log file path
//		will be <SystemDirectory>\logFileName. Hence the logFileName may be relative
//		path. For exaple if this argument is specified as wbem\logs\dsprov.txt, then
//		the actual log file would be c:\winnt\system32\wbem\logs\dsprov.txt on a system
//		where the system directory is c:\winnt\system32
//
//  
//***************************************************************************

CDSClassProvider :: CDSClassProvider ()
{
	InterlockedIncrement(&g_lComponents);

	m_lReferenceCount = 0 ;
	m_IWbemServices = NULL;
	m_bInitializedSuccessfully = FALSE;
}

CDSClassProvider::~CDSClassProvider ()
{
	g_pLogObject->WriteW( L"CDSClassProvider :: DESTRUCTOR\r\n");

	InterlockedDecrement(&g_lComponents);

	if(m_IWbemServices)
	{
		m_IWbemServices->Release();
		m_IWbemServices = NULL;
	}

}

//***************************************************************************
//
// CDSClassProvider::QueryInterface
// CDSClassProvider::AddRef
// CDSClassProvider::Release
//
// Purpose: Standard COM routines needed for all COM objects
//
//***************************************************************************
STDMETHODIMP CDSClassProvider :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) (IUnknown *)(IWbemProviderInit *)this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) (IWbemServices *)this ;		
	}	
	else if ( iid == IID_IWbemProviderInit )
	{
		*iplpv = ( LPVOID ) (IWbemProviderInit *)this ;		
	}	
	else
	{
		return E_NOINTERFACE;
	}

	( ( LPUNKNOWN ) *iplpv )->AddRef () ;
	return  S_OK;
}


STDMETHODIMP_( ULONG ) CDSClassProvider :: AddRef ()
{
	return InterlockedIncrement ( & m_lReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CDSClassProvider :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_lReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}


HRESULT CDSClassProvider :: Initialize( 
        LPWSTR wszUser,
        LONG lFlags,
        LPWSTR wszNamespace,
        LPWSTR wszLocale,
        IWbemServices __RPC_FAR *pNamespace,
        IWbemContext __RPC_FAR *pCtx,
        IWbemProviderInitSink __RPC_FAR *pInitSink)
{
	// Validate the arguments
	if( pNamespace == NULL || lFlags != 0 )
	{
		g_pLogObject->WriteW( L"CDSClassProvider :: Argument validation FAILED\r\n");
		pInitSink->SetStatus(WBEM_E_FAILED, 0);
		return WBEM_S_NO_ERROR;
	}

	// Store the IWbemServices pointer for future use
	m_IWbemServices = pNamespace;
	m_IWbemServices->AddRef();
		
	m_bInitializedSuccessfully = TRUE;
	pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
	return WBEM_S_NO_ERROR;
}

HRESULT CDSClassProvider :: OpenNamespace( 
    /* [in] */ const BSTR strNamespace,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: CancelAsyncCall( 
    /* [in] */ IWbemObjectSink __RPC_FAR *pSink)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: QueryObjectSink( 
    /* [in] */ long lFlags,
    /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: GetObject( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: GetObjectAsync( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	if(!m_bInitializedSuccessfully)
	{
		g_pLogObject->WriteW( L"CDSClassProvider :: Initialization status is FAILED, hence returning failure\r\n");
		return WBEM_E_FAILED;
	}

	// For exception handling
	//========================
	SetStructuredExceptionHandler seh;
	
	try 
	{
		if(!m_bInitializedSuccessfully)
		{
			g_pLogObject->WriteW( L"CDSClassProvider :: Initialization status is FAILED, hence returning failure\r\n");
			return WBEM_E_FAILED;
		}

		g_pLogObject->WriteW( L"CDSClassProvider :: GetObjectAsync() called for %s \r\n", strObjectPath);

		// Impersonate the client
		//=======================
		HRESULT result;
		if(!SUCCEEDED(result = WbemCoImpersonateClient()))
		{
			g_pLogObject->WriteW( L"CDSClassProvider :: GetObjectAsync() CoImpersonate FAILED for %s with %x\r\n", strObjectPath, result);
			return WBEM_E_FAILED;
		}

		// Validate the arguments
		//========================
		if(strObjectPath == NULL ) 
		{
			g_pLogObject->WriteW( L"CDSClassProvider :: GetObjectAsync() argument validation FAILED\r\n");
			return WBEM_E_INVALID_PARAMETER;
		}

		// Parse the object path
		//========================
		CObjectPathParser theParser;
		ParsedObjectPath *theParsedObjectPath = NULL;
		switch(theParser.Parse(strObjectPath, &theParsedObjectPath))
		{
			case CObjectPathParser::NoError:
				break;
			default:
				g_pLogObject->WriteW( L"CDSClassProvider :: GetObjectAsync() object path parsing FAILED\r\n");
				return WBEM_E_INVALID_PARAMETER;
		}

		try
		{
			// Check to see if it one of those classes that we know that dont provide
			//=======================================================================
			if(IsUnProvidedClass(theParsedObjectPath->m_pClass))
			{
				pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE , WBEM_E_NOT_FOUND, NULL, NULL);
			}
			else
			{
				IWbemClassObject *pReturnObject = NULL;
				if(SUCCEEDED(result = GetClassFromCacheOrADSI(theParsedObjectPath->m_pClass, &pReturnObject, pCtx)))
				{
					result = pResponseHandler->Indicate(1, &pReturnObject);
					pReturnObject->Release();
					pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE , WBEM_S_NO_ERROR, NULL, NULL);
				}
				else
				{
					g_pLogObject->WriteW( L"CDSClassProvider :: GetObjectAsync() GetClassFromCacheOrADSI FAILED for %s with %x\r\n", strObjectPath, result);
					pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE , WBEM_E_NOT_FOUND, NULL, NULL);
				}
			}
		}
		catch ( ... )
		{
			theParser.Free(theParsedObjectPath);
			throw;
		}

		// Delete the parser allocated structures
		//=======================================
		theParser.Free(theParsedObjectPath);

	}
	catch(Heap_Exception e_HE)
	{
		pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE , WBEM_E_OUT_OF_MEMORY, NULL, NULL);
	}

	return WBEM_S_NO_ERROR;

}

HRESULT CDSClassProvider :: PutClass( 
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: PutClassAsync( 
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: DeleteClass( 
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: DeleteClassAsync( 
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: CreateClassEnum( 
    /* [in] */ const BSTR strSuperclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: CreateClassEnumAsync( 
    /* [in] */ const BSTR strSuperclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: PutInstance( 
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: PutInstanceAsync( 
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: DeleteInstance( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: DeleteInstanceAsync( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: CreateInstanceEnum( 
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: CreateInstanceEnumAsync( 
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: ExecQuery( 
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: ExecQueryAsync( 
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: ExecNotificationQuery( 
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: ExecNotificationQueryAsync( 
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: ExecMethod( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: ExecMethodAsync( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}



HRESULT CDSClassProvider :: GetClassFromCacheOrADSI(LPCWSTR pszWBEMClassName, 
	IWbemClassObject **ppWbemClassObject,
	IWbemContext *pCtx)
{
	HRESULT result = E_FAIL;
	// The algorithm is as follows:
	// Check whether the classname is present in the list of classes to which this user is granted access
	// If so
	//		See if is present in the WBEM Cache.
	//		If so return it.
	//		If not, get it from ADSI. 
	//			If successful Map it to WBEM class and add the WBEM class to the WBEM cache and return
	//			If not, if the return value is ACCESS_DENIED, remove it from the user's list
	// If not
	//		Get it from ADSI.
	//		if successful
	//			if it is not present in the cache map it to WBEM and add the WBEM class to the cache
	//			else discard it and return the WBEM class in the cache to the user
	//		else
	//			return error
	if(m_AccessAllowedClasses.IsNamePresent(pszWBEMClassName))
	{
		g_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() Found class in Authenticated list for %s\r\n", pszWBEMClassName);

		// Check the WBEM Cache to see if it there
		//=========================================
		CWbemClass *pWbemClass = NULL;

		try
		{
			if(SUCCEEDED(result = s_pWbemCache->GetClass(pszWBEMClassName, &pWbemClass)))
			{
				g_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() Found class in cache for %s\r\n", pszWBEMClassName);

				// Get the IWbemClassObject of the cache object
				IWbemClassObject *pCacheObject = pWbemClass->GetWbemClass();

				pWbemClass->Release();
				pWbemClass = NULL;

				// Clone it
				if(!SUCCEEDED(result = pCacheObject->Clone(ppWbemClassObject)))
					g_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() Clone() FAILED : %x for %s\r\n", result, pszWBEMClassName);

				pCacheObject->Release();
			}
			else // Could not be found in cache. Go to ADSI
				//=========================================
			{
				g_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() Could not find class in cache for %s. Going to ADSI\r\n", pszWBEMClassName);

				IWbemClassObject *pNewObject = NULL;
				if(SUCCEEDED(result = GetClassFromADSI(pszWBEMClassName, pCtx, &pNewObject)))
				{
					try
					{
						// Add it to the cache
						pWbemClass = NULL;
						if(pWbemClass = new CWbemClass(pszWBEMClassName, pNewObject))
						{
							s_pWbemCache->AddClass(pWbemClass);

							pWbemClass->Release();
							pWbemClass = NULL;

							g_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() Added %s to cache\r\n", pszWBEMClassName);
							
							// Clone it
							if(!SUCCEEDED(result = pNewObject->Clone(ppWbemClassObject)))
								g_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() Clone() FAILED : %x for %s\r\n", result, pszWBEMClassName);

							pNewObject->Release();
							pNewObject = NULL;
						}
						else
							result = E_OUTOFMEMORY;
					}
					catch ( ... )
					{
						if ( pNewObject )
						{
							pNewObject->Release ();
							pNewObject = NULL;
						}

						throw;
					}
				}
				else 
				{
					m_AccessAllowedClasses.RemoveName(pszWBEMClassName);
					g_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() GetClassFromADSI() FAILED : %x. Removing %s from user list\r\n", result, pszWBEMClassName);
				}
			}
		}
		catch ( ... )
		{
			if ( pWbemClass )
			{
				pWbemClass->Release ();
				pWbemClass = NULL;
			}

			throw;
		}
	}
	else // Get it from ADSI
		//=========================================
	{
		g_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() Could not find class in Authenticated list for %s. Going to ADSI\r\n", pszWBEMClassName);

		CWbemClass *pWbemClass = NULL;
		IWbemClassObject *pNewObject = NULL;

		try
		{
			if(SUCCEEDED(result = GetClassFromADSI(pszWBEMClassName, pCtx, &pNewObject)))
			{
				// Add it to the cache
				pWbemClass = NULL;
				if(pWbemClass = new CWbemClass(pszWBEMClassName, pNewObject))
				{
					s_pWbemCache->AddClass(pWbemClass);

					pWbemClass->Release();
					pWbemClass = NULL;

					g_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() GetClassFromADSI succeeded for %s Added it to cache\r\n", pszWBEMClassName);
					
					// Clone it
					if(!SUCCEEDED(result = pNewObject->Clone(ppWbemClassObject)))
							g_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() Clone() FAILED : %x for %s\r\n", result, pszWBEMClassName);

					pNewObject->Release();
					pNewObject = NULL;

					// Add it to the list of classnames for this user
					m_AccessAllowedClasses.AddName(pszWBEMClassName);
					g_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() Also added to Authenticated list : %s \r\n", pszWBEMClassName);
				}
				else
					result = E_OUTOFMEMORY;
			}
			else
				g_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() GetClassFromADSI FAILED : %x for %s\r\n", result, pszWBEMClassName);
		}
		catch ( ... )
		{
			if ( pNewObject )
			{
				pNewObject->Release ();
				pNewObject = NULL;
			}

			if ( pWbemClass )
			{
				pWbemClass->Release ();
				pWbemClass = NULL;
			}

			throw;
		}
	}

	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\classpro.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:classpro.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the DS Class Provider class. This is
//	the base class for all DS Class Providers. Note that an instance of the CDSClassProviderInitializer
//	class has to be created to initialize the static members of the CDSClassProvider class. Hence exactly
//	one instance of the CDSClassProviderInitializer class should be created for this
//	class to function properly.
//
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef DS_CLASS_PROVIDER_H
#define DS_CLASS_PROVIDER_H

 
// Forward declaration for the initializer class
class CDSClassProviderInitializer;

class CDSClassProvider : public IWbemProviderInit, public IWbemServices
{
	// The initialization class is a friend of this class
	friend CDSClassProviderInitializer;

public:

	static DWORD dwClassProviderCount;
	// Create the object by passing the log object
    CDSClassProvider () ;
    virtual ~CDSClassProvider () ;

	////////////////////////////////////////
	//IUnknown members
	////////////////////////////////////////
	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;


	////////////////////////////////////////
	//IWbemProviderInit members
	////////////////////////////////////////
	virtual HRESULT STDMETHODCALLTYPE Initialize( 
            LPWSTR wszUser,
            LONG lFlags,
            LPWSTR wszNamespace,
            LPWSTR wszLocale,
            IWbemServices __RPC_FAR *pNamespace,
            IWbemContext __RPC_FAR *pCtx,
            IWbemProviderInitSink __RPC_FAR *pInitSink) ;

		
	////////////////////////////////////////
	//IWbemServices members
	////////////////////////////////////////
    virtual HRESULT STDMETHODCALLTYPE OpenNamespace( 
        /* [in] */ const BSTR strNamespace,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult);
    
    virtual HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink);
    
    virtual HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE GetObject( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE GetObjectAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE PutClass( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE PutClassAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteClass( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE CreateClassEnum( 
        /* [in] */ const BSTR strSuperclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
        /* [in] */ const BSTR strSuperclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE PutInstance( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteInstance( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE ExecQuery( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE ExecMethod( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ const BSTR strMethodName,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ const BSTR strMethodName,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);




protected:

#ifdef PROFILING
	// Used for profiling. Should be removed.
	DWORD dwStartTime;
#endif

	////////////////////////////////////////////////
	// Functions for interacting with ADSI providers
	////////////////////////////////////////////////
	//***************************************************************************
	//
	// CDSClassProvider::GetWBEMProviderName
	//
	// Purpose : Returns the name of the provider. This should be the same as the
	// value of the field Name in the __Win32Provider instance used for registration
	// of the provider
	//
	// Parameters:
	//	None
	// 
	//	Return Value: The name of the provider
	//***************************************************************************
	virtual const BSTR GetWBEMProviderName() = 0;

	//***************************************************************************
	//
	// CDSClassProvider::IsUnProvidedClass
	//
	// Purpose : To check whether a class is one that the provider does not provide
	//
	// Parameters:
	//	lpszClassName : The WBEM Name of the class to be checked
	//
	// 
	//	Return Value: TRUE is this is one of the classes not provided by the provider
	//***************************************************************************
	virtual BOOLEAN IsUnProvidedClass(LPCWSTR lpszClassName) = 0;

	//***************************************************************************
	//
	// CDSClassProvider::GetClassFromCacheOrADSI
	//
	// Purpose : To create a WBEM class from an ADSI Class
	//
	// Parameters:
	//	lpszClassName : The WBEM Name of the class to be retreived
	//	pCtx : A pointer to the context object that was used in this call. This
	//		may be used by this function to make calls to CIMOM
	//
	// 
	//	Return Value: The COM result representing the status. 
	//***************************************************************************
	virtual HRESULT GetClassFromCacheOrADSI(LPCWSTR pszWBEMClassName, 
		IWbemClassObject **ppReturnObject,
		IWbemContext *pCtx);

	//***************************************************************************
	//
	// CDSClassProvider::GetClassFromADSI
	//
	// Purpose : To create a WBEM class from an ADSI Class
	//
	// Parameters:
	//	lpszClassName : The WBEM Name of the class to be retreived
	//	pCtx : A pointer to the context object that was used in this call. This
	//		may be used by this function to make calls to CIMOM
	//	ppWbemClass : The resulting WBEM Class. This has to be released once the
	//		user is done with it.
	//
	// 
	//	Return Value: The COM result representing the status. 
	//***************************************************************************
	virtual HRESULT GetClassFromADSI( 
		LPCWSTR lpszClassName,
		IWbemContext *pCtx,
		IWbemClassObject ** ppWbemClass
		) = 0;	

	//***************************************************************************
	//
	// CDSClassProvider::GetADSIClass
	//
	// Purpose : To Create a CADSIClass from an ADSI classSchema object
	// Parameters:
	//		lpszWBEMClassName : The WBEM Name of the class to be fetched. 
	//		ppADSIClass : The address where the pointer to the CADSIClass will be stored.
	//			It is the caller's responsibility to Release() the object when done with it
	// 
	//	Return Value: The COM status value indicating the status of the request.
	//***************************************************************************
	virtual HRESULT GetADSIClass(LPCWSTR lpszClassName, 
		CADSIClass ** ppADSIClass) = 0;

	//***************************************************************************
	//
	// CDSClassProvider::GetADSIProperty
	//
	// Purpose : To create an CADSIProperty object from an LDAP AttributeSchema object
	// Parameters:
	//		lpszPropertyName : The LDAPDisplayName of the LDAP property to be fetched. 
	//		ppADSIProperty : The address where the pointer to the IDirectoryObject interface will be stored
	//			It is the caller's responsibility to Release() the interface when done with it
	// 
	//	Return Value: The COM status value indicating the status of the request
	//***************************************************************************
	virtual HRESULT GetADSIProperty(
		LPCWSTR lpszPropertyName, 
		CADSIProperty **ppADSIProperty) = 0;

	//***************************************************************************
	//
	// CDSClassProvider::GetWBEMBaseClassName
	//
	// Purpose : Returns the name of the class that is the base class of all classes
	//	provided by this provider.
	//
	// Parameters:
	//	None
	// 
	//	Return Value: The name of the base class. NULL if such a class doesnt exist.
	//***************************************************************************
	virtual const BSTR GetWBEMBaseClassName() = 0;
	//***************************************************************************
	//
	// CDSClassProvider::GetWBEMBaseClass
	//
	// Purpose : Returns a pointer to the class that is the base class of all classes
	//	provided by this provider.
	//
	// Parameters:
	//	None
	// 
	//	Return Value: The IWbemClassObject pointer to the base class. It is the duty of 
	//	user to release the class when done with using it.
	//***************************************************************************
	virtual IWbemClassObject * GetWBEMBaseClass() = 0;

	// Returns whether the class name is present in the list of classes authorized for this user
	BOOLEAN IsClassAccessible();

	// The IWbemServices pointer stored from Initialize()
	IWbemServices *m_IWbemServices;

	// Indicates whether the call to Initialize() was successful
	BOOLEAN m_bInitializedSuccessfully;

	// Creates a log file using the m_lpszLogFileName member
	BOOLEAN CreateLogFile();

	// Some literals
	static BSTR CLASS_STR;

	// A cache of wbem classes
	static CWbemCache *s_pWbemCache;

	// A list of classes to which access has been granted for this user
	CNamesList m_AccessAllowedClasses;

private:

	// The COM Reference count
    long m_lReferenceCount ;
};


#endif // DS_CLASS_PROVIDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\classfac.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:classfac.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the DS Class Provider class factory and
// the DS CLass Associations Provider class factory.
//
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef DS_CLASS_PROVIDER_CLASS_FACTORY_H
#define DS_CLASS_PROVIDER_CLASS_FACTORY_H


////////////////////////////////////////////////////////////////
//////
//////		The DS Class provider class factory
//////
///////////////////////////////////////////////////////////////
class CDSClassProviderClassFactory : public IClassFactory
{
private:

    long m_ReferenceCount ;

protected:
public:

	// Initializer objects required by the classes used by the DLL
	static CDSClassProviderInitializer *s_pDSClassProviderInitializer;
	static CLDAPClassProviderInitializer *s_pLDAPClassProviderInitializer;

    CDSClassProviderClassFactory () ;
    ~CDSClassProviderClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;

};

////////////////////////////////////////////////////////////////
//////
//////		The DS Class Associations provider class factory
//////
///////////////////////////////////////////////////////////////
class CDSClassAssociationsProviderClassFactory : public IClassFactory
{
private:

    long m_ReferenceCount ;

protected:
public:


    CDSClassAssociationsProviderClassFactory () ;
    ~CDSClassAssociationsProviderClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;
};


#endif // DS_CLASS_PROVIDER_CLASS_FACTORY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\assocprov.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:classpro.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains implementation of the DS Class Associations Provider class. 
//
//***************************************************************************

#include "precomp.h"

/////////////////////////////////////////
// Initialize the static members
/////////////////////////////////////////
LPCWSTR CLDAPClassAsssociationsProvider :: s_LogFileName			= L"wbem\\logs\\ldapascl.txt";
LPCWSTR CLDAPClassAsssociationsProvider :: CHILD_CLASS_PROPERTY		= L"ChildClass";
LPCWSTR CLDAPClassAsssociationsProvider :: PARENT_CLASS_PROPERTY	= L"ParentClass";
LPCWSTR CLDAPClassAsssociationsProvider :: POSSIBLE_SUPERIORS		= L"PossibleSuperiors";
LPCWSTR CLDAPClassAsssociationsProvider :: SCHEMA_NAMING_CONTEXT	= L"schemaNamingContext";
LPCWSTR CLDAPClassAsssociationsProvider :: LDAP_SCHEMA				= L"LDAP://Schema";	
LPCWSTR CLDAPClassAsssociationsProvider :: LDAP_SCHEMA_SLASH		= L"LDAP://Schema/";	

//***************************************************************************
//
// CLDAPClassAsssociationsProvider::CLDAPClassAsssociationsProvider
// CLDAPClassAsssociationsProvider::~CLDAPClassAsssociationsProvider
//
// Constructor Parameters:
//
//  
//***************************************************************************

CLDAPClassAsssociationsProvider :: CLDAPClassAsssociationsProvider ()
{
	InterlockedIncrement(&g_lComponents);

	m_lReferenceCount = 0 ;
	m_IWbemServices = NULL;
	m_pAssociationClass = NULL;

	m_lpszSchemaContainerSuffix = NULL;
	m_pDirectorySearchSchemaContainer = NULL;
	m_bInitializedSuccessfully = FALSE;

	CHILD_CLASS_PROPERTY_STR = SysAllocString(CHILD_CLASS_PROPERTY);
	PARENT_CLASS_PROPERTY_STR = SysAllocString(PARENT_CLASS_PROPERTY);
	CLASS_ASSOCIATION_CLASS_STR = SysAllocString(CLASS_ASSOCIATION_CLASS);
	POSSIBLE_SUPERIORS_STR = SysAllocString(POSSIBLE_SUPERIORS);
}

CLDAPClassAsssociationsProvider::~CLDAPClassAsssociationsProvider ()
{
	g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: DESTRUCTOR\r\n");

	InterlockedDecrement(&g_lComponents);

	if(m_IWbemServices)
		m_IWbemServices->Release();

	if(m_pDirectorySearchSchemaContainer)
		m_pDirectorySearchSchemaContainer->Release();

	if(m_pAssociationClass)
		m_pAssociationClass->Release();

	delete [] m_lpszSchemaContainerSuffix;

	SysFreeString(CHILD_CLASS_PROPERTY_STR);
	SysFreeString(PARENT_CLASS_PROPERTY_STR);
	SysFreeString(CLASS_ASSOCIATION_CLASS_STR);
	SysFreeString(POSSIBLE_SUPERIORS_STR);
}

//***************************************************************************
//
// CLDAPClassAsssociationsProvider::QueryInterface
// CLDAPClassAsssociationsProvider::AddRef
// CLDAPClassAsssociationsProvider::Release
//
// Purpose: Standard COM routines needed for all COM objects
//
//***************************************************************************

STDMETHODIMP CLDAPClassAsssociationsProvider :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) (IUnknown *)(IWbemProviderInit *)this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) (IWbemServices *)this ;		
	}	
	else if ( iid == IID_IWbemProviderInit )
	{
		*iplpv = ( LPVOID ) (IWbemProviderInit *)this ;		
	}	
	else
	{
		return E_NOINTERFACE;
	}

	( ( LPUNKNOWN ) *iplpv )->AddRef () ;
	return  S_OK;
}


STDMETHODIMP_( ULONG ) CLDAPClassAsssociationsProvider :: AddRef ()
{
	return InterlockedIncrement ( & m_lReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CLDAPClassAsssociationsProvider :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_lReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}


HRESULT CLDAPClassAsssociationsProvider :: Initialize( 
        LPWSTR wszUser,
        LONG lFlags,
        LPWSTR wszNamespace,
        LPWSTR wszLocale,
        IWbemServices __RPC_FAR *pNamespace,
        IWbemContext __RPC_FAR *pCtx,
        IWbemProviderInitSink __RPC_FAR *pInitSink)
{

	// Validate the arguments
	if(pNamespace == NULL || lFlags != 0)
	{
		g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: Argument validation FAILED\r\n");
		pInitSink->SetStatus(WBEM_E_FAILED, 0);
		return WBEM_S_NO_ERROR;
	}

	// Store the IWbemServices pointer for future use
	m_IWbemServices = pNamespace;
	m_IWbemServices->AddRef();
		
	// Do LDAP Provider initialization
	if(!InitializeAssociationsProvider(pCtx))
	{
		g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: InitializeAssociationsProvider FAILED\r\n");
		m_IWbemServices->Release();
		m_IWbemServices = NULL;
		m_bInitializedSuccessfully = FALSE;
	}
	else
		m_bInitializedSuccessfully = TRUE;

	pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
	return WBEM_S_NO_ERROR;
}

HRESULT CLDAPClassAsssociationsProvider :: OpenNamespace( 
    /* [in] */ const BSTR strNamespace,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: CancelAsyncCall( 
    /* [in] */ IWbemObjectSink __RPC_FAR *pSink)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: QueryObjectSink( 
    /* [in] */ long lFlags,
    /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: GetObject( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: GetObjectAsync( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{

	if(!m_bInitializedSuccessfully)
	{
		g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: Initialization status is FAILED, hence returning failure\n");
		return WBEM_E_FAILED;
	}

	g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: GetObjectAsync() called for %s \r\n", strObjectPath);

	HRESULT result = S_OK;

	// Impersonate the client
	if(!SUCCEEDED(result = WbemCoImpersonateClient()))
	{
		g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: GetObjectAsync() CoImpersonate FAILED for %s with %x\r\n", strObjectPath, result);
		return WBEM_E_FAILED;
	}

	// Validate the arguments
	if(strObjectPath == NULL || lFlags != 0) 
	{
		g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: GetObjectAsync() argument validation FAILED\r\n");
		return WBEM_E_INVALID_PARAMETER;
	}

	// Parse the object path
	CObjectPathParser theParser;
	ParsedObjectPath *theParsedObjectPath = NULL;
	switch(theParser.Parse(strObjectPath, &theParsedObjectPath))
	{
		case CObjectPathParser::NoError:
			break;
		default:
			g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: GetObjectAsync() object path parsing FAILED\r\n");
			return WBEM_E_INVALID_PARAMETER;
	}

	// Check whether there are exactly 2 keys specified
	if(theParsedObjectPath->m_dwNumKeys != 2)
		result = WBEM_E_INVALID_PARAMETER;

	// Check whether these keys are 
	KeyRef *pChildKeyRef = *(theParsedObjectPath->m_paKeys);
	KeyRef *pParentKeyRef = *(theParsedObjectPath->m_paKeys + 1);

	if(_wcsicmp(pChildKeyRef->m_pName, CHILD_CLASS_PROPERTY) != 0)
	{
		// Exchange them
		KeyRef *temp = pChildKeyRef;
		pChildKeyRef = pParentKeyRef;
		pParentKeyRef = pChildKeyRef;
	}

	// The status on the sink
	IWbemClassObject *ppReturnWbemClassObjects[1];
	ppReturnWbemClassObjects[0] = NULL;

	if(SUCCEEDED(result))
	{
		if(SUCCEEDED(result = IsContainedIn(pChildKeyRef->m_vValue.bstrVal, pParentKeyRef->m_vValue.bstrVal)))
		{
			if(result == S_OK)
			{
				if(SUCCEEDED(result = CreateInstance(pChildKeyRef->m_vValue.bstrVal, pParentKeyRef->m_vValue.bstrVal, ppReturnWbemClassObjects)))
				{
					result = pResponseHandler->Indicate(1, ppReturnWbemClassObjects);
					ppReturnWbemClassObjects[0]->Release();
				}

			}
			else // the instance was not found
			{
				g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: returning WBEM_E_NOT_FOUND for %s \r\n", strObjectPath);
				result = WBEM_E_NOT_FOUND;
			}
		}
		else
		{
			g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: IsContainedIn() FAILED with %x \r\n", result);
		}
	}

	// Free the parser object path
	theParser.Free(theParsedObjectPath);

	// Set the status of the request
	result = (SUCCEEDED(result)? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND);
	pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE , result, NULL, NULL);
	
	return result;
}

HRESULT CLDAPClassAsssociationsProvider :: PutClass( 
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: PutClassAsync( 
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: DeleteClass( 
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: DeleteClassAsync( 
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: CreateClassEnum( 
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: CreateClassEnumAsync( 
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: PutInstance( 
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: PutInstanceAsync( 
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: DeleteInstance( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: DeleteInstanceAsync( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: CreateInstanceEnum( 
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: CreateInstanceEnumAsync( 
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	if(!m_bInitializedSuccessfully)
	{
		g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: Initialization status is FAILED, hence returning failure\n");
		return WBEM_E_FAILED;
	}

	g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: CreateInstanceEnumAsync() called\r\n");

	HRESULT result = S_OK;

	// Impersonate the client
	if(!SUCCEEDED(result = WbemCoImpersonateClient()))
	{
		g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: CreateInstanceEnumAsync() CoImpersonate FAILED with %x\r\n", result);
		return WBEM_E_FAILED;
	}

	// Get all the ADSI classes 
	result = DoEnumeration(pResponseHandler);

			
	if(SUCCEEDED(result))
	{
		pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_S_NO_ERROR, NULL, NULL);
		g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: CreateInstanceEnumAsync()  enumeration succeeded\r\n");
		return WBEM_S_NO_ERROR;
	}
	else
	{
		pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_E_FAILED, NULL, NULL);
		g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: CreateInstanceEnumAsync() enumeration FAILED\r\n");
		return WBEM_E_FAILED;
	}	
	
	return result;
}

HRESULT CLDAPClassAsssociationsProvider :: ExecQuery( 
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: ExecQueryAsync( 
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

HRESULT CLDAPClassAsssociationsProvider :: ExecNotificationQuery( 
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: ExecNotificationQueryAsync( 
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: ExecMethod( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: ExecMethodAsync( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}


//***************************************************************************
//
// CLDAPClassAsssociationsProvider::IsContainedIn
//
// Purpose: Checks whether a containment is valid
//
// Parameters: 
//	lpszChildClass : The WBEM Name of the child class
//	lpszParentClass : The WBEM Name of the parent class
//
// Return Value: The COM status of the request
//
//***************************************************************************
HRESULT CLDAPClassAsssociationsProvider :: IsContainedIn(LPCWSTR lpszChildClass, LPCWSTR lpszParentClass)
{
	LPWSTR lpszLDAPChildClass = NULL;
	LPWSTR lpszLDAPParentClass = NULL;
	lpszLDAPChildClass = CLDAPHelper::UnmangleWBEMNameToLDAP(lpszChildClass);
	lpszLDAPParentClass = CLDAPHelper::UnmangleWBEMNameToLDAP(lpszParentClass);

	// Check whether these are valid names
	if(!lpszLDAPChildClass || !lpszLDAPParentClass)
	{
		delete [] lpszLDAPChildClass;
		delete [] lpszLDAPParentClass;
		return S_FALSE;
	}

	LPWSTR lpszADSIAbstractSchemaPath = new WCHAR[wcslen(LDAP_SCHEMA_SLASH) + wcslen(lpszLDAPChildClass) + 1];
	wcscpy(lpszADSIAbstractSchemaPath, LDAP_SCHEMA_SLASH);
	wcscat(lpszADSIAbstractSchemaPath, lpszLDAPChildClass);

	IADsClass *pADsChildClass;
	HRESULT result;
	if(SUCCEEDED(result = ADsOpenObject(lpszADSIAbstractSchemaPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IADsClass, (LPVOID *) &pADsChildClass)))
	{
		// Get the POSSIBLE_SUPERIORS_STR property. This property contains the possible superiors
		VARIANT variant;
		VariantInit(&variant);
		if(SUCCEEDED(result = pADsChildClass->get_PossibleSuperiors(&variant)))
		{
			// Check the lone possible superior
			if(variant.vt == VT_BSTR)
			{
				if(_wcsicmp(variant.bstrVal, lpszLDAPParentClass) == 0)
					result = S_OK;
				else
					result = S_FALSE;
			}
			else
			{
				// Go thru the list of possible superiorsV
				SAFEARRAY *pSafeArray = variant.parray;
				LONG lNumber = 0;
				VARIANT vTmp;
				if(SUCCEEDED(result = SafeArrayGetUBound(pSafeArray, 1, &lNumber)) )
				{
					result = S_FALSE;
					for(LONG index=0L; index<=lNumber; index++)
					{
						if(SUCCEEDED(SafeArrayGetElement(pSafeArray, &index, &vTmp) ))
						{
							if(_wcsicmp(vTmp.bstrVal, lpszLDAPParentClass) == 0)
							{
								result = S_OK;
							}
							VariantClear(&vTmp);
							if(result == S_OK)
								break;
						}
					}
				}
			}

			VariantClear(&variant);
		}
		pADsChildClass->Release();
	}

	delete [] lpszLDAPChildClass;
	delete [] lpszLDAPParentClass;
	delete [] lpszADSIAbstractSchemaPath;

	return result;
}

//***************************************************************************
//
// CLDAPClassAsssociationsProvider::InitializeAssociationsProvider
//
// Purpose: A helper function to do the ADSI LDAP provider specific initialization.
//
// Parameters:
//		pCtx	The context object used in this call initialization
// 
// Return Value: TRUE if the function successfully finishes the initializaion. FALSE
//	otherwise
//***************************************************************************
BOOLEAN CLDAPClassAsssociationsProvider :: InitializeAssociationsProvider(IWbemContext *pCtx)
{
	// Get the class for which instances are provided by the provider
	HRESULT result = m_IWbemServices->GetObject(CLASS_ASSOCIATION_CLASS_STR, 0, pCtx, &m_pAssociationClass, NULL);
	if(SUCCEEDED(result))
	{
		// Get the ADSI path of the schema container and store it for future use
		IADs *pRootDSE = NULL;
		if(SUCCEEDED(result = ADsOpenObject((LPWSTR)ROOT_DSE_PATH, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IADs, (LPVOID *) &pRootDSE)))
		{
			// Get the location of the schema container
			BSTR strSchemaPropertyName = SysAllocString((LPWSTR) SCHEMA_NAMING_CONTEXT);

			// Get the schemaNamingContext property. This property contains the ADSI path
			// of the schema container
			VARIANT variant;
			VariantInit(&variant);
			if(SUCCEEDED(result = pRootDSE->Get(strSchemaPropertyName, &variant)))
			{
				// Store the ADSI path to the schema container
				m_lpszSchemaContainerSuffix = new WCHAR[wcslen(variant.bstrVal) + 1];
				wcscpy(m_lpszSchemaContainerSuffix, variant.bstrVal );
				g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: Got Schema Container as : %s\r\n", m_lpszSchemaContainerSuffix);

				// Form the schema container path
				LPWSTR lpszSchemaContainerPath = new WCHAR[wcslen(LDAP_PREFIX) + wcslen(m_lpszSchemaContainerSuffix) + 1];
				wcscpy(lpszSchemaContainerPath, LDAP_PREFIX);
				wcscat(lpszSchemaContainerPath, m_lpszSchemaContainerSuffix);
				if(SUCCEEDED(result = ADsOpenObject(lpszSchemaContainerPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectorySearch, (LPVOID *) &m_pDirectorySearchSchemaContainer)))
				{
					g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: Got IDirectorySearch on Schema Container \r\n");
				}
				else
					g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: FAILED to get IDirectorySearch on Schema Container : %x\r\n", result);

				delete[] lpszSchemaContainerPath;
			}
			else
				g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: Get on RootDSE FAILED : %x\r\n", result);

			SysFreeString(strSchemaPropertyName);
			VariantClear(&variant);
			pRootDSE->Release();
		}
		else
			g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: InitializeLDAPProvider ADsOpenObject on RootDSE FAILED : %x\r\n", result);
	}
	else
		g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: InitializeLDAPProvider GetClass on LDAP Association class FAILED : %x\r\n", result);

	return SUCCEEDED(result);
}

HRESULT CLDAPClassAsssociationsProvider :: DoEnumeration(IWbemObjectSink *pResponseHandler)
{
	HRESULT result = E_FAIL;

	// Get the IADsContainer interface on the schema container
	IADsContainer *pADsContainer = NULL;
	IUnknown *pChild = NULL;

	// An instance of the association
	IWbemClassObject *pInstance = NULL;

	if(SUCCEEDED(result = ADsOpenObject((LPWSTR)LDAP_SCHEMA, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IADsContainer, (LPVOID *) &pADsContainer)))
	{
		IEnumVARIANT *pEnum = NULL;
		if(SUCCEEDED(result = ADsBuildEnumerator(pADsContainer, &pEnum)))
		{
			IADsClass *pADsChildClass = NULL;
			VARIANT v;
			VariantInit(&v);
			while (SUCCEEDED(result = ADsEnumerateNext(pEnum, 1, &v, NULL)) && result != S_FALSE)
			{
				pChild = v.punkVal;
				if(SUCCEEDED(result = pChild->QueryInterface(IID_IADsClass, (LPVOID *) &pADsChildClass)))
				{
					BSTR strChildClassName;
					if(SUCCEEDED(result = pADsChildClass->get_Name(&strChildClassName)))
					{
						// Mangle the name to WBEM
						LPWSTR szChildName = CLDAPHelper::MangleLDAPNameToWBEM(strChildClassName);
						VARIANT variant;
						VariantInit(&variant);
						if(SUCCEEDED(result = pADsChildClass->get_PossibleSuperiors(&variant)))
						{
							// Check the lone possible superior
							if(variant.vt == VT_BSTR)
							{
								LPWSTR szParentName = CLDAPHelper::MangleLDAPNameToWBEM(variant.bstrVal);
								if(SUCCEEDED(result = CreateInstance(szChildName, szParentName, &pInstance)))
								{
									pResponseHandler->Indicate(1, &pInstance);
									pInstance->Release();
								}
								delete [] szParentName;
							}
							else // It is an array of variants
							{
								// Go thru the list of possible superiorsV
								SAFEARRAY *pSafeArray = variant.parray;
								VARIANT HUGEP *pVar;
								LONG lUbound = 0, lLbound = 0;
								if(SUCCEEDED(result = SafeArrayAccessData(pSafeArray, (void HUGEP* FAR*)&pVar) ) )
								{
									if( SUCCEEDED (result = SafeArrayGetLBound(pSafeArray, 1, &lLbound)) &&
										SUCCEEDED (result = SafeArrayGetUBound(pSafeArray, 1, &lUbound)) )
									{
										for(LONG index=lLbound; index<=lUbound; index++)
										{
											LPWSTR szParentName = CLDAPHelper::MangleLDAPNameToWBEM(pVar[index].bstrVal);
											if(SUCCEEDED(result = CreateInstance(szChildName, szParentName, &pInstance)))
											{
												pResponseHandler->Indicate(1, &pInstance);
												pInstance->Release();
											}
											delete [] szParentName;
										}
									}
									SafeArrayUnaccessData(pSafeArray);
								}
							}
							VariantClear(&variant);
						}
						delete [] szChildName;
						SysFreeString(strChildClassName);
					}
					pADsChildClass->Release();
				}
				VariantClear(&v);
			}
			ADsFreeEnumerator(pEnum);
		}

		pADsContainer->Release();
	}
	else
		g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: FAILED to get IDirectoryObject on Schema Container : %x\r\n", result);

	return result;

}

HRESULT CLDAPClassAsssociationsProvider :: CreateInstance(BSTR strChildName, BSTR strParentName, IWbemClassObject **ppInstance)
{
	HRESULT result = E_FAIL;
	*ppInstance = NULL;
	if(SUCCEEDED(result = m_pAssociationClass->SpawnInstance(0, ppInstance)))
	{
		// Put the property values
		if(SUCCEEDED(result = CWBEMHelper::PutBSTRProperty(*ppInstance, CHILD_CLASS_PROPERTY_STR, strChildName, FALSE)))
		{
			if(SUCCEEDED(result = CWBEMHelper::PutBSTRProperty(*ppInstance, PARENT_CLASS_PROPERTY_STR, strParentName, FALSE)))
			{
			}
			else
				g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: CreateInstance() PutBSTRProperty on parent property FAILED %x \r\n", result);
		}
		else
			g_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: CreateInstance() PutBSTRProperty on child property FAILED %x \r\n", result);
	}

	if(FAILED(result) && *ppInstance)
	{
		(*ppInstance)->Release();
		*ppInstance = NULL;
	}
	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\classfac.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:classfac.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the implementation of the DS Class Provider factory.
// Currently it always creates the LDAP CLass Provider. It remains to be decided as to how this can
// be changed
//
//***************************************************************************

#include "precomp.h"

// Initializer objects required by the classes used by the DLL
CDSClassProviderInitializer *CDSClassProviderClassFactory::s_pDSClassProviderInitializer = NULL;
CLDAPClassProviderInitializer *CDSClassProviderClassFactory::s_pLDAPClassProviderInitializer = NULL;



//***************************************************************************
//
// CDSClassProviderClassFactory::CDSClassProviderClassFactory
// CDSClassProviderClassFactory::~CDSClassProviderClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CDSClassProviderClassFactory :: CDSClassProviderClassFactory ()
{
	m_ReferenceCount = 0 ;
	InterlockedIncrement(&g_lComponents);
}

CDSClassProviderClassFactory::~CDSClassProviderClassFactory ()
{
	InterlockedDecrement(&g_lComponents);
}

//***************************************************************************
//
// CDSClassProviderClassFactory::QueryInterface
// CDSClassProviderClassFactory::AddRef
// CDSClassProviderClassFactory::Release
//
// Purpose: Standard COM routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CDSClassProviderClassFactory::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IClassFactory )
	{
		*iplpv = ( LPVOID ) this ;		
	}	
	else
	{
		return E_NOINTERFACE;
	}

	( ( LPUNKNOWN ) *iplpv )->AddRef () ;
	return  S_OK;
}


STDMETHODIMP_( ULONG ) CDSClassProviderClassFactory :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CDSClassProviderClassFactory :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

//***************************************************************************
//
// CDSClassProviderClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CDSClassProviderClassFactory :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR * ppvObject
)
{
	HRESULT status = S_OK ;

	// We do not support aggregation
	if ( pUnkOuter )
	{
		status = CLASS_E_NOAGGREGATION ;
	}
	else 
	{
		// Check to see if the static members have been initialized
		// Create any initializer objects required for the classes
		EnterCriticalSection(&g_StaticsCreationDeletion);
		if(!s_pDSClassProviderInitializer)
		{
			BOOL bLogObjectAllocated = FALSE;

			try 
			{
				// Th Log Object might have been created by the CreateInstance() function for the other
				// providers (Instance/ Class Association)
				if( !g_pLogObject )
				{
					g_pLogObject = new ProvDebugLog(DSPROVIDER);
					bLogObjectAllocated = TRUE;
				}

				g_pLogObject->WriteW(L"CDSClassProviderClassFactory::CreateInstance() called\r\n");

				s_pDSClassProviderInitializer = new CDSClassProviderInitializer();
				s_pLDAPClassProviderInitializer = new CLDAPClassProviderInitializer();

			}
			catch(Heap_Exception e_HE)
			{
				if ( bLogObjectAllocated && g_pLogObject )
				{
					delete g_pLogObject;
					g_pLogObject = NULL;
				}

				if ( s_pDSClassProviderInitializer )
				{
					delete s_pDSClassProviderInitializer;
					s_pDSClassProviderInitializer = NULL;
				}

				if ( s_pLDAPClassProviderInitializer )
				{
					delete s_pLDAPClassProviderInitializer;
					s_pLDAPClassProviderInitializer = NULL;
				}

				status = E_OUTOFMEMORY ;
			}
		}
		LeaveCriticalSection(&g_StaticsCreationDeletion);

		if(SUCCEEDED(status))
		{
			CLDAPClassProvider *lpunk = NULL;
			try
			{
				lpunk = new CLDAPClassProvider();
				status = lpunk->QueryInterface ( riid , ppvObject ) ;
				if ( FAILED ( status ) )
				{
					delete lpunk ;
				}
			}
			catch(Heap_Exception e_HE)
			{
				if ( lpunk )
				{
					delete lpunk ;
					lpunk = NULL;
				}

				status = E_OUTOFMEMORY ;
			}
		}
	}

	return status ;
}

//***************************************************************************
//
// CDSClassProviderClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CDSClassProviderClassFactory :: LockServer ( BOOL fLock )
{
	if ( fLock )
	{
		InterlockedIncrement ( & g_lServerLocks ) ;
	}
	else
	{
		InterlockedDecrement ( & g_lServerLocks ) ;
	}

	return S_OK	;
}



//***************************************************************************
//
// CDSClassAssociationsProviderClassFactory::CDSClassAssociationsProviderClassFactory
// CDSClassAssociationsProviderClassFactory::~CDSClassAssociationsProviderClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CDSClassAssociationsProviderClassFactory :: CDSClassAssociationsProviderClassFactory ()
{
	m_ReferenceCount = 0 ;
	InterlockedIncrement(&g_lComponents);
}

CDSClassAssociationsProviderClassFactory::~CDSClassAssociationsProviderClassFactory ()
{
	InterlockedDecrement(&g_lComponents);
}

//***************************************************************************
//
// CDSClassAssociationsProviderClassFactory::QueryInterface
// CDSClassAssociationsProviderClassFactory::AddRef
// CDSClassAssociationsProviderClassFactory::Release
//
// Purpose: Standard COM routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CDSClassAssociationsProviderClassFactory::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IClassFactory )
	{
		*iplpv = ( LPVOID ) this ;		
	}	
	else
	{
		return E_NOINTERFACE;
	}

	( ( LPUNKNOWN ) *iplpv )->AddRef () ;
	return  S_OK;
}


STDMETHODIMP_( ULONG ) CDSClassAssociationsProviderClassFactory :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CDSClassAssociationsProviderClassFactory :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

//***************************************************************************
//
// CDSClassAssociationsProviderClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CDSClassAssociationsProviderClassFactory :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR * ppvObject
)
{
	HRESULT status = S_OK ;

	// We do not support aggregation
	if ( pUnkOuter )
	{
		status = CLASS_E_NOAGGREGATION ;
	}
	else 
	{
		CLDAPClassAsssociationsProvider *lpunk = NULL;
		// Check to see if the static members have been initialized
		// Create any initializer objects required for the classes
		EnterCriticalSection(&g_StaticsCreationDeletion);
		BOOL bLogObjectAllocated = FALSE;

		try 
		{
			// This might have been created by the CreateInstance() function of the
			// other DS Providers (Class, ClassAssociation)
			if( !g_pLogObject )
			{
				g_pLogObject = new ProvDebugLog(DSPROVIDER);
				bLogObjectAllocated = TRUE;
			}

			g_pLogObject->WriteW(L"CDSClassAssociationsProviderClassFactory::CreateInstance() called\r\n");

			lpunk = new CLDAPClassAsssociationsProvider();
			status = lpunk->QueryInterface ( riid , ppvObject ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;
			}
		}
		catch(Heap_Exception e_HE)
		{
			if ( bLogObjectAllocated && g_pLogObject )
			{
				delete g_pLogObject;
				g_pLogObject = NULL;
			}

			if ( lpunk )
			{
				delete lpunk;
				lpunk = NULL;
			}

			status = E_OUTOFMEMORY ;
		}
		LeaveCriticalSection(&g_StaticsCreationDeletion);
	}

	return status ;
}

//***************************************************************************
//
// CDSClassAssociationsProviderClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CDSClassAssociationsProviderClassFactory :: LockServer ( BOOL fLock )
{
	if ( fLock )
	{
		InterlockedIncrement ( & g_lServerLocks ) ;
	}
	else
	{
		InterlockedDecrement ( & g_lServerLocks ) ;
	}

	return S_OK	;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\clsname.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include "precomp.h"


CNamesList :: CNamesList()
{
	m_pListOfClassNames = NULL;
	m_dwElementCount = 0;
	InitializeCriticalSection(&m_AccessibleClassesSection);
}

CNamesList :: ~CNamesList()
{
	EnterCriticalSection(&m_AccessibleClassesSection);
	CLPWSTR *pTemp1 = m_pListOfClassNames;
	CLPWSTR *pNext = m_pListOfClassNames;
	while(pTemp1)
	{
		pNext = pTemp1->pNext;
		delete pTemp1;
		pTemp1 = pNext;
	}
	LeaveCriticalSection(&m_AccessibleClassesSection);
	DeleteCriticalSection(&m_AccessibleClassesSection);
}

BOOLEAN CNamesList :: IsNamePresent(LPCWSTR pszClassName) 
{
	// Get the current impersonation level
	DWORD dwCurrentImpersonationLevel = 0;
	if(FAILED(GetImpersonationLevel(&dwCurrentImpersonationLevel)))
		return FALSE;

	// Look for a name in the list that has an impersonation level of current or greater
	BOOLEAN bRetVal = FALSE;
	EnterCriticalSection(&m_AccessibleClassesSection);
	CLPWSTR *pCurrent = m_pListOfClassNames;
	while(pCurrent)
	{
		if(_wcsicmp(pCurrent->pszVal, pszClassName) == 0 && pCurrent->dwImpersonationLevel <= dwCurrentImpersonationLevel)
		{
			bRetVal = TRUE;
			break;
		}
		pCurrent = pCurrent->pNext;
	}
	LeaveCriticalSection(&m_AccessibleClassesSection);

	return bRetVal;
}

BOOLEAN CNamesList :: RemoveName(LPCWSTR pszClassName)
{
#ifdef NO_WBEM_CACHE
	return FALSE;
#else
	BOOLEAN bRetVal = FALSE;
	EnterCriticalSection(&m_AccessibleClassesSection);
	if(m_pListOfClassNames)
	{
		// Is it the first node ?
		if(_wcsicmp(m_pListOfClassNames->pszVal, pszClassName) == 0)
		{
			bRetVal = TRUE;
			CLPWSTR *pTemp = m_pListOfClassNames->pNext;
			delete m_pListOfClassNames;
			m_pListOfClassNames = pTemp;
			m_dwElementCount--;
		}
		else
		{
			CLPWSTR *pPrev = m_pListOfClassNames;
			CLPWSTR *pCurrent = m_pListOfClassNames->pNext;

			while(pCurrent)
			{
				if(_wcsicmp(pCurrent->pszVal, pszClassName) == 0)
				{
					bRetVal = TRUE;
					pPrev->pNext = pCurrent->pNext;
					delete pCurrent;
					m_dwElementCount --;
					break;
				}
				pPrev = pCurrent;
				pCurrent = pCurrent->pNext;
			}
		}
	}
	LeaveCriticalSection(&m_AccessibleClassesSection);

	return bRetVal;
#endif
}

BOOLEAN CNamesList :: AddName(LPCWSTR pszClassName)
{
#ifdef NO_WBEM_CACHE
	return FALSE;
#else

	// Get the current impersonation level
	DWORD dwCurrentImpersonationLevel = 0;
	if(!SUCCEEDED(GetImpersonationLevel(&dwCurrentImpersonationLevel)))
		return FALSE;
	
	
	// Add it only if it doesnt already exist in the list
	BOOLEAN bFound = FALSE;
	EnterCriticalSection(&m_AccessibleClassesSection);
	CLPWSTR *pCurrent = m_pListOfClassNames;
	while(pCurrent)
	{
		if(_wcsicmp(pCurrent->pszVal, pszClassName) == 0)
		{
			bFound = TRUE;
			break;
		}
		pCurrent = pCurrent->pNext;
	}

	// Add it at the head
	if(!bFound)
	{
		pCurrent = m_pListOfClassNames;
		m_pListOfClassNames = new CLPWSTR;
		m_pListOfClassNames->pszVal = new WCHAR[wcslen(pszClassName) + 1];
		m_pListOfClassNames->dwImpersonationLevel = dwCurrentImpersonationLevel;
		wcscpy(m_pListOfClassNames->pszVal, pszClassName);
		m_pListOfClassNames->pNext = pCurrent;
		m_dwElementCount ++;
	}
	else	// update the impersonation level if necessary
	{
		if(pCurrent->dwImpersonationLevel < dwCurrentImpersonationLevel)
			pCurrent->dwImpersonationLevel = dwCurrentImpersonationLevel;
	}
	LeaveCriticalSection(&m_AccessibleClassesSection);

	return !bFound;
#endif
}

DWORD CNamesList :: GetAllNames(LPWSTR **pppszNames) 
{
	EnterCriticalSection(&m_AccessibleClassesSection);
	DWORD retVal = m_dwElementCount;
	*pppszNames = NULL;
	if(m_dwElementCount)
	{
		if(*pppszNames = new LPWSTR[m_dwElementCount])
		{
			CLPWSTR *pCurrent = m_pListOfClassNames;
			bool bError = false;
			for(DWORD i=0; !bError && (i<m_dwElementCount); i++)
			{
				(*pppszNames)[i] = NULL;
				if((*pppszNames)[i] = new WCHAR[wcslen(pCurrent->pszVal) + 1])
				{
					wcscpy((*pppszNames)[i], pCurrent->pszVal);
					pCurrent = pCurrent->pNext;
				}
				else
					bError = true;
			}

			if(bError)
			{
				retVal = 0;
				delete [] (*pppszNames);
				*pppszNames = NULL;
			}
		}
		else
			retVal = 0;
	}
	LeaveCriticalSection(&m_AccessibleClassesSection);

	return retVal;
}

HRESULT CNamesList :: GetImpersonationLevel(DWORD *pdwImpLevel)
{
	//get implevel...
	HANDLE hThreadTok = NULL;
	HRESULT hr = E_FAIL;

	if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hThreadTok) )
	{
		DWORD dwBytesReturned = 0;
		DWORD dwThreadImpLevel = 0;

		if (GetTokenInformation(hThreadTok, TokenImpersonationLevel, &dwThreadImpLevel,
									sizeof(DWORD), &dwBytesReturned)) 
		{
			hr = S_OK;

			switch(dwThreadImpLevel)
			{
				case SecurityAnonymous:
				{
					*pdwImpLevel = RPC_C_IMP_LEVEL_ANONYMOUS;
				}
				break;

				case SecurityIdentification:
				{
					*pdwImpLevel = RPC_C_IMP_LEVEL_IDENTIFY;
				}
				break;

				case SecurityImpersonation:
				{
					*pdwImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
				}
				break;

				case SecurityDelegation:
				{
					*pdwImpLevel = RPC_C_IMP_LEVEL_DELEGATE;
				}
				break;
				
				default:
				{
					hr = E_FAIL;
				}
			}
		}
		CloseHandle(hThreadTok);
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\clsname.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:clasname.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for a list of class names. This user
// the templates from SNMPProvider\Common
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef NAME_LIST_H
#define NAME_LIST_H

// Need to encapsulate LPWSTR to avoid conversion to CString

class CLPWSTR
{
	public :
		LPWSTR pszVal;
		DWORD dwImpersonationLevel;
		CLPWSTR * pNext;

		CLPWSTR()
		{
			pszVal = NULL;
			pNext = NULL;
		}

		~CLPWSTR()
		{
			delete [] pszVal;
		}
};

class CNamesList
{

private:
	CRITICAL_SECTION m_AccessibleClassesSection;
	CLPWSTR *m_pListOfClassNames;
	DWORD m_dwElementCount;
	HRESULT GetImpersonationLevel(DWORD *pdwImpLevel);

public:
	CNamesList();
	virtual ~CNamesList();
	BOOLEAN IsNamePresent(LPCWSTR pszClassName);
	BOOLEAN RemoveName(LPCWSTR pszClassName);
	BOOLEAN AddName(LPCWSTR pszClassName);
	DWORD GetAllNames(LPWSTR **ppszNames);

};

#endif /*NAME_LIST_H*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\clsproi.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:clsproi.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the CDSClassProviderInitializer class. This class
// is used to initialize the static members of the CDSCLassProvider class
//
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef DS_CLASS_PROVIDER_INIT_H
#define DS_CLASS_PROVIDER_INIT_H

class CDSClassProviderInitializer
{

public:
	CDSClassProviderInitializer();
	~CDSClassProviderInitializer();
};

#endif /* DS_CLASS_PROVIDER_INIT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\clsproi.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:clsproi.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains implementation of the class that is used to initialize the
//	CDSClassProvider class
//
//***************************************************************************

#include "precomp.h"


//***************************************************************************
//
// CDSClassProviderInitializer::CDSClassProviderInitializer
//
// Constructor Parameters:
//		None
//
//  
//***************************************************************************

CDSClassProviderInitializer :: CDSClassProviderInitializer ()
{
	CDSClassProvider :: CLASS_STR				= SysAllocString(L"__CLASS");
	CDSClassProvider :: s_pWbemCache			= new CWbemCache();
}

//***************************************************************************
//
// CDSClassProviderInitializer::CDSClassProviderInitializer
//
// Destructor
//
//  
//***************************************************************************
CDSClassProviderInitializer :: ~CDSClassProviderInitializer ()
{
	delete CDSClassProvider::s_pWbemCache;
	SysFreeString(CDSClassProvider::CLASS_STR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\dsipguid.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 9/16/98 4:43p $
// 	$Workfile: dsipguid.cpp $
//
//	$Modtime: 9/16/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
//	Description: This file is used to generate definitions of the GUIDs in the project
//
// ***************************************************************************

#include <objbase.h>
#include <initguid.h>

#include "dsipguid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\dscpguid.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile: guids.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
//	Description: This file is used to generate definitions of the GUIDs in the project
//
// ***************************************************************************

#include <objbase.h>
#include <initguid.h>

#include "dscpguid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\dscpguid.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:guids.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains GUID definitions used in this project
//
//***************************************************************************

//
// The CLSID of the DS Provider - {1EF94880-01A8-11d2-A90B-00AA00BF3363}
//
DEFINE_GUID(CLSID_DSProvider, 0x1ef94880, 0x1a8, 0x11d2, 0xa9, 0xb, 0x0, 0xaa, 0x0, 0xbf, 0x33, 0x63);

//
// The CLSID of the DS Class ASsociations Provider - {33831ED4-42B8-11d2-93AD-00805F853771}
//
DEFINE_GUID(CLSID_DSClassAssocProvider, 0x33831ed4, 0x42b8, 0x11d2, 0x93, 0xad, 0x0, 0x80, 0x5f, 0x85, 0x37, 0x71);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\dsipguid.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 9/16/98 4:43p $
// 	$Workfile:dsipguid.h $
//
//	$Modtime: 9/16/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains GUID definitions used in this project
//
//***************************************************************************

//
// The CLSID of the DS Instance Provider - {AA527A40-4D9A-11d2-93AD-00805F853771}
//
// {AA527A40-4D9A-11d2-93AD-00805F853771}
DEFINE_GUID(CLSID_DSInstanceProvider, 
0xaa527a40, 0x4d9a, 0x11d2, 0x93, 0xad, 0x0, 0x80, 0x5f, 0x85, 0x37, 0x71);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\instfac.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 9/16/98 4:43p $
// 	$Workfile:classfac.cpp $
//
//	$Modtime: 9/16/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the DS Instnace Provider class factory
//
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef DS_INSTANCE_PROVIDER_CLASS_FACTORY_H
#define DS_INSTANCE_PROVIDER_CLASS_FACTORY_H


class CDSInstanceProviderClassFactory : public IClassFactory
{
private:

    long m_ReferenceCount ;

protected:
public:

	// Initializer objects required by the classes used by the DLL
	static CDSInstanceProviderInitializer *s_pDSInstanceProviderInitializer;

    CDSInstanceProviderClassFactory () ;
    ~CDSInstanceProviderClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;
};


#endif // DS_INSTANCE_PROVIDER_CLASS_FACTORY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\instfac.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 9/16/98 4:43p $
// 	$Workfile:classfac.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $
//	$Nokeywords:  $
//
//
//  Description: Contains the implementation of the DS Instance Provider factory.
//
//***************************************************************************

#include "precomp.h"

CDSInstanceProviderInitializer *CDSInstanceProviderClassFactory::s_pDSInstanceProviderInitializer = NULL;

//***************************************************************************
//
// CDSInstanceProviderClassFactory::CDSInstanceProviderClassFactory
// CDSInstanceProviderClassFactory::~CDSInstanceProviderClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CDSInstanceProviderClassFactory :: CDSInstanceProviderClassFactory ()
{
	m_ReferenceCount = 0 ;
	InterlockedIncrement(&g_lComponents);
}

CDSInstanceProviderClassFactory::~CDSInstanceProviderClassFactory ()
{
	InterlockedDecrement(&g_lComponents);
}

//***************************************************************************
//
// CDSInstanceProviderClassFactory::QueryInterface
// CDSInstanceProviderClassFactory::AddRef
// CDSInstanceProviderClassFactory::Release
//
// Purpose: Standard COM routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CDSInstanceProviderClassFactory::QueryInterface (

	REFIID iid ,
	LPVOID FAR *iplpv
)
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IClassFactory )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else
	{
		return E_NOINTERFACE;
	}

	( ( LPUNKNOWN ) *iplpv )->AddRef () ;
	return  S_OK;
}


STDMETHODIMP_( ULONG ) CDSInstanceProviderClassFactory :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CDSInstanceProviderClassFactory :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

//***************************************************************************
//
// CDSInstanceProviderClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CDSInstanceProviderClassFactory :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR * ppvObject
)
{
	HRESULT status = S_OK ;

	// We do not support aggregation
	if ( pUnkOuter )
	{
		status = CLASS_E_NOAGGREGATION ;
	}
	else
	{
		// Check to see if the static members have been initialized
		// Create any initializer objects required for the classes
		EnterCriticalSection(&g_StaticsCreationDeletion);
		if(!s_pDSInstanceProviderInitializer)
		{
			BOOL bLocObjectAllocated = FALSE;

			try
			{
				// This might have been created by the CreateInstance() function of the
				// other DS Providers (Class, ClassAssociation)
				if( !g_pLogObject )
				{
					g_pLogObject = new ProvDebugLog(DSPROVIDER);
					bLocObjectAllocated = TRUE;
				}

				g_pLogObject->WriteW(L"CDSInstanceProviderClassFactory::CreateInstance() called\r\n");
				s_pDSInstanceProviderInitializer = new CDSInstanceProviderInitializer();
			}
			catch(Heap_Exception e_HE)
			{
				if ( bLocObjectAllocated && g_pLogObject )
				{
					delete g_pLogObject;
					g_pLogObject = NULL;
				}

				if ( s_pDSInstanceProviderInitializer )
				{
					delete s_pDSInstanceProviderInitializer;
					s_pDSInstanceProviderInitializer = NULL;
				}

				status = E_OUTOFMEMORY ;
			}
		}
		LeaveCriticalSection(&g_StaticsCreationDeletion);

		if(SUCCEEDED(status))
		{
			CLDAPInstanceProvider *lpunk = NULL;
			try
			{
				lpunk = new CLDAPInstanceProvider();
				status = lpunk->QueryInterface ( riid , ppvObject ) ;
				if ( FAILED ( status ) )
				{
					delete lpunk ;
				}
			}
			catch(Heap_Exception e_HE)
			{
				status = E_OUTOFMEMORY ;
			}

		}
	}

	return status ;
}

//***************************************************************************
//
// CDSInstanceProviderClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CDSInstanceProviderClassFactory :: LockServer ( BOOL fLock )
{
	if ( fLock )
	{
		InterlockedIncrement ( & g_lServerLocks ) ;
	}
	else
	{
		InterlockedDecrement ( & g_lServerLocks ) ;
	}

	return S_OK	;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\instproi.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:instproi.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the CDSInstanceProviderInitializer class. This class
// is used to initialize the static members of the CLDAPInstanceProvider class
//
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef DS_INSTANCE_PROVIDER_INIT_H
#define DS_INSTANCE_PROVIDER_INIT_H

class CDSInstanceProviderInitializer
{

public:
	CDSInstanceProviderInitializer();
	~CDSInstanceProviderInitializer();
};

#endif /* DS_INSTANCE_PROVIDER_INIT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\instprov.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 9/16/98 4:43p $
// 	$Workfile:instprov.cpp $
//
//	$Modtime: 9/16/98 11:21a $
//	$Revision: 1 $
//	$Nokeywords:  $
//
//
//  Description: Contains implementation of the DS Instance Provider class.
//
//***************************************************************************

#include "precomp.h"

/////////////////////////////////////////
// Initialize the static members
/////////////////////////////////////////
LPCWSTR CLDAPInstanceProvider :: DEFAULT_NAMING_CONTEXT_ATTR	= L"defaultNamingContext";
LPCWSTR CLDAPInstanceProvider :: OBJECT_CLASS_EQUALS			= L"(objectClass=";
LPCWSTR CLDAPInstanceProvider :: QUERY_FORMAT					= L"select * from DSClass_To_DNInstance where DSClass=\"%s\"";
BSTR CLDAPInstanceProvider :: CLASS_STR							= NULL;
BSTR CLDAPInstanceProvider :: DN_PROPERTY						= NULL;
BSTR CLDAPInstanceProvider :: ROOT_DN_PROPERTY					= NULL;
BSTR CLDAPInstanceProvider :: QUERY_LANGUAGE					= NULL;
BSTR CLDAPInstanceProvider :: ADSI_PATH_STR						= NULL;
BSTR CLDAPInstanceProvider :: UINT8ARRAY_STR					= NULL;
BSTR CLDAPInstanceProvider :: DN_WITH_STRING_CLASS_STR			= NULL;
BSTR CLDAPInstanceProvider :: DN_WITH_BINARY_CLASS_STR			= NULL;
BSTR CLDAPInstanceProvider :: VALUE_PROPERTY_STR				= NULL;
BSTR CLDAPInstanceProvider :: DN_STRING_PROPERTY_STR			= NULL;
BSTR CLDAPInstanceProvider :: INSTANCE_ASSOCIATION_CLASS_STR	= NULL;
BSTR CLDAPInstanceProvider :: CHILD_INSTANCE_PROPERTY_STR		= NULL;
BSTR CLDAPInstanceProvider :: PARENT_INSTANCE_PROPERTY_STR		= NULL;
BSTR CLDAPInstanceProvider :: RELPATH_STR						= NULL;
BSTR CLDAPInstanceProvider :: ATTRIBUTE_SYNTAX_STR				= NULL;
BSTR CLDAPInstanceProvider :: DEFAULT_OBJECT_CATEGORY_STR		= NULL;
BSTR CLDAPInstanceProvider :: LDAP_DISPLAY_NAME_STR				= NULL;
BSTR CLDAPInstanceProvider :: PUT_EXTENSIONS_STR				= NULL;
BSTR CLDAPInstanceProvider :: PUT_EXT_PROPERTIES_STR			= NULL;
BSTR CLDAPInstanceProvider :: CIMTYPE_STR						= NULL;

// Names of the RootDSE attributes
BSTR CLDAPInstanceProvider :: SUBSCHEMASUBENTRY_STR							= NULL;
BSTR CLDAPInstanceProvider :: CURRENTTIME_STR								= NULL;
BSTR CLDAPInstanceProvider :: SERVERNAME_STR								= NULL;
BSTR CLDAPInstanceProvider :: NAMINGCONTEXTS_STR							= NULL;
BSTR CLDAPInstanceProvider :: DEFAULTNAMINGCONTEXT_STR						= NULL;
BSTR CLDAPInstanceProvider :: SCHEMANAMINGCONTEXT_STR						= NULL;
BSTR CLDAPInstanceProvider :: CONFIGURATIONNAMINGCONTEXT_STR				= NULL;
BSTR CLDAPInstanceProvider :: ROOTDOMAINNAMINGCONTEXT_STR					= NULL;
BSTR CLDAPInstanceProvider :: SUPPORTEDCONTROLS_STR							= NULL;
BSTR CLDAPInstanceProvider :: SUPPORTEDVERSION_STR							= NULL;
BSTR CLDAPInstanceProvider :: DNSHOSTNAME_STR								= NULL;
BSTR CLDAPInstanceProvider :: DSSERVICENAME_STR								= NULL;
BSTR CLDAPInstanceProvider :: HIGHESTCOMMITEDUSN_STR						= NULL;
BSTR CLDAPInstanceProvider :: LDAPSERVICENAME_STR							= NULL;
BSTR CLDAPInstanceProvider :: SUPPORTEDCAPABILITIES_STR						= NULL;
BSTR CLDAPInstanceProvider :: SUPPORTEDLDAPPOLICIES_STR						= NULL;
BSTR CLDAPInstanceProvider :: SUPPORTEDSASLMECHANISMS_STR					= NULL;



//***************************************************************************
//
// CLDAPInstanceProvider::CLDAPInstanceProvider
// CLDAPInstanceProvider::~CLDAPInstanceProvider
//
// Constructor Parameters:
//
//
//***************************************************************************

CLDAPInstanceProvider :: CLDAPInstanceProvider ()
{
	InterlockedIncrement(&g_lComponents);

	// Initialize the search preferences often used
	m_pSearchInfo[0].dwSearchPref		= ADS_SEARCHPREF_SEARCH_SCOPE;
	m_pSearchInfo[0].vValue.dwType		= ADSTYPE_INTEGER;
	m_pSearchInfo[0].vValue.Integer		= ADS_SCOPE_SUBTREE;

	m_pSearchInfo[1].dwSearchPref		= ADS_SEARCHPREF_PAGESIZE;
	m_pSearchInfo[1].vValue.dwType		= ADSTYPE_INTEGER;
	m_pSearchInfo[1].vValue.Integer		= 1024;

	m_lReferenceCount = 0 ;
	m_IWbemServices = NULL;
	m_pWbemUin8ArrayClass = NULL;
	m_pWbemDNWithBinaryClass = NULL;
	m_pWbemDNWithStringClass = NULL;
	m_pAssociationsClass = NULL;
	m_lpszTopLevelContainerPath = NULL;
	m_bInitializedSuccessfully = FALSE;

	if(g_pLogObject)
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: CONSTRUCTOR\r\n");
}

CLDAPInstanceProvider::~CLDAPInstanceProvider ()
{
	if(g_pLogObject)
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: DESCTRUVTOR\r\n");

	InterlockedDecrement(&g_lComponents);

	delete [] m_lpszTopLevelContainerPath;
	if(m_IWbemServices)
		m_IWbemServices->Release();
	if(m_pWbemUin8ArrayClass)
		m_pWbemUin8ArrayClass->Release();
	if(m_pWbemDNWithBinaryClass)
		m_pWbemDNWithBinaryClass->Release();
	if(m_pWbemDNWithStringClass)
		m_pWbemDNWithStringClass->Release();
	if(m_pAssociationsClass)
		m_pAssociationsClass->Release();
}

//***************************************************************************
//
// CLDAPInstanceProvider::QueryInterface
// CLDAPInstanceProvider::AddRef
// CLDAPInstanceProvider::Release
//
// Purpose: Standard COM routines needed for all COM objects
//
//***************************************************************************

STDMETHODIMP CLDAPInstanceProvider :: QueryInterface (

	REFIID iid ,
	LPVOID FAR *iplpv
)
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) (IUnknown *)(IWbemProviderInit *)this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) (IWbemServices *)this ;
	}
	else if ( iid == IID_IWbemProviderInit )
	{
		*iplpv = ( LPVOID ) (IWbemProviderInit *)this ;
	}
	else
	{
		return E_NOINTERFACE;
	}

	( ( LPUNKNOWN ) *iplpv )->AddRef () ;
	return  S_OK;
}


STDMETHODIMP_( ULONG ) CLDAPInstanceProvider :: AddRef ()
{
	return InterlockedIncrement ( & m_lReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CLDAPInstanceProvider :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_lReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}


HRESULT CLDAPInstanceProvider :: Initialize(
        LPWSTR wszUser,
        LONG lFlags,
        LPWSTR wszNamespace,
        LPWSTR wszLocale,
        IWbemServices __RPC_FAR *pNamespace,
        IWbemContext __RPC_FAR *pCtx,
        IWbemProviderInitSink __RPC_FAR *pInitSink)
{
	// Validate the arguments
	if(pNamespace == NULL || lFlags != 0)
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: Argument validation FAILED\r\n");
		pInitSink->SetStatus(WBEM_E_FAILED, 0);
		return WBEM_S_NO_ERROR;
	}

	// Store the IWbemServices pointer for future use
	m_IWbemServices = pNamespace;
	m_IWbemServices->AddRef();

	// Get the DefaultNamingContext to get at the top level container
	// Get the ADSI path of the schema container and store it for future use
	IADs *pRootDSE = NULL;
	HRESULT result;

	if(SUCCEEDED(result = ADsOpenObject((LPWSTR)ROOT_DSE_PATH, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IADs, (LPVOID *) &pRootDSE)))
	{
		// Get the location of the schema container
		BSTR strDefaultNamingContext = SysAllocString((LPWSTR) DEFAULT_NAMING_CONTEXT_ATTR);

		// Get the DEFAULT_NAMING_CONTEXT property. This property contains the ADSI path
		// of the top level container
		VARIANT variant;
		VariantInit(&variant);
		if(SUCCEEDED(result = pRootDSE->Get(strDefaultNamingContext, &variant)))
		{
			g_pLogObject->WriteW( L"CLDAPInstanceProvider :: Got Top Level Container as : %s\r\n", variant.bstrVal);

			// Form the top level container path
			m_lpszTopLevelContainerPath = new WCHAR[wcslen(LDAP_PREFIX) + wcslen(variant.bstrVal) + 1];
			wcscpy(m_lpszTopLevelContainerPath, LDAP_PREFIX);
			wcscat(m_lpszTopLevelContainerPath, variant.bstrVal);
			// Get the Uint8Array Class
			if(SUCCEEDED(result = m_IWbemServices->GetObject(UINT8ARRAY_STR, 0, pCtx, &m_pWbemUin8ArrayClass, NULL)))
			{
				// Get the DNWIthBinary Class
				if(SUCCEEDED(result = m_IWbemServices->GetObject(DN_WITH_BINARY_CLASS_STR, 0, pCtx, &m_pWbemDNWithBinaryClass, NULL)))
				{
					// Get the DNWIthBinary Class
					if(SUCCEEDED(result = m_IWbemServices->GetObject(DN_WITH_STRING_CLASS_STR, 0, pCtx, &m_pWbemDNWithStringClass, NULL)))
					{
						// Get the Associations Class
						if(SUCCEEDED(result = m_IWbemServices->GetObject(INSTANCE_ASSOCIATION_CLASS_STR, 0, pCtx, &m_pAssociationsClass, NULL)))
						{
						}
						else
						{
							g_pLogObject->WriteW( L"CLDAPInstanceProvider :: FAILED to get Instance Associations class %x\r\n", result);
						}
					}
					else
					{
						g_pLogObject->WriteW( L"CLDAPInstanceProvider :: FAILED to get DNWithString class %x\r\n", result);
					}
				}
				else
				{
					g_pLogObject->WriteW( L"CLDAPInstanceProvider :: FAILED to get DNWithBinary class %x\r\n", result);
				}
			}
			else
			{
				g_pLogObject->WriteW( L"CLDAPInstanceProvider :: FAILED to get Uint8Array class %x\r\n", result);
			}
			VariantClear(&variant);
		}
		SysFreeString(strDefaultNamingContext);
		pRootDSE->Release();
	}

	if(SUCCEEDED(result))
	{
		m_bInitializedSuccessfully = TRUE;
		pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
	}
	else
	{
		m_bInitializedSuccessfully = FALSE;
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: Initialize() FAILED \r\n");
		pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
	}

	return WBEM_S_NO_ERROR;
}

HRESULT CLDAPInstanceProvider :: OpenNamespace(
    /* [in] */ const BSTR strNamespace,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: CancelAsyncCall(
    /* [in] */ IWbemObjectSink __RPC_FAR *pSink)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: QueryObjectSink(
    /* [in] */ long lFlags,
    /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: GetObject(
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: GetObjectAsync(
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	if(!m_bInitializedSuccessfully)
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: Initialization status is FAILED, hence returning failure\n");
		return WBEM_E_FAILED;
	}

	g_pLogObject->WriteW( L"CLDAPInstanceProvider :: GetObjectAsync() called for %s \r\n", strObjectPath);

	HRESULT result = S_OK;
	// Impersonate the client
	if(!SUCCEEDED(result = WbemCoImpersonateClient()))
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: GetObjectAsync() CoImpersonate FAILED for %s with %x\r\n", strObjectPath, result);
		return WBEM_E_FAILED;
	}

	// Validate the arguments
	if(strObjectPath == NULL)
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: GetObjectAsync() argument validation FAILED\r\n");
		return WBEM_E_INVALID_PARAMETER;
	}

	// Parse the object path
	CObjectPathParser theParser;
	ParsedObjectPath *theParsedObjectPath = NULL;
	switch(theParser.Parse(strObjectPath, &theParsedObjectPath))
	{
		case CObjectPathParser::NoError:
			break;
		default:
			g_pLogObject->WriteW( L"CLDAPInstanceProvider :: GetObjectAsync() object path parsing FAILED\r\n");
			return WBEM_E_INVALID_PARAMETER;
	}

	try
	{
		// Check if this is for associations
		if(_wcsicmp(theParsedObjectPath->m_pClass, INSTANCE_ASSOCIATION_CLASS_STR) == 0)
		{
			// Check whether there are exactly 2 keys specified
			if(theParsedObjectPath->m_dwNumKeys != 2)
				result = WBEM_E_INVALID_PARAMETER;

			// Check whether these keys are
			KeyRef *pChildKeyRef = *(theParsedObjectPath->m_paKeys);
			KeyRef *pParentKeyRef = *(theParsedObjectPath->m_paKeys + 1);

			if(_wcsicmp(pChildKeyRef->m_pName, CHILD_INSTANCE_PROPERTY_STR) != 0)
			{
				// Exchange them
				KeyRef *temp = pChildKeyRef;
				pChildKeyRef = pParentKeyRef;
				pParentKeyRef = pChildKeyRef;
			}

			// The status on the sink
			IWbemClassObject *ppReturnWbemClassObjects[1];
			ppReturnWbemClassObjects[0] = NULL;

			if(SUCCEEDED(result))
			{
				// Convert the key values to ADSI paths
				LPWSTR pszChildADSIPath = NULL;
				LPWSTR pszParentADSIPath = NULL;

				try
				{
					pszChildADSIPath = CWBEMHelper::GetADSIPathFromObjectPath(pChildKeyRef->m_vValue.bstrVal);
					pszParentADSIPath = CWBEMHelper::GetADSIPathFromObjectPath(pParentKeyRef->m_vValue.bstrVal);

					if(SUCCEEDED(result = IsContainedIn(pszChildADSIPath, pszParentADSIPath)))
					{
						if(result == S_OK)
						{
							if(SUCCEEDED(result = CreateWBEMInstance(pChildKeyRef->m_vValue.bstrVal, pParentKeyRef->m_vValue.bstrVal, ppReturnWbemClassObjects)))
							{
								result = pResponseHandler->Indicate(1, ppReturnWbemClassObjects);
								ppReturnWbemClassObjects[0]->Release();
							}
						}
						else // the instance was not found
						{
							g_pLogObject->WriteW( L"CLDAPInstanceProvider :: returning WBEM_E_NOT_FOUND for %s \r\n", strObjectPath);
							result = WBEM_E_NOT_FOUND;
						}
					}
					else
					{
						g_pLogObject->WriteW( L"CLDAPInstanceProvider :: IsContainedIn() FAILED with %x \r\n", result);
					}
				}
				catch ( ... )
				{
					if ( pszChildADSIPath )
					{
						delete [] pszChildADSIPath;
						pszChildADSIPath = NULL;
					}

					if ( pszParentADSIPath )
					{
						delete [] pszParentADSIPath;
						pszParentADSIPath = NULL;
					}

					throw;
				}

				if ( pszChildADSIPath )
				{
					delete [] pszChildADSIPath;
					pszChildADSIPath = NULL;
				}

				if ( pszParentADSIPath )
				{
					delete [] pszParentADSIPath;
					pszParentADSIPath = NULL;
				}
			}
		}
		// Check if this is for the RootDSE class
		else if(_wcsicmp(theParsedObjectPath->m_pClass, ROOTDSE_CLASS) == 0)
		{
			result = ProcessRootDSEGetObject(theParsedObjectPath->m_pClass, pResponseHandler, pCtx);
		}
		else // It is for ADSI instances
		{
			// Check whether there is exactly 1 key specified
			if(theParsedObjectPath->m_dwNumKeys != 1 )
				result = WBEM_E_INVALID_PARAMETER;

			// Get the key
			KeyRef *pKeyRef = *(theParsedObjectPath->m_paKeys);

			// Check to see that the key name is correct, if it is present
			if(pKeyRef->m_pName && _wcsicmp(pKeyRef->m_pName, ADSI_PATH_STR) != 0)
				result = WBEM_E_INVALID_PARAMETER;

			// The status on the sink
			IWbemClassObject *ppReturnWbemClassObjects[1];
			ppReturnWbemClassObjects[0] = NULL;

			if(SUCCEEDED(result))
			{
				// Get the ADSI object
				CADSIInstance *pADSIObject = NULL;
				if(SUCCEEDED(result = CLDAPHelper::GetADSIInstance(pKeyRef->m_vValue.bstrVal, &pADSIObject, g_pLogObject)))
				{
					try
					{
						// Get the class to spawn an instance
						IWbemClassObject *pWbemClass = NULL;
						if(SUCCEEDED(result = m_IWbemServices->GetObject(theParsedObjectPath->m_pClass, 0, pCtx, &pWbemClass, NULL)))
						{
							try
							{
								// Spawn a instance of the WBEM Class
								if(SUCCEEDED(result = pWbemClass->SpawnInstance(0, ppReturnWbemClassObjects)))
								{
									// Map it to WBEM
									if(SUCCEEDED(result = MapADSIInstance(pADSIObject, ppReturnWbemClassObjects[0], pWbemClass)))
									{
										// Indicate the result
										if(FAILED(result = pResponseHandler->Indicate(1, ppReturnWbemClassObjects)))
										{
											g_pLogObject->WriteW( L"CLDAPInstanceProvider :: GetObjectAsync : Indicate() for %s FAILED with %x \r\n", theParsedObjectPath->m_pClass, result);
										}
									}
									else
									{
										g_pLogObject->WriteW( L"CLDAPInstanceProvider :: GetObjectAsync : MapADSIInstance() for %s FAILED with %x \r\n", theParsedObjectPath->m_pClass, result);
									}
									ppReturnWbemClassObjects[0]->Release();
								}
								else
								{
									g_pLogObject->WriteW( L"CLDAPInstanceProvider :: SpawnInstance() for %s FAILED with %x \r\n", theParsedObjectPath->m_pClass, result);
								}
							}
							catch ( ... )
							{
								pWbemClass->Release();
								pWbemClass = NULL;

								throw;
							}

							pWbemClass->Release();
						}
						else
						{
							g_pLogObject->WriteW( L"CLDAPInstanceProvider :: GetObjectAsync() GetObject() for %s FAILED with %x \r\n", theParsedObjectPath->m_pClass, result);
						}
					}
					catch ( ... )
					{
						pADSIObject->Release();
						pADSIObject = NULL;

						throw;
					}

					pADSIObject->Release();
				}
				else
				{
					g_pLogObject->WriteW( L"CLDAPInstanceProvider :: GetObjectAsync : GetADSIInstance() FAILED with %x \r\n", result);
				}
			}
			else
			{
				g_pLogObject->WriteW( L"CLDAPInstanceProvider :: GetObjectAsync() Argument processing FAILED \r\n");
			}
		}
	}
	catch ( ... )
	{
		theParser.Free(theParsedObjectPath);
		throw;
	}

	// Free the parser object path
	theParser.Free(theParsedObjectPath);

	// Set the status of the request
	result = (SUCCEEDED(result)? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND);
	pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, result, NULL, NULL);

	if(SUCCEEDED(result))
		g_pLogObject->WriteW( L"XXXXXXXXXXXXXXXXX CLDAPInstanceProvider :: GetObjectAsync() succeeded for %s\r\n", strObjectPath);
	else
		g_pLogObject->WriteW( L"XXXXXXXXXXXXXXXXX CLDAPInstanceProvider :: GetObjectAsync() FAILED for %s\r\n", strObjectPath);
	return WBEM_S_NO_ERROR;
}

HRESULT CLDAPInstanceProvider :: PutClass(
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: PutClassAsync(
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: DeleteClass(
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: DeleteClassAsync(
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: CreateClassEnum(
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: CreateClassEnumAsync(
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: PutInstance(
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	g_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstance() called\r\n");
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: PutInstanceAsync(
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	if(!m_bInitializedSuccessfully)
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: Initialization status is FAILED, hence returning failure\n");
		return WBEM_E_FAILED;
	}

	g_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstanceAsync() called\r\n");

	HRESULT result = WBEM_S_NO_ERROR;
	// Impersonate the client
	if(!SUCCEEDED(result = WbemCoImpersonateClient()))
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstanceAsync() CoImpersonate FAILED forwith %x\r\n", result);
		return WBEM_E_FAILED;
	}

	// Get the object ref of the instance being put
	BSTR strRelPath = NULL;
	if(SUCCEEDED(CWBEMHelper::GetBSTRProperty(pInst, RELPATH_STR, &strRelPath)))
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstanceAsync()  calledfor %s\r\n", strRelPath);
		// Check to see if the ADSI Path is present.
		// Parse the object path
		// Parse the object path
		CObjectPathParser theParser;
		ParsedObjectPath *theParsedObjectPath = NULL;
		LPWSTR pszADSIPath = NULL;
		LPWSTR pszWBEMClass = NULL;
		LPWSTR pszADSIClass = NULL;

		try
		{
			switch(theParser.Parse((LPWSTR)strRelPath, &theParsedObjectPath))
			{
				case CObjectPathParser::NoError:
				{
					KeyRef *pKeyRef = *(theParsedObjectPath->m_paKeys);
					// Check to see that there is 1 key specified and that its type is VT_BSTR
					if(pKeyRef && theParsedObjectPath->m_dwNumKeys == 1 && pKeyRef->m_vValue.vt == VT_BSTR)
					{
						try
						{
							// If the name of the key is specified, check the name
							if(pKeyRef->m_pName && _wcsicmp(pKeyRef->m_pName, ADSI_PATH_STR) != 0)
								break;

							pszADSIPath = new WCHAR[wcslen((*theParsedObjectPath->m_paKeys)->m_vValue.bstrVal) + 1];
							wcscpy(pszADSIPath, (*theParsedObjectPath->m_paKeys)->m_vValue.bstrVal);
							pszWBEMClass = new WCHAR[wcslen(theParsedObjectPath->m_pClass) + 1];
							wcscpy(pszWBEMClass, theParsedObjectPath->m_pClass);
						}
						catch ( ... )
						{
							theParser.Free(theParsedObjectPath);
							throw;
						}
					}
					break;
				}
				default:
					g_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstanceAsync() Parsing of RELPATH FAILED\r\n");
					SysFreeString(strRelPath);
					return WBEM_E_FAILED;
					break;
			}

			try
			{
				if(pszWBEMClass)
				{
					// CHeck to see if the class is the containment/RootDSE class, if so disallow the operation
					if(_wcsicmp(theParsedObjectPath->m_pClass, INSTANCE_ASSOCIATION_CLASS_STR) == 0 ||
						_wcsicmp(theParsedObjectPath->m_pClass, ROOTDSE_CLASS) == 0 )
					{
						result =  WBEM_E_PROVIDER_NOT_CAPABLE;
					}
					else
						pszADSIClass = CLDAPHelper::UnmangleWBEMNameToLDAP(pszWBEMClass);
				}
			}
			catch ( ... )
			{
				theParser.Free(theParsedObjectPath);
				throw;
			}

			// Free the parser object path
			theParser.Free(theParsedObjectPath);

			if ( strRelPath )
			{
				SysFreeString(strRelPath);
				strRelPath = NULL;
			}

			if ( pszWBEMClass )
			{
				delete [] pszWBEMClass;
				pszWBEMClass = NULL;
			}

			if(pszADSIPath && pszADSIClass && SUCCEEDED(result))
			{
				// Try to retreive the existing object
				// Get the ADSI object
				CADSIInstance *pADSIObject = NULL;
				result = CLDAPHelper::GetADSIInstance(pszADSIPath, &pADSIObject, g_pLogObject);

				try
				{
					// Check if the WBEM_FLAG_UPDATE_ONLY flag is specified
					if(lFlags & WBEM_FLAG_UPDATE_ONLY)
					{
						if(!pADSIObject)
							result = WBEM_E_FAILED;
					}
					// Check if the WBEM_FLAG_CREATE_ONLY flag is specified
					if(SUCCEEDED(result) && lFlags & WBEM_FLAG_CREATE_ONLY)
					{
						if(pADSIObject)
							result = WBEM_E_ALREADY_EXISTS;
					}
					else
						result = WBEM_S_NO_ERROR;

					if(SUCCEEDED(result))
					{
						if(pADSIObject)
						{
							if(SUCCEEDED(result = ModifyExistingADSIInstance(pInst, pszADSIPath, pADSIObject, pszADSIClass, pCtx)))
								g_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstanceAsync()  ModifyExistingInstance succeeded for %s\r\n", pszADSIPath);
							else
								g_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstanceAsync() ModifyExistingInstance FAILED for %s with %x\r\n", pszADSIPath, result);
						}
						else
						{
							if(SUCCEEDED(result = CreateNewADSIInstance(pInst, pszADSIPath, pszADSIClass)))
								g_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstanceAsync() CreateNewInstance succeeded for %s\r\n", pszADSIPath);
							else
								g_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstanceAsync() CreateNewInstance FAILED for %s with %x\r\n", pszADSIPath, result);
						}
					}
				}
				catch ( ... )
				{
					// Release any existing object
					if(pADSIObject)
					{
						pADSIObject->Release();
						pADSIObject = NULL;
					}

					throw;
				}

				// Release any existing object
				if(pADSIObject)
					pADSIObject->Release();
			}
			else
				g_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstanceAsync() one of ADSIPath or ADSIClass is NULL\r\n");
		}
		catch ( ... )
		{
			if ( strRelPath )
			{
				SysFreeString(strRelPath);
				strRelPath = NULL;
			}

			if ( pszWBEMClass )
			{
				delete [] pszWBEMClass;
				pszWBEMClass = NULL;
			}

			if ( pszADSIClass )
			{
				delete [] pszADSIClass;
				pszADSIClass = NULL;
			}

			if ( pszADSIPath )
			{
				delete [] pszADSIPath;
				pszADSIPath = NULL;
			}

			throw;
		}

		delete [] pszADSIClass;
		delete [] pszADSIPath;
	}
	else
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstanceAsync()  FAILED to get RELPATH \r\n");

	// Set the status of the request
	result = (SUCCEEDED(result)? WBEM_S_NO_ERROR : WBEM_E_FAILED);
	pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, result, NULL, NULL);
	return result;
}

HRESULT CLDAPInstanceProvider :: DeleteInstance(
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: DeleteInstanceAsync(
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	if(!m_bInitializedSuccessfully)
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: Initialization status is FAILED, hence returning failure\n");
		return WBEM_E_FAILED;
	}

	g_pLogObject->WriteW( L"CLDAPInstanceProvider :: DeleteInstanceAsync() called for %s\r\n", strObjectPath);

	HRESULT result = S_OK;
	// Impersonate the client
	if(!SUCCEEDED(result = WbemCoImpersonateClient()))
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: DeleteInstanceAsync() CoImpersonate FAILED for %s with %x\r\n", strObjectPath, result);
		return WBEM_E_FAILED;
	}

	// Validate the arguments
	if(strObjectPath == NULL)
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: DeleteInstanceAsync() argument validation FAILED\r\n");
		return WBEM_E_INVALID_PARAMETER;
	}

	// Parse the object path
	CObjectPathParser theParser;
	ParsedObjectPath *theParsedObjectPath = NULL;
	switch(theParser.Parse(strObjectPath, &theParsedObjectPath))
	{
		case CObjectPathParser::NoError:
			break;
		default:
			g_pLogObject->WriteW( L"CLDAPInstanceProvider :: DeleteInstanceAsync() object path parsing FAILED\r\n");
			return WBEM_E_INVALID_PARAMETER;
	}

	// CHeck to see if the class is the containment/RootDSE class, if so disallow the operation
	if(_wcsicmp(theParsedObjectPath->m_pClass, INSTANCE_ASSOCIATION_CLASS_STR) == 0 ||
		_wcsicmp(theParsedObjectPath->m_pClass, ROOTDSE_CLASS) == 0 )
	{
		result =  WBEM_E_PROVIDER_NOT_CAPABLE;
	}

	// Check whether there is exactly 1 key specified
	if(theParsedObjectPath->m_dwNumKeys != 1 )
		result = WBEM_E_INVALID_PARAMETER;

	// Get the key
	KeyRef *pKeyRef = *(theParsedObjectPath->m_paKeys);

	// Check to see that the key name is correct, if it is present
	if(pKeyRef->m_pName && _wcsicmp(pKeyRef->m_pName, ADSI_PATH_STR) != 0)
		result = WBEM_E_INVALID_PARAMETER;

	// Unfortunately, ADSI uses different interfaces to delete containers and non-containers
	// Try the containers first (IADsDeleteOps)
	// Then try the IDirectoryObject
	//=======================================================================================
	if(SUCCEEDED(result))
	{
		IADsDeleteOps *pDirectoryObject = NULL;
		if(SUCCEEDED(result = ADsOpenObject(pKeyRef->m_vValue.bstrVal, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IADsDeleteOps, (LPVOID *)&pDirectoryObject)))
		{
			if(SUCCEEDED(result = pDirectoryObject->DeleteObject(0)))
			{
			}
			else
				result = WBEM_E_FAILED;
			pDirectoryObject->Release();
		}
		else // Try the IDirectoryObject interface
		{
			IDirectoryObject *pDirectoryObject = NULL;
			if(SUCCEEDED(result = ADsOpenObject(pKeyRef->m_vValue.bstrVal, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectoryObject, (LPVOID *)&pDirectoryObject)))
			{
				PADS_OBJECT_INFO pObjectInfo = NULL;
				if(SUCCEEDED(result = pDirectoryObject->GetObjectInformation(&pObjectInfo)))
				{
					// CHeck whether it is the same class as the class being deleted.
					LPWSTR pszWbemClass = CLDAPHelper::MangleLDAPNameToWBEM(pObjectInfo->pszClassName);
					if(_wcsicmp(theParsedObjectPath->m_pClass, pszWbemClass) == 0)
					{
						// Get its parent. THis should be the container from which the child is deleted
						IDirectoryObject *pParent = NULL;
						if(SUCCEEDED(result = ADsOpenObject(pObjectInfo->pszParentDN, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectoryObject, (LPVOID *)&pParent)))
						{
							if(SUCCEEDED(result = pParent->DeleteDSObject(pObjectInfo->pszRDN)))
							{
								g_pLogObject->WriteW( L"CLDAPInstanceProvider :: DeleteInstanceAsync() Deleted %s successfully\r\n", pKeyRef->m_vValue.bstrVal);
								result = WBEM_S_NO_ERROR;
							}
							else
							{
								g_pLogObject->WriteW( L"CLDAPInstanceProvider :: DeleteInstanceAsync() DeleteDSObject FAILED on %s with %x\r\n", pKeyRef->m_vValue.bstrVal, result);
								result = WBEM_E_FAILED;
							}
							pParent->Release();
						}
						else
						{
							g_pLogObject->WriteW( L"CLDAPInstanceProvider :: DeleteInstanceAsync() ADsOpenObject on parent FAILED on %s with %x\r\n", pKeyRef->m_vValue.bstrVal, result);
							result = WBEM_E_FAILED;
						}
					}
					else
					{
						g_pLogObject->WriteW( L"CLDAPInstanceProvider :: DeleteInstanceAsync() wrong class returning success\r\n");
						result = WBEM_S_NO_ERROR;
					}

					delete [] pszWbemClass;
					FreeADsMem((LPVOID *) pObjectInfo);
				}
				else
				{
					g_pLogObject->WriteW( L"CLDAPInstanceProvider :: DeleteInstanceAsync() GetObjectInformation FAILED on %s with %x\r\n", pKeyRef->m_vValue.bstrVal, result);
					result = WBEM_E_NOT_FOUND;
				}
				pDirectoryObject->Release();
			}
			else
			{
				g_pLogObject->WriteW( L"CLDAPInstanceProvider :: DeleteInstanceAsync() ADsOpenObject FAILED on %s with %x\r\n", pKeyRef->m_vValue.bstrVal, result);
				result = WBEM_E_NOT_FOUND;
			}
		}
	}
	// Free the parser object path
	theParser.Free(theParsedObjectPath);

	pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE , result, NULL, NULL);

	return WBEM_S_NO_ERROR;
}

HRESULT CLDAPInstanceProvider :: CreateInstanceEnum(
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: CreateInstanceEnumAsync(
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	if(!m_bInitializedSuccessfully)
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: Initialization status is FAILED, hence returning failure\n");
		return WBEM_E_FAILED;
	}
	g_pLogObject->WriteW( L"CLDAPInstanceProvider :: CreateInstanceEnumAsync() called for %s Class \r\n", strClass  );

	HRESULT result;
	// Impersonate the client
	if(!SUCCEEDED(result = WbemCoImpersonateClient()))
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: CreateInstanceEnumAsync() CoImpersonate FAILED for %s with %x\r\n", strClass, result);
		return WBEM_E_FAILED;
	}

	// CHeck to see if the class is the containment class, if so disallow an enumeration
	if(_wcsicmp(strClass, INSTANCE_ASSOCIATION_CLASS_STR) == 0)
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: CLDAPInstanceProvider() Enumeration called on the containment class. Returning FAILED : WBEM_E_PROVIDER_NOT_CAPABLE\r\n");
		return WBEM_E_PROVIDER_NOT_CAPABLE;
	}
	// Check if this is for the RootDSE class
	else if(_wcsicmp(strClass, ROOTDSE_CLASS) == 0)
	{
		result = ProcessRootDSEGetObject(strClass, pResponseHandler, pCtx);
	}
	else // The rest of the classes
	{

		// Fetch the class from CIMOM
		IWbemClassObject *pWbemClass = NULL;
		if(SUCCEEDED(result = m_IWbemServices->GetObject(strClass, 0, pCtx, &pWbemClass, NULL)))
		{
			// We need the object category information
			LPWSTR pszLDAPQuery = new WCHAR[10*(wcslen(strClass) + 25) + 50];
			if(SUCCEEDED(CWBEMHelper::FormulateInstanceQuery(m_IWbemServices, pCtx, strClass, pWbemClass, pszLDAPQuery, LDAP_DISPLAY_NAME_STR, DEFAULT_OBJECT_CATEGORY_STR)))
			{
		
				// Check to see if the client has specified any hints as to the DN of the object from
				// which the search should start
				BOOLEAN bRootDNSpecified = FALSE;
				LPWSTR *ppszRootDN = NULL;
				DWORD dwRootDNCount = 0;
				if(SUCCEEDED(GetRootDN(strClass, &ppszRootDN, &dwRootDNCount, pCtx)) && dwRootDNCount)
					bRootDNSpecified = TRUE;

				// Enumerate the ADSI Instances
				// If any RootDNs were specified, use them. Otherwise use the default naming context

				if(bRootDNSpecified)
				{
					for( DWORD i=0; i<dwRootDNCount; i++)
					{
						DoSingleQuery(strClass, pWbemClass, ppszRootDN[i], pszLDAPQuery,  pResponseHandler);
					}
				}
				else
				{
					DoSingleQuery(strClass, pWbemClass, m_lpszTopLevelContainerPath, pszLDAPQuery,  pResponseHandler);
				}

				if(bRootDNSpecified)
				{
					for(DWORD i=0; i<dwRootDNCount; i++)
					{
						delete [] ppszRootDN[i];
					}
					delete [] ppszRootDN;
				}

			}
			else
				g_pLogObject->WriteW( L"CLDAPInstanceProvider :: CreateInstanceEnumAsync : FormulateInstanceQuery() FAILED for %s with %x \r\n", strClass, result);
			delete [] pszLDAPQuery;
			pWbemClass->Release();
		}
		else
			g_pLogObject->WriteW( L"CLDAPInstanceProvider :: CreateInstanceEnumAsync : GetObject() FAILED for %s with %x \r\n", strClass, result);
	}

	if(SUCCEEDED(result))
	{
		pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_S_NO_ERROR, NULL, NULL);
		g_pLogObject->WriteW( L"XXXXXXXXXXXXX CLDAPInstanceProvider :: CreateInstanceEnumAsync() Enumeration succeeded for %s\r\n", strClass);
		return WBEM_S_NO_ERROR;
	}
	else
	{
		pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_E_FAILED, NULL, NULL);
		g_pLogObject->WriteW( L"XXXXXXXXXXXXX CLDAPInstanceProvider :: CreateInstanceEnumAsync() Enumeration FAILED for %s\r\n", strClass);
		return WBEM_S_NO_ERROR;
	}
}

HRESULT CLDAPInstanceProvider :: ExecQuery(
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: ExecQueryAsync(
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	if(!m_bInitializedSuccessfully)
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: Initialization status is FAILED, hence returning failure\n");
		return WBEM_E_FAILED;
	}

	g_pLogObject->WriteW( L"CLDAPInstanceProvider :: ExecQueryAsync() called with %s\r\n", strQuery);

	HRESULT result;
	// Impersonate the client
	if(!SUCCEEDED(result = WbemCoImpersonateClient()))
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: ExecQueryAsync() CoImpersonate FAILED for %s with %x\r\n", strQuery, result);
		return WBEM_E_FAILED;
	}

	// Create Parser for the Query.
    CTextLexSource src(strQuery);
    SQL1_Parser parser(&src);

    // Get the class name
    wchar_t classbuf[128];
    *classbuf = 0;
    parser.GetQueryClass(classbuf, 127);

	// Compare to see if it is the association class, Otherwise do an enuemration
	if(_wcsicmp(classbuf, INSTANCE_ASSOCIATION_CLASS_STR) != 0)
	{
		BSTR strClass = SysAllocString((LPWSTR)classbuf);

		// Ask CIMOM to postprocess the result
		pResponseHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, WBEM_S_NO_ERROR, NULL, NULL);

		// Try to process the query myself. If not successful, enumerate
		if(SUCCEEDED(result = ProcessInstanceQuery(strClass, strQuery, pCtx, pResponseHandler, &parser)))
		{
			pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_S_NO_ERROR, NULL, NULL);
		}
		else
		{
			g_pLogObject->WriteW( L"CLDAPInstanceProvider :: ExecQueryAsync() FAILED to process query %s. Resorting to enumeration\r\n", strQuery);
			CreateInstanceEnumAsync(strClass, 0, pCtx, pResponseHandler);
		}

		SysFreeString(strClass);
	}
	else
	{
		// Process query for associations
		result = ProcessAssociationQuery(pCtx, pResponseHandler, &parser);
	}

	return WBEM_S_NO_ERROR;
}

HRESULT CLDAPInstanceProvider :: ExecNotificationQuery(
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: ExecNotificationQueryAsync(
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: ExecMethod(
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: ExecMethodAsync(
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}


// Maps an ADSI Instance to WBEM
HRESULT CLDAPInstanceProvider :: MapADSIInstance(CADSIInstance *pADSIObject, IWbemClassObject *pWbemObject, IWbemClassObject *pWbemClass)
{
	DWORD dwNumAttributes = 0;
	PADS_ATTR_INFO pAttributeEntries = pADSIObject->GetAttributes(&dwNumAttributes);
	HRESULT result;
	for(DWORD i=0; i<dwNumAttributes; i++)
	{
		PADS_ATTR_INFO pNextAttribute = pAttributeEntries+i;

		// Get the WBEM Property Name
		LPWSTR pszWbemName = CLDAPHelper::MangleLDAPNameToWBEM(pNextAttribute->pszAttrName);
		BSTR strWbemName = SysAllocString(pszWbemName);
		delete[] pszWbemName;

		// No point in checking the return code, except for logging
		if(SUCCEEDED(result = MapPropertyValueToWBEM(strWbemName, pWbemClass, pWbemObject, pNextAttribute)))
		{
		}
		else if( result != WBEM_E_NOT_FOUND )
		{
			g_pLogObject->WriteW( L"CLDAPInstanceProvider :: MapADSIInstance() MapPropertyValueToWBEM FAILED with %x for attribute %s\r\n", result, strWbemName);
		}
		SysFreeString(strWbemName);
	}

	// Map the key property and other properties of the base-most class
	PADS_OBJECT_INFO pObjectInfo = pADSIObject->GetObjectInfo();
	if(!SUCCEEDED(result = CWBEMHelper::PutBSTRPropertyT(pWbemObject, ADSI_PATH_STR, pObjectInfo->pszObjectDN, FALSE)))
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: MapADSIInstance() Put FAILED for Key Property  with %x\r\n", result);

	return S_OK;
}

// Gets the IDIrectoryObject interface on an ADSI instance
HRESULT CLDAPInstanceProvider :: MapPropertyValueToWBEM(BSTR strWbemName, IWbemClassObject *pWbemClass, IWbemClassObject *pWbemObject, PADS_ATTR_INFO pAttribute)
{
	// This happens in WMI Stress sometimes.
	if(pAttribute->dwADsType == ADSTYPE_INVALID || pAttribute->dwADsType == ADSTYPE_PROV_SPECIFIC)
		return E_FAIL;

	VARIANT variant;
	VariantInit(&variant);
	CIMTYPE cimType;

	// Get the CIM TYPE of the property
	VARIANT dummyUnused;
	VariantInit(&dummyUnused);

	HRESULT result = pWbemClass->Get(strWbemName, 0, &dummyUnused, &cimType, NULL);

	VariantClear(&dummyUnused);

	// Whether the value was mapped successfully;
	BOOLEAN bMappedValue = FALSE;

	if(SUCCEEDED(result))
	{
		if(cimType & CIM_FLAG_ARRAY)
		{
			switch(cimType & ~CIM_FLAG_ARRAY)
			{
				case CIM_BOOLEAN:
				{
					// Create the safe array elements
					SAFEARRAY *safeArray;
					DWORD dwLength = pAttribute->dwNumValues;
					SAFEARRAYBOUND safeArrayBounds [ 1 ];
					safeArrayBounds[0].lLbound = 0;
					safeArrayBounds[0].cElements = dwLength;
					safeArray = SafeArrayCreate(VT_BOOL, 1, safeArrayBounds);
					PADSVALUE pNextValue = pAttribute->pADsValues;
					for ( long index = 0; index<(long)dwLength; index ++ )
					{
						if(FAILED(result = SafeArrayPutElement ( safeArray , &index ,  &(pNextValue->Boolean))))
							break;
						pNextValue ++;
					}
					if(SUCCEEDED(result))
					{
						variant.vt = VT_ARRAY | VT_BOOL;
						variant.parray = safeArray;
						bMappedValue = TRUE;
					}
					else
						SafeArrayDestroy(safeArray);
					break;
				}
				case CIM_SINT32:
				{
					// Create the safe array elements
					SAFEARRAY *safeArray;
					DWORD dwLength = pAttribute->dwNumValues;
					SAFEARRAYBOUND safeArrayBounds [ 1 ];
					safeArrayBounds[0].lLbound = 0;
					safeArrayBounds[0].cElements = dwLength;
					safeArray = SafeArrayCreate(VT_I4, 1, safeArrayBounds);
					PADSVALUE pNextValue = pAttribute->pADsValues;
					for ( long index = 0; index<(long)dwLength; index ++ )
					{
						if(FAILED(result = SafeArrayPutElement ( safeArray , &index ,  &(pNextValue->Integer))))
							break;
						pNextValue ++;
					}
					if(SUCCEEDED(result))
					{
						variant.vt = VT_ARRAY | VT_I4;
						variant.parray = safeArray;
						bMappedValue = TRUE;
					}
					else
						SafeArrayDestroy(safeArray);

					break;
				}
				case CIM_SINT64:
				{
					// Create the safe array elements
					SAFEARRAY *safeArray;
					DWORD dwLength = pAttribute->dwNumValues;
					SAFEARRAYBOUND safeArrayBounds [ 1 ];
					safeArrayBounds[0].lLbound = 0;
					safeArrayBounds[0].cElements = dwLength;
					safeArray = SafeArrayCreate(VT_BSTR, 1, safeArrayBounds);
					PADSVALUE pNextValue = pAttribute->pADsValues;
					WCHAR temp[20];
					BSTR strTemp = NULL;
					for ( long index = 0; index<(long)dwLength; index ++ )
					{
						swprintf(temp, L"%I64d", (pNextValue->LargeInteger).QuadPart);
						if(FAILED(result = SafeArrayPutElement ( safeArray , &index ,  strTemp = SysAllocString(temp))))
						{
							SysFreeString(strTemp);
							break;
						}
						pNextValue ++;
					}

					if(SUCCEEDED(result))
					{
						variant.vt = VT_ARRAY | VT_BSTR;
						variant.parray = safeArray;
						bMappedValue = TRUE;
					}
					else
						SafeArrayDestroy(safeArray);
					break;
				}
				case CIM_STRING:
				{
					// Create the safe array elements
					SAFEARRAY *safeArray;
					DWORD dwLength = pAttribute->dwNumValues;
					SAFEARRAYBOUND safeArrayBounds [ 1 ];
					safeArrayBounds[0].lLbound = 0;
					safeArrayBounds[0].cElements = dwLength;
					safeArray = SafeArrayCreate(VT_BSTR, 1, safeArrayBounds);
					PADSVALUE pNextValue = pAttribute->pADsValues;
					BSTR strTemp = NULL;
					for ( long index = 0; index<(long)dwLength; index ++ )
					{
						if(FAILED(result = SafeArrayPutElement ( safeArray , &index ,  strTemp = SysAllocString(pNextValue->DNString))))
						{
							SysFreeString(strTemp);
							break;
						}
						pNextValue ++;
					}
					if(SUCCEEDED(result))
					{
						variant.vt = VT_ARRAY | VT_BSTR;
						variant.parray = safeArray;
						bMappedValue = TRUE;
					}
					else
						SafeArrayDestroy(safeArray);
					break;
				}

				case CIM_DATETIME:
				{
					// Create the safe array elements
					SAFEARRAY *safeArray;
					DWORD dwLength = pAttribute->dwNumValues;
					SAFEARRAYBOUND safeArrayBounds [ 1 ];
					safeArrayBounds[0].lLbound = 0;
					safeArrayBounds[0].cElements = dwLength;
					safeArray = SafeArrayCreate(VT_BSTR, 1, safeArrayBounds);
					PADSVALUE pNextValue = pAttribute->pADsValues;
					BSTR strTemp = NULL;
					for ( long index = 0; index<(long)dwLength; index ++ )
					{
						WBEMTime wbemValue(pNextValue->UTCTime);
						if(FAILED(result = SafeArrayPutElement ( safeArray , &index ,  strTemp = wbemValue.GetDMTF(TRUE))))
						{
							SysFreeString(strTemp);
							break;
						}
						pNextValue ++;
					}
					if(SUCCEEDED(result))
					{
						variant.vt = VT_ARRAY | VT_BSTR;
						variant.parray = safeArray;
						bMappedValue = TRUE;
					}
					else
						SafeArrayDestroy(safeArray);

					break;
				}

				case CIM_OBJECT:
				{
					// Get its cimType Qualifier to determine the "type" of the embedded object
					IWbemQualifierSet *pQualifierSet = NULL;
					if(SUCCEEDED(pWbemClass->GetPropertyQualifierSet(strWbemName, &pQualifierSet)))
					{
						LPWSTR pszQualifierValue = NULL;
						if(SUCCEEDED(CWBEMHelper::GetBSTRQualifierT(pQualifierSet, CIMTYPE_STR, &pszQualifierValue, NULL)))
						{

							// Create the safe array elements
							SAFEARRAY *safeArray;
							DWORD dwLength = pAttribute->dwNumValues;
							SAFEARRAYBOUND safeArrayBounds [ 1 ];
							safeArrayBounds[0].lLbound = 0;
							safeArrayBounds[0].cElements = dwLength;
							safeArray = SafeArrayCreate(VT_UNKNOWN, 1, safeArrayBounds);
							PADSVALUE pNextValue = pAttribute->pADsValues;
							IUnknown *pNextObject = NULL;
							for ( long index = 0; index<(long)dwLength; index ++ )
							{
								// Put the Embedded object in the array
								if(SUCCEEDED(MapEmbeddedObjectToWBEM(pNextValue, pszQualifierValue, &pNextObject)))
								{
									if(FAILED(result = SafeArrayPutElement ( safeArray , &index ,  pNextObject)))
									{
										pNextObject->Release();
										break;
									}
									pNextObject = NULL;
								}
								else
									break;

								pNextValue ++;
							}
							if(SUCCEEDED(result))
							{
								variant.vt = VT_ARRAY | VT_UNKNOWN;
								variant.parray = safeArray;
								if(index == (long)dwLength)
									bMappedValue = TRUE;
							}
							else
								SafeArrayDestroy(safeArray);

							delete[] pszQualifierValue;
						}
						pQualifierSet->Release();
					}
					break;
				}
				default:
					break;
			}
		}
		else
		{
			switch(cimType)
			{
			case CIM_BOOLEAN:
				variant.vt = VT_BOOL;
				variant.boolVal = (pAttribute->pADsValues->Boolean)? VARIANT_TRUE : VARIANT_FALSE;
				bMappedValue = TRUE;
				break;

			case CIM_SINT32:
				variant.vt = VT_I4;
				variant.lVal = pAttribute->pADsValues->Integer;
				bMappedValue = TRUE;
				break;

			case CIM_SINT64:
				variant.vt = VT_BSTR;
				WCHAR temp[20];
				swprintf(temp, L"%I64d", (pAttribute->pADsValues->LargeInteger).QuadPart);
				variant.bstrVal = SysAllocString(temp);
				bMappedValue = TRUE;
				break;

			case CIM_STRING:
				variant.vt = VT_BSTR;
				if(pAttribute->pADsValues->DNString)
				{
					variant.bstrVal = SysAllocString(pAttribute->pADsValues->DNString);
					bMappedValue = TRUE;
				}
				break;

			case CIM_OBJECT:
			{
				// Get its cimType Qualifier to determine the "type" of the embedded object
				IWbemQualifierSet *pQualifierSet = NULL;
				if(SUCCEEDED(pWbemClass->GetPropertyQualifierSet(strWbemName, &pQualifierSet)))
				{
					LPWSTR pszQualifierValue = NULL;
					if(SUCCEEDED(CWBEMHelper::GetBSTRQualifierT(pQualifierSet, CIMTYPE_STR, &pszQualifierValue, NULL)))
					{
						IUnknown *pEmbeddedObject = NULL;
						if(SUCCEEDED(MapEmbeddedObjectToWBEM(pAttribute->pADsValues, pszQualifierValue, &pEmbeddedObject)))
						{
							variant.vt = VT_UNKNOWN;
							variant.punkVal = pEmbeddedObject;
							bMappedValue = TRUE;
						}

						delete[] pszQualifierValue;
					}
					pQualifierSet->Release();
				}

			}
			break;

			case CIM_DATETIME:
			{
				variant.vt = VT_BSTR;
				WBEMTime wbemValue(pAttribute->pADsValues->UTCTime);
				if(variant.bstrVal = wbemValue.GetDMTF(TRUE))
					bMappedValue = TRUE;
			}
			break;

			default:
				break;
			}
		}
	}


	if(bMappedValue && FAILED(result = pWbemObject->Put(strWbemName, 0, &variant, NULL)))
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: MapADSIInstance() Put FAILED for %s with %x\r\n", strWbemName, result);

	VariantClear(&variant);
	return result;
}

HRESULT CLDAPInstanceProvider :: MapEmbeddedObjectToWBEM(PADSVALUE pAttribute, LPCWSTR pszQualifierName, IUnknown **ppEmbeddedObject)
{
	HRESULT result = WBEM_E_FAILED;

	// Skip the "object:" prefix while comparing
	//===========================================
	if (_wcsicmp(pszQualifierName+7, UINT8ARRAY_STR) == 0)
		result = MapUint8ArrayToWBEM(pAttribute, ppEmbeddedObject);
	else if(_wcsicmp(pszQualifierName+7, DN_WITH_BINARY_CLASS_STR) == 0)
		result = MapDNWithBinaryToWBEM(pAttribute, ppEmbeddedObject);
	else if (_wcsicmp(pszQualifierName+7, DN_WITH_STRING_CLASS_STR) == 0)
		result = MapDNWithStringToWBEM(pAttribute, ppEmbeddedObject);
	else
		result = E_FAIL;
	return result;
}

HRESULT CLDAPInstanceProvider :: MapUint8ArrayToWBEM(PADSVALUE pAttribute, IUnknown **ppEmbeddedObject)
{
	HRESULT result = E_FAIL;

	*ppEmbeddedObject = NULL;
	IWbemClassObject *pEmbeddedObject;
	if(SUCCEEDED(result = m_pWbemUin8ArrayClass->SpawnInstance(0, &pEmbeddedObject)))
	{
		if(SUCCEEDED(result = MapByteArray((pAttribute->OctetString).lpValue ,(pAttribute->OctetString).dwLength, VALUE_PROPERTY_STR, pEmbeddedObject)))
		{
			// Get the IUnknown interface of the embedded object
			if(SUCCEEDED(result = pEmbeddedObject->QueryInterface(IID_IUnknown, (LPVOID *)ppEmbeddedObject)))
			{
			}
		}
		pEmbeddedObject->Release();
	}
	return result;
}

HRESULT CLDAPInstanceProvider :: MapByteArray(LPBYTE lpBinaryValue, DWORD dwLength, const BSTR strPropertyName, IWbemClassObject *pInstance)
{
	HRESULT result = S_OK;
	// Create the safe array of uint8 elements
	SAFEARRAY *safeArray = NULL;
	SAFEARRAYBOUND safeArrayBounds [ 1 ];
	safeArrayBounds[0].lLbound = 0;
	safeArrayBounds[0].cElements = dwLength;
	safeArray = SafeArrayCreate(VT_UI1, 1, safeArrayBounds);
	for ( long index = 0; index<(long)dwLength; index ++ )
	{
		if(FAILED(result = SafeArrayPutElement ( safeArray , &index ,  lpBinaryValue+index)))
			break;
	}

	if(SUCCEEDED(result))
	{
		VARIANT embeddedVariant;
		VariantInit(&embeddedVariant);
		embeddedVariant.vt = VT_ARRAY | VT_UI1;
		embeddedVariant.parray = safeArray;

		result = pInstance->Put(strPropertyName, 0, &embeddedVariant, 0);
		VariantClear(&embeddedVariant);
	}
	else
		SafeArrayDestroy(safeArray);

	return result;
}

HRESULT CLDAPInstanceProvider :: MapDNWithBinaryToWBEM(PADSVALUE pAttribute, IUnknown **ppEmbeddedObject)
{
	
	HRESULT result = E_FAIL;
	IWbemClassObject *pEmbeddedObject;
	if(SUCCEEDED(result = m_pWbemDNWithBinaryClass->SpawnInstance(0, &pEmbeddedObject)))
	{
		if(pAttribute->pDNWithBinary->pszDNString && SUCCEEDED(result = CWBEMHelper::PutBSTRProperty(pEmbeddedObject, DN_STRING_PROPERTY_STR, SysAllocString(pAttribute->pDNWithBinary->pszDNString), TRUE)))
		{
			if(SUCCEEDED(result = MapByteArray(pAttribute->pDNWithBinary->lpBinaryValue, pAttribute->pDNWithBinary->dwLength, VALUE_PROPERTY_STR, pEmbeddedObject)))
			{
				// Get the IUnknown interface of the embedded object
				if(SUCCEEDED(result = pEmbeddedObject->QueryInterface(IID_IUnknown, (LPVOID *)ppEmbeddedObject)))
				{
				}
			}
		}
		pEmbeddedObject->Release();
	}
	return result;
}

HRESULT CLDAPInstanceProvider :: MapDNWithStringToWBEM(PADSVALUE pAttribute, IUnknown **ppEmbeddedObject)
{
	HRESULT result = E_FAIL;

	IWbemClassObject *pEmbeddedObject;
	if(SUCCEEDED(result = m_pWbemDNWithStringClass->SpawnInstance(0, &pEmbeddedObject)))
	{

		if(pAttribute->pDNWithString->pszDNString && SUCCEEDED(result = CWBEMHelper::PutBSTRProperty(pEmbeddedObject, DN_STRING_PROPERTY_STR, SysAllocString(pAttribute->pDNWithString->pszDNString), TRUE)))
		{
			if(pAttribute->pDNWithString->pszStringValue && SUCCEEDED(result = CWBEMHelper::PutBSTRProperty(pEmbeddedObject, VALUE_PROPERTY_STR, SysAllocString(pAttribute->pDNWithString->pszStringValue), TRUE)))
			{
				// Get the IUnknown interface of the embedded object
				if(SUCCEEDED(result = pEmbeddedObject->QueryInterface(IID_IUnknown, (LPVOID *)ppEmbeddedObject)))
				{
				}
			}
		}
		pEmbeddedObject->Release();
	}
	return result;
}


//***************************************************************************
//
// CLDAPInstanceProvider::IsContainedIn
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: IsContainedIn(LPCWSTR pszChildInstance, LPCWSTR pszParentInstance)
{
	IDirectoryObject *pDirectoryObject = NULL;
	HRESULT result = S_FALSE;
	if(SUCCEEDED(result = ADsOpenObject((LPWSTR)pszChildInstance, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectoryObject, (LPVOID *) &pDirectoryObject)))
	{
		PADS_OBJECT_INFO pObjectInfo = NULL;
		if(SUCCEEDED(result = pDirectoryObject->GetObjectInformation(&pObjectInfo)))
		{
			if(_wcsicmp(pszParentInstance, pObjectInfo->pszParentDN) == 0)
				result = S_OK;
			else
				result = S_FALSE;
			FreeADsMem((LPVOID *)pObjectInfo);
		}
		pDirectoryObject->Release();
	}
	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::CreateWBEMInstance
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: CreateWBEMInstance(BSTR strChildName, BSTR strParentName, IWbemClassObject **ppInstance)
{
	HRESULT result;
	if(SUCCEEDED(result = m_pAssociationsClass->SpawnInstance(0, ppInstance)))
	{
		// Put the property values
		if(SUCCEEDED(result = CWBEMHelper::PutBSTRProperty(*ppInstance, CHILD_INSTANCE_PROPERTY_STR, strChildName, FALSE)))
		{
			if(SUCCEEDED(result = CWBEMHelper::PutBSTRProperty(*ppInstance, PARENT_INSTANCE_PROPERTY_STR, strParentName, FALSE)))
			{
			}
			else
				g_pLogObject->WriteW( L"CLDAPInstanceProvider :: CreateWBEMInstance() PutBSTRProperty on parent property FAILED %x \r\n", result);
		}
		else
			g_pLogObject->WriteW( L"CLDAPInstanceProvider :: CreateWBEMInstance() PutBSTRProperty on child property FAILED %x \r\n", result);
	}
	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::DoChildContainmentQuery
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: DoChildContainmentQuery(LPCWSTR pszChildPath, IWbemObjectSink *pResponseHandler, CNamesList *pListIndicatedSoFar)
{
	IDirectoryObject *pChildObject = NULL;
	HRESULT result = S_FALSE;
	if(SUCCEEDED(result = ADsOpenObject((LPWSTR)pszChildPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectoryObject, (LPVOID *) &pChildObject)))
	{
		PADS_OBJECT_INFO pChildInfo = NULL;
		if(SUCCEEDED(result = pChildObject->GetObjectInformation(&pChildInfo)))
		{
			IDirectoryObject *pParentObject = NULL;
			if(SUCCEEDED(result = ADsOpenObject(pChildInfo->pszParentDN, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectoryObject, (LPVOID *) &pParentObject)))
			{
				PADS_OBJECT_INFO pParentInfo = NULL;
				if(SUCCEEDED(result = pParentObject->GetObjectInformation(&pParentInfo)))
				{
					IWbemClassObject *pAssociationInstance = NULL;
					// Get the WBEM names of the LDAP classes
					LPWSTR pszChildClassWbemName = CLDAPHelper::MangleLDAPNameToWBEM(pChildInfo->pszClassName);
					LPWSTR pszParentClassWbemName = CLDAPHelper::MangleLDAPNameToWBEM(pParentInfo->pszClassName);
					BSTR strChildPath = CWBEMHelper::GetObjectRefFromADSIPath(pszChildPath, pszChildClassWbemName);
					BSTR strParentPath = CWBEMHelper::GetObjectRefFromADSIPath(pParentInfo->pszObjectDN, pszParentClassWbemName);
					delete [] pszChildClassWbemName;
					delete [] pszParentClassWbemName;

					// Check to see if it has already been indicated
					LPWSTR pszCombinedName = NULL;
					if(pszCombinedName = new WCHAR[wcslen(pszChildPath) + wcslen(pParentInfo->pszObjectDN) + 1])
					{
						wcscpy(pszCombinedName,pszChildPath);
						wcscat(pszCombinedName,pParentInfo->pszObjectDN);
						if(!pListIndicatedSoFar->IsNamePresent(pszCombinedName))
						{
							if(SUCCEEDED(result = CreateWBEMInstance(strChildPath, strParentPath, &pAssociationInstance)))
							{
								result = pResponseHandler->Indicate(1, &pAssociationInstance);
								pAssociationInstance->Release();

								// Add it to the list of objects indicated so far
								pListIndicatedSoFar->AddName(pszCombinedName);
							}
						}
						delete [] pszCombinedName;
					}
					else
						result = E_OUTOFMEMORY;
					SysFreeString(strChildPath);
					SysFreeString(strParentPath);
					FreeADsMem((LPVOID *)pParentInfo);
				}

				pParentObject->Release();
			}
			FreeADsMem((LPVOID *)pChildInfo);
		}
		pChildObject->Release();
	}
	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::DoParentContainmentQuery
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: DoParentContainmentQuery(LPCWSTR pszParentPath, IWbemObjectSink *pResponseHandler, CNamesList *pListIndicatedSoFar)
{
	// We *have* to use the IADs interfaces since there are no container in
	IADsContainer *pContainer = NULL;
	IADs *pChild = NULL;
	VARIANT variant;
	VariantInit(&variant);
	HRESULT result;
	if(SUCCEEDED(result = ADsOpenObject((LPWSTR)pszParentPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IADsContainer, (LPVOID *) &pContainer)))
	{
		IADs *pParent = NULL;
		if(SUCCEEDED(result = pContainer->QueryInterface(IID_IADs, (LPVOID *)&pParent)))
		{
			BSTR strParentClass = NULL;
			if(SUCCEEDED(result = pParent->get_Class(&strParentClass)))
			{
				// Get the WBEM names of the LDAP class
				LPWSTR pszParentClassWbemName = CLDAPHelper::MangleLDAPNameToWBEM(strParentClass);
				BSTR strParentWBEMPath = CWBEMHelper::GetObjectRefFromADSIPath(pszParentPath, pszParentClassWbemName);
				delete [] pszParentClassWbemName;
				SysFreeString(strParentClass);
				IEnumVARIANT *pEnum = NULL;
				if(SUCCEEDED(result = ADsBuildEnumerator(pContainer, &pEnum)))
				{
					bool bDone = false;
					while(!bDone && SUCCEEDED(result = ADsEnumerateNext(pEnum, 1, &variant, NULL)) && result != S_FALSE)
					{
						if(SUCCEEDED(result = (variant.pdispVal)->QueryInterface(IID_IADs, (LPVOID *)&pChild)))
						{
							BSTR strChildADSIPath = NULL;
							if(SUCCEEDED(result = pChild->get_ADsPath(&strChildADSIPath)))
							{
								BSTR strChildClass = NULL;
								if(SUCCEEDED(result = pChild->get_Class(&strChildClass)))
								{
									// Create an instance of the association class
									IWbemClassObject *pAssociationInstance = NULL;
									// Get the WBEM Name oo the child class
									LPWSTR pszChildClassWbemName = CLDAPHelper::MangleLDAPNameToWBEM(strChildClass);
									BSTR strChildWBEMPath = CWBEMHelper::GetObjectRefFromADSIPath(strChildADSIPath, pszChildClassWbemName);
									delete [] pszChildClassWbemName;

									// Check to see if it has already been indicated
									LPWSTR pszCombinedName = NULL;
									if(pszCombinedName = new WCHAR[wcslen(strChildADSIPath) + wcslen(pszParentPath) + 1])
									{
										wcscpy(pszCombinedName,strChildADSIPath);
										wcscat(pszCombinedName,pszParentPath);

										if(!pListIndicatedSoFar->IsNamePresent(pszCombinedName))
										{
											if(SUCCEEDED(result = CreateWBEMInstance(strChildWBEMPath, strParentWBEMPath, &pAssociationInstance)))
											{
												if(FAILED(result = pResponseHandler->Indicate(1, &pAssociationInstance)))
													bDone = true;
												pAssociationInstance->Release();

												// Add it to the list of objects indicated so far
												pListIndicatedSoFar->AddName(pszCombinedName);
											}
										}
										delete [] pszCombinedName;
									}
									else
										result = E_OUTOFMEMORY;
									SysFreeString(strChildClass);
									SysFreeString(strChildWBEMPath);
								}
								SysFreeString(strChildADSIPath);
							}
							pChild->Release();
						}

						VariantClear(&variant);
						VariantInit(&variant);
					}
					ADsFreeEnumerator(pEnum);
				}
				SysFreeString(strParentWBEMPath);
			}
			pParent->Release();
		}
		pContainer->Release();
	}
	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::ModifyExistingADSIInstance
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: ModifyExistingADSIInstance(IWbemClassObject *pWbemInstance,
															LPCWSTR pszADSIPath,
															CADSIInstance *pExistingObject,
															LPCWSTR pszADSIClass,
															IWbemContext *pCtx)
{
	HRESULT result = S_OK;
	BOOLEAN bPartialUpdate = FALSE;
	DWORD dwPartialUpdateCount = 0;
	BSTR *pstrProperyNames = NULL;
	SAFEARRAY *pArray = NULL;
	// See if the partial property list is indicated in the context
	VARIANT v1, v2;
	VariantInit(&v1);
	VariantInit(&v2);

	if(SUCCEEDED(result = pCtx->GetValue(PUT_EXTENSIONS_STR, 0, &v1)))
	{
		if(SUCCEEDED(result = pCtx->GetValue(PUT_EXT_PROPERTIES_STR, 0, &v2)))
		{

			switch(v2.vt)
			{
				case VT_BSTR | VT_ARRAY:
				{
					pArray = v2.parray;
					LONG lUbound = 0, lLbound = 0;
					if(SUCCEEDED(result = SafeArrayAccessData(pArray, (void HUGEP* FAR*)&pstrProperyNames) ) &&
						SUCCEEDED (result = SafeArrayGetLBound(pArray, 1, &lLbound)) &&
						SUCCEEDED (result = SafeArrayGetUBound(pArray, 1, &lUbound)) )
					{
						dwPartialUpdateCount = lUbound - lLbound + 1;
						bPartialUpdate = TRUE;
					}
				}
				break;
				default:
					result = WBEM_E_FAILED;
					break;
			}
		}
		VariantClear(&v1);
	}
	else
		result = S_OK; // Reset it, there was no request for partial update

	if (FAILED(result))
		return WBEM_E_FAILED;

	// Find the number of properties first by doing an enumeration
	if(SUCCEEDED(result = pWbemInstance->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY)))
	{
		DWORD dwNumProperties = 0;
		while(SUCCEEDED(result = pWbemInstance->Next(0, NULL, NULL, NULL, NULL)) && result != WBEM_S_NO_MORE_DATA )
			dwNumProperties ++;
		pWbemInstance->EndEnumeration();

		// Allocate ADSI structures for these properties
		PADS_ATTR_INFO pAttributeEntries = NULL;
		if(pAttributeEntries = new ADS_ATTR_INFO [dwNumProperties])
		{
			// Now go thru each wbem property and map it
			if(SUCCEEDED(result = pWbemInstance->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY)))
			{
				DWORD dwNumPropertiesMapped = 0;
				BSTR strPropertyName = NULL;
				VARIANT vPropertyValue;
				CIMTYPE cType;
				LONG lFlavour;

				while(SUCCEEDED(result = pWbemInstance->Next(0,  &strPropertyName, &vPropertyValue, &cType, &lFlavour)) && result != WBEM_S_NO_MORE_DATA )
				{
					// Skip those properties that should not go to ADSI
					if(_wcsicmp(strPropertyName, ADSI_PATH_STR) == 0 )
					{
					}
					else // Map the property to ADSI
					{
						BOOLEAN bMapProperty = FALSE;
						if(bPartialUpdate)
						{
							if(CWBEMHelper::IsPresentInBstrList(pstrProperyNames, dwPartialUpdateCount, strPropertyName))
								bMapProperty = TRUE;
						}
						else
							bMapProperty = TRUE;

						if(bMapProperty)
						{

							if(vPropertyValue.vt == VT_NULL)
							{
								(pAttributeEntries + dwNumPropertiesMapped)->dwControlCode = ADS_ATTR_CLEAR;
								(pAttributeEntries + dwNumPropertiesMapped)->pszAttrName = CLDAPHelper::UnmangleWBEMNameToLDAP(strPropertyName);
								dwNumPropertiesMapped ++;
							}
							else if(SUCCEEDED(MapPropertyValueToADSI(pWbemInstance, strPropertyName, vPropertyValue, cType, lFlavour,  pAttributeEntries + dwNumPropertiesMapped)))
							{
								// Set the "attribute has been modified" flag
								(pAttributeEntries + dwNumPropertiesMapped)->dwControlCode = ADS_ATTR_UPDATE;
								dwNumPropertiesMapped ++;
							}
							else
								g_pLogObject->WriteW( L"CLDAPInstanceProvider :: ModifyExistingADSIInstance() MapPropertyValueToADSI FAILED %x for %s\r\n", result, strPropertyName);
						}
						else
							g_pLogObject->WriteW( L"CLDAPInstanceProvider :: ModifyExistingADSIInstance() Skipping %s since it is not in Context list\r\n", strPropertyName);
					}

					SysFreeString(strPropertyName);
					VariantClear(&vPropertyValue);
				}
				pWbemInstance->EndEnumeration();

				// Logging
				g_pLogObject->WriteW( L"CLDAPInstanceProvider :: The %d attributes being put are:\r\n", dwNumPropertiesMapped);
				for(DWORD i=0; i<dwNumPropertiesMapped; i++)
					g_pLogObject->WriteW( L"%s\r\n", (pAttributeEntries + i)->pszAttrName);

				// Get the actual object from ADSI to find out which attributes have changed.
				DWORD dwNumModified = 0;
				IDirectoryObject *pDirectoryObject = pExistingObject->GetDirectoryObject();
				if(SUCCEEDED(result = pDirectoryObject->SetObjectAttributes(pAttributeEntries, dwNumPropertiesMapped, &dwNumModified)))
				{
				}
				else
					g_pLogObject->WriteW( L"CLDAPInstanceProvider :: SetObjectAttributes FAILED with %x\r\n", result);
				pDirectoryObject->Release();

				// Delete the contents of each of the attributes
				for(i=0; i<dwNumPropertiesMapped; i++)
				{
					if((pAttributeEntries + i)->dwControlCode != ADS_ATTR_CLEAR)
						CLDAPHelper::DeleteAttributeContents(pAttributeEntries + i);
				}
			}
			delete [] pAttributeEntries;
		}
		else
			result = E_OUTOFMEMORY;
	}

	if(bPartialUpdate)
	{
		SafeArrayUnaccessData(pArray);
		VariantClear(&v2);
	}


	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::CreateNewADSIInstance
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: CreateNewADSIInstance(IWbemClassObject *pWbemInstance, LPCWSTR pszADSIPath, LPCWSTR pszADSIClass)
{
	// Find the ADSI path of the parent and the RDN of the child
	BSTR strRDNName = NULL;
	BSTR strParentADSIPath = NULL;
	BSTR strParentADSIPathWithoutLDAP = NULL;
	BSTR strParentPlusRDNADSIPath = NULL;
	HRESULT result = WBEM_E_FAILED;

	// Get the parentADSI path and RDN from the ADSI Path
	IADsPathname *pADsPathName = NULL;
	BSTR strADSIPath = SysAllocString(pszADSIPath);
	if(SUCCEEDED(result = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_ALL, IID_IADsPathname, (LPVOID *)&pADsPathName)))
	{
		if(SUCCEEDED(result = pADsPathName->Set(strADSIPath, ADS_SETTYPE_FULL)))
		{
			// This gives "<Parent>" without the "LDAP://" prefix
			if(SUCCEEDED(result = pADsPathName->Retrieve(ADS_FORMAT_X500_PARENT, &strParentADSIPathWithoutLDAP)))
			{
				// This gives "CN=Administrator,<Parent>"
				if(SUCCEEDED(result = pADsPathName->Retrieve(ADS_FORMAT_X500_DN, &strParentPlusRDNADSIPath)))
				{
					// Form the RDN - Dont ignore the comma.
					DWORD dwRDNLength = wcslen(strParentPlusRDNADSIPath) - wcslen(strParentADSIPathWithoutLDAP);
					LPWSTR pszRDN = NULL;
					if(pszRDN = new WCHAR [dwRDNLength])
					{
						wcsncpy(pszRDN, strParentPlusRDNADSIPath, dwRDNLength-1);
						pszRDN[dwRDNLength-1] = NULL;
						strRDNName = SysAllocString(pszRDN);
						delete [] pszRDN;
					}
					else
						result = E_OUTOFMEMORY;

					if(SUCCEEDED(result))
					{
						LPWSTR pszParentADSIPath  = NULL;
						if(pszParentADSIPath  = new WCHAR[wcslen(strParentADSIPathWithoutLDAP) + wcslen(LDAP_PREFIX) + 1])
						{
							wcscpy(pszParentADSIPath, LDAP_PREFIX);
							wcscat(pszParentADSIPath, strParentADSIPathWithoutLDAP);
							strParentADSIPath = SysAllocString(pszParentADSIPath);
							delete [] pszParentADSIPath;
						}
						else
							result = E_OUTOFMEMORY;
					}

					// Find the number of properties first by doing an enumeration
					if(SUCCEEDED(result) && SUCCEEDED(result = pWbemInstance->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY)))
					{
						DWORD dwNumProperties = 0;
						while(SUCCEEDED(result = pWbemInstance->Next(0, NULL, NULL, NULL, NULL)) && result != WBEM_S_NO_MORE_DATA )
							dwNumProperties ++;
						pWbemInstance->EndEnumeration();

						// Allocate ADSI structures for these properties. An additional one for the "objectclass" property
						PADS_ATTR_INFO pAttributeEntries = NULL;
						if(pAttributeEntries = new ADS_ATTR_INFO [dwNumProperties + 1])
						{
							// Now go thru each wbem property and map it
							if(SUCCEEDED(result = pWbemInstance->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY)))
							{
								DWORD dwNumPropertiesMapped = 0;
								BSTR strPropertyName = NULL;
								VARIANT vPropertyValue;
								CIMTYPE cType;
								LONG lFlavour;

								while(SUCCEEDED(result = pWbemInstance->Next(0,  &strPropertyName, &vPropertyValue, &cType, &lFlavour)) && result != WBEM_S_NO_MORE_DATA )
								{
									if(vPropertyValue.vt != VT_NULL)
									{
										// Skip those properties that should not go to ADSI
										if(_wcsicmp(strPropertyName, ADSI_PATH_STR) == 0 ||
											_wcsicmp(strPropertyName, OBJECT_CLASS_PROPERTY) == 0)
										{
										}
										else // Map the property to ADSI
										{
											if(SUCCEEDED(MapPropertyValueToADSI(pWbemInstance, strPropertyName, vPropertyValue, cType, lFlavour,  pAttributeEntries + dwNumPropertiesMapped)))
												dwNumPropertiesMapped ++;
											else
												g_pLogObject->WriteW( L"CLDAPInstanceProvider :: CreateNewADSIInstance() MapPropertyValueToADSI FAILED %x for %s\r\n", result, strPropertyName);
										}
									}

									SysFreeString(strPropertyName);
									VariantClear(&vPropertyValue);
								}
								pWbemInstance->EndEnumeration();


								// Set the objectClass attribute too
								SetObjectClassAttribute(pAttributeEntries + dwNumPropertiesMapped, pszADSIClass);
								dwNumPropertiesMapped++;


								// Now get the parent ADSI object
								IDirectoryObject *pParentObject = NULL;
								if(SUCCEEDED(result = ADsOpenObject(strParentADSIPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectoryObject, (LPVOID *)&pParentObject)))
								{
									if(SUCCEEDED(result = pParentObject->CreateDSObject(strRDNName, pAttributeEntries, dwNumPropertiesMapped, NULL)))
									{
									}
									else
										g_pLogObject->WriteW( L"CLDAPInstanceProvider :: CreateDSObject on parent FAILED with %x\r\n", result);
									pParentObject->Release();
								}
								else
									g_pLogObject->WriteW( L"CLDAPInstanceProvider :: ADsOpenObject on parent %s FAILED with %x\r\n", strParentADSIPath, result);

								// Delete the contents of each of the attributes
								for(DWORD i=0; i<dwNumPropertiesMapped; i++)
									CLDAPHelper::DeleteAttributeContents(pAttributeEntries + i);

							}

							delete [] pAttributeEntries;
						}
						else
							result = E_OUTOFMEMORY;
					}
					SysFreeString(strParentPlusRDNADSIPath);
					SysFreeString(strParentADSIPath);
				}
				SysFreeString(strParentADSIPathWithoutLDAP);
			}
		}

		pADsPathName->Release();
	}
	else
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: CoCreateInstance() on IADsPathName FAILED %x\r\n", result);

	SysFreeString(strADSIPath);
	return result;
}


//***************************************************************************
//
// CLDAPInstanceProvider::MapPropertyValueToADSI
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: MapPropertyValueToADSI(IWbemClassObject *pWbemInstance, BSTR strPropertyName, VARIANT vPropertyValue, CIMTYPE cType, LONG lFlavour,  PADS_ATTR_INFO pAttributeEntry)
{
	// Set its fields to 0;
	memset((LPVOID)pAttributeEntry, 0, sizeof(ADS_ATTR_INFO));

	HRESULT result = E_FAIL;

	// Set the name
	pAttributeEntry->pszAttrName = CLDAPHelper::UnmangleWBEMNameToLDAP(strPropertyName);
	IWbemQualifierSet *pQualifierSet = NULL;

	if(SUCCEEDED(result = pWbemInstance->GetPropertyQualifierSet(strPropertyName, &pQualifierSet)))
	{
		// Get its attributeSyntax qualifer
		LPWSTR pszAttributeSyntax = NULL;
		if(SUCCEEDED(CWBEMHelper::GetBSTRQualifierT(pQualifierSet, ATTRIBUTE_SYNTAX_STR, &pszAttributeSyntax, NULL)))
		{
			if(_wcsicmp(pszAttributeSyntax, DISTINGUISHED_NAME_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_DN_STRING;
				result = SetStringValues(pAttributeEntry, ADSTYPE_DN_STRING, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, OBJECT_IDENTIFIER_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_CASE_IGNORE_STRING;
				result = SetStringValues(pAttributeEntry, ADSTYPE_DN_STRING, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, CASE_SENSITIVE_STRING_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_CASE_EXACT_STRING;
				result = SetStringValues(pAttributeEntry, ADSTYPE_CASE_EXACT_STRING, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, CASE_INSENSITIVE_STRING_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_CASE_IGNORE_STRING;
				result = SetStringValues(pAttributeEntry, ADSTYPE_CASE_IGNORE_STRING, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, PRINT_CASE_STRING_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_PRINTABLE_STRING;
				result = SetStringValues(pAttributeEntry, ADSTYPE_PRINTABLE_STRING, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, NUMERIC_STRING_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_NUMERIC_STRING;
				result = SetStringValues(pAttributeEntry, ADSTYPE_NUMERIC_STRING, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, DN_WITH_STRING_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_DN_WITH_STRING;
				result = SetDNWithStringValues(pAttributeEntry, ADSTYPE_DN_WITH_STRING, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, DN_WITH_BINARY_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_DN_WITH_BINARY;
				result = SetDNWithBinaryValues(pAttributeEntry, ADSTYPE_DN_WITH_BINARY, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, BOOLEAN_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_BOOLEAN;
				result = SetBooleanValues(pAttributeEntry, ADSTYPE_BOOLEAN, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, INTEGER_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_INTEGER;
				result = SetIntegerValues(pAttributeEntry, ADSTYPE_INTEGER, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, OCTET_STRING_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_OCTET_STRING;
				result = SetOctetStringValues(pAttributeEntry, ADSTYPE_OCTET_STRING, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, TIME_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_CASE_IGNORE_STRING;
				result = SetTimeValues(pAttributeEntry, ADSTYPE_CASE_IGNORE_STRING, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, UNICODE_STRING_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_CASE_IGNORE_STRING;
				result = SetStringValues(pAttributeEntry, ADSTYPE_DN_STRING, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, NT_SECURITY_DESCRIPTOR_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
				result = SetOctetStringValues(pAttributeEntry, ADSTYPE_NT_SECURITY_DESCRIPTOR, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, LARGE_INTEGER_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_LARGE_INTEGER;
				result = SetLargeIntegerValues(pAttributeEntry, ADSTYPE_LARGE_INTEGER, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, SID_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_OCTET_STRING;
				result = SetOctetStringValues(pAttributeEntry, ADSTYPE_OCTET_STRING, &vPropertyValue);
			}
			else
			{
				g_pLogObject->WriteW( L"CLDAPInstanceProvider :: MapPropertyValueToADSI() Unknown attributeSyntax %s\r\n", pszAttributeSyntax);
				result = E_FAIL;
			}

			delete[] pszAttributeSyntax;
		}
		else
			g_pLogObject->WriteW( L"CLDAPInstanceProvider :: MapPropertyValueToADSI() Get on attributeSyntax FAILED %x\r\n", result);
		pQualifierSet->Release();
	}

	return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
// CLDAPInstanceProvider::SetStringValues
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: SetStringValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue)
{
	HRESULT result = S_OK;
	switch(pvPropertyValue->vt)
	{
		case VT_BSTR:
		{
			if(pvPropertyValue->bstrVal)
			{
				pAttributeEntry->dwNumValues = 1;
				pAttributeEntry->pADsValues = NULL;
				if(pAttributeEntry->pADsValues = new ADSVALUE)
				{
					pAttributeEntry->pADsValues->dwType = adType;
					pAttributeEntry->pADsValues->DNString = NULL;
					if(pAttributeEntry->pADsValues->DNString = new WCHAR[wcslen(pvPropertyValue->bstrVal) + 1])
						wcscpy(pAttributeEntry->pADsValues->DNString, pvPropertyValue->bstrVal);
					else
						result = E_OUTOFMEMORY;
				}
				else
					result = E_OUTOFMEMORY;
			}
		}
		break;
		case VT_BSTR | VT_ARRAY:
		{
			SAFEARRAY *pArray = pvPropertyValue->parray;
			BSTR HUGEP *pbstr;
			LONG lUbound = 0, lLbound = 0;
			if(SUCCEEDED(result = SafeArrayAccessData(pArray, (void HUGEP* FAR*)&pbstr) ))
			{
				if(SUCCEEDED (result = SafeArrayGetLBound(pArray, 1, &lLbound)) &&
				SUCCEEDED (result = SafeArrayGetUBound(pArray, 1, &lUbound)) )
				{
					if(pAttributeEntry->dwNumValues = lUbound - lLbound + 1)
					{
						pAttributeEntry->pADsValues = NULL;
						if(pAttributeEntry->pADsValues = new ADSVALUE[pAttributeEntry->dwNumValues])
						{
							PADSVALUE pValues = pAttributeEntry->pADsValues;
							for(DWORD i=0; i<pAttributeEntry->dwNumValues; i++)
							{
								pValues->dwType = adType;
								pValues->DNString = NULL;
								if(pValues->DNString = new WCHAR[wcslen(pbstr[i]) + 1])
									wcscpy(pValues->DNString, pbstr[i]);
								pValues ++;
							}
						}
						else
							result = E_OUTOFMEMORY;
					}
				}
				SafeArrayUnaccessData(pArray);
			}
		}
		break;
		default:
			return E_FAIL;
	}
	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::SetIntegerValues
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: SetIntegerValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue)
{
	HRESULT result = S_OK;
	switch(pvPropertyValue->vt)
	{
		case VT_I4:
		{
			pAttributeEntry->dwNumValues = 1;
			pAttributeEntry->pADsValues = NULL;
			if(pAttributeEntry->pADsValues = new ADSVALUE)
			{
				pAttributeEntry->pADsValues->dwType = adType;
				pAttributeEntry->pADsValues->Integer = pvPropertyValue->lVal;
			}
			else
				result = E_OUTOFMEMORY;
		}
		break;
		case VT_I4 | VT_ARRAY:
		{
			SAFEARRAY *pArray = pvPropertyValue->parray;
			LONG HUGEP *pl;
			LONG lUbound = 0, lLbound = 0;
			if(SUCCEEDED(result = SafeArrayAccessData(pArray, (void HUGEP* FAR*)&pl) ) &&
				SUCCEEDED (result = SafeArrayGetLBound(pArray, 1, &lLbound)) &&
				SUCCEEDED (result = SafeArrayGetUBound(pArray, 1, &lUbound)) )
			{
				if(pAttributeEntry->dwNumValues = lUbound - lLbound + 1)
				{
					pAttributeEntry->pADsValues = NULL;
					if(pAttributeEntry->pADsValues = new ADSVALUE[pAttributeEntry->dwNumValues])
					{
						PADSVALUE pValues = pAttributeEntry->pADsValues;
						for(DWORD i=0; i<pAttributeEntry->dwNumValues; i++)
						{
							pValues->dwType = adType;
							pValues->Integer = pl[i];
							pValues ++;
						}
					}
					else
						result = E_OUTOFMEMORY;
				}
				SafeArrayUnaccessData(pArray);
			}
		}
		break;
		default:
			return E_FAIL;
	}
	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::SetBooleanValues
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: SetBooleanValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue)
{
	HRESULT result = S_OK;
	switch(pvPropertyValue->vt)
	{
		case VT_BOOL:
		{
			pAttributeEntry->dwNumValues = 1;
			pAttributeEntry->pADsValues = NULL;
			if(pAttributeEntry->pADsValues = new ADSVALUE)
			{
				pAttributeEntry->pADsValues->dwType = adType;
				pAttributeEntry->pADsValues->Boolean = pvPropertyValue->boolVal;
			}
			else
				result = E_OUTOFMEMORY;
		}
		break;
		case VT_BOOL | VT_ARRAY:
		{
			SAFEARRAY *pArray = pvPropertyValue->parray;
			VARIANT_BOOL HUGEP *pb;
			LONG lUbound = 0, lLbound = 0;
			if(SUCCEEDED(result = SafeArrayAccessData(pArray, (void HUGEP* FAR*)&pb) ) &&
				SUCCEEDED (result = SafeArrayGetLBound(pArray, 1, &lLbound)) &&
				SUCCEEDED (result = SafeArrayGetUBound(pArray, 1, &lUbound)) )
			{
				if(pAttributeEntry->dwNumValues = lUbound - lLbound + 1)
				{
					pAttributeEntry->pADsValues = NULL;
					if(pAttributeEntry->pADsValues = new ADSVALUE[pAttributeEntry->dwNumValues])
					{
						PADSVALUE pValues = pAttributeEntry->pADsValues;
						for(DWORD i=0; i<pAttributeEntry->dwNumValues; i++)
						{
							pValues->dwType = adType;
							pValues->Boolean = (pb[i] == VARIANT_TRUE)? TRUE : FALSE;
							pValues ++;
						}
					}
					else
						result = E_OUTOFMEMORY;
				}
				SafeArrayUnaccessData(pArray);
			}
		}
		break;
		default:
			return E_FAIL;
	}
	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::SetOctetStringValues
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: SetOctetStringValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue)
{
	HRESULT result = E_FAIL;
	switch(pvPropertyValue->vt)
	{
		case VT_UNKNOWN:
		{
			pAttributeEntry->dwNumValues = 1;
			pAttributeEntry->pADsValues = NULL;
			if(pAttributeEntry->pADsValues = new ADSVALUE)
			{
				pAttributeEntry->pADsValues->dwType = adType;
				// Get the array
				IWbemClassObject *pEmbeddedObject = NULL;
				if(SUCCEEDED(result = (pvPropertyValue->punkVal)->QueryInterface(IID_IWbemClassObject, (LPVOID *)&pEmbeddedObject)))
				{
					if(SUCCEEDED(result = CWBEMHelper::GetUint8ArrayProperty(pEmbeddedObject, VALUE_PROPERTY_STR, &(pAttributeEntry->pADsValues->OctetString.lpValue), &(pAttributeEntry->pADsValues->OctetString.dwLength) )))
					{
					}
					pEmbeddedObject->Release();
				}
			}
			else
				result = E_OUTOFMEMORY;
		}
		break;
		case VT_UNKNOWN | VT_ARRAY:
		{
			SAFEARRAY *pArray = pvPropertyValue->parray;
			LONG lUbound = 0, lLbound = 0;
			if(SUCCEEDED (result = SafeArrayGetLBound(pArray, 1, &lLbound)) &&
				SUCCEEDED (result = SafeArrayGetUBound(pArray, 1, &lUbound)) )
			{
				if(pAttributeEntry->dwNumValues = lUbound - lLbound + 1)
				{
					pAttributeEntry->pADsValues = NULL;
					if(pAttributeEntry->pADsValues = new ADSVALUE[pAttributeEntry->dwNumValues])
					{
						PADSVALUE pValues = pAttributeEntry->pADsValues;
						IUnknown *pNextElement = NULL;
						for(DWORD i=0; i<pAttributeEntry->dwNumValues; i++)
						{
							pValues->dwType = adType;
							if(SUCCEEDED(result = SafeArrayGetElement(pArray, (LONG *)&i, (LPVOID )&pNextElement )))
							{
								IWbemClassObject *pEmbeddedObject = NULL;
								if(SUCCEEDED(result = pNextElement->QueryInterface(IID_IWbemClassObject, (LPVOID *)&pEmbeddedObject)))
								{
									if(SUCCEEDED(result = CWBEMHelper::GetUint8ArrayProperty(pEmbeddedObject, VALUE_PROPERTY_STR, &(pValues->OctetString.lpValue), &(pValues->OctetString.dwLength))))
									{
									}
									pEmbeddedObject->Release();
								}
								pNextElement->Release();

							}
							pValues ++;

						}
					}
					else
						result = E_OUTOFMEMORY;
				}
			}
		}
		break;
		default:
			return E_FAIL;
	}
	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::SetDNWithStringValues
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: SetDNWithStringValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue)
{
	HRESULT result = E_FAIL;
	switch(pvPropertyValue->vt)
	{
		case VT_UNKNOWN:
		{
			pAttributeEntry->dwNumValues = 1;
			pAttributeEntry->pADsValues = NULL;
			if(pAttributeEntry->pADsValues = new ADSVALUE)
			{
				pAttributeEntry->pADsValues->dwType = adType;
				pAttributeEntry->pADsValues->pDNWithString = NULL;
				if(pAttributeEntry->pADsValues->pDNWithString = new ADS_DN_WITH_STRING)
				{
					IWbemClassObject *pEmbeddedObject = NULL;
					if(SUCCEEDED(result = (pvPropertyValue->punkVal)->QueryInterface(IID_IWbemClassObject, (LPVOID *)&pEmbeddedObject)))
					{
						if(SUCCEEDED(result = CWBEMHelper::GetBSTRPropertyT(pEmbeddedObject, VALUE_PROPERTY_STR, &(pAttributeEntry->pADsValues->pDNWithString->pszStringValue) )))
						{
							if(SUCCEEDED(result = CWBEMHelper::GetBSTRPropertyT(pEmbeddedObject, DN_STRING_PROPERTY_STR, &(pAttributeEntry->pADsValues->pDNWithString->pszDNString) )))
							{
							}
						}
						pEmbeddedObject->Release();
					}
				}
				else
					result = E_OUTOFMEMORY;
			}
			else
				result = E_OUTOFMEMORY;
		}
		break;
		case VT_UNKNOWN | VT_ARRAY:
		{
			SAFEARRAY *pArray = pvPropertyValue->parray;
			LONG lUbound = 0, lLbound = 0;
			if(SUCCEEDED (result = SafeArrayGetLBound(pArray, 1, &lLbound)) &&
				SUCCEEDED (result = SafeArrayGetUBound(pArray, 1, &lUbound)) )
			{
				if(pAttributeEntry->dwNumValues = lUbound - lLbound + 1)
				{
					pAttributeEntry->pADsValues = NULL;
					if(pAttributeEntry->pADsValues = new ADSVALUE[pAttributeEntry->dwNumValues])
					{
						PADSVALUE pValues = pAttributeEntry->pADsValues;
						IUnknown *pNextElement = NULL;
						for(DWORD i=0; i<pAttributeEntry->dwNumValues; i++)
						{
							pValues->dwType = adType;
							if(SUCCEEDED(result = SafeArrayGetElement(pArray, (LONG *)&i, (LPVOID )&pNextElement )))
							{

								IWbemClassObject *pEmbeddedObject = NULL;
								if(SUCCEEDED(result = pNextElement->QueryInterface(IID_IWbemClassObject, (LPVOID *)&pEmbeddedObject)))
								{
									if(pValues->pDNWithString = new ADS_DN_WITH_STRING)
									{
										if(SUCCEEDED(result = CWBEMHelper::GetBSTRPropertyT(pEmbeddedObject, VALUE_PROPERTY_STR, &(pValues->pDNWithString->pszStringValue) )))
										{
											if(SUCCEEDED(result = CWBEMHelper::GetBSTRPropertyT(pEmbeddedObject, DN_STRING_PROPERTY_STR, &(pValues->pDNWithString->pszDNString) )))
											{
											}
										}
									}
									pEmbeddedObject->Release();
								}
								pNextElement->Release();
							}
							pValues ++;
						}
					}
					else
						result = E_OUTOFMEMORY;
				}
			}
		}
		break;
		default:
			return E_FAIL;
	}
	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::SetDNWithBinaryValues
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: SetDNWithBinaryValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue)
{
	HRESULT result = E_FAIL;
	switch(pvPropertyValue->vt)
	{
		case VT_UNKNOWN:
		{
			pAttributeEntry->dwNumValues = 1;
			pAttributeEntry->pADsValues = NULL;
			if(pAttributeEntry->pADsValues = new ADSVALUE)
			{
				pAttributeEntry->pADsValues->dwType = adType;
				pAttributeEntry->pADsValues->pDNWithBinary = NULL;
				if(pAttributeEntry->pADsValues->pDNWithBinary = new ADS_DN_WITH_BINARY)
				{
					IWbemClassObject *pEmbeddedObject = NULL;
					if(SUCCEEDED(result = (pvPropertyValue->punkVal)->QueryInterface(IID_IWbemClassObject, (LPVOID *)&pEmbeddedObject)))
					{
						if(SUCCEEDED(result = CWBEMHelper::GetUint8ArrayProperty(pEmbeddedObject, VALUE_PROPERTY_STR, &(pAttributeEntry->pADsValues->pDNWithBinary->lpBinaryValue), &(pAttributeEntry->pADsValues->pDNWithBinary->dwLength) )))
						{
							if(SUCCEEDED(result = CWBEMHelper::GetBSTRPropertyT(pEmbeddedObject, DN_STRING_PROPERTY_STR, &(pAttributeEntry->pADsValues->pDNWithBinary->pszDNString) )))
							{
							}
						}
						pEmbeddedObject->Release();
					}
				}
				else
					result = E_OUTOFMEMORY;
			}
			else
				result = E_OUTOFMEMORY;
		}
		break;
		case VT_UNKNOWN | VT_ARRAY:
		{
			SAFEARRAY *pArray = pvPropertyValue->parray;
			LONG lUbound = 0, lLbound = 0;
			if(SUCCEEDED (result = SafeArrayGetLBound(pArray, 1, &lLbound)) &&
				SUCCEEDED (result = SafeArrayGetUBound(pArray, 1, &lUbound)) )
			{
				if(pAttributeEntry->dwNumValues = lUbound - lLbound + 1)
				{
					pAttributeEntry->pADsValues = NULL;
					if(pAttributeEntry->pADsValues = new ADSVALUE[pAttributeEntry->dwNumValues])
					{
						PADSVALUE pValues = pAttributeEntry->pADsValues;
						IUnknown *pNextElement = NULL;
						for(DWORD i=0; i<pAttributeEntry->dwNumValues; i++)
						{
							pValues->dwType = adType;
							if(SUCCEEDED(result = SafeArrayGetElement(pArray, (LONG *)&i, (LPVOID )&pNextElement )))
							{

								IWbemClassObject *pEmbeddedObject = NULL;
								if(SUCCEEDED(result = pNextElement->QueryInterface(IID_IWbemClassObject, (LPVOID *)&pEmbeddedObject)))
								{
									if(pValues->pDNWithBinary = new ADS_DN_WITH_BINARY)
									{
										if(SUCCEEDED(result = CWBEMHelper::GetUint8ArrayProperty(pEmbeddedObject, VALUE_PROPERTY_STR, &(pAttributeEntry->pADsValues->pDNWithBinary->lpBinaryValue), &(pAttributeEntry->pADsValues->pDNWithBinary->dwLength) )))
										{
											if(SUCCEEDED(result = CWBEMHelper::GetBSTRPropertyT(pEmbeddedObject, DN_STRING_PROPERTY_STR, &(pAttributeEntry->pADsValues->pDNWithBinary->pszDNString) )))
											{
											}
										}
									}
									pEmbeddedObject->Release();
								}
								pNextElement->Release();
							}
							pValues ++;

						}
					}
					else
						result = E_OUTOFMEMORY;
				}
			}
		}
		break;
		default:
			return E_FAIL;
	}
	return result;
}


//***************************************************************************
//
// CLDAPInstanceProvider::SetTimeValues
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: SetTimeValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue)
{
	HRESULT result = S_OK;
	switch(pvPropertyValue->vt)
	{
		case VT_BSTR:
		{
			//199880819014734.000000+000 to 19980819014734.0Z to
			pAttributeEntry->dwNumValues = 1;
			pAttributeEntry->pADsValues = NULL;
			if(pAttributeEntry->pADsValues = new ADSVALUE)
			{
				pAttributeEntry->pADsValues->dwType = adType;
				pAttributeEntry->pADsValues->DNString = NULL;
				if(pAttributeEntry->pADsValues->DNString = new WCHAR[27])
				{
					wcscpy(pAttributeEntry->pADsValues->DNString, pvPropertyValue->bstrVal);
					(pAttributeEntry->pADsValues->DNString)[16] = L'Z';
					(pAttributeEntry->pADsValues->DNString)[17] = NULL;
				}
				else
					result = E_OUTOFMEMORY;
			}
			else
				result = E_OUTOFMEMORY;
		}
		break;
		case VT_BSTR | VT_ARRAY:
		{
			SAFEARRAY *pArray = pvPropertyValue->parray;
			BSTR HUGEP *pbstr;
			LONG lUbound = 0, lLbound = 0;
			if(SUCCEEDED(result = SafeArrayAccessData(pArray, (void HUGEP* FAR*)&pbstr) ) &&
				SUCCEEDED (result = SafeArrayGetLBound(pArray, 1, &lLbound)) &&
				SUCCEEDED (result = SafeArrayGetUBound(pArray, 1, &lUbound)) )
			{
				if(pAttributeEntry->dwNumValues = lUbound - lLbound + 1)
				{
					pAttributeEntry->pADsValues = NULL;
					if(pAttributeEntry->pADsValues = new ADSVALUE[pAttributeEntry->dwNumValues])
					{
						PADSVALUE pValues = pAttributeEntry->pADsValues;
						bool bError = false;
						for(DWORD i=0; !bError && (i<pAttributeEntry->dwNumValues); i++)
						{
							pValues->dwType = adType;
							pValues->DNString = NULL;
							if(pValues->DNString = new WCHAR[27])
							{
								wcscpy(pValues->DNString, pbstr[i]);
								(pValues->DNString)[16] = L'Z';
								(pValues->DNString)[17] = NULL;
								pValues ++;
							}
							else
							{
								bError = true;
								result = E_OUTOFMEMORY;
							}
						}
					}
					else
						result = E_OUTOFMEMORY;
				}
				SafeArrayUnaccessData(pArray);
			}
		}
		break;
		default:
			return E_FAIL;
	}
	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::SetLargeIntegerValues
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: SetLargeIntegerValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue)
{
	HRESULT result = S_OK;
	switch(pvPropertyValue->vt)
	{
		case VT_BSTR:
		{
			pAttributeEntry->dwNumValues = 1;
			pAttributeEntry->pADsValues = NULL;
			if(pAttributeEntry->pADsValues = new ADSVALUE)
			{
				pAttributeEntry->pADsValues->dwType = adType;
				swscanf(pvPropertyValue->bstrVal, L"%I64d", &((pAttributeEntry->pADsValues->LargeInteger).QuadPart));
			}
			else
				result = E_OUTOFMEMORY;
		}
		break;
		case VT_BSTR | VT_ARRAY:
		{
			SAFEARRAY *pArray = pvPropertyValue->parray;
			BSTR HUGEP *pbstr;
			LONG lUbound = 0, lLbound = 0;
			if(SUCCEEDED(result = SafeArrayAccessData(pArray, (void HUGEP* FAR*)&pbstr) ) &&
				SUCCEEDED (result = SafeArrayGetLBound(pArray, 1, &lLbound)) &&
				SUCCEEDED (result = SafeArrayGetUBound(pArray, 1, &lUbound)) )
			{
				if(pAttributeEntry->dwNumValues = lUbound - lLbound + 1)
				{
					pAttributeEntry->pADsValues = NULL;
					if(pAttributeEntry->pADsValues = new ADSVALUE[pAttributeEntry->dwNumValues])
					{
						PADSVALUE pValues = pAttributeEntry->pADsValues;
						for(DWORD i=0; i<pAttributeEntry->dwNumValues; i++)
						{
							pValues->dwType = adType;
							swscanf(pbstr[i], L"%I64d", &((pValues->LargeInteger).QuadPart));
							pValues ++;
						}
					}
					else
						result = E_OUTOFMEMORY;
				}
				SafeArrayUnaccessData(pArray);
			}
		}
		break;
		default:
			return E_FAIL;
	}
	return result;
}


//***************************************************************************
//
// CLDAPInstanceProvider::SetObjectClassAttribute
//
// Purpose: See Header File
//
//***************************************************************************
void CLDAPInstanceProvider :: SetObjectClassAttribute(PADS_ATTR_INFO pAttributeEntry, LPCWSTR pszADSIClassName)
{
	// Set its fields to 0;
	memset((LPVOID)pAttributeEntry, 0, sizeof(ADS_ATTR_INFO));


	// Set the name
	pAttributeEntry->pszAttrName = CLDAPHelper::UnmangleWBEMNameToLDAP(OBJECT_CLASS_PROPERTY);

	// Set the value
	pAttributeEntry->dwADsType = ADSTYPE_CASE_IGNORE_STRING;
	pAttributeEntry->dwNumValues = 1;
	pAttributeEntry->pADsValues = NULL;
	if(pAttributeEntry->pADsValues = new ADSVALUE)
	{
		pAttributeEntry->pADsValues->dwType = ADSTYPE_DN_STRING;
		pAttributeEntry->pADsValues->DNString = NULL;
		if(pAttributeEntry->pADsValues->DNString = new WCHAR[wcslen(pszADSIClassName) + 1])
			wcscpy(pAttributeEntry->pADsValues->DNString, pszADSIClassName);
	}
}



// Process query for associations
HRESULT CLDAPInstanceProvider :: ProcessAssociationQuery(
	IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler,
	SQL1_Parser *pParser)
{
	HRESULT result = WBEM_S_NO_ERROR;
	// Parse the query
    SQL_LEVEL_1_RPN_EXPRESSION *pExp = 0;
    if(!pParser->Parse(&pExp))
    {
		// Check to see that it has exactly 1 or 2 clauses, and
		// if 2 clauses are present, these should be different ones, and the operator should be an AND
		// This is because we support only the following kinds of queries
		// Select * From DS_LDAP_CONTAINMENT_CLASS Where parentInstance = <something>
		// Select * From DS_LDAP_CONTAINMENT_CLASS Where childInstance = <something>
		// For all other queries, if there is a NOT operator, we do not support it.
		// Otherwise we just take the individual clauses and return theri union, asking CIMOM to postprocess
		int iNumTokens = pExp->nNumTokens;

		// Go thru the tokens to see that NOT is not present
		SQL_LEVEL_1_TOKEN *pNextToken = pExp->pArrayOfTokens;
		for(int i=0; i<iNumTokens; i++)
		{
			if(pNextToken->nTokenType == SQL_LEVEL_1_TOKEN::TOKEN_NOT ||
				(pNextToken->nTokenType == SQL_LEVEL_1_TOKEN::OP_EXPRESSION && pNextToken->nOperator == SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL))
			{
				result = WBEM_E_PROVIDER_NOT_CAPABLE;
				break;
			}
			pNextToken ++;
		}

		// No NOT was found
		if(result != WBEM_E_PROVIDER_NOT_CAPABLE)
		{
			// Ask CIMOM to postprocess the result
			pResponseHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, WBEM_S_NO_ERROR, NULL, NULL);

			// Duplicates need to be avoided. So keep a list of objects indicated so far.
			// The key in the list is formed by concatenating the child and parent ADSI paths
			//===========================================================================

			CNamesList listIndicatedSoFar;

			pNextToken = pExp->pArrayOfTokens;
			i=0;
			while(i<iNumTokens && result != WBEM_E_PROVIDER_NOT_CAPABLE)
			{
				if(pNextToken->nTokenType == SQL_LEVEL_1_TOKEN::OP_EXPRESSION)
				{
					LPWSTR pszADSIPath = CWBEMHelper::GetADSIPathFromObjectPath(pNextToken->vConstValue.bstrVal);
					if(_wcsicmp(pNextToken->pPropertyName, CHILD_INSTANCE_PROPERTY_STR) == 0)
					{
						DoChildContainmentQuery(pszADSIPath, pResponseHandler, &listIndicatedSoFar);
						result = WBEM_S_NO_ERROR;
					}
					else if (_wcsicmp(pNextToken->pPropertyName, PARENT_INSTANCE_PROPERTY_STR) == 0)
					{
						DoParentContainmentQuery(pszADSIPath, pResponseHandler, &listIndicatedSoFar);
						result = WBEM_S_NO_ERROR;
					}
					else
						result = WBEM_E_PROVIDER_NOT_CAPABLE;

					delete [] pszADSIPath;

				}
				i++;
				pNextToken ++;
			}

		}
    }
	else
		result = WBEM_E_FAILED;

    delete pExp;
	if(SUCCEEDED(result))
	{
		pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_S_NO_ERROR, NULL, NULL);
		result = WBEM_S_NO_ERROR;
	}
	else
	{
		pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_E_FAILED, NULL, NULL);
		result = WBEM_S_NO_ERROR;
	}

	return result;
}


// Process Query for DS instances
HRESULT CLDAPInstanceProvider :: ProcessInstanceQuery(
    BSTR strClass,
	BSTR strQuery,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler,
	SQL1_Parser *pParser)
{
	g_pLogObject->WriteW( L"CLDAPInstanceProvider :: ProcessInstanceQuery() called for %s Class and query %s\r\n", strClass, strQuery);

	HRESULT result = WBEM_E_FAILED;

	// Parse the query
    SQL_LEVEL_1_RPN_EXPRESSION *pExp = NULL;
    if(!pParser->Parse(&pExp))
    {
		// Fetch the class from CIMOM
		IWbemClassObject *pWbemClass = NULL;
		if(SUCCEEDED(result = m_IWbemServices->GetObject(strClass, 0, pCtx, &pWbemClass, NULL)))
		{
			// We need the object category information
			LPWSTR pszLDAPQuery = NULL;
			if(pszLDAPQuery = new WCHAR[6*(2*wcslen(strClass) + 75) + wcslen(strQuery) + 500])
			{
				pszLDAPQuery[0] = LEFT_BRACKET_STR[0];
				pszLDAPQuery[1] = AMPERSAND_STR[0];
				pszLDAPQuery[2] = NULL;
				if(SUCCEEDED(CWBEMHelper::FormulateInstanceQuery(m_IWbemServices, pCtx, strClass, pWbemClass, pszLDAPQuery + 2, LDAP_DISPLAY_NAME_STR, DEFAULT_OBJECT_CATEGORY_STR)))
				{
					// Check to see if it can be converted to an LDAP query
					if(SUCCEEDED(result = ConvertWQLToLDAPQuery(pExp, pszLDAPQuery)))
					{
						// Complete the query string
						DWORD dwLen = wcslen(pszLDAPQuery);
						pszLDAPQuery[dwLen] = RIGHT_BRACKET_STR[0];
						pszLDAPQuery[dwLen + 1] = NULL;

						// Check to see if the client has specified any hints as to the DN of the object from
						// which the search should start
						BOOLEAN bRootDNSpecified = FALSE;
						LPWSTR *ppszRootDN = NULL;
						DWORD dwRootDNCount = 0;
						if(SUCCEEDED(GetRootDN(strClass, &ppszRootDN, &dwRootDNCount, pCtx)) && dwRootDNCount)
							bRootDNSpecified = TRUE;

						// Enumerate the ADSI Instances
						if(bRootDNSpecified)
						{
							for( DWORD i=0; i<dwRootDNCount; i++)
							{
								DoSingleQuery(strClass, pWbemClass, ppszRootDN[i], pszLDAPQuery,  pResponseHandler);
							}
						}
						else
						{
							DoSingleQuery(strClass, pWbemClass, m_lpszTopLevelContainerPath, pszLDAPQuery,  pResponseHandler);
						}

						if(bRootDNSpecified)
						{
							for(DWORD i=0; i<dwRootDNCount; i++)
							{
								delete [] ppszRootDN[i];
							}
							delete [] ppszRootDN;
						}

					}
				}
				else
					g_pLogObject->WriteW( L"CLDAPInstanceProvider :: FormulateInstanceQuery() on WBEM class %s FAILED with %x on query %s \r\n", strClass, result, strQuery);
			}
			else
				result = E_OUTOFMEMORY;
			pWbemClass->Release();
			delete [] pszLDAPQuery;
		}
		else
			g_pLogObject->WriteW( L"CLDAPInstanceProvider :: ProcessInstanceQuery() Getting WBEM class %s FAILED with %x on query %s \r\n", strClass, result, strQuery);
	}
	else
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: ProcessInstanceQuery() Parse() FAILED on query %s \r\n", strQuery);
    delete pExp;
	return result;
}

HRESULT CLDAPInstanceProvider :: ConvertWQLToLDAPQuery(SQL_LEVEL_1_RPN_EXPRESSION *pExp, LPWSTR pszLDAPQuery)
{
	HRESULT result = E_FAIL;
	DWORD dwLength = wcslen(pszLDAPQuery);

	// Append to the existing string
	if(QueryConvertor::ConvertQueryToLDAP(pExp, pszLDAPQuery + dwLength))
	{
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: ConvertWQLToLDAPQuery() Query converted to %s \r\n", pszLDAPQuery);
		result = S_OK;
	}
	else
		g_pLogObject->WriteW( L"CLDAPInstanceProvider :: ConvertWQLToLDAPQuery() FAILED \r\n");

	return result;
}

HRESULT CLDAPInstanceProvider :: GetRootDN( LPCWSTR pszClass, LPWSTR **pppszRootDN, DWORD *pdwCount, IWbemContext *pCtx)
{
	*pppszRootDN = NULL;
	*pdwCount = 0;
	HRESULT result = WBEM_E_FAILED;

	// For the correct query
	LPWSTR pszQuery = new WCHAR[wcslen(pszClass) + wcslen(QUERY_FORMAT) + 10];
	swprintf(pszQuery, QUERY_FORMAT, pszClass);
	BSTR strQuery = SysAllocString(pszQuery);
	delete [] pszQuery;

	IEnumWbemClassObject *pEnum = NULL;
	if(SUCCEEDED(result = m_IWbemServices->ExecQuery(QUERY_LANGUAGE, strQuery, WBEM_FLAG_BIDIRECTIONAL, pCtx, &pEnum)))
	{
		// We ignore more than one instance in this implementation
		// Walk thru the enumeration and examine each class
		IWbemClassObject *pInstance = NULL;
		ULONG dwNextReturned = 0;
		while(SUCCEEDED(result = pEnum->Next( WBEM_INFINITE, 1, &pInstance, &dwNextReturned)) && dwNextReturned == 1)
		{
			(*pdwCount)++;
			pInstance->Release();
		}

		if(*pdwCount)
		{
			if(SUCCEEDED(result = pEnum->Reset()))
			{
				*pppszRootDN  = new LPWSTR[*pdwCount];

				DWORD i =0;
				while(SUCCEEDED(result = pEnum->Next( WBEM_INFINITE, 1, &pInstance, &dwNextReturned)) && dwNextReturned == 1)
				{
					// Get the ROOT_DN_PROPERTY, which has the instance
					BSTR strInstancePath = NULL;
					if(SUCCEEDED(result = CWBEMHelper::GetBSTRProperty(pInstance, ROOT_DN_PROPERTY, &strInstancePath)))
					{
						// Now get the object
						IWbemClassObject *pDNInstance = NULL;
						if(SUCCEEDED(result = m_IWbemServices->GetObject(strInstancePath, 0, pCtx, &pDNInstance, NULL)))
						{
							// Now get the DN_PROPERTY from the instance
							BSTR strRootDN = NULL;
							if(SUCCEEDED(result = CWBEMHelper::GetBSTRProperty(pDNInstance, DN_PROPERTY, &strRootDN)))
							{
								(*pppszRootDN)[i] = new WCHAR[wcslen(strRootDN) + 1];
								wcscpy((*pppszRootDN)[i], strRootDN);
								SysFreeString(strRootDN);

								i++;
							}
							pDNInstance->Release();
						}
						SysFreeString(strInstancePath);
					}
					pInstance->Release();
				}
				*pdwCount = i;
			}
		}
		else
			result = WBEM_E_FAILED; // To satisfy the return semantics of the function

		pEnum->Release();
	}
	SysFreeString(strQuery);
	return result;
}

// Process query for associations
HRESULT CLDAPInstanceProvider :: ProcessRootDSEGetObject(BSTR strClassName, IWbemObjectSink *pResponseHandler, IWbemContext *pCtx)
{
	HRESULT result = E_FAIL;

	// First get the object rom ADSI
	//==============================

	IADs *pADSIRootDSE = NULL;
	if(SUCCEEDED(result = ADsOpenObject((LPWSTR)ROOT_DSE_PATH, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IADs, (LPVOID *) &pADSIRootDSE)))
	{
		// Get the class to spawn an instance
		IWbemClassObject *pWbemClass = NULL;
		if(SUCCEEDED(result = m_IWbemServices->GetObject(strClassName, 0, pCtx, &pWbemClass, NULL)))
		{
			IWbemClassObject *pWBEMRootDSE = NULL;
			// Spawn a instance of the WBEM Class
			if(SUCCEEDED(result = pWbemClass->SpawnInstance(0, &pWBEMRootDSE)))
			{
				// Map it to WBEM
				if(SUCCEEDED(result = MapRootDSE(pADSIRootDSE, pWBEMRootDSE)))
				{
					// Indicate the result
					result = pResponseHandler->Indicate(1, &pWBEMRootDSE);
				}
				pWBEMRootDSE->Release();
			}
			pWbemClass->Release();
		}
		pADSIRootDSE->Release();
	}

	return result;
}


HRESULT CLDAPInstanceProvider :: MapRootDSE(IADs *pADSIRootDSE, IWbemClassObject *pWBEMRootDSE)
{
	// Map the properties one-by-one
	//=================================
	VARIANT variant;

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(SUBSCHEMASUBENTRY_STR, &variant)))
		pWBEMRootDSE->Put(SUBSCHEMASUBENTRY_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(SERVERNAME_STR, &variant)))
		pWBEMRootDSE->Put(SERVERNAME_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(DEFAULTNAMINGCONTEXT_STR, &variant)))
		pWBEMRootDSE->Put(DEFAULTNAMINGCONTEXT_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(SCHEMANAMINGCONTEXT_STR, &variant)))
		pWBEMRootDSE->Put(SCHEMANAMINGCONTEXT_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(CONFIGURATIONNAMINGCONTEXT_STR, &variant)))
		pWBEMRootDSE->Put(CONFIGURATIONNAMINGCONTEXT_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(ROOTDOMAINNAMINGCONTEXT_STR, &variant)))
		pWBEMRootDSE->Put(ROOTDOMAINNAMINGCONTEXT_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(CURRENTTIME_STR, &variant)))
		pWBEMRootDSE->Put(CURRENTTIME_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(SUPPORTEDVERSION_STR, &variant)))
		CWBEMHelper::PutBSTRArrayProperty(pWBEMRootDSE, SUPPORTEDVERSION_STR, &variant);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(NAMINGCONTEXTS_STR, &variant)))
		CWBEMHelper::PutBSTRArrayProperty(pWBEMRootDSE, NAMINGCONTEXTS_STR, &variant);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(SUPPORTEDCONTROLS_STR, &variant)))
		CWBEMHelper::PutBSTRArrayProperty(pWBEMRootDSE, SUPPORTEDCONTROLS_STR, &variant);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(DNSHOSTNAME_STR, &variant)))
		pWBEMRootDSE->Put(DNSHOSTNAME_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(DSSERVICENAME_STR, &variant)))
		pWBEMRootDSE->Put(DSSERVICENAME_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(HIGHESTCOMMITEDUSN_STR, &variant)))
		pWBEMRootDSE->Put(HIGHESTCOMMITEDUSN_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(LDAPSERVICENAME_STR, &variant)))
		pWBEMRootDSE->Put(LDAPSERVICENAME_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(SUPPORTEDCAPABILITIES_STR, &variant)))
		pWBEMRootDSE->Put(SUPPORTEDCAPABILITIES_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(SUPPORTEDLDAPPOLICIES_STR, &variant)))
		CWBEMHelper::PutBSTRArrayProperty(pWBEMRootDSE, SUPPORTEDLDAPPOLICIES_STR, &variant);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(SUPPORTEDSASLMECHANISMS_STR, &variant)))
		CWBEMHelper::PutBSTRArrayProperty(pWBEMRootDSE, SUPPORTEDSASLMECHANISMS_STR, &variant);
	VariantClear(&variant);

	return S_OK;
}

HRESULT CLDAPInstanceProvider :: DoSingleQuery(BSTR strClass, IWbemClassObject *pWbemClass, LPCWSTR pszRootDN, LPCWSTR pszLDAPQuery, IWbemObjectSink *pResponseHandler)
{
	// Initialize the return values
	HRESULT result = E_FAIL;

	// Bind to the node from which the search should start
	IDirectorySearch *pDirectorySearchContainer = NULL;
	if(SUCCEEDED(result = ADsOpenObject((LPWSTR)pszRootDN, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectorySearch, (LPVOID *)&pDirectorySearchContainer)))
	{
		try
		{
			// Now perform a search for the attribute DISTINGUISHED_NAME_ATTR name
			if(SUCCEEDED(result = pDirectorySearchContainer->SetSearchPreference(m_pSearchInfo, 2)))
			{
				ADS_SEARCH_HANDLE hADSSearchOuter;

				if(SUCCEEDED(result = pDirectorySearchContainer->ExecuteSearch((LPWSTR) pszLDAPQuery, (LPWSTR *)&ADS_PATH_ATTR, 1, &hADSSearchOuter)))
				{
					try
					{
						bool bDone = false;
						// Calculate the number of rows first. 
						while(!bDone && SUCCEEDED(result = pDirectorySearchContainer->GetNextRow(hADSSearchOuter)) &&
							result != S_ADS_NOMORE_ROWS)
						{
							CADSIInstance *pADSIInstance = NULL;

							// Get the columns for the attributes
							ADS_SEARCH_COLUMN adsColumn;

							// Store each of the LDAP class attributes 
							if(SUCCEEDED(pDirectorySearchContainer->GetColumn(hADSSearchOuter, (LPWSTR)ADS_PATH_ATTR, &adsColumn)))
							{
								try
								{
									// Protect against an ADSI bug
									if(adsColumn.pADsValues->dwType != ADSTYPE_PROV_SPECIFIC)
									{
										// Create the CADSIInstance
										if(SUCCEEDED(result = CLDAPHelper:: GetADSIInstance(adsColumn.pADsValues->DNString, &pADSIInstance, g_pLogObject)))
										{
											try
											{
												// Spawn a instance of the WBEM Class
												IWbemClassObject *pWbemInstance = NULL;
												if(SUCCEEDED(result = pWbemClass->SpawnInstance(0, &pWbemInstance)))
												{
													try
													{
														// Map it to WBEM
														if(SUCCEEDED(result = MapADSIInstance(pADSIInstance, pWbemInstance, pWbemClass)))
														{
															// Indicate the result
															if(FAILED(result = pResponseHandler->Indicate(1, &pWbemInstance)))
															{
																bDone = true;
																g_pLogObject->WriteW( L"CLDAPInstanceProvider :: CreateInstanceEnumAsync Indicate() FAILED with %x \r\n", result);
															}
														}
														else
															g_pLogObject->WriteW( L"CLDAPInstanceProvider :: CreateInstanceEnumAsync MapADSIInstance() FAILED with %x \r\n", result);
													}
													catch ( ... )
													{
														if ( pWbemInstance )
														{
															pWbemInstance->Release();
															pWbemInstance = NULL;
														}

														throw;
													}

													pWbemInstance->Release();
												}
											}
											catch ( ... )
											{
												if ( pADSIInstance )
												{
													pADSIInstance->Release();
													pADSIInstance = NULL;
												}

												throw;
											}

											pADSIInstance->Release();
										}
									}
								}
								catch ( ... )
								{
									pDirectorySearchContainer->FreeColumn( &adsColumn );
									throw;
								}

								// Free resouces
								pDirectorySearchContainer->FreeColumn( &adsColumn );
							}
						}
					}
					catch ( ... )
					{
						pDirectorySearchContainer->CloseSearchHandle(hADSSearchOuter);
						throw;
					}

					// Close the search. 
					pDirectorySearchContainer->CloseSearchHandle(hADSSearchOuter);

				} // ExecuteSearch() 
				else
					g_pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery ExecuteSearch() %s FAILED with %x\r\n", pszLDAPQuery, result);
			} // SetSearchPreference()
			else
				g_pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery SetSearchPreference() on %s FAILED with %x \r\n", pszLDAPQuery, result);
		}
		catch ( ... )
		{
			pDirectorySearchContainer->Release();
			throw;
		}

		pDirectorySearchContainer->Release();
	} // ADsOpenObject
	else
		g_pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery ADsOpenObject() on %s FAILED with %x \r\n", pszRootDN, result);

	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\ldapcach.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:ldapcach.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Cache for LDAP Schema objects. 
//
//***************************************************************************

#include "precomp.h"

// Initialize the statics
LPCWSTR CLDAPCache :: ROOT_DSE_PATH			= L"LDAP://RootDSE";
LPCWSTR CLDAPCache :: SCHEMA_NAMING_CONTEXT = L"schemaNamingContext";
LPCWSTR CLDAPCache :: LDAP_PREFIX			= L"LDAP://";	
LPCWSTR CLDAPCache :: LDAP_TOP_PREFIX		= L"LDAP://CN=top,";
LPCWSTR CLDAPCache :: RIGHT_BRACKET			= L")";
LPCWSTR CLDAPCache :: OBJECT_CATEGORY_EQUALS_ATTRIBUTE_SCHEMA	= L"(objectCategory=attributeSchema)";

DWORD CLDAPCache::dwLDAPCacheCount = 0;

//***************************************************************************
//
// CLDAPCache::CLDAPCache
//
// Purpose : Constructor. Fills in the cache with all the properties in LDAP.
//
// Parameters: 
//	dsLog : The CDSLog object  onto which logging will be done.
//***************************************************************************

CLDAPCache :: CLDAPCache()
{
	dwLDAPCacheCount++;
	m_isInitialized = FALSE;
	m_pDirectorySearchSchemaContainer = NULL;

	// Initialize the search preferences often used
	m_pSearchInfo[0].dwSearchPref		= ADS_SEARCHPREF_SEARCH_SCOPE;
	m_pSearchInfo[0].vValue.dwType		= ADSTYPE_INTEGER;
	m_pSearchInfo[0].vValue.Integer		= ADS_SCOPE_ONELEVEL;

	m_pSearchInfo[1].dwSearchPref		= ADS_SEARCHPREF_PAGESIZE;
	m_pSearchInfo[1].vValue.dwType		= ADSTYPE_INTEGER;
	m_pSearchInfo[1].vValue.Integer		= 64;

	/*
	m_pSearchInfo[2].dwSearchPref		= ADS_SEARCHPREF_CACHE_RESULTS;
	m_pSearchInfo[2].vValue.dwType		= ADSTYPE_BOOLEAN;
	m_pSearchInfo[2].vValue.Boolean		= 0;
	*/

	m_lpszSchemaContainerSuffix = NULL;
	m_lpszSchemaContainerPath = NULL;
	// Get the ADSI path of the schema container and store it for future use
	//========================================================================
	IADs *pRootDSE = NULL;
	HRESULT result;
	if(SUCCEEDED(result = ADsOpenObject((LPWSTR)ROOT_DSE_PATH, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IADs, (LPVOID *) &pRootDSE)))
	{
		// Get the location of the schema container
		BSTR strSchemaPropertyName = SysAllocString((LPWSTR) SCHEMA_NAMING_CONTEXT);


		// Get the schemaNamingContext property. This property contains the ADSI path
		// of the schema container
		VARIANT variant;
		VariantInit(&variant);
		if(SUCCEEDED(result = pRootDSE->Get(strSchemaPropertyName, &variant)))
		{
			// Store the ADSI path to the schema container
			m_lpszSchemaContainerSuffix = NULL;
			if(m_lpszSchemaContainerSuffix = new WCHAR[wcslen(variant.bstrVal) + 1])
			{
				wcscpy(m_lpszSchemaContainerSuffix, variant.bstrVal );
				g_pLogObject->WriteW( L"CLDAPCache :: Got Schema Container as : %s\r\n", m_lpszSchemaContainerSuffix);
			}

			// Form the schema container path
			//==================================
			m_lpszSchemaContainerPath = NULL;
			if(m_lpszSchemaContainerPath = new WCHAR[wcslen(LDAP_PREFIX) + wcslen(m_lpszSchemaContainerSuffix) + 1])
			{
				wcscpy(m_lpszSchemaContainerPath, LDAP_PREFIX);
				wcscat(m_lpszSchemaContainerPath, m_lpszSchemaContainerSuffix);
				
				m_isInitialized = TRUE;
				/*
				if(SUCCEEDED(result = ADsOpenObject(m_lpszSchemaContainerPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectorySearch, (LPVOID *) &m_pDirectorySearchSchemaContainer)))
				{

					g_pLogObject->WriteW( L"CLDAPCache :: Got IDirectorySearch on Schema Container \r\n");

					if(SUCCEEDED(result = InitializeObjectTree()))
					{
							m_isInitialized = TRUE;
					}
					else
						g_pLogObject->WriteW( L"CLDAPCache :: InitializeObjectTree() FAILED : %x \r\n", result);
				}
				else
					g_pLogObject->WriteW( L"CLDAPCache :: FAILED to get IDirectorySearch on Schema Container : %x\r\n", result);
				*/
			}
		}
		else
			g_pLogObject->WriteW( L"CLDAPCache :: Get on RootDSE FAILED : %x\r\n", result);

		SysFreeString(strSchemaPropertyName);
		VariantClear(&variant);
		pRootDSE->Release();

	}
	else
		g_pLogObject->WriteW( L"CLDAPClassProvider :: InitializeLDAPProvider ADsOpenObject on RootDSE FAILED : %x\r\n", result);

}

//***************************************************************************
//
// CLDAPCache::~CLDAPCache
//
// Purpose : Destructor 
//
//***************************************************************************

CLDAPCache :: ~CLDAPCache()
{
	dwLDAPCacheCount--;
	if(m_pDirectorySearchSchemaContainer)
		m_pDirectorySearchSchemaContainer->Release();

	delete [] m_lpszSchemaContainerSuffix;
	delete [] m_lpszSchemaContainerPath;
}

//***************************************************************************
//
// CLDAPCache::GetProperty
//
// Purpose : Retreives the IDirectory interface of an LDAP property
//
// Parameters: 
//	lpszPropertyName : The name of the LDAP Property to be retreived
//	ppADSIProperty : The address of the pointer where the CADSIProperty object will be placed
//	bWBEMName : True if the lpszPropertyName is the WBEM name. False, if it is the LDAP name
//
//	Return value:
//		The COM value representing the return status. The user should release the object when done.
//		
//***************************************************************************
HRESULT CLDAPCache :: GetProperty(LPCWSTR lpszPropertyName, CADSIProperty **ppADSIProperty, BOOLEAN bWBEMName)
{
	HRESULT result = E_FAIL;

	// Get the LDAP property name from the WBEM class name
	LPWSTR lpszLDAPPropertyName = NULL;
	if(bWBEMName)
		lpszLDAPPropertyName = CLDAPHelper::UnmangleWBEMNameToLDAP(lpszPropertyName);
	else
		lpszLDAPPropertyName = (LPWSTR)lpszPropertyName; // Save a copy by casting, be careful when deleting

	try
	{
		// This is a cached implementation
		// Check the object tree first
		//===================================

		if((*ppADSIProperty) = (CADSIProperty *) m_objectTree.GetElement(lpszLDAPPropertyName))
		{
			// Found it in the tree. Nothing more to be done. It has already been 'addreff'ed
			result = S_OK;
		}
		else // Get it from ADSI 
		{
			if(!m_pDirectorySearchSchemaContainer)
			{
				if(!SUCCEEDED(result = ADsOpenObject(m_lpszSchemaContainerPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectorySearch, (LPVOID *) &m_pDirectorySearchSchemaContainer)))
					result = E_FAIL;
			}
			else
				result = S_OK;

			if(SUCCEEDED(result))
			{
				// Search for the property
				LPWSTR lpszQuery = NULL;
				if(lpszQuery = new WCHAR[ wcslen(OBJECT_CATEGORY_EQUALS_ATTRIBUTE_SCHEMA) + wcslen(LDAP_DISPLAY_NAME_ATTR) + wcslen(lpszLDAPPropertyName) + 20])
				{
					try
					{
						wcscpy(lpszQuery, LEFT_BRACKET_STR);
						wcscat(lpszQuery, AMPERSAND_STR);
						wcscat(lpszQuery, OBJECT_CATEGORY_EQUALS_ATTRIBUTE_SCHEMA);
						wcscat(lpszQuery, LEFT_BRACKET_STR);
						wcscat(lpszQuery, LDAP_DISPLAY_NAME_ATTR);
						wcscat(lpszQuery, EQUALS_STR);
						wcscat(lpszQuery, lpszLDAPPropertyName);
						wcscat(lpszQuery, RIGHT_BRACKET_STR);
						wcscat(lpszQuery, RIGHT_BRACKET_STR);

						ADS_SEARCH_HANDLE hADSSearchOuter;
						if(SUCCEEDED(result = m_pDirectorySearchSchemaContainer->ExecuteSearch(lpszQuery, NULL, -1, &hADSSearchOuter)))
						{
							try
							{
								if(SUCCEEDED(result = m_pDirectorySearchSchemaContainer->GetNextRow(hADSSearchOuter)) &&
									result != S_ADS_NOMORE_ROWS)
								{
									*ppADSIProperty = NULL;
									if(*ppADSIProperty = new CADSIProperty())
									{
										try
										{
											// Fill in the details of the property
											if(SUCCEEDED(result = FillInAProperty(*ppADSIProperty, hADSSearchOuter)))
											{
												// Add the property to the tree
												m_objectTree.AddElement((*ppADSIProperty)->GetADSIPropertyName(), *ppADSIProperty);
												// No need to release it since we're returning it
											}
											else
											{
												delete *ppADSIProperty;
												*ppADSIProperty = NULL;
											}
										}
										catch ( ... )
										{
											delete *ppADSIProperty;
											*ppADSIProperty = NULL;

											throw;
										}
									}
									else
										result = E_OUTOFMEMORY;
								}
							}
							catch ( ... )
							{
								m_pDirectorySearchSchemaContainer->CloseSearchHandle(hADSSearchOuter);
								throw;
							}

							m_pDirectorySearchSchemaContainer->CloseSearchHandle(hADSSearchOuter);
						}
					}
					catch ( ... )
					{
						delete [] lpszQuery;
						throw;
					}

					delete [] lpszQuery;
				}
				else
					result = E_OUTOFMEMORY;
			}
		}
	}
	catch ( ... )
	{
		if(bWBEMName)
		{
			delete[] lpszLDAPPropertyName;
			lpszLDAPPropertyName = NULL;
		}
		throw;
	}

	// Delete only what was allocated in this function
	//================================================
	if(bWBEMName)
	{
		delete[] lpszLDAPPropertyName;
		lpszLDAPPropertyName = NULL;
	}

	return result;
}

//***************************************************************************
//
// CLDAPCache::GetClass
//
// Purpose : See Header File
//		
//***************************************************************************
HRESULT CLDAPCache :: GetClass(LPCWSTR lpszWBEMClassName, LPCWSTR lpszLDAPClassName, CADSIClass **ppADSIClass)
{
	/************************************************************
	*************************************************************
	***** NO Cache implementation for now. Always fetch everytime
	*************************************************************
	*************************************************************/

	*ppADSIClass = NULL;
	if(!(*ppADSIClass = new CADSIClass(lpszWBEMClassName, lpszLDAPClassName)) )
		return E_OUTOFMEMORY;
	

	HRESULT result = E_FAIL;

	try
	{
		if(!m_pDirectorySearchSchemaContainer)
		{
			if(!SUCCEEDED(result = ADsOpenObject(m_lpszSchemaContainerPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectorySearch, (LPVOID *) &m_pDirectorySearchSchemaContainer)))
				result = E_FAIL;
		}
		else
			result = S_OK;

		if(SUCCEEDED(result))
		{
			result = CLDAPHelper::GetLDAPClassFromLDAPName(m_pDirectorySearchSchemaContainer,
				m_lpszSchemaContainerSuffix,
				m_pSearchInfo,
				2,
				*ppADSIClass
				);
		}
	}
	catch ( ... )
	{
		// at least GetLDAPClassFromLDAPName throws
		delete *ppADSIClass;
		*ppADSIClass = NULL;

		throw;
	}

	if(!SUCCEEDED(result))
	{
		delete *ppADSIClass;
		*ppADSIClass = NULL;
	}

	return result;
}

//***************************************************************************
//
// CLDAPCache::GetSchemaContainerSearch
//
// Purpose : To return the IDirectorySearch interface on the schema container
//
// Parameters:
//	ppDirectorySearch : The address where the pointer to the required interface will
//		be stored.
//
// 
//	Return Value: The COM result representing the status. The user should release
//	the interface pointer when done with it.
//***************************************************************************
HRESULT CLDAPCache :: GetSchemaContainerSearch(IDirectorySearch ** ppDirectorySearch)
{
	if(m_pDirectorySearchSchemaContainer)
	{
		*ppDirectorySearch = m_pDirectorySearchSchemaContainer;
		(*ppDirectorySearch)->AddRef();
		return S_OK;
	}
	else
		return E_FAIL;

}

//***************************************************************************
//
// CLDAPCache::EnumerateClasses
//
// Purpose : See Header
//		
//***************************************************************************
HRESULT CLDAPCache::EnumerateClasses(LPCWSTR lpszWBEMSuperclass,
	BOOLEAN bDeep,
	LPWSTR **pppADSIClasses,
	DWORD *pdwNumRows,
	BOOLEAN bArtificialClass)
{
	// Get the LDAP name of the super class
	// Do not mangle if it one of the classes that we know
	//=====================================================
	LPWSTR lpszLDAPSuperClassName = NULL;
	if(_wcsicmp(lpszWBEMSuperclass, LDAP_BASE_CLASS) != 0)
	{
		lpszLDAPSuperClassName = CLDAPHelper::UnmangleWBEMNameToLDAP(lpszWBEMSuperclass);
		if(!lpszLDAPSuperClassName) // We were returned a NULL by the Unmangler, so not a DS class
		{
			*pppADSIClasses = NULL;
			*pdwNumRows = 0;
			return S_OK;
		}
	}

	HRESULT result = E_FAIL;
	if(!m_pDirectorySearchSchemaContainer)
	{
		if(!SUCCEEDED(result = ADsOpenObject(m_lpszSchemaContainerPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectorySearch, (LPVOID *) &m_pDirectorySearchSchemaContainer)))
			result = E_FAIL;
	}
	else
		result = S_OK;

	if(SUCCEEDED(result))
	{
		result = CLDAPHelper::EnumerateClasses(m_pDirectorySearchSchemaContainer, 
							m_lpszSchemaContainerSuffix, 
							m_pSearchInfo,
							2,
							lpszLDAPSuperClassName, 
							bDeep, 
							pppADSIClasses, 
							pdwNumRows,
							bArtificialClass);
	}

	// If the superclass is an artificial class like "ADS_User", then a concrete sub-class "DS_User" exists.
	// This is added manually here, to both the EnumInfoList as well as the structure being returned
	// The above call to EnumerateClasses would have helpfully left an extra element unfilled at the beginning
	// of the array
	if(SUCCEEDED(result) && bArtificialClass)
	{
		(*pppADSIClasses)[0] = NULL;
		if((*pppADSIClasses)[0] = new WCHAR[wcslen(lpszWBEMSuperclass+1) + 1])
			wcscpy((*pppADSIClasses)[0], lpszWBEMSuperclass+1); 
		else
			result = E_OUTOFMEMORY;
	}

	delete[] lpszLDAPSuperClassName;
	return result;
}

//***************************************************************************
//
// CLDAPCache::IsInitialized
//
// Purpose : Indicates whether the cache was created and initialized succeddfully
//
// Parameters: 
//	None
//
//	Return value:
//		A boolean value indicating the status
//		
//***************************************************************************

BOOLEAN CLDAPCache :: IsInitialized()
{
	return m_isInitialized;
}




//***************************************************************************
//
// CLDAPCache :: InitializeObjectTree
//
// Purpose : Initialize the lexically ordered binary tree with all the properties 
//	LDAP
//
// Parameters:
//	None
// 
//	Return Value: The COM status representing the return value
//***************************************************************************

HRESULT CLDAPCache :: InitializeObjectTree()
{
	// Get the attributes of all the instances of the
	// class "AttributeSchema"
	//=================================================
	HRESULT result = E_FAIL;

/*
	// Now perform a search for all the attributes
	//============================================
	if(SUCCEEDED(result = m_pDirectorySearchSchemaContainer->SetSearchPreference(m_pSearchInfo, 2)))
	{
		ADS_SEARCH_HANDLE hADSSearchOuter;
		
		// Count of attributes
		DWORD dwCount = 0;

		if(SUCCEEDED(result = m_pDirectorySearchSchemaContainer->ExecuteSearch((LPWSTR)OBJECT_CATEGORY_EQUALS_ATTRIBUTE_SCHEMA, NULL, -1, &hADSSearchOuter)))
		{
			CADSIProperty *pNextProperty;
			while(SUCCEEDED(result = m_pDirectorySearchSchemaContainer->GetNextRow(hADSSearchOuter)) &&
				result != S_ADS_NOMORE_ROWS)
			{
				pNextProperty = new CADSIProperty();
				dwCount ++;

				// Fill in the details of the property
				FillInAProperty(pNextProperty, hADSSearchOuter);

				// Add the property to the tree
				m_objectTree.AddElement(pNextProperty->GetADSIPropertyName(), pNextProperty);
				pNextProperty->Release();
			}
			m_pDirectorySearchSchemaContainer->CloseSearchHandle(hADSSearchOuter);
		}

		g_pLogObject->WriteW( L"CLDAPCache :: InitializeObjectTree() Initialized with %d attributes\r\n", dwCount);
	}
	else
		g_pLogObject->WriteW( L"CLDAPCache :: InitializeObjectTree() SetSearchPreference() FAILED with %x\r\n", result);

*/
	return result;
}

HRESULT CLDAPCache :: FillInAProperty(CADSIProperty *pNextProperty, ADS_SEARCH_HANDLE hADSSearchOuter)
{
	ADS_SEARCH_COLUMN adsNextColumn;
	HRESULT result = E_FAIL;
	LPWSTR lpszWBEMName = NULL;
	BOOLEAN bNeedToCheckForORName = FALSE;
	if(SUCCEEDED(result = m_pDirectorySearchSchemaContainer->GetColumn( hADSSearchOuter, (LPWSTR)ATTRIBUTE_SYNTAX_ATTR, &adsNextColumn )))
	{
		if(adsNextColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
			result = E_FAIL;
		else
		{
			pNextProperty->SetSyntaxOID(adsNextColumn.pADsValues->CaseIgnoreString);
			if(_wcsicmp(adsNextColumn.pADsValues->CaseIgnoreString, DN_WITH_BINARY_OID) == 0)
				bNeedToCheckForORName = TRUE;
		}
		m_pDirectorySearchSchemaContainer->FreeColumn( &adsNextColumn );
	}

	if(SUCCEEDED(result) && SUCCEEDED(result = m_pDirectorySearchSchemaContainer->GetColumn( hADSSearchOuter, (LPWSTR)IS_SINGLE_VALUED_ATTR, &adsNextColumn )))
	{
		if(adsNextColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
			result = E_FAIL;
		else
			pNextProperty->SetMultiValued( (adsNextColumn.pADsValues->Boolean)? FALSE : TRUE);
		m_pDirectorySearchSchemaContainer->FreeColumn( &adsNextColumn );
	}

	if(SUCCEEDED(result) && SUCCEEDED(result = m_pDirectorySearchSchemaContainer->GetColumn( hADSSearchOuter, (LPWSTR)ATTRIBUTE_ID_ATTR, &adsNextColumn )))
	{
		if(adsNextColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
			result = E_FAIL;
		else
			pNextProperty->SetAttributeID(adsNextColumn.pADsValues->CaseIgnoreString);
		m_pDirectorySearchSchemaContainer->FreeColumn( &adsNextColumn );
	}

	if(SUCCEEDED(result) && SUCCEEDED(result = m_pDirectorySearchSchemaContainer->GetColumn( hADSSearchOuter, (LPWSTR)COMMON_NAME_ATTR, &adsNextColumn )))
	{
		if(adsNextColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
			result = E_FAIL;
		else
			pNextProperty->SetCommonName(adsNextColumn.pADsValues->CaseIgnoreString);
		m_pDirectorySearchSchemaContainer->FreeColumn( &adsNextColumn );
	}

	if(SUCCEEDED(result) && SUCCEEDED(result = m_pDirectorySearchSchemaContainer->GetColumn( hADSSearchOuter, (LPWSTR)LDAP_DISPLAY_NAME_ATTR, &adsNextColumn )))
	{
		if(adsNextColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
			result = E_FAIL;
		else
		{
			pNextProperty->SetADSIPropertyName(adsNextColumn.pADsValues->CaseIgnoreString);
			lpszWBEMName = CLDAPHelper::MangleLDAPNameToWBEM(adsNextColumn.pADsValues->CaseIgnoreString);
			pNextProperty->SetWBEMPropertyName(lpszWBEMName);
			delete []lpszWBEMName;
		}
		m_pDirectorySearchSchemaContainer->FreeColumn( &adsNextColumn );
	}

	if(SUCCEEDED(result) && SUCCEEDED(m_pDirectorySearchSchemaContainer->GetColumn( hADSSearchOuter, (LPWSTR)MAPI_ID_ATTR, &adsNextColumn )))
	{
		if(adsNextColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
			result = E_FAIL;
		else
			pNextProperty->SetMAPI_ID(adsNextColumn.pADsValues->Integer);
		m_pDirectorySearchSchemaContainer->FreeColumn( &adsNextColumn );
	}

	if(SUCCEEDED(result) && SUCCEEDED(result = m_pDirectorySearchSchemaContainer->GetColumn( hADSSearchOuter, (LPWSTR)OM_SYNTAX_ATTR, &adsNextColumn )))
	{
		if(adsNextColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
			result = E_FAIL;
		else
			pNextProperty->SetOMSyntax(adsNextColumn.pADsValues->Integer);
		m_pDirectorySearchSchemaContainer->FreeColumn( &adsNextColumn );
	}

	if(bNeedToCheckForORName && SUCCEEDED(result) && SUCCEEDED(m_pDirectorySearchSchemaContainer->GetColumn( hADSSearchOuter, (LPWSTR)OM_OBJECT_CLASS_ATTR, &adsNextColumn )))
	{
		if(adsNextColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
			result = E_FAIL;
		else
		{
			// Just the first octet in the LPBYTE array is enough for differntiating between ORName and DNWithBinary
			if((adsNextColumn.pADsValues->OctetString).lpValue[0] == 0x56)
				pNextProperty->SetORName(TRUE);
		}
		m_pDirectorySearchSchemaContainer->FreeColumn( &adsNextColumn );
	}

	if(SUCCEEDED(result) && SUCCEEDED(m_pDirectorySearchSchemaContainer->GetColumn( hADSSearchOuter, (LPWSTR)SEARCH_FLAGS_ATTR, &adsNextColumn )))
	{
		if(adsNextColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
			result = E_FAIL;
		else
			pNextProperty->SetSearchFlags(adsNextColumn.pADsValues->Integer);
		m_pDirectorySearchSchemaContainer->FreeColumn( &adsNextColumn );
	}

	if(SUCCEEDED(result) && SUCCEEDED(m_pDirectorySearchSchemaContainer->GetColumn( hADSSearchOuter, (LPWSTR)SYSTEM_ONLY_ATTR, &adsNextColumn )))
	{
		if(adsNextColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
			result = E_FAIL;
		else
			pNextProperty->SetSystemOnly(TRUE);
		m_pDirectorySearchSchemaContainer->FreeColumn( &adsNextColumn );
	}

	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\instprov.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 9/16/98 4:43p $
// 	$Workfile:instprov.h $
//
//	$Modtime: 9/16/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the DS Instance Provider class. 
//
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef DS_INSTANCE_PROVIDER_H
#define DS_INSTANCE_PROVIDER_H

// Forward declaration for the initializer class
class CDSInstanceProviderInitializer;

class CLDAPInstanceProvider : public IWbemProviderInit, public IWbemServices
{
	// The initialization class is a friend of this class
	friend CDSInstanceProviderInitializer;

public:

	// Create the object 
    CLDAPInstanceProvider () ;
    virtual ~CLDAPInstanceProvider () ;

	////////////////////////////////////////
	//IUnknown members
	////////////////////////////////////////
	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;


	////////////////////////////////////////
	//IWbemProviderInit members
	////////////////////////////////////////
	virtual HRESULT STDMETHODCALLTYPE Initialize( 
            LPWSTR wszUser,
            LONG lFlags,
            LPWSTR wszNamespace,
            LPWSTR wszLocale,
            IWbemServices __RPC_FAR *pNamespace,
            IWbemContext __RPC_FAR *pCtx,
            IWbemProviderInitSink __RPC_FAR *pInitSink) ;

		
	////////////////////////////////////////
	//IWbemServices members
	////////////////////////////////////////
    virtual HRESULT STDMETHODCALLTYPE OpenNamespace( 
        /* [in] */ const BSTR strNamespace,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult);
    
    virtual HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink);
    
    virtual HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE GetObject( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE GetObjectAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE PutClass( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE PutClassAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteClass( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE CreateClassEnum( 
        /* [in] */ const BSTR strSuperclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
        /* [in] */ const BSTR strSuperclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE PutInstance( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteInstance( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE ExecQuery( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE ExecMethod( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ const BSTR strMethodName,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ const BSTR strMethodName,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

protected:

	// The IWbemServices pointer stored from Initialize()
	IWbemServices *m_IWbemServices;

	// SHows whether the call to Initialize() was successful
	BOOLEAN m_bInitializedSuccessfully;

	// The IWbemClassObject pointer to the Uint8ArrayClass
	IWbemClassObject *m_pWbemUin8ArrayClass;

	// The IWbemClassObject pointer to the DNWithBinaryClass
	IWbemClassObject *m_pWbemDNWithBinaryClass;

	// The IWbemClassObject pointer to the DNWithStringClass
	IWbemClassObject *m_pWbemDNWithStringClass;

	// The IWbemClassObject interface to the associations class
	IWbemClassObject *m_pAssociationsClass;

	// The path to the top level container
	LPWSTR m_lpszTopLevelContainerPath;

	// Gets the IDIrectoryObject interface on an ADSI instance
	HRESULT MapPropertyValueToWBEM(BSTR strWbemName, IWbemClassObject *pWbemClass, IWbemClassObject *pWbemObject, PADS_ATTR_INFO pAttribute);

	//***************************************************************************
	//
	// CLDAPInstanceProvider::IsContainedIn
	//
	// Purpose: Checks whether a containment is valid
	//
	// Parameters: 
	//	pszChildInstance : The WBEM Name of the child class
	//	pszParentInstance : The WBEM Name of the parent class
	//
	// Return Value: The COM status of the request
	//
	//***************************************************************************
	HRESULT IsContainedIn(LPCWSTR pszChildInstance, LPCWSTR pszParentInstance);

	//***************************************************************************
	//
	// CLDAPInstanceProvider::CreateInstance
	//
	// Purpose: Checks whether a containment is valid
	//
	// Parameters: 
	//	strChildName : The WBEM Name of the child instance
	//	strParentName : The WBEM Name of the parent instance
	//
	// Return Value: The COM status of the request. THe user should free the returned 
	//	IWbemClassObject when done.
	//
	//***************************************************************************
	HRESULT CreateWBEMInstance(BSTR strChildName, BSTR strParentName, IWbemClassObject **ppInstance);

	//***************************************************************************
	//
	// CLDAPInstanceProvider::ModifyExistingADSIInstance
	//
	// Purpose: Modify an existing ADSI Object using information from the WBEM object
	//
	// Parameters: 
	//	pWbemInstance : The WBEM instance being mapped
	//	pszADSIPath : The path to the ADSI instance
	//	pExistingObject : The CADSIInstance pointer on the existing instance
	//	pszADSIClass : The ADSI class name of the new instance
	//
	// Return Value: The COM status of the request. 
	//
	//***************************************************************************
	HRESULT ModifyExistingADSIInstance(IWbemClassObject *pWbemInstance, LPCWSTR pszADSIPath, CADSIInstance *pExistingObject, LPCWSTR pszADSIClass, IWbemContext *pCtx);

	//***************************************************************************
	//
	// CLDAPInstanceProvider::CreateNewADSIInstance
	//
	// Purpose: To create a new ADSI instance form a WBEM instance
	//
	// Parameters: 
	//	pWbemInstance : The WBEM instance being mapped
	//	pszADSIPath : The path to the new ADSI instance
	//	pszADSIClass : The ADSI class name of the new instance
	//
	// Return Value: The COM status of the request. 
	//
	//***************************************************************************
	HRESULT CreateNewADSIInstance(IWbemClassObject *pWbemInstance, LPCWSTR pszADSIPath, LPCWSTR pszADSIClass);

	//***************************************************************************
	//
	// CLDAPInstanceProvider::MapPropertyValueToADSI
	//
	// Purpose: To map a WBEM property to ADSI
	//
	//	strPropertyName : The WBEM name of the property
	//	vPropertyValue : The variant representing the proeprty value
	//	cType : The CIMTYPE of the property
	//	lFlavour : The WBEM flavour of the proeprty
	//	pAttributeEntry : A pointer to an ADS_ATTR_INFO structure that will be filled in.
	//
	//***************************************************************************
	HRESULT MapPropertyValueToADSI(IWbemClassObject *pWbemInstance, BSTR strPropertyName, VARIANT vPropertyValue, CIMTYPE cType, LONG lFlavour,  PADS_ATTR_INFO pAttributeEntry);

	//***************************************************************************
	//
	// CLDAPInstanceProvider::DoChildContainmentQuery
	//
	// Purpose: Find the parent of a given child and create an association class
	//
	// Parameters: 
	//	pszChildPath : The ADSI path of the child instance
	//	pResponseHandler : A sink on which the resulting objects are indicated
	//	pListIndicatedSoFar : To avoid duplicate indications (WinMgmt will lot filter them), a
	//		list of objects indicated so far is kept. Any objects in this list are
	//		not indicated again
	//
	// Return Value: The COM status of the request. 
	//
	//***************************************************************************
	HRESULT DoChildContainmentQuery(LPCWSTR pszChildPath, IWbemObjectSink *pResponseHandler, CNamesList *pListIndicatedSoFar);

	//***************************************************************************
	//
	// CLDAPInstanceProvider::DoParentContainmentQuery
	//
	// Purpose: Enumerate the children of a given parent and create association classes
	//
	// Parameters: 
	//	pszParentPath : The ADSI path of the parent instance
	//	pResponseHandler : A sink on which the resulting objects are indicated
	//	pListIndicatedSoFar : To avoid duplicate indications (WinMgmt will lot filter them), a
	//		list of objects indicated so far is kept. Any objects in this list are
	//		not indicated again
	//
	// Return Value: The COM status of the request. 
	//
	//***************************************************************************
	HRESULT DoParentContainmentQuery(LPCWSTR pszParentPath, IWbemObjectSink *pResponseHandler, CNamesList *pListIndicatedSoFar);

	// Maps an ADSI Instance to WBEM
	HRESULT MapADSIInstance(CADSIInstance *pADSInstance, IWbemClassObject *pWbemClass, IWbemClassObject *pWbemObject);


private:

	// The COM Reference count
    long m_lReferenceCount ;

	// These are the search preferences often used
	ADS_SEARCHPREF_INFO m_pSearchInfo[2];

	// A query for getting the DN associators of a class
    static LPCWSTR QUERY_FORMAT;
    static BSTR QUERY_LANGUAGE;
    static BSTR DN_PROPERTY;
    static BSTR ROOT_DN_PROPERTY;

	// Some literals
	static LPCWSTR DEFAULT_NAMING_CONTEXT_ATTR;
	static LPCWSTR OBJECT_CLASS_EQUALS;
	static BSTR CLASS_STR;
	static BSTR ADSI_PATH_STR;
	static BSTR UINT8ARRAY_STR;
	static BSTR	DN_WITH_BINARY_CLASS_STR;
	static BSTR	DN_WITH_STRING_CLASS_STR;
	static BSTR VALUE_PROPERTY_STR;
	static BSTR DN_STRING_PROPERTY_STR;
	static BSTR INSTANCE_ASSOCIATION_CLASS_STR;
	static BSTR CHILD_INSTANCE_PROPERTY_STR;
	static BSTR PARENT_INSTANCE_PROPERTY_STR;
	static BSTR RELPATH_STR;
	static BSTR ATTRIBUTE_SYNTAX_STR;
	static BSTR DEFAULT_OBJECT_CATEGORY_STR;
	static BSTR LDAP_DISPLAY_NAME_STR;
	static BSTR PUT_EXTENSIONS_STR;
	static BSTR PUT_EXT_PROPERTIES_STR;
	static BSTR CIMTYPE_STR;
	// Properties of LDAP://RootDSE
	static BSTR SUBSCHEMASUBENTRY_STR;
	static BSTR CURRENTTIME_STR;
	static BSTR SERVERNAME_STR;
	static BSTR NAMINGCONTEXTS_STR;
	static BSTR DEFAULTNAMINGCONTEXT_STR;
	static BSTR SCHEMANAMINGCONTEXT_STR;
	static BSTR CONFIGURATIONNAMINGCONTEXT_STR;
	static BSTR ROOTDOMAINNAMINGCONTEXT_STR;
	static BSTR SUPPORTEDCONTROLS_STR;
	static BSTR SUPPORTEDVERSION_STR;
	static BSTR DNSHOSTNAME_STR;
	static BSTR DSSERVICENAME_STR;
	static BSTR HIGHESTCOMMITEDUSN_STR;
	static BSTR LDAPSERVICENAME_STR;
	static BSTR SUPPORTEDCAPABILITIES_STR;
	static BSTR SUPPORTEDLDAPPOLICIES_STR;
	static BSTR SUPPORTEDSASLMECHANISMS_STR;


	// Process query for DS Associations
	HRESULT ProcessAssociationQuery( 
		IWbemContext __RPC_FAR *pCtx,
		IWbemObjectSink __RPC_FAR *pResponseHandler,
		SQL1_Parser *pParser);

	// Process Query for DS Instances
	HRESULT ProcessInstanceQuery( 
		BSTR strClass,
		BSTR strQuery,
		IWbemContext __RPC_FAR *pCtx,
		IWbemObjectSink __RPC_FAR *pResponseHandler,
		SQL1_Parser *pParser);
	
	// COnverts a WQL query to an LDAP Filter. If possible
	HRESULT ConvertWQLToLDAPQuery(SQL_LEVEL_1_RPN_EXPRESSION *pExp, LPWSTR pszLDAPQuery);

	// Does a query on a specified Root DN
	HRESULT DoSingleQuery(BSTR strClass, IWbemClassObject *pWbemClass, LPCWSTR pszRootDN, LPCWSTR pszLDAPQuery, IWbemObjectSink *pResponseHandler);

	// Gets any static configuration data for enumerating/querying a given class
	HRESULT GetRootDN( LPCWSTR pszClass, LPWSTR **ppszRootDN, DWORD *pdwCount, IWbemContext *pCtx);

	HRESULT MapEmbeddedObjectToWBEM(PADSVALUE pAttribute, LPCWSTR pszQualifierName, IUnknown **ppEmbeddedObject);
	HRESULT MapUint8ArrayToWBEM(PADSVALUE pAttribute, IUnknown **ppEmbeddedObject);
	HRESULT MapDNWithBinaryToWBEM(PADSVALUE pAttribute, IUnknown **ppEmbeddedObject);
	HRESULT MapDNWithStringToWBEM(PADSVALUE pAttribute, IUnknown **ppEmbeddedObject);
	HRESULT MapByteArray(LPBYTE lpBinaryValue, DWORD dwLength, const BSTR strPropertyName, IWbemClassObject *pInstance);

	HRESULT ProcessRootDSEGetObject(BSTR strClassName, IWbemObjectSink *pResponseHandler, IWbemContext *pCtx);
	HRESULT MapRootDSE(IADs *pADSIRootDSE, IWbemClassObject *pWBEMRootDSE);

	//***************************************************************************
	//
	// CLDAPInstanceProvider::SetStringValues
	//
	// Purpose: See Header File
	//
	//***************************************************************************
	HRESULT SetStringValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue);
	
	//***************************************************************************
	//
	// CLDAPInstanceProvider::SetBooleanValues
	//
	// Purpose: See Header File
	//
	//***************************************************************************
	HRESULT SetBooleanValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue);
	
	//***************************************************************************
	//
	// CLDAPInstanceProvider::SetIntegerValues
	//
	// Purpose: See Header File
	//
	//***************************************************************************
	HRESULT SetIntegerValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue);

	
	//***************************************************************************
	//
	// CLDAPInstanceProvider::SetOctetStringValues
	//
	// Purpose: See Header File
	//
	//***************************************************************************
	HRESULT SetOctetStringValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue);
	HRESULT SetDNWithBinaryValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue);
	HRESULT SetDNWithStringValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue);
	
	//***************************************************************************
	//
	// CLDAPInstanceProvider::SetStringValues
	//
	// Purpose: See Header File
	//
	//***************************************************************************
	HRESULT SetTimeValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue);


	//***************************************************************************
	//
	// CLDAPInstanceProvider::SetStringValues
	//
	// Purpose: See Header File
	//
	//***************************************************************************
	HRESULT SetLargeIntegerValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue);

	//***************************************************************************
	//
	// CLDAPInstanceProvider::SetObjectClassAttribute
	//
	// Purpose: See Header File
	//
	//***************************************************************************
	void SetObjectClassAttribute(PADS_ATTR_INFO pAttributeEntry, LPCWSTR pszADSIClassName);
};


#endif // DS_INSTANCE_PROVIDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\instproi.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:instproi.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $
//	$Nokeywords:  $
//
//
//  Description: Contains implementation of the class that is used to initialize the
//	CLDAPInstanceProvider class
//
//***************************************************************************

#include "precomp.h"


//***************************************************************************
//
// CDSInstanceProviderInitializer::CDSInstanceProviderInitializer
//
// Constructor Parameters:
//		None
//
//
//***************************************************************************

CDSInstanceProviderInitializer :: CDSInstanceProviderInitializer ()
{
	CLDAPInstanceProvider :: CLASS_STR						= SysAllocString(L"__CLASS");
	CLDAPInstanceProvider :: DN_PROPERTY					= SysAllocString(L"DN");
	CLDAPInstanceProvider :: ROOT_DN_PROPERTY				= SysAllocString(L"RootDNForSearchAndQuery");
	CLDAPInstanceProvider :: QUERY_LANGUAGE					= SysAllocString(L"WQL");
	CLDAPInstanceProvider :: RELPATH_STR					= SysAllocString(L"__RELPATH");
	CLDAPInstanceProvider :: VALUE_PROPERTY_STR				= SysAllocString(L"value");
	CLDAPInstanceProvider :: DN_STRING_PROPERTY_STR			= SysAllocString(L"dnString");
	CLDAPInstanceProvider :: UINT8ARRAY_STR					= SysAllocString(L"Uint8Array");
	CLDAPInstanceProvider :: DN_WITH_BINARY_CLASS_STR		= SysAllocString(L"DN_With_Binary");
	CLDAPInstanceProvider :: DN_WITH_STRING_CLASS_STR		= SysAllocString(L"DN_With_String");
	CLDAPInstanceProvider :: ADSI_PATH_STR					= SysAllocString(ADSI_PATH_ATTR);
	CLDAPInstanceProvider :: INSTANCE_ASSOCIATION_CLASS_STR	= SysAllocString(INSTANCE_ASSOCIATION_CLASS);
	CLDAPInstanceProvider :: CHILD_INSTANCE_PROPERTY_STR	= SysAllocString(L"ChildInstance");
	CLDAPInstanceProvider :: PARENT_INSTANCE_PROPERTY_STR	= SysAllocString(L"ParentInstance");
	CLDAPInstanceProvider :: ATTRIBUTE_SYNTAX_STR			= SysAllocString(L"attributeSyntax");
	CLDAPInstanceProvider :: DEFAULT_OBJECT_CATEGORY_STR	= SysAllocString(L"defaultObjectCategory");
	CLDAPInstanceProvider :: LDAP_DISPLAY_NAME_STR			= SysAllocString(L"ldapDisplayName");
	CLDAPInstanceProvider :: PUT_EXTENSIONS_STR				= SysAllocString(L"__PUT_EXTENSIONS");
	CLDAPInstanceProvider :: PUT_EXT_PROPERTIES_STR			= SysAllocString(L"__PUT_EXT_PROPERTIES");
	CLDAPInstanceProvider :: CIMTYPE_STR					= SysAllocString(L"Cimtype");

	// LDAP://RootDSE Properties
	CLDAPInstanceProvider :: SUBSCHEMASUBENTRY_STR			= SysAllocString(L"subschemaSubentry");
	CLDAPInstanceProvider :: CURRENTTIME_STR				= SysAllocString(L"currentTime");
	CLDAPInstanceProvider :: SERVERNAME_STR					= SysAllocString(L"serverName");
	CLDAPInstanceProvider :: NAMINGCONTEXTS_STR				= SysAllocString(L"namingContexts");
	CLDAPInstanceProvider :: DEFAULTNAMINGCONTEXT_STR		= SysAllocString(L"defaultNamingContext");
	CLDAPInstanceProvider :: SCHEMANAMINGCONTEXT_STR		= SysAllocString(L"schemaNamingContext");
	CLDAPInstanceProvider :: CONFIGURATIONNAMINGCONTEXT_STR	= SysAllocString(L"configurationNamingContext");
	CLDAPInstanceProvider :: ROOTDOMAINNAMINGCONTEXT_STR	= SysAllocString(L"rootDomainNamingContext");
	CLDAPInstanceProvider :: SUPPORTEDCONTROLS_STR			= SysAllocString(L"supportedControl");
	CLDAPInstanceProvider :: SUPPORTEDVERSION_STR			= SysAllocString(L"supportedLDAPVersion");
	CLDAPInstanceProvider :: DNSHOSTNAME_STR				= SysAllocString(L"dnsHostName");
	CLDAPInstanceProvider :: DSSERVICENAME_STR				= SysAllocString(L"dsServiceName");
	CLDAPInstanceProvider :: HIGHESTCOMMITEDUSN_STR			= SysAllocString(L"highestCommittedUSN");
	CLDAPInstanceProvider :: LDAPSERVICENAME_STR			= SysAllocString(L"LDAPServiceName");
	CLDAPInstanceProvider :: SUPPORTEDCAPABILITIES_STR		= SysAllocString(L"supportedCapabilities");
	CLDAPInstanceProvider :: SUPPORTEDLDAPPOLICIES_STR		= SysAllocString(L"supportedLDAPPolicies");
	CLDAPInstanceProvider :: SUPPORTEDSASLMECHANISMS_STR	= SysAllocString(L"supportedSASLMechanisms");
}

//***************************************************************************
//
// CDSInstanceProviderInitializer::CDSInstanceProviderInitializer
//
// Destructor
//
//
//***************************************************************************
CDSInstanceProviderInitializer :: ~CDSInstanceProviderInitializer ()
{
	SysFreeString(CLDAPInstanceProvider::CLASS_STR);
	SysFreeString(CLDAPInstanceProvider::DN_PROPERTY);
	SysFreeString(CLDAPInstanceProvider::ROOT_DN_PROPERTY);
	SysFreeString(CLDAPInstanceProvider::QUERY_LANGUAGE);
	SysFreeString(CLDAPInstanceProvider::RELPATH_STR);
	SysFreeString(CLDAPInstanceProvider::VALUE_PROPERTY_STR);
	SysFreeString(CLDAPInstanceProvider::DN_STRING_PROPERTY_STR);
	SysFreeString(CLDAPInstanceProvider::UINT8ARRAY_STR);
	SysFreeString(CLDAPInstanceProvider::DN_WITH_STRING_CLASS_STR);
	SysFreeString(CLDAPInstanceProvider::DN_WITH_BINARY_CLASS_STR);
	SysFreeString(CLDAPInstanceProvider::ADSI_PATH_STR);
	SysFreeString(CLDAPInstanceProvider::INSTANCE_ASSOCIATION_CLASS_STR);
	SysFreeString(CLDAPInstanceProvider::CHILD_INSTANCE_PROPERTY_STR);
	SysFreeString(CLDAPInstanceProvider::PARENT_INSTANCE_PROPERTY_STR);
	SysFreeString(CLDAPInstanceProvider::ATTRIBUTE_SYNTAX_STR);
	SysFreeString(CLDAPInstanceProvider::DEFAULT_OBJECT_CATEGORY_STR);
	SysFreeString(CLDAPInstanceProvider::LDAP_DISPLAY_NAME_STR);
	SysFreeString(CLDAPInstanceProvider::PUT_EXTENSIONS_STR);
	SysFreeString(CLDAPInstanceProvider::PUT_EXT_PROPERTIES_STR);
	SysFreeString(CLDAPInstanceProvider::CIMTYPE_STR);

	// LDAP://RootDSE Properties
	SysFreeString(CLDAPInstanceProvider::SUBSCHEMASUBENTRY_STR);
	SysFreeString(CLDAPInstanceProvider::CURRENTTIME_STR);
	SysFreeString(CLDAPInstanceProvider::SERVERNAME_STR);
	SysFreeString(CLDAPInstanceProvider::NAMINGCONTEXTS_STR);
	SysFreeString(CLDAPInstanceProvider::DEFAULTNAMINGCONTEXT_STR);
	SysFreeString(CLDAPInstanceProvider::SCHEMANAMINGCONTEXT_STR);
	SysFreeString(CLDAPInstanceProvider::CONFIGURATIONNAMINGCONTEXT_STR);
	SysFreeString(CLDAPInstanceProvider::ROOTDOMAINNAMINGCONTEXT_STR);
	SysFreeString(CLDAPInstanceProvider::SUPPORTEDCONTROLS_STR);
	SysFreeString(CLDAPInstanceProvider::SUPPORTEDVERSION_STR);
	SysFreeString(CLDAPInstanceProvider::DNSHOSTNAME_STR);
	SysFreeString(CLDAPInstanceProvider::DSSERVICENAME_STR);
	SysFreeString(CLDAPInstanceProvider::HIGHESTCOMMITEDUSN_STR);
	SysFreeString(CLDAPInstanceProvider::LDAPSERVICENAME_STR);
	SysFreeString(CLDAPInstanceProvider::SUPPORTEDCAPABILITIES_STR);
	SysFreeString(CLDAPInstanceProvider::SUPPORTEDLDAPPOLICIES_STR);
	SysFreeString(CLDAPInstanceProvider::SUPPORTEDSASLMECHANISMS_STR);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\ldapcach.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:ldapcach.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Cache for LDAP Schema objects (Properties and Classes)
//
//***************************************************************************


#ifndef LDAP_CACHE_H
#define LDAP_CACHE_H


class CLDAPCache
{
public:
	static DWORD dwLDAPCacheCount;

	//***************************************************************************
	//
	// CLDAPCache::CLDAPCache
	//
	// Purpose : Constructor. Fills in the cache with all the properties in LDAP.
	//
	// Parameters: 
	//	plogObject : Pointer to the ProvDebugLog object  onto which logging will be done.
	//***************************************************************************
	CLDAPCache();

	//***************************************************************************
	//
	// CLDAPCache::~CLDAPCache
	//
	// Purpose : Destructor 
	//
	//***************************************************************************
	~CLDAPCache();

	//***************************************************************************
	//
	// CLDAPCache::IsInitialized
	//
	// Purpose : Indicates whether the cache was created and initialized succeddfully
	//
	// Parameters: 
	//	None
	//
	//	Return value:
	//		A boolean value indicating the status
	//		
	//***************************************************************************
	BOOLEAN IsInitialized();

	//***************************************************************************
	//
	// CLDAPCache::GetProperty
	//
	// Purpose : Retreives the IDirectory interface of an LDAP property. 
	//
	// Parameters: 
	//	lpszPropertyName : The name of the LDAP Property to be retreived
	//	ppADSIProperty : The address of the pointer where the CADSIProperty object will be placed
	//	bWBEMName : True if the lpszPropertyName is the WBEM name. False, if it is the LDAP name
	//
	//	Return value:
	//		The COM value representing the return status. The user should delete the returned object when done.
	//		
	//***************************************************************************
	HRESULT GetProperty(LPCWSTR lpszPropertyName, CADSIProperty **ppADSIProperty, BOOLEAN bWBEMName);

	//***************************************************************************
	//
	// CLDAPCache::GetClass
	//
	// Purpose : Retreives the IDirectory interface of an LDAP Class
	//
	// Parameters: 
	//	lpszClassName : The name of the Class to be retreived. 
	//	ppADSIClass : The address of the pointer where the CADSIClass object will be placed
	//
	//	Return value:
	//		The COM value representing the return status. The user should delete the returned object when done.
	//		
	//***************************************************************************
	HRESULT GetClass(LPCWSTR lpszWBEMClassName, LPCWSTR lpszClassName, CADSIClass **ppADSIClass);

	//***************************************************************************
	//
	// CLDAPCache::EnumerateClasses
	//
	// Purpose : Retreives the IDirectory interface of an LDAP Class
	//
	// Parameters: 
	//		lppszWBEMSuperClass : The WBEM name of the immediate superclass of the classes to be retreived. This is optional
	//			and is ignored if NULL
	//		bDeep : Indicates whether a deep enumeration is required. Otherwise a shallow enumeration is done
	//		pppszClassNames : The address of the array of LPWSTR pointers where the resulting objects will be
	//			placed. The user should deallocate this array as well as its contents when done with them.
	//		pdwNumRows : The number of elements in the above array returned
	//
	//	Return value:
	//		The COM value representing the return status. The user should delete the returned object when done.
	//		
	//***************************************************************************
	HRESULT EnumerateClasses(LPCWSTR lpszSuperclass,
		BOOLEAN bDeep,
		LPWSTR **pppADSIClasses,
		DWORD *pdwNumRows,
		BOOLEAN bArtificialClass
		);

	//***************************************************************************
	//
	// CLDAPCache::GetSchemaContainerSearch
	//
	// Purpose : To return the IDirectorySearch interface on the schema container
	//
	// Parameters:
	//	ppDirectorySearch : The address where the pointer to the required interface will
	//		be stored.
	//
	// 
	//	Return Value: The COM result representing the status. The user should release
	//	the interface pointer when done with it.
	//***************************************************************************
	HRESULT GetSchemaContainerSearch(IDirectorySearch ** ppDirectorySearch);

	//***************************************************************************
	//
	// CLDAPCache::GetSchemaContainerObject
	//
	// Purpose : To return the IDirectoryObject interface on the schema container
	//
	// Parameters:
	//	ppDirectoryObject : The address where the pointer to the required interface will
	//		be stored.
	//
	// 
	//	Return Value: The COM result representing the status. The user should release
	//	the interface pointer when done with it.
	//***************************************************************************
	HRESULT GetSchemaContainerObject(IDirectoryObject ** ppDirectorySearch);
	
	//***************************************************************************
	//
	// CLDAPCache :: CreateEmptyADSIClass
	//
	// Purpose: Creates a new ADSI class from a WBEM class
	//
	// Parameters:
	//	lpszWBEMName : The WBEM Name of the class
	//
	//
	// Return Value: 
	//
	//***************************************************************************
	HRESULT CreateEmptyADSIClass( 
		LPCWSTR lpszWBEMName,
		CADSIClass **ppADSIClass);


	HRESULT FillInAProperty(CADSIProperty *pNextProperty, ADS_SEARCH_HANDLE hADSSearchOuter);


private:

	// The storage for cached properties
	CObjectTree m_objectTree;

	// Whether the cache was created successfully
	BOOLEAN m_isInitialized;

	// These are the search preferences often used
	ADS_SEARCHPREF_INFO m_pSearchInfo[3];

	// The path to the schema container
	LPWSTR m_lpszSchemaContainerSuffix;
	LPWSTR m_lpszSchemaContainerPath;
	// The IDirectorySearch interface of the schema container
	IDirectorySearch *m_pDirectorySearchSchemaContainer;

	// Some other literals
	static LPCWSTR ROOT_DSE_PATH;
	static LPCWSTR SCHEMA_NAMING_CONTEXT;
	static LPCWSTR LDAP_PREFIX;
	static LPCWSTR LDAP_TOP_PREFIX;
	static LPCWSTR RIGHT_BRACKET;
	static LPCWSTR OBJECT_CATEGORY_EQUALS_ATTRIBUTE_SCHEMA;

	// A function to fill in the object tree
	// This can be called only after the m_pDirectorySearchSchemaContainer member
	// is initialized
	HRESULT InitializeObjectTree();


};

#endif /* LDAP_CACHE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\ldapproi.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:ldapproi.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the CLDAPClassProviderInitializer class. This class
// is used to initialize the static members of the CLDAPCLassProvider class
//
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef DS_LDAP_CLASS_PROVIDER_INIT_H
#define DS_LDAP_CLASS_PROVIDER_INIT_H

class CLDAPClassProviderInitializer
{

public:
	CLDAPClassProviderInitializer();
	~CLDAPClassProviderInitializer();
};

#endif /* DS_LDAP_CLASS_PROVIDER_INIT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\ldapproi.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:ldapproi.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains implementation of the class that is used to initialize the
//	CLDAPClassProvider class
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
// CLDAPClassProviderInitializer::CLDAPClassProviderInitializer
//
// Constructor Parameters:
//		None
//
//  
//***************************************************************************

CLDAPClassProviderInitializer :: CLDAPClassProviderInitializer ()
{
	CLDAPClassProvider :: LDAP_BASE_CLASS_STR			= SysAllocString(LDAP_BASE_CLASS);
	CLDAPClassProvider :: LDAP_CLASS_PROVIDER_NAME		= SysAllocString(L"Microsoft|DSLDAPClassProvider|V1.0");
	CLDAPClassProvider :: LDAP_INSTANCE_PROVIDER_NAME	= SysAllocString(L"Microsoft|DSLDAPInstanceProvider|V1.0");

	// WBEM Class Qualfiers
	CLDAPClassProvider :: DYNAMIC_BSTR						= SysAllocString(L"dynamic");
	CLDAPClassProvider :: PROVIDER_BSTR						= SysAllocString(L"provider");
	CLDAPClassProvider :: ABSTRACT_BSTR						= SysAllocString(L"abstract");
	CLDAPClassProvider :: COMMON_NAME_ATTR_BSTR				= SysAllocString(COMMON_NAME_ATTR);
	CLDAPClassProvider :: LDAP_DISPLAY_NAME_ATTR_BSTR		= SysAllocString(LDAP_DISPLAY_NAME_ATTR);
	CLDAPClassProvider :: GOVERNS_ID_ATTR_BSTR				= SysAllocString(GOVERNS_ID_ATTR);
	CLDAPClassProvider :: SCHEMA_ID_GUID_ATTR_BSTR			= SysAllocString(SCHEMA_ID_GUID_ATTR);
	CLDAPClassProvider :: MAPI_DISPLAY_TYPE_ATTR_BSTR		= SysAllocString(MAPI_DISPLAY_TYPE_ATTR);
	CLDAPClassProvider :: RDN_ATT_ID_ATTR_BSTR				= SysAllocString(RDN_ATT_ID_ATTR);
	CLDAPClassProvider :: SYSTEM_MUST_CONTAIN_ATTR_BSTR		= SysAllocString(SYSTEM_MUST_CONTAIN_ATTR);
	CLDAPClassProvider :: MUST_CONTAIN_ATTR_BSTR			= SysAllocString(MUST_CONTAIN_ATTR);
	CLDAPClassProvider :: SYSTEM_MAY_CONTAIN_ATTR_BSTR		= SysAllocString(SYSTEM_MAY_CONTAIN_ATTR);
	CLDAPClassProvider :: MAY_CONTAIN_ATTR_BSTR				= SysAllocString(MAY_CONTAIN_ATTR);
	CLDAPClassProvider :: SYSTEM_POSS_SUPERIORS_ATTR_BSTR	= SysAllocString(SYSTEM_POSS_SUPERIORS_ATTR);
	CLDAPClassProvider :: POSS_SUPERIORS_ATTR_BSTR			= SysAllocString(POSS_SUPERIORS_ATTR);
	CLDAPClassProvider :: SYSTEM_AUXILIARY_CLASS_ATTR_BSTR	= SysAllocString(SYSTEM_AUXILIARY_CLASS_ATTR);
	CLDAPClassProvider :: AUXILIARY_CLASS_ATTR_BSTR			= SysAllocString(AUXILIARY_CLASS_ATTR);
	CLDAPClassProvider :: DEFAULT_SECURITY_DESCRP_ATTR_BSTR	= SysAllocString(DEFAULT_SECURITY_DESCRP_ATTR);
	CLDAPClassProvider :: OBJECT_CLASS_CATEGORY_ATTR_BSTR	= SysAllocString(OBJECT_CLASS_CATEGORY_ATTR);
	CLDAPClassProvider :: SYSTEM_ONLY_ATTR_BSTR				= SysAllocString(SYSTEM_ONLY_ATTR);
	CLDAPClassProvider :: NT_SECURITY_DESCRIPTOR_ATTR_BSTR	= SysAllocString(NT_SECURITY_DESCRIPTOR_ATTR);
	CLDAPClassProvider :: DEFAULT_OBJECTCATEGORY_ATTR_BSTR	= SysAllocString(DEFAULT_OBJECTCATEGORY_ATTR);

	// WBEM Property Qualifiers
	CLDAPClassProvider :: SYSTEM_BSTR						= SysAllocString(L"system");
	CLDAPClassProvider :: NOT_NULL_BSTR						= SysAllocString(L"not_null");
	CLDAPClassProvider :: INDEXED_BSTR						= SysAllocString(L"indexed");
	CLDAPClassProvider :: ATTRIBUTE_SYNTAX_ATTR_BSTR		= SysAllocString(L"attributeSyntax");
	CLDAPClassProvider :: ATTRIBUTE_ID_ATTR_BSTR			= SysAllocString(L"attributeID");
	CLDAPClassProvider :: MAPI_ID_ATTR_BSTR					= SysAllocString(L"MAPI_ID");
	CLDAPClassProvider :: OM_SYNTAX_ATTR_BSTR				= SysAllocString(L"OM_Syntax");
	CLDAPClassProvider :: RANGE_LOWER_ATTR_BSTR				= SysAllocString(L"Range_Lower");
	CLDAPClassProvider :: RANGE_UPPER_ATTR_BSTR				= SysAllocString(L"Range_Upper");
	CLDAPClassProvider :: CIMTYPE_STR						= SysAllocString(L"Cimtype");
	CLDAPClassProvider :: EMBED_UINT8ARRAY					= SysAllocString(L"object:Uint8Array");
	CLDAPClassProvider :: EMBED_DN_WITH_STRING				= SysAllocString(L"object:DN_With_String");
	CLDAPClassProvider :: EMBED_DN_WITH_BINARY				= SysAllocString(L"object:DN_WIth_Binary");

	// WBEM Property names
	CLDAPClassProvider :: DYNASTY_BSTR						= SysAllocString(L"__DYNASTY");

	// The property cache
	CLDAPClassProvider :: s_pLDAPCache = new CLDAPCache();
}

//***************************************************************************
//
// CLDAPClassProviderInitializer::CLDAPClassProviderInitializer
//
// Destructor
//
//***************************************************************************
CLDAPClassProviderInitializer :: ~CLDAPClassProviderInitializer ()
{
	SysFreeString(CLDAPClassProvider::LDAP_BASE_CLASS_STR);
	SysFreeString(CLDAPClassProvider::LDAP_CLASS_PROVIDER_NAME);
	SysFreeString(CLDAPClassProvider::LDAP_INSTANCE_PROVIDER_NAME);

	// Class Qualifiers
	SysFreeString(CLDAPClassProvider::DYNAMIC_BSTR);
	SysFreeString(CLDAPClassProvider::PROVIDER_BSTR);
	SysFreeString(CLDAPClassProvider::ABSTRACT_BSTR);
	SysFreeString(CLDAPClassProvider::COMMON_NAME_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::LDAP_DISPLAY_NAME_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::GOVERNS_ID_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::SCHEMA_ID_GUID_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::MAPI_DISPLAY_TYPE_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::RDN_ATT_ID_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::SYSTEM_MUST_CONTAIN_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::MUST_CONTAIN_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::SYSTEM_MAY_CONTAIN_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::MAY_CONTAIN_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::SYSTEM_POSS_SUPERIORS_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::POSS_SUPERIORS_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::SYSTEM_AUXILIARY_CLASS_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::AUXILIARY_CLASS_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::DEFAULT_SECURITY_DESCRP_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::OBJECT_CLASS_CATEGORY_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::SYSTEM_ONLY_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::NT_SECURITY_DESCRIPTOR_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::DEFAULT_OBJECTCATEGORY_ATTR_BSTR);

	// Property Qualifiers
	SysFreeString(CLDAPClassProvider::SYSTEM_BSTR);
	SysFreeString(CLDAPClassProvider::NOT_NULL_BSTR);
	SysFreeString(CLDAPClassProvider::INDEXED_BSTR);
	SysFreeString(CLDAPClassProvider::ATTRIBUTE_SYNTAX_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::ATTRIBUTE_ID_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::MAPI_ID_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::OM_SYNTAX_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::RANGE_LOWER_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::RANGE_UPPER_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::CIMTYPE_STR);
	SysFreeString(CLDAPClassProvider::EMBED_UINT8ARRAY);
	SysFreeString(CLDAPClassProvider::EMBED_DN_WITH_STRING);
	SysFreeString(CLDAPClassProvider::EMBED_DN_WITH_BINARY);

	// WBEM Property names
	SysFreeString(CLDAPClassProvider::DYNASTY_BSTR);

	// The property cache
	delete CLDAPClassProvider :: s_pLDAPCache;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\ldaphelp.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:ldaphelp.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the CLDAPHelper class. This is
//	a class that has many static helper functions pertaining to ADSI LDAP Provider
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef LDAP_HELPER_H
#define LDAP_HELPER_H

class CLDAPHelper
{

public:

	//***************************************************************************
	//
	// CLDAPHelper :: GetLDAPClassFromLDAPName
	//
	// Purpose : To fill in a CADSIClass object on a class/property provided by the LDAP Provider
	// Parameters:
	//		pDirectorySearchSchemaContainer : The IDirectorySearch interface where the schema object should be looked for
	//		lpszSchemaContainerSuffix : The suffix to be used. The actual object fetched will be:
	//			LDAP://CN=<lpszCommonName>,<lpszSchemaContainerSuffix>, where lpszCommonName is the
	//			'cn' attribute of the object having the ldapdisplayname attribute as lpszLDAPObjectName
	//		pSearchInfo: An array of ADS_SEARCHPREF_INFO to be used in the search
	//		dwSearchInfoCount : The number of elements in the above array
	//		lpszLDAPObjectName : The LDAPDisplayName of the LDAP class or property to be fetched. 
	//		ppLDAPObject : The address where the pointer to IDirectoryObject will be stored
	//			It is the caller's responsibility to delete the object when done with it
	// 
	//	Return Value: The COM status value indicating the status of the request.
	//***************************************************************************
	static HRESULT GetLDAPClassFromLDAPName(
		IDirectorySearch *pDirectorySearchSchemaContainer,
		LPCWSTR lpszSchemaContainerSuffix,
		PADS_SEARCHPREF_INFO pSearchInfo,
		DWORD dwSearchInfoCount,
		CADSIClass *pADSIClass);


	//***************************************************************************
	//
	// CLDAPHelper :: GetLDAPSchemaObjectFromCommonName
	//
	// Purpose : To fetch the IDirectoryObject interface on a class/property provided by the LDAP Provider
	// Parameters:
	//		lpszSchemaContainerSuffix : The suffix to be used. The actual object fetced will be:
	//			LDAP://CN=<lpszCommonName>,<lpszSchemaContainerSuffix>
	//		lpszCommonName : The 'cn' attribute of the LDAP class or property to be fetched. 
	//		ppLDAPObject : The address where the pointer to IDirectoryObject will be stored
	//			It is the caller's responsibility to delete the object when done with it
	// 
	//	Return Value: The COM status value indicating the status of the request.
	//***************************************************************************
	static HRESULT GetLDAPSchemaObjectFromCommonName(
		LPCWSTR lpszSchemaContainerSuffix,
		LPCWSTR lpszCommonName, 
		IDirectoryObject **ppLDAPObject);

	//***************************************************************************
	//
	// CLDAPHelper :: GetLDAPClassNameFromCN
	//
	// Purpose : To fetch the LDAPDisplayNAme of a class from its path
	// Parameters:
	// 
	//	Return Value: The COM status value indicating the status of the request. The user should delete the
	// name returned, when done
	//***************************************************************************
	static HRESULT GetLDAPClassNameFromCN(LPCWSTR lpszLDAPClassPath, 
		LPWSTR *lppszLDAPName);

	//***************************************************************************
	//
	// CLDAPHelper :: EnumerateClasses
	//
	// Purpose : To fetch the list of names of subclasses (immediate) of an LDAP class
	// Parameters:
	//		pDirectorySearchSchemaContainer : The IDirectorySearch interface where the schema object should be looked for
	//		lpszSchemaContainerSuffix : The suffix to be used. The actual object fetced will be:
	//			LDAP://CN=<lpszObjectName>,<lpszSchemaContainerSuffix>
	//		pSearchInfo: An array of ADS_SEARCHPREF_INFO to be used in the search
	//		dwSearchInfoCount : The number of elements in the above array
	//		lppszLDAPSuperClass : The immediate superclass of the classes to be retreived. This is optional
	//			and is ignored if NULL
	//		bDeep : Indicates whether a deep enumeration is required. Otherwise a shallow enumeration is done
	//		pppszClassNames : The address of the array of LPWSTR pointers where the resulting objects will be
	//			placed. The user should deallocate this array as well as its contents when done with them.
	//		pdwNumRows : The number of elements in the above array returned
	// 
	//	Return Value: The COM status value indicating the status of the request.
	//***************************************************************************
	static HRESULT EnumerateClasses(
		IDirectorySearch *pDirectorySearchSchemaContainer,
		LPCWSTR lpszSchemaContainerSuffix,
		PADS_SEARCHPREF_INFO pSearchInfo,
		DWORD dwSearchInfoCount,
		LPCWSTR lpszSuperClass,
		BOOLEAN bDeep,
		LPWSTR **pppszClassNames,
		DWORD *pdwNumRows,
		BOOLEAN bArtificialClass);

	// Gets the IDIrectoryObject interface on an ADSI instance
	static HRESULT GetADSIInstance(LPCWSTR szADSIPath, CADSIInstance **ppADSIInstance, ProvDebugLog *pLogObject);

	//***************************************************************************
	//
	// CLDAPHelper :: ExecuteQuery
	//
	// Purpose : To fetch the IDirectoryObject interface on a class/property provided by the LDAP Provider
	// Parameters:
	//		pszPathToRoot : The ADSI path to the node from which the search should start
	//		pSearchInfo: A pointer to a ADS_SEARCHPREF_INFO to be used in the search
	//		dwSearchInfoCount: The number of elements in pSearchInfo array
	//		pszLDAPQuery : The LDAP query to be executed
	//		pppADSIInstances : The address of the array of CADSIInstance pointers where the resulting objects will be
	//			placed. The user should deallocate this array as well as its contents when done with them.
	//		pdwNumRows : The number of elements in the above array returned
	// 
	//	Return Value: The COM status value indicating the status of the request.
	//***************************************************************************
	static HRESULT ExecuteQuery(
		LPCWSTR pszPathToRoot,
		PADS_SEARCHPREF_INFO pSearchInfo,
		DWORD dwSearchInfoCount,
		LPCWSTR pszLDAPQuery,
		CADSIInstance ***pppADSIInstances,
		DWORD *pdwNumRows,
		ProvDebugLog *pLogObject);

	// Helper functions to delete a ADS_ATTR_INFO structure
	static void DeleteAttributeContents(PADS_ATTR_INFO pAttribute);
	static void DeleteADsValueContents(PADSVALUE pValue);


	//***************************************************************************
	//
	// CLDAPHelper :: UnmangleWBEMNameToLDAP
	//
	// Purpose : Converts a mangled WBEM name to LDAP
	//	An underscore in LDAP maps to two underscores in WBEM
	//	An hyphen in LDAP maps to one underscore in WBEM
	//
	// Parameters:
	//	lpszWBEMName : The WBEM class or property name
	// 
	//	Return Value: The LDAP name to the class or property object. This has to
	//	be deallocated by the user
	//***************************************************************************
	static LPWSTR UnmangleWBEMNameToLDAP(LPCWSTR lpszWBEMName);

	//***************************************************************************
	//
	// CLDAPHelper :: MangleLDAPNameToWBEM
	//
	// Purpose : Converts a LDAP name to WBEM by mangling it
	//	An underscore in LDAP maps to two underscores in WBEM
	//	An hyphen in LDAP maps to one underscore in WBEM
	//
	// Parameters:
	//	lpszLDAPName : The LDAP class or property name
	// 
	//	Return Value: The LDAP name to the class or property object. This has to
	//	be deallocated by the user
	//***************************************************************************
	static LPWSTR MangleLDAPNameToWBEM(LPCWSTR lpszLDAPName, BOOLEAN bArtificalName = FALSE);

private:

	// Forms the ADSI path from a class or property name
	static LPWSTR CreateADSIPath(LPCWSTR lpszLDAPSchemaObjectName,	LPCWSTR lpszSchemaContainerSuffix);

	// Some literals
	static LPCWSTR LDAP_CN_EQUALS;
	static LPCWSTR LDAP_DISP_NAME_EQUALS;
	static LPCWSTR OBJECT_CATEGORY_EQUALS_CLASS_SCHEMA;
	static LPCWSTR SUB_CLASS_OF_EQUALS;
	static LPCWSTR NOT_LDAP_NAME_EQUALS;
	static LPCWSTR LEFT_BRACKET_AND;
	static LPCWSTR GOVERNS_ID_EQUALS;
	static LPCWSTR CLASS_SCHEMA;
	static LPCWSTR CN_EQUALS;
};

#endif /* LDAP_HELPER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\ldaphelp.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:ldaphelp.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the implementation the CLDAPHelper class. This is
//	a class that has many static helper functions pertaining to ADSI LDAP Provider
//***************************************************************************
/////////////////////////////////////////////////////////////////////////


#include "precomp.h"

LPCWSTR CLDAPHelper :: LDAP_CN_EQUALS						= L"LDAP://CN=";	
LPCWSTR CLDAPHelper :: LDAP_DISP_NAME_EQUALS				= L"(lDAPDisplayName=";
LPCWSTR CLDAPHelper :: OBJECT_CATEGORY_EQUALS_CLASS_SCHEMA		= L"(objectCategory=classSchema)";
LPCWSTR CLDAPHelper	:: SUB_CLASS_OF_EQUALS				= L"(subclassOf=";
LPCWSTR CLDAPHelper :: NOT_LDAP_NAME_EQUALS				= L"(!ldapDisplayName=";
LPCWSTR CLDAPHelper :: LEFT_BRACKET_AND					= L"(&";
LPCWSTR CLDAPHelper :: GOVERNS_ID_EQUALS				= L"(governsId=";
LPCWSTR CLDAPHelper :: CLASS_SCHEMA						= L"classSchema";
LPCWSTR CLDAPHelper :: CN_EQUALS						= L"cn=";

//***************************************************************************
//
// CLDAPHelper :: GetLDAPClassFromLDAPName
//
// Purpose : See Header
//***************************************************************************
HRESULT CLDAPHelper :: GetLDAPClassFromLDAPName(
	IDirectorySearch *pDirectorySearchSchemaContainer,
	LPCWSTR lpszSchemaContainerSuffix,
	PADS_SEARCHPREF_INFO pSearchInfo,
	DWORD dwSearchInfoCount,
	CADSIClass *pADSIClass
)
{
	// We map the object from the LDAP Display name
	// Hence we cannot directly do an ADsOpenObject().
	// We have to send an LDAP query for the instance of ClassSchema/AttributeSchema where the
	// ldapdisplayname attribute is the lpszObjectName parameter.
	HRESULT result = E_FAIL;

	// For the search filter;
	LPCWSTR lpszLDAPObjectName = pADSIClass->GetADSIClassName();
	LPWSTR lpszSearchFilter = NULL;
	if(lpszSearchFilter = new WCHAR[ wcslen(LDAP_DISP_NAME_EQUALS) + wcslen(lpszLDAPObjectName) + wcslen(RIGHT_BRACKET_STR) + 1])
	{
		try
		{
			wcscpy(lpszSearchFilter, LDAP_DISP_NAME_EQUALS);
			wcscat(lpszSearchFilter, lpszLDAPObjectName);
			wcscat(lpszSearchFilter, RIGHT_BRACKET_STR);
			ADS_SEARCH_HANDLE hADSSearch;
			if(SUCCEEDED(result = pDirectorySearchSchemaContainer->ExecuteSearch(lpszSearchFilter, NULL, -1, &hADSSearch)))
			{
				try
				{
					if(SUCCEEDED(result = pDirectorySearchSchemaContainer->GetNextRow(hADSSearch)) && result != S_ADS_NOMORE_ROWS)
					{
						// Get the column for the CN attribute
						ADS_SEARCH_COLUMN adsColumn;

						// Store each of the LDAP class attributes
						// Reset the LDAP and WBEM names to take care of change in case
						if(SUCCEEDED(result) && SUCCEEDED(result = pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)LDAP_DISPLAY_NAME_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
								{
									pADSIClass->SetADSIClassName(adsColumn.pADsValues->CaseIgnoreString);
									LPWSTR lpszWBEMName = CLDAPHelper::MangleLDAPNameToWBEM(adsColumn.pADsValues->CaseIgnoreString);

									try
									{
										pADSIClass->SetWBEMClassName(lpszWBEMName);
									}
									catch ( ... )
									{
										delete [] lpszWBEMName;
										throw;
									}

									delete [] lpszWBEMName;
								}
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}

						// Store each of the LDAP class attributes 
						if(SUCCEEDED(result) && SUCCEEDED(result = pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)COMMON_NAME_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
									pADSIClass->SetCommonName(adsColumn.pADsValues->CaseIgnoreString);
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}

						// Special case for top since ADSI returns "top" as the parent class of "top" and we
						// will go into an infinite loop later if we dont check this
						if(pADSIClass->GetCommonName() && _wcsicmp(pADSIClass->GetCommonName(), TOP_CLASS) != 0)
						{
							if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
								result = E_FAIL;
							else
							{
								if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)SUB_CLASS_OF_ATTR, &adsColumn)))
								{
									try
									{
										if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
											result = E_FAIL;
										else
											pADSIClass->SetSuperClassLDAPName(adsColumn.pADsValues->CaseIgnoreString);
									}
									catch ( ... )
									{
										pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
										throw;
									}

									pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								}
							}
						}

						if(SUCCEEDED(result) && SUCCEEDED(result = pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)GOVERNS_ID_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
									pADSIClass->SetGovernsID(adsColumn.pADsValues->CaseIgnoreString);
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}

						if(SUCCEEDED(result) && SUCCEEDED(result = pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)SCHEMA_ID_GUID_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
									pADSIClass->SetSchemaIDGUID((adsColumn.pADsValues->OctetString).lpValue, (adsColumn.pADsValues->OctetString).dwLength);
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}

						if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)RDN_ATT_ID_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
									pADSIClass->SetRDNAttribute(adsColumn.pADsValues->CaseIgnoreString);
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}

						if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)DEFAULT_SECURITY_DESCRP_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
									pADSIClass->SetDefaultSecurityDescriptor(adsColumn.pADsValues->CaseIgnoreString);
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}

						if(SUCCEEDED(result) && SUCCEEDED(result = pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)OBJECT_CLASS_CATEGORY_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
									pADSIClass->SetObjectClassCategory(adsColumn.pADsValues->Integer);
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}

						/*
						if(SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)NT_SECURITY_DESCRIPTOR_ATTR, &adsColumn)))
						{
							pADSIClass->SetNTSecurityDescriptor((adsColumn.pADsValues->SecurityDescriptor).lpValue, (adsColumn.pADsValues->SecurityDescriptor).dwLength);
							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}
						*/
						if(SUCCEEDED(result) && SUCCEEDED(result = pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)DEFAULT_OBJECTCATEGORY_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
								{
									// Get the LDAPDIpslayName of the class
									LPWSTR lpszLDAPName = NULL;
									if(SUCCEEDED(result) && SUCCEEDED(result = GetLDAPClassNameFromCN(adsColumn.pADsValues->DNString, &lpszLDAPName)))
									{
										try
										{
											pADSIClass->SetDefaultObjectCategory(lpszLDAPName);
										}
										catch ( ... )
										{
											delete [] lpszLDAPName;
											throw;
										}

										delete [] lpszLDAPName;
									}
								}
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}

						if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)SYSTEM_ONLY_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
									pADSIClass->SetSystemOnly((BOOLEAN)adsColumn.pADsValues->Boolean);
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}

						if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)AUXILIARY_CLASS_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
									pADSIClass->SetAuxiliaryClasses(adsColumn.pADsValues, adsColumn.dwNumValues);
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}

						if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)SYSTEM_AUXILIARY_CLASS_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
									pADSIClass->SetSystemAuxiliaryClasses(adsColumn.pADsValues, adsColumn.dwNumValues);
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}

						if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)SYSTEM_MAY_CONTAIN_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
									pADSIClass->SetSystemMayContains(adsColumn.pADsValues, adsColumn.dwNumValues);
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}
						if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)MAY_CONTAIN_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
									pADSIClass->SetMayContains(adsColumn.pADsValues, adsColumn.dwNumValues);
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}
						if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)SYSTEM_MUST_CONTAIN_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
									pADSIClass->SetSystemMustContains(adsColumn.pADsValues, adsColumn.dwNumValues);
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}
						if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)MUST_CONTAIN_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
									pADSIClass->SetMustContains(adsColumn.pADsValues, adsColumn.dwNumValues);
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}
						if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)SYSTEM_POSS_SUPERIORS_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
									pADSIClass->SetSystemPossibleSuperiors(adsColumn.pADsValues, adsColumn.dwNumValues);
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}
						if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)POSS_SUPERIORS_ATTR, &adsColumn)))
						{
							try
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
									result = E_FAIL;
								else
									pADSIClass->SetPossibleSuperiors(adsColumn.pADsValues, adsColumn.dwNumValues);
							}
							catch ( ... )
							{
								pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								throw;
							}

							pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
						}
					}
					else
						result = E_FAIL;
				}
				catch ( ... )
				{
					// Close the search
					pDirectorySearchSchemaContainer->CloseSearchHandle(hADSSearch);

					throw;
				}

				// Close the search
				pDirectorySearchSchemaContainer->CloseSearchHandle(hADSSearch);
			}
		}
		catch ( ... )
		{
			if ( lpszSearchFilter )
			{
				// Delete the filter
				delete [] lpszSearchFilter;
				lpszSearchFilter = NULL;
			}

			throw;
		}

		if ( lpszSearchFilter )
		{
			// Delete the filter
			delete [] lpszSearchFilter;
			lpszSearchFilter = NULL;
		}
	}
	else
		result = E_OUTOFMEMORY;

	return result;
}


//***************************************************************************
//
// CLDAPHelper :: GetLDAPSchemaObjectFromCommonName
//
// Purpose : To fetch the IDirectoryObject interface on a class/property provided by the LDAP Provider
// Parameters:
//		lpszSchemaContainerSuffix : The suffix to be used. The actual object fetced will be:
//			LDAP://CN=<lpszCommonName>,<lpszSchemaContainerSuffix>
//		lpszCommonName : The 'cn' attribute of the LDAP class or property to be fetched. 
//		ppLDAPObject : The address where the pointer to IDirectoryObject will be stored
//			It is the caller's responsibility to delete the object when done with it
// 
//	Return Value: The COM status value indicating the status of the request.
//***************************************************************************
HRESULT CLDAPHelper :: GetLDAPSchemaObjectFromCommonName(
	LPCWSTR lpszSchemaContainerSuffix,
	LPCWSTR lpszCommonName, 
	IDirectoryObject **ppLDAPObject)
{
	HRESULT result = S_OK;

	// Form the ADSI path to the LDAP object
	LPWSTR lpszLDAPObjectPath = NULL;
	if(lpszLDAPObjectPath = new WCHAR[wcslen(LDAP_CN_EQUALS) + wcslen(lpszCommonName) + wcslen(COMMA_STR) + wcslen(lpszSchemaContainerSuffix) + 1])
	{
		wcscpy(lpszLDAPObjectPath, LDAP_CN_EQUALS);
		wcscat(lpszLDAPObjectPath, lpszCommonName);
		wcscat(lpszLDAPObjectPath, COMMA_STR);
		wcscat(lpszLDAPObjectPath, lpszSchemaContainerSuffix);

		result = ADsOpenObject(lpszLDAPObjectPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectoryObject, (LPVOID *)ppLDAPObject);

		delete[] lpszLDAPObjectPath;
	}
	else
		result = E_OUTOFMEMORY;
	return result;
}

//***************************************************************************
//
// CLDAPHelper :: GetLDAPClassNameFromCN
//
// Purpose : To fetch the LDAPDisplayNAme of a class from its path
// Parameters:
// 
//	lpszLDAPClassPath : The path to the class object without the LDAP prefix. Ex CN=user,CN=Schema, CN=COnfiguration ...
//	Return Value: The COM status value indicating the status of the request. The user should delete the
// name returned, when done
//***************************************************************************
HRESULT CLDAPHelper :: GetLDAPClassNameFromCN(LPCWSTR lpszLDAPClassPath, 
	LPWSTR *lppszLDAPName)
{
	IDirectoryObject *pLDAPClass = NULL;

	// Prepend the LDAP:// perfix
	LPWSTR lpszRealPath = NULL;
	HRESULT result = S_OK;
	if(lpszRealPath = new WCHAR[ wcslen(LDAP_PREFIX) + wcslen(lpszLDAPClassPath) + 1])
	{
		wcscpy(lpszRealPath, LDAP_PREFIX);
		wcscat(lpszRealPath, lpszLDAPClassPath);

		result = ADsOpenObject(lpszRealPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectoryObject, (LPVOID *)&pLDAPClass);
		delete [] lpszRealPath;
	}
	else
		result = E_OUTOFMEMORY;

	// Get the attribute LDAPDisplayName
	if(SUCCEEDED(result))
	{
		PADS_ATTR_INFO pAttributes = NULL;
		DWORD dwReturnCount = 0;
		if(SUCCEEDED(result = pLDAPClass->GetObjectAttributes((LPWSTR *)&LDAP_DISPLAY_NAME_ATTR, 1, &pAttributes, &dwReturnCount)) && dwReturnCount == 1)
		{
			if(pAttributes->pADsValues->dwType == ADSTYPE_PROV_SPECIFIC)
				result = E_FAIL;
			else
			{
				*lppszLDAPName = NULL;
				if(*lppszLDAPName = new WCHAR[wcslen(pAttributes->pADsValues->DNString) + 1])
					wcscpy(*lppszLDAPName, pAttributes->pADsValues->DNString);
				else
					result = E_OUTOFMEMORY;
			}
			FreeADsMem((LPVOID *)pAttributes);
		}

		pLDAPClass->Release();
	}
	return result;
}

//***************************************************************************
//
// CLDAPHelper :: EnumerateClasses
//
// Purpose : See Header
//***************************************************************************
HRESULT CLDAPHelper :: EnumerateClasses(
	IDirectorySearch *pDirectorySearchSchemaContainer,
	LPCWSTR lpszSchemaContainerSuffix,
	PADS_SEARCHPREF_INFO pSearchInfo,
	DWORD dwSearchInfoCount,
	LPCWSTR lpszLDAPSuperClass,
	BOOLEAN bDeep,
	LPWSTR **pppszClassNames,
	DWORD *pdwNumRows,
	BOOLEAN bArtificialClass)
{
	// Initialize the return values
	HRESULT result = E_FAIL;
	*pdwNumRows = 0;

	// The search filter;
	LPWSTR lpszSearchFilter = NULL;

	// There's various cases to be considered here.
	// if(lpszLDAPSuperClass is NULL)
	// then
	//		if bDeep is false, then no objects is returned (since we do not provide the LDAP base class
	//		else all the classes are returned using the filter (objectCategory=classSchema)
	//	else
	//		if bDeep is false, then the filter (&(objectCategory=classSchema)(subClassOf=lpszLDAPSuperClass)) is used
	//		else a lot of work has to be done!
	if(lpszLDAPSuperClass == NULL)
	{
		if(!bDeep)
		{
			*pppszClassNames = NULL;
			*pdwNumRows = 0;
			return S_OK;
		}
		else
		{
			if(!(lpszSearchFilter = new WCHAR[ wcslen(OBJECT_CATEGORY_EQUALS_CLASS_SCHEMA) + 1]))
				return E_OUTOFMEMORY;
			wcscpy(lpszSearchFilter, OBJECT_CATEGORY_EQUALS_CLASS_SCHEMA);
		}
	}
	else
	{
		if(!bDeep)
		{
			// One would imagine that a filter of the kind
			 //(&(objectClass=classSchema)(subClassOf=<lpszLDAPSuperClass>))
			// would be enough. Unfortunately it also gives the Top class
			//in the results when the value of lpszLDAPSuperClass is Top
			// we dont need that. Hnce we form the filter
			 //(&(objectClass=classSchema)(subClassOf=<lpszLDAPSuperClass>)(!ldapDisplayName=<lpszLDAPSuperClass>))
			if(lpszSearchFilter = new WCHAR[ wcslen(LEFT_BRACKET_AND)					// (&
									+ wcslen(OBJECT_CATEGORY_EQUALS_CLASS_SCHEMA)		// (objectCategory=classSchema)
									+ wcslen(SUB_CLASS_OF_EQUALS)					// (subClassOf=
									+ wcslen(lpszLDAPSuperClass)					// superClass
									+ wcslen(RIGHT_BRACKET_STR)							// )
									+ wcslen(NOT_LDAP_NAME_EQUALS)					// (!ldapDisplayName=
									+ wcslen(lpszLDAPSuperClass)					// superClass
									+ 2*wcslen(RIGHT_BRACKET_STR)						// ))
									+1])
			{
				wcscpy(lpszSearchFilter, LEFT_BRACKET_AND);
				wcscat(lpszSearchFilter, OBJECT_CATEGORY_EQUALS_CLASS_SCHEMA);
				wcscat(lpszSearchFilter, SUB_CLASS_OF_EQUALS);
				wcscat(lpszSearchFilter, lpszLDAPSuperClass);
				wcscat(lpszSearchFilter, RIGHT_BRACKET_STR);
				wcscat(lpszSearchFilter, NOT_LDAP_NAME_EQUALS);					// (!ldapDisplayName=
				wcscat(lpszSearchFilter, lpszLDAPSuperClass);
				wcscat(lpszSearchFilter, RIGHT_BRACKET_STR);
				wcscat(lpszSearchFilter, RIGHT_BRACKET_STR);
			}
			else
				result = E_OUTOFMEMORY;
		}
		else
			lpszSearchFilter = NULL; // THIS SPECIAL CASE IS TACKLED LATER
	}

	if(lpszSearchFilter)
	{
		ADS_SEARCH_HANDLE hADSSearchOuter;
		if(SUCCEEDED(result = pDirectorySearchSchemaContainer->ExecuteSearch(lpszSearchFilter, (LPWSTR *)&LDAP_DISPLAY_NAME_ATTR, 1, &hADSSearchOuter)))
		{
			*pdwNumRows = 0;
			DWORD dwFirstCount = 0; // Number of rows retreived on the first count

			// Calculate the number of rows first. 
			while(SUCCEEDED(result = pDirectorySearchSchemaContainer->GetNextRow(hADSSearchOuter)) &&
				result != S_ADS_NOMORE_ROWS)
				dwFirstCount ++;

			// Allocate enough memory for the classes and names
			*pppszClassNames = NULL;
			if(bArtificialClass)
			{
				dwFirstCount ++;
				if(*pppszClassNames = new LPWSTR [dwFirstCount])
					(*pppszClassNames)[0] = NULL;
				else
					result = E_OUTOFMEMORY;
			}
			else
			{
				if(!(*pppszClassNames = new LPWSTR [dwFirstCount]))
					result = E_OUTOFMEMORY;
			}

			// The index of the attribute being processed
			DWORD dwSecondCount = 0;
			if(bArtificialClass)
				dwSecondCount ++;

			// Get the columns for the attributes
			ADS_SEARCH_COLUMN adsColumn;

			// Move to the beginning of the search
			if(SUCCEEDED(result = pDirectorySearchSchemaContainer->GetFirstRow(hADSSearchOuter)) 
				&& result != S_ADS_NOMORE_ROWS)
			{
				// Store each of the LDAP class attributes 
				if(SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearchOuter, (LPWSTR)LDAP_DISPLAY_NAME_ATTR, &adsColumn)))
				{
					if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
					{
						result = E_FAIL;
						pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
					}
					else
					{
						// Create the CADSIClass
						(*pppszClassNames)[dwSecondCount] = NULL;
						if((*pppszClassNames)[dwSecondCount] = new WCHAR[wcslen(adsColumn.pADsValues->CaseIgnoreString) + 1])
							wcscpy((*pppszClassNames)[dwSecondCount], adsColumn.pADsValues->CaseIgnoreString);
						pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
	
						dwSecondCount++;

						// Get the rest of the rows
						while(SUCCEEDED(result = pDirectorySearchSchemaContainer->GetNextRow(hADSSearchOuter))&&
								result != S_ADS_NOMORE_ROWS)
						{
							// Store each of the LDAP class attributes 
							if(SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearchOuter, (LPWSTR)LDAP_DISPLAY_NAME_ATTR, &adsColumn)))
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
								{
									result = E_FAIL;
									pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								}
								else
								{
									// Create the CADSIClass
									(*pppszClassNames)[dwSecondCount] = NULL;
									if((*pppszClassNames)[dwSecondCount] = new WCHAR[wcslen(adsColumn.pADsValues->CaseIgnoreString) + 1])
										wcscpy((*pppszClassNames)[dwSecondCount], adsColumn.pADsValues->CaseIgnoreString);
									pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );

									dwSecondCount++;
								}
							}
						}
					}
				}
			}

			// Something went wrong? Release allocated resources
			if(dwSecondCount != dwFirstCount)
			{
				// Delete the contents of the array
				for(DWORD j=0; j<dwSecondCount; j++)
				{
					delete [] (*pppszClassNames)[j];
				}

				// Delete the array itself
				delete [] (*pppszClassNames);

				// Set return values to empty
				*pppszClassNames = NULL;
				*pdwNumRows = 0;

				result = E_FAIL;
			}
			else
				*pdwNumRows = dwFirstCount;

			// Close the search
			pDirectorySearchSchemaContainer->CloseSearchHandle(hADSSearchOuter);

		} // ExecuteSearch() - Outer
		delete [] lpszSearchFilter;
	}
	else // THIS IS THE SPECIAL CASE WHERE ALL SUBCLASSES (RECURSIVELY) OF A GIVEN CLASS ARE REQUIRED
	{
		// A lot of work has to be done. THis is handled by CLDAPClassProvider. Hence control shold never reach here
		result = E_FAIL;
	}
	return result;
}


// Gets the IDIrectoryObject interface on an ADSI instance
HRESULT CLDAPHelper :: GetADSIInstance(LPCWSTR szADSIPath, CADSIInstance **ppADSIObject, ProvDebugLog *pLogObject)
{
	HRESULT result;
	IDirectoryObject *pDirectoryObject;
	*ppADSIObject = NULL;

	try
	{
		if(SUCCEEDED(result = ADsOpenObject((LPWSTR)szADSIPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectoryObject, (LPVOID *)&pDirectoryObject)))
		{

			if(*ppADSIObject = new CADSIInstance(szADSIPath, pDirectoryObject))
			{
				PADS_ATTR_INFO pAttributeEntries;
				DWORD dwNumAttributes;
				if(SUCCEEDED(result = pDirectoryObject->GetObjectAttributes(NULL, -1, &pAttributeEntries, &dwNumAttributes)))
				{
					(*ppADSIObject)->SetAttributes(pAttributeEntries, dwNumAttributes);
					PADS_OBJECT_INFO pObjectInfo = NULL;
					if(SUCCEEDED(result = pDirectoryObject->GetObjectInformation(&pObjectInfo)))
					{
						(*ppADSIObject)->SetObjectInfo(pObjectInfo);
					}
					else
						pLogObject->WriteW( L"CLDAPHelper :: GetADSIInstance GetObjectInformation() FAILED on %s with %x\r\n", szADSIPath, result);
				}
				else
					pLogObject->WriteW( L"CLDAPHelper :: GetADSIInstance GetObjectAttributes() FAILED on %s with %x\r\n", szADSIPath, result);
			}
			else
				result = E_OUTOFMEMORY;
			pDirectoryObject->Release();
		}
		else
			pLogObject->WriteW( L"CLDAPHelper :: GetADSIInstance ADsOpenObject() FAILED on %s with %x\r\n", szADSIPath, result);
	}
	catch ( ... )
	{
		if ( *ppADSIObject )
		{
			delete *ppADSIObject;
			*ppADSIObject = NULL;
		}

		throw;
	}

	if(!SUCCEEDED(result))
	{
		delete *ppADSIObject;
		*ppADSIObject = NULL;
	}

	return result;
}

//***************************************************************************
//
// CLDAPHelper :: CreateADSIPath
//
// Purpose : Forms the ADSI path from a class or property name
//
// Parameters:
//	lpszLDAPSchemaObjectName : The LDAP class or property name
//	lpszSchemaContainerSuffix : The suffix to be used. The actual object fetced will be:
//			LDAP://CN=<lpszLDAPSchemaObjectName>,<lpszSchemaContainerSuffix>
// 
//	Return Value: The ADSI path to the class or property object. This has to
//	be deallocated by the user
//***************************************************************************
LPWSTR CLDAPHelper :: CreateADSIPath(LPCWSTR lpszLDAPSchemaObjectName,	
									 LPCWSTR lpszSchemaContainerSuffix)
{
	LPWSTR lpszADSIObjectPath = NULL;
	if(lpszADSIObjectPath = new WCHAR[wcslen(LDAP_CN_EQUALS) + wcslen(lpszLDAPSchemaObjectName) + wcslen(COMMA_STR) + wcslen(lpszSchemaContainerSuffix) + 1])
	{
		wcscpy(lpszADSIObjectPath, LDAP_CN_EQUALS);
		wcscat(lpszADSIObjectPath, lpszLDAPSchemaObjectName);
		wcscat(lpszADSIObjectPath, COMMA_STR);
		wcscat(lpszADSIObjectPath, lpszSchemaContainerSuffix);
	}
	return lpszADSIObjectPath;
}

//***************************************************************************
//
// CLDAPHelper :: UnmangleWBEMNameToLDAP
//
// Purpose : Converts a mangled WBEM name to LDAP
//	An underscore in LDAP maps to two underscores in WBEM
//	An hyphen in LDAP maps to one underscore in WBEM
//
// Parameters:
//	lpszWBEMName : The WBEM class or property name
// 
//	Return Value: The LDAP name to the class or property object. This has to
//	be deallocated by the user
//***************************************************************************
LPWSTR CLDAPHelper :: UnmangleWBEMNameToLDAP(LPCWSTR lpszWBEMName)
{
	DWORD iPrefixLength = 0;
	if(_wcsnicmp(lpszWBEMName, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX_LENGTH) == 0)
	{
		iPrefixLength = LDAP_ARTIFICIAL_CLASS_NAME_PREFIX_LENGTH;
	}
	else if (_wcsnicmp(lpszWBEMName, LDAP_CLASS_NAME_PREFIX, LDAP_CLASS_NAME_PREFIX_LENGTH) == 0)
	{
		iPrefixLength = LDAP_CLASS_NAME_PREFIX_LENGTH;
	}
	else
		return NULL;

	// The length of the resulting string (LDAP Name) is bound to be less than of equal to the length of WBEM name
	// So let's allocate the same as the wbem name length
	DWORD dwWbemNameLength = wcslen(lpszWBEMName) - iPrefixLength;
	LPWSTR lpszLDAPName = NULL;
	if(lpszLDAPName = new WCHAR[dwWbemNameLength + 1])
	{
		LPCWSTR lpszWBEMNameWithoutPrefix = lpszWBEMName + iPrefixLength;

		DWORD j=0;
		for(DWORD i=0; i<dwWbemNameLength; )
		{
			switch(lpszWBEMNameWithoutPrefix[i])
			{
				case (L'_'):
					if(lpszWBEMNameWithoutPrefix[i+1] == L'_')
					{
						i += 2;
						lpszLDAPName[j++] = L'_';
					}
					else
					{
						i++;
						lpszLDAPName[j++] = L'-';
					}
					break;

				default:
					lpszLDAPName[j++] = lpszWBEMNameWithoutPrefix[i++];

			}
		}
		lpszLDAPName[j] = NULL;
	}
	return lpszLDAPName;
}

//***************************************************************************
//
// CLDAPHelper :: MangleLDAPNameToWBEM
//
// Purpose : Converts a LDAP name to WBEM by mangling it
//	An underscore in LDAP maps to two underscores in WBEM
//	An hyphen in LDAP maps to one underscore in WBEM
//
// Parameters:
//	lpszLDAPName : The LDAP class or property name
// 
//	Return Value: The LDAP name to the class or property object. This has to
//	be deallocated by the user
//***************************************************************************
LPWSTR CLDAPHelper :: MangleLDAPNameToWBEM(LPCWSTR lpszLDAPName, BOOLEAN bArtificalName)
{
	if(!lpszLDAPName)
		return NULL;

	// The length of the resulting string (WBEM Name) is bound to be less than of equal to twice the length of LDAP name
	// So let's allocate double the LDAP name length
	DWORD dwLDAPNameLength = wcslen(lpszLDAPName);
	DWORD dwPrefixLength = (bArtificalName)? LDAP_ARTIFICIAL_CLASS_NAME_PREFIX_LENGTH : LDAP_CLASS_NAME_PREFIX_LENGTH;
	LPWSTR lpszWBEMName = NULL;
	
	if(lpszWBEMName = new WCHAR[2*dwLDAPNameLength + dwPrefixLength + 1])
	{
		// Prefix "DS_" or "ADS_"
		if(bArtificalName)
			wcscpy(lpszWBEMName, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX);
		else
			wcscpy(lpszWBEMName, LDAP_CLASS_NAME_PREFIX);

		DWORD j=dwPrefixLength;

		for(DWORD i=0; i<dwLDAPNameLength; i++)
		{
			switch(lpszLDAPName[i])
			{
				case (__TEXT('-')):
					lpszWBEMName[j++] = L'_';
					break;

				case (__TEXT('_')):
					lpszWBEMName[j++] = L'_';
					lpszWBEMName[j++] = L'_';
					break;

				default:
					lpszWBEMName[j++] = lpszLDAPName[i];

			}
		}
		lpszWBEMName[j] = NULL;
	}
	return lpszWBEMName;
}

void CLDAPHelper :: DeleteAttributeContents(PADS_ATTR_INFO pAttribute)
{
	// delete the name
	delete [] pAttribute->pszAttrName;

	// Delete each value
	for(DWORD i=0; i<pAttribute->dwNumValues; i++)
		DeleteADsValueContents(pAttribute->pADsValues + i);

	// Delete the array of values
	delete [] pAttribute->pADsValues;
}

void CLDAPHelper :: DeleteADsValueContents(PADSVALUE pValue)
{
	switch(pValue->dwType)
	{
		// Nothing to delete
		case ADSTYPE_BOOLEAN:
		case ADSTYPE_INTEGER:
		case ADSTYPE_LARGE_INTEGER:
			break;
		
		case ADSTYPE_UTC_TIME:
		case ADSTYPE_DN_STRING:
		case ADSTYPE_CASE_EXACT_STRING:
		case ADSTYPE_CASE_IGNORE_STRING:
		case ADSTYPE_PRINTABLE_STRING:
		case ADSTYPE_NUMERIC_STRING:
			delete [] pValue->DNString;
			break;
		
		case ADSTYPE_OCTET_STRING:
		case ADSTYPE_NT_SECURITY_DESCRIPTOR:
			delete [] (pValue->OctetString.lpValue);
			break;
		case ADSTYPE_DN_WITH_BINARY:
			delete [] (pValue->pDNWithBinary->lpBinaryValue);
			delete [] (pValue->pDNWithBinary->pszDNString);
			delete pValue->pDNWithBinary;
			break;

		case ADSTYPE_DN_WITH_STRING:
			delete [] (pValue->pDNWithString->pszStringValue);
			delete [] (pValue->pDNWithString->pszDNString);
			delete pValue->pDNWithString;
			break;

		default:
		// Cause a Null Pointer violation intentionally
		// Otherwise we leak memory
		{
			assert(0);
		}
		break;
	}
}

//***************************************************************************
//
// CLDAPHelper :: ExecuteQuery
//
// Purpose : See Header
//***************************************************************************
HRESULT CLDAPHelper :: ExecuteQuery(
	LPCWSTR pszPathToRoot,
	PADS_SEARCHPREF_INFO pSearchInfo,
	DWORD dwSearchInfoCount,
	LPCWSTR pszLDAPQuery,
	CADSIInstance ***pppADSIInstances,
	DWORD *pdwNumRows,
	ProvDebugLog *pLogObject)
{
	// Initialize the return values
	HRESULT result = E_FAIL;
	*pdwNumRows = 0;
	*pppADSIInstances = NULL;

	// Bind to the node from which the search should start
	IDirectorySearch *pDirectorySearchContainer = NULL;
	if(SUCCEEDED(result = ADsOpenObject((LPWSTR)pszPathToRoot, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectorySearch, (LPVOID *)&pDirectorySearchContainer)))
	{
		try
		{
			// Now perform a search for the attribute DISTINGUISHED_NAME_ATTR name
			if(SUCCEEDED(result = pDirectorySearchContainer->SetSearchPreference(pSearchInfo, dwSearchInfoCount)))
			{
				ADS_SEARCH_HANDLE hADSSearchOuter;

				if(SUCCEEDED(result = pDirectorySearchContainer->ExecuteSearch((LPWSTR) pszLDAPQuery, (LPWSTR *)&ADS_PATH_ATTR, 1, &hADSSearchOuter)))
				{
					*pdwNumRows = 0;
					// Calculate the number of rows first. 
					while(SUCCEEDED(result = pDirectorySearchContainer->GetNextRow(hADSSearchOuter)) &&
						result != S_ADS_NOMORE_ROWS)
						(*pdwNumRows) ++;

					try
					{
						// Do only if there were any rows
						if(*pdwNumRows)
						{
							// The index of the attribute being processed
							DWORD i = 0;

							// Allocate enough memory for the classes and names
							*pppADSIInstances = NULL;
							if(*pppADSIInstances = new CADSIInstance * [*pdwNumRows])
							{
								try
								{
									// Get the columns for the attributes
									ADS_SEARCH_COLUMN adsColumn;
									CADSIInstance *pADSIInstance = NULL;

									// Move to the first row
									if (SUCCEEDED(result = pDirectorySearchContainer->GetFirstRow(hADSSearchOuter))&&
											result != S_ADS_NOMORE_ROWS)
									{
										// Store each of the LDAP class attributes 
										if(SUCCEEDED(pDirectorySearchContainer->GetColumn(hADSSearchOuter, (LPWSTR)ADS_PATH_ATTR, &adsColumn)))
										{
											try
											{
												if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
													result = E_FAIL;
												else
												{
													// Create the CADSIInstance
													// Now get the attributes on this object

													if(SUCCEEDED(result = GetADSIInstance(adsColumn.pADsValues->DNString, &pADSIInstance, pLogObject)))
													{
														(*pppADSIInstances)[i] = pADSIInstance;
														i++;
													}
													else
														pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery GetADSIInstance() FAILED on %s with %x\r\n", adsColumn.pADsValues->DNString, result);
												}
											}
											catch ( ... )
											{
												pDirectorySearchContainer->FreeColumn( &adsColumn );
												throw;
											}

											// Free resouces
											pDirectorySearchContainer->FreeColumn( &adsColumn );
										}
										else
											pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery GetColumn() FAILED on %s with %x\r\n", pszLDAPQuery, result);

										// Get the other rows now
										if(SUCCEEDED(result))
										{
											while(SUCCEEDED(result = pDirectorySearchContainer->GetNextRow(hADSSearchOuter))&&
													result != S_ADS_NOMORE_ROWS)
											{

												// Store each of the LDAP class attributes 
												if(SUCCEEDED(pDirectorySearchContainer->GetColumn(hADSSearchOuter, (LPWSTR)ADS_PATH_ATTR, &adsColumn)))
												{
													try
													{
														if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
															result = E_FAIL;
														else
														{
															// Create the CADSIInstance
															// Now get the attributes on this object
															if(SUCCEEDED(result = GetADSIInstance(adsColumn.pADsValues->DNString, &pADSIInstance, pLogObject)))
															{
																(*pppADSIInstances)[i] = pADSIInstance;
																i++;
															}
															else
																pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery GetADSIInstance() FAILED on %s with %x\r\n", adsColumn.pADsValues->DNString, result);
														}
													}
													catch ( ... )
													{
														pDirectorySearchContainer->FreeColumn( &adsColumn );
														throw;
													}

													// Free resouces
													pDirectorySearchContainer->FreeColumn( &adsColumn );
												}
												else
													pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery GetColumn() FAILED on %s with %x\r\n", pszLDAPQuery, result);
											}
										}
									}
									else
										pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery GetFirstRow() FAILED on %s with %x\r\n", pszLDAPQuery, result);
								}
								catch ( ... )
								{
									// Delete the contents of the array
									for(DWORD j=0; j<i; j++)
										delete (*pppADSIInstances)[j];

									// Delete the array itself
									delete [] (*pppADSIInstances);

									// Set return values to empty
									*pppADSIInstances = NULL;
									*pdwNumRows = 0;

									throw;
								}
							}

							// Something went wrong? Release allocated resources
							if(i != *pdwNumRows)
							{
								pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery() Difference between Number of rows in 2 searches %d %d on %s Am invalidating the search as FAILED\r\n", i, *pdwNumRows, pszLDAPQuery);
								
								// Delete the contents of the array
								for(DWORD j=0; j<i; j++)
									delete (*pppADSIInstances)[j];

								// Delete the array itself
								delete [] (*pppADSIInstances);

								// Set return values to empty
								*pppADSIInstances = NULL;
								*pdwNumRows = 0;

								result = E_FAIL;
							}
						}
					}
					catch ( ... )
					{
						pDirectorySearchContainer->CloseSearchHandle(hADSSearchOuter);
						throw;
					}

					// Close the search. 
					pDirectorySearchContainer->CloseSearchHandle(hADSSearchOuter);
				} // ExecuteSearch() 
				else
					pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery ExecuteSearch() %s FAILED with %x\r\n", pszLDAPQuery, result);
			} // SetSearchPreference()
			else
				pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery SetSearchPreference() on %s FAILED with %x \r\n", pszPathToRoot, result);
		}
		catch ( ... )
		{
			pDirectorySearchContainer->Release();
			throw;
		}

		pDirectorySearchContainer->Release();
	} // ADsOpenObject
	else
		pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery ADsOpenObject() on %s FAILED with %x \r\n", pszPathToRoot, result);

	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\ldapprov.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:ldapprov.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the DS LDAP Class Provider class. This
// class provides the classes in the DS LDAP namespace to WBEM. Note that an instance of the CDSClassProviderInitializer
//	class has to be created to initialize the static members of the CDSClassProvider class. Hence exactly
//	one instance of the CLDAPClassProviderInitializer class should be created for this
//	class to function properly.
//
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef LDAP_CLASS_PROVIDER_H
#define LDAP_CLASS_PROVIDER_H

// Forward declaration for the initializer class
class CLDAPClassProviderInitializer;

class CLDAPClassProvider : public CDSClassProvider
{
	// The initializer class is a friend of this class
	friend CLDAPClassProviderInitializer;

public:

	//***************************************************************************
	//
	// CLDAPClassProvider::CLDAPClassProvider
	// CLDAPClassProvider::~CLDAPClassProvider
	//
	// Constructor Parameters:
	//  None
	//***************************************************************************
    CLDAPClassProvider () ;
    ~CLDAPClassProvider () ;

	//***************************************************************************
	//
	// CLDAPClassProvider::Initialize
	//
	// Purpose:
	//		As defined by the IWbemProviderInit interface
	//
	// Parameters:
	//		As defined by IWbemProviderInit interface
	// 
	//	Return Value: The COM status value indicating the status of the request
	//***************************************************************************
	HRESULT STDMETHODCALLTYPE Initialize( 
            LPWSTR wszUser,
            LONG lFlags,
            LPWSTR wszNamespace,
            LPWSTR wszLocale,
            IWbemServices __RPC_FAR *pNamespace,
            IWbemContext __RPC_FAR *pCtx,
            IWbemProviderInitSink __RPC_FAR *pInitSink) ;

	//***************************************************************************
	//
	// CLDAPClassProvider :: CreateClassEnumAsync
	//
	// Purpose: Enumerates the classes 
	//
	// Parameters:
	//	Standard parmaters as described by the IWbemServices interface
	//
	//
	// Return Value: As described by the IWbemServices interface
	//
	//***************************************************************************
	HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
		const BSTR strSuperclass,
		long lFlags,
		IWbemContext __RPC_FAR *pCtx,
		IWbemObjectSink __RPC_FAR *pResponseHandler);


protected:

	//***************************************************************************
	//
	// CLDAPClassProvider::InitializeLDAPProvider
	//
	// Purpose: A helper function to do the ADSI LDAP provider specific initialization.
	//
	// Parameters:
	//		pCtx	The context object used in this call initialization
	// 
	// Return Value: TRUE if the function successfully finishes the initializaion. FALSE
	//	otherwise
	//***************************************************************************
	BOOLEAN InitializeLDAPProvider(IWbemContext *pCtx);

	////////////////////////////////////////////////////////
	// Functions for interacting with the LDAP ADSI provider
	////////////////////////////////////////////////////////
	//***************************************************************************
	//
	// CLDAPClassProvider::GetADSIClass
	//
	// Purpose : To Create a CADSIClass from an ADSI classSchema object
	// Parameters:
	//		lpszWBEMClassName : The WBEM Name of the class to be fetched. 
	//		ppADSIClass : The address where the pointer to the CADSIClass will be stored.
	//			It is the caller's responsibility to Release() the object when done with it
	// 
	//	Return Value: The COM status value indicating the status of the request.
	//***************************************************************************
	HRESULT GetADSIClass(
		LPCWSTR lpszClassName, 
		CADSIClass ** ppADSIClass);

	//***************************************************************************
	//
	// CLDAPClassProvider::GetADSIProperty
	//
	// Purpose : To create an CADSIProperty object from an LDAP AttributeSchema object
	// Parameters:
	//		lpszPropertyName : The LDAPDisplayName of the LDAP property to be fetched. 
	//		ppADSIProperty : The address where the pointer to the IDirectoryObject interface will be stored
	//			It is the caller's responsibility to Release() the interface when done with it
	// 
	//	Return Value: The COM status value indicating the status of the request
	//***************************************************************************
	HRESULT GetADSIProperty(
		LPCWSTR lpszPropertyName, 
		CADSIProperty **ppADSIProperty);

	//***************************************************************************
	//
	// CLDAPClassProvider::GetWBEMBaseClassName
	//
	// Purpose : Returns the name of the class that is the base class of all classes
	//	provided by this provider.
	//
	// Parameters:
	//	None
	// 
	//	Return Value: The name of the base class. NULL if such a class doesnt exist.
	//***************************************************************************
	const BSTR GetWBEMBaseClassName();

	//***************************************************************************
	//
	// CLDAPClassProvider::GetWBEMBaseClass
	//
	// Purpose : Returns a pointer to the class that is the base class of all classes
	//	provided by this provider.
	//
	// Parameters:
	//	None
	// 
	//	Return Value: The IWbemClassObject pointer to the base class. It is the duty of 
	//	user to release the class when done with using it.
	//***************************************************************************
	IWbemClassObject * GetWBEMBaseClass();

	//***************************************************************************
	//
	// CLDAPClassProvider::GetWBEMProviderName
	//
	// Purpose : Returns the name of the provider. This should be the same as the
	// value of the field Name in the __Win32Provider instance used for registration
	// of the provider
	//
	// Parameters:
	//	None
	// 
	//	Return Value: The name of the provider
	//***************************************************************************
	const BSTR GetWBEMProviderName();

	//***************************************************************************
	//
	// CLDAPClassProvider::IsUnProvidedClass
	//
	// Purpose : To check whether a class is one that the provider does not provide
	//
	// Parameters:
	//	lpszClassName : The WBEM Name of the class to be checked
	//
	// 
	//	Return Value: TRUE is this is one of the classes not provided by the provider
	//***************************************************************************
	BOOLEAN IsUnProvidedClass(LPCWSTR lpszClassName);

	////////////////////////////////////////////////////////
	// Functions for handling a Get()
	////////////////////////////////////////////////////////
	//***************************************************************************
	//
	// CLDAPClassProvider::GetClassFromADSI
	//
	// Purpose : To create a WBEM class from an ADSI Class
	//
	// Parameters:
	//	lpszClassName : The WBEM Name of the class to be retreived
	//	pCtx : A pointer to the context object that was used in this call. This
	//		may be used by this function to make calls to CIMOM
	//	ppWbemClass : The resulting WBEM Class. This has to be released once the
	//		user is done with it.
	//
	// 
	//	Return Value: The COM result representing the status. 
	//***************************************************************************
	HRESULT GetClassFromADSI( 
		LPCWSTR lpszClassName,
		IWbemContext *pCtx,
		IWbemClassObject ** ppWbemClass
		);	
	
	//***************************************************************************
	//
	// CDSClassProvider::CreateWBEMClass
	//
	// Purpose: Creates WBEM Class corresponding an ADSI Class
	//
	// Parameters:
	//	pADSIClass : A pointer to a CADSI class object that is to be mapped to WBEM.
	//	ppWbemClass : The WBEM class object retrieved. This is created by this function.
	//		The caller should release it when done
	//	pCtx : The context object that was used in this provider call
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	virtual HRESULT CreateWBEMClass (CADSIClass *pADSIClass, int iCaseNumber, IWbemClassObject **ppWbemClass, IWbemContext *pCtx);

	//***************************************************************************
	//
	// CDSClassProvider::MapClassSystemProperties
	//
	// Purpose: Creates an appropriately derived WBEM class and names it (__CLASS)
	//
	// Parameters:
	//	pADSIClass : The ADSI class that is being mapped
	//	ppWbemClass : The WBEM class object retrieved. This is created by this function.
	//		The caller should release it when done
	//	pCtx : The context object that was used in this provider call
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	virtual HRESULT MapClassSystemProperties(CADSIClass *pADSIClass, int iCaseNumber, IWbemClassObject **ppWbemClass, IWbemContext *pCtx);

	//***************************************************************************
	//
	// CDSClassProvider :: MapClassQualifiersToWBEM
	//
	// Purpose: Creates the class qualifiers for a WBEM class from the ADSI class
	//
	// Parameters:
	//	pADSIClass : The LDAP class that is being mapped
	//	pWbemClass : The WBEM class object being created. T
	//	pCtx : The context object that was used in this provider call
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	virtual HRESULT MapClassQualifiersToWBEM(CADSIClass *pADSIClass, int iCaseNumber, IWbemClassObject *pWbemClass, IWbemContext *pCtx);

	//***************************************************************************
	//
	// CDSClassProvider :: MapClassPropertiesToWBEM
	//
	// Purpose: Creates the class properties for a WBEM class from the ADSI class
	//
	// Parameters:
	//	pADSIClass : The LDAP class that is being mapped
	//	pWbemClass : The WBEM class object being created. 
	//	pCtx : The context object that was used in this provider call
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	virtual HRESULT MapClassPropertiesToWBEM(CADSIClass *pADSIClass, IWbemClassObject *pWbemClass, IWbemContext *pCtx);

	//***************************************************************************
	//
	// CLDAPClassProvider :: MapPropertyListToWBEM
	//
	// Purpose: Maps a list of class properties for a WBEM class from the ADSI class
	//
	// Parameters:
	//	pWbemClass : The WBEM class object being created. 
	//	lppszPropertyList : A list of propery names
	//	dwCOunt : The number of items in the above list
	//	bMapSystemQualifier : Whether the "system" qualifier should be mapped
	//	bMapNotNullQualifier: Whether the "notNull" qualifier should be mapped
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	HRESULT MapPropertyListToWBEM(IWbemClassObject *pWbemClass, 
									LPCWSTR *lppszPropertyList, 
									DWORD dwCount, 
									BOOLEAN bMapSystemQualifier, 
									BOOLEAN bMapNotNullQualifier);

	//***************************************************************************
	//
	// CLDAPClassProvider :: CreateWBEMProperty
	//
	// Purpose: Creates a WBEM property from an LDAP property
	//
	// Parameters:
	//	pWbemClass : The WBEM class in which the property is created
	//	ppQualiferSet : The address of the pointer to IWbemQualiferSet where the qualifier set
	//		of this property will be placed
	//	pADSIProperty : The ADSI Property object that is being mapped to the property being created
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************	
	HRESULT CreateWBEMProperty(IWbemClassObject *pWbemClass, IWbemQualifierSet **ppQualifierSet, CADSIProperty *pNextProperty);

	//***************************************************************************
	//
	// CLDAPClassProvider :: MapLDAPSyntaxToWBEM
	//
	// Purpose: Maps the LDAP Syntax to WBEM
	//
	// Parameters:
	//	pADSIProperty = Pointer to the CADSIProperty object representing this attribute
	//
	// Return Value: The CIMTYPE value representing the WBEM Syntax for the LDAP Syntax. If
	// the syntax is unmappable, then CIM_STRING or CIM_STRING | CIM_FLAG_ARRAY is returned
	//
	//***************************************************************************
	CIMTYPE MapLDAPSyntaxToWBEM(CADSIProperty *pADSIProperty, BSTR *pstrCimTypeQualifier);

	/////////////////////////////////////
	/// Functions for Enumeration
	//////////////////////////////////////
	//***************************************************************************
	//
	// CLDAPClassProvider :: GetOneLevelDeep
	//
	// Purpose: Enumerates the sub classes of a superclass non-recursively
	//
	// Parameters:
	//
	//	lpszSuperClass : The super class name
	//	pResponseHandler : The interface where the resulting classes are put
	//
	//
	// Return Value: As described by the IWbemServices interface
	//
	//***************************************************************************
	HRESULT GetOneLevelDeep( 
		LPCWSTR lpszWBEMSuperclass,
		BOOLEAN bArtificialClass,
		LPWSTR ** pppADSIClasses,
		DWORD *pdwNumClasses,
		IWbemContext *pCtx);

	//***************************************************************************
	//
	// CLDAPClassProvider :: HandleRecursiveEnumeration
	//
	// Purpose: Enumerates the sub classes of a superclass recursively
	//
	// Parameters:
	//
	//	lpszSuperClass : The super class name
	//	pResponseHandler : The interface where the resulting classes are put
	//
	//
	// Return Value: As described by the IWbemServices interface
	//
	//***************************************************************************
	HRESULT HandleRecursiveEnumeration( 
		LPCWSTR lpszSuperclass,
		IWbemContext *pCtx,
		IWbemObjectSink *pResponseHandler);

	//***************************************************************************
	//
	// CLDAPClassProvider :: WrapUpEnumeration
	//
	// Purpose: Creates WBEM classes from ADSI classes 
	//
	// Parameters:
	//
	//	lpszSuperClass : The super class name
	//	pResponseHandler : The interface where the resulting classes are put
	//
	//
	// Return Value: As described by the IWbemServices interface
	//
	//***************************************************************************
	HRESULT WrapUpEnumeration( 
		LPWSTR *ppADSIClasses,
		DWORD dwNumClasses,
		IWbemContext *pCtx,
		IWbemObjectSink *pResponseHandler);

	//***************************************************************************
	//
	// CLDAPClassProvider :: IsConcreteClass
	//
	// Purpose: Find out whether a WBEM class is concrete. First checks in the WBEM Cache and then calls GetClassFromCacheorADSI()
	//
	// Parameters:
	//
	//	pszWBEMName : The class name
	//
	//
	// Return Value: As described by the IWbemServices interface
	//
	//***************************************************************************
	HRESULT IsConcreteClass( 
		LPCWSTR pszWBEMName,
		IWbemContext *pCtx);

	// Convert all characters to lower case
	void SanitizedClassName(LPWSTR lpszClassName);

private:

	// LDAP Class attribute names 
	static BSTR COMMON_NAME_ATTR_BSTR;
	static BSTR LDAP_DISPLAY_NAME_ATTR_BSTR;
	static BSTR GOVERNS_ID_ATTR_BSTR;
	static BSTR SCHEMA_ID_GUID_ATTR_BSTR;
	static BSTR MAPI_DISPLAY_TYPE_ATTR_BSTR;
	static BSTR RDN_ATT_ID_ATTR_BSTR;
	static BSTR SYSTEM_MUST_CONTAIN_ATTR_BSTR;
	static BSTR MUST_CONTAIN_ATTR_BSTR;
	static BSTR SYSTEM_MAY_CONTAIN_ATTR_BSTR;
	static BSTR MAY_CONTAIN_ATTR_BSTR;
	static BSTR SYSTEM_POSS_SUPERIORS_ATTR_BSTR;
	static BSTR POSS_SUPERIORS_ATTR_BSTR;
	static BSTR SYSTEM_AUXILIARY_CLASS_ATTR_BSTR;
	static BSTR AUXILIARY_CLASS_ATTR_BSTR;
	static BSTR DEFAULT_SECURITY_DESCRP_ATTR_BSTR;
	static BSTR OBJECT_CLASS_CATEGORY_ATTR_BSTR;
	static BSTR SYSTEM_ONLY_ATTR_BSTR;
	static BSTR NT_SECURITY_DESCRIPTOR_ATTR_BSTR;
	static BSTR DEFAULT_OBJECTCATEGORY_ATTR_BSTR;

	// Provider specific literals
	static BSTR	LDAP_BASE_CLASS_STR;
	static BSTR	LDAP_CLASS_PROVIDER_NAME;
	static BSTR	LDAP_INSTANCE_PROVIDER_NAME;

	// WBEM Class Qualifier names
	static BSTR	DYNAMIC_BSTR;
	static BSTR	PROVIDER_BSTR;
	static BSTR	ABSTRACT_BSTR;

	// WBEM Property Qualifier names
	static BSTR SYSTEM_BSTR;
	static BSTR NOT_NULL_BSTR;
	static BSTR INDEXED_BSTR;
	static BSTR ATTRIBUTE_SYNTAX_ATTR_BSTR;
	static BSTR ATTRIBUTE_ID_ATTR_BSTR;
	static BSTR MAPI_ID_ATTR_BSTR;
	static BSTR OM_SYNTAX_ATTR_BSTR;
	static BSTR RANGE_LOWER_ATTR_BSTR;
	static BSTR RANGE_UPPER_ATTR_BSTR;

	// Qualifiers for embedded objects
	static BSTR CIMTYPE_STR;
	static BSTR EMBED_UINT8ARRAY;
	static BSTR EMBED_DN_WITH_STRING;
	static BSTR EMBED_DN_WITH_BINARY;

	// WBEM Property names
	static BSTR DYNASTY_BSTR;

	// The default flavor for qualifiers
	static LONG DEFAULT_QUALIFIER_FLAVOUR;

	// These are the search preferences often used
	ADS_SEARCHPREF_INFO m_searchInfo1;

	// The LDAP property cache
	static CLDAPCache *s_pLDAPCache;

	// The base class of all the LDAP Provider Classes.
	IWbemClassObject *m_pLDAPBaseClass;

};


#endif // LDAP_CLASS_PROVIDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\log.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include <stdio.h>
#include <time.h>
#include <tchar.h>
#include <windows.h>
#include <comdef.h>

#include "provlog.h"


//***************************************************************************
//
// CDsLog::CDsLog
//
// Purpose: Contructs an empty CDsLog object.
//
// Parameters:
//  None
//
//***************************************************************************
CDsLog :: CDsLog()
{
	m_lpszLogFileName = NULL;
	m_fpLogFile = NULL;

	// Turn on logging by default
	m_bEnabled = TRUE;

	// Enable all severity levels
	m_iLevel = NONE;
}

//***************************************************************************
//
// CDsLog::~CDsLog
//
// Purpose: Destructor
//
//
//***************************************************************************
CDsLog :: ~CDsLog()
{
	delete [] m_lpszLogFileName;

	if(m_fpLogFile)
		fclose(m_fpLogFile);
}

//***************************************************************************
//
// CDsLog::LogMessage
//
// Purpose: See Header
//
//***************************************************************************
BOOLEAN CDsLog :: Initialise(LPCWSTR lpszRegistrySubTreeRoot) 
{
	// Get the various values from the registry
	if(!GetRegistryValues(lpszRegistrySubTreeRoot))
		return FALSE;

	// Open the Log File
	m_fpLogFile = _tfopen((LPTSTR)(_bstr_t)(m_lpszLogFileName), __TEXT("w"));
	if(m_fpLogFile)
		WriteInitialMessage();
	return (m_fpLogFile != NULL);
}

//***************************************************************************
//
// CDsLog::LogMessage
//
// Purpose: See Header
//
//***************************************************************************
BOOLEAN CDsLog :: Initialise(LPCWSTR lpszFileName, BOOLEAN bEnabled, UINT iLevel)
{
	m_bEnabled = bEnabled;
	m_iLevel = iLevel;

	m_fpLogFile = _tfopen((LPTSTR)(_bstr_t)(lpszFileName), __TEXT("w"));
	if(m_fpLogFile)
		WriteInitialMessage();
	return (m_fpLogFile != NULL);
}


//***************************************************************************
//
// CDsLog::LogMessage
//
// Purpose: See Header
//
//***************************************************************************
void CDsLog :: LogMessage(UINT iLevel, LPCWSTR lpszMessage, ...)
{

	va_list marker;
	va_start(marker, lpszMessage);

	if(m_bEnabled && iLevel >= m_iLevel)
	{
		EnterCriticalSection(&m_FileCriticalSection);

		_vftprintf(m_fpLogFile, lpszMessage, marker);
		fflush(m_fpLogFile);

		LeaveCriticalSection(&m_FileCriticalSection);
	}

	va_end(marker);

}

//***************************************************************************
//
// CDsLog::GetRegistryValues
//
// Purpose: See Header
//***************************************************************************
BOOLEAN CDsLog :: GetRegistryValues(LPCWSTR lpszRegistrySubTreeRoot)
{
	HKEY subtreeRootKey;
	if( RegOpenKeyEx(HKEY_LOCAL_MACHINE,
					(LPTSTR)(_bstr_t)(lpszRegistrySubTreeRoot),
					0,
					KEY_READ,
					&subtreeRootKey) != ERROR_SUCCESS)
		return FALSE;

	BOOLEAN retVal = TRUE;

	// Retrieve the "File" value
	LONG lDataLength = 0;
	if(RegQueryValue(subtreeRootKey,
		FILE_STRING,
		NULL,	
		&lDataLength) == ERROR_SUCCESS)
	{
		m_lpszLogFileName = new TCHAR [lDataLength + 1];


		if(RegQueryValue(subtreeRootKey,
			FILE_STRING,
			m_lpszLogFileName,	
			&lDataLength) != ERROR_SUCCESS)
		{
			retVal = FALSE;
		}
	}
	else
		retVal = FALSE;

	// Retrieve the "Enabled" value
	lDataLength = 0;
	if(RegQueryValue(subtreeRootKey,
		ENABLED_STRING,
		NULL,	
		&lDataLength) == ERROR_SUCCESS)
	{
		LPTSTR lpszEnabled = new TCHAR [lDataLength + 1];

		if(RegQueryValue(subtreeRootKey,
			FILE_STRING,
			lpszEnabled,	
			&lDataLength) != ERROR_SUCCESS)
		{
			retVal = FALSE;
		}
		else // Convert the string to boolena
		{
			if(_tcscmp(lpszEnabled, ONE_STRING) == 0)
				m_bEnabled = TRUE;
			else
				m_bEnabled = FALSE;
		}

		delete [] lpszEnabled;
	}
	else
		retVal = FALSE;

	// Retrieve the "Level" value
	lDataLength = 0;
	if(RegQueryValue(subtreeRootKey,
		LEVEL_STRING,
		NULL,	
		&lDataLength) == ERROR_SUCCESS)
	{
		LPTSTR lpszEnabled = new TCHAR [lDataLength + 1];

		if(RegQueryValue(subtreeRootKey,
			FILE_STRING,
			lpszEnabled,	
			&lDataLength) != ERROR_SUCCESS)
		{
			retVal = FALSE;
		}
		else // Convert the string to boolena
		{
			if(_tcscmp(lpszEnabled, ONE_STRING) == 0)
				m_bEnabled = TRUE;
			else
				m_bEnabled = FALSE;
		}

		delete [] lpszEnabled;
	}
	else
		retVal = FALSE;

	// Close the registry key
	RegCloseKey(subtreeRootKey);
	return retVal;
}

//***************************************************************************
//
// CDsLog::WriteInitialMessage
//
// Purpose: See Header
//***************************************************************************
void CDsLog :: WriteInitialMessage()
{
	if(m_bEnabled)
	{
		EnterCriticalSection(&m_FileCriticalSection);

		// Get the DateTime in Ascii format
		struct tm *newtime;        
		time_t long_time;
		time( &long_time );                /* Get time as long integer. */
		newtime = localtime( &long_time ); /* Convert to local time. */
		_ftprintf(m_fpLogFile, __TEXT("Log File Created at : %s\n"), _tasctime(newtime));
		_ftprintf(m_fpLogFile, __TEXT("================================================\n\n"));
		fflush(m_fpLogFile);
		LeaveCriticalSection(&m_FileCriticalSection);

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\ldapprov.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:ldapprov.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains implementation of the DS LDAP Class Provider class. 
//
//***************************************************************************

#include "precomp.h"

/////////////////////////////////////////
// Initialize the static members
/////////////////////////////////////////
CLDAPCache *CLDAPClassProvider :: s_pLDAPCache		= NULL;	
DWORD CLDAPClassProvider::dwClassProviderCount = 0;

BSTR CLDAPClassProvider:: LDAP_BASE_CLASS_STR			= NULL;
BSTR CLDAPClassProvider:: LDAP_CLASS_PROVIDER_NAME		= NULL;
BSTR CLDAPClassProvider:: LDAP_INSTANCE_PROVIDER_NAME	= NULL;

// Names of the LDAP class attributes
BSTR CLDAPClassProvider :: COMMON_NAME_ATTR_BSTR			= NULL;
BSTR CLDAPClassProvider :: LDAP_DISPLAY_NAME_ATTR_BSTR		= NULL;
BSTR CLDAPClassProvider :: GOVERNS_ID_ATTR_BSTR				= NULL;
BSTR CLDAPClassProvider :: SCHEMA_ID_GUID_ATTR_BSTR			= NULL;
BSTR CLDAPClassProvider :: MAPI_DISPLAY_TYPE_ATTR_BSTR		= NULL;
BSTR CLDAPClassProvider :: RDN_ATT_ID_ATTR_BSTR				= NULL;
BSTR CLDAPClassProvider :: SYSTEM_MUST_CONTAIN_ATTR_BSTR	= NULL;
BSTR CLDAPClassProvider :: MUST_CONTAIN_ATTR_BSTR			= NULL;
BSTR CLDAPClassProvider :: SYSTEM_MAY_CONTAIN_ATTR_BSTR		= NULL;
BSTR CLDAPClassProvider :: MAY_CONTAIN_ATTR_BSTR			= NULL;
BSTR CLDAPClassProvider :: SYSTEM_POSS_SUPERIORS_ATTR_BSTR	= NULL;
BSTR CLDAPClassProvider :: POSS_SUPERIORS_ATTR_BSTR			= NULL;
BSTR CLDAPClassProvider :: SYSTEM_AUXILIARY_CLASS_ATTR_BSTR	= NULL;
BSTR CLDAPClassProvider :: AUXILIARY_CLASS_ATTR_BSTR		= NULL;
BSTR CLDAPClassProvider :: DEFAULT_SECURITY_DESCRP_ATTR_BSTR= NULL;
BSTR CLDAPClassProvider :: OBJECT_CLASS_CATEGORY_ATTR_BSTR	= NULL;
BSTR CLDAPClassProvider :: SYSTEM_ONLY_ATTR_BSTR			= NULL;
BSTR CLDAPClassProvider :: NT_SECURITY_DESCRIPTOR_ATTR_BSTR	= NULL;
BSTR CLDAPClassProvider :: DEFAULT_OBJECTCATEGORY_ATTR_BSTR	= NULL;


// Names of the LDAP property attributes
BSTR CLDAPClassProvider :: ATTRIBUTE_SYNTAX_ATTR_BSTR	= NULL;
BSTR CLDAPClassProvider :: ATTRIBUTE_ID_ATTR_BSTR		= NULL;
BSTR CLDAPClassProvider :: MAPI_ID_ATTR_BSTR			= NULL;
BSTR CLDAPClassProvider :: OM_SYNTAX_ATTR_BSTR			= NULL;
BSTR CLDAPClassProvider :: RANGE_LOWER_ATTR_BSTR		= NULL;
BSTR CLDAPClassProvider :: RANGE_UPPER_ATTR_BSTR		= NULL;

// Qualifiers for embedded objects
BSTR CLDAPClassProvider :: CIMTYPE_STR			= NULL;
BSTR CLDAPClassProvider :: EMBED_UINT8ARRAY		= NULL;
BSTR CLDAPClassProvider :: EMBED_DN_WITH_STRING = NULL;
BSTR CLDAPClassProvider :: EMBED_DN_WITH_BINARY = NULL;


// Default Qualifier Flavour
LONG CLDAPClassProvider :: DEFAULT_QUALIFIER_FLAVOUR = WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS | WBEM_FLAVOR_OVERRIDABLE ;

// Names of WBEM Class Qualifiers
BSTR CLDAPClassProvider:: DYNAMIC_BSTR			= NULL;
BSTR CLDAPClassProvider:: PROVIDER_BSTR			= NULL;
BSTR CLDAPClassProvider:: ABSTRACT_BSTR			= NULL;

// Names of WBEM Property Qualifiers
BSTR CLDAPClassProvider :: SYSTEM_BSTR			= NULL;
BSTR CLDAPClassProvider :: NOT_NULL_BSTR		= NULL;
BSTR CLDAPClassProvider :: INDEXED_BSTR			= NULL;

// Names of WBEM properties
BSTR CLDAPClassProvider :: DYNASTY_BSTR			= NULL;

//***************************************************************************
//
// CLDAPClassProvider::CLDAPClassProvider
// CLDAPClassProvider::~CLDAPClassProvider
//
// Constructor Parameters:
//  None
//***************************************************************************

CLDAPClassProvider :: CLDAPClassProvider ()
: CDSClassProvider()
{
	// Initialize the search preferences often used
	m_searchInfo1.dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
	m_searchInfo1.vValue.Integer = ADS_SCOPE_ONELEVEL;
	m_searchInfo1.dwStatus = ADS_STATUS_S_OK;

	m_pLDAPBaseClass = NULL;
	dwClassProviderCount++;
}

CLDAPClassProvider::~CLDAPClassProvider ()
{
	g_pLogObject->WriteW( L"CLDAPClassProvider :: ~CLDAPClassProvider() Called\r\n");
	dwClassProviderCount --;
	if(m_pLDAPBaseClass)
		m_pLDAPBaseClass->Release();
}

//***************************************************************************
//
// CLDAPClassProvider::Initialize
//
// Purpose:
//		As defined by the IWbemProviderInit interface
//
// Parameters:
//		As defined by IWbemProviderInit interface
// 
//	Return Value: The COM status value indicating the status of the request
//***************************************************************************

HRESULT CLDAPClassProvider :: Initialize( 
        LPWSTR wszUser,
        LONG lFlags,
        LPWSTR wszNamespace,
        LPWSTR wszLocale,
        IWbemServices __RPC_FAR *pNamespace,
        IWbemContext __RPC_FAR *pCtx,
        IWbemProviderInitSink __RPC_FAR *pInitSink)
{

	// Validate the arguments
	if( pNamespace == NULL || lFlags != 0 )
	{
		g_pLogObject->WriteW( L"CLDAPClassProvider :: Argument validation FAILED\r\n");
		pInitSink->SetStatus(WBEM_E_FAILED, 0);
		return WBEM_S_NO_ERROR;
	}

	g_pLogObject->WriteW( L"CLDAPClassProvider :: Initialize() Called\r\n");

	// Store the IWbemServices pointer for future use
	m_IWbemServices = pNamespace;
	m_IWbemServices->AddRef();


	// Do LDAP Provider initialization
	if(!InitializeLDAPProvider(pCtx))
	{
		g_pLogObject->WriteW( L"CLDAPClassProvider :: InitializeLDAPProvider FAILED\r\n");
		m_IWbemServices->Release();
		m_IWbemServices = NULL;

		// Do not set the status to failed for purposes of installation (MOFCOMP fails!)
		// Instead return a success but set an internal status value to FALSE
		// All operations should return FAILED if this internal status value is set to FALSE
		m_bInitializedSuccessfully = FALSE;
	}
	else
		m_bInitializedSuccessfully = TRUE;

	pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
	return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
// CLDAPClassProvider::InitializeLDAPProvider
//
// Purpose: A helper function to do the ADSI LDAP provider specific initialization.
//
// Parameters:
//		pCtx	The context object used in this call initialization
// 
// Return Value: TRUE if the function successfully finishes the initializaion. FALSE
//	otherwise
//***************************************************************************
BOOLEAN CLDAPClassProvider :: InitializeLDAPProvider(IWbemContext *pCtx)
{
	// Get the static classes used by the LDAP provider
	HRESULT result = WBEM_E_FAILED;
	if(SUCCEEDED(result = m_IWbemServices->GetObject(LDAP_BASE_CLASS_STR, 0, pCtx, &m_pLDAPBaseClass, NULL)))
	{
		result = (s_pLDAPCache->IsInitialized())? S_OK : E_FAIL;
	}
	else
		g_pLogObject->WriteW( L"CLDAPClassProvider :: InitializeLDAPProvider GetObject on base LDAP class FAILED : %x\r\n", result);

	return SUCCEEDED(result);
}		

//***************************************************************************
//
// CLDAPClassProvider::GetADSIClass
//
// Purpose : To Create a CADSIClass from an ADSI classSchema object
// Parameters:
//		lpszWBEMClassName : The WBEM Name of the class to be fetched. 
//		ppADSIClass : The address where the pointer to the CADSIClass will be stored.
//			It is the caller's responsibility to Release() the object when done with it
// 
//	Return Value: The COM status value indicating the status of the request.
//***************************************************************************
HRESULT CLDAPClassProvider :: GetADSIClass(LPCWSTR lpszADSIClassName, CADSIClass **ppADSIClass)
{
	// Convert the WBEM Class Name to LDAP
	LPWSTR lpszWBEMClassName = CLDAPHelper::MangleLDAPNameToWBEM(lpszADSIClassName);
	HRESULT result = s_pLDAPCache->GetClass(lpszWBEMClassName, lpszADSIClassName, ppADSIClass);

	delete[] lpszWBEMClassName;
	return result;
}

//***************************************************************************
//
// CLDAPClassProvider::GetADSIProperty
//
// Purpose : To create an CADSIProperty object from an LDAP AttributeSchema object
// Parameters:
//		lpszPropertyName : The LDAPDisplayName of the LDAP property to be fetched. 
//		ppADSIProperty : The address where the pointer to the IDirectoryObject interface will be stored
//			It is the caller's responsibility to Release() the interface when done with it
// 
//	Return Value: The COM status value indicating the status of the request
//***************************************************************************
HRESULT CLDAPClassProvider :: GetADSIProperty(LPCWSTR lpszPropertyName, CADSIProperty **ppADSIProperty)
{
	return s_pLDAPCache->GetProperty(lpszPropertyName, ppADSIProperty, FALSE);
}


//***************************************************************************
//
// CLDAPClassProvider::GetWBEMBaseClassName
//
// Purpose : Returns the name of the class that is the base class of all classes
//	provided by this provider.
//
// Parameters:
//	None
// 
//	Return Value: The name of the base class. NULL if such a class doesnt exist.
//***************************************************************************
const BSTR CLDAPClassProvider :: GetWBEMBaseClassName()
{
	return LDAP_BASE_CLASS_STR; 
}

//***************************************************************************
//
// CLDAPClassProvider::GetWBEMBaseClass
//
// Purpose : Returns a pointer to the class that is the base class of all classes
//	provided by this provider.
//
// Parameters:
//	None
// 
//	Return Value: The IWbemClassObject pointer to the base class. It is the duty of 
//	user to release the class when done with using it.
//***************************************************************************
IWbemClassObject * CLDAPClassProvider :: GetWBEMBaseClass()
{
	m_pLDAPBaseClass->AddRef();
	return m_pLDAPBaseClass;
}


//***************************************************************************
//
// CLDAPClassProvider::GetWBEMProviderName
//
// Purpose : Returns the name of the provider. This should be the same as the
// value of the field Name in the __Win32Provider instance used for registration
// of the provider
//
// Parameters:
//	None
// 
//	Return Value: The name of the provider
//***************************************************************************
const BSTR CLDAPClassProvider :: GetWBEMProviderName()
{
	return LDAP_CLASS_PROVIDER_NAME; 
}

//***************************************************************************
//
// CLDAPClassProvider::IsUnProvidedClass
//
// Purpose : See header
//***************************************************************************
BOOLEAN CLDAPClassProvider :: IsUnProvidedClass(LPCWSTR lpszClassName)
{
	// CHeck if it is one of the static classes
	if(_wcsicmp(lpszClassName, LDAP_BASE_CLASS_STR) == 0 ||
		_wcsicmp(lpszClassName, UINT8ARRAY_CLASS) == 0 ||
		_wcsicmp(lpszClassName, DN_WITH_STRING_CLASS) == 0 ||
		_wcsicmp(lpszClassName, DN_WITH_BINARY_CLASS) == 0 ||
		_wcsicmp(lpszClassName, ROOTDSE_CLASS) == 0 ||
		_wcsicmp(lpszClassName, CLASS_ASSOCIATION_CLASS) == 0 ||
		_wcsicmp(lpszClassName, DN_ASSOCIATION_CLASS) == 0 ||
		_wcsicmp(lpszClassName, DN_CLASS) == 0 ||
		_wcsicmp(lpszClassName, INSTANCE_ASSOCIATION_CLASS) == 0)
		return TRUE;

	// Next check if it has appropriate profixes
	if(_wcsnicmp(lpszClassName, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX_LENGTH) == 0 ||
		_wcsnicmp(lpszClassName, LDAP_CLASS_NAME_PREFIX, LDAP_CLASS_NAME_PREFIX_LENGTH) == 0 )
	{
		return FALSE;
	}

	return TRUE;
}

//***************************************************************************
//
// CLDAPClassProvider::GetClassFromADSI
//
// Purpose : To return the IDirectoryObject interface on the schema container
//
// Parameters:
//	lpszClassName : The WBEM Name of the class to be retreived
//	pCtx : A pointer to the context object that was used in this call. This
//		may be used by this function to make calls to CIMOM
//	ppWbemClass : The resulting WBEM Class. This has to be released once the
//		user is done with it.
//
// 
//	Return Value: The COM result representing the status. 
//***************************************************************************
HRESULT CLDAPClassProvider :: GetClassFromADSI( 
    LPCWSTR lpszWbemClassName,
    IWbemContext *pCtx,
	IWbemClassObject ** ppWbemClass
	)
{
	HRESULT result = E_FAIL;
	BOOLEAN bArtificialClass = FALSE;
	BOOLEAN bAbstractDSClass = FALSE;
	LPWSTR lpszADSIClassName = NULL;

	// First check if this is one our "artificial" classes. All "aritificial" classes start with "ads_".
	// All non artificial classes start with "ds_"
	if(!(lpszADSIClassName = CLDAPHelper::UnmangleWBEMNameToLDAP(lpszWbemClassName)))
	{
		*ppWbemClass = NULL;
		return result;
	}

	if(_wcsnicmp(lpszWbemClassName, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX_LENGTH) == 0)
		bArtificialClass = TRUE;

	CADSIClass *pADSIClass = NULL;
	CADSIClass *pADSIParentClass = NULL;

	try
	{
		if(SUCCEEDED(result = GetADSIClass(lpszADSIClassName, &pADSIClass)))
		{
			pADSIClass->SetWBEMClassName(lpszWbemClassName);

			// It is an abstract class is the ADSI class type is Abstract or Auxiliary
			if(pADSIClass->GetObjectClassCategory() == 2 || pADSIClass->GetObjectClassCategory() == 3) 
				bAbstractDSClass = TRUE;

			int iCaseNumber = 0;

			// if the WBEM class name starts with "ADS_" and the DS class is abstract, then this is an error
			if(bArtificialClass && bAbstractDSClass)
				result = WBEM_E_NOT_FOUND;
			else
			{
				// Special case for "top" since the DS returns top as the superclass of top
				if(_wcsicmp(lpszWbemClassName, TOP_CLASS) == 0)
					iCaseNumber = 1;
				else
				{
					if(pADSIClass->GetSuperClassLDAPName())
					{
						// If this is an artificial class
						// Then
						//		Get the ParentDS Class
						//		If the ParentDSClass is abstract 
						//		Then
						//			WMI Parent class is the non-artificial class. Case 2
						//		Else
						//			WMI Parent class is artificial. Case 3
						// Else
						//		If the Current DS Class is abstract
						//		Then
						//			WMI Parent is non-artificial. Case 4
						//		Else
						//			WMI Parent is artificial. Case 5
						//
						if(bArtificialClass)
						{
							// Get the parent DS Class
							if(SUCCEEDED(result = GetADSIClass(pADSIClass->GetSuperClassLDAPName(), &pADSIParentClass)))
							{
								if(pADSIParentClass->GetObjectClassCategory() == 2 || pADSIParentClass->GetObjectClassCategory() == 3) 
								{
									iCaseNumber = 2;
								}
								else
								{
									iCaseNumber = 3;
								}
							}
						}
						else
						{
							if(bAbstractDSClass)
							{
								iCaseNumber = 4;
							}
							else
							{
								iCaseNumber = 5;
							}
						}
					}
					else
						iCaseNumber = 1;
				}	
				
				// Map the ADSI class to a WBEM Class
				if(iCaseNumber != 0 && SUCCEEDED(result = CreateWBEMClass(pADSIClass, iCaseNumber, ppWbemClass,  pCtx)))
				{
				}
				else
				{
					result = WBEM_E_FAILED;
					g_pLogObject->WriteW(L"CLDAPClassProvider :: GetClassFromADSI() : CreateWBEMClass FAILED: %x for %s\r\n", result, lpszWbemClassName);
				}
			}

			// Free the parent ADSI class
			if(pADSIParentClass)
			{
				pADSIParentClass->Release();
				pADSIParentClass = NULL;
			}

			// Free the ADSI Class
			if ( pADSIClass )
			{
				pADSIClass->Release();
				pADSIClass = NULL;
			}
		}
		else
			g_pLogObject->WriteW( L"CLDAPClassProvider :: GetClassFromADSI() GetADSIClass FAILED : %x for %s\r\n", result, lpszWbemClassName);
	}
	catch ( ... )
	{
		// Free the parent ADSI class
		if ( pADSIParentClass )
		{
			pADSIParentClass->Release();
			pADSIParentClass = NULL;
		}

		// Free the ADSI Class
		if ( pADSIClass )
		{
			pADSIClass->Release();
			pADSIClass = NULL;
		}

		delete [] lpszADSIClassName;
		throw;
	}

	delete [] lpszADSIClassName;
	return result;
}


//***************************************************************************
//
// CLDAPClassProvider::CreateWBEMClass
//
// Purpose: Creates WBEM Class corresponding an ADSI Class
//
// Parameters:
//	pADSIClass : A pointer to a CADSI class object that is to be mapped to WBEM.
//	ppWbemClass : The WBEM class object retrieved. This is created by this function.
//		The caller should release it when done
//	pCtx : The context object that was used in this provider call
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CLDAPClassProvider :: CreateWBEMClass (CADSIClass *pADSIClass, int iCaseNumber, IWbemClassObject **ppWbemClass, IWbemContext *pCtx)
{
	HRESULT result;

	*ppWbemClass = NULL;

	// Create the WBEM class and Map the class qualifiers
	if( SUCCEEDED(result = MapClassSystemProperties(pADSIClass, iCaseNumber, ppWbemClass, pCtx) ) )
	{
		// Now that ppWbemClass has been allocated, we need to deallocate it if the return value of this function
		// is not a success
		//=======================================================================================================


		if(iCaseNumber == 5)
		{
			// Nothing more to do except add the "provider" qualifier
			IWbemQualifierSet *pQualifierSet = NULL;
			if(SUCCEEDED(result = (*ppWbemClass)->GetQualifierSet(&pQualifierSet)))
			{
				result = CWBEMHelper::PutBSTRQualifier(pQualifierSet, PROVIDER_BSTR, LDAP_INSTANCE_PROVIDER_NAME, DEFAULT_QUALIFIER_FLAVOUR, FALSE);
				pQualifierSet->Release();
			}
	
		}
		else
		{
			if( SUCCEEDED(result = MapClassQualifiersToWBEM(pADSIClass, iCaseNumber, *ppWbemClass, pCtx) ) )
			{
				// Map the  class properties 
				if( SUCCEEDED(result = MapClassPropertiesToWBEM(pADSIClass, *ppWbemClass, pCtx) ) )
				{
				}
				else
					g_pLogObject->WriteW( L"CLDAPClassProvider :: CreateWBEMClass() MapClassPropertiesToWBEM FAILED : %x for %s\r\n", result, pADSIClass->GetWBEMClassName());
			}
			else
				g_pLogObject->WriteW( L"CLDAPClassProvider :: CreateWBEMClass() MapClassQualifiersToWBEM FAILED : %x for %s\r\n", result, pADSIClass->GetWBEMClassName());
		}
	}
	else
		g_pLogObject->WriteW( L"CLDAPClassProvider :: CreateWBEMClass() MapClassSystemProperties FAILED : %x for %s\r\n", result, pADSIClass->GetWBEMClassName());

	if(!SUCCEEDED(result))
	{
		if(*ppWbemClass)
		{
			(*ppWbemClass)->Release();
			*ppWbemClass = NULL;
		}
	}

	return result;
}

//***************************************************************************
//
// CLDAPClassProvider::MapClassSystemProperties
//
// Purpose: Creates an appropriately derived WBEM class and names it (__CLASS)
//
// Parameters:
//	pADSIClass : The ADSI class that is being mapped
//	ppWbemClass : The WBEM class object retrieved. This is created by this function.
//		The caller should release it when done
//	pCtx : The context object that was used in this provider call
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CLDAPClassProvider :: MapClassSystemProperties(CADSIClass *pADSIClass, int iCaseNumber, IWbemClassObject **ppWbemClass, IWbemContext *pCtx)
{
	HRESULT result = WBEM_S_NO_ERROR;
	LPCWSTR lpszClassName = pADSIClass->GetWBEMClassName();

	// Create the WBEM class first.
	// This process depends on whether the ADSI class is derived from
	// another ADSI class or not. 
	// If so, that base class has to be retrieved and the derived class
	// to be spawned from that.
	// If not, then the function GetWBEMBaseClass() is called and the class 
	// being mapped is derived from that class

	IWbemClassObject *pBaseClass = NULL;
	if(iCaseNumber == 1)
	{
		pBaseClass = GetWBEMBaseClass();
	}
	else
	{
		LPWSTR lpszWBEMParentClassName = NULL;
		switch(iCaseNumber)
		{
			case 1:
				{
					pBaseClass = GetWBEMBaseClass();
					break;
				}
			case 2:
			case 4:
				{
					lpszWBEMParentClassName = CLDAPHelper::MangleLDAPNameToWBEM(pADSIClass->GetSuperClassLDAPName(), FALSE);
					break;
				}
			case 3:
				{
					lpszWBEMParentClassName = CLDAPHelper::MangleLDAPNameToWBEM(pADSIClass->GetSuperClassLDAPName(), TRUE);
					break;
				}
			case 5:
				{
					lpszWBEMParentClassName = CLDAPHelper::MangleLDAPNameToWBEM(pADSIClass->GetADSIClassName(), TRUE);
					break;
				}
			default:
				{
					result = WBEM_E_FAILED;
					break;
				}
		}

		if(SUCCEEDED(result))
		{
			BSTR strWBEMParentClass = SysAllocString(lpszWBEMParentClassName);		
			delete [] lpszWBEMParentClassName;
			// Get the parent WBEM Class
			if(FAILED(result = m_IWbemServices->GetObject(strWBEMParentClass, 0, pCtx, &pBaseClass, NULL)))
				g_pLogObject->WriteW( L"CLDAPClassProvider :: MapClassSystemProperties() GetObject on ADSI base class FAILED : %x for %s\r\n", result, strWBEMParentClass);
			SysFreeString(strWBEMParentClass);
		}
	}
	
	if(FAILED(result) || pBaseClass == NULL)
		return result;

	// Spawn the derived class
	result = pBaseClass->SpawnDerivedClass(0, ppWbemClass);
	pBaseClass->Release();
	if(SUCCEEDED(result))
	{
		// Create the __CLASS property
		// Make sure the case of the letters is not mixed up
		SanitizedClassName((LPWSTR)lpszClassName);
		if(SUCCEEDED(result = CWBEMHelper::PutBSTRProperty(*ppWbemClass, CLASS_STR, SysAllocString(lpszClassName), TRUE)))
		{
		}
		else
			g_pLogObject->WriteW( L"CLDAPClassProvider :: MapClassSystemProperties() on __CLASS FAILED : %x for %s\r\n", result, lpszClassName);
	}
	else
		g_pLogObject->WriteW( L"CLDAPClassProvider :: MapClassSystemProperties() SpawnDerived on WBEM base class FAILED : %x for %s\r\n", result, lpszClassName);
	
	return result;
}




//***************************************************************************
//
// CLDAPClassProvider :: MapClassQualifiersToWBEM
//
// Purpose: Creates the class qualifiers for a WBEM class from the ADSI class
//
// Parameters:
//	pADSIClass : The LDAP class that is being mapped
//	pWbemClass : The WBEM class object being created. T
//	pCtx : The context object that was used in this provider call
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CLDAPClassProvider :: MapClassQualifiersToWBEM(CADSIClass *pADSIClass, int iCaseNumber, IWbemClassObject *pWbemClass, IWbemContext *pCtx)
{
	IWbemQualifierSet *pQualifierSet = NULL;
	HRESULT result = pWbemClass->GetQualifierSet(&pQualifierSet);

	LPCWSTR lpszTemp;
	BOOLEAN bIsAbstract = FALSE;

	// Map each of the LDAP class attributes to WBEM class qualifiers/properties
	if(SUCCEEDED(result))
	{
		result = CWBEMHelper::PutI4Qualifier(pQualifierSet, OBJECT_CLASS_CATEGORY_ATTR_BSTR, pADSIClass->GetObjectClassCategory(), DEFAULT_QUALIFIER_FLAVOUR);
		// It is an abstract class is the ADSI class type is Abstract or Auxiliary
		if(SUCCEEDED(result) && (pADSIClass->GetObjectClassCategory() == 2 || pADSIClass->GetObjectClassCategory() == 3) )
		{
			bIsAbstract = TRUE;
			result = CWBEMHelper::PutBOOLQualifier(pQualifierSet, ABSTRACT_BSTR, VARIANT_TRUE, WBEM_FLAVOR_OVERRIDABLE);
		} 
		else if (iCaseNumber == 2 || iCaseNumber == 3)
		{
			bIsAbstract = TRUE;
			result = CWBEMHelper::PutBOOLQualifier(pQualifierSet, ABSTRACT_BSTR, VARIANT_TRUE, WBEM_FLAVOR_OVERRIDABLE);
		}
	}

	if(SUCCEEDED(result))
		result = CWBEMHelper::PutBOOLQualifier(pQualifierSet, DYNAMIC_BSTR, VARIANT_TRUE, DEFAULT_QUALIFIER_FLAVOUR);

	// provider qualifier is put only for non-abstract classes
	if(!bIsAbstract && SUCCEEDED(result))
		result = CWBEMHelper::PutBSTRQualifier(pQualifierSet, PROVIDER_BSTR, LDAP_INSTANCE_PROVIDER_NAME, DEFAULT_QUALIFIER_FLAVOUR, FALSE);

	if(SUCCEEDED(result))
		result = CWBEMHelper::PutBSTRQualifier(pQualifierSet, COMMON_NAME_ATTR_BSTR, SysAllocString(pADSIClass->GetCommonName()), DEFAULT_QUALIFIER_FLAVOUR);

	if(SUCCEEDED(result))
		result = CWBEMHelper::PutBSTRQualifier(pQualifierSet, LDAP_DISPLAY_NAME_ATTR_BSTR, SysAllocString(pADSIClass->GetName()), DEFAULT_QUALIFIER_FLAVOUR);
	
	if(SUCCEEDED(result))
		result = CWBEMHelper::PutBSTRQualifier(pQualifierSet, GOVERNS_ID_ATTR_BSTR, SysAllocString(pADSIClass->GetGovernsID()), DEFAULT_QUALIFIER_FLAVOUR);
	
	// Do not map this, since this is not exposed thru the schema-management snapin
	/*
	if(SUCCEEDED(result))
	{
		const LPBYTE pValues = pADSIClass->GetSchemaIDGUID(&dwTemp);
		result = CWBEMHelper::PutUint8ArrayQualifier(pQualifierSet, SCHEMA_ID_GUID_ATTR_BSTR, pValues, dwTemp, DEFAULT_QUALIFIER_FLAVOUR);
	}
	*/
	
	if(SUCCEEDED(result) && (lpszTemp = pADSIClass->GetDefaultSecurityDescriptor()))
		result = CWBEMHelper::PutBSTRQualifier(pQualifierSet, DEFAULT_SECURITY_DESCRP_ATTR_BSTR, SysAllocString(lpszTemp), DEFAULT_QUALIFIER_FLAVOUR);
	
	if(SUCCEEDED(result))
		result = CWBEMHelper::PutBOOLQualifier(pQualifierSet, SYSTEM_ONLY_ATTR_BSTR, pADSIClass->GetSystemOnly(), DEFAULT_QUALIFIER_FLAVOUR);

	/*
	if(SUCCEEDED(result))
	{
		const LPBYTE pValues = pADSIClass->GetNTSecurityDescriptor(&dwTemp);
		result = CWBEMHelper::PutUint8ArrayQualifier(pQualifierSet, NT_SECURITY_DESCRIPTOR_ATTR_BSTR, pValues, dwTemp, DEFAULT_QUALIFIER_FLAVOUR);
	}
	*/

	if(SUCCEEDED(result))
		result = CWBEMHelper::PutBSTRQualifier(pQualifierSet, DEFAULT_OBJECTCATEGORY_ATTR_BSTR, SysAllocString(pADSIClass->GetDefaultObjectCategory()), DEFAULT_QUALIFIER_FLAVOUR);

	pQualifierSet->Release();
	return result;
}

//***************************************************************************
//
// CLDAPClassProvider :: MapClassPropertiesToWBEM
//
// Purpose: Creates the class properties for a WBEM class from the ADSI class
//
// Parameters:
//	pADSIClass : The LDAP class that is being mapped
//	pWbemClass : The WBEM class object being created. 
//	pCtx : The context object that was used in this provider call
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CLDAPClassProvider :: MapClassPropertiesToWBEM(CADSIClass *pADSIClass, IWbemClassObject *pWbemClass, IWbemContext *pCtx)
{
	HRESULT result = S_OK;

	//////////////////////////////////////////////////
	// Go thru the set of Auxiliary Classes 
	//////////////////////////////////////////////////
	DWORD dwCount = 0;
	LPCWSTR *lppszPropertyList = pADSIClass->GetAuxiliaryClasses(&dwCount);
	CADSIClass *pNextClass = NULL;
	if(dwCount)
	{
		for(DWORD dwNextClass=0; dwNextClass<dwCount; dwNextClass++)
		{
			LPWSTR lpszWBEMClassName = CLDAPHelper::MangleLDAPNameToWBEM(lppszPropertyList[dwNextClass]);

			try
			{
				if(SUCCEEDED(result = s_pLDAPCache->GetClass(lpszWBEMClassName, lppszPropertyList[dwNextClass], &pNextClass)))
				{
					if(SUCCEEDED(result = MapClassPropertiesToWBEM(pNextClass, pWbemClass, pCtx)))
					{
					}
					pNextClass->Release();
					pNextClass = NULL;
				}
			}
			catch ( ... )
			{
				if ( pNextClass )
				{
					pNextClass->Release ();
					pNextClass = NULL;
				}

				delete [] lpszWBEMClassName;
				throw;
			}

			delete [] lpszWBEMClassName;
		}
	}
	if(FAILED(result))
		return result;

	//////////////////////////////////////////////////
	// Go thru the set of System Auxiliary Classes 
	//////////////////////////////////////////////////
	dwCount = 0;
	lppszPropertyList = pADSIClass->GetSystemAuxiliaryClasses(&dwCount);
	pNextClass = NULL;
	if(dwCount)
	{
		for(DWORD dwNextClass=0; dwNextClass<dwCount; dwNextClass++)
		{
			LPWSTR lpszWBEMClassName = CLDAPHelper::MangleLDAPNameToWBEM(lppszPropertyList[dwNextClass]);

			try
			{
				if(SUCCEEDED(result = s_pLDAPCache->GetClass(lpszWBEMClassName, lppszPropertyList[dwNextClass], &pNextClass)))
				{
					if(SUCCEEDED(result = MapClassPropertiesToWBEM(pNextClass, pWbemClass, pCtx)))
					{
					}
					pNextClass->Release();
					pNextClass = NULL;
				}
			}
			catch ( ... )
			{
				if ( pNextClass )
				{
					pNextClass->Release ();
					pNextClass = NULL;
				}

				delete [] lpszWBEMClassName;
				throw;
			}

			delete [] lpszWBEMClassName;
		}
	}
	if(FAILED(result))
		return result;

	//////////////////////////////////////////////////
	// Go thru the set of System May Contains
	//////////////////////////////////////////////////
	dwCount = 0;
	lppszPropertyList = pADSIClass->GetSystemMayContains(&dwCount);
	if(SUCCEEDED(result = MapPropertyListToWBEM(pWbemClass, lppszPropertyList, dwCount, TRUE, FALSE)))
	{
		//////////////////////////////////////////////////
		// Go thru the set of May Contains
		//////////////////////////////////////////////////
		dwCount = 0;
		lppszPropertyList = pADSIClass->GetMayContains(&dwCount);
		if(SUCCEEDED(result = MapPropertyListToWBEM(pWbemClass, lppszPropertyList, dwCount, FALSE, FALSE)))
		{
			//////////////////////////////////////////////////
			// Go thru the set of System Must Contains
			//////////////////////////////////////////////////
			dwCount = 0;
			lppszPropertyList = pADSIClass->GetSystemMustContains(&dwCount);
			if(SUCCEEDED(result = MapPropertyListToWBEM(pWbemClass, lppszPropertyList, dwCount, TRUE, TRUE)))
			{
				//////////////////////////////////////////////////
				// Go thru the set of Must Contains
				//////////////////////////////////////////////////
				dwCount = 0;
				lppszPropertyList = pADSIClass->GetMustContains(&dwCount);
				if(SUCCEEDED(result = MapPropertyListToWBEM(pWbemClass, lppszPropertyList, dwCount, FALSE, TRUE)))
				{

				} // MapPropertyListToWBEM
			} // MapPropertyListToWBEM
		} // MapPropertyListToWBEM
	} // MapPropertyListToWBEM
		
	// Do not map any other properties, if failed
	if(FAILED(result))
		return result;

	// Map the RDN property as indexed
	LPWSTR lpszRDNAttribute = NULL;
	lpszRDNAttribute = CLDAPHelper::MangleLDAPNameToWBEM(pADSIClass->GetRDNAttribute());
	if(lpszRDNAttribute)
	{
		BSTR strRDNAttribute = SysAllocString(lpszRDNAttribute);
		IWbemQualifierSet *pQualifierSet = NULL;
		if(SUCCEEDED(result = pWbemClass->GetPropertyQualifierSet(strRDNAttribute, &pQualifierSet)))
		{
			IWbemQualifierSet *pClassQualifiers = NULL;
			if(SUCCEEDED(result = pWbemClass->GetQualifierSet(&pClassQualifiers)))
			{
				// ALso put a qualifier on the class that indicates that this is the RDNAttId
				if(SUCCEEDED(result = CWBEMHelper::PutBSTRQualifier(pClassQualifiers, RDN_ATT_ID_ATTR_BSTR, SysAllocString(pADSIClass->GetRDNAttribute()), DEFAULT_QUALIFIER_FLAVOUR, TRUE)))
				{
					if(SUCCEEDED(result = CWBEMHelper::PutBOOLQualifier(pQualifierSet, INDEXED_BSTR, VARIANT_TRUE, DEFAULT_QUALIFIER_FLAVOUR)))
					{

					}
					// It is fine if this property has already been designated as indexed in the base class
					else if (result == WBEM_E_OVERRIDE_NOT_ALLOWED)
						result = S_OK;
				}
				pClassQualifiers->Release();
			}
			// Release the Qualifer Set
			pQualifierSet->Release();
		}
		SysFreeString(strRDNAttribute);
	}
	delete [] lpszRDNAttribute;

	return result;
}


//***************************************************************************
//
// CLDAPClassProvider :: MapPropertyListToWBEM
//
// Purpose: Maps a list of class properties for a WBEM class from the ADSI class
//
// Parameters:
//	pWbemClass : The WBEM class object being created. 
//	lppszPropertyList : A list of propery names
//	dwCOunt : The number of items in the above list
//	bMapSystemQualifier : Whether the "system" qualifier should be mapped
//	bMapNotNullQualifier: Whether the "notNull" qualifier should be mapped
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CLDAPClassProvider :: MapPropertyListToWBEM(IWbemClassObject *pWbemClass, 
													LPCWSTR *lppszPropertyList, 
													DWORD dwCount, 
													BOOLEAN bMapSystemQualifier, 
													BOOLEAN bMapNotNullQualifier)
{
	HRESULT result = S_OK;
	CADSIProperty *pNextProperty;
	IWbemQualifierSet *pQualifierSet;
	if(dwCount)
	{
		for(DWORD dwNextProperty=0; dwNextProperty<dwCount; dwNextProperty++)
		{
			// Get the property from the cache. The name of the property will be the LDAP name
			if(SUCCEEDED(result = s_pLDAPCache->GetProperty(lppszPropertyList[dwNextProperty], &pNextProperty, FALSE)))
			{
				// Map the basic property
				if(SUCCEEDED(result = CreateWBEMProperty(pWbemClass, &pQualifierSet, pNextProperty)))
				{
					// Map the "system" qualifier
					if(bMapSystemQualifier && SUCCEEDED(result = CWBEMHelper::PutBOOLQualifier(pQualifierSet, SYSTEM_BSTR, VARIANT_TRUE, DEFAULT_QUALIFIER_FLAVOUR)))
					{
					}

					// Map the "not_null" qualifier
					if(bMapNotNullQualifier && SUCCEEDED(result = CWBEMHelper::PutBOOLQualifier(pQualifierSet, NOT_NULL_BSTR, VARIANT_TRUE, DEFAULT_QUALIFIER_FLAVOUR)))
					{
					}

					// Release the qualifier set
					pQualifierSet->Release();
				}
				// Release the property
				pNextProperty->Release();
			}
			// Do not map any other properties
			if(FAILED(result))
				break;
		}
	}

	return result;
}

//***************************************************************************
//
// CLDAPClassProvider :: CreateWBEMProperty
//
// Purpose: Creates a WBEM property from an LDAP property
//
// Parameters:
//	pWbemClass : The WBEM class in which the property is created
//	ppQualiferSet : The address of the pointer to IWbemQualiferSet where the qualifier set
//		of this property will be placed
//	pADSIProperty : The ADSI Property object that is being mapped to the property being created
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CLDAPClassProvider :: CreateWBEMProperty(IWbemClassObject *pWbemClass, IWbemQualifierSet **ppQualifierSet, CADSIProperty *pADSIProperty)
{
	HRESULT result = E_FAIL;

	// Get all the attributes of the ADSI class
	LPCWSTR lpszSyntaxOid = pADSIProperty->GetSyntaxOID();
	BSTR strCimTypeQualifier = NULL;

	// Note that strCimTypeQualifier is not allocated in this call, so it is not freed.
	CIMTYPE theCimType = MapLDAPSyntaxToWBEM(pADSIProperty, &strCimTypeQualifier);

	if(lpszSyntaxOid)
	{
		// Create the property
		BSTR strPropertyName = SysAllocString(pADSIProperty->GetWBEMPropertyName());
		if(SUCCEEDED(result = pWbemClass->Put(strPropertyName, 0, NULL, theCimType)))
		{
			// Get the Qualifier Set in ppQualifierSet
			if(SUCCEEDED(result = pWbemClass->GetPropertyQualifierSet(strPropertyName, ppQualifierSet)))
			{
				// Map the property attributes to WBEM qualifiers
				if(SUCCEEDED(result = CWBEMHelper::PutBSTRQualifier(*ppQualifierSet, 
							ATTRIBUTE_SYNTAX_ATTR_BSTR, 
							SysAllocString(lpszSyntaxOid),
							DEFAULT_QUALIFIER_FLAVOUR)))
				{
					/* Commented to reduce size of classes
					if(SUCCEEDED(result = CWBEMHelper::PutBSTRQualifier(*ppQualifierSet, 
								ATTRIBUTE_ID_ATTR_BSTR, 
								SysAllocString(pADSIProperty->GetAttributeID()),
								DEFAULT_QUALIFIER_FLAVOUR)))
					{
					*/
						if(SUCCEEDED(result = CWBEMHelper::PutBSTRQualifier(*ppQualifierSet, 
								COMMON_NAME_ATTR_BSTR, 
								SysAllocString(pADSIProperty->GetCommonName()),
								DEFAULT_QUALIFIER_FLAVOUR)))
						{
							/* Commented to reduce size of classes
							if(SUCCEEDED(result = CWBEMHelper::PutI4Qualifier(*ppQualifierSet, 
									MAPI_ID_ATTR_BSTR,
									pADSIProperty->GetMAPI_ID(),
									DEFAULT_QUALIFIER_FLAVOUR)))
							{
								if(SUCCEEDED(result = CWBEMHelper::PutI4Qualifier(*ppQualifierSet, 
										OM_SYNTAX_ATTR_BSTR,
										pADSIProperty->GetOMSyntax(),
										DEFAULT_QUALIFIER_FLAVOUR)))
								{
									if(pADSIProperty->IsSystemOnly())
									{
										if(SUCCEEDED(result = CWBEMHelper::PutBOOLQualifier(*ppQualifierSet, 
												SYSTEM_ONLY_ATTR_BSTR,
												VARIANT_TRUE,
												DEFAULT_QUALIFIER_FLAVOUR)))
										{
										}
									}
								*/

									// If this is an embedded property, then use the cimType qualifier on the property
									if(strCimTypeQualifier)
									{
										result = CWBEMHelper::PutBSTRQualifier(*ppQualifierSet, 
													CIMTYPE_STR, 
													strCimTypeQualifier,
													DEFAULT_QUALIFIER_FLAVOUR, FALSE); 
									}

									if(SUCCEEDED(result) && pADSIProperty->GetSearchFlags() == 1)
									{
										if(SUCCEEDED(result = CWBEMHelper::PutBOOLQualifier(*ppQualifierSet, 
											INDEXED_BSTR,
											VARIANT_TRUE,
											DEFAULT_QUALIFIER_FLAVOUR)))
										{
										}
										else if (result == WBEM_E_OVERRIDE_NOT_ALLOWED)
											result = S_OK;
									}
								}
							/*
							}
						}
					}
					*/
				}
			}
			else
				g_pLogObject->WriteW( L"CLDAPClassProvider :: CreateWBEMProperty FAILED to get qualifier set for %s", pADSIProperty->GetADSIPropertyName());
		}
		else
			g_pLogObject->WriteW( L"CLDAPClassProvider :: CreateWBEMProperty FAILED to put property : %s", pADSIProperty->GetADSIPropertyName());

		SysFreeString(strPropertyName);
	}
	else
	{
		g_pLogObject->WriteW( L"CLDAPClassProvider :: CreateWBEMProperty FAILED to get Syntax OID property for %s", pADSIProperty->GetADSIPropertyName());
		result = E_FAIL;
	}

	return result;
}


//***************************************************************************
//
// CLDAPClassProvider :: MapLDAPSyntaxToWBEM
//
// Purpose: See Header
//
//***************************************************************************
CIMTYPE CLDAPClassProvider :: MapLDAPSyntaxToWBEM(CADSIProperty *pADSIProperty, BSTR *pstrCimTypeQualifier)
{
	*pstrCimTypeQualifier = NULL;
	LPCWSTR lpszSyntaxOid = pADSIProperty->GetSyntaxOID();
	CIMTYPE retValue = (pADSIProperty->IsMultiValued())? CIM_FLAG_ARRAY : 0;

	if(wcscmp(lpszSyntaxOid, UNICODE_STRING_OID) == 0)
		return retValue | CIM_STRING;
	else if(wcscmp(lpszSyntaxOid, INTEGER_OID) == 0)
		return retValue | CIM_SINT32;
	else if(wcscmp(lpszSyntaxOid, LARGE_INTEGER_OID) == 0)
		return retValue | CIM_SINT64;
	else if(wcscmp(lpszSyntaxOid, BOOLEAN_OID) == 0)
		return retValue | CIM_BOOLEAN;
	else if(wcscmp(lpszSyntaxOid, OBJECT_IDENTIFIER_OID) == 0)
		return retValue | CIM_STRING;
	else if(wcscmp(lpszSyntaxOid, DISTINGUISHED_NAME_OID) == 0)
		return retValue | CIM_STRING;
	else if(wcscmp(lpszSyntaxOid, CASE_SENSITIVE_STRING_OID) == 0)
		return retValue | CIM_STRING;
	else if(wcscmp(lpszSyntaxOid, CASE_INSENSITIVE_STRING_OID) == 0)
		return retValue | CIM_STRING;
	else if(wcscmp(lpszSyntaxOid, PRINT_CASE_STRING_OID) == 0)
		return retValue | CIM_STRING;
	else if(wcscmp(lpszSyntaxOid, OCTET_STRING_OID) == 0)
	{
		*pstrCimTypeQualifier = EMBED_UINT8ARRAY;
		return retValue | CIM_OBJECT;
	}
	else if(wcscmp(lpszSyntaxOid, NUMERIC_STRING_OID) == 0)
		return retValue | CIM_STRING;
	else if(wcscmp(lpszSyntaxOid, PRINT_CASE_STRING_OID) == 0)
		return retValue | CIM_STRING;
	else if(wcscmp(lpszSyntaxOid, DN_WITH_BINARY_OID) == 0)
	{
		// DN_With_Binary and OR_Name have the same syntax oid.
		// They are differentiated base on the value of the OMObjectClass value
		if(pADSIProperty->IsORName())
			return retValue | CIM_STRING;
		else // It is DN_With_Binary
		{
			*pstrCimTypeQualifier = EMBED_DN_WITH_BINARY;
			return retValue | CIM_OBJECT;
		}
	}
	else if(wcscmp(lpszSyntaxOid, NT_SECURITY_DESCRIPTOR_OID) == 0)
	{
		*pstrCimTypeQualifier = EMBED_UINT8ARRAY;
		return retValue | CIM_OBJECT;
	}
	else if(wcscmp(lpszSyntaxOid, PRESENTATION_ADDRESS_OID) == 0)
	{
		*pstrCimTypeQualifier = EMBED_UINT8ARRAY;
		return retValue | CIM_OBJECT;
	}
	else if(wcscmp(lpszSyntaxOid, DN_WITH_STRING_OID) == 0)
	{
		*pstrCimTypeQualifier = EMBED_DN_WITH_BINARY;
		return retValue | CIM_OBJECT;
	}
	else if(wcscmp(lpszSyntaxOid, SID_OID) == 0)
	{
		*pstrCimTypeQualifier = EMBED_UINT8ARRAY;
		return retValue | CIM_OBJECT;
	}
	else if(wcscmp(lpszSyntaxOid, TIME_OID) == 0)
		return retValue | CIM_DATETIME;
	else 
	{
		g_pLogObject->WriteW( L"CLDAPClassProvider :: MapLDAPSyntaxToWBEM FAILED to map syntax for OID: %s\r\n", lpszSyntaxOid);
		return retValue | CIM_STRING;
	}
}

//***************************************************************************
//
// CLDAPClassProvider :: CreateClassEnumAsync
//
// Purpose: Enumerates the classes 
//
// Parameters:
//	Standard parmaters as described by the IWbemServices interface
//
//
// Return Value: As described by the IWbemServices interface
//
//***************************************************************************
HRESULT CLDAPClassProvider :: CreateClassEnumAsync( 
    /* [in] */ const BSTR strSuperclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	if(!m_bInitializedSuccessfully)
	{
		g_pLogObject->WriteW( L"CLDAPClassProvider :: Initialization status is FAILED, hence returning failure\r\n");
		return WBEM_E_FAILED;
	}

	g_pLogObject->WriteW( L"CLDAPClassProvider :: CreateClassEnumAsync() called for %s SuperClass and %s \r\n",
		((strSuperclass)? strSuperclass : L" "), ((lFlags & WBEM_FLAG_SHALLOW)? L"SHALLOW" : L"DEEP"));

	// Impersonate the client
	//=======================
	HRESULT result = WBEM_E_FAILED;
	if(!SUCCEEDED(result = WbemCoImpersonateClient()))
	{
		g_pLogObject->WriteW( L"CDSClassProvider :: CreateClassEnumAsync() CoImpersonate FAILED for %s with %x\r\n", strSuperclass, result);
		return WBEM_E_FAILED;
	}

	try
	{

		BSTR strTheSuperClass = strSuperclass;
		
		// CIMOM seems to give the strSuperClass as NULL sometimes and as "" sometimes. Make it unambiguous
		if(!strTheSuperClass || wcscmp(strTheSuperClass, L"") == 0)
		{
			if( lFlags & WBEM_FLAG_SHALLOW) 
			{
				// Nothing to be done since we do not provide cany classes that fit this
				strTheSuperClass = NULL;
				result = S_OK;
			}
			else
			{
				strTheSuperClass = LDAP_BASE_CLASS_STR; // Recursive enumeration handled below
			}
		}

		// Take the special cases first
		//	1. Where the strSuperClass is LDAP_BASE_CLASS_STR and lFlags is Shallow
		//	Nothing to be returned here, since we are not supplying the LDAP_BASE_CLASS_STR
		//	which is statically supplied.
		//=======================================================================
		if(strTheSuperClass && _wcsicmp(strTheSuperClass, LDAP_BASE_CLASS_STR) == 0 )
		{
			// First the TOP class needs to be returned
			IWbemClassObject *pReturnObject = NULL;
			if(SUCCEEDED(result = GetClassFromCacheOrADSI(TOP_CLASS, &pReturnObject, pCtx)))
			{
				result = pResponseHandler->Indicate(1, &pReturnObject);
				pReturnObject->Release();

				if(SUCCEEDED(result))
				{
					if( lFlags & WBEM_FLAG_SHALLOW) // Notheing more to be done
					{
					}
					else // We've to return all the sub classes of top too, recursively
					{
						if(SUCCEEDED(result = HandleRecursiveEnumeration(TOP_CLASS, pCtx, pResponseHandler)))
						{
							g_pLogObject->WriteW( L"CLDAPClassProvider :: CreateClassEnumAsync() Recursive enumeration for %s succeeded\r\n", strTheSuperClass);
						}
						else
						{
							g_pLogObject->WriteW( L"CLDAPClassProvider :: CreateClassEnumAsync() Recursive enumeration for %s FAILED\r\n", strTheSuperClass);
						}
					}
				}
				else
					g_pLogObject->WriteW( L"CLDAPClassProvider :: CreateClassEnumAsync() Recursive enumeration for %s was CANCELLED\r\n", strTheSuperClass);
			}
		}
		// 2. Where the superClass is specified
		//=======================================================================
		else if(strTheSuperClass)
		{
			// Optimize the operation by seeing if it is one of the static classes and
			// its name does not start with "ADS_" or "DS_". Then we dont know anything about it
			//============================================================================
			if(IsUnProvidedClass(strTheSuperClass))
			{
				result = S_OK;
			}
			else
			{
				BOOLEAN bArtificialClass = FALSE;

				// First check if this is one our "artificial" classes. All "aritificial" classes start with "ads_".
				// All non artificial classes start with "ds_"
				if(_wcsnicmp(strTheSuperClass, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX_LENGTH) == 0)
					bArtificialClass = TRUE;

				// When the search is shallow
				if( lFlags & WBEM_FLAG_SHALLOW)
				{
					// The ADSI classes
					LPWSTR *ppADSIClasses = NULL;
					// The number of ADSI classes
					DWORD dwNumClasses = 0;

					try
					{
						if(SUCCEEDED(result = GetOneLevelDeep(strTheSuperClass, bArtificialClass, &ppADSIClasses, &dwNumClasses, pCtx)))
						{
							// Interact with CIMOM
							//=====================
							if(SUCCEEDED(result = WrapUpEnumeration(ppADSIClasses, dwNumClasses, pCtx, pResponseHandler)))
							{
							}

							// Release the list of ADSI classes and its contents
							//==================================================
							for(DWORD j=0; j<dwNumClasses; j++)
							{
								delete [] ppADSIClasses[j];
								ppADSIClasses[j] = NULL;
							}

							delete[] ppADSIClasses;
							ppADSIClasses = NULL;
						}
					}
					catch ( ... )
					{
						if ( ppADSIClasses )
						{
							for ( DWORD j=0; j<dwNumClasses; j++ )
							{
								delete [] ppADSIClasses[j];
								ppADSIClasses[j] = NULL;
							}

							delete[] ppADSIClasses;
							ppADSIClasses = NULL;
						}

						throw;
					}
				}
				else // the search is deep
				{
					if(SUCCEEDED(result = HandleRecursiveEnumeration(strTheSuperClass, pCtx, pResponseHandler)))
					{
						g_pLogObject->WriteW( L"CLDAPClassProvider :: CreateClassEnumAsync() Recursive enumeration for %s succeeded\r\n", strTheSuperClass);
					}
					else
					{
						g_pLogObject->WriteW( L"CLDAPClassProvider :: CreateClassEnumAsync() Recursive enumeration for %s FAILED\r\n", strTheSuperClass);
					}
				}

			}
		}

				
		if(SUCCEEDED(result))
		{
			pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_S_NO_ERROR, NULL, NULL);
			g_pLogObject->WriteW( L"CLDAPClassProvider :: CreateClassEnumAsync() Non-Recursive enumeration succeeded\r\n");
		}
		else
		{
			pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_E_FAILED, NULL, NULL);
			g_pLogObject->WriteW( L"CLDAPClassProvider :: CreateClassEnumAsync() Non-Recursive enumeration FAILED for superclass %s \r\n", strTheSuperClass);
		}
	}
	catch(Heap_Exception e_HE)
	{
		pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE , WBEM_E_OUT_OF_MEMORY, NULL, NULL);
	}

	return WBEM_S_NO_ERROR;
}
    

//***************************************************************************
//
// CLDAPClassProvider :: GetOneLevelDeep
//
// Purpose: Enumerates the sub classes of a superclass non-recursively
//
// Parameters:
//
//	lpszSuperClass : The super class name
//	pResponseHandler : The interface where the resulting classes are put
//
//
// Return Value: As described by the IWbemServices interface
//
//***************************************************************************
HRESULT CLDAPClassProvider :: GetOneLevelDeep( 
    LPCWSTR lpszWBEMSuperclass,
	BOOLEAN bArtificialClass,
	LPWSTR ** pppADSIClasses,
	DWORD *pdwNumClasses,
	IWbemContext *pCtx)
{
	// The ADSI classes
	*pppADSIClasses = NULL;
	// The number of ADSI classes
	*pdwNumClasses = 0;
	HRESULT result = WBEM_E_FAILED;

	// See if the super class
	IWbemClassObject *pSuperClass = NULL;
	if(!SUCCEEDED(result = GetClassFromCacheOrADSI(lpszWBEMSuperclass, &pSuperClass, pCtx)))
	{
		return WBEM_E_NOT_FOUND;
	}
	pSuperClass->Release();

	// If the WBEM class is concrete, we dont need to do anything
	if (SUCCEEDED(result = IsConcreteClass(lpszWBEMSuperclass, pCtx)))
	{
		if(result == S_OK)
			return S_OK;
	}
	else
		return result;

	// See the cache first
	//====================
	CEnumInfo *pEnumInfo = NULL;
	try
	{
		if(SUCCEEDED(result = s_pWbemCache->GetEnumInfo(lpszWBEMSuperclass, &pEnumInfo)))
		{
			CNamesList *pNamesList = pEnumInfo->GetSubClassNames();
			*pdwNumClasses = pNamesList->GetAllNames(pppADSIClasses);

			pEnumInfo->Release();
			pEnumInfo = NULL;
		}
		else // Go to ADSI 
			//============
		{
			// The following are the possibilities now"
			// 1. The Class starts with "ADS_". It is abstract by definition. All its sub-classes except one are abstract,artificial.
			// 2. The Class starts with "DS_" and it is abstract. It being concrete is ruled out since it was handled at the
			// top of this function

			// Get all the ADSI classes 
			if(SUCCEEDED(result = s_pLDAPCache->EnumerateClasses(
				lpszWBEMSuperclass,
				FALSE,
				pppADSIClasses,
				pdwNumClasses,
				bArtificialClass)))
			{

				// Create a list of names for holding the subclasses
				CNamesList *pNewList = new CNamesList;
				LPWSTR pszWBEMName = NULL;

				try
				{
					// The First case in the 2 cases above
					if(bArtificialClass)
					{
						// The first element is just the super class without the A
						// Example if the super class is "ADS_User", the first element is DS_user
						pNewList->AddName((*pppADSIClasses)[0]);


						// Start from the secodn element
						for(DWORD i=1; i<*pdwNumClasses; i++)
						{
							// Convert names to WBEM And add them to the new list
							pszWBEMName = CLDAPHelper::MangleLDAPNameToWBEM((*pppADSIClasses)[i], TRUE);
							pNewList->AddName(pszWBEMName);

							delete [] (*pppADSIClasses)[i];
							(*pppADSIClasses)[i] = pszWBEMName;
						}
					}
					else // The Second case
					{
						for(DWORD i=0; i<*pdwNumClasses; i++)
						{
							// Convert names to WBEM And add them to the new list
							pszWBEMName = CLDAPHelper::MangleLDAPNameToWBEM((*pppADSIClasses)[i], FALSE);

							LPWSTR pszRealClassName = NULL;

							if(SUCCEEDED(result = IsConcreteClass(pszWBEMName, pCtx)))
							{
								if(result == S_OK)
								{
									pszRealClassName = CLDAPHelper::MangleLDAPNameToWBEM((*pppADSIClasses)[i], TRUE);
									delete[] pszWBEMName;
									pNewList->AddName(pszRealClassName);
									delete [] (*pppADSIClasses)[i];
									(*pppADSIClasses)[i] = pszRealClassName;
								}
								else
								{
									pNewList->AddName(pszWBEMName);
									delete [] (*pppADSIClasses)[i];
									(*pppADSIClasses)[i] = pszWBEMName;
								}
							}
							else
								g_pLogObject->WriteW( L"CLDAPClassProvider :: GetOneLevelDeep() UNKNOWN FAILED for %s \r\n", lpszWBEMSuperclass);
						}
					}
				}
				catch ( ... )
				{
					if ( pNewList )
					{
						delete pNewList;
						pNewList = NULL;
					}

					throw;
				}

				// Add the new EnumInfo to the Enum cache
				pEnumInfo = new CEnumInfo(lpszWBEMSuperclass, pNewList);
				s_pWbemCache->AddEnumInfo(pEnumInfo);

				pEnumInfo->Release();
				pEnumInfo = NULL;
				
			}
			else
				g_pLogObject->WriteW( L"CLDAPClassProvider :: CreateClassEnumAsync() GetOneLevelDeep() FAILED for %s \r\n", lpszWBEMSuperclass);
		}
	}
	catch ( ... )
	{
		if ( pEnumInfo )
		{
			pEnumInfo->Release();
			pEnumInfo = NULL;
		}

		throw;
	}

	return result;
}

//***************************************************************************
//
// CLDAPClassProvider :: HandleRecursiveEnumeration
//
// Purpose: Enumerates the sub classes of a superclass recursively
//
// Parameters:
//
//	lpszSuperClass : The super class name
//	pResponseHandler : The interface where the resulting classes are put
//
//
// Return Value: As described by the IWbemServices interface
//
//***************************************************************************
HRESULT CLDAPClassProvider :: HandleRecursiveEnumeration( 
    LPCWSTR lpszWBEMSuperclass,
    IWbemContext *pCtx,
    IWbemObjectSink *pResponseHandler)
{
	g_pLogObject->WriteW( L"CLDAPClassProvider :: HandleRecursiveEnumeration() called for %s SuperClass \r\n",
			((lpszWBEMSuperclass)? lpszWBEMSuperclass : L" "));
	HRESULT result = E_FAIL;

	// The ADSI classes
	LPWSTR *ppADSIClasses = NULL;
	// The number of ADSI classes
	DWORD dwNumClasses = 0;

	// First check if this is one our "artificial" classes. All "aritificial" classes start with "ads_".
	// All non artificial classes start with "ds_"
	BOOLEAN bArtificialClass = FALSE;
	if(_wcsnicmp(lpszWBEMSuperclass, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX_LENGTH) == 0)
		bArtificialClass = TRUE;

	if(SUCCEEDED(result = GetOneLevelDeep(lpszWBEMSuperclass, bArtificialClass, &ppADSIClasses, &dwNumClasses, pCtx)))
	{
		// Interact with CIMOM
		//=====================
		if(FAILED(result = WrapUpEnumeration(ppADSIClasses, dwNumClasses, pCtx, pResponseHandler)))
			g_pLogObject->WriteW( L"CLDAPClassProvider :: HandleRecursiveEnumeration() WrapUpEnumeration() for Superclass %s FAILED with %x \r\n",
				((lpszWBEMSuperclass)? lpszWBEMSuperclass : L" "), result);
		else
		{
			// Go thru the list of ADSI classes and its contents and Enumerate into them too
			for(DWORD j=0; j<dwNumClasses; j++)
			{
				if(FAILED(result = HandleRecursiveEnumeration(ppADSIClasses[j], pCtx, pResponseHandler)))
					break;
			}
		}

		// Go thru the list of ADSI classes and release them
		for(DWORD j=0; j<dwNumClasses; j++)
			delete [] ppADSIClasses[j];

		delete[] ppADSIClasses;
	}
	return result;
}

//***************************************************************************
//
// CLDAPClassProvider :: WrapUpEnumeration
//
// Purpose: Creates WBEM classes from ADSI classes and Indicates them to CIMOM
//
// Parameters:
//
//	lpszSuperClass : The super class name
//	pResponseHandler : The interface where the resulting classes are put
//
//
// Return Value: As described by the IWbemServices interface
//
//***************************************************************************
HRESULT CLDAPClassProvider :: WrapUpEnumeration( 
	LPWSTR *ppADSIClasses,
	DWORD dwNumClasses,
    IWbemContext *pCtx,
    IWbemObjectSink *pResponseHandler)
{
	// The WBEM Class objects created
	IWbemClassObject **ppReturnWbemClassObjects = NULL;
	// The number of WBEM class objects that were successfully created
	DWORD i=0;
	DWORD j=0;
	HRESULT result = S_OK;
	if(dwNumClasses != 0)
	{
		// Allocate an array of IWbemClassObject pointers
		ppReturnWbemClassObjects = NULL;
		if(ppReturnWbemClassObjects = new IWbemClassObject *[dwNumClasses])
		{
			for(i=0; i<dwNumClasses; i++)
			{
				// Get the class
				if(!SUCCEEDED(result = GetClassFromCacheOrADSI(ppADSIClasses[i], ppReturnWbemClassObjects + i, pCtx)))
				{
					g_pLogObject->WriteW( L"CLDAPClassProvider :: WrapUpEnumeration() GetClassFromCacheOrADSI() FAILED with %x \r\n", result);
					break;
				}
			}
		}
		else
			result = E_OUTOFMEMORY;
	}

	// Indicate(), but do not SetStatus()
	if(SUCCEEDED(result))
	{
		// result = pResponseHandler->Indicate(i, ppReturnWbemClassObjects);
		////////////////////////////////////

		//
		// Break it up into 4 objects at a time - JUST FOR TESTING AGAINST BUG 39838
		// 

		DWORD dwMaxObjectsAtATime  = 4;
		j = 0;
		while ( j<i )
		{
			DWORD dwThisIndicationsCount = ((i-j) > dwMaxObjectsAtATime)? dwMaxObjectsAtATime : (i-j);
			if(FAILED(result = pResponseHandler->Indicate(dwThisIndicationsCount, ppReturnWbemClassObjects + j)))
			{
				g_pLogObject->WriteW( L"CLDAPClassProvider :: WrapUpEnumeration() Indicate() FAILED with %x \r\n", result);
				break;
			}

			j+= dwThisIndicationsCount;
		}
	}
	else
		g_pLogObject->WriteW( L"CLDAPClassProvider :: HandleRecursiveEnumeration() WrapUpEnumeration() FAILED with %x \r\n", result);

	// Delete the list of WBEM Classes and its contents. 
	for(j=0; j<i; j++)
		(ppReturnWbemClassObjects[j])->Release();
	delete[] ppReturnWbemClassObjects;

	return result;
}

//***************************************************************************
//
// CLDAPClassProvider :: IsConcreteClass
//
// Purpose: Find out whether a WBEM class is concrete. 
//
// Parameters:
//
//	pszWBEMName : The class name
//
//
// Return Value: As described by the IWbemServices interface
//
//***************************************************************************
HRESULT CLDAPClassProvider :: IsConcreteClass( 
	LPCWSTR pszWBEMName,
    IWbemContext *pCtx)
{
	// The call to IsConcreteClass is optimized if the class is artificial,
	// since all artificial classes are non-concrete
	if(_wcsnicmp(pszWBEMName, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX_LENGTH) == 0)
		return S_FALSE;

	IWbemClassObject *pWbemClass = NULL;
	HRESULT result = E_FAIL;

	if(SUCCEEDED(GetClassFromCacheOrADSI(pszWBEMName,  &pWbemClass, pCtx)))
	{
		IWbemQualifierSet *pQualifierSet = NULL;
		if(SUCCEEDED(result = pWbemClass->GetQualifierSet(&pQualifierSet)))
		{
			VARIANT_BOOL bAbstract = VARIANT_FALSE;
			if(SUCCEEDED(CWBEMHelper::GetBOOLQualifier(pQualifierSet, ABSTRACT_BSTR, &bAbstract, NULL)))
			{
				if(bAbstract == VARIANT_TRUE)
					result = S_FALSE;
				else
					result = S_OK;
			}
			pQualifierSet->Release();
		}
		pWbemClass->Release();
	}
	return result;
}

void CLDAPClassProvider :: SanitizedClassName(LPWSTR lpszClassName)
{
	while(*lpszClassName)
	{
		*lpszClassName = towlower(*lpszClassName);
		lpszClassName++;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\maindll.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile: maindll.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $
//	$Nokeywords:  $
//
//
//  Description: Contains DLL entry points.  Also has code that controls
//  when the DLL can be unloaded by tracking the number of objects and locks.
//
//***************************************************************************

#include "precomp.h"
#include <initguid.h>
#include "dscpguid.h"
#include "dsipguid.h"

// HANDLE of the DLL
HINSTANCE   g_hInst = NULL;

// Count of locks
long g_lComponents = 0;
// Count of active locks
long g_lServerLocks = 0;

// A critical section to create/delete statics 
CRITICAL_SECTION g_StaticsCreationDeletion;

ProvDebugLog *g_pLogObject = NULL;

//***************************************************************************
//
// DllMain
//
// Description: Entry point for DLL.  Good place for initialization.
// Parameters: The standard DllMain() parameters
// Return: TRUE if OK.
//***************************************************************************

BOOL APIENTRY DllMain (
	HINSTANCE hInstance,
	ULONG ulReason ,
	LPVOID pvReserved
)
{
	g_hInst = hInstance;
	BOOL status = TRUE ;

    if ( DLL_PROCESS_ATTACH == ulReason )
	{
		// Initialize the critical section to access the static initializer objects
		InitializeCriticalSection(&g_StaticsCreationDeletion);

		// Initialize the static Initializer objects. These are destroyed in DllCanUnloadNow
		CDSClassProviderClassFactory :: s_pDSClassProviderInitializer = NULL;
		CDSClassProviderClassFactory ::s_pLDAPClassProviderInitializer = NULL;
		CDSInstanceProviderClassFactory :: s_pDSInstanceProviderInitializer = NULL;
		DisableThreadLibraryCalls(g_hInst);			// 158024 

		status = TRUE ;
    }
    else if ( DLL_PROCESS_DETACH == ulReason )
	{
		DeleteCriticalSection(&g_StaticsCreationDeletion);
		status = TRUE ;
    }
    else if ( DLL_THREAD_DETACH == ulReason )
	{
		status = TRUE ;
    }
    else if ( DLL_THREAD_ATTACH == ulReason )
	{
		status = TRUE ;
    }

    return status ;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Description: Called by COM when some client wants a a class factory.
//
//	Parameters: Ths standard DllGetClassObject() parameters
//
//	Return Value: S_OK only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject (
	REFCLSID rclsid ,
	REFIID riid,
	void **ppv
)
{
	HRESULT status = S_OK ;

	try
	{
		if ( rclsid == CLSID_DSProvider )
		{
			CDSClassProviderClassFactory *lpunk = NULL;
			lpunk = new CDSClassProviderClassFactory ;

			status = lpunk->QueryInterface ( riid , ppv ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;
			}
		}
		else if ( rclsid == CLSID_DSClassAssocProvider )
		{
			CDSClassAssociationsProviderClassFactory *lpunk = new CDSClassAssociationsProviderClassFactory ;
			status = lpunk->QueryInterface ( riid , ppv ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;
			}
		}
		else if ( rclsid == CLSID_DSInstanceProvider )
		{
			CDSInstanceProviderClassFactory *lpunk = new CDSInstanceProviderClassFactory ;
			status = lpunk->QueryInterface ( riid , ppv ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;
			}
		}
		else
		{
			status = CLASS_E_CLASSNOTAVAILABLE ;
		}
	}
	catch(Heap_Exception e_HE)
	{
		status = E_OUTOFMEMORY ;
	}

	return status ;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Description: Called periodically by COM in order to determine if the
// DLL can be unloaded.
//
// Return Value: S_OK if there are no objects in use and the class factory
// isn't locked.
//***************************************************************************

STDAPI DllCanUnloadNow ()
{
	if(g_lServerLocks == 0 && g_lComponents == 0)
	{
		// Delete the Initializer objects
		EnterCriticalSection(&g_StaticsCreationDeletion);

		if ( g_pLogObject )
		{
			g_pLogObject->WriteW(L"DllCanUnloadNow called\r\n");
		}

		if ( CDSClassProviderClassFactory::s_pDSClassProviderInitializer )
		{
			delete CDSClassProviderClassFactory::s_pDSClassProviderInitializer;
			CDSClassProviderClassFactory::s_pDSClassProviderInitializer = NULL;
		}

		if ( CDSClassProviderClassFactory::s_pLDAPClassProviderInitializer )
		{
			delete CDSClassProviderClassFactory::s_pLDAPClassProviderInitializer;
			CDSClassProviderClassFactory::s_pLDAPClassProviderInitializer = NULL;
		}

		if ( CDSInstanceProviderClassFactory::s_pDSInstanceProviderInitializer )
		{
			delete CDSInstanceProviderClassFactory::s_pDSInstanceProviderInitializer;
			CDSInstanceProviderClassFactory::s_pDSInstanceProviderInitializer = NULL;
		}

		if ( g_pLogObject )
		{
			delete g_pLogObject;
			g_pLogObject = NULL;
		}

		LeaveCriticalSection(&g_StaticsCreationDeletion);

		return S_OK;
	}
	else
		return S_FALSE;
}

/***************************************************************************
 *
 * SetKeyAndValue
 *
 * Description: Helper function for DllRegisterServer that creates
 * a key, sets a value, and closes that key. If pszSubkey is NULL, then
 * the value is created for the pszKey key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the name of the key
 *  pszSubkey       LPTSTR to the name of a subkey
 *  pszValueName    LPTSTR to the value name to use
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue(LPCTSTR pszKey, LPCTSTR pszSubkey, LPCTSTR pszValueName, LPCTSTR pszValue)
{
    HKEY        hKey;
    TCHAR       szKey[256];

    _tcscpy(szKey, pszKey);

	// If a sub key is mentioned, use it.
    if (NULL != pszSubkey)
    {
		_tcscat(szKey, __TEXT("\\"));
        _tcscat(szKey, pszSubkey);
    }

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE,
		szKey, 0, NULL, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

    if (NULL != pszValue)
    {
        if (ERROR_SUCCESS != RegSetValueEx(hKey, pszValueName, 0, REG_SZ, (BYTE *)pszValue,
			(_tcslen(pszValue)+1)*sizeof(TCHAR)))
			return FALSE;
    }
    RegCloseKey(hKey);
    return TRUE;
}

/***************************************************************************
 *
 * DeleteKey
 *
 * Description: Helper function for DllUnRegisterServer that deletes the subkey
 * of a key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the name of the key
 *  pszSubkey       LPTSTR ro the name of a subkey
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL DeleteKey(LPCTSTR pszKey, LPCTSTR pszSubkey)
{
    HKEY        hKey;

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE,
		pszKey, 0, NULL, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

	if(ERROR_SUCCESS != RegDeleteKey(hKey, pszSubkey))
		return FALSE;

    RegCloseKey(hKey);
    return TRUE;
}


////////////////////////////////////////////////////////////////////
// Strings used during self registration
////////////////////////////////////////////////////////////////////
LPCTSTR INPROC32_STR			= __TEXT("InprocServer32");
LPCTSTR INPROC_STR				= __TEXT("InprocServer");
LPCTSTR THREADING_MODEL_STR		= __TEXT("ThreadingModel");
LPCTSTR APARTMENT_STR			= __TEXT("Both");

LPCTSTR CLSID_STR				= __TEXT("SOFTWARE\\CLASSES\\CLSID\\");

// DS Class Provider
LPCTSTR DSPROVIDER_NAME_STR		= __TEXT("Microsoft NT DS Class Provider for WBEM");

// DS Class Associations provider
LPCTSTR DS_ASSOC_PROVIDER_NAME_STR		= __TEXT("Microsoft NT DS Class Associations Provider for WBEM");

// DS Instance provider
LPCTSTR DS_INSTANCE_PROVIDER_NAME_STR		= __TEXT("Microsoft NT DS Instance Provider for WBEM");

STDAPI DllRegisterServer()
{
	TCHAR szModule[512];
	GetModuleFileName(g_hInst, szModule, sizeof(szModule)/sizeof(TCHAR));

	TCHAR szDSProviderClassID[128];
	TCHAR szDSProviderCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_DSProvider, szDSProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszDSProviderClassID[128];
	if(StringFromGUID2(CLSID_DSProvider, wszDSProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszDSProviderClassID, -1, szDSProviderClassID, 128, NULL, NULL);

#endif

	_tcscpy(szDSProviderCLSIDClassID, CLSID_STR);
	_tcscat(szDSProviderCLSIDClassID, szDSProviderClassID);

	//
	// Create entries under CLSID for DS Class Provider
	//
	if (FALSE == SetKeyAndValue(szDSProviderCLSIDClassID, NULL, NULL, DSPROVIDER_NAME_STR))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szDSProviderCLSIDClassID, INPROC32_STR, NULL, szModule))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szDSProviderCLSIDClassID, INPROC32_STR, THREADING_MODEL_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;


	TCHAR szDSClassAssocProviderClassID[128];
	TCHAR szDSClassAssocProviderCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_DSClassAssocProvider, szDSClassAssocProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszDSClassAssocProviderClassID[128];
	if(StringFromGUID2(CLSID_DSClassAssocProvider, wszDSClassAssocProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszDSClassAssocProviderClassID, -1, szDSClassAssocProviderClassID, 128, NULL, NULL);

#endif

	_tcscpy(szDSClassAssocProviderCLSIDClassID, CLSID_STR);
	_tcscat(szDSClassAssocProviderCLSIDClassID, szDSClassAssocProviderClassID);

	//
	// Create entries under CLSID for DS Class Associations Provider
	//
	if (FALSE == SetKeyAndValue(szDSClassAssocProviderCLSIDClassID, NULL, NULL, DS_ASSOC_PROVIDER_NAME_STR))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szDSClassAssocProviderCLSIDClassID, INPROC32_STR, NULL, szModule))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szDSClassAssocProviderCLSIDClassID, INPROC32_STR, THREADING_MODEL_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;




	TCHAR szDSInstanceProviderClassID[128];
	TCHAR szDSInstanceProviderCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_DSInstanceProvider, szDSInstanceProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszDSInstanceProviderClassID[128];
	if(StringFromGUID2(CLSID_DSInstanceProvider, wszDSInstanceProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszDSInstanceProviderClassID, -1, szDSInstanceProviderClassID, 128, NULL, NULL);

#endif


	_tcscpy(szDSInstanceProviderCLSIDClassID, CLSID_STR);
	_tcscat(szDSInstanceProviderCLSIDClassID, szDSInstanceProviderClassID);

	//
	// Create entries under CLSID for DS Instance Provider
	//
	if (FALSE == SetKeyAndValue(szDSInstanceProviderCLSIDClassID, NULL, NULL, DS_INSTANCE_PROVIDER_NAME_STR))
		return SELFREG_E_CLASS;

	if (FALSE == SetKeyAndValue(szDSInstanceProviderCLSIDClassID, INPROC32_STR, NULL, szModule))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szDSInstanceProviderCLSIDClassID, INPROC32_STR, THREADING_MODEL_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;



	return S_OK;
}


STDAPI DllUnregisterServer(void)
{
	TCHAR szModule[512];
	GetModuleFileName(g_hInst,szModule, sizeof(szModule)/sizeof(TCHAR));

	TCHAR szDSProviderClassID[128];
	TCHAR szDSProviderCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_DSProvider, szDSProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszDSProviderClassID[128];
	if(StringFromGUID2(CLSID_DSProvider, wszDSProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszDSProviderClassID, -1, szDSProviderClassID, 128, NULL, NULL);

#endif

	_tcscpy(szDSProviderCLSIDClassID, CLSID_STR);
	_tcscat(szDSProviderCLSIDClassID, szDSProviderClassID);

	//
	// Delete the keys for DS Class Provider in the reverse order of creation in DllRegisterServer()
	//
	if(FALSE == DeleteKey(szDSProviderCLSIDClassID, INPROC32_STR))
		return SELFREG_E_CLASS;
	if(FALSE == DeleteKey(CLSID_STR, szDSProviderClassID))
		return SELFREG_E_CLASS;

	TCHAR szDSClassAssocProviderClassID[128];
	TCHAR szDSClassAssocProviderCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_DSClassAssocProvider, szDSClassAssocProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszDSClassAssocProviderClassID[128];
	if(StringFromGUID2(CLSID_DSClassAssocProvider, wszDSClassAssocProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszDSClassAssocProviderClassID, -1, szDSClassAssocProviderClassID, 128, NULL, NULL);

#endif

	_tcscpy(szDSClassAssocProviderCLSIDClassID, CLSID_STR);
	_tcscat(szDSClassAssocProviderCLSIDClassID, szDSClassAssocProviderClassID);

	//
	// Delete the keys for DS Class Provider in the reverse order of creation in DllRegisterServer()
	//
	if(FALSE == DeleteKey(szDSClassAssocProviderCLSIDClassID, INPROC32_STR))
		return SELFREG_E_CLASS;
	if(FALSE == DeleteKey(CLSID_STR, szDSClassAssocProviderClassID))
		return SELFREG_E_CLASS;

	TCHAR szDSInstanceProviderClassID[128];
	TCHAR szDSInstanceProviderCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_DSInstanceProvider, szDSInstanceProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszDSInstanceProviderClassID[128];
	if(StringFromGUID2(CLSID_DSInstanceProvider, wszDSInstanceProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszDSInstanceProviderClassID, -1, szDSInstanceProviderClassID, 128, NULL, NULL);

#endif

	_tcscpy(szDSInstanceProviderCLSIDClassID, CLSID_STR);
	_tcscat(szDSInstanceProviderCLSIDClassID, szDSInstanceProviderClassID);

	//
	// Delete the keys in the reverse order of creation in DllRegisterServer()
	//
	if(FALSE == DeleteKey(szDSInstanceProviderCLSIDClassID, INPROC32_STR))
		return SELFREG_E_CLASS;
	if(FALSE == DeleteKey(CLSID_STR, szDSInstanceProviderClassID))
		return SELFREG_E_CLASS;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\main.cpp ===
//



// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

//

//***************************************************************************

//

//  MAIND.CPP

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains the global EXE functions

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************


#include <tchar.h>
#include <stdio.h>

#include <windows.h>
#include <objbase.h>
#include <olectl.h>

/* WBEM includes */
#include <wbemcli.h>
#include <wbemprov.h>
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include <sqllex.h>
#include <sql_1.h>

/* ADSI includes */
#include <activeds.h>

/* DS Provider includes */
#include "provlog.h"
#include "maindll.h"
#include "clsname.h"
#include <initguid.h>
#include "dscpguid.h"
#include "dsipguid.h"
#include "refcount.h"
#include "adsiprop.h"
#include "adsiclas.h"
#include "adsiinst.h"
#include "provlog.h"
#include "provexpt.h"
#include "tree.h"
#include "ldapcach.h"
#include "wbemcach.h"
#include "classpro.h"
#include "ldapprov.h"
#include "clsproi.h"
#include "ldapproi.h"
#include "classfac.h"
#include "instprov.h"
#include "instproi.h"
#include "instfac.h"

// Count of locks
long g_lComponents = 0;
// Count of active locks
long g_lServerLocks = 0;

// A critical section to create/delete statics 
CRITICAL_SECTION g_StaticsCreationDeletion;

ProvDebugLog *g_pLogObject = NULL;
BOOL s_Exiting = FALSE ;

typedef HRESULT (WINAPI* PFNCOINITIALIZEEX)(void* pvReserved,  //Reserved  
                                            DWORD dwCoInit      //COINIT value
                                            );

typedef HRESULT (WINAPI* PFNCOINITIALIZESECURITY)(
								PSECURITY_DESCRIPTOR         pSecDesc,
								LONG                         cAuthSvc,
								SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
								void                        *pReserved1,
								DWORD                        dwAuthnLevel,
								DWORD                        dwImpLevel,
								void                        *pReserved2,
								DWORD                        dwCapabilities,
								void                        *pReserved3 );

HRESULT COMInit();
STDAPI ExeRegisterServer(void);
STDAPI ExeUnregisterServer(void);


BOOL StartupProvider (DWORD *pdwClassFac)
{
	// Initialize the critical section to access the static initializer objects
	InitializeCriticalSection(&g_StaticsCreationDeletion);

	// Initialize the static Initializer objects. These are destroyed in DllCanUnloadNow
	CDSClassProviderClassFactory :: s_pDSClassProviderInitializer = NULL;
	CDSClassProviderClassFactory ::s_pLDAPClassProviderInitializer = NULL;
	CDSInstanceProviderClassFactory :: s_pDSInstanceProviderInitializer = NULL;
	CDSClassProviderClassFactory *lpunk1 = new CDSClassProviderClassFactory;
	CDSInstanceProviderClassFactory *lpunk2 = new CDSInstanceProviderClassFactory;
	CDSClassAssociationsProviderClassFactory *lpunk3 = new CDSClassAssociationsProviderClassFactory;
	lpunk1->AddRef();
	lpunk2->AddRef();
	lpunk3->AddRef();

	HRESULT hr = CoRegisterClassObject(
						  CLSID_DSProvider,			//Class identifier (CLSID) to be registered
						  (IUnknown *) lpunk1,						//Pointer to the class object
						  CLSCTX_LOCAL_SERVER|CLSCTX_INPROC_SERVER,	//Context for running executable code
						  REGCLS_MULTIPLEUSE,						//How to connect to the class object
						  &pdwClassFac[0]							//Pointer to the value returned
						  );

	if(SUCCEEDED(hr))
	{
		hr = CoRegisterClassObject(
						  CLSID_DSInstanceProvider,			//Class identifier (CLSID) to be registered
						  (IUnknown *) lpunk2,						//Pointer to the class object
						  CLSCTX_LOCAL_SERVER|CLSCTX_INPROC_SERVER,	//Context for running executable code
						  REGCLS_MULTIPLEUSE,						//How to connect to the class object
						  &pdwClassFac[1]							//Pointer to the value returned
						  );
	}

	if(SUCCEEDED(hr))
	{
		hr = CoRegisterClassObject(
						  CLSID_DSClassAssocProvider,			//Class identifier (CLSID) to be registered
						  (IUnknown *) lpunk3,						//Pointer to the class object
						  CLSCTX_LOCAL_SERVER|CLSCTX_INPROC_SERVER,	//Context for running executable code
						  REGCLS_MULTIPLEUSE,						//How to connect to the class object
						  &pdwClassFac[3]							//Pointer to the value returned
						  );
	}

	return (SUCCEEDED(hr));
}

void ShutdownProvider(DWORD *pdwClassFac)
{
	// Delete the Initializer objects
	EnterCriticalSection(&g_StaticsCreationDeletion);
	if(g_pLogObject)
		g_pLogObject->WriteW(L"DllCanUnloadNow called\r\n");
	delete CDSClassProviderClassFactory::s_pDSClassProviderInitializer;
	delete CDSClassProviderClassFactory::s_pLDAPClassProviderInitializer;
	delete CDSInstanceProviderClassFactory::s_pDSInstanceProviderInitializer;
	delete g_pLogObject;
	CDSClassProviderClassFactory::s_pDSClassProviderInitializer = NULL;
	CDSClassProviderClassFactory::s_pLDAPClassProviderInitializer = NULL;
	CDSInstanceProviderClassFactory::s_pDSInstanceProviderInitializer = NULL;
	g_pLogObject = NULL;
	LeaveCriticalSection(&g_StaticsCreationDeletion);


	CoRevokeClassObject(pdwClassFac[0]);
	CoRevokeClassObject(pdwClassFac[1]);
	CoRevokeClassObject(pdwClassFac[2]);
	DeleteCriticalSection(&g_StaticsCreationDeletion);
}

BOOL ParseCommandLine () 
{
	BOOL t_Exit = FALSE ;

	LPTSTR t_CommandLine = GetCommandLine () ;
	if ( t_CommandLine )
	{
		TCHAR *t_Arg = NULL ;
		TCHAR *t_ApplicationArg = NULL ;
		t_ApplicationArg = _tcstok ( t_CommandLine , _TEXT ( " \t" ) ) ;
		t_Arg = _tcstok ( NULL , _TEXT ( " \t" ) ) ;

		if ( t_Arg ) 
		{
			if ( _tcsicmp ( t_Arg , _TEXT ( "/RegServer" ) ) == 0 )
			{
				t_Exit = TRUE ;
			    ExeRegisterServer();
			}
			else if ( _tcsicmp ( t_Arg , _TEXT ( "/UnRegServer" ) ) == 0 )
			{
				t_Exit = TRUE ;
			    ExeUnregisterServer();
			}
            else if(_tcsicmp(t_Arg, _TEXT ( "/EMBEDDING" ) ) == 0)
		    {
			    // COM called us, so this is the real thing...
                t_Exit = FALSE;
		    }
		}
	}

	return t_Exit ;
}

LONG CALLBACK WindowsMainProc ( HWND a_hWnd , UINT a_message , WPARAM a_wParam , LPARAM a_lParam )
{
	long t_rc = 0 ;

	switch ( a_message )
	{
        case WM_CLOSE:
        {
            s_Exiting = TRUE ;
        }
        break ;

		case WM_DESTROY:
		{
			PostMessage ( a_hWnd , WM_QUIT , 0 , 0 ) ;
		}
		break ;

		default:
		{		
			t_rc = DefWindowProc ( a_hWnd , a_message , a_wParam , a_lParam ) ;
		}
		break ;
	}

	return ( t_rc ) ;
}

HWND WindowsInit ( HINSTANCE a_HInstance )
{
	static wchar_t *t_TemplateCode = L"DS Provider" ;

	WNDCLASS  t_wc ;
 
	t_wc.style            = CS_HREDRAW | CS_VREDRAW ;
	t_wc.lpfnWndProc      = WindowsMainProc ;
	t_wc.cbClsExtra       = 0 ;
	t_wc.cbWndExtra       = 0 ;
	t_wc.hInstance        = a_HInstance ;
	t_wc.hIcon            = LoadIcon(NULL, IDI_HAND) ;
	t_wc.hCursor          = LoadCursor(NULL, IDC_ARROW) ;
	t_wc.hbrBackground    = (HBRUSH) (COLOR_WINDOW + 1) ;
	t_wc.lpszMenuName     = NULL ;
	t_wc.lpszClassName    = t_TemplateCode ;
 
	ATOM t_winClass = RegisterClass ( &t_wc ) ;

	HWND t_HWnd = CreateWindow (

		t_TemplateCode ,              // see RegisterClass() call
		t_TemplateCode ,                      // text for window title bar
		WS_OVERLAPPEDWINDOW ,               // window style
		CW_USEDEFAULT ,                     // default horizontal position
		CW_USEDEFAULT ,                     // default vertical position
		CW_USEDEFAULT ,                     // default width
		CW_USEDEFAULT ,                     // default height
		NULL ,                              // overlapped windows have no parent
		NULL ,                              // use the window class menu
		a_HInstance ,
		NULL                                // pointer not needed
	) ;

	if (t_HWnd)
	{
		ShowWindow ( t_HWnd, SW_SHOW ) ;
	}

	return t_HWnd ;
}

void WindowsStop ( HWND a_HWnd )
{
	DestroyWindow ( a_HWnd ) ;
}

HWND WindowsStart ( HINSTANCE a_Handle )
{
	HWND t_HWnd = WindowsInit(a_Handle);

	return t_HWnd;
}

void WindowsDispatch ()
{
	BOOL t_GetMessage ;
	MSG t_lpMsg ;

	while (	( t_GetMessage = GetMessage ( & t_lpMsg , NULL , 0 , 0 ) ) == TRUE )
	{
		TranslateMessage ( & t_lpMsg ) ;
		DispatchMessage ( & t_lpMsg ) ;

        if ( s_Exiting ) 
            return ;
	}
}


int WINAPI WinMain (
  
    HINSTANCE hInstance,		// handle to current instance
    HINSTANCE hPrevInstance,	// handle to previous instance
    LPSTR lpCmdLine,			// pointer to command line
    int nShowCmd 				// show state of window
)
{
    // Initialize the COM Library.
	HRESULT hr = COMInit();

	BOOL t_Exit = ParseCommandLine();

	if (!t_Exit) 
	{
		HWND hWnd = WindowsStart(hInstance);

		if (hWnd)
		{
			DWORD dwArray[] = {0, 0, 0};

			if (StartupProvider(dwArray))
			{
				WindowsDispatch();
				ShutdownProvider(dwArray);
			}

			WindowsStop(hWnd);
		}
	}

	// Uninitialize the COM Library.
	::CoUninitialize() ;

	return 0 ;
}


////////////////////////////////////////////////////////////////////
// Strings used during self registration
////////////////////////////////////////////////////////////////////
LPCTSTR THREADING_MODEL_STR		= __TEXT("ThreadingModel");
LPCTSTR APARTMENT_STR			= __TEXT("Both");

LPCTSTR CLSID_STR				= __TEXT("CLSID\\");

// DS Class Provider
LPCTSTR DSPROVIDER_NAME_STR		= __TEXT("Microsoft NT DS Class Provider for WBEM");

// DS Class Associations provider
LPCTSTR DS_ASSOC_PROVIDER_NAME_STR		= __TEXT("Microsoft NT DS Class Associations Provider for WBEM");

// DS Instance provider
LPCTSTR DS_INSTANCE_PROVIDER_NAME_STR		= __TEXT("Microsoft NT DS Instance Provider for WBEM");

#define REG_FORMAT2_STR			_T("%s%s")
#define REG_FORMAT3_STR			_T("%s%s\\%s")
#define VER_IND_STR				_T("VersionIndependentProgID")
#define NOT_INTERT_STR			_T("NotInsertable")
#define LOCALSRV32_STR			_T("LocalServer32")
#define PROGID_STR				_T("ProgID")
#define THREADING_MODULE_STR	_T("ThreadingModel")
#define APARTMENT_STR			_T("Both")

#define CLSID_STR				_T("CLSID\\")


/***************************************************************************
 * SetKeyAndValue
 *
 * Purpose:
 *  Private helper function for DllRegisterServer that creates
 *  a key, sets a value, and closes that key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the ame of the key
 *  pszSubkey       LPTSTR ro the name of a subkey
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue(LPCTSTR pszKey, LPCTSTR pszSubkey, LPCTSTR pszValueName, LPCTSTR pszValue)
{
    HKEY        hKey;
    TCHAR       szKey[256];

    _tcscpy(szKey, pszKey);

	// If a sub key is mentioned, use it.
    if (NULL != pszSubkey)
    {
		_tcscat(szKey, __TEXT("\\"));
        _tcscat(szKey, pszSubkey);
    }

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
		szKey, 0, NULL, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

    if (NULL != pszValue)
    {
        if (ERROR_SUCCESS != RegSetValueEx(hKey, pszValueName, 0, REG_SZ, (BYTE *)pszValue,
			(_tcslen(pszValue)+1)*sizeof(TCHAR)))
			return FALSE;
    }
    RegCloseKey(hKey);
    return TRUE;
}

BOOL DeleteKey(LPCTSTR pszKey, LPCTSTR pszSubkey)
{
    HKEY        hKey;

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
		pszKey, 0, NULL, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

	if(ERROR_SUCCESS != RegDeleteKey(hKey, pszSubkey))
		return FALSE;

    RegCloseKey(hKey);
    return TRUE;
}


//***************************************************************************
//
// ExeRegisterServer
//
// Purpose: Called when /register is specified on the command line.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI ExeRegisterServer(void)
{   

	TCHAR szModule[MAX_PATH + 1];
	HINSTANCE hInst = GetModuleHandle(_T("DSPROV"));
	GetModuleFileName(hInst,(TCHAR*)szModule, MAX_PATH + 1);

	TCHAR szDSProviderClassID[128];
	TCHAR szDSProviderCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_DSProvider, szDSProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszDSProviderClassID[128];
	if(StringFromGUID2(CLSID_DSProvider, wszDSProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszDSProviderClassID, -1, szDSProviderCLSIDClassID, 128, NULL, NULL);

#endif

	_tcscpy(szDSProviderCLSIDClassID, CLSID_STR);
	_tcscat(szDSProviderCLSIDClassID, szDSProviderClassID);

	//
	// Create entries under CLSID for DS Class Provider
	//
	if (FALSE == SetKeyAndValue(szDSProviderCLSIDClassID, NULL, NULL, DSPROVIDER_NAME_STR))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szDSProviderCLSIDClassID, LOCALSRV32_STR, NULL, szModule))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szDSProviderCLSIDClassID, LOCALSRV32_STR, THREADING_MODEL_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;


	TCHAR szDSClassAssocProviderClassID[128];
	TCHAR szDSClassAssocProviderCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_DSClassAssocProvider, szDSClassAssocProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszDSClassAssocProviderClassID[128];
	if(StringFromGUID2(CLSID_DSClassAssocProvider, wszDSClassAssocProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszDSClassAssocProviderClassID, -1, szDSClassAssocProviderCLSIDClassID, 128, NULL, NULL);

#endif

	_tcscpy(szDSClassAssocProviderCLSIDClassID, CLSID_STR);
	_tcscat(szDSClassAssocProviderCLSIDClassID, szDSClassAssocProviderClassID);

	//
	// Create entries under CLSID for DS Class Associations Provider
	//
	if (FALSE == SetKeyAndValue(szDSClassAssocProviderCLSIDClassID, NULL, NULL, DS_ASSOC_PROVIDER_NAME_STR))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szDSClassAssocProviderCLSIDClassID, LOCALSRV32_STR, NULL, szModule))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szDSClassAssocProviderCLSIDClassID, LOCALSRV32_STR, THREADING_MODEL_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;




	TCHAR szDSInstanceProviderClassID[128];
	TCHAR szDSInstanceProviderCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_DSInstanceProvider, szDSInstanceProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszDSInstanceProviderClassID[128];
	if(StringFromGUID2(CLSID_DSInstanceProvider, wszDSInstanceProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszDSInstanceProviderClassID, -1, szDSInstanceProviderCLSIDClassID, 128, NULL, NULL);

#endif


	_tcscpy(szDSInstanceProviderCLSIDClassID, CLSID_STR);
	_tcscat(szDSInstanceProviderCLSIDClassID, szDSInstanceProviderClassID);

	//
	// Create entries under CLSID for DS Instance Provider
	//
	if (FALSE == SetKeyAndValue(szDSInstanceProviderCLSIDClassID, NULL, NULL, DS_INSTANCE_PROVIDER_NAME_STR))
		return SELFREG_E_CLASS;

	if (FALSE == SetKeyAndValue(szDSInstanceProviderCLSIDClassID, LOCALSRV32_STR, NULL, szModule))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szDSInstanceProviderCLSIDClassID, LOCALSRV32_STR, THREADING_MODEL_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;

	return S_OK;
}

//***************************************************************************
//
// ExeUnregisterServer
//
// Purpose: Called when /unregister is specified on the command line.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI ExeUnregisterServer(void)
{
	TCHAR szModule[MAX_PATH + 1];
	HINSTANCE hInst = GetModuleHandle(_T("DSPROV"));
	GetModuleFileName(hInst,(TCHAR*)szModule, MAX_PATH + 1);


	TCHAR szDSProviderClassID[128];
	TCHAR szDSProviderCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_DSProvider, szDSProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszDSProviderClassID[128];
	if(StringFromGUID2(CLSID_DSProvider, wszDSProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszDSProviderClassID, -1, szDSProviderCLSIDClassID, 128, NULL, NULL);

#endif

	_tcscpy(szDSProviderCLSIDClassID, CLSID_STR);
	_tcscat(szDSProviderCLSIDClassID, szDSProviderClassID);

	//
	// Delete the keys for DS Class Provider in the reverse order of creation in DllRegisterServer()
	//
	if(FALSE == DeleteKey(szDSProviderCLSIDClassID, LOCALSRV32_STR))
		return SELFREG_E_CLASS;
	if(FALSE == DeleteKey(CLSID_STR, szDSProviderClassID))
		return SELFREG_E_CLASS;

	TCHAR szDSClassAssocProviderClassID[128];
	TCHAR szDSClassAssocProviderCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_DSClassAssocProvider, szDSClassAssocProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszDSClassAssocProviderClassID[128];
	if(StringFromGUID2(CLSID_DSClassAssocProvider, wszDSClassAssocProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszDSClassAssocProviderClassID, -1, szDSClassAssocProviderCLSIDClassID, 128, NULL, NULL);

#endif

	_tcscpy(szDSClassAssocProviderCLSIDClassID, CLSID_STR);
	_tcscat(szDSClassAssocProviderCLSIDClassID, szDSClassAssocProviderClassID);

	//
	// Delete the keys for DS Class Provider in the reverse order of creation in DllRegisterServer()
	//
	if(FALSE == DeleteKey(szDSClassAssocProviderCLSIDClassID, LOCALSRV32_STR))
		return SELFREG_E_CLASS;
	if(FALSE == DeleteKey(CLSID_STR, szDSClassAssocProviderClassID))
		return SELFREG_E_CLASS;

	TCHAR szDSInstanceProviderClassID[128];
	TCHAR szDSInstanceProviderCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_DSInstanceProvider, szDSInstanceProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszDSInstanceProviderClassID[128];
	if(StringFromGUID2(CLSID_DSInstanceProvider, wszDSInstanceProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszDSInstanceProviderClassID, -1, szDSInstanceProviderCLSIDClassID, 128, NULL, NULL);

#endif

	_tcscpy(szDSInstanceProviderCLSIDClassID, CLSID_STR);
	_tcscat(szDSInstanceProviderCLSIDClassID, szDSInstanceProviderClassID);

	//
	// Delete the keys in the reverse order of creation in DllRegisterServer()
	//
	if(FALSE == DeleteKey(szDSInstanceProviderCLSIDClassID, LOCALSRV32_STR))
		return SELFREG_E_CLASS;
	if(FALSE == DeleteKey(CLSID_STR, szDSInstanceProviderClassID))
		return SELFREG_E_CLASS;
	return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
HRESULT COMInit()
{
    HRESULT hr;
    PFNCOINITIALIZESECURITY pfnCoInitializeSecurity = NULL;
    PFNCOINITIALIZEEX pfnCoInitializeEx = NULL;

   	
    //Get handle to COM library 
    HMODULE ghOle32 = LoadLibraryEx(_T("ole32.dll"), NULL, 0);

    if(ghOle32 != NULL) 
    {                                            
	    //Get ptr to functions CoInitialize and CoInitializeSecurity.
        pfnCoInitializeEx = (PFNCOINITIALIZEEX) GetProcAddress(ghOle32, 
                                                   "CoInitializeEx");
        pfnCoInitializeSecurity = (PFNCOINITIALIZESECURITY) GetProcAddress(ghOle32, 
                                             "CoInitializeSecurity");

        //Initialize COM
	    if (pfnCoInitializeEx) 
	    {
	        hr = pfnCoInitializeEx(NULL, COINIT_MULTITHREADED);
        }
	    else 
	    {
            hr = CoInitialize(NULL);
	    }

	    if(FAILED(hr))
	    {
		    FreeLibrary(ghOle32);
            ghOle32 = NULL;
            return E_FAIL;
	    }
	  
	    //Initialize Security
	    if (pfnCoInitializeSecurity)
	    {
		    hr = pfnCoInitializeSecurity(NULL, -1, NULL, NULL, 
		      							   RPC_C_AUTHN_LEVEL_NONE, 
			       						   RPC_C_IMP_LEVEL_IMPERSONATE, 
     				   					   NULL, EOAC_NONE, 0);
        }
	
	    if(FAILED(hr))
	    {
	        CoUninitialize();
	        FreeLibrary(ghOle32);
            ghOle32 = NULL;
	        return E_FAIL;
	    }

    }
    else
    {
	    return E_FAIL;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\log.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:log.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the Logging object which supplies
// basic thread-safe logging capabilities.  The behaviour of this log object depends on
// 3 keys in the registry under a root key whose path is supplied in the construction
// of this object. The 3 keys are:
//	File: The path to the file where the logging is done
//	Enabled: 1 if logging is enabled, any other value disables logging
//	Level: Severity level. Only messages tagged with severity levels greater than
//		or equal to this level are logged/ 
//
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

class CDsLog : ProvDebugLog
{
public:

	//***************************************************************************
	//
	// CDsLog::CDsLog
	//
	// Purpose: Contructs an empty CDsLog object.
	//
	// Parameters:
	//  None
	//
	//***************************************************************************
	CDsLog(const TCHAR *a_DebugComponent );

	//***************************************************************************
	//
	// CDsLog::~CDsLog
	//
	// Purpose: Destructor
	//
	//
	//***************************************************************************
	virtual ~CDsLog();

	//***************************************************************************
	//
	// CDsLog::LogMessage
	//
	// Purpose: Initialise it by supplying the registry key that stores the
	//		configuration information
	//
	// Parameters:
	//  lpszRegistrySubTreeRoot: The root of the subtree from which the configuration
	//	values ("File", "Enabled" and "Level") are read
	//
	// Return Value:
	//  TRUE  If the object was initialized successfully. else, FALSE.
	//
	//***************************************************************************
	BOOLEAN Initialise(LPCWSTR lpRegistryRoot);

	//***************************************************************************
	//
	// CDsLog::LogMessage
	//
	// Purpose: Initialise it by supplying the values for File, Level and Enabled keys
	//
	// Parameters:
	//	lpszFileName: The name of the file to which log messages are written
	//  bEnabled: Whether ;pgging is enabled to start with
	//	iLevel : The severity level. Any messages at or above this level are logged.
	//
	// Return Value:
	//	TRUE if successfully initialized. Else, FALSE
	//
	//***************************************************************************
	BOOLEAN Initialise(LPCWSTR lpszFileName, BOOLEAN bEnabled, UINT iLevel);

	//***************************************************************************
	//
	// CDsLog::LogMessage
	//
	// Purpose: Logs a message. The actual message is written on to the log file
	//	only if logging has been enabled and the severity level of the message is
	//	greater than the severity level currently logged
	//
	// Parameters:
	//  iLevel : The severity level of this message
	//	lpszMessage : The message which is formatted according to the 
	//		standard printf() format
	//	The rest of the arguments required for above string to be pronted follow
	//
	// Return Value:
	//	None
	//
	//***************************************************************************
	void LogMessage(UINT iLevel, LPCWSTR lpszMessage, ...);

	// The various severity levels
	enum SeverityLevels
	{
		NONE,
		INFORMATION,
		WARNING,
		FATAL
	};

private:
	//***************************************************************************
	//
	// CDsLog::WriteInitialMessage
	//
	// Purpose: Writes the time the log was created into the log file
	//
	// Parameters:
	//
	// Return Value: None
	//
	//***************************************************************************
	void WriteInitialMessage();

	//***************************************************************************
	//
	// CDsLog::GetRegistryValues
	//
	// Purpose: Reads the registry values and fills in the members.
	//
	// Parameters:
	//  lpszRegistrySubTreeRoot: The root of the subtree from which the configuration
	//	values ("File", "Enabled" and "Level") are read
	//
	// Return Value:
	//  TRUE         If the reading of the registry was done successflly, FALSE otherwise
	//
	//***************************************************************************
	BOOLEAN GetRegistryValues(LPCWSTR lpRegistryRoot);

	// The Log File name
	LPTSTR m_lpszLogFileName;

	// Pointer to the log file
	ProvDebugLog *m_pProvLog;
	// Logging level till which logging is enabled
	UINT m_iLevel;
	// Whether logging is enabled
	BOOLEAN m_bEnabled;

	// The key in the registry below which the File, Enabled and Type keys are
	// defined
	LPTSTR m_lpszRegistryRoot;

	// Literals for "FILE", "ENABLED" and "TYPE"
	static LPCTSTR FILE_STRING;
	static LPCTSTR ENABLED_STRING;
	static LPCTSTR LEVEL_STRING;
	static LPCTSTR ONE_STRING;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// All Rights Reserved.
//

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
#include <tchar.h>
#include <stdio.h>

#include <assert.h>
#include <objbase.h>
#include <olectl.h>
#include <comdef.h>


/* WBEM includes */
#include <wbemcli.h>
#include <wbemprov.h>
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include <sqllex.h>
#include <sql_1.h>
#include <cominit.h>

/* ADSI includes */
#include <activeds.h>

/* DS Provider includes */
#include <provexpt.h>
#include <provlog.h>
#include "maindll.h"
#include "attributes.h"
#include "clsname.h"
#include "refcount.h"
#include "adsiprop.h"
#include "adsiclas.h"
#include "adsiinst.h"
#include "tree.h"
#include "ldapcach.h"
#include "ldaphelp.h"
#include "wbemhelp.h"
#include "wbemcach.h"
#include "classpro.h"
#include "ldapprov.h"
#include "clsproi.h"
#include "ldapproi.h"
#include "classfac.h"
#include "instprov.h"
#include "instproi.h"
#include "instfac.h"
#include "assocprov.h"
#include <wbemtime.h>
#include "queryconv.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\maindll.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Count of locks
extern long g_lComponents;

// Count of active locks
extern long g_lServerLocks;

// Critical section to access the static initializers of all classes in the DLL
extern CRITICAL_SECTION g_StaticsCreationDeletion;

// The log object for all providers
extern ProvDebugLog *g_pLogObject;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\queryconv.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include "precomp.h"


const WCHAR QueryConvertor::wchAND		= L'&';
const WCHAR QueryConvertor::wchOR			= L'|';
const WCHAR QueryConvertor::wchNOT		= L'!';
const WCHAR QueryConvertor::wchSTAR		= L'*';
const WCHAR QueryConvertor::wchEQUAL		= L'=';
const WCHAR QueryConvertor::wchLEFT_BRACKET	= L'(';
const WCHAR QueryConvertor::wchRIGHT_BRACKET	= L')';
const WCHAR QueryConvertor::wchBACK_SLASH		= L'\\';
LPCWSTR QueryConvertor::pszGE	= L">=";
LPCWSTR QueryConvertor::pszLE	= L"<=";

int Stack::s_iMax = 100;

// This assumes that enough memory has been allocated to the resulting query
BOOLEAN QueryConvertor::ConvertQueryToLDAP(SQL_LEVEL_1_RPN_EXPRESSION *pExp, LPWSTR pszLDAPQuery)
{
	Stack t_stack;

	int iCurrentOperator = 0, idwNumOperandsLeft = 0;
	int iOutputIndex = 0;

	if(pExp->nNumTokens == 0)
		return TRUE;

	int iCurrentToken = pExp->nNumTokens -1;

	SQL_LEVEL_1_TOKEN *pNextToken = pExp->pArrayOfTokens + iCurrentToken;

	BOOLEAN retVal = FALSE, done = FALSE;

	// Write a '(' at the head of the LDAP Query
	pszLDAPQuery[iOutputIndex ++] = wchLEFT_BRACKET;

	while (!done && iCurrentToken >= 0)
	{
		switch(pNextToken->nTokenType)
		{
			case SQL_LEVEL_1_TOKEN::OP_EXPRESSION:
			{
				// Try to tranlsate expression to LDAP
				if(TranslateExpression(pszLDAPQuery, &iOutputIndex, pNextToken->nOperator, pNextToken->pPropertyName, &pNextToken->vConstValue))
				{
					// If we've finished all the operands for the current operator, get the next one
					idwNumOperandsLeft --;
					while(idwNumOperandsLeft == 0)
					{
						pszLDAPQuery[iOutputIndex ++] = wchRIGHT_BRACKET;
						if(!t_stack.Pop(&iCurrentOperator, &idwNumOperandsLeft))
							done = TRUE;
						idwNumOperandsLeft --;
					}
					iCurrentToken --;
				}
				else
					done = TRUE;
				pNextToken --;
				break;
			}

			case SQL_LEVEL_1_TOKEN::TOKEN_AND:
			{
				if(iCurrentOperator)
				{
					if(!t_stack.Push(iCurrentOperator, idwNumOperandsLeft))
						done = TRUE;
					iCurrentOperator = SQL_LEVEL_1_TOKEN::TOKEN_AND;
					idwNumOperandsLeft = 2;
					pszLDAPQuery[iOutputIndex ++] = wchLEFT_BRACKET;
					pszLDAPQuery[iOutputIndex ++] = wchAND;
				}
				else
				{
					pszLDAPQuery[iOutputIndex ++] = wchLEFT_BRACKET;
					pszLDAPQuery[iOutputIndex ++] = wchAND;
					iCurrentOperator = SQL_LEVEL_1_TOKEN::TOKEN_AND;
					idwNumOperandsLeft = 2;
				}
				iCurrentToken --;
				pNextToken --;

				break;
			}

			case SQL_LEVEL_1_TOKEN::TOKEN_OR:
			{
				if(iCurrentOperator)
				{
					if(!t_stack.Push(iCurrentOperator, idwNumOperandsLeft))
						done = TRUE;
					iCurrentOperator = SQL_LEVEL_1_TOKEN::TOKEN_OR;
					idwNumOperandsLeft = 2;
					pszLDAPQuery[iOutputIndex ++] = wchLEFT_BRACKET;
					pszLDAPQuery[iOutputIndex ++] = wchOR;
				}
				else
				{
					pszLDAPQuery[iOutputIndex ++] = wchLEFT_BRACKET;
					pszLDAPQuery[iOutputIndex ++] = wchOR;
					iCurrentOperator = SQL_LEVEL_1_TOKEN::TOKEN_OR;
					idwNumOperandsLeft = 2;
				}
				iCurrentToken --;
				pNextToken --;
				break;
			}

			case SQL_LEVEL_1_TOKEN::TOKEN_NOT:
			{
				if(iCurrentOperator)
				{
					if(!t_stack.Push(iCurrentOperator, idwNumOperandsLeft))
						done = TRUE;
					iCurrentOperator = SQL_LEVEL_1_TOKEN::TOKEN_NOT;
					idwNumOperandsLeft = 1;
					pszLDAPQuery[iOutputIndex ++] = wchLEFT_BRACKET;
					pszLDAPQuery[iOutputIndex ++] = wchNOT;
				}
				else
				{
					pszLDAPQuery[iOutputIndex ++] = wchLEFT_BRACKET;
					pszLDAPQuery[iOutputIndex ++] = wchNOT;
					iCurrentOperator = SQL_LEVEL_1_TOKEN::TOKEN_NOT;
					idwNumOperandsLeft = 1;
				}
				iCurrentToken --;
				pNextToken --;
				break;
			}

			default:
				done = TRUE;
				break;
		}

	}

	// Check if we used up all the tokens
	if(iCurrentToken == -1)
		retVal = TRUE;

	// Write a ')' at the end of the LDAP Query
	pszLDAPQuery[iOutputIndex ++] = wchRIGHT_BRACKET;
	pszLDAPQuery[iOutputIndex ++] = NULL;
	return retVal;
}



BOOLEAN QueryConvertor::TranslateExpression(LPWSTR pszLDAPQuery, int *piOutputIndex, 
											int iOperator, LPCWSTR pszPropertyName, VARIANT *pValue)
{
	// If it is a CIMOM System property, then dont attempt to map it to LDAP
	if(pszPropertyName[0] == L'_' &&
		pszPropertyName[1] == L'_' )
		return TRUE;

	// If it is ADSIPath, convert it to distinguishedName attribute
	if(_wcsicmp(pszPropertyName, ADSI_PATH_ATTR) == 0 )
	{
		if(pValue== NULL || pValue->vt == VT_NULL)
		{
			if(iOperator == SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL)
			{
				// Put the property name as DistiguishedName
				wcscpy(pszLDAPQuery + *piOutputIndex, DISTINGUISHED_NAME_ATTR);
				*piOutputIndex += wcslen(DISTINGUISHED_NAME_ATTR);


				*(pszLDAPQuery + *piOutputIndex) = wchEQUAL;
				(*piOutputIndex) ++;

				*(pszLDAPQuery + *piOutputIndex) = wchSTAR;
				(*piOutputIndex) ++;
				return TRUE;
			}
			else
			{
				// The '!'
				*(pszLDAPQuery + *piOutputIndex) = wchNOT;
				(*piOutputIndex) ++;

				// The '('
				*(pszLDAPQuery + *piOutputIndex) = wchLEFT_BRACKET;
				(*piOutputIndex) ++;
				if(TranslateExpression(pszLDAPQuery, piOutputIndex, SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL, pszPropertyName, NULL))
				{
					// The ')'
					*(pszLDAPQuery + *piOutputIndex) = wchRIGHT_BRACKET;
					(*piOutputIndex) ++;
					return TRUE;
				}
				else 
					return FALSE;
			}
		}

		// TODO - WinMgmt should not allow this. It should check that the property type matches the property value
		// As soon as Winmgmt has fixed this bug, the next 2 lines may be deleted
		if(pValue->vt != VT_BSTR)
			return FALSE;

		// Get the parentADSI path and RDN from the ADSI Path
		IADsPathname *pADsPathName = NULL;
		BSTR strADSIPath = SysAllocString(pValue->bstrVal);
		BSTR strDN = NULL;
		BOOLEAN bRetVal = FALSE;
		HRESULT result = E_FAIL;
		if(SUCCEEDED(result = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_ALL, IID_IADsPathname, (LPVOID *)&pADsPathName)))
		{
			if(SUCCEEDED(result = pADsPathName->Set(strADSIPath, ADS_SETTYPE_FULL)))
			{
				// This gives the DN
				if(SUCCEEDED(result = pADsPathName->Retrieve(ADS_FORMAT_X500_DN, &strDN)))
				{
					// Put the property name as DistiguishedName
					wcscpy(pszLDAPQuery + *piOutputIndex, DISTINGUISHED_NAME_ATTR);
					*piOutputIndex += wcslen(DISTINGUISHED_NAME_ATTR);

					// Put the LDAP Operator
					if(iOperator == SQL_LEVEL_1_TOKEN::OP_EQUAL)
					{
						*(pszLDAPQuery + *piOutputIndex) = wchEQUAL;
						(*piOutputIndex) ++;
					}
					else
					{
						// The '!'
						*(pszLDAPQuery + *piOutputIndex) = wchNOT;
						(*piOutputIndex) ++;

						*(pszLDAPQuery + *piOutputIndex) = wchEQUAL;
						(*piOutputIndex) ++;
					}

					// Look for the special characters ( ) * and \ and escape them with a \ 
					LPWSTR pszEscapedValue = EscapeStringValue(strDN);
					wcscpy(pszLDAPQuery + *piOutputIndex, pszEscapedValue);
					(*piOutputIndex) += wcslen(pszEscapedValue);
					delete [] pszEscapedValue;

					SysFreeString(strDN);
					bRetVal = TRUE;
				}
			}
			pADsPathName->Release();
		}
		SysFreeString(strADSIPath);

		return bRetVal;
	}

	// Write a '('
	pszLDAPQuery[(*piOutputIndex) ++] = wchLEFT_BRACKET;

	switch(iOperator)
	{
		case SQL_LEVEL_1_TOKEN::OP_EQUAL:
		{
			// Special case where we use '*' LDAP operator
			// is NULL translates to !( x=*)
			if(pValue->vt == VT_NULL)
			{
				// The '!'
				*(pszLDAPQuery + *piOutputIndex) = wchNOT;
				(*piOutputIndex) ++;

				// The '('
				*(pszLDAPQuery + *piOutputIndex) = wchLEFT_BRACKET;
				(*piOutputIndex) ++;

				if(!TranslateExpression(pszLDAPQuery, piOutputIndex, SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL, pszPropertyName, NULL))
					return FALSE;

				// The ')'
				*(pszLDAPQuery + *piOutputIndex) = wchRIGHT_BRACKET;
				(*piOutputIndex) ++;

				break;
			}
			else
			{
				// Followthru
			}
		}
		case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
		case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
		{
			// Get the LDAP name of the property
			LPWSTR pszLDAPName = CLDAPHelper::UnmangleWBEMNameToLDAP(pszPropertyName);
			wcscpy(pszLDAPQuery + *piOutputIndex, pszLDAPName);
			*piOutputIndex += wcslen(pszLDAPName);
			delete [] pszLDAPName;

			// Put the LDAP Operator
			if(iOperator == SQL_LEVEL_1_TOKEN::OP_EQUAL)
			{
				*(pszLDAPQuery + *piOutputIndex) = wchEQUAL;
				(*piOutputIndex) ++;
			}
			else if(iOperator == SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN)
			{
				wcscpy(pszLDAPQuery + *piOutputIndex, pszGE);
				*piOutputIndex += 2;
			}
			else
			{
				wcscpy(pszLDAPQuery + *piOutputIndex, pszLE);
				*piOutputIndex += 2;
			}

			// Put the value of the property
			if(!TranslateValueToLDAP(pszLDAPQuery, piOutputIndex, pValue))
				return FALSE;

		}
		break;

		case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
		{
			// Special case for use of '*'
			if(pValue == NULL || pValue->vt == VT_NULL)
			{

				// Get the LDAP name of the property
				LPWSTR pszLDAPName = CLDAPHelper::UnmangleWBEMNameToLDAP(pszPropertyName);
				wcscpy(pszLDAPQuery + *piOutputIndex, pszLDAPName);
				*piOutputIndex += wcslen(pszLDAPName);
				delete [] pszLDAPName;

				*(pszLDAPQuery + *piOutputIndex) = wchEQUAL;
				(*piOutputIndex) ++;

				*(pszLDAPQuery + *piOutputIndex) = wchSTAR;
				(*piOutputIndex) ++;

			}
			else 			
			{
				// The '!'
				*(pszLDAPQuery + *piOutputIndex) = wchNOT;
				(*piOutputIndex) ++;

				// The '('
				*(pszLDAPQuery + *piOutputIndex) = wchLEFT_BRACKET;
				(*piOutputIndex) ++;

				if(TranslateExpression(pszLDAPQuery, piOutputIndex, SQL_LEVEL_1_TOKEN::OP_EQUAL, pszPropertyName, pValue))
				{
					// The ')'
					*(pszLDAPQuery + *piOutputIndex) = wchRIGHT_BRACKET;
					(*piOutputIndex) ++;
				}
				else
					return FALSE;
			}
		}
		break;

		case SQL_LEVEL_1_TOKEN::OP_LESSTHAN:
		{
			// The '!'
			*(pszLDAPQuery + *piOutputIndex) = wchNOT;
			(*piOutputIndex) ++;

			// The '('
			*(pszLDAPQuery + *piOutputIndex) = wchLEFT_BRACKET;
			(*piOutputIndex) ++;

			if(TranslateExpression(pszLDAPQuery, piOutputIndex, SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN, pszPropertyName, pValue))
			{
				// The ')'
				*(pszLDAPQuery + *piOutputIndex) = wchRIGHT_BRACKET;
				(*piOutputIndex) ++;
			}
			else
				return FALSE;
		}
		break;

		case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN:
		{
			// The '!'
			*(pszLDAPQuery + *piOutputIndex) = wchNOT;
			(*piOutputIndex) ++;

			// The '('
			*(pszLDAPQuery + *piOutputIndex) = wchLEFT_BRACKET;
			(*piOutputIndex) ++;

			if(TranslateExpression(pszLDAPQuery, piOutputIndex, SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN, pszPropertyName, pValue))
			{
				// The ')'
				*(pszLDAPQuery + *piOutputIndex) = wchRIGHT_BRACKET;
				(*piOutputIndex) ++;
			}
			else
				return FALSE;
		}
		break;
		default:
			return FALSE;
	}

	// Write a ')'
	pszLDAPQuery[(*piOutputIndex) ++] = wchRIGHT_BRACKET;
	return TRUE;
}

BOOLEAN QueryConvertor::TranslateValueToLDAP(LPWSTR pszLDAPQuery, int *piOutputIndex, VARIANT *pValue)
{
	switch(pValue->vt)
	{
		case VT_BSTR:
			{ 
				// Look for the special characters ( ) * and \ and escape them with a \ 
				LPWSTR pszEscapedValue = EscapeStringValue(pValue->bstrVal);
				wcscpy(pszLDAPQuery + *piOutputIndex, pszEscapedValue);
				(*piOutputIndex) += wcslen(pszEscapedValue);
				delete [] pszEscapedValue;
		}
		break;
			
		case VT_I4:
		{
			WCHAR temp[18];
			swprintf(temp, L"%d", pValue->lVal);
			wcscpy(pszLDAPQuery + *piOutputIndex, temp);
			(*piOutputIndex) += wcslen(temp);
		}
		break;

		case VT_BOOL:
		{
			if(pValue->boolVal == VARIANT_TRUE)
			{
				wcscpy(pszLDAPQuery + *piOutputIndex, L"TRUE");
				(*piOutputIndex) += wcslen(L"TRUE");
			}
			else
			{
				wcscpy(pszLDAPQuery + *piOutputIndex, L"FALSE");
				(*piOutputIndex) += wcslen(L"FALSE");
			}
		}
		break;
		default:
			return FALSE;
	}
	return TRUE;
}

LPWSTR QueryConvertor::EscapeStringValue(LPCWSTR pszValue)
{
	// Escape the special characters in a string value in a query
	LPWSTR pszRetValue = new WCHAR [wcslen(pszValue)*2 + 1];
	DWORD j=0;
	for(DWORD i=0; i<wcslen(pszValue); i++)
	{
		switch(pszValue[i])
		{
			case wchLEFT_BRACKET:
				pszRetValue[j++] = wchBACK_SLASH;
				pszRetValue[j++] = '2';
				pszRetValue[j++] = '8';
				break;
			case wchRIGHT_BRACKET:
				pszRetValue[j++] = wchBACK_SLASH;
				pszRetValue[j++] = '2';
				pszRetValue[j++] = '9';
				break;
			case wchSTAR:
				pszRetValue[j++] = wchBACK_SLASH;
				pszRetValue[j++] = '2';
				pszRetValue[j++] = 'a';
				break;
			case wchBACK_SLASH:
				pszRetValue[j++] = wchBACK_SLASH;
				pszRetValue[j++] = '5';
				pszRetValue[j++] = 'c';
				break;

			default:
				pszRetValue[j++] = pszValue[i];
				break;
		}
	}
	pszRetValue[j] = NULL;
	return 	pszRetValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\queryconv.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#ifndef QUERY_H
#define QUERY_H


struct StackElement
{
	int m_iOperator;
	int m_iNumOperandsLeft;
};

class Stack
{
	StackElement m_stack[100];
	int m_iTop;
	static int s_iMax;

	public:
		Stack()
		{
			m_iTop = 0;
		}

		BOOLEAN Push(int iOperator, int iNumOperandsLeft)
		{
			if(m_iTop == s_iMax)
				return FALSE;
			m_stack[m_iTop].m_iOperator = iOperator;
			m_stack[m_iTop].m_iNumOperandsLeft = iNumOperandsLeft;
			m_iTop ++;
			return TRUE;
		}

		BOOLEAN Pop(int *piOperator, int *piNumOperandsLeft)
		{
			if(m_iTop == 0)
				return FALSE;
			m_iTop --;
			*piOperator = 	m_stack[m_iTop].m_iOperator;
			*piNumOperandsLeft = m_stack[m_iTop].m_iNumOperandsLeft;
			return TRUE;
		}

};

class QueryConvertor
{
private:
	static const WCHAR wchAND;
	static const WCHAR wchOR;
	static const WCHAR wchNOT;
	static const WCHAR wchEQUAL;
	static const WCHAR wchSTAR;
	static const WCHAR wchLEFT_BRACKET;
	static const WCHAR wchRIGHT_BRACKET;
	static LPCWSTR pszGE;
	static LPCWSTR pszLE;

	// Special characters excluding ( and ) and *
	static const WCHAR wchBACK_SLASH;

	static BOOLEAN TranslateExpression(LPWSTR pszLDAPQuery, int *piOutputIndex, 
											int iOperator, LPCWSTR pszPropertyName, VARIANT *pValue);
	static BOOLEAN TranslateValueToLDAP(LPWSTR pszLDAPQuery, int *piOutputIndex, VARIANT *pValue);

	static LPWSTR EscapeStringValue(LPCWSTR pszValue);

public:
	// This assumes that enough memory has been allocated to the resulting query
	static BOOLEAN ConvertQueryToLDAP(SQL_LEVEL_1_RPN_EXPRESSION *pExp, LPWSTR pszLDAPQuery);


};	

#endif /* QUERY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\refcount.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:refcount.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the imlementation for a basic reference counted object
//
//***************************************************************************

#include "precomp.h"

CRefCountedObject::CRefCountedObject() :
	m_dwRefCount ( 1 ),
	m_lpszName ( NULL ),
	m_CreationTime ( 0 ),
	m_LastAccessTime ( 0 )
{
	// Initialize the critical section 
	InitializeCriticalSection(&m_ReferenceCountSection);

	FILETIME fileTime;
	GetSystemTimeAsFileTime(&fileTime);
	LARGE_INTEGER creationTime;
	memcpy((LPVOID)&creationTime, (LPVOID)&fileTime, sizeof LARGE_INTEGER);
	m_CreationTime = creationTime.QuadPart;
	m_LastAccessTime = creationTime.QuadPart;
}

CRefCountedObject::CRefCountedObject(LPCWSTR lpszName) :
	m_dwRefCount ( 1 ),
	m_lpszName ( NULL ),
	m_CreationTime ( 0 ),
	m_LastAccessTime ( 0 )
{
	// Initialize the critical section 
	InitializeCriticalSection(&m_ReferenceCountSection);

	if(lpszName)
	{
		try
		{
			m_lpszName = new WCHAR[wcslen(lpszName) + 1];
			wcscpy(m_lpszName, lpszName);
		}
		catch ( ... )
		{
			if ( m_lpszName )
			{
				delete [] m_lpszName;
				m_lpszName = NULL;
			}

			DeleteCriticalSection(&m_ReferenceCountSection);

			throw;
		}
	}

	FILETIME fileTime;
	GetSystemTimeAsFileTime(&fileTime);
	LARGE_INTEGER creationTime;
	memcpy((LPVOID)&creationTime, (LPVOID)&fileTime, sizeof LARGE_INTEGER);
	m_CreationTime = creationTime.QuadPart;
}

CRefCountedObject::~CRefCountedObject()
{
	delete[] m_lpszName;

	// Destroy the critical section
	DeleteCriticalSection(&m_ReferenceCountSection);
}


void CRefCountedObject::AddRef()
{
	EnterCriticalSection(&m_ReferenceCountSection);
	m_dwRefCount ++;
	LeaveCriticalSection(&m_ReferenceCountSection);
}

void CRefCountedObject::Release()
{
	EnterCriticalSection(&m_ReferenceCountSection);
	DWORD dwCount = --m_dwRefCount;
	LeaveCriticalSection(&m_ReferenceCountSection);

	if( dwCount == 0)
		delete this;
}

LPCWSTR CRefCountedObject::GetName()
{
	return m_lpszName;
}

void CRefCountedObject::SetName(LPCWSTR lpszName)
{
	delete[] m_lpszName;
	if(lpszName)
	{
		m_lpszName = new WCHAR[wcslen(lpszName) + 1];
		wcscpy(m_lpszName, lpszName);
	}
	else
		m_lpszName = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\sources.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################


WMIPRECOMPSHARED=1
!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETNAME=dsprov

TARGETPATH=obj
TARGETTYPE=DYNLINK

# The TARGETLIBS macro specifies additional libraries to link against your target
# image. Each library path specification should contain an asterisk (*)
# where the machine-specific subdirectory name should go.
TARGETLIBS= \
    $(FRAMEWORK_EXPT_LIB) \
	$(FRAMEWORK_THRD_LIB) \
	$(UTILLIB_LIB) \
	$(WMIIDL_LIB) \
	$(STDLIBRARY_LIB) \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\uuid.lib \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\activeds.lib \
	$(SDK_LIB_PATH)\adsiid.lib   \
    $(SDK_LIB_PATH)\vccomsup.lib \
	$(SDK_LIB_PATH)\advapi32.lib

# The INCLUDES variable specifies any include paths that are specific to
# this source directory. Separate multiple paths with single
# semicolons. Relative path specifications are okay.
INCLUDES=$(INCLUDES); \
	$(WMIIDL_INC); \
	$(STDLIBRARY_INC); \
	$(UTILLIB_INC); \
	$(FRAMEWORK_THRD_INC); \
	$(FRAMEWORK_EXPT_INC);

# The developer defines the SOURCES macro. It contains a list of all the
# source files for this component. Specify each source file on a separate
# line using the line-continuation character. This minimizes merge
# conflicts if two developers are adding source files to the same component.
SOURCES=\
	..\maindll.cpp	\
	..\adsiclas.cpp	\
	..\adsiprop.cpp	\
	..\adsiinst.cpp	\
	..\wbemhelp.cpp	\
	..\ldaphelp.cpp	\
	..\refcount.cpp	\
	..\queryconv.cpp	\
	..\tree.cpp		\
	..\clsname.cpp	\
	..\classfac.cpp	\
	..\assocprov.cpp	\
	..\classpro.cpp	\
	..\clsproi.cpp	\
	..\ldapprov.cpp	\
	..\ldapproi.cpp	\
	..\wbemcach.cpp	\
	..\ldapcach.cpp	\
	..\instfac.cpp	\
	..\instprov.cpp	\
	..\instproi.cpp	\
	..\dsprov.rc	


# Next, specify options for the compiler using C_DEFINES. 
C_DEFINES=$(C_DEFINES)  
USER_C_FLAGS=/EHa
USE_MSVCRT=1
DLLENTRY=_DllMainCRTStartup
DLLDEF=$(O)\dsprov.def
USE_NATIVE_EH=1

#NO_OPTIM=1
#NO_RTTI=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\tree.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include <precomp.h>


CTreeElement :: CTreeElement(LPCWSTR lpszHashedName, CRefCountedObject *pObject)
{
	m_lpszHashedName = new WCHAR[wcslen(lpszHashedName) + 1];
	wcscpy(m_lpszHashedName, lpszHashedName);

	m_pObject = pObject;
	m_pObject->AddRef();
	m_pLeft = NULL;
	m_pRight = NULL;
}

CTreeElement :: ~CTreeElement()
{
	delete [] m_lpszHashedName;
	m_pObject->Release();
}

LPCWSTR CTreeElement :: GetHashedName() const
{
	return m_lpszHashedName;
}

CRefCountedObject *CTreeElement :: GetObject() const
{
	m_pObject->AddRef();
	return m_pObject;
}

CTreeElement *CTreeElement :: GetRight() const
{
	return m_pRight;
}

CTreeElement *CTreeElement :: GetLeft() const
{
	return m_pLeft;
}

void CTreeElement :: SetRight(CTreeElement *pNext)
{
	m_pRight = pNext;
}

void CTreeElement :: SetLeft(CTreeElement *pNext)
{
	m_pLeft = pNext;
}

CObjectTree :: CObjectTree()
{
	// Initialize the critical section 
	InitializeCriticalSection(&m_ModificationSection);

	m_dwNumElements = 0;
	m_pHead = NULL;

}

CObjectTree :: ~CObjectTree()
{
	// Destroy the data
	DeleteTree();

	// Destroy the critical section
	DeleteCriticalSection(&m_ModificationSection);

}

void CObjectTree :: DeleteTree()
{
	EnterCriticalSection(&m_ModificationSection);
	if(m_pHead)
		DeleteSubTree(m_pHead);
	m_dwNumElements = 0;
	LeaveCriticalSection(&m_ModificationSection);
}


void CObjectTree :: DeleteSubTree(CTreeElement *pRoot)
{
	if(pRoot->GetLeft())
		DeleteSubTree(pRoot->GetLeft());
	if(pRoot->GetRight())
		DeleteSubTree(pRoot->GetRight());
	delete pRoot;
}

BOOLEAN CObjectTree :: AddElement(LPCWSTR lpszHashedName, CRefCountedObject *pObject)
{
	BOOLEAN retVal = TRUE;

	EnterCriticalSection(&m_ModificationSection);
	CTreeElement *pCurrent = m_pHead;
	CTreeElement *pParent = NULL;
	int iCompare;
	// Locate the position where the new element is to be inserted
	while(pCurrent)
	{
		iCompare = _wcsicmp(lpszHashedName, pCurrent->GetHashedName());
		if(iCompare == 0)
		{
			retVal = FALSE; // The element already exists
			break;
		}
		else if(iCompare > 0)
		{
			pParent = pCurrent;
			pCurrent = pCurrent->GetRight();
		}
		else
		{
			pParent = pCurrent;
			pCurrent = pCurrent->GetLeft();
		}
	}

	// Create the new element at the appropriate position
	if(retVal == TRUE && pParent)
	{
		iCompare = _wcsicmp(lpszHashedName, pParent->GetHashedName());
		if(iCompare == 0)
			retVal = FALSE;
		else if(iCompare > 0)
		{
			retVal = TRUE;
			pParent->SetRight(new CTreeElement(lpszHashedName, pObject));
		}
		else
		{
			retVal = TRUE;
			pParent->SetLeft(new CTreeElement(lpszHashedName, pObject));
		}
	}
	else if (retVal == TRUE)
	{
		m_pHead = new CTreeElement(lpszHashedName, pObject);
		retVal =  TRUE;
	}
	// Increment the object count if the insertion was successful
	if(retVal)
		m_dwNumElements ++;

	LeaveCriticalSection(&m_ModificationSection);
	return retVal;
}

BOOLEAN CObjectTree :: DeleteElement(LPCWSTR lpszHashedName)
{
	BOOLEAN retVal = FALSE;
	int iDirection = 0; // 0 indicates Unknown, 1 indicates LEFT and 2 indicates RIGHT
	EnterCriticalSection(&m_ModificationSection);
	if(m_pHead == NULL)
		retVal = FALSE;
	else
	{
		// Find the node to be deleted and its parent
		CTreeElement *pParent = NULL;
		CTreeElement *pCurrent = m_pHead;
		int iCompare;
		while(pCurrent)
		{
			iCompare = _wcsicmp(lpszHashedName, pCurrent->GetHashedName());
			if(iCompare == 0)
				break;
			else if(iCompare < 0)
			{
				iDirection = 1;
				pParent = pCurrent;
				pCurrent = pCurrent->GetLeft();
			}
			else
			{
				iDirection = 2;
				pParent = pCurrent;
				pCurrent = pCurrent->GetRight();
			}
		}

		if(!pCurrent) 
			// The element was not found
			retVal = FALSE;
		else
		{
			CTreeElement *pCutPart = NULL;

			// If its left child is null, attach the right subtree to parent
			if(pCurrent->GetLeft() == NULL)
				pCutPart = pCurrent->GetRight();
			// If its right child is null, attach the left subtree to parent
			else if(pCurrent->GetRight() == NULL)
				pCutPart = pCurrent->GetLeft();
			else // We need to find the inorder successor
			{
				CTreeElement *pInorderSuccessor = pCurrent->GetRight();
				if(pInorderSuccessor->GetLeft() == NULL)
				{
					pInorderSuccessor->SetLeft(pCurrent->GetLeft());
					pCutPart = pInorderSuccessor;
				}
				else
				{
					CTreeElement *pPredecessor = pCurrent->GetRight();
					pInorderSuccessor = pPredecessor->GetLeft();
					while(pInorderSuccessor->GetLeft())
					{
						pPredecessor = pInorderSuccessor;
						pInorderSuccessor = pPredecessor->GetLeft();
					}
					pPredecessor->SetLeft(pInorderSuccessor->GetRight());
					pInorderSuccessor->SetLeft(pCurrent->GetLeft());
					pInorderSuccessor->SetRight(pCurrent->GetRight());
					pCutPart = pInorderSuccessor;
				}
			}

			if(iDirection == 0)
				m_pHead = pCutPart;
			else if (iDirection == 1)
				pParent->SetLeft(pCutPart);
			else
				pParent->SetRight(pCutPart);

			delete pCurrent;
			retVal = TRUE;

		}
	}
	// Decrement the count of items in the tree
	if(retVal)
		m_dwNumElements --;

	LeaveCriticalSection(&m_ModificationSection);

	return retVal;
}


CRefCountedObject * CObjectTree :: GetElement(LPCWSTR lpszHashedName)
{
	EnterCriticalSection(&m_ModificationSection);
	CTreeElement *pCurrent = m_pHead;
	CRefCountedObject *pRetVal = NULL;

	int iCompare;
	while(pCurrent)
	{
		iCompare = _wcsicmp(lpszHashedName, pCurrent->GetHashedName());
		if(iCompare == 0)
		{
			pRetVal = pCurrent->GetObject();
			break;
		}
		else if (iCompare > 0) 
			pCurrent = pCurrent->GetRight();
		else 
			pCurrent = pCurrent->GetLeft();
	}
	LeaveCriticalSection(&m_ModificationSection);
	return pRetVal;
}

BOOLEAN CObjectTree :: DeleteLeastRecentlyAccessedElement()
{
	BOOLEAN retVal = FALSE;
	EnterCriticalSection(&m_ModificationSection);
	if(m_pHead)
	{
		CRefCountedObject *pOldestElement = m_pHead->GetObject();
		CRefCountedObject *pLeftOldestElement = GetLeastRecentlyAccessedElementRecursive(m_pHead->GetLeft());
		CRefCountedObject *pRightOldestElement = GetLeastRecentlyAccessedElementRecursive(m_pHead->GetRight());

		if (pLeftOldestElement)
		{
			if(pLeftOldestElement->GetLastAccessTime() < pOldestElement->GetLastAccessTime())
			{
				pOldestElement->Release();
				pOldestElement = pLeftOldestElement;
			}
			else
				pLeftOldestElement->Release();
		}

		if (pRightOldestElement)
		{
			if(pRightOldestElement->GetLastAccessTime() < pOldestElement->GetLastAccessTime())
			{
				pOldestElement->Release();
				pOldestElement = pRightOldestElement;
			}
			else
				pRightOldestElement->Release();
		}

		retVal = DeleteElement(pOldestElement->GetName());
		pOldestElement->Release();
	}
	LeaveCriticalSection(&m_ModificationSection);
	return retVal;
}

CRefCountedObject * CObjectTree :: GetLeastRecentlyAccessedElementRecursive(CTreeElement *pElement)
{
	CRefCountedObject *pObject = NULL;
	if(pElement)
	{
		pObject = pElement->GetObject();
		CRefCountedObject *pLeftObject = GetLeastRecentlyAccessedElementRecursive(pElement->GetLeft());
		if(pLeftObject)
		{
			if(pLeftObject->GetCreationTime() < pObject->GetCreationTime())
			{
				pObject->Release();
				pObject = pLeftObject;
			}
			else
				pLeftObject->Release();
		}

		CRefCountedObject *pRightObject = GetLeastRecentlyAccessedElementRecursive(pElement->GetRight());
		if(pRightObject)
		{
			if (pRightObject->GetCreationTime() < pObject->GetCreationTime())
			{
				pObject->Release();
				pObject = pRightObject;
			}
			else
				pRightObject->Release();
		}

	}

	return pObject;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\tree.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#ifndef OBJECT_TREE_H
#define OBJECT_TREE_H


class CTreeElement
{
public:
	CTreeElement(LPCWSTR lpszHashedName, CRefCountedObject *pObject);
	~CTreeElement();

	LPCWSTR GetHashedName() const;
	CRefCountedObject *GetObject() const;
	CTreeElement *GetLeft() const;
	CTreeElement *GetRight() const;

	void SetLeft(CTreeElement *pNext);
	void SetRight(CTreeElement *pNext);
private:
	LPWSTR m_lpszHashedName;
	CRefCountedObject *m_pObject;
	CTreeElement *m_pLeft;
	CTreeElement *m_pRight;
};

class CObjectTree
{

public:
	CObjectTree();
	~CObjectTree();

	BOOLEAN AddElement(LPCWSTR lpszHashedName, CRefCountedObject *pObject);
	BOOLEAN DeleteElement(LPCWSTR lpszHashedName);
	BOOLEAN DeleteLeastRecentlyAccessedElement();
	CRefCountedObject *GetElement(LPCWSTR lpszHashedName);
	void DeleteTree();
	DWORD GetNumberOfElements() const
	{
		return m_dwNumElements;
	}

private:

	CTreeElement *m_pHead;

	// The number of elements in the tree currently
	DWORD m_dwNumElements;

	// A critical section object for synchronizing modifications
	CRITICAL_SECTION m_ModificationSection;

	// Private fucntions for recursive calls
	void DeleteSubTree(CTreeElement *pRoot);
	
	CRefCountedObject * GetLeastRecentlyAccessedElementRecursive(CTreeElement *pElement);

};	

#endif /* OBJECT_TREE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\refcount.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:refcount.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for a basic reference counted object, that
//	also stores a timestamp (in 100-nanosecond intervals since January 1, 1601. This
//	is copatible with the definition of the Win32 FILETIME struture)
//
//***************************************************************************

#ifndef REFCOUNTED_OBJECT_H
#define REFCOUNTED_OBJECT_H


class CRefCountedObject
{

public:

	CRefCountedObject();
	CRefCountedObject(LPCWSTR lpszName);
	virtual ~CRefCountedObject();

	LPCWSTR GetName();
	void SetName(LPCWSTR lpszName);
	void AddRef();
	void Release();
	// Returns the time of creation 
	__int64 GetCreationTime()
	{
		return m_CreationTime;
	}

	// Returns the last time of access 
	__int64 GetLastAccessTime()
	{
		return m_LastAccessTime;
	}
	// Sets the last time of access 
	void SetLastAccessTime(__int64 lastAccessTime)
	{
		m_LastAccessTime = lastAccessTime;
	}


private:
	// A critical section object for synchronizing modifications to refcount
	CRITICAL_SECTION m_ReferenceCountSection;

	unsigned m_dwRefCount;
	LPWSTR m_lpszName;
	__int64 m_CreationTime; 
	__int64 m_LastAccessTime; 

	
};

#endif /* REFCOUNTED_OBJECT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\wbemcach.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:wbemcach.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Cache for WBEM Class objects 
//
//***************************************************************************

#ifndef WBEM_CACHE_H
#define WBEM_CACHE_H

// This encapsulates a WBEM Class object
class CWbemClass : public CRefCountedObject
{
private:
	IWbemClassObject *m_pWbemClass;

public:
	static DWORD dwCWbemClassCount;

	CWbemClass(LPCWSTR pszWbemClassName, IWbemClassObject *pWbemClass)
		: CRefCountedObject(pszWbemClassName)
	{
		dwCWbemClassCount++;
		m_pWbemClass = pWbemClass;
		m_pWbemClass->AddRef();
	}
	~CWbemClass()
	{
		dwCWbemClassCount--;
		m_pWbemClass->Release();
	}

	IWbemClassObject *GetWbemClass()
	{
		m_pWbemClass->AddRef();
		return m_pWbemClass;
	}

};

// This encapsulates subclass enumeration (deep) of a WBEM class
class CEnumInfo : public CRefCountedObject
{
private:
	CNamesList *m_pClassNameList;

public:
	static DWORD dwCEnumInfoCount;
	CEnumInfo(LPCWSTR pszWbemSuperClassName, CNamesList *pClassNameList)
		: CRefCountedObject(pszWbemSuperClassName)
	{
		dwCEnumInfoCount++;
		m_pClassNameList = pClassNameList;
	}
	~CEnumInfo()
	{
		dwCEnumInfoCount--;
		delete m_pClassNameList;
	}

	CNamesList *GetSubClassNames() 
	{
		return m_pClassNameList;
	}
};

class CWbemCache
{
private:
	// The storage for cached classes
	CObjectTree m_objectTree;
	// The storage for enumeration information
	CObjectTree m_EnumTree;

	// Cache configuration parameters
	static const __int64 MAX_CACHE_AGE; // In seconds
	static const DWORD MAX_CACHE_SIZE;
	static DWORD dwWBEMCacheCount;

public:
	//***************************************************************************
	//
	// CWbemCache::CLDAPCache
	//
	// Purpose : Constructor. Creates an empty cache
	//
	// Parameters: 
	//***************************************************************************
	CWbemCache();

	//***************************************************************************
	//
	// CWbemCache::GetClass
	//
	// Purpose : Retreives the IDirectory interface of an LDAP Class
	//
	// Parameters: 
	//	lpszClassName : The WBEM name of the Class to be retreived. 
	//	ppWbemClass : The address of the pointer where the CWbemClass object will be placed
	//
	//	Return value:
	//		The COM value representing the return status. The user should release the WBEM cclass
	// when done.
	//		
	//***************************************************************************
	HRESULT GetClass(LPCWSTR lpszWbemClassName, CWbemClass **ppWbemClass );

	//***************************************************************************
	//
	// CWbemCache::AddClass
	//
	// Purpose : Adds the CWbemClass object to the cache
	//
	// Parameters: 
	//	ppWbemClass : The CWbemClass pointer of the object to be added
	//
	//	Return value:
	//		The COM value representing the return status. 
	// when done.
	//		
	//***************************************************************************
	HRESULT AddClass(CWbemClass *pWbemClass );

	//***************************************************************************
	//
	// CEnumCache::GetEnumInfo
	//
	// Purpose : Retreives the CEnumInfo object of a WBEM class
	//
	// Parameters: 
	//	lpszWbemClassName : The WBEM name of the Class to be retreived. 
	//	ppEnumInfo : The address of the pointer where the CEnumInfo object will be placed
	//
	//	Return value:
	//		The COM value representing the return status. The user should release the WBEM cclass
	// when done.
	//		
	//***************************************************************************
	HRESULT GetEnumInfo(LPCWSTR lpszWbemClassName, CEnumInfo **ppEnumInfo );

	//***************************************************************************
	//
	// CEnumCache::AddEnumInfo
	//
	// Purpose : Adds the CEnumInfo object to the cache
	//
	// Parameters: 
	//	ppWbemClass : The CEnumInfo pointer of the object to be added
	//
	//	Return value:
	//		The COM value representing the return status. 
	// when done.
	//		
	//***************************************************************************
	HRESULT AddEnumInfo(CEnumInfo *pEnumInfo);


};

#endif /* WBEM_CACHE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\wbemcach.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include <precomp.h>


// Initialize the statics
const __int64 CWbemCache :: MAX_CACHE_AGE = 60*60*20; // In seconds, 4 Hours
const DWORD CWbemCache :: MAX_CACHE_SIZE = 500;

DWORD CWbemCache:: dwWBEMCacheCount = 0;
DWORD CEnumInfo:: dwCEnumInfoCount = 0;
DWORD CWbemClass:: dwCWbemClassCount = 0;

//***************************************************************************
//
// CWbemCache::CWbemCache
//
// Purpose : Constructor. Creates an empty cache
//
// Parameters: 
//***************************************************************************

CWbemCache :: CWbemCache()
{
	dwWBEMCacheCount ++;
}

//***************************************************************************
//
// CWbemCache::GetClass
//
// Purpose : Retreives the CWbemClass object, if present in the cache. Otherwise returns NULL
//
// Parameters: 
//	lpszClassName : The WBEM name of the Class to be retreived. 
//	ppWbemClass : The address of the pointer where the CWbemClass object will be placed
//
//	Return value:
//		The COM value representing the return status. The user should release the WBEM cclass
// when done.
//		
//***************************************************************************
HRESULT CWbemCache :: GetClass(LPCWSTR lpszWbemClassName, CWbemClass **ppWbemClass )
{
#ifdef NO_WBEM_CACHE
	return E_FAIL;
#else
	if(*ppWbemClass = (CWbemClass *)m_objectTree.GetElement(lpszWbemClassName))
	{
		// Get the current time
		FILETIME fileTime;
		GetSystemTimeAsFileTime(&fileTime);
		LARGE_INTEGER currentTime;
		memcpy((LPVOID)&currentTime, (LPVOID)&fileTime, sizeof LARGE_INTEGER);

		// The QuadPart is in number of 100s of NanoSeconds.
		// Delete the object if is too old, and return failure
		// timeElapsed is the amount of time in seconds
		__int64 timeElapsed = ( currentTime.QuadPart - (*ppWbemClass)->GetCreationTime());
		timeElapsed = timeElapsed/(__int64)10000000;
		if( timeElapsed	> MAX_CACHE_AGE ) // in Seconds
		{
			(*ppWbemClass)->Release();
			*ppWbemClass = NULL;
			m_objectTree.DeleteElement(lpszWbemClassName);
			g_pLogObject->WriteW( L"CWbemCache :: GetClass() Deleted senile class : %s\r\n", lpszWbemClassName);
			return E_FAIL;
		}

		// Set its last accessed time
		(*ppWbemClass)->SetLastAccessTime(currentTime.QuadPart);

		return S_OK;
	}

	return E_FAIL;
#endif
}

//***************************************************************************
//
// CWbemCache::AddClass
//
// Purpose : Adds the CWbemClass object to the cache
//
// Parameters: 
//	ppWbemClass : The CWbemClass pointer of the object to be added
//
//	Return value:
//		The COM value representing the return status. 
// when done.
//		
//***************************************************************************
HRESULT CWbemCache :: AddClass(CWbemClass *pWbemClass )
{
#ifdef NO_WBEM_CACHE
	return E_FAIL;
#else
	// Delete an element from the tree if its size has reached a limit of 100 nodes
	if(m_objectTree.GetNumberOfElements() >= MAX_CACHE_SIZE)
	{
		if(!m_objectTree.DeleteLeastRecentlyAccessedElement())
			return E_FAIL;
		g_pLogObject->WriteW( L"CWbemCache :: AddClass() Deleted LRU class from cache\r\n");
	}

	// Add the new element
	if(m_objectTree.AddElement(pWbemClass->GetName(), pWbemClass))
	{
		g_pLogObject->WriteW( L"CWbemCache :: AddClass() Added a class %s to cache\r\n", pWbemClass->GetName());
		return S_OK;
	}
	return E_FAIL;
#endif
}

//***************************************************************************
//
// CWbemCache::GetEnumInfo
//
// Purpose : Retreives the CEnumInfo object, if present in the cache. Otherwise returns NULL
//
// Parameters: 
//	lpszClassName : The WBEM name of the Class to be retreived. 
//	ppEnumInfo : The address of the pointer where the CEnumInfo object will be placed
//
//	Return value:
//		The COM value representing the return status. The user should release the EnumInfo object
// when done.
//		
//***************************************************************************
HRESULT CWbemCache :: GetEnumInfo(LPCWSTR lpszWbemClassName, CEnumInfo **ppEnumInfo )
{
#ifdef NO_WBEM_CACHE
	return E_FAIL;
#else
	if(*ppEnumInfo = (CEnumInfo *)m_EnumTree.GetElement(lpszWbemClassName))
	{
		// Get the current time
		FILETIME fileTime;
		GetSystemTimeAsFileTime(&fileTime);
		LARGE_INTEGER currentTime;
		memcpy((LPVOID)&currentTime, (LPVOID)&fileTime, sizeof LARGE_INTEGER);

		// The QuadPart is in number of 100s of NanoSeconds.
		// Delete the object if is too old, and return failure
		// timeElapsed is the amount of time in seconds
		__int64 timeElapsed = ( currentTime.QuadPart - (*ppEnumInfo)->GetCreationTime());
		timeElapsed = timeElapsed/(__int64)10000000;
		if( timeElapsed	> MAX_CACHE_AGE ) // in Seconds
		{
			(*ppEnumInfo)->Release();
			*ppEnumInfo = NULL;
			m_EnumTree.DeleteElement(lpszWbemClassName);
			g_pLogObject->WriteW( L"CEnumCache :: GetClass() Deleted senile EnumInfo : %s\r\n", lpszWbemClassName);
			return E_FAIL;
		}

		// Set its last accessed time
		(*ppEnumInfo)->SetLastAccessTime(currentTime.QuadPart);

		return S_OK;
	}

	return E_FAIL;
#endif
}

//***************************************************************************
//
// CWbemCache::AddEnumInfo
//
// Purpose : Adds the CEnumInfo object to the cache
//
// Parameters: 
//	ppEnumInfo : The CEnumInfo pointer of the object to be added
//
//	Return value:
//		The COM value representing the return status. 
// when done.
//		
//***************************************************************************
HRESULT CWbemCache :: AddEnumInfo(CEnumInfo *pEnumInfo )
{
#ifdef NO_WBEM_CACHE
	return E_FAIL;
#else
	// Delete an element from the tree if its size has reached a limit of 100 nodes
	if(m_EnumTree.GetNumberOfElements() >= MAX_CACHE_SIZE)
	{
		if(!m_EnumTree.DeleteLeastRecentlyAccessedElement())
			return E_FAIL;
		g_pLogObject->WriteW( L"CEnumCache :: AddClass() Deleted LRU class from cache\r\n");
	}

	// Add the new element
	if(m_EnumTree.AddElement(pEnumInfo->GetName(), pEnumInfo))
	{
		g_pLogObject->WriteW( L"CEnumCache :: AddClass() Added a EnumInfo %s to cache\r\n", pEnumInfo->GetName());
		return S_OK;
	}
	return E_FAIL;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\adsitest\leakproj\main.cpp ===
#include <stdio.h>
#include <windows.h>

main()
{
	DWORD i;

	printf("Press akey\n");
	getchar();
	printf("Allocating\n");

	for (int j=0; j<10; j++)  {
		printf("%0x\n", LocalAlloc(LPTR, 2));
	}
	getchar();
	printf("Exiting\n");

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\wbemhelp.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:wbemhelp.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the CWBEMHelper class. This is
//	a class that has many static helper functions pertaining to WBEM
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef WBEM_HELPER_H
#define WBEM_HELPER_H

class CWBEMHelper
{
protected:
	static LPCWSTR EQUALS_QUOTE;
	static LPCWSTR QUOTE;
	static LPCWSTR OBJECT_CATEGORY_EQUALS;
	static LPCWSTR OBJECT_CLASS_EQUALS;
public:

	//***************************************************************************
	//
	// CWBEMHelper::PutBSTRProperty
	//
	// Purpose: Puts a BSTR property
	//
	// Parameters:
	//	pWbemClass : The WBEM class on which the property has to be put
	//	strPropertyName : The name of the property to be put
	//	strPropertyValue : The value of the property to be put
	//	deallocatePropertyValue : whether to deallocate the parameter strPropertyValue before
	//		the function returns
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	static HRESULT PutBSTRProperty(IWbemClassObject *pWbemClass, 
		const BSTR strPropertyName, 
		BSTR strPropertyValue, 
		BOOLEAN deallocatePropertyValue = TRUE);

	//***************************************************************************
	//
	// CWBEMHelper::GetBSTRProperty
	//
	// Purpose: Gets a BSTR property
	//
	// Parameters:
	//	pWbemClass : The WBEM class on which the property has to be gotten
	//	strPropertyName : The name of the property to be gotten
	//	pStrPropertyValue : The address where the value of the property to should be put
	//
	// Return Value: The COM value representing the return status. The user should delete the
	// string allocated when done
	//
	//***************************************************************************
	static HRESULT GetBSTRProperty(IWbemClassObject *pWbemClass, 
		const BSTR strPropertyName, 
		BSTR *pStrPropertyValue);

	//***************************************************************************
	//
	// CWBEMHelper::PutBSTRPropertyT
	//
	// Purpose: Puts a BSTR property
	//
	// Parameters:
	//	pWbemClass : The WBEM class on which the property has to be put
	//	strPropertyName : The name of the property to be put
	//	lpszPropertyValue : The value of the property to be put
	//	deallocatePropertyValue : whether to deallocate the parameter lpszPropertyValue before
	//		the function returns
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	static HRESULT PutBSTRPropertyT(IWbemClassObject *pWbemClass, 
		const BSTR strPropertyName, 
		LPWSTR lpszPropertyValue, 
		BOOLEAN deallocatePropertyValue = TRUE);

	//***************************************************************************
	//
	// CWBEMHelper::GetBSTRPropertyT
	//
	// Purpose: Gets a BSTR property
	//
	// Parameters:
	//	pWbemClass : The WBEM class on which the property has to be put
	//	strPropertyName : The name of the property to be put
	//	lppszPropertyValue : The pointer to LPWSTR where the value of the property will be placed. The user should
	//		delete this once he is done with it.
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	static HRESULT GetBSTRPropertyT(IWbemClassObject *pWbemClass, 
		const BSTR strPropertyName, 
		LPWSTR *lppszPropertyValue);

	//***************************************************************************
	//
	// CWBEMHelper::PutBSTRArrayProperty
	//
	// Purpose: Puts a BSTR Array property
	//
	// Parameters:
	//	pWbemClass : The WBEM class on which the property has to be put
	//	strPropertyName : The name of the property to be put
	//	pStrPropertyValue : The array of BSTRS  that have the values of the property to be put
	//	lCount : The number of elements in the above array
	//	deallocatePropertyValue : whether to deallocate the parameter strPropertyValue before
	//		the function returns
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************	
	static HRESULT PutBSTRArrayProperty(IWbemClassObject *pWbemClass, 
		const BSTR strPropertyName, 
		VARIANT *pVariant);

	//***************************************************************************
	//
	// CWBEMHelper::GetUint8ArrayProperty
	//
	// Purpose: Gets a VT_UI1 Array property
	//
	// Parameters:
	//	pWbemClass : The WBEM class on which the property has to be gotten
	//	strPropertyName : The name of the property 
	//	ppPropertyValuea : The address of a pointer to BYTE  where an array of values will be places
	//	plCount : The address where the count of elements will be placed
	//
	// Return Value: The COM value representing the return status. The user should deallocate the array
	//	returned when done.
	//
	//***************************************************************************	
	static HRESULT GetUint8ArrayProperty(IWbemClassObject *pWbemClass, 
		const BSTR strPropertyName, 
		LPBYTE *ppPropertyValues, 
		ULONG *plCount);


	//***************************************************************************
	//
	// CWBEMHelper :: PutBOOLQualifier
	//
	// Purpose: Puts a BOOLEAN Qualifier
	//
	// Parameters:
	//	pQualifierSet : The Qualifier set on which this qualifier has to be put
	//	strQualifierName : The name of the qualifier to be put
	//	bQualifierValue : The value of the qualifier to be put
	//	lFlavour : The flavour of the qualifer
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	static HRESULT PutBOOLQualifier(IWbemQualifierSet *pQualifierSet, 
		const BSTR strQualifierName, 
		VARIANT_BOOL bQualifierValue,
		LONG lFlavour);

	//***************************************************************************
	//
	// CWBEMHelper :: GetBOOLQualifier
	//
	// Purpose: Gets a BOOLEAN Qualifier
	//
	// Parameters:
	//	pQualifierSet : The Qualifier set on which this qualifier has to be put
	//	strQualifierName : The name of the qualifier to get
	//	bQualifierValue : The value of the qualifier to get
	//	lFlavour : The flavour of the qualifer
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	static HRESULT GetBOOLQualifier(IWbemQualifierSet *pQualifierSet, 
		const BSTR strQualifierName, 
		VARIANT_BOOL *pbQualifierValue,
		LONG *plFlavour);

	//***************************************************************************
	//
	// CWBEMHelper :: PutI4Qualifier
	//
	// Purpose: Puts a VT_I4 Qualifier
	//
	// Parameters:
	//	pQualifierSet : The Qualifier set on which this qualifier has to be put
	//	strQualifierName : The name of the qualifier to be put
	//	lQualifierValue : The value of the qualifier to be put
	//	lFlavour : The flavour of the qualifer
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************	
	static HRESULT PutI4Qualifier(IWbemQualifierSet *pQualifierSet, 
		const BSTR strQualifierName, 
		long lQualifierValue,
		LONG lFlavour);

	//***************************************************************************
	//
	// CWBEMHelper :: PutBSTRQualifier
	//
	// Purpose: Puts a BSTR Qualifier
	//
	// Parameters:
	//	pQualifierSet : The Qualifier set on which this qualifier has to be put
	//	strQualifierName : The name of the qualifier to be put
	//	strQualifierValue : The value of the qualifier to be put
	//	lFlavour : The flavour of the qualifer
	//	deallocateQualifierValue : whether to deallocate the parameter strQualifierValue 
	//	before the function returns
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	static HRESULT PutBSTRQualifier(IWbemQualifierSet *pQualifierSet, 
		const BSTR strQualifierName, 
		BSTR strQualifierValue,
		LONG lFlavour,
		BOOLEAN deallocateQualifierValue = TRUE);

	//***************************************************************************
	//
	// CWBEMHelper :: GetBSTRQualifierT
	//
	// Purpose: Gets a BSTR Qualifier
	//
	// Parameters:
	//	pQualifierSet : The Qualifier set on which this qualifier has to be put
	//	strQualifierName : The name of the qualifier to be put
	//	lppszQualifierValue : The address of the LPWSTR where the qualifier value will be put/
	//		It is the duty of the caller to free this memory when done
	//	plFlavour : The address where the qualifier flavor will be put. This is optional
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	static HRESULT GetBSTRQualifierT(IWbemQualifierSet *pQualifierSet, 
		const BSTR strQualifierName, 
		LPWSTR *lppszQualifierValue,
		LONG *plFlavour);

	//***************************************************************************
	//
	// CWBEMHelper :: PutLONGQualifier
	//
	// Purpose: Puts a LONG Qualifier
	//
	// Parameters:
	//	pQualifierSet : The Qualifier set on which this qualifier has to be put
	//	strQualifierName : The name of the qualifier to be put
	//	lQualifierValue : The value of the qualifier to be put
	//	lFlavour : The flavour of the qualifer
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	static HRESULT PutLONGQualifier(IWbemQualifierSet *pQualifierSet, 
		const BSTR strQualifierName, 
		LONG lQualifierValue,
		LONG lFlavour);

	//***************************************************************************
	//
	// CWBEMHelper :: PutUint8ArrayQualifier
	//
	// Purpose: Puts a Uint8 array  Qualifier
	//
	// Parameters:
	//	pQualifierSet : The Qualifier set on which this qualifier has to be put
	//	strQualifierName : The name of the qualifier to be put
	//	lpQualifierValue : The value of the qualifier to be put. An array of BYTEs
	//	dwLenght : The number of elements in the above array
	//	lFlavour : The flavour of the qualifer
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	static HRESULT PutUint8ArrayQualifier(IWbemQualifierSet *pQualifierSet, 
		const BSTR strQualifierName, 
		LPBYTE lpQualifierValue,
		DWORD dwLength,
		LONG lFlavour);

	//***************************************************************************
	//
	// CWBEMHelper::GetADSIPathFromObjectPath
	//
	// Purpose: Gets the ADSI Path from an object ref of a WBEM object
	//
	// Parameters :
	//	pszObjectRef : The object ref to a WBEM instance
	//
	// Return Value : The ADSI Path in the key of the object ref. The user should delete this
	//	when done
	//
	//***************************************************************************
	static LPWSTR GetADSIPathFromObjectPath(LPCWSTR pszObjectRef);

	//***************************************************************************
	//
	// CWBEMHelper::GetObjectRefFromADSIPath
	//
	// Purpose: Gets the object ref of a WBEM object from its ADSI path
	//
	// Parameters :
	//	pszADSIPath : The ADSI path to an ADSI instance
	//	pszWbemClassName : The WBEM class name of the instance
	//
	// Return Value : The WBEM object ref of the ADSI instance. The user should delete this
	//	when done
	//
	//***************************************************************************
	static BSTR GetObjectRefFromADSIPath(LPCWSTR pszADSIPath, LPCWSTR pszWBEMClassName);

	static HRESULT FormulateInstanceQuery(IWbemServices *pServices, IWbemContext *pContext, BSTR strClass, IWbemClassObject *pWbemClass, LPWSTR pszObjectCategory, BSTR strClassQualifier, BSTR strCategoryQualifier);
	static HRESULT AddSingleCategory(LPWSTR pszObjectCategory, DWORD *pdwOutput, IWbemClassObject *pNextObject, BSTR strClassQualifier, BSTR strCategoryQualifier);

	static BOOLEAN IsPresentInBstrList(BSTR *pstrProperyNames, DWORD dwNumPropertyNames, BSTR strPropertyName);

};

#endif /* WBEM_HELPER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\wbemhelp.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:wbemhelp.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the implementation the CWBEMHelper class. This is
//	a class that has many static helper functions pertaining to WBEM
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#include "precomp.h"

LPCWSTR CWBEMHelper :: EQUALS_QUOTE					= L"=\"";
LPCWSTR CWBEMHelper :: QUOTE						= L"\"";
LPCWSTR CWBEMHelper :: OBJECT_CATEGORY_EQUALS		= L"objectCategory=";
LPCWSTR CWBEMHelper :: OBJECT_CLASS_EQUALS			= L"objectClass=";

//***************************************************************************
//
// CWBEMHelper::PutBSTRProperty
//
// Purpose: Puts a BSTR property
//
// Parameters:
//	pWbemClass : The WBEM class on which the property has to be put
//	strPropertyName : The name of the property to be put
//	strPropertyValue : The value of the property to be put
//	deallocatePropertyValue : whether to deallocate the parameter strPropertyValue before
//		the function returns
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: PutBSTRProperty(IWbemClassObject *pWbemClass, 
									   const BSTR strPropertyName, 
									   BSTR strPropertyValue, 
									   BOOLEAN deallocatePropertyValue)
{
	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_BSTR;
	variant.bstrVal = strPropertyValue;

	HRESULT result = pWbemClass->Put(strPropertyName, 0, &variant, 0);
	if (!deallocatePropertyValue)
		variant.bstrVal = NULL;

	VariantClear(&variant);
	return result;
}

//***************************************************************************
//
// CWBEMHelper::GetBSTRProperty
//
// Purpose: Gets a BSTR property
//
// Parameters:
//	pWbemClass : The WBEM class on which the property has to be gotten
//	strPropertyName : The name of the property to be gotten
//	pStrPropertyValue : The address where the value of the property to should be put
//
// Return Value: The COM value representing the return status. The user should delete the
// string allocated when done
//
//***************************************************************************
HRESULT CWBEMHelper :: GetBSTRProperty(IWbemClassObject *pWbemClass, 
	const BSTR strPropertyName, 
	BSTR *pStrPropertyValue)
{
	VARIANT variant;
	VariantInit(&variant);
	HRESULT result = pWbemClass->Get(strPropertyName, 0, &variant, NULL, NULL);
	if(variant.vt == VT_BSTR && variant.bstrVal)
		*pStrPropertyValue = SysAllocString(variant.bstrVal);
	else
		*pStrPropertyValue = NULL;
	VariantClear(&variant);
	return result;
}

//***************************************************************************
//
// CWBEMHelper::PutBSTRPropertyT
//
// Purpose: Puts a BSTR property
//
// Parameters:
//	pWbemClass : The WBEM class on which the property has to be put
//	strPropertyName : The name of the property to be put
//	lpszPropertyValue : The value of the property to be put
//	deallocatePropertyValue : whether to deallocate the parameter lpszPropertyValue before
//		the function returns
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: PutBSTRPropertyT(IWbemClassObject *pWbemClass, 
	const BSTR strPropertyName, 
	LPWSTR lpszPropertyValue, 
	BOOLEAN deallocatePropertyValue)
{
	BSTR strPropertyValue = SysAllocString(lpszPropertyValue);
	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_BSTR;
	variant.bstrVal = strPropertyValue;

	HRESULT result = pWbemClass->Put(strPropertyName, 0, &variant, 0);
	if (deallocatePropertyValue)
		delete[] lpszPropertyValue;

	VariantClear(&variant);
	return result;
}

//***************************************************************************
//
// CWBEMHelper::GetBSTRPropertyT
//
// Purpose: Gets a BSTR property
//
// Parameters:
//	pWbemClass : The WBEM class on which the property has to be put
//	strPropertyName : The name of the property to be put
//	lppszPropertyValue : The pointer to LPWSTR where the value of the property will be placed. The user should
//		delete this once he is done with it.
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: GetBSTRPropertyT(IWbemClassObject *pWbemClass, 
	const BSTR strPropertyName, 
	LPWSTR *lppszPropertyValue)
{
	VARIANT variant;
	VariantInit(&variant);
	HRESULT result = pWbemClass->Get(strPropertyName, 0, &variant, NULL, NULL);
	if(SUCCEEDED(result))
	{
		*lppszPropertyValue = new WCHAR[wcslen(variant.bstrVal) + 1];
		wcscpy(*lppszPropertyValue, variant.bstrVal);
	}
	VariantClear(&variant);
	return result;
}

//***************************************************************************
//
// CWBEMHelper::PutBSTRArrayProperty
//
// Purpose: Puts a BSTR Array property
//
// Parameters:
//	pWbemClass : The WBEM class on which the property has to be put
//	strPropertyName : The name of the property to be put
//	pStrPropertyValue : The array of BSTRS  that have the values of the property to be put
//	lCount : The number of elements in the above array
//	deallocatePropertyValue : whether to deallocate the parameter strPropertyValue before
//		the function returns
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: PutBSTRArrayProperty(IWbemClassObject *pWbemClass, 
											const BSTR strPropertyName, 
											VARIANT *pInputVariant)
{
	// THe input is a safe array of variants of type VT_BSTR
	// The output is a safe array for VT_BSTRs

    LONG lstart, lend;
    SAFEARRAY *inputSafeArray = pInputVariant->parray;
 
    // Get the lower and upper bound of the inpute safe array
    SafeArrayGetLBound( inputSafeArray, 1, &lstart );
    SafeArrayGetUBound( inputSafeArray, 1, &lend );
 

	// Create the output SAFEARRAY
	SAFEARRAY *outputSafeArray = NULL;
	SAFEARRAYBOUND safeArrayBounds [ 1 ] ;
	safeArrayBounds[0].lLbound = lstart ;
	safeArrayBounds[0].cElements = lend - lstart + 1 ;
	outputSafeArray = SafeArrayCreate (VT_BSTR, 1, safeArrayBounds);

	// Fill it
    VARIANT inputItem;
	VariantInit(&inputItem);
	HRESULT result = S_OK;
	bool bError = false;
    for ( long idx=lstart; !bError && (idx <=lend); idx++ )
    {
	    VariantInit(&inputItem);
        SafeArrayGetElement( inputSafeArray, &idx, &inputItem );
		if(FAILED(result = SafeArrayPutElement(outputSafeArray, &idx, inputItem.bstrVal)))
			bError = true;
        VariantClear(&inputItem);
    }
 

	// Create the variant
	if(SUCCEEDED(result))
	{
		VARIANT outputVariant;
		VariantInit(&outputVariant);
		outputVariant.vt = VT_ARRAY | VT_BSTR ;
		outputVariant.parray = outputSafeArray ; 		
		result = pWbemClass->Put (strPropertyName, 0, &outputVariant, 0);
		VariantClear(&outputVariant);
	}
	else
		SafeArrayDestroy(outputSafeArray);
	return result;
}


//***************************************************************************
//
// CWBEMHelper :: PutBOOLQualifier
//
// Purpose: Puts a BOOLEAN Qualifier
//
// Parameters:
//	pQualifierSet : The Qualifier set on which this qualifier has to be put
//	strQualifierName : The name of the qualifier to be put
//	bQualifierValue : The value of the qualifier to be put
//	lFlavour : The flavour of the qualifer
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: PutBOOLQualifier(IWbemQualifierSet *pQualifierSet, 
	const BSTR strQualifierName, 
	VARIANT_BOOL bQualifierValue,
	LONG lFlavour)
{

	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_BOOL;
	variant.boolVal = bQualifierValue;
	HRESULT result = pQualifierSet->Put(strQualifierName, &variant, lFlavour);
	VariantClear(&variant);
	return result;
}

//***************************************************************************
//
// CWBEMHelper :: GetBOOLQualifier
//
// Purpose: Gets a BOOLEAN Qualifier
//
// Parameters:
//	pQualifierSet : The Qualifier set on which this qualifier has to be put
//	strQualifierName : The name of the qualifier to get
//	bQualifierValue : The value of the qualifier to get
//	lFlavour : The flavour of the qualifer
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: GetBOOLQualifier(IWbemQualifierSet *pQualifierSet, 
	const BSTR strQualifierName, 
	VARIANT_BOOL *pbQualifierValue,
	LONG *plFlavour)
{
	VARIANT variant;
	VariantInit(&variant);
	HRESULT result = pQualifierSet->Get(strQualifierName, 0, &variant, plFlavour);
	if(SUCCEEDED(result))
		*pbQualifierValue = variant.boolVal;
	VariantClear(&variant);
	return result;
}


//***************************************************************************
//
// CWBEMHelper :: PutI4Qualifier
//
// Purpose: Puts a VT_I4 Qualifier
//
// Parameters:
//	pQualifierSet : The Qualifier set on which this qualifier has to be put
//	strQualifierName : The name of the qualifier to be put
//	lQualifierValue : The value of the qualifier to be put
//	lFlavour : The flavour of the qualifer
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: PutI4Qualifier(IWbemQualifierSet *pQualifierSet, 
	const BSTR strQualifierName, 
	long lQualifierValue,
	LONG lFlavour)
{

	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_I4;
	variant.lVal = lQualifierValue;
	HRESULT result = pQualifierSet->Put(strQualifierName, &variant, lFlavour);
	VariantClear(&variant);
	return result;
}


//***************************************************************************
//
// CWBEMHelper :: PutLONGQualifier
//
// Purpose: Puts a LONG Qualifier
//
// Parameters:
//	pQualifierSet : The Qualifier set on which this qualifier has to be put
//	strQualifierName : The name of the qualifier to be put
//	lQualifierValue : The value of the qualifier to be put
//	lFlavour : The flavour of the qualifer
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: PutLONGQualifier(IWbemQualifierSet *pQualifierSet, 
	const BSTR strQualifierName, 
	LONG lQualifierValue,
	LONG lFlavour)
{

	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_I4;
	variant.lVal = lQualifierValue;
	HRESULT result = pQualifierSet->Put(strQualifierName, &variant, lFlavour);
	VariantClear(&variant);
	return result;
}

//***************************************************************************
//
// CWBEMHelper :: PutBSTRQualifier
//
// Purpose: Puts a BSTR Qualifier
//
// Parameters:
//	pQualifierSet : The Qualifier set on which this qualifier has to be put
//	strQualifierName : The name of the qualifier to be put
//	strQualifierValue : The value of the qualifier to be put
//	lFlavour : The flavour of the qualifer
//	deallocateQualifierValue : whether to deallocate the parameter strQualifierValue 
//	before the function returns
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: PutBSTRQualifier(IWbemQualifierSet *pQualifierSet, 
	const BSTR strQualifierName, 
	BSTR strQualifierValue,
	LONG lFlavour,
	BOOLEAN deallocateQualifierValue)
{
	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_BSTR;
	variant.bstrVal = strQualifierValue;
	HRESULT result = pQualifierSet->Put(strQualifierName, &variant, lFlavour);
	if(!deallocateQualifierValue)
		variant.bstrVal = NULL;
	VariantClear(&variant);
	return result;
}

//***************************************************************************
//
// CWBEMHelper :: GetBSTRQualifierT
//
// Purpose: Gets a BSTR Qualifier
//
// Parameters:
//	pQualifierSet : The Qualifier set on which this qualifier has to be put
//	strQualifierName : The name of the qualifier to be put
//	lppszQualifierValue : The address of the LPWSTR where the qualifier value will be put/
//		It is the duty of the caller to free this memory when done
//	plFlavour : The address where the qualifier flavor will be put. This is optional
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: GetBSTRQualifierT(
	IWbemQualifierSet *pQualifierSet, 
	const BSTR strQualifierName, 
	LPWSTR *lppszQualifierValue,
	LONG *plFlavour)
{
	VARIANT variant;
	VariantInit(&variant);
	HRESULT result = pQualifierSet->Get(strQualifierName, 0, &variant, plFlavour);
	if(SUCCEEDED(result))
	{
		if(variant.vt == VT_BSTR && variant.bstrVal)
		{
			*lppszQualifierValue = NULL;
			if(*lppszQualifierValue = new WCHAR [ wcslen(variant.bstrVal) + 1])
				wcscpy(*lppszQualifierValue, variant.bstrVal);
			else
				result = E_OUTOFMEMORY;
		}
		else
			result = E_FAIL;
	}
	VariantClear(&variant);
	return result;
}

//***************************************************************************
//
// CWBEMHelper :: PutUint8ArrayQualifier
//
// Purpose: Puts a Uint8 array  Qualifier
//
// Parameters:
//	pQualifierSet : The Qualifier set on which this qualifier has to be put
//	strQualifierName : The name of the qualifier to be put
//	lpQualifierValue : The value of the qualifier to be put. An array of BYTEs
//	dwLenght : The number of elements in the above array
//	lFlavour : The flavour of the qualifer
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: PutUint8ArrayQualifier(IWbemQualifierSet *pQualifierSet, 
	const BSTR strQualifierName, 
	LPBYTE lpQualifierValue,
	DWORD dwLength,
	LONG lFlavour)
{

	// Create the variant
	VARIANT variant;
	VariantInit(&variant);

	// Create the SAFEARRAY
	SAFEARRAY *safeArray ;
	SAFEARRAYBOUND safeArrayBounds [ 1 ] ;
	safeArrayBounds[0].lLbound = 0 ;
	safeArrayBounds[0].cElements = dwLength ;
	safeArray = SafeArrayCreate (VT_I4, 1, safeArrayBounds);

	// Fill it
	UINT temp;
	HRESULT result = S_OK;
	bool bError = false;
	for (LONG index = 0; !bError && (index<(LONG)dwLength); index++)
	{
		temp = (UINT)lpQualifierValue[index];
		if(FAILED(result = SafeArrayPutElement(safeArray , &index,  (LPVOID)&temp)))
			bError = true;
	}

	if(SUCCEEDED(result))
	{
		variant.vt = VT_ARRAY | VT_I4 ;
		variant.parray = safeArray ; 		
		result = pQualifierSet->Put (strQualifierName, &variant, lFlavour);
		VariantClear(&variant);
	}
	else
		SafeArrayDestroy(safeArray);

	return result;

}

//***************************************************************************
//
// CWBEMHelper::GetADSIPathFromObjectPath
//
// Purpose: See Header File
//
//***************************************************************************
LPWSTR CWBEMHelper :: GetADSIPathFromObjectPath(LPCWSTR pszObjectRef)
{
	// Parse the object path
	CObjectPathParser theParser;
	ParsedObjectPath *theParsedObjectPath = NULL;
	LPWSTR pszADSIPath = NULL;
	switch(theParser.Parse((LPWSTR)pszObjectRef, &theParsedObjectPath))
	{
		case CObjectPathParser::NoError:
		{
			KeyRef *pKeyRef = *(theParsedObjectPath->m_paKeys);
			// Check to see that there is 1 key specified and that its type is VT_BSTR
			if(theParsedObjectPath->m_dwNumKeys == 1 && pKeyRef->m_vValue.vt == VT_BSTR)
			{
				// If the name of the key is specified, check the name
				if(pKeyRef->m_pName && _wcsicmp(pKeyRef->m_pName, ADSI_PATH_ATTR) != 0)
					break;

				pszADSIPath = new WCHAR[wcslen((*theParsedObjectPath->m_paKeys)->m_vValue.bstrVal) + 1];
				wcscpy(pszADSIPath, (*theParsedObjectPath->m_paKeys)->m_vValue.bstrVal);
			}
			break;
		}	
		default:
			break;
	}

	// Free the parser object path
	theParser.Free(theParsedObjectPath);
	return pszADSIPath;
}

//***************************************************************************
//
// CWBEMHelper::GetObjectRefFromADSIPath
//
// Purpose: See Header File
//
//***************************************************************************
BSTR CWBEMHelper :: GetObjectRefFromADSIPath(LPCWSTR pszADSIPath, LPCWSTR pszWBEMClassName)
{
	// We need the object path parser to add WMI escape characters
	// from the key value which is an ADSI Path
	ParsedObjectPath t_ObjectPath;

	// Add a key value binding for the ADSIPath
	//===========================================
	VARIANT vKeyValue;
	VariantInit(&vKeyValue);
	vKeyValue.vt = VT_BSTR;
	vKeyValue.bstrVal = SysAllocString(pszADSIPath);
	t_ObjectPath.SetClassName(pszWBEMClassName);
	t_ObjectPath.AddKeyRef(ADSI_PATH_ATTR, &vKeyValue);
	VariantClear(&vKeyValue);


	// Get the Object Path value now
	//================================
	CObjectPathParser t_Parser;
	LPWSTR t_pszObjectPath = NULL;
	BSTR retVal = NULL;
	if(CObjectPathParser::NoError == t_Parser.Unparse(&t_ObjectPath, &t_pszObjectPath))
	{
		retVal = SysAllocString(t_pszObjectPath);
		delete [] t_pszObjectPath;
	}
	return retVal;
}

//***************************************************************************
//
// CWBEMHelper::GetUint8ArrayProperty
//
// Purpose: See Header file
//
//***************************************************************************	
HRESULT CWBEMHelper :: GetUint8ArrayProperty(IWbemClassObject *pWbemClass, 
	const BSTR strPropertyName, 
	LPBYTE *ppPropertyValues, 
	ULONG *plCount)
{
	VARIANT variant;
	VariantInit(&variant);
	HRESULT result = pWbemClass->Get(strPropertyName, 0, &variant, NULL, NULL);
	if(SUCCEEDED(result))
	{
		if(variant.vt == (VT_ARRAY|VT_UI1))
		{
			SAFEARRAY *pArray = variant.parray;
			BYTE HUGEP *pb;
			LONG lUbound = 0, lLbound = 0;
			if(SUCCEEDED(result = SafeArrayAccessData(pArray, (void HUGEP* FAR*)&pb)))
			{
				if(SUCCEEDED (result = SafeArrayGetLBound(pArray, 1, &lLbound)))
				{
					if (SUCCEEDED (result = SafeArrayGetUBound(pArray, 1, &lUbound)))
					{
						if(*plCount = lUbound - lLbound + 1)
						{
							*ppPropertyValues = new BYTE[*plCount];
							for(DWORD i=0; i<*plCount; i++)
								(*ppPropertyValues)[i] = pb[i];
						}
					}
				}
				SafeArrayUnaccessData(pArray);
			}
		}
		else
		{
			*ppPropertyValues = NULL;
			*plCount = 0;
		}
	}
	VariantClear(&variant);
	return result;
}

//***************************************************************************
//
// CWBEMHelper::FormulateInstanceQuery
//
// Purpose: See Header file
//
//***************************************************************************	
HRESULT CWBEMHelper :: FormulateInstanceQuery(IWbemServices *pServices, IWbemContext *pCtx, BSTR strClass, IWbemClassObject *pWbemClass, LPWSTR pszObjectCategory, BSTR strClassQualifier, BSTR strCategoryQualifier)
{
	DWORD dwOutput = 0;
	pszObjectCategory[dwOutput++] = LEFT_BRACKET_STR[0];
	DWORD dwOrPosition = dwOutput;
	pszObjectCategory[dwOutput++] = PIPE_STR[0];

	HRESULT result = E_FAIL;
	if(SUCCEEDED(result = AddSingleCategory(pszObjectCategory, &dwOutput, pWbemClass, strClassQualifier, strCategoryQualifier)))
	{
	}
/*
	IEnumWbemClassObject *pEnum = NULL;
	DWORD dwNumObjects = 0;
	HRESULT result = pServices->CreateClassEnum(strClass, WBEM_FLAG_DEEP, pCtx, &pEnum);
	if(SUCCEEDED(result))
	{
		IWbemClassObject *pNextObject = NULL;
		ULONG lNum = 0;
		while(SUCCEEDED(pEnum->Next(WBEM_INFINITE, 1, &pNextObject, &lNum)) && lNum )
		{
			if(!SUCCEEDED(AddSingleCategory(pszObjectCategory, &dwOutput, pNextObject, strClassQualifier, strCategoryQualifier)))
			{
				pNextObject->Release();
				break;
			}
			dwNumObjects ++;
			pNextObject->Release();
		}
		pEnum->Release();
	}

	// Remove the '|' if there is only one element
	if(!dwNumObjects)
	*/
		pszObjectCategory[dwOrPosition] = SPACE_STR[0];

	// Terminate the query
	pszObjectCategory[dwOutput++] = RIGHT_BRACKET_STR[0];
	pszObjectCategory[dwOutput] = NULL;
	return result;
}

//***************************************************************************
//
// CWBEMHelper::AddSingleCategory
//
// Purpose: See Header file
//
//***************************************************************************	
HRESULT CWBEMHelper :: AddSingleCategory(LPWSTR pszObjectCategory, DWORD *pdwOutput, IWbemClassObject *pNextObject, BSTR strLDAPNameQualifier, BSTR strCategoryQualifier)
{
	pszObjectCategory[(*pdwOutput)++] = SPACE_STR[0];
	pszObjectCategory[(*pdwOutput)++] = LEFT_BRACKET_STR[0];
	IWbemQualifierSet *pQualifierSet = NULL;
	HRESULT result;
	if(SUCCEEDED(result = pNextObject->GetQualifierSet(&pQualifierSet)))
	{
		VARIANT classNameVariant;
		if(SUCCEEDED(result = pQualifierSet->Get(strLDAPNameQualifier, 0, &classNameVariant, NULL)))
		{
			VARIANT categoryVariant;

			if(SUCCEEDED(result = pQualifierSet->Get(strCategoryQualifier, 0, &categoryVariant, NULL)))
			{
				pszObjectCategory[(*pdwOutput)++] = AMPERSAND_STR[0];

				pszObjectCategory[(*pdwOutput)++] = LEFT_BRACKET_STR[0];
				wcscpy(pszObjectCategory + *pdwOutput, OBJECT_CATEGORY_EQUALS);
				*pdwOutput += wcslen(OBJECT_CATEGORY_EQUALS);
				wcscpy(pszObjectCategory + *pdwOutput, categoryVariant.bstrVal);
				*pdwOutput += wcslen(categoryVariant.bstrVal);
				pszObjectCategory[(*pdwOutput)++] = RIGHT_BRACKET_STR[0];

				pszObjectCategory[(*pdwOutput)++] = LEFT_BRACKET_STR[0];
				wcscpy(pszObjectCategory + *pdwOutput, OBJECT_CLASS_EQUALS);
				*pdwOutput += wcslen(OBJECT_CLASS_EQUALS);
				wcscpy(pszObjectCategory + *pdwOutput, classNameVariant.bstrVal);
				*pdwOutput += wcslen(classNameVariant.bstrVal);
				pszObjectCategory[(*pdwOutput)++] = RIGHT_BRACKET_STR[0];

				VariantClear(&categoryVariant);
			}
			VariantClear(&classNameVariant);
		}
		pQualifierSet->Release();
	}
	pszObjectCategory[(*pdwOutput)++] = RIGHT_BRACKET_STR[0];
	pszObjectCategory[(*pdwOutput)++] = SPACE_STR[0];
	return result;
}


//***************************************************************************
//
// CWBEMHelper::IsPresentInBstrList
//
// Purpose: See Header file
//
//***************************************************************************	
BOOLEAN CWBEMHelper :: IsPresentInBstrList(BSTR *pstrProperyNames, DWORD dwNumPropertyNames, BSTR strPropertyName)
{
	for(DWORD i=0; i<dwNumPropertyNames; i++)
	{
		if(_wcsicmp(pstrProperyNames[i], strPropertyName) == 0)
			return TRUE;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\adsitest\methprov\classfac.cpp ===
//***************************************************************************

//

//  CLASSFAC.CPP

//

//  Module: WBEM method provider sample code

//

//  Purpose: Contains the class factory.  This creates objects when

//           connections are requested.

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include "methprov.h"

//***************************************************************************
//
// CProvFactory::CProvFactory
// CProvFactory::~CProvFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CProvFactory::CProvFactory()
{
    m_cRef=0L;
    return;
}

CProvFactory::~CProvFactory(void)
{
    return;
}

//***************************************************************************
//
// CProvFactory::QueryInterface
// CProvFactory::AddRef
// CProvFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CProvFactory::QueryInterface(REFIID riid
    , PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CProvFactory::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CProvFactory::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

//***************************************************************************
//
// CProvFactory::CreateInstance
//
// Purpose: Instantiates a Locator object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CProvFactory::CreateInstance(LPUNKNOWN pUnkOuter
    , REFIID riid, PPVOID ppvObj)
{
    IWbemProviderInit *   pInit;
    HRESULT hr;

    *ppvObj=NULL;
    hr = E_OUTOFMEMORY;

    // This object doesnt support aggregation.

    if (NULL!=pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    // Create the Initialize object.
    
    pInit=new CMethodPro();

    if (NULL==pInit)
        return E_OUTOFMEMORY;

    hr=pInit->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.

    if (FAILED(hr))
        delete pInit;
    return hr;
}

//***************************************************************************
//
// CProvFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CProvFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\adsitest\memleak\main.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include <windows.h>
#include <stdio.h>

#include <objbase.h>
#include <activeds.h>


LPWSTR m_lpszTopLevelContainerPath = NULL;
// These are the search preferences often used
ADS_SEARCHPREF_INFO m_pSearchInfo[2];
LPCWSTR ADS_PATH_ATTR				= L"ADsPath";

HRESULT GetRootDSE()
{
	// Get the DefaultNamingContext to get at the top level container
	// Get the ADSI path of the schema container and store it for future use
	IADs *pRootDSE = NULL;
	HRESULT result;

	if(SUCCEEDED(result = ADsOpenObject(L"LDAP://RootDSE", NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IADs, (LPVOID *) &pRootDSE)))
	{
		// Get the location of the schema container
		BSTR strDefaultNamingContext = SysAllocString(L"defaultNamingContext");

		// Get the DEFAULT_NAMING_CONTEXT property. This property contains the ADSI path
		// of the top level container
		VARIANT variant;
		VariantInit(&variant);
		if(SUCCEEDED(result = pRootDSE->Get(strDefaultNamingContext, &variant)))
		{

			// Form the top level container path
			m_lpszTopLevelContainerPath = new WCHAR[wcslen(L"LDAP://") + wcslen(variant.bstrVal) + 1];
			wcscpy(m_lpszTopLevelContainerPath, L"LDAP://");
			wcscat(m_lpszTopLevelContainerPath, variant.bstrVal);

			VariantClear(&variant);
		}

		SysFreeString(strDefaultNamingContext);
		pRootDSE->Release();
	}

	return result;
}

HRESULT GetADSIInstance(LPWSTR szADSIPath)
{
	HRESULT result;
	IDirectoryObject *pDirectoryObject;

	if(SUCCEEDED(result = ADsOpenObject((LPWSTR)szADSIPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectoryObject, (LPVOID *)&pDirectoryObject)))
	{

		PADS_ATTR_INFO pAttributeEntries;
		DWORD dwNumAttributes;
		if(SUCCEEDED(result = pDirectoryObject->GetObjectAttributes(NULL, -1, &pAttributeEntries, &dwNumAttributes)))
		{

			PADS_OBJECT_INFO pObjectInfo = NULL;
			if(SUCCEEDED(result = pDirectoryObject->GetObjectInformation(&pObjectInfo)))
			{
				FreeADsMem((LPVOID *) pObjectInfo);
			}
			else
				return result;
			FreeADsMem((LPVOID *) pAttributeEntries);

		}
		else
			return result;
		pDirectoryObject->Release();
	}
	else
		return result;

	return result;

}

HRESULT EnumerateClass(LPCWSTR pszClass, LPCWSTR pszCategory)
{
	// Formulate the query
	WCHAR pszQuery[100];
	wcscpy(pszQuery, L"(&(objectCategory=" );
	wcscat(pszQuery, pszCategory);
	wcscat(pszQuery, L")(objectClass=");
	wcscat(pszQuery, pszClass);
	wcscat(pszQuery, L"))");

	// Initialize the return values
	HRESULT result = E_FAIL;

	// Bind to the node from which the search should start
	IDirectorySearch *pDirectorySearchContainer = NULL;
	if(SUCCEEDED(result = ADsOpenObject((LPWSTR)m_lpszTopLevelContainerPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectorySearch, (LPVOID *)&pDirectorySearchContainer)))
	{
		// Now perform a search for the attribute DISTINGUISHED_NAME_ATTR name
		if(SUCCEEDED(result = pDirectorySearchContainer->SetSearchPreference(m_pSearchInfo, 2)))
		{
			ADS_SEARCH_HANDLE hADSSearchOuter;

			if(SUCCEEDED(result = pDirectorySearchContainer->ExecuteSearch((LPWSTR) pszQuery, (LPWSTR *)&ADS_PATH_ATTR, 1, &hADSSearchOuter)))
			{
				// Calculate the number of rows first. 
				while(SUCCEEDED(result = pDirectorySearchContainer->GetNextRow(hADSSearchOuter)) &&
					result != S_ADS_NOMORE_ROWS)
				{

					// Get the columns for the attributes
					ADS_SEARCH_COLUMN adsColumn;

					// Store each of the LDAP class attributes 
					if(SUCCEEDED(pDirectorySearchContainer->GetColumn(hADSSearchOuter, (LPWSTR)ADS_PATH_ATTR, &adsColumn)))
					{
						// Create the CADSIInstance
						if(SUCCEEDED(result = GetADSIInstance(adsColumn.pADsValues->DNString)))
						{

						}
						else
							return result;

						// Free resouces
						pDirectorySearchContainer->FreeColumn( &adsColumn );
					}
					else
						return result;
				}

				// Close the search. 
				pDirectorySearchContainer->CloseSearchHandle(hADSSearchOuter);

			} // ExecuteSearch() 
			else
				return result;
		} // SetSearchPreference()
		else
			return result;
		pDirectorySearchContainer->Release();
	} // ADsOpenObject
	else
		return result;

	return result;

}


int main(int argc, char *argv)
{
	LPTSTR lpszCommandLine = GetCommandLine();
	LPWSTR * lppszCommandArgs = CommandLineToArgvW(lpszCommandLine, &argc);
	DWORD dwMaxInnerIterations = 3000;
	DWORD dwMaxOuterIterations = 10;
	DWORD dwSleepSeconds = 25*60; // Amount of time to sleep after inner loop
	LPWSTR pszClass = NULL;
	LPWSTR pszCategory = NULL;

	for(int i=1; i<argc; i++)
	{
		if(_wcsicmp(lppszCommandArgs[i], L"/OC") == 0)
		{
			pszClass = lppszCommandArgs[++i];
		}
		else if(_wcsicmp(lppszCommandArgs[i], L"/OT") == 0)
		{
			pszCategory = lppszCommandArgs[++i];
		}
		else if(_wcsicmp(lppszCommandArgs[i], L"/S") == 0)
		{
			WCHAR *pLeftOver;
			dwSleepSeconds = wcstol(lppszCommandArgs[++i], &pLeftOver, 10);
		}
		else if(_wcsicmp(lppszCommandArgs[i], L"/ON") == 0)
		{
			WCHAR *pLeftOver;
			dwMaxOuterIterations = wcstol(lppszCommandArgs[++i], &pLeftOver, 10);
		}
		else
		{
			wprintf(L"Usage : %s /OC <objectClass> /OT <objectCategory> /ON <outerLoopCount>  /S <sleepSecondsAfterInnerLoop>\n",  lppszCommandArgs[0]);
			return 1;
		}
	}


	// Initialize the search preferences often used
	m_pSearchInfo[0].dwSearchPref		= ADS_SEARCHPREF_SEARCH_SCOPE;
	m_pSearchInfo[0].vValue.dwType		= ADSTYPE_INTEGER;
	m_pSearchInfo[0].vValue.Integer		= ADS_SCOPE_SUBTREE;

	m_pSearchInfo[1].dwSearchPref		= ADS_SEARCHPREF_PAGESIZE;
	m_pSearchInfo[1].vValue.dwType		= ADSTYPE_INTEGER;
	m_pSearchInfo[1].vValue.Integer		= 1024;


	HRESULT result;
	if(SUCCEEDED(result = CoInitialize(NULL) ))
	{
		if(SUCCEEDED(GetRootDSE()))
		{
			for(DWORD j=0; j<dwMaxOuterIterations; j++)
			{

				if(SUCCEEDED(result = EnumerateClass(pszClass, pszCategory)))
				{
				}
				else
					wprintf(L"EnumerateClass FAILED for iteration %d with %x\n", j, result);

				wprintf(L"Sleeping for %d seconds ...\n", dwSleepSeconds);
				Sleep(1000*dwSleepSeconds);
			}
		}
		else
			wprintf(L"Get RootDSE failed with %x\n", result);

	}
	else
		wprintf(L"CoIntialize or CoInitializeSecurity() failed with %x\n", result);

	wprintf(L"Press a key to exit\n");
	getchar();

	if(SUCCEEDED(result))
		return 0;
	else
		return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\adsitest\methprov\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

// 

//  Module: WBEM Method provider sample code

//

//  Purpose: Contains DLL entry points.  Also has code that controls

//           when the DLL can be unloaded by tracking the number of

//           objects and locks as well as routines that support

//           self registration.

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include <initguid.h>
#include "methprov.h"

HMODULE ghModule;

// TODO, GuidGen should be used to generate a unique number for any 
// providers that are going to be used for anything more extensive 
// than just testing.
                                 
DEFINE_GUID(CLSID_methodprovider,0xe30ec6a0, 0x23cf, 0x11d1, 0x8f, 0xde, 0x0, 0x0, 0xf8, 0x4, 0xaa, 0x5c);
//{E30EC6A0-23CF-11d1-8FDE-0000F804AA5C}

//Count number of objects and number of locks.

long       g_cObj=0;
long       g_cLock=0;

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.
//
// Return: TRUE if OK.
//
//***************************************************************************


BOOL WINAPI LibMain32(HINSTANCE hInstance, ULONG ulReason
    , LPVOID pvReserved)
{
    if (DLL_PROCESS_DETACH==ulReason)
    {
        return TRUE;
    }
    else
    {
        if (DLL_PROCESS_ATTACH!=ulReason)
            return TRUE;
		else
			DisableThreadLibraryCalls(hInstance);			// 158024 
    }
	

    ghModule = hInstance;
    return TRUE;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr;
    CProvFactory *pObj;

    if (CLSID_methodprovider!=rclsid)
        return E_FAIL;

    pObj=new CProvFactory();

    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    sc=(0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;
    return sc;
}

//***************************************************************************
//
//  Is4OrMore
//
//  Returns true if win95 or any version of NT > 3.51
//
//***************************************************************************

BOOL Is4OrMore(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return os.dwMajorVersion >= 4;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    char       szID[128];
    WCHAR      wcID[128];
    char       szCLSID[128];
    char       szModule[MAX_PATH];
    char * pName = "WBEM Method Provider Test";
    char * pModel;
    HKEY hKey1, hKey2;

    // Normally we want to use "Both" as the threading model since
    // the DLL is free threaded, but NT 3.51 Ole doesnt work unless
    // the model is "Aparment"

    if(Is4OrMore())
        pModel = "Both";
    else
        pModel = "Apartment";

    // Create the path.

    StringFromGUID2(CLSID_methodprovider, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("CLSID\\"));
    lstrcat(szCLSID, szID);

    // Create entries under CLSID

    RegCreateKey(HKEY_CLASSES_ROOT, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, lstrlen(pName)+1);
    RegCreateKey(hKey1,"InprocServer32",&hKey2);

    GetModuleFileName(ghModule, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        lstrlen(szModule)+1);
    RegSetValueEx(hKey2, "ThreadingModel", 0, REG_SZ, 
                                        (BYTE *)pModel, lstrlen(pModel)+1);
    CloseHandle(hKey1);
    CloseHandle(hKey2);
    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    char       szID[128];
    WCHAR      wcID[128];
    char  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

    StringFromGUID2(CLSID_methodprovider, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_CLASSES_ROOT, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, "InProcServer32");
        CloseHandle(hKey);
    }

    dwRet = RegOpenKey(HKEY_CLASSES_ROOT, "CLSID", &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        CloseHandle(hKey);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\adsitest\methprov\methprov.h ===
//***************************************************************************

//

//  methprov.h

//

//  Module: WBEM Method Test Provider code

//

//  Purpose: Method Provider Test Header File.

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _methprov_H_
#define _methprov_H_

#include "wbemidl.h"

typedef LPVOID * PPVOID;

// Provider interfaces are provided by objects of this class
 
class CMethodPro : public IWbemServices, public IWbemProviderInit
    {
    protected:
        ULONG              m_cRef;         //Object reference count
        IWbemServices *  m_pWbemSvcs;
        IWbemClassObject* m_pOutClass;
     public:
        CMethodPro();
        ~CMethodPro(void);

        //Non-delegating object IUnknown

        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo){return WBEM_E_NOT_SUPPORTED;};

        STDMETHOD(GetTypeInfo)(
           THIS_
           UINT itinfo,
           LCID lcid,
           ITypeInfo FAR* FAR* pptinfo){return WBEM_E_NOT_SUPPORTED;};

        STDMETHOD(GetIDsOfNames)(
          THIS_
          REFIID riid,
          OLECHAR FAR* FAR* rgszNames,
          UINT cNames,
          LCID lcid,
          DISPID FAR* rgdispid){return WBEM_E_NOT_SUPPORTED;};

        STDMETHOD(Invoke)(
          THIS_
          DISPID dispidMember,
          REFIID riid,
          LCID lcid,
          WORD wFlags,
          DISPPARAMS FAR* pdispparams,
          VARIANT FAR* pvarResult,
          EXCEPINFO FAR* pexcepinfo,
          UINT FAR* puArgErr){return WBEM_E_NOT_SUPPORTED;};


        SCODE GetByPath( BSTR Path, IWbemClassObject FAR* FAR* pObj, IWbemContext  *pCtx);

        //IWbemProviderInit

        HRESULT STDMETHODCALLTYPE Initialize(
             /* [in] */ LPWSTR pszUser,
             /* [in] */ LONG lFlags,
             /* [in] */ LPWSTR pszNamespace,
             /* [in] */ LPWSTR pszLocale,
             /* [in] */ IWbemServices *pNamespace,
             /* [in] */ IWbemContext *pCtx,
             /* [in] */ IWbemProviderInitSink *pInitSink
                        );

        //IWbemServices  

		HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;}
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;}
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        // Supported !!!!

        HRESULT STDMETHODCALLTYPE ExecMethod( BSTR, BSTR, long, IWbemContext*,
            IWbemClassObject*, IWbemClassObject**, IWbemCallResult**){return WBEM_E_NOT_SUPPORTED;}

        HRESULT STDMETHODCALLTYPE ExecMethodAsync( BSTR, BSTR, long, 
            IWbemContext*, IWbemClassObject*, IWbemObjectSink*);

       
};

typedef CMethodPro *PCMethodPro;

// This class is the class factory for CMethodPro objects.

class CProvFactory : public IClassFactory
    {
    protected:
        ULONG           m_cRef;

    public:
        CProvFactory(void);
        ~CProvFactory(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID
                                 , PPVOID);
        STDMETHODIMP         LockServer(BOOL);
    };

typedef CProvFactory *PCProvFactory;



// These variables keep track of when the module can be unloaded

extern long       g_cObj;
extern long       g_cLock;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\adsitest\testcom\main.cpp ===
#include <tchar.h>
#include <stdio.h>

#include <windows.h>
#include <objbase.h>

#include <initguid.h>
#include <wmixmlst.h>

int main(int argc, char * argv[])
{
	IWmiXMLTransport *pWbemServices;
	HRESULT result = CoInitialize(NULL);

	if(SUCCEEDED(result))
	{
		HRESULT result = CoCreateInstance (CLSID_WmiXMLTransport , NULL ,
			CLSCTX_LOCAL_SERVER , 
				IID_IWmiXMLTransport,(void **)&pWbemServices);

		printf("Result of CoCreateInstance : %x\n", result);
		if(SUCCEEDED(result = pWbemServices->ConnectUsingToken(0, NULL)))
		{
		}
		else 
			printf ("FAILED with %x\n", result);

	}
	
	return 0;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\adsitest\testenum\main.cpp ===
#include <stdio.h>
#include <windows.h>
#include <activeds.h>


HRESULT DoEnum()
{
	// Get the IADsContainer interface on the schema container
	IADsContainer *pADsContainer = NULL;
	IUnknown *pChild = NULL;
	HRESULT result = E_FAIL;

	// Go thru the possible superiors of every class
	if(SUCCEEDED(result = ADsOpenObject(L"LDAP://Schema", NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IADsContainer, (LPVOID *) &pADsContainer)))
	{
		IEnumVARIANT *pEnum = NULL;
		if(SUCCEEDED(result = ADsBuildEnumerator(pADsContainer, &pEnum)))
		{
			IADsClass *pADsChildClass = NULL;
			VARIANT v;
			VariantInit(&v);
			while (SUCCEEDED(result = ADsEnumerateNext(pEnum, 1, &v, NULL)) && result != S_FALSE)
			{
				pChild = v.punkVal;
				if(SUCCEEDED(result = pChild->QueryInterface(IID_IADsClass, (LPVOID *) &pADsChildClass)))
				{
					BSTR strChildClassName;
					if(SUCCEEDED(result = pADsChildClass->get_Name(&strChildClassName)))
					{
						VARIANT variant;
						VariantInit(&variant);
						if(SUCCEEDED(result = pADsChildClass->get_PossibleSuperiors(&variant)))
						{
							VariantClear(&variant);
						}
						SysFreeString(strChildClassName);
					}
					pADsChildClass->Release();
				}
				VariantClear(&v);
			}
			ADsFreeEnumerator(pEnum);
		}
		pADsContainer->Release();
		
	}
	return result;
}

void main()
{
	CoInitialize(NULL);
	for(int i=0; i<100; i++)
	{
		if(SUCCEEDED(DoEnum()))
			printf("Enum succeeded for iteration %d\n", i);
		else
			printf("Enum FAILED for iteration %d\n", i);
		Sleep(7000);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\adsitest\put\main.cpp ===
#include <tchar.h>
#include <windows.h>
#include <wbemcli.h>

#include <stdio.h>


int main(int argc, char *argv)
{
	LPTSTR lpszCommandLine = GetCommandLine();
	LPWSTR * lppszCommandArgs = CommandLineToArgvW(lpszCommandLine, &argc);

	
	lppszCommandArgs[++i];
	
	HRESULT result;
	if(SUCCEEDED(result = CoInitialize(NULL)))
	{
		IWbemLocator *pLocator = NULL;
		if(SUCCEEDED(result = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID *) &pLocator)))
		{

			IWbemServices *pServices = NULL;
			// Connect to the Root\Default namespace with current user
			BSTR strNamespace = SysAllocString(pszNamespace);
			if(SUCCEEDED(result = pLocator->ConnectServer(strNamespace, NULL, NULL,	0, NULL, 0, 0, &pServices)))
			{
				SysFreeString(strNamespace);
				switch(op)
				{
					case GET_CLASS:
					{
						BSTR strClass = SysAllocString(pszClass);
						IWbemClassObject *pClass = NULL;
						for(DWORD j=0; j<dwMaxOuterIterations; j++)
						{
							for(DWORD i=0; i<dwMaxInnerIterations; i++)
							{

								if(SUCCEEDED(result = pServices->GetObject(strClass, 0, NULL, &pClass, NULL)))
								{
									_tprintf(__TEXT("GetClass succeeded for iteration (%d,%d) \n"), j, i);
									pClass->Release();
									pClass = NULL;
								}
								else
									_tprintf(__TEXT("GetClass FAILED for iteration (%d, %d) with %x\n"), j, i, result);

							}
							_tprintf(__TEXT("Sleeping for %d seconds ...\n"), dwSleepSeconds);
							Sleep(1000*dwSleepSeconds);
						}
						SysFreeString(strClass);
						break;
					}
					case ENUM_CLASS:
					{
						BSTR strClass = SysAllocString(pszClass);
						IEnumWbemClassObject  *pClassEnum = NULL;
						IWbemClassObject *pClass = NULL;
						ULONG lCount; 
						ULONG lRetreivedCount; 
						for(DWORD j=0; j<dwMaxOuterIterations; j++)
						{
							for(DWORD i=0; i<dwMaxInnerIterations; i++)
							{

								if(SUCCEEDED(result = pServices->CreateClassEnum(strClass, lEnumerationType, NULL, &pClassEnum)))
								{
									lRetreivedCount = 0;
									_tprintf(__TEXT("Enumerate Classes succeeded for iteration (%d, %d) \n"), j, i);
									while(SUCCEEDED(pClassEnum->Next(WBEM_INFINITE, 1, &pClass, &lCount)) && lCount == 1)
									{
										lRetreivedCount ++;
										pClass->Release();
										pClass = NULL;
									}
									_tprintf(__TEXT("Enumerate Classes Retreived %d classes for iteration (%d, %d) \n"), lRetreivedCount, j, i);
									pClassEnum->Release();
									pClassEnum = NULL;
								}
								else
									_tprintf(__TEXT("Enumerate Classes FAILED for iteration (%d, %d) with %x\n"), j, i, result);

							}
							_tprintf(__TEXT("Sleeping for %d seconds ...\n"), dwSleepSeconds);
							Sleep(1000*dwSleepSeconds);
						}
						SysFreeString(strClass);
						break;
					}

					case GET_INSTANCE:
					case ENUM_INSTANCE:
						_tprintf(__TEXT("These operations not implemented yet\n"));
						break;
				}
				pServices->Release();
			}
			else
				_tprintf(__TEXT("ConnectServer on locator failed %x\n"), result);
		}
		else
			_tprintf(__TEXT("CoCreate on locator failed %x\n"), result);
	}
	else
		_tprintf(__TEXT("CoIntialize failed %x\n"), result);

	if(SUCCEEDED(result))
		return 0;
	else
		return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\adsitest\methprov\methprov.cpp ===
//***************************************************************************

//

//  METHPROV.CPP

//

//  Module: WBEM Method provider sample code

//

//  Purpose: Defines the CMethodPro class.  An object of this class is

//           created by the class factory for each connection.

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include "methprov.h"
#define _MT
#include <process.h>
#include <wbemidl.h>
#include <stdio.h>


//***************************************************************************
//
// CMethodPro::CMethodPro
// CMethodPro::~CMethodPro
//
//***************************************************************************

CMethodPro::CMethodPro()
{
    InterlockedIncrement(&g_cObj);
    return;
   
}

CMethodPro::~CMethodPro(void)
{
    InterlockedDecrement(&g_cObj);
    return;
}

//***************************************************************************
//
// CMethodPro::QueryInterface
// CMethodPro::AddRef
// CMethodPro::Release
//
// Purpose: IUnknown members for CMethodPro object.
//***************************************************************************


STDMETHODIMP CMethodPro::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IWbemServices == riid || IID_IWbemProviderInit==riid)
       if(riid== IID_IWbemServices){
          *ppv=(IWbemServices*)this;
       }

       if(IID_IUnknown==riid || riid== IID_IWbemProviderInit){
          *ppv=(IWbemProviderInit*)this;
       }
    

    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CMethodPro::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CMethodPro::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

/***********************************************************************
*                                                                      *
*CMethodPro::Initialize                                                *
*                                                                      *
*Purpose: This is the implementation of IWbemProviderInit. The method  *
* is need to initialize with CIMOM.                                    *
*                                                                      *
***********************************************************************/
STDMETHODIMP CMethodPro::Initialize(LPWSTR pszUser, LONG lFlags,
                                    LPWSTR pszNamespace, LPWSTR pszLocale,
                                    IWbemServices *pNamespace, 
                                    IWbemContext *pCtx,
                                    IWbemProviderInitSink *pInitSink)
{

   
   m_pWbemSvcs=pNamespace;
   m_pWbemSvcs->AddRef();
   
    //Let CIMOM know your initialized
    //===============================
    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}



/************************************************************************
*                                                                       *      
*CMethodPro::ExecMethodAsync                                            *
*                                                                       *
*Purpose: This is the Async function implementation.                    *
*         The only method supported in this sample is named Echo.  It   * 
*         takes an input string, copies it to the output and returns the* 
*         length.  The mof definition is                                *
*                                                                       *
*    [dynamic: ToInstance, provider("MethProv")]class MethProvSamp      *
*    {                                                                  *
*         [implemented, static]                                         *
*            uint32 Echo([IN]string sInArg="default",                   *
*                [out] string sOutArg);                                 *
*    };                                                                 *
*                                                                       *
************************************************************************/

STDMETHODIMP CMethodPro::ExecMethodAsync(BSTR ObjectPath, BSTR MethodName, 
            long lFlags, IWbemContext* pCtx, IWbemClassObject* pInParams, 
            IWbemObjectSink* pResultSink)
{
    HRESULT hr;    
    IWbemClassObject * pClass = NULL;
    IWbemClassObject * pOutClass = NULL;    
    IWbemClassObject* pOutParams = NULL;
 
    // Do some minimal error checking.  This code only support the
    // method "Echo" as defined in the mof.  A routine could support
    // more than on method

    if(_wcsicmp(MethodName, L"Echo"))
        return WBEM_E_INVALID_PARAMETER;

    // Allocate some BSTRs
    
    BSTR ClassName = SysAllocString(L"MethProvSamp");    
    BSTR InputArgName = SysAllocString(L"sInArg");
    BSTR OutputArgName = SysAllocString(L"sOutArg");
    BSTR retValName = SysAllocString(L"ReturnValue");

    // Get the class object, this is hard coded and matches the class
    // in the MOF.  A more sophisticated example would parse the 
    // ObjectPath to determine the class and possibly the instance.

    hr = m_pWbemSvcs->GetObject(ClassName, 0, pCtx, &pClass, NULL);
	if(hr != S_OK)
	{
		 pResultSink->SetStatus(0,hr, NULL, NULL);
		 return WBEM_S_NO_ERROR;
	}
 

    // This method returns values, and so create an instance of the
    // output argument class.

    hr = pClass->GetMethod(MethodName, 0, NULL, &pOutClass);
    pOutClass->SpawnInstance(0, &pOutParams);

    // Copy the input argument into the output object    
    
    VARIANT var;
    VariantInit(&var);    // Get the input argument
    pInParams->Get(InputArgName, 0, &var, NULL, NULL);   

    // put it into the output object

    pOutParams->Put(OutputArgName , 0, &var, 0);      
    long lLen = wcslen(var.bstrVal);    VariantClear(&var);    var.vt = VT_I4;
    var.lVal = lLen;    // special name for return value.
    pOutParams->Put(retValName , 0, &var, 0); 

    // Send the output object back to the client via the sink. Then 
    // release the pointers and free the strings.

    hr = pResultSink->Indicate(1, &pOutParams);    
    pOutParams->Release();
    pOutClass->Release();    
    pClass->Release();    
    SysFreeString(ClassName);
    SysFreeString(InputArgName);    
    SysFreeString(OutputArgName);
    SysFreeString(retValName);     
    
    // all done now, set the status
    hr = pResultSink->SetStatus(0,WBEM_S_NO_ERROR,NULL,NULL);
    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\adsitest\testperf\main.cpp ===
#include <tchar.h>
#include <windows.h>
#include <activeds.h>

#include <stdio.h>


HRESULT GetLDAPClass(IDirectorySearch *pDirectorySearchSchemaContainer, LPCTSTR lpszClassName);
HRESULT GetProperties(IDirectorySearch *pDirectorySearchSchemaContainer, PADS_ATTR_INFO pAttribute);
HRESULT GetLDAPProperty(IDirectorySearch *pDirectorySearchSchemaContainer, LPCTSTR lpszPropertyName);
HRESULT GetLDAPSchemaObject(IDirectorySearch *pDirectorySearchSchemaContainer, LPCTSTR lpszObjectName, IDirectoryObject **ppDIrectoryObject);
LPTSTR CreateADSIPath(LPCTSTR lpszLDAPSchemaObjectName,	LPCTSTR lpszSchemaContainerSuffix);
HRESULT GetAllAttributes(IDirectorySearch *pDirectorySearchSchemaContainer,
		PADS_SEARCHPREF_INFO pSearchInfo,
		DWORD dwSearchInfoCount,
		LPTSTR **lpppszLDAPNames, 
		LPTSTR **lpppszCommonNames, 
		DWORD *pdwCount);

LPCTSTR MAY_CONTAIN_ATTR				= __TEXT("mayContain");
LPCTSTR SYSTEM_MAY_CONTAIN_ATTR			= __TEXT("systemMayContain");
LPCTSTR MUST_CONTAIN_ATTR				= __TEXT("mustContain");
LPCTSTR SYSTEM_MUST_CONTAIN_ATTR		= __TEXT("systemMustContain");
LPCTSTR POSS_SUPERIORS_ATTR				= __TEXT("possSuperiors");
LPCTSTR SYSTEM_POSS_SUPERIORS_ATTR		= __TEXT("systemPossSuperiors");

LPCTSTR LDAP_PREFIX						= __TEXT("LDAP://CN=");
LPCTSTR OBJECT_CLASS_EQUALS_ATTRIBUTE_SCHEMA	= __TEXT("(objectClass=attributeSchema)");
LPCTSTR SCHEMA_SUFFIX					= __TEXT(",CN=Schema,CN=Configuration,DC=dsprovider,DC=microsoft,DC=com");
LPCTSTR SCHEMA_PATH						= __TEXT("LDAP://CN=Schema,CN=Configuration,DC=dsprovider,DC=microsoft,DC=com");
LPCTSTR LDAP_DISP_NAME_EQUALS			= __TEXT("(lDAPDisplayName=");
LPCTSTR LDAP_DISPLAY_NAME_ATTR			= __TEXT("LDAPDisplayName");
LPCTSTR COMMON_NAME_ATTR				= __TEXT("cn");
LPCTSTR RIGHT_BRACKET					= __TEXT(")");
LPCTSTR COMMA							= __TEXT(",");

static ADS_SEARCHPREF_INFO pSearchInfo[2];

int main()
{
	LPWSTR lpszCommandLine = GetCommandLine();
	INT iArgc;
	LPCTSTR * lppszArgv = (LPCTSTR *)CommandLineToArgvW(lpszCommandLine, &iArgc);
	IDirectorySearch *pDirectorySearchSchemaContainer;
	
	pSearchInfo[0].dwSearchPref		= ADS_SEARCHPREF_SEARCH_SCOPE;
	pSearchInfo[0].vValue.Integer		= ADS_SCOPE_ONELEVEL;

	pSearchInfo[1].dwSearchPref		= ADS_SEARCHPREF_PAGESIZE;
	pSearchInfo[1].vValue.Integer		= 256;

	HRESULT result;
	if(SUCCEEDED(result = CoInitialize(NULL)))
	{
		if(SUCCEEDED(result = ADsGetObject((LPTSTR)SCHEMA_PATH, IID_IDirectorySearch, (LPVOID *) &pDirectorySearchSchemaContainer)))
		{

			// Attempt to get all the attributes in AD
			// Get the LDAPDisplayName attributes of all the instances of the
			// class "AttributeSchema"
			LPTSTR * lppszLDAPNames, *lppszCommonNames;
			DWORD dwCount;

			result = GetAllAttributes(pDirectorySearchSchemaContainer, pSearchInfo, 2, &lppszLDAPNames, &lppszCommonNames, &dwCount);


			for(INT i=1; i<iArgc; i++)
			{

				_tprintf(__TEXT("Getting the adsi class: %s\n"), lppszArgv[i]);
				if(SUCCEEDED(result = GetLDAPClass(pDirectorySearchSchemaContainer, lppszArgv[i])))
				{
					_tprintf(__TEXT("Got the class successfully\n"));
				}
				else
				{
					_tprintf(__TEXT("Could not get the LDAP class :%x\n"), result);
					break;
				}
			}

		}
		else
			_tprintf(__TEXT("Could not Get Schema COntainer\n"));

	}
	else
		_tprintf(__TEXT("Could not CoIntialize\n"));

	if(SUCCEEDED(result))
		return 0;
	else
		return 1;
}


HRESULT GetLDAPClass(IDirectorySearch *pDirectorySearchSchemaContainer, LPCTSTR lpszClassName)
{

	IDirectoryObject *pDirectoryObject;

	HRESULT result;
	if(SUCCEEDED(result = GetLDAPSchemaObject(pDirectorySearchSchemaContainer, lpszClassName, &pDirectoryObject)))
	{
		DWORD lCount = 0;
		PADS_ATTR_INFO pAdsAttributes = NULL;

		// Get all the attributes of the ADSI class
		if(SUCCEEDED(result = pDirectoryObject->GetObjectAttributes(NULL, -1, &pAdsAttributes, &lCount)))
		{
			PADS_ATTR_INFO nextAttribute;
			// GO thru each of the attributes and call an appropriate function
			for(DWORD i=0; i<lCount; i++)
			{
				nextAttribute = pAdsAttributes + i;

				// Map each of the LDAP class attributes to WBEM class qualifiers/properties
				if(_tcsicmp(nextAttribute->pszAttrName, SYSTEM_MAY_CONTAIN_ATTR) == 0)
					GetProperties(pDirectorySearchSchemaContainer, nextAttribute);
				else if(_tcsicmp(nextAttribute->pszAttrName, MAY_CONTAIN_ATTR) == 0)
					GetProperties(pDirectorySearchSchemaContainer, nextAttribute);
				else if(_tcsicmp(nextAttribute->pszAttrName, SYSTEM_MUST_CONTAIN_ATTR) == 0)
					GetProperties(pDirectorySearchSchemaContainer, nextAttribute);
				else if(_tcsicmp(nextAttribute->pszAttrName, MUST_CONTAIN_ATTR) == 0)
					GetProperties(pDirectorySearchSchemaContainer, nextAttribute);
				else if(_tcsicmp(nextAttribute->pszAttrName, SYSTEM_POSS_SUPERIORS_ATTR) == 0)
					GetProperties(pDirectorySearchSchemaContainer, nextAttribute);
				else if(_tcsicmp(nextAttribute->pszAttrName, POSS_SUPERIORS_ATTR) == 0)
					GetProperties(pDirectorySearchSchemaContainer, nextAttribute);
			}

			FreeADsMem((LPVOID *)pAdsAttributes);
		}
	}
	return result;
}




HRESULT GetProperties(IDirectorySearch *pDirectorySearchSchemaContainer, PADS_ATTR_INFO pAttribute)
{
	HRESULT result;

	DWORD dwMayContainsCount = pAttribute->dwNumValues;
	PADSVALUE nextValue = pAttribute->pADsValues;
	for(DWORD i=0; i<dwMayContainsCount; i++)
	{
		if(!SUCCEEDED(result = GetLDAPProperty(pDirectorySearchSchemaContainer,nextValue->CaseIgnoreString)))
			break;

		nextValue ++;
	}
	return result;
}

HRESULT GetLDAPProperty(IDirectorySearch *pDirectorySearchSchemaContainer, LPCTSTR lpszPropertyName)
{
	HRESULT result = E_FAIL;

	IDirectoryObject *pDirectoryObject;
	if(SUCCEEDED(result = GetLDAPSchemaObject(pDirectorySearchSchemaContainer, lpszPropertyName, &pDirectoryObject)))
	{
		DWORD lCount = 0;
		PADS_ATTR_INFO pAdsAttributes = NULL;

		// Get all the attributes of the ADSI class
		if(SUCCEEDED(result = pDirectoryObject->GetObjectAttributes(NULL, -1, &pAdsAttributes, &lCount)))
		{
			PADS_ATTR_INFO nextAttribute;

			// GO thru each of the attributes and collect the syntax information
			for(DWORD i=0; i<lCount; i++)
			{
				nextAttribute = pAdsAttributes + i;
			}


			FreeADsMem((LPVOID *)pAdsAttributes);
		}
	}
	return result;

}

HRESULT GetLDAPSchemaObject(IDirectorySearch *pDirectorySearchSchemaContainer, LPCTSTR lpszObjectName, IDirectoryObject **ppDirectoryObject)
{
	// We map the object from the LDAP Display name
	// Hence we cannot directly do an ADsGetObject().
	// We have to send an LDAP query for the instance of ClassSchema/AttributeSchema where the
	// ldapdisplayname attribute is the lpszObjectName parameter.
	HRESULT result = E_FAIL;

	// Now perform one-level search for a class with the lDAPdisplayName property of that value
	if(SUCCEEDED(result = pDirectorySearchSchemaContainer->SetSearchPreference(pSearchInfo, 1)))
	{
		// For the search filter;
		LPTSTR lpszSearchFilter = new TCHAR[ _tcslen(LDAP_DISP_NAME_EQUALS) + _tcslen(lpszObjectName) + _tcslen(RIGHT_BRACKET) + 1];
		_tcscpy(lpszSearchFilter, LDAP_DISP_NAME_EQUALS);
		_tcscat(lpszSearchFilter, lpszObjectName);
		_tcscat(lpszSearchFilter, RIGHT_BRACKET);
		ADS_SEARCH_HANDLE hADSSearch;
		if(SUCCEEDED(result = pDirectorySearchSchemaContainer->ExecuteSearch(lpszSearchFilter, (LPTSTR *)&COMMON_NAME_ATTR, 1, &hADSSearch)))
		{
			if(SUCCEEDED(result = pDirectorySearchSchemaContainer->GetNextRow(hADSSearch)))
			{
				// Get the column for the CN attribute
				ADS_SEARCH_COLUMN adsColumn;
				if(SUCCEEDED(result = pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPTSTR)COMMON_NAME_ATTR, &adsColumn)))
				{
					// Now get the IDirectoryObject interface on this ADSI object

					// First form the ADSI path to the class/property instance
					LPTSTR lpszADSIObjectPath = CreateADSIPath((*adsColumn.pADsValues).DNString, SCHEMA_SUFFIX);

					// Get the IDirectoryObject interface on the class/property object
					if(SUCCEEDED(result = ADsGetObject(lpszADSIObjectPath, IID_IDirectoryObject, (LPVOID *)ppDirectoryObject)))
					{
					}

					// Delete the ADSI path)
					delete [] lpszADSIObjectPath;

					// Free the column
					pDirectorySearchSchemaContainer->FreeColumn(&adsColumn);
				}
			}

			// Close the search
			pDirectorySearchSchemaContainer->CloseSearchHandle(hADSSearch);
		}

		// Delete the filter
		delete [] lpszSearchFilter;
	}

	return result;
}

LPTSTR CreateADSIPath(LPCTSTR lpszLDAPSchemaObjectName,	LPCTSTR lpszSchemaContainerSuffix)
{
	LPTSTR lpszADSIObjectPath = new TCHAR[_tcslen(LDAP_PREFIX) + _tcslen(lpszLDAPSchemaObjectName) + _tcslen(COMMA) + _tcslen(lpszSchemaContainerSuffix) + 1];
	_tcscpy(lpszADSIObjectPath, LDAP_PREFIX);
	_tcscat(lpszADSIObjectPath, lpszLDAPSchemaObjectName);
	_tcscat(lpszADSIObjectPath, lpszSchemaContainerSuffix);

	return lpszADSIObjectPath;

}

HRESULT GetAllAttributes(IDirectorySearch *pDirectorySearchSchemaContainer,
		PADS_SEARCHPREF_INFO pSearchInfo,
		DWORD dwSearchInfoCount,
		LPTSTR **lpppszLDAPNames, 
		LPTSTR **lpppszCommonNames, 
		DWORD *pdwCount)
{
	HRESULT result;

	// Now perform a search for the attributes ldapdisplayname and common names
	if(SUCCEEDED(result = pDirectorySearchSchemaContainer->SetSearchPreference(pSearchInfo, dwSearchInfoCount)))
	{
		ADS_SEARCH_HANDLE hADSSearchOuter;
		LPCTSTR lppszAttributesRequired[] = 
		{
			LDAP_DISPLAY_NAME_ATTR,
			COMMON_NAME_ATTR
		};

		if(SUCCEEDED(result = pDirectorySearchSchemaContainer->ExecuteSearch((LPTSTR)OBJECT_CLASS_EQUALS_ATTRIBUTE_SCHEMA, (LPTSTR *)lppszAttributesRequired, 1, &hADSSearchOuter)))
		{
			*pdwCount = 0;
			// Calculate the number of rows first. You HAVE to iterate :-(
			// Which means that you have to execute the search again
			while(SUCCEEDED(result = pDirectorySearchSchemaContainer->GetNextRow(hADSSearchOuter)) &&
				result != S_ADS_NOMORE_ROWS)
				(*pdwCount) ++;

			// Close the search
			pDirectorySearchSchemaContainer->CloseSearchHandle(hADSSearchOuter);

			ADS_SEARCH_HANDLE hADSSearchInner;
			if(SUCCEEDED(result = pDirectorySearchSchemaContainer->ExecuteSearch((LPTSTR)OBJECT_CLASS_EQUALS_ATTRIBUTE_SCHEMA, (LPTSTR *)&lppszAttributesRequired, 2, &hADSSearchInner)))
			{
				// Allocate enough memory for the classes and names
				*lpppszLDAPNames = new LPTSTR [*pdwCount];
				*lpppszCommonNames = new LPTSTR [*pdwCount];

				// The index of the attribute being processed
				DWORD i = 0;

				// Get the names of the attributes now
				while(SUCCEEDED(result = pDirectorySearchSchemaContainer->GetNextRow(hADSSearchInner))&&
						result != S_ADS_NOMORE_ROWS)
				{
					// Get the column for the LDAP Display Name attribute
					ADS_SEARCH_COLUMN adsLDAPNameColumn, adsCommonNameColumn;
					if(SUCCEEDED(result = pDirectorySearchSchemaContainer->GetColumn(hADSSearchInner, (LPTSTR)COMMON_NAME_ATTR, &adsCommonNameColumn))) 
					{
						// Copy the attribute value
						(*lpppszCommonNames)[i] = new TCHAR[_tcslen((*adsCommonNameColumn.pADsValues).DNString) + 1];
						_tcscpy((*lpppszCommonNames)[i], (*adsCommonNameColumn.pADsValues).DNString);
						pDirectorySearchSchemaContainer->FreeColumn(&adsCommonNameColumn);

						if(SUCCEEDED(result = pDirectorySearchSchemaContainer->GetColumn(hADSSearchInner, (LPTSTR)LDAP_DISPLAY_NAME_ATTR, &adsLDAPNameColumn)))
						{
							// Copy the attribute value
							(*lpppszLDAPNames)[i] = new TCHAR[_tcslen((*adsLDAPNameColumn.pADsValues).DNString) + 1];
							_tcscpy((*lpppszLDAPNames)[i], (*adsLDAPNameColumn.pADsValues).DNString);

							// Free the column
							pDirectorySearchSchemaContainer->FreeColumn(&adsLDAPNameColumn);
						}
						else
							break;
						i++;
					}
					else
						break;
				}

				// Something went wrong? Release allocated resources
				if(i != *pdwCount)
				{
					// Delete the contents of the arrays
					for(DWORD j=0; j<i; j++)
					{
						delete [] (*lpppszLDAPNames)[j];
						delete [] (*lpppszCommonNames)[j];
					}

					// Delete the arrays themselves
					delete [] (*lpppszLDAPNames);
					delete [] (*lpppszCommonNames);

					// Set return values to empty
					*lpppszLDAPNames = NULL;
					*lpppszCommonNames = NULL;
					*pdwCount = 0;

					result = E_FAIL;
				}

				// Close the search
				pDirectorySearchSchemaContainer->CloseSearchHandle(hADSSearchInner);
			}
		}
	}
	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\adsitest\stress\main.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#define _WIN32_WINNT    0x0500

#include <windows.h>
#include <stdio.h>

#include <objbase.h>
#include <wbemcli.h>

typedef enum
{
	OP_INVALID,
	GET_CLASS,
	ENUM_CLASS,
	GET_INSTANCE,
	ENUM_INSTANCE
} OPERATIONS;

int main(int argc, char *argv)
{
	LPTSTR lpszCommandLine = GetCommandLine();
	LPWSTR * lppszCommandArgs = CommandLineToArgvW(lpszCommandLine, &argc);
	OPERATIONS op = OP_INVALID;
	LPWSTR pszNamespace = L"root\\directory\\ldap";
	LPWSTR pszClass = L"top";
	LPWSTR pszInstance = L"user=\"LDAP://CN=Administrator,CN=users,DC=dsprovider,DC=microsoft,DC=com\"";
	DWORD dwMaxInnerIterations = 3000;
	DWORD dwMaxOuterIterations = 10;
	DWORD dwSleepSeconds = 25*60; // Amount of time to sleep after inner loop
	long lEnumerationType = WBEM_FLAG_SHALLOW;

	for(int i=1; i<argc; i++)
	{
		if(_wcsicmp(lppszCommandArgs[i], L"/GC") == 0)
		{
			op = GET_CLASS;
			pszClass = lppszCommandArgs[++i];
		}
		else if(_wcsicmp(lppszCommandArgs[i], L"/EC") == 0)
		{
			op = ENUM_CLASS;
			pszClass = lppszCommandArgs[++i];
		}
		else if(_wcsicmp(lppszCommandArgs[i], L"/R") == 0)
		{
			lEnumerationType = WBEM_FLAG_DEEP;
		}
		else if(_wcsicmp(lppszCommandArgs[i], L"/GI") == 0)
		{
			op = GET_INSTANCE;
			pszInstance = lppszCommandArgs[++i];
		}
		else if(_wcsicmp(lppszCommandArgs[i], L"/EI") == 0)
		{
			op = ENUM_INSTANCE;
			pszClass = lppszCommandArgs[++i];
		}
		else if(_wcsicmp(lppszCommandArgs[i], L"/S") == 0)
		{
			WCHAR *pLeftOver;
			dwSleepSeconds = wcstol(lppszCommandArgs[++i], &pLeftOver, 10);
		}
		else if(_wcsicmp(lppszCommandArgs[i], L"/ON") == 0)
		{
			WCHAR *pLeftOver;
			dwMaxOuterIterations = wcstol(lppszCommandArgs[++i], &pLeftOver, 10);
		}
		else if(_wcsicmp(lppszCommandArgs[i], L"/IN") == 0)
		{
			WCHAR *pLeftOver;
			dwMaxInnerIterations = wcstol(lppszCommandArgs[++i], &pLeftOver, 10);
		}
		else
		{
			wprintf(L"Usage : %s <OPERATION> <OPERAND>\n",  lppszCommandArgs[0]);
			wprintf(L"\t<OPERATION> ::= /GC | /EC | /GI | /EI\n");
			wprintf(L"\t<OPERAND> ::= <classname> | <instancePath>\n");
			return 1;
		}
	}

	HRESULT result;
	if(SUCCEEDED(result = CoInitialize(NULL)) && SUCCEEDED(result = CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, 0)))
	{
		IWbemLocator *pLocator = NULL;
		if(SUCCEEDED(result = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID *) &pLocator)))
		{

			IWbemServices *pServices = NULL;
			// Connect to the Root\Default namespace with current user
			BSTR strNamespace = SysAllocString(pszNamespace);
			if(SUCCEEDED(result = pLocator->ConnectServer(strNamespace, NULL, NULL,	0, NULL, 0, 0, &pServices)))
			{
				SysFreeString(strNamespace);
				switch(op)
				{
					case GET_CLASS:
					{
						BSTR strClass = SysAllocString(pszClass);
						IWbemClassObject *pClass = NULL;
						for(DWORD j=0; j<dwMaxOuterIterations; j++)
						{
							for(DWORD i=0; i<dwMaxInnerIterations; i++)
							{

								if(SUCCEEDED(result = pServices->GetObject(strClass, 0, NULL, &pClass, NULL)))
								{
									wprintf(L"GetClass succeeded for iteration (%d,%d) \n", j, i);
									pClass->Release();
									pClass = NULL;
								}
								else
									wprintf(L"GetClass FAILED for iteration (%d, %d) with %x\n", j, i, result);

							}
							wprintf(L"Sleeping for %d seconds ...\n", dwSleepSeconds);
							Sleep(1000*dwSleepSeconds);
						}
						SysFreeString(strClass);
						break;
					}
					case ENUM_CLASS:
					{
						BSTR strClass = SysAllocString(pszClass);
						IEnumWbemClassObject  *pClassEnum = NULL;
						IWbemClassObject *pClass = NULL;
						ULONG lCount; 
						ULONG lRetreivedCount; 
						for(DWORD j=0; j<dwMaxOuterIterations; j++)
						{
							for(DWORD i=0; i<dwMaxInnerIterations; i++)
							{
								if(SUCCEEDED(result = pServices->CreateClassEnum(strClass, lEnumerationType, NULL, &pClassEnum)))
								{
									lRetreivedCount = 0;
									wprintf(L"Enumerate Classes succeeded for iteration (%d, %d) \n", j, i);
									while(SUCCEEDED(pClassEnum->Next(WBEM_INFINITE, 1, &pClass, &lCount)) && lCount == 1)
									{
										lRetreivedCount ++;
										pClass->Release();
										pClass = NULL;
									}
									wprintf(L"Enumerate Classes Retreived %d classes for iteration (%d, %d) \n", lRetreivedCount, j, i);
									pClassEnum->Release();
									pClassEnum = NULL;
								}
								else
									wprintf(L"Enumerate Classes FAILED for iteration (%d, %d) with %x\n", j, i, result);

							}
							wprintf(L"Sleeping for %d seconds ...\n", dwSleepSeconds);
							Sleep(1000*dwSleepSeconds);
						}
						SysFreeString(strClass);
						break;
					}

					case GET_INSTANCE:
					{
						BSTR strClass = SysAllocString(pszInstance);
						IWbemClassObject *pClass = NULL;
						for(DWORD j=0; j<dwMaxOuterIterations; j++)
						{
							for(DWORD i=0; i<dwMaxInnerIterations; i++)
							{
								DWORD dwInit = GetTickCount();

								if(SUCCEEDED(result = pServices->GetObject(strClass, 0, NULL, &pClass, NULL)))
								{
									wprintf(L"GetInstance succeeded for iteration (%d,%d) after %d secs\n", j, i, GetTickCount()-dwInit);
									pClass->Release();
									pClass = NULL;
								}
								else
									wprintf(L"GetClass FAILED for iteration (%d, %d) with %x\n", j, i, result);

							}
							wprintf(L"Sleeping for %d seconds ...\n", dwSleepSeconds);
							Sleep(1000*dwSleepSeconds);
						}
						SysFreeString(strClass);
						break;
					}
					case ENUM_INSTANCE:
					{
						BSTR strClass = SysAllocString(pszClass);
						IEnumWbemClassObject  *pClassEnum = NULL;
						IWbemClassObject *pClass = NULL;
						ULONG lCount; 
						ULONG lRetreivedCount; 
						for(DWORD j=0; j<dwMaxOuterIterations; j++)
						{
							for(DWORD i=0; i<dwMaxInnerIterations; i++)
							{
								if(SUCCEEDED(result = pServices->CreateInstanceEnum(strClass, lEnumerationType, NULL, &pClassEnum)))
								{
									lRetreivedCount = 0;
									wprintf(L"Enumerate Instances succeeded for iteration (%d, %d) \n", j, i);
									while(SUCCEEDED(pClassEnum->Next(WBEM_INFINITE, 1, &pClass, &lCount)) && lCount == 1)
									{
										lRetreivedCount ++;
										pClass->Release();
										pClass = NULL;
									}
									wprintf(L"Enumerate Instances Retreived %d instances for iteration (%d, %d) \n", lRetreivedCount, j, i);
									pClassEnum->Release();
									pClassEnum = NULL;
								}
								else
									wprintf(L"Enumerate Instances FAILED for iteration (%d, %d) with %x\n", j, i, result);

							}
							wprintf(L"Sleeping for %d seconds ...\n", dwSleepSeconds);
							Sleep(1000*dwSleepSeconds);
						}
						SysFreeString(strClass);
						break;
					}
				}
				pServices->Release();
			}
			else
				wprintf(L"ConnectServer on locator failed %x\n", result);
			pLocator->Release();
		}
		else
			wprintf(L"CoCreate on locator failed %x\n", result);
	}
	else
		wprintf(L"CoIntialize or CoInitializeSecurity() failed with %x\n", result);

	if(SUCCEEDED(result))
		return 0;
	else
		return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\classprovider\dscpguid.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile: guids.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
//	Description: This file is used to generate definitions of the GUIDs in the project
//
// ***************************************************************************

#include <objbase.h>
#include <initguid.h>

#include "dscpguid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\adsitest\testperf\main2.cpp ===
#include <tchar.h>
#include <windows.h>
#include <activeds.h>

#include <stdio.h>
int main(int argc, char *argv)
{
	if(argc != 2)
	{
		printf("USAGE: testperf <ADSIPath\n");
		return 0;
	}

	LPTSTR lpszCommandLine = GetCommandLine();
	LPWSTR * lppszCommandArgs = CommandLineToArgvW(lpszCommandLine, &argc);

	IDirectoryObject *pDirectoryObject = NULL;

	HRESULT result;
	if(SUCCEEDED(CoInitialize(NULL)))
	{
		if(SUCCEEDED(result = ADsGetObject(lppszCommandArgs[1], IID_IDirectoryObject, (LPVOID *)&pDirectoryObject)))
		{
			printf("Call Succeeded. Waiting Forever ...\n");
			pDirectoryObject->Release();
			CoFreeUnusedLibraries();
			for(int i=0; i<60; i++)
				Sleep(1000*60);
			printf("Exiting\n");
		}
		else
			printf("ADsGetObject() Call FAILED on %s with %x\n", lppszCommandArgs[1], result);
	}
	else
		printf("CoInitialize() Call FAILED with %x\n", result);

	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\adsitest\testregsvr\main.cpp ===
#include <tchar.h>
#include <windows.h>
#include <stdio.h>

#include <shellapi.h>

int main(int argc, char *argv)
{
	LPTSTR lpszCommandLine = GetCommandLine();
	LPWSTR * lppszCommandArgs = CommandLineToArgvW(lpszCommandLine, &argc);

	HINSTANCE hLibrary = LoadLibrary(lppszCommandArgs[1]);

	if(hLibrary == NULL)
	{
		LPTSTR lpszMessage;
		DWORD dwStatus = FormatMessage( 
			FORMAT_MESSAGE_ALLOCATE_BUFFER | 			FORMAT_MESSAGE_FROM_SYSTEM, 
			NULL, 
			GetLastError(), 
			0, 
			(LPTSTR)(LPVOID )&lpszMessage, 
			250, 
			NULL); 

		_tprintf(__TEXT("%s\n"), lpszMessage);
		return 1;
	}
	else
		_tprintf(__TEXT("Load Library Succeeded on %s\n"), lppszCommandArgs[1]);

	return 0;

	

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\ansi\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\classprovider\assocprov.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:classpro.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains implementation of the DS Class Associations Provider class. 
//
//***************************************************************************

#include <tchar.h>
#include <stdio.h>

#include <windows.h>
#include <objbase.h>
#include <comdef.h>

/* WBEM includes */
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include <sqllex.h>
#include <sql_1.h>
#include <wbemcli.h>
#include <wbemprov.h>
#include <cominit.h>

/* ADSI includes */
#include <activeds.h>

/* DS Provider includes */
#include "attributes.h"
#include "provlog.h"
#include "maindll.h"
#include "dscpguid.h"
#include "refcount.h"
#include "adsiclas.h"
#include "adsiinst.h"
#include "ldaphelp.h"
#include "assocprov.h"
#include "wbemhelp.h"

/////////////////////////////////////////
// Initialize the static members
/////////////////////////////////////////
LPCWSTR CLDAPClassAsssociationsProvider :: s_LogFileName			= L"wbem\\logs\\ldapascl.txt";
LPCWSTR CLDAPClassAsssociationsProvider :: CHILD_CLASS_PROPERTY		= L"ChildClass";
LPCWSTR CLDAPClassAsssociationsProvider :: PARENT_CLASS_PROPERTY	= L"ParentClass";
LPCWSTR CLDAPClassAsssociationsProvider :: POSSIBLE_SUPERIORS		= L"PossibleSuperiors";
LPCWSTR CLDAPClassAsssociationsProvider :: SCHEMA_NAMING_CONTEXT	= L"schemaNamingContext";
LPCWSTR CLDAPClassAsssociationsProvider :: LDAP_SCHEMA				= L"LDAP://Schema";	
LPCWSTR CLDAPClassAsssociationsProvider :: LDAP_SCHEMA_SLASH		= L"LDAP://Schema/";	

//***************************************************************************
//
// CLDAPClassAsssociationsProvider::CLDAPClassAsssociationsProvider
// CLDAPClassAsssociationsProvider::~CLDAPClassAsssociationsProvider
//
// Constructor Parameters:
//
//  
//***************************************************************************

CLDAPClassAsssociationsProvider :: CLDAPClassAsssociationsProvider (ProvDebugLog *pLogObject)
{
	InterlockedIncrement(&g_lComponents);

	m_lReferenceCount = 0 ;
	m_IWbemServices = NULL;
	m_pAssociationClass = NULL;
	m_pLogObject = pLogObject;

	m_lpszSchemaContainerSuffix = NULL;
	m_pDirectorySearchSchemaContainer = NULL;
	m_bInitializedSuccessfully = FALSE;

	CHILD_CLASS_PROPERTY_STR = SysAllocString(CHILD_CLASS_PROPERTY);
	PARENT_CLASS_PROPERTY_STR = SysAllocString(PARENT_CLASS_PROPERTY);
	CLASS_ASSOCIATION_CLASS_STR = SysAllocString(CLASS_ASSOCIATION_CLASS);
	POSSIBLE_SUPERIORS_STR = SysAllocString(POSSIBLE_SUPERIORS);
}

CLDAPClassAsssociationsProvider::~CLDAPClassAsssociationsProvider ()
{
	m_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: DESTRUCTOR\r\n");

	InterlockedDecrement(&g_lComponents);

	if(m_IWbemServices)
		m_IWbemServices->Release();

	if(m_pDirectorySearchSchemaContainer)
		m_pDirectorySearchSchemaContainer->Release();

	if(m_pAssociationClass)
		m_pAssociationClass->Release();

	delete [] m_lpszSchemaContainerSuffix;

	SysFreeString(CHILD_CLASS_PROPERTY_STR);
	SysFreeString(PARENT_CLASS_PROPERTY_STR);
	SysFreeString(CLASS_ASSOCIATION_CLASS_STR);
	SysFreeString(POSSIBLE_SUPERIORS_STR);
}

//***************************************************************************
//
// CLDAPClassAsssociationsProvider::QueryInterface
// CLDAPClassAsssociationsProvider::AddRef
// CLDAPClassAsssociationsProvider::Release
//
// Purpose: Standard COM routines needed for all COM objects
//
//***************************************************************************

STDMETHODIMP CLDAPClassAsssociationsProvider :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) (IUnknown *)(IWbemProviderInit *)this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) (IWbemServices *)this ;		
	}	
	else if ( iid == IID_IWbemProviderInit )
	{
		*iplpv = ( LPVOID ) (IWbemProviderInit *)this ;		
	}	
	else
	{
		return E_NOINTERFACE;
	}

	( ( LPUNKNOWN ) *iplpv )->AddRef () ;
	return  S_OK;
}


STDMETHODIMP_( ULONG ) CLDAPClassAsssociationsProvider :: AddRef ()
{
	return InterlockedIncrement ( & m_lReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CLDAPClassAsssociationsProvider :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_lReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}


HRESULT CLDAPClassAsssociationsProvider :: Initialize( 
        LPWSTR wszUser,
        LONG lFlags,
        LPWSTR wszNamespace,
        LPWSTR wszLocale,
        IWbemServices __RPC_FAR *pNamespace,
        IWbemContext __RPC_FAR *pCtx,
        IWbemProviderInitSink __RPC_FAR *pInitSink)
{

	// Validate the arguments
	if(pNamespace == NULL || lFlags != 0)
	{
		m_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: Argument validation FAILED\r\n");
		pInitSink->SetStatus(WBEM_E_FAILED, 0);
		return WBEM_S_NO_ERROR;
	}

	// Store the IWbemServices pointer for future use
	m_IWbemServices = pNamespace;
	m_IWbemServices->AddRef();
		
	// Do LDAP Provider initialization
	if(!InitializeAssociationsProvider(pCtx))
	{
		m_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: InitializeAssociationsProvider FAILED\r\n");
		m_IWbemServices->Release();
		m_IWbemServices = NULL;
		m_bInitializedSuccessfully = FALSE;
	}
	else
		m_bInitializedSuccessfully = TRUE;

	pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
	return WBEM_S_NO_ERROR;
}

HRESULT CLDAPClassAsssociationsProvider :: OpenNamespace( 
    /* [in] */ const BSTR strNamespace,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: CancelAsyncCall( 
    /* [in] */ IWbemObjectSink __RPC_FAR *pSink)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: QueryObjectSink( 
    /* [in] */ long lFlags,
    /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: GetObject( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: GetObjectAsync( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{

	if(!m_bInitializedSuccessfully)
	{
		m_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: Initialization status is FAILED, hence returning failure\n");
		return WBEM_E_FAILED;
	}

	m_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: GetObjectAsync() called for %s \r\n", strObjectPath);

	HRESULT result = S_OK;

	// Impersonate the client
	if(!SUCCEEDED(result = WbemCoImpersonateClient()))
	{
		m_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: GetObjectAsync() CoImpersonate FAILED for %s with %x\r\n", strObjectPath, result);
		return WBEM_E_FAILED;
	}

	// Validate the arguments
	if(strObjectPath == NULL || lFlags != 0) 
	{
		m_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: GetObjectAsync() argument validation FAILED\r\n");
		return WBEM_E_INVALID_PARAMETER;
	}

	// Parse the object path
	CObjectPathParser theParser;
	ParsedObjectPath *theParsedObjectPath = NULL;
	switch(theParser.Parse(strObjectPath, &theParsedObjectPath))
	{
		case CObjectPathParser::NoError:
			break;
		default:
			m_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: GetObjectAsync() object path parsing FAILED\r\n");
			return WBEM_E_INVALID_PARAMETER;
	}

	// Check whether there are exactly 2 keys specified
	if(theParsedObjectPath->m_dwNumKeys != 2)
		result = WBEM_E_INVALID_PARAMETER;

	// Check whether these keys are 
	KeyRef *pChildKeyRef = *(theParsedObjectPath->m_paKeys);
	KeyRef *pParentKeyRef = *(theParsedObjectPath->m_paKeys + 1);

	if(_wcsicmp(pChildKeyRef->m_pName, CHILD_CLASS_PROPERTY) != 0)
	{
		// Exchange them
		KeyRef *temp = pChildKeyRef;
		pChildKeyRef = pParentKeyRef;
		pParentKeyRef = pChildKeyRef;
	}

	// The status on the sink
	IWbemClassObject *ppReturnWbemClassObjects[1];
	ppReturnWbemClassObjects[0] = NULL;

	if(SUCCEEDED(result))
	{
		if(SUCCEEDED(result = IsContainedIn(pChildKeyRef->m_vValue.bstrVal, pParentKeyRef->m_vValue.bstrVal)))
		{
			if(result == S_OK)
			{
				if(SUCCEEDED(result = CreateInstance(pChildKeyRef->m_vValue.bstrVal, pParentKeyRef->m_vValue.bstrVal, ppReturnWbemClassObjects)))
				{
					result = pResponseHandler->Indicate(1, ppReturnWbemClassObjects);
					ppReturnWbemClassObjects[0]->Release();
				}

			}
			else // the instance was not found
			{
				m_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: returning WBEM_E_NOT_FOUND for %s \r\n", strObjectPath);
				result = WBEM_E_NOT_FOUND;
			}
		}
		else
		{
			m_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: IsContainedIn() FAILED with %x \r\n", result);
		}
	}

	// Free the parser object path
	theParser.Free(theParsedObjectPath);

	// Set the status of the request
	result = (SUCCEEDED(result)? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND);
	pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE , result, NULL, NULL);
	
	return result;
}

HRESULT CLDAPClassAsssociationsProvider :: PutClass( 
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: PutClassAsync( 
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: DeleteClass( 
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: DeleteClassAsync( 
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: CreateClassEnum( 
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: CreateClassEnumAsync( 
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: PutInstance( 
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: PutInstanceAsync( 
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: DeleteInstance( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: DeleteInstanceAsync( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: CreateInstanceEnum( 
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: CreateInstanceEnumAsync( 
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	if(!m_bInitializedSuccessfully)
	{
		m_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: Initialization status is FAILED, hence returning failure\n");
		return WBEM_E_FAILED;
	}

	m_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: CreateInstanceEnumAsync() called\r\n");

	HRESULT result = S_OK;

	// Impersonate the client
	if(!SUCCEEDED(result = WbemCoImpersonateClient()))
	{
		m_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: CreateInstanceEnumAsync() CoImpersonate FAILED with %x\r\n", result);
		return WBEM_E_FAILED;
	}

	// Get all the ADSI classes 
	result = DoEnumeration(pResponseHandler);

			
	if(SUCCEEDED(result))
	{
		pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_S_NO_ERROR, NULL, NULL);
		m_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: CreateInstanceEnumAsync()  enumeration succeeded\r\n");
		return WBEM_S_NO_ERROR;
	}
	else
	{
		pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_E_FAILED, NULL, NULL);
		m_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: CreateInstanceEnumAsync() enumeration FAILED\r\n");
		return WBEM_E_FAILED;
	}	
	
	return result;
}

HRESULT CLDAPClassAsssociationsProvider :: ExecQuery( 
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: ExecQueryAsync( 
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

HRESULT CLDAPClassAsssociationsProvider :: ExecNotificationQuery( 
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: ExecNotificationQueryAsync( 
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: ExecMethod( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPClassAsssociationsProvider :: ExecMethodAsync( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}


//***************************************************************************
//
// CLDAPClassAsssociationsProvider::IsContainedIn
//
// Purpose: Checks whether a containment is valid
//
// Parameters: 
//	lpszChildClass : The WBEM Name of the child class
//	lpszParentClass : The WBEM Name of the parent class
//
// Return Value: The COM status of the request
//
//***************************************************************************
HRESULT CLDAPClassAsssociationsProvider :: IsContainedIn(LPCWSTR lpszChildClass, LPCWSTR lpszParentClass)
{
	LPWSTR lpszLDAPChildClass = NULL;
	LPWSTR lpszLDAPParentClass = NULL;
	lpszLDAPChildClass = CLDAPHelper::UnmangleWBEMNameToLDAP(lpszChildClass);
	lpszLDAPParentClass = CLDAPHelper::UnmangleWBEMNameToLDAP(lpszParentClass);

	// Check whether these are valid names
	if(!lpszLDAPChildClass || !lpszLDAPParentClass)
	{
		delete [] lpszLDAPChildClass;
		delete [] lpszLDAPParentClass;
		return S_FALSE;
	}

	LPWSTR lpszADSIAbstractSchemaPath = new WCHAR[wcslen(LDAP_SCHEMA_SLASH) + wcslen(lpszLDAPChildClass) + 1];
	wcscpy(lpszADSIAbstractSchemaPath, LDAP_SCHEMA_SLASH);
	wcscat(lpszADSIAbstractSchemaPath, lpszLDAPChildClass);

	IADsClass *pADsChildClass;
	HRESULT result;
	if(SUCCEEDED(result = ADsOpenObject(lpszADSIAbstractSchemaPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IADsClass, (LPVOID *) &pADsChildClass)))
	{
		// Get the POSSIBLE_SUPERIORS_STR property. This property contains the possible superiors
		VARIANT variant;
		VariantInit(&variant);
		if(SUCCEEDED(result = pADsChildClass->get_PossibleSuperiors(&variant)))
		{
			// Check the lone possible superior
			if(variant.vt == VT_BSTR)
			{
				if(_wcsicmp(variant.bstrVal, lpszLDAPParentClass) == 0)
					result = S_OK;
				else
					result = S_FALSE;
			}
			else
			{
				// Go thru the list of possible superiorsV
				SAFEARRAY *pSafeArray = variant.parray;
				LONG lNumber = 0;
				VARIANT vTmp;
				if(SUCCEEDED(result = SafeArrayGetUBound(pSafeArray, 1, &lNumber)) )
				{
					result = S_FALSE;
					for(LONG index=0L; index<=lNumber; index++)
					{
						if(SUCCEEDED(SafeArrayGetElement(pSafeArray, &index, &vTmp) ))
						{
							if(_wcsicmp(vTmp.bstrVal, lpszLDAPParentClass) == 0)
							{
								result = S_OK;
							}
							VariantClear(&vTmp);
							if(result == S_OK)
								break;
						}
					}
				}
			}

			VariantClear(&variant);
		}
		pADsChildClass->Release();
	}

	delete [] lpszLDAPChildClass;
	delete [] lpszLDAPParentClass;
	delete [] lpszADSIAbstractSchemaPath;

	return result;
}

//***************************************************************************
//
// CLDAPClassAsssociationsProvider::InitializeAssociationsProvider
//
// Purpose: A helper function to do the ADSI LDAP provider specific initialization.
//
// Parameters:
//		pCtx	The context object used in this call initialization
// 
// Return Value: TRUE if the function successfully finishes the initializaion. FALSE
//	otherwise
//***************************************************************************
BOOLEAN CLDAPClassAsssociationsProvider :: InitializeAssociationsProvider(IWbemContext *pCtx)
{
	// Get the class for which instances are provided by the provider
	HRESULT result = m_IWbemServices->GetObject(CLASS_ASSOCIATION_CLASS_STR, 0, pCtx, &m_pAssociationClass, NULL);
	if(SUCCEEDED(result))
	{
		// Get the ADSI path of the schema container and store it for future use
		IADs *pRootDSE = NULL;
		if(SUCCEEDED(result = ADsOpenObject((LPWSTR)ROOT_DSE_PATH, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IADs, (LPVOID *) &pRootDSE)))
		{
			// Get the location of the schema container
			BSTR strSchemaPropertyName = SysAllocString((LPWSTR) SCHEMA_NAMING_CONTEXT);

			// Get the schemaNamingContext property. This property contains the ADSI path
			// of the schema container
			VARIANT variant;
			VariantInit(&variant);
			if(SUCCEEDED(result = pRootDSE->Get(strSchemaPropertyName, &variant)))
			{
				// Store the ADSI path to the schema container
				m_lpszSchemaContainerSuffix = new WCHAR[wcslen(variant.bstrVal) + 1];
				wcscpy(m_lpszSchemaContainerSuffix, variant.bstrVal );
				m_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: Got Schema Container as : %s\r\n", m_lpszSchemaContainerSuffix);

				// Form the schema container path
				LPWSTR lpszSchemaContainerPath = new WCHAR[wcslen(LDAP_PREFIX) + wcslen(m_lpszSchemaContainerSuffix) + 1];
				wcscpy(lpszSchemaContainerPath, LDAP_PREFIX);
				wcscat(lpszSchemaContainerPath, m_lpszSchemaContainerSuffix);
				if(SUCCEEDED(result = ADsOpenObject(lpszSchemaContainerPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectorySearch, (LPVOID *) &m_pDirectorySearchSchemaContainer)))
				{
					m_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: Got IDirectorySearch on Schema Container \r\n");
				}
				else
					m_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: FAILED to get IDirectorySearch on Schema Container : %x\r\n", result);

				delete[] lpszSchemaContainerPath;
			}
			else
				m_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: Get on RootDSE FAILED : %x\r\n", result);

			SysFreeString(strSchemaPropertyName);
			VariantClear(&variant);
			pRootDSE->Release();
		}
		else
			m_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: InitializeLDAPProvider ADsOpenObject on RootDSE FAILED : %x\r\n", result);
	}
	else
		m_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: InitializeLDAPProvider GetClass on LDAP Association class FAILED : %x\r\n", result);

	return SUCCEEDED(result);
}

HRESULT CLDAPClassAsssociationsProvider :: DoEnumeration(IWbemObjectSink *pResponseHandler)
{
	HRESULT result = E_FAIL;

	// Get the IADsContainer interface on the schema container
	IADsContainer *pADsContainer = NULL;
	IUnknown *pChild = NULL;

	// An instance of the association
	IWbemClassObject *pInstance = NULL;

	if(SUCCEEDED(result = ADsOpenObject((LPWSTR)LDAP_SCHEMA, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IADsContainer, (LPVOID *) &pADsContainer)))
	{
		IEnumVARIANT *pEnum = NULL;
		if(SUCCEEDED(result = ADsBuildEnumerator(pADsContainer, &pEnum)))
		{
			IADsClass *pADsChildClass = NULL;
			VARIANT v;
			VariantInit(&v);
			while (SUCCEEDED(result = ADsEnumerateNext(pEnum, 1, &v, NULL)) && result != S_FALSE)
			{
				pChild = v.punkVal;
				if(SUCCEEDED(result = pChild->QueryInterface(IID_IADsClass, (LPVOID *) &pADsChildClass)))
				{
					BSTR strChildClassName;
					if(SUCCEEDED(result = pADsChildClass->get_Name(&strChildClassName)))
					{
						// Mangle the name to WBEM
						LPWSTR szChildName = CLDAPHelper::MangleLDAPNameToWBEM(strChildClassName);
						VARIANT variant;
						VariantInit(&variant);
						if(SUCCEEDED(result = pADsChildClass->get_PossibleSuperiors(&variant)))
						{
							// Check the lone possible superior
							if(variant.vt == VT_BSTR)
							{
								LPWSTR szParentName = CLDAPHelper::MangleLDAPNameToWBEM(variant.bstrVal);
								if(SUCCEEDED(result = CreateInstance(szChildName, szParentName, &pInstance)))
								{
									pResponseHandler->Indicate(1, &pInstance);
									pInstance->Release();
								}
								delete [] szParentName;
							}
							else // It is an array of variants
							{
								// Go thru the list of possible superiorsV
								SAFEARRAY *pSafeArray = variant.parray;
								VARIANT HUGEP *pVar;
								LONG lUbound = 0, lLbound = 0;
								if(SUCCEEDED(result = SafeArrayAccessData(pSafeArray, (void HUGEP* FAR*)&pVar) ) )
								{
									if( SUCCEEDED (result = SafeArrayGetLBound(pSafeArray, 1, &lLbound)) &&
										SUCCEEDED (result = SafeArrayGetUBound(pSafeArray, 1, &lUbound)) )
									{
										for(LONG index=lLbound; index<=lUbound; index++)
										{
											LPWSTR szParentName = CLDAPHelper::MangleLDAPNameToWBEM(pVar[index].bstrVal);
											if(SUCCEEDED(result = CreateInstance(szChildName, szParentName, &pInstance)))
											{
												pResponseHandler->Indicate(1, &pInstance);
												pInstance->Release();
											}
											delete [] szParentName;
										}
									}
									SafeArrayUnaccessData(pSafeArray);
								}
							}
							VariantClear(&variant);
						}
						delete [] szChildName;
						SysFreeString(strChildClassName);
					}
					pADsChildClass->Release();
				}
				VariantClear(&v);
			}
			ADsFreeEnumerator(pEnum);
		}

		pADsContainer->Release();
	}
	else
		m_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: FAILED to get IDirectoryObject on Schema Container : %x\r\n", result);

	return result;

}

HRESULT CLDAPClassAsssociationsProvider :: CreateInstance(BSTR strChildName, BSTR strParentName, IWbemClassObject **ppInstance)
{
	HRESULT result = E_FAIL;
	*ppInstance = NULL;
	if(SUCCEEDED(result = m_pAssociationClass->SpawnInstance(0, ppInstance)))
	{
		// Put the property values
		if(SUCCEEDED(result = CWBEMHelper::PutBSTRProperty(*ppInstance, CHILD_CLASS_PROPERTY_STR, strChildName, FALSE)))
		{
			if(SUCCEEDED(result = CWBEMHelper::PutBSTRProperty(*ppInstance, PARENT_CLASS_PROPERTY_STR, strParentName, FALSE)))
			{
			}
			else
				m_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: CreateInstance() PutBSTRProperty on parent property FAILED %x \r\n", result);
		}
		else
			m_pLogObject->WriteW( L"CLDAPClassAsssociationsProvider :: CreateInstance() PutBSTRProperty on child property FAILED %x \r\n", result);
	}

	if(FAILED(result) && *ppInstance)
	{
		(*ppInstance)->Release();
		*ppInstance = NULL;
	}
	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\classprovider\classfac.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:classfac.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the implementation of the DS Class Provider factory.
// Currently it always creates the LDAP CLass Provider. It remains to be decided as to how this can
// be changed
//
//***************************************************************************

#include <stdio.h>
#include <tchar.h>

#include <windows.h>
#include <objbase.h>
#include <comdef.h>

/* WBEM includes */
#include <wbemcli.h>
#include <wbemprov.h>

/* ADSI includes */
#include <activeds.h>

/* DS Provider includes */
#include "attributes.h"
#include "clsname.h"
#include "provlog.h"
#include "maindll.h"
#include "provexpt.h"
#include "refcount.h"
#include "adsiprop.h"
#include "adsiclas.h"
#include "ldapproi.h"
#include "clsproi.h"
#include "classfac.h"
#include "dscpguid.h"
#include "tree.h"
#include "ldapcach.h"
#include "wbemcach.h"
#include "classpro.h"
#include "ldapprov.h"
#include "assocprov.h"

// Initializer objects required by the classes used by the DLL
CDSClassProviderInitializer *CDSClassProviderClassFactory::s_pDSClassProviderInitializer = NULL;
CLDAPClassProviderInitializer *CDSClassProviderClassFactory::s_pLDAPClassProviderInitializer = NULL;



//***************************************************************************
//
// CDSClassProviderClassFactory::CDSClassProviderClassFactory
// CDSClassProviderClassFactory::~CDSClassProviderClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CDSClassProviderClassFactory :: CDSClassProviderClassFactory ()
{
	m_ReferenceCount = 0 ;
	InterlockedIncrement(&g_lComponents);
}

CDSClassProviderClassFactory::~CDSClassProviderClassFactory ()
{
	InterlockedDecrement(&g_lComponents);
}

//***************************************************************************
//
// CDSClassProviderClassFactory::QueryInterface
// CDSClassProviderClassFactory::AddRef
// CDSClassProviderClassFactory::Release
//
// Purpose: Standard COM routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CDSClassProviderClassFactory::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IClassFactory )
	{
		*iplpv = ( LPVOID ) this ;		
	}	
	else
	{
		return E_NOINTERFACE;
	}

	( ( LPUNKNOWN ) *iplpv )->AddRef () ;
	return  S_OK;
}


STDMETHODIMP_( ULONG ) CDSClassProviderClassFactory :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CDSClassProviderClassFactory :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

//***************************************************************************
//
// CDSClassProviderClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CDSClassProviderClassFactory :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR * ppvObject
)
{
	HRESULT status = S_OK ;

	// We do not support aggregation
	if ( pUnkOuter )
	{
		status = CLASS_E_NOAGGREGATION ;
	}
	else 
	{
		// Check to see if the static members have been initialized
		// Create any initializer objects required for the classes
		EnterCriticalSection(&g_StaticsCreationDeletion);
		if(!s_pDSClassProviderInitializer)
		{
			try 
			{
				// Th Log Object might have been created by the CreateInstance() function for the other
				// providers (Instance/ Class Association)
				if(!g_pLogObject)
					g_pLogObject = new ProvDebugLog(DSPROVIDER);
				g_pLogObject->WriteW(L"CDSClassProviderClassFactory::CreateInstance() called\r\n");
				s_pDSClassProviderInitializer = new CDSClassProviderInitializer(g_pLogObject);
				s_pLDAPClassProviderInitializer = new CLDAPClassProviderInitializer(g_pLogObject);

			}
			catch(Heap_Exception e_HE)
			{
				delete g_pLogObject;
				g_pLogObject = NULL;
				delete s_pDSClassProviderInitializer;
				s_pDSClassProviderInitializer = NULL;
				delete s_pLDAPClassProviderInitializer;
				s_pLDAPClassProviderInitializer = NULL;
				status = E_OUTOFMEMORY ;
			}
		}
		LeaveCriticalSection(&g_StaticsCreationDeletion);

		if(SUCCEEDED(status))
		{
			CLDAPClassProvider *lpunk = NULL;
			try
			{
				lpunk = new CLDAPClassProvider(g_pLogObject);
				status = lpunk->QueryInterface ( riid , ppvObject ) ;
				if ( FAILED ( status ) )
				{
					delete lpunk ;
				}
			}
			catch(Heap_Exception e_HE)
			{
				delete lpunk ;
				status = E_OUTOFMEMORY ;
			}
		}
	}

	return status ;
}

//***************************************************************************
//
// CDSClassProviderClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CDSClassProviderClassFactory :: LockServer ( BOOL fLock )
{
	if ( fLock )
	{
		InterlockedIncrement ( & g_lServerLocks ) ;
	}
	else
	{
		InterlockedDecrement ( & g_lServerLocks ) ;
	}

	return S_OK	;
}



//***************************************************************************
//
// CDSClassAssociationsProviderClassFactory::CDSClassAssociationsProviderClassFactory
// CDSClassAssociationsProviderClassFactory::~CDSClassAssociationsProviderClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CDSClassAssociationsProviderClassFactory :: CDSClassAssociationsProviderClassFactory ()
{
	m_ReferenceCount = 0 ;
	InterlockedIncrement(&g_lComponents);
}

CDSClassAssociationsProviderClassFactory::~CDSClassAssociationsProviderClassFactory ()
{
	InterlockedDecrement(&g_lComponents);
}

//***************************************************************************
//
// CDSClassAssociationsProviderClassFactory::QueryInterface
// CDSClassAssociationsProviderClassFactory::AddRef
// CDSClassAssociationsProviderClassFactory::Release
//
// Purpose: Standard COM routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CDSClassAssociationsProviderClassFactory::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IClassFactory )
	{
		*iplpv = ( LPVOID ) this ;		
	}	
	else
	{
		return E_NOINTERFACE;
	}

	( ( LPUNKNOWN ) *iplpv )->AddRef () ;
	return  S_OK;
}


STDMETHODIMP_( ULONG ) CDSClassAssociationsProviderClassFactory :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CDSClassAssociationsProviderClassFactory :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

//***************************************************************************
//
// CDSClassAssociationsProviderClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CDSClassAssociationsProviderClassFactory :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR * ppvObject
)
{
	HRESULT status = S_OK ;

	// We do not support aggregation
	if ( pUnkOuter )
	{
		status = CLASS_E_NOAGGREGATION ;
	}
	else 
	{
		CLDAPClassAsssociationsProvider *lpunk = NULL;
		// Check to see if the static members have been initialized
		// Create any initializer objects required for the classes
		EnterCriticalSection(&g_StaticsCreationDeletion);
		try 
		{
			// This might have been created by the CreateInstance() function of the
			// other DS Providers (Class, ClassAssociation)
			if(!g_pLogObject)
				g_pLogObject = new ProvDebugLog(DSPROVIDER);
			g_pLogObject->WriteW(L"CDSClassAssociationsProviderClassFactory::CreateInstance() called\r\n");
			lpunk = new CLDAPClassAsssociationsProvider(g_pLogObject);
			status = lpunk->QueryInterface ( riid , ppvObject ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;
			}
		}
		catch(Heap_Exception e_HE)
		{
			delete g_pLogObject;
			g_pLogObject = NULL;
			delete lpunk;
			status = E_OUTOFMEMORY ;
		}
		LeaveCriticalSection(&g_StaticsCreationDeletion);
	}

	return status ;
}

//***************************************************************************
//
// CDSClassAssociationsProviderClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CDSClassAssociationsProviderClassFactory :: LockServer ( BOOL fLock )
{
	if ( fLock )
	{
		InterlockedIncrement ( & g_lServerLocks ) ;
	}
	else
	{
		InterlockedDecrement ( & g_lServerLocks ) ;
	}

	return S_OK	;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\classprovider\classpro.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:classpro.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains implementation of the DS Class Provider class. THis is the
// base class for all DS class providers
//
//***************************************************************************

#include <tchar.h>
#include <stdio.h>

#include <windows.h>
#include <objbase.h>
#include <comdef.h>

/* WBEM includes */
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include <wbemcli.h>
#include <wbemprov.h>
#include <cominit.h>

/* ADSI includes */
#include <activeds.h>

/* DS Provider includes */
#include "clsname.h"
#include "provlog.h"
#include "maindll.h"
#include "dscpguid.h"
#include "provexpt.h"
#include "refcount.h"
#include "tree.h"
#include "adsiprop.h"
#include "adsiclas.h"
#include "wbemcach.h"
#include "classpro.h"
#include "wbemhelp.h"


// Initialize the static members
BSTR CDSClassProvider :: CLASS_STR			= NULL;
CWbemCache *CDSClassProvider :: s_pWbemCache = NULL;

//***************************************************************************
//
// CDSClassProvider::CDSClassProvider
// CDSClassProvider::~CDSClassProvider
//
// Constructor Parameters:
//		lpLogFileName : The name of the file used for logging. The log file
//		name will be used in creating the log file path. The log file path
//		will be <SystemDirectory>\logFileName. Hence the logFileName may be relative
//		path. For exaple if this argument is specified as wbem\logs\dsprov.txt, then
//		the actual log file would be c:\winnt\system32\wbem\logs\dsprov.txt on a system
//		where the system directory is c:\winnt\system32
//
//  
//***************************************************************************

CDSClassProvider :: CDSClassProvider (ProvDebugLog *pLogObject)
{
	InterlockedIncrement(&g_lComponents);

	m_lReferenceCount = 0 ;
	m_IWbemServices = NULL;
	m_pLogObject = pLogObject;
	m_bInitializedSuccessfully = FALSE;
}

CDSClassProvider::~CDSClassProvider ()
{
	m_pLogObject->WriteW( L"CDSClassProvider :: DESTRUCTOR\r\n");

	InterlockedDecrement(&g_lComponents);

	if(m_IWbemServices)
	{
		m_IWbemServices->Release();
		m_IWbemServices = NULL;
	}

}

//***************************************************************************
//
// CDSClassProvider::QueryInterface
// CDSClassProvider::AddRef
// CDSClassProvider::Release
//
// Purpose: Standard COM routines needed for all COM objects
//
//***************************************************************************
STDMETHODIMP CDSClassProvider :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) (IUnknown *)(IWbemProviderInit *)this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) (IWbemServices *)this ;		
	}	
	else if ( iid == IID_IWbemProviderInit )
	{
		*iplpv = ( LPVOID ) (IWbemProviderInit *)this ;		
	}	
	else
	{
		return E_NOINTERFACE;
	}

	( ( LPUNKNOWN ) *iplpv )->AddRef () ;
	return  S_OK;
}


STDMETHODIMP_( ULONG ) CDSClassProvider :: AddRef ()
{
	return InterlockedIncrement ( & m_lReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CDSClassProvider :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_lReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}


HRESULT CDSClassProvider :: Initialize( 
        LPWSTR wszUser,
        LONG lFlags,
        LPWSTR wszNamespace,
        LPWSTR wszLocale,
        IWbemServices __RPC_FAR *pNamespace,
        IWbemContext __RPC_FAR *pCtx,
        IWbemProviderInitSink __RPC_FAR *pInitSink)
{
	// Validate the arguments
	if(m_pLogObject == NULL || pNamespace == NULL || lFlags != 0)
	{
		m_pLogObject->WriteW( L"CDSClassProvider :: Argument validation FAILED\r\n");
		pInitSink->SetStatus(WBEM_E_FAILED, 0);
		return WBEM_S_NO_ERROR;
	}

	// Store the IWbemServices pointer for future use
	m_IWbemServices = pNamespace;
	m_IWbemServices->AddRef();
		
	m_bInitializedSuccessfully = TRUE;
	pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
	return WBEM_S_NO_ERROR;
}

HRESULT CDSClassProvider :: OpenNamespace( 
    /* [in] */ const BSTR strNamespace,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: CancelAsyncCall( 
    /* [in] */ IWbemObjectSink __RPC_FAR *pSink)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: QueryObjectSink( 
    /* [in] */ long lFlags,
    /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: GetObject( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: GetObjectAsync( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	if(!m_bInitializedSuccessfully)
	{
		m_pLogObject->WriteW( L"CDSClassProvider :: Initialization status is FAILED, hence returning failure\r\n");
		return WBEM_E_FAILED;
	}

	// For exception handling
	//========================
	SetStructuredExceptionHandler seh;
	
	try 
	{
		if(!m_bInitializedSuccessfully)
		{
			m_pLogObject->WriteW( L"CDSClassProvider :: Initialization status is FAILED, hence returning failure\r\n");
			return WBEM_E_FAILED;
		}

		m_pLogObject->WriteW( L"CDSClassProvider :: GetObjectAsync() called for %s \r\n", strObjectPath);

		// Impersonate the client
		//=======================
		HRESULT result;
		if(!SUCCEEDED(result = WbemCoImpersonateClient()))
		{
			m_pLogObject->WriteW( L"CDSClassProvider :: GetObjectAsync() CoImpersonate FAILED for %s with %x\r\n", strObjectPath, result);
			return WBEM_E_FAILED;
		}

		// Validate the arguments
		//========================
		if(strObjectPath == NULL ) 
		{
			m_pLogObject->WriteW( L"CDSClassProvider :: GetObjectAsync() argument validation FAILED\r\n");
			return WBEM_E_INVALID_PARAMETER;
		}

		// Parse the object path
		//========================
		CObjectPathParser theParser;
		ParsedObjectPath *theParsedObjectPath = NULL;
		switch(theParser.Parse(strObjectPath, &theParsedObjectPath))
		{
			case CObjectPathParser::NoError:
				break;
			default:
				m_pLogObject->WriteW( L"CDSClassProvider :: GetObjectAsync() object path parsing FAILED\r\n");
				return WBEM_E_INVALID_PARAMETER;
		}

		// Check to see if it one of those classes that we know that dont provide
		//=======================================================================
		if(IsUnProvidedClass(theParsedObjectPath->m_pClass))
		{
			pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE , WBEM_E_NOT_FOUND, NULL, NULL);
		}
		else
		{
			IWbemClassObject *pReturnObject = NULL;
			if(SUCCEEDED(result = GetClassFromCacheOrADSI(theParsedObjectPath->m_pClass, &pReturnObject, pCtx)))
			{
				result = pResponseHandler->Indicate(1, &pReturnObject);
				pReturnObject->Release();
				pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE , WBEM_S_NO_ERROR, NULL, NULL);
			}
			else
			{
				m_pLogObject->WriteW( L"CDSClassProvider :: GetObjectAsync() GetClassFromCacheOrADSI FAILED for %s with %x\r\n", strObjectPath, result);
				pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE , WBEM_E_NOT_FOUND, NULL, NULL);
			}
		}

		// Delete the parser allocated structures
		//=======================================
		theParser.Free(theParsedObjectPath);

 }
	catch(Heap_Exception e_HE)
	{
		pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE , WBEM_E_OUT_OF_MEMORY, NULL, NULL);
	}

	return WBEM_S_NO_ERROR;

}

HRESULT CDSClassProvider :: PutClass( 
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: PutClassAsync( 
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: DeleteClass( 
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: DeleteClassAsync( 
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: CreateClassEnum( 
    /* [in] */ const BSTR strSuperclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: CreateClassEnumAsync( 
    /* [in] */ const BSTR strSuperclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: PutInstance( 
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: PutInstanceAsync( 
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: DeleteInstance( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: DeleteInstanceAsync( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: CreateInstanceEnum( 
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: CreateInstanceEnumAsync( 
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: ExecQuery( 
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: ExecQueryAsync( 
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: ExecNotificationQuery( 
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: ExecNotificationQueryAsync( 
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: ExecMethod( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CDSClassProvider :: ExecMethodAsync( 
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}



HRESULT CDSClassProvider :: GetClassFromCacheOrADSI(LPCWSTR pszWBEMClassName, 
	IWbemClassObject **ppWbemClassObject,
	IWbemContext *pCtx)
{
	HRESULT result = E_FAIL;
	// The algorithm is as follows:
	// Check whether the classname is present in the list of classes to which this user is granted access
	// If so
	//		See if is present in the WBEM Cache.
	//		If so return it.
	//		If not, get it from ADSI. 
	//			If successful Map it to WBEM class and add the WBEM class to the WBEM cache and return
	//			If not, if the return value is ACCESS_DENIED, remove it from the user's list
	// If not
	//		Get it from ADSI.
	//		if successful
	//			if it is not present in the cache map it to WBEM and add the WBEM class to the cache
	//			else discard it and return the WBEM class in the cache to the user
	//		else
	//			return error
	if(m_AccessAllowedClasses.IsNamePresent(pszWBEMClassName))
	{
		m_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() Found class in Authenticated list for %s\r\n", pszWBEMClassName);

		// Check the WBEM Cache to see if it there
		//=========================================
		CWbemClass *pWbemClass = NULL;

		if(SUCCEEDED(result = s_pWbemCache->GetClass(pszWBEMClassName, &pWbemClass)))
		{
			m_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() Found class in cache for %s\r\n", pszWBEMClassName);

			// Get the IWbemClassObject of the cache object
			IWbemClassObject *pCacheObject = pWbemClass->GetWbemClass();
			pWbemClass->Release();

			// Clone it
			if(!SUCCEEDED(result = pCacheObject->Clone(ppWbemClassObject)))
				m_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() Clone() FAILED : %x for %s\r\n", result, pszWBEMClassName);

			pCacheObject->Release();
		}
		else // Could not be found in cache. Go to ADSI
			//=========================================
		{
			m_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() Could not find class in cache for %s. Going to ADSI\r\n", pszWBEMClassName);

			IWbemClassObject *pNewObject = NULL;
			if(SUCCEEDED(result = GetClassFromADSI(pszWBEMClassName, pCtx, &pNewObject)))
			{

				// Add it to the cache
				pWbemClass = new CWbemClass(pszWBEMClassName, pNewObject);
				s_pWbemCache->AddClass(pWbemClass);
				pWbemClass->Release();
				m_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() Added %s to cache\r\n", pszWBEMClassName);
				
				// Clone it
				if(!SUCCEEDED(result = pNewObject->Clone(ppWbemClassObject)))
					m_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() Clone() FAILED : %x for %s\r\n", result, pszWBEMClassName);
				pNewObject->Release();
			}
			else 
			{
				m_AccessAllowedClasses.RemoveName(pszWBEMClassName);
				m_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() GetClassFromADSI() FAILED : %x. Removing %s from user list\r\n", result, pszWBEMClassName);
			}
		}
	}
	else // Get it from ADSI
		//=========================================
	{
		m_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() Could not find class in Authenticated list for %s. Going to ADSI\r\n", pszWBEMClassName);

		CWbemClass *pWbemClass = NULL;
		IWbemClassObject *pNewObject = NULL;

		if(SUCCEEDED(result = GetClassFromADSI(pszWBEMClassName, pCtx, &pNewObject)))
		{
			// Add it to the cache
			pWbemClass = new CWbemClass(pszWBEMClassName, pNewObject);
			s_pWbemCache->AddClass(pWbemClass);
			pWbemClass->Release();
			m_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() GetClassFromADSI succeeded for %s Added it to cache\r\n", pszWBEMClassName);
			
			// Clone it
			if(!SUCCEEDED(result = pNewObject->Clone(ppWbemClassObject)))
					m_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() Clone() FAILED : %x for %s\r\n", result, pszWBEMClassName);
			pNewObject->Release();

			// Add it to the list of classnames for this user
			m_AccessAllowedClasses.AddName(pszWBEMClassName);
			m_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() Also added to Authenticated list : %s \r\n", pszWBEMClassName);
		}
		else
			m_pLogObject->WriteW( L"CDSClassProvider :: GetClassFromCacheOrADSI() GetClassFromADSI FAILED : %x for %s\r\n", result, pszWBEMClassName);
	}

	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\classprovider\include\classfac.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:classfac.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the DS Class Provider class factory and
// the DS CLass Associations Provider class factory.
//
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef DS_CLASS_PROVIDER_CLASS_FACTORY_H
#define DS_CLASS_PROVIDER_CLASS_FACTORY_H


////////////////////////////////////////////////////////////////
//////
//////		The DS Class provider class factory
//////
///////////////////////////////////////////////////////////////
class CDSClassProviderClassFactory : public IClassFactory
{
private:

    long m_ReferenceCount ;

protected:
public:

	// Initializer objects required by the classes used by the DLL
	static CDSClassProviderInitializer *s_pDSClassProviderInitializer;
	static CLDAPClassProviderInitializer *s_pLDAPClassProviderInitializer;

    CDSClassProviderClassFactory () ;
    ~CDSClassProviderClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;

};

////////////////////////////////////////////////////////////////
//////
//////		The DS Class Associations provider class factory
//////
///////////////////////////////////////////////////////////////
class CDSClassAssociationsProviderClassFactory : public IClassFactory
{
private:

    long m_ReferenceCount ;

protected:
public:


    CDSClassAssociationsProviderClassFactory () ;
    ~CDSClassAssociationsProviderClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;
};


#endif // DS_CLASS_PROVIDER_CLASS_FACTORY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\classprovider\clsproi.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:clsproi.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains implementation of the class that is used to initialize the
//	CDSClassProvider class
//
//***************************************************************************

#include <tchar.h>
#include <stdio.h>

#include <windows.h>
#include <objbase.h>

/* WBEM includes */
#include <wbemcli.h>
#include <wbemprov.h>
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>

/* ADSI includes */
#include <activeds.h>

/* DS Provider includes */
#include "clsname.h"
#include "dscpguid.h"
#include "provlog.h"
#include "refcount.h"
#include "adsiprop.h"
#include "adsiclas.h"
#include "tree.h"
#include "wbemcach.h"
#include "classpro.h"
#include "clsproi.h"


//***************************************************************************
//
// CDSClassProviderInitializer::CDSClassProviderInitializer
//
// Constructor Parameters:
//		None
//
//  
//***************************************************************************

CDSClassProviderInitializer :: CDSClassProviderInitializer (ProvDebugLog *pLogObject)
{
	CDSClassProvider :: CLASS_STR				= SysAllocString(L"__CLASS");
	CDSClassProvider :: s_pWbemCache			= new CWbemCache(pLogObject);
}

//***************************************************************************
//
// CDSClassProviderInitializer::CDSClassProviderInitializer
//
// Destructor
//
//  
//***************************************************************************
CDSClassProviderInitializer :: ~CDSClassProviderInitializer ()
{
	delete CDSClassProvider::s_pWbemCache;
	SysFreeString(CDSClassProvider::CLASS_STR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\classprovider\ldapprov.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:ldapprov.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains implementation of the DS LDAP Class Provider class. 
//
//***************************************************************************

#include <tchar.h>
#include <stdio.h>

#include <windows.h>
#include <objbase.h>

/* WBEM includes */
#include <wbemcli.h>
#include <wbemprov.h>
#include <cominit.h>

/* ADSI includes */
#include <activeds.h>

/* DS Provider includes */
#include "clsname.h"
#include "attributes.h"
#include "dscpguid.h"
#include "provlog.h"
#include "provexpt.h"
#include "wbemhelp.h"
#include "refcount.h"
#include "adsiprop.h"
#include "adsiclas.h"
#include "adsiinst.h"
#include "ldaphelp.h"
#include "tree.h"
#include "ldapcach.h"
#include "wbemcach.h"
#include "classpro.h"
#include "ldapprov.h"

/////////////////////////////////////////
// Initialize the static members
/////////////////////////////////////////
CLDAPCache *CLDAPClassProvider :: s_pLDAPCache		= NULL;	
DWORD CLDAPClassProvider::dwClassProviderCount = 0;

BSTR CLDAPClassProvider:: LDAP_BASE_CLASS_STR			= NULL;
BSTR CLDAPClassProvider:: LDAP_CLASS_PROVIDER_NAME		= NULL;
BSTR CLDAPClassProvider:: LDAP_INSTANCE_PROVIDER_NAME	= NULL;

// Names of the LDAP class attributes
BSTR CLDAPClassProvider :: COMMON_NAME_ATTR_BSTR			= NULL;
BSTR CLDAPClassProvider :: LDAP_DISPLAY_NAME_ATTR_BSTR		= NULL;
BSTR CLDAPClassProvider :: GOVERNS_ID_ATTR_BSTR				= NULL;
BSTR CLDAPClassProvider :: SCHEMA_ID_GUID_ATTR_BSTR			= NULL;
BSTR CLDAPClassProvider :: MAPI_DISPLAY_TYPE_ATTR_BSTR		= NULL;
BSTR CLDAPClassProvider :: RDN_ATT_ID_ATTR_BSTR				= NULL;
BSTR CLDAPClassProvider :: SYSTEM_MUST_CONTAIN_ATTR_BSTR	= NULL;
BSTR CLDAPClassProvider :: MUST_CONTAIN_ATTR_BSTR			= NULL;
BSTR CLDAPClassProvider :: SYSTEM_MAY_CONTAIN_ATTR_BSTR		= NULL;
BSTR CLDAPClassProvider :: MAY_CONTAIN_ATTR_BSTR			= NULL;
BSTR CLDAPClassProvider :: SYSTEM_POSS_SUPERIORS_ATTR_BSTR	= NULL;
BSTR CLDAPClassProvider :: POSS_SUPERIORS_ATTR_BSTR			= NULL;
BSTR CLDAPClassProvider :: SYSTEM_AUXILIARY_CLASS_ATTR_BSTR	= NULL;
BSTR CLDAPClassProvider :: AUXILIARY_CLASS_ATTR_BSTR		= NULL;
BSTR CLDAPClassProvider :: DEFAULT_SECURITY_DESCRP_ATTR_BSTR= NULL;
BSTR CLDAPClassProvider :: OBJECT_CLASS_CATEGORY_ATTR_BSTR	= NULL;
BSTR CLDAPClassProvider :: SYSTEM_ONLY_ATTR_BSTR			= NULL;
BSTR CLDAPClassProvider :: NT_SECURITY_DESCRIPTOR_ATTR_BSTR	= NULL;
BSTR CLDAPClassProvider :: DEFAULT_OBJECTCATEGORY_ATTR_BSTR	= NULL;


// Names of the LDAP property attributes
BSTR CLDAPClassProvider :: ATTRIBUTE_SYNTAX_ATTR_BSTR	= NULL;
BSTR CLDAPClassProvider :: ATTRIBUTE_ID_ATTR_BSTR		= NULL;
BSTR CLDAPClassProvider :: MAPI_ID_ATTR_BSTR			= NULL;
BSTR CLDAPClassProvider :: OM_SYNTAX_ATTR_BSTR			= NULL;
BSTR CLDAPClassProvider :: RANGE_LOWER_ATTR_BSTR		= NULL;
BSTR CLDAPClassProvider :: RANGE_UPPER_ATTR_BSTR		= NULL;

// Qualifiers for embedded objects
BSTR CLDAPClassProvider :: CIMTYPE_STR			= NULL;
BSTR CLDAPClassProvider :: EMBED_UINT8ARRAY		= NULL;
BSTR CLDAPClassProvider :: EMBED_DN_WITH_STRING = NULL;
BSTR CLDAPClassProvider :: EMBED_DN_WITH_BINARY = NULL;


// Default Qualifier Flavour
LONG CLDAPClassProvider :: DEFAULT_QUALIFIER_FLAVOUR = WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS | WBEM_FLAVOR_OVERRIDABLE ;

// Names of WBEM Class Qualifiers
BSTR CLDAPClassProvider:: DYNAMIC_BSTR			= NULL;
BSTR CLDAPClassProvider:: PROVIDER_BSTR			= NULL;
BSTR CLDAPClassProvider:: ABSTRACT_BSTR			= NULL;

// Names of WBEM Property Qualifiers
BSTR CLDAPClassProvider :: SYSTEM_BSTR			= NULL;
BSTR CLDAPClassProvider :: NOT_NULL_BSTR		= NULL;
BSTR CLDAPClassProvider :: INDEXED_BSTR			= NULL;

// Names of WBEM properties
BSTR CLDAPClassProvider :: DYNASTY_BSTR			= NULL;

//***************************************************************************
//
// CLDAPClassProvider::CLDAPClassProvider
// CLDAPClassProvider::~CLDAPClassProvider
//
// Constructor Parameters:
//  None
//***************************************************************************

CLDAPClassProvider :: CLDAPClassProvider (ProvDebugLog *pLogObject)
: CDSClassProvider(pLogObject)
{
	// Initialize the search preferences often used
	m_searchInfo1.dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
	m_searchInfo1.vValue.Integer = ADS_SCOPE_ONELEVEL;
	m_searchInfo1.dwStatus = ADS_STATUS_S_OK;

	m_pLDAPBaseClass = NULL;
	dwClassProviderCount++;
}

CLDAPClassProvider::~CLDAPClassProvider ()
{
	m_pLogObject->WriteW( L"CLDAPClassProvider :: ~CLDAPClassProvider() Called\r\n");
	dwClassProviderCount --;
	if(m_pLDAPBaseClass)
		m_pLDAPBaseClass->Release();
}

//***************************************************************************
//
// CLDAPClassProvider::Initialize
//
// Purpose:
//		As defined by the IWbemProviderInit interface
//
// Parameters:
//		As defined by IWbemProviderInit interface
// 
//	Return Value: The COM status value indicating the status of the request
//***************************************************************************

HRESULT CLDAPClassProvider :: Initialize( 
        LPWSTR wszUser,
        LONG lFlags,
        LPWSTR wszNamespace,
        LPWSTR wszLocale,
        IWbemServices __RPC_FAR *pNamespace,
        IWbemContext __RPC_FAR *pCtx,
        IWbemProviderInitSink __RPC_FAR *pInitSink)
{

	// Validate the arguments
	if(m_pLogObject == NULL || pNamespace == NULL || lFlags != 0)
	{
		m_pLogObject->WriteW( L"CLDAPClassProvider :: Argument validation FAILED\r\n");
		pInitSink->SetStatus(WBEM_E_FAILED, 0);
		return WBEM_S_NO_ERROR;
	}

	m_pLogObject->WriteW( L"CLDAPClassProvider :: Initialize() Called\r\n");

	// Store the IWbemServices pointer for future use
	m_IWbemServices = pNamespace;
	m_IWbemServices->AddRef();


	// Do LDAP Provider initialization
	if(!InitializeLDAPProvider(pCtx))
	{
		m_pLogObject->WriteW( L"CLDAPClassProvider :: InitializeLDAPProvider FAILED\r\n");
		m_IWbemServices->Release();
		m_IWbemServices = NULL;

		// Do not set the status to failed for purposes of installation (MOFCOMP fails!)
		// Instead return a success but set an internal status value to FALSE
		// All operations should return FAILED if this internal status value is set to FALSE
		m_bInitializedSuccessfully = FALSE;
	}
	else
		m_bInitializedSuccessfully = TRUE;

	pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
	return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
// CLDAPClassProvider::InitializeLDAPProvider
//
// Purpose: A helper function to do the ADSI LDAP provider specific initialization.
//
// Parameters:
//		pCtx	The context object used in this call initialization
// 
// Return Value: TRUE if the function successfully finishes the initializaion. FALSE
//	otherwise
//***************************************************************************
BOOLEAN CLDAPClassProvider :: InitializeLDAPProvider(IWbemContext *pCtx)
{
	// Get the static classes used by the LDAP provider
	HRESULT result = WBEM_E_FAILED;
	if(SUCCEEDED(result = m_IWbemServices->GetObject(LDAP_BASE_CLASS_STR, 0, pCtx, &m_pLDAPBaseClass, NULL)))
	{
		result = (s_pLDAPCache->IsInitialized())? S_OK : E_FAIL;
	}
	else
		m_pLogObject->WriteW( L"CLDAPClassProvider :: InitializeLDAPProvider GetObject on base LDAP class FAILED : %x\r\n", result);

	return SUCCEEDED(result);
}		

//***************************************************************************
//
// CLDAPClassProvider::GetADSIClass
//
// Purpose : To Create a CADSIClass from an ADSI classSchema object
// Parameters:
//		lpszWBEMClassName : The WBEM Name of the class to be fetched. 
//		ppADSIClass : The address where the pointer to the CADSIClass will be stored.
//			It is the caller's responsibility to Release() the object when done with it
// 
//	Return Value: The COM status value indicating the status of the request.
//***************************************************************************
HRESULT CLDAPClassProvider :: GetADSIClass(LPCWSTR lpszADSIClassName, CADSIClass **ppADSIClass)
{
	// Convert the WBEM Class Name to LDAP
	LPWSTR lpszWBEMClassName = CLDAPHelper::MangleLDAPNameToWBEM(lpszADSIClassName);
	HRESULT result = s_pLDAPCache->GetClass(lpszWBEMClassName, lpszADSIClassName, ppADSIClass);

	delete[] lpszWBEMClassName;
	return result;
}

//***************************************************************************
//
// CLDAPClassProvider::GetADSIProperty
//
// Purpose : To create an CADSIProperty object from an LDAP AttributeSchema object
// Parameters:
//		lpszPropertyName : The LDAPDisplayName of the LDAP property to be fetched. 
//		ppADSIProperty : The address where the pointer to the IDirectoryObject interface will be stored
//			It is the caller's responsibility to Release() the interface when done with it
// 
//	Return Value: The COM status value indicating the status of the request
//***************************************************************************
HRESULT CLDAPClassProvider :: GetADSIProperty(LPCWSTR lpszPropertyName, CADSIProperty **ppADSIProperty)
{
	return s_pLDAPCache->GetProperty(lpszPropertyName, ppADSIProperty, FALSE);
}


//***************************************************************************
//
// CLDAPClassProvider::GetWBEMBaseClassName
//
// Purpose : Returns the name of the class that is the base class of all classes
//	provided by this provider.
//
// Parameters:
//	None
// 
//	Return Value: The name of the base class. NULL if such a class doesnt exist.
//***************************************************************************
const BSTR CLDAPClassProvider :: GetWBEMBaseClassName()
{
	return LDAP_BASE_CLASS_STR; 
}

//***************************************************************************
//
// CLDAPClassProvider::GetWBEMBaseClass
//
// Purpose : Returns a pointer to the class that is the base class of all classes
//	provided by this provider.
//
// Parameters:
//	None
// 
//	Return Value: The IWbemClassObject pointer to the base class. It is the duty of 
//	user to release the class when done with using it.
//***************************************************************************
IWbemClassObject * CLDAPClassProvider :: GetWBEMBaseClass()
{
	m_pLDAPBaseClass->AddRef();
	return m_pLDAPBaseClass;
}


//***************************************************************************
//
// CLDAPClassProvider::GetWBEMProviderName
//
// Purpose : Returns the name of the provider. This should be the same as the
// value of the field Name in the __Win32Provider instance used for registration
// of the provider
//
// Parameters:
//	None
// 
//	Return Value: The name of the provider
//***************************************************************************
const BSTR CLDAPClassProvider :: GetWBEMProviderName()
{
	return LDAP_CLASS_PROVIDER_NAME; 
}

//***************************************************************************
//
// CLDAPClassProvider::IsUnProvidedClass
//
// Purpose : See header
//***************************************************************************
BOOLEAN CLDAPClassProvider :: IsUnProvidedClass(LPCWSTR lpszClassName)
{
	// CHeck if it is one of the static classes
	if(_wcsicmp(lpszClassName, LDAP_BASE_CLASS_STR) == 0 ||
		_wcsicmp(lpszClassName, UINT8ARRAY_CLASS) == 0 ||
		_wcsicmp(lpszClassName, DN_WITH_STRING_CLASS) == 0 ||
		_wcsicmp(lpszClassName, DN_WITH_BINARY_CLASS) == 0 ||
		_wcsicmp(lpszClassName, ROOTDSE_CLASS) == 0 ||
		_wcsicmp(lpszClassName, CLASS_ASSOCIATION_CLASS) == 0 ||
		_wcsicmp(lpszClassName, DN_ASSOCIATION_CLASS) == 0 ||
		_wcsicmp(lpszClassName, DN_CLASS) == 0 ||
		_wcsicmp(lpszClassName, INSTANCE_ASSOCIATION_CLASS) == 0)
		return TRUE;

	// Next check if it has appropriate profixes
	if(_wcsnicmp(lpszClassName, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX_LENGTH) == 0 ||
		_wcsnicmp(lpszClassName, LDAP_CLASS_NAME_PREFIX, LDAP_CLASS_NAME_PREFIX_LENGTH) == 0 )
	{
		return FALSE;
	}

	return TRUE;
}

//***************************************************************************
//
// CLDAPClassProvider::GetClassFromADSI
//
// Purpose : To return the IDirectoryObject interface on the schema container
//
// Parameters:
//	lpszClassName : The WBEM Name of the class to be retreived
//	pCtx : A pointer to the context object that was used in this call. This
//		may be used by this function to make calls to CIMOM
//	ppWbemClass : The resulting WBEM Class. This has to be released once the
//		user is done with it.
//
// 
//	Return Value: The COM result representing the status. 
//***************************************************************************
HRESULT CLDAPClassProvider :: GetClassFromADSI( 
    LPCWSTR lpszWbemClassName,
    IWbemContext *pCtx,
	IWbemClassObject ** ppWbemClass
	)
{
	HRESULT result = E_FAIL;
	BOOLEAN bArtificialClass = FALSE;
	BOOLEAN bAbstractDSClass = FALSE;
	LPWSTR lpszADSIClassName = NULL;

	// First check if this is one our "artificial" classes. All "aritificial" classes start with "ads_".
	// All non artificial classes start with "ds_"
	if(!(lpszADSIClassName = CLDAPHelper::UnmangleWBEMNameToLDAP(lpszWbemClassName)))
	{
		*ppWbemClass = NULL;
		return result;
	}

	if(_wcsnicmp(lpszWbemClassName, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX_LENGTH) == 0)
		bArtificialClass = TRUE;

	CADSIClass *pADSIClass = NULL;
	CADSIClass *pADSIParentClass = NULL;

	if(SUCCEEDED(result = GetADSIClass(lpszADSIClassName, &pADSIClass)))
	{
		pADSIClass->SetWBEMClassName(lpszWbemClassName);

		// It is an abstract class is the ADSI class type is Abstract or Auxiliary
		if(pADSIClass->GetObjectClassCategory() == 2 || pADSIClass->GetObjectClassCategory() == 3) 
			bAbstractDSClass = TRUE;

		int iCaseNumber = 0;

		// if the WBEM class name starts with "ADS_" and the DS class is abstract, then this is an error
		if(bArtificialClass && bAbstractDSClass)
			result = WBEM_E_NOT_FOUND;
		else
		{
			// Special case for "top" since the DS returns top as the superclass of top
			if(_wcsicmp(lpszWbemClassName, TOP_CLASS) == 0)
				iCaseNumber = 1;
			else
			{
				if(pADSIClass->GetSuperClassLDAPName())
				{
					// If this is an artificial class
					// Then
					//		Get the ParentDS Class
					//		If the ParentDSClass is abstract 
					//		Then
					//			WMI Parent class is the non-artificial class. Case 2
					//		Else
					//			WMI Parent class is artificial. Case 3
					// Else
					//		If the Current DS Class is abstract
					//		Then
					//			WMI Parent is non-artificial. Case 4
					//		Else
					//			WMI Parent is artificial. Case 5
					//
					if(bArtificialClass)
					{
						// Get the parent DS Class
						if(SUCCEEDED(result = GetADSIClass(pADSIClass->GetSuperClassLDAPName(), &pADSIParentClass)))
						{
							if(pADSIParentClass->GetObjectClassCategory() == 2 || pADSIParentClass->GetObjectClassCategory() == 3) 
							{
								iCaseNumber = 2;
							}
							else
							{
								iCaseNumber = 3;
							}
						}
					}
					else
					{
						if(bAbstractDSClass)
						{
							iCaseNumber = 4;
						}
						else
						{
							iCaseNumber = 5;
						}
					}
				}
				else
					iCaseNumber = 1;
			}	
			
			// Map the ADSI class to a WBEM Class
			if(iCaseNumber != 0 && SUCCEEDED(result = CreateWBEMClass(pADSIClass, iCaseNumber, ppWbemClass,  pCtx)))
			{
			}
			else
			{
				result = WBEM_E_FAILED;
				m_pLogObject->WriteW(L"CLDAPClassProvider :: GetClassFromADSI() : CreateWBEMClass FAILED: %x for %s\r\n", result, lpszWbemClassName);
			}
		}

		// Free the parent ADSI class
		if(pADSIParentClass)
			pADSIParentClass->Release();

		// Free the ADSI Class
		pADSIClass->Release();
	}
	else
		m_pLogObject->WriteW( L"CLDAPClassProvider :: GetClassFromADSI() GetADSIClass FAILED : %x for %s\r\n", result, lpszWbemClassName);
	
	delete [] lpszADSIClassName;
	return result;
}


//***************************************************************************
//
// CLDAPClassProvider::CreateWBEMClass
//
// Purpose: Creates WBEM Class corresponding an ADSI Class
//
// Parameters:
//	pADSIClass : A pointer to a CADSI class object that is to be mapped to WBEM.
//	ppWbemClass : The WBEM class object retrieved. This is created by this function.
//		The caller should release it when done
//	pCtx : The context object that was used in this provider call
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CLDAPClassProvider :: CreateWBEMClass (CADSIClass *pADSIClass, int iCaseNumber, IWbemClassObject **ppWbemClass, IWbemContext *pCtx)
{
	HRESULT result;

	*ppWbemClass = NULL;

	// Create the WBEM class and Map the class qualifiers
	if( SUCCEEDED(result = MapClassSystemProperties(pADSIClass, iCaseNumber, ppWbemClass, pCtx) ) )
	{
		// Now that ppWbemClass has been allocated, we need to deallocate it if the return value of this function
		// is not a success
		//=======================================================================================================


		if(iCaseNumber == 5)
		{
			// Nothing more to do except add the "provider" qualifier
			IWbemQualifierSet *pQualifierSet = NULL;
			if(SUCCEEDED(result = (*ppWbemClass)->GetQualifierSet(&pQualifierSet)))
			{
				result = CWBEMHelper::PutBSTRQualifier(pQualifierSet, PROVIDER_BSTR, LDAP_INSTANCE_PROVIDER_NAME, DEFAULT_QUALIFIER_FLAVOUR, FALSE);
				pQualifierSet->Release();
			}
	
		}
		else
		{
			if( SUCCEEDED(result = MapClassQualifiersToWBEM(pADSIClass, iCaseNumber, *ppWbemClass, pCtx) ) )
			{
				// Map the  class properties 
				if( SUCCEEDED(result = MapClassPropertiesToWBEM(pADSIClass, *ppWbemClass, pCtx) ) )
				{
				}
				else
					m_pLogObject->WriteW( L"CLDAPClassProvider :: CreateWBEMClass() MapClassPropertiesToWBEM FAILED : %x for %s\r\n", result, pADSIClass->GetWBEMClassName());
			}
			else
				m_pLogObject->WriteW( L"CLDAPClassProvider :: CreateWBEMClass() MapClassQualifiersToWBEM FAILED : %x for %s\r\n", result, pADSIClass->GetWBEMClassName());
		}
	}
	else
		m_pLogObject->WriteW( L"CLDAPClassProvider :: CreateWBEMClass() MapClassSystemProperties FAILED : %x for %s\r\n", result, pADSIClass->GetWBEMClassName());

	if(!SUCCEEDED(result))
	{
		if(*ppWbemClass)
		{
			(*ppWbemClass)->Release();
			*ppWbemClass = NULL;
		}
	}

	return result;
}

//***************************************************************************
//
// CLDAPClassProvider::MapClassSystemProperties
//
// Purpose: Creates an appropriately derived WBEM class and names it (__CLASS)
//
// Parameters:
//	pADSIClass : The ADSI class that is being mapped
//	ppWbemClass : The WBEM class object retrieved. This is created by this function.
//		The caller should release it when done
//	pCtx : The context object that was used in this provider call
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CLDAPClassProvider :: MapClassSystemProperties(CADSIClass *pADSIClass, int iCaseNumber, IWbemClassObject **ppWbemClass, IWbemContext *pCtx)
{
	HRESULT result = WBEM_S_NO_ERROR;
	LPCWSTR lpszClassName = pADSIClass->GetWBEMClassName();

	// Create the WBEM class first.
	// This process depends on whether the ADSI class is derived from
	// another ADSI class or not. 
	// If so, that base class has to be retrieved and the derived class
	// to be spawned from that.
	// If not, then the function GetWBEMBaseClass() is called and the class 
	// being mapped is derived from that class

	IWbemClassObject *pBaseClass = NULL;
	if(iCaseNumber == 1)
	{
		pBaseClass = GetWBEMBaseClass();
	}
	else
	{
		LPWSTR lpszWBEMParentClassName = NULL;
		switch(iCaseNumber)
		{
			case 1:
				{
					pBaseClass = GetWBEMBaseClass();
					break;
				}
			case 2:
			case 4:
				{
					lpszWBEMParentClassName = CLDAPHelper::MangleLDAPNameToWBEM(pADSIClass->GetSuperClassLDAPName(), FALSE);
					break;
				}
			case 3:
				{
					lpszWBEMParentClassName = CLDAPHelper::MangleLDAPNameToWBEM(pADSIClass->GetSuperClassLDAPName(), TRUE);
					break;
				}
			case 5:
				{
					lpszWBEMParentClassName = CLDAPHelper::MangleLDAPNameToWBEM(pADSIClass->GetADSIClassName(), TRUE);
					break;
				}
			default:
				{
					result = WBEM_E_FAILED;
					break;
				}
		}

		if(SUCCEEDED(result))
		{
			BSTR strWBEMParentClass = SysAllocString(lpszWBEMParentClassName);		
			delete [] lpszWBEMParentClassName;
			// Get the parent WBEM Class
			if(FAILED(result = m_IWbemServices->GetObject(strWBEMParentClass, 0, pCtx, &pBaseClass, NULL)))
				m_pLogObject->WriteW( L"CLDAPClassProvider :: MapClassSystemProperties() GetObject on ADSI base class FAILED : %x for %s\r\n", result, strWBEMParentClass);
			SysFreeString(strWBEMParentClass);
		}
	}
	
	if(FAILED(result) || pBaseClass == NULL)
		return result;

	// Spawn the derived class
	result = pBaseClass->SpawnDerivedClass(0, ppWbemClass);
	pBaseClass->Release();
	if(SUCCEEDED(result))
	{
		// Create the __CLASS property
		// Make sure the case of the letters is not mixed up
		SanitizedClassName((LPWSTR)lpszClassName);
		if(SUCCEEDED(result = CWBEMHelper::PutBSTRProperty(*ppWbemClass, CLASS_STR, SysAllocString(lpszClassName), TRUE)))
		{
		}
		else
			m_pLogObject->WriteW( L"CLDAPClassProvider :: MapClassSystemProperties() on __CLASS FAILED : %x for %s\r\n", result, lpszClassName);
	}
	else
		m_pLogObject->WriteW( L"CLDAPClassProvider :: MapClassSystemProperties() SpawnDerived on WBEM base class FAILED : %x for %s\r\n", result, lpszClassName);
	
	return result;
}




//***************************************************************************
//
// CLDAPClassProvider :: MapClassQualifiersToWBEM
//
// Purpose: Creates the class qualifiers for a WBEM class from the ADSI class
//
// Parameters:
//	pADSIClass : The LDAP class that is being mapped
//	pWbemClass : The WBEM class object being created. T
//	pCtx : The context object that was used in this provider call
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CLDAPClassProvider :: MapClassQualifiersToWBEM(CADSIClass *pADSIClass, int iCaseNumber, IWbemClassObject *pWbemClass, IWbemContext *pCtx)
{
	IWbemQualifierSet *pQualifierSet = NULL;
	HRESULT result = pWbemClass->GetQualifierSet(&pQualifierSet);

	LPCWSTR lpszTemp;
	BOOLEAN bIsAbstract = FALSE;

	// Map each of the LDAP class attributes to WBEM class qualifiers/properties
	if(SUCCEEDED(result))
	{
		result = CWBEMHelper::PutI4Qualifier(pQualifierSet, OBJECT_CLASS_CATEGORY_ATTR_BSTR, pADSIClass->GetObjectClassCategory(), DEFAULT_QUALIFIER_FLAVOUR);
		// It is an abstract class is the ADSI class type is Abstract or Auxiliary
		if(SUCCEEDED(result) && (pADSIClass->GetObjectClassCategory() == 2 || pADSIClass->GetObjectClassCategory() == 3) )
		{
			bIsAbstract = TRUE;
			result = CWBEMHelper::PutBOOLQualifier(pQualifierSet, ABSTRACT_BSTR, VARIANT_TRUE, WBEM_FLAVOR_OVERRIDABLE);
		} 
		else if (iCaseNumber == 2 || iCaseNumber == 3)
		{
			bIsAbstract = TRUE;
			result = CWBEMHelper::PutBOOLQualifier(pQualifierSet, ABSTRACT_BSTR, VARIANT_TRUE, WBEM_FLAVOR_OVERRIDABLE);
		}
	}

	if(SUCCEEDED(result))
		result = CWBEMHelper::PutBOOLQualifier(pQualifierSet, DYNAMIC_BSTR, VARIANT_TRUE, DEFAULT_QUALIFIER_FLAVOUR);

	// provider qualifier is put only for non-abstract classes
	if(!bIsAbstract && SUCCEEDED(result))
		result = CWBEMHelper::PutBSTRQualifier(pQualifierSet, PROVIDER_BSTR, LDAP_INSTANCE_PROVIDER_NAME, DEFAULT_QUALIFIER_FLAVOUR, FALSE);

	if(SUCCEEDED(result))
		result = CWBEMHelper::PutBSTRQualifier(pQualifierSet, COMMON_NAME_ATTR_BSTR, SysAllocString(pADSIClass->GetCommonName()), DEFAULT_QUALIFIER_FLAVOUR);

	if(SUCCEEDED(result))
		result = CWBEMHelper::PutBSTRQualifier(pQualifierSet, LDAP_DISPLAY_NAME_ATTR_BSTR, SysAllocString(pADSIClass->GetName()), DEFAULT_QUALIFIER_FLAVOUR);
	
	if(SUCCEEDED(result))
		result = CWBEMHelper::PutBSTRQualifier(pQualifierSet, GOVERNS_ID_ATTR_BSTR, SysAllocString(pADSIClass->GetGovernsID()), DEFAULT_QUALIFIER_FLAVOUR);
	
	// Do not map this, since this is not exposed thru the schema-management snapin
	/*
	if(SUCCEEDED(result))
	{
		const LPBYTE pValues = pADSIClass->GetSchemaIDGUID(&dwTemp);
		result = CWBEMHelper::PutUint8ArrayQualifier(pQualifierSet, SCHEMA_ID_GUID_ATTR_BSTR, pValues, dwTemp, DEFAULT_QUALIFIER_FLAVOUR);
	}
	*/
	
	if(SUCCEEDED(result) && (lpszTemp = pADSIClass->GetDefaultSecurityDescriptor()))
		result = CWBEMHelper::PutBSTRQualifier(pQualifierSet, DEFAULT_SECURITY_DESCRP_ATTR_BSTR, SysAllocString(lpszTemp), DEFAULT_QUALIFIER_FLAVOUR);
	
	if(SUCCEEDED(result))
		result = CWBEMHelper::PutBOOLQualifier(pQualifierSet, SYSTEM_ONLY_ATTR_BSTR, pADSIClass->GetSystemOnly(), DEFAULT_QUALIFIER_FLAVOUR);

	/*
	if(SUCCEEDED(result))
	{
		const LPBYTE pValues = pADSIClass->GetNTSecurityDescriptor(&dwTemp);
		result = CWBEMHelper::PutUint8ArrayQualifier(pQualifierSet, NT_SECURITY_DESCRIPTOR_ATTR_BSTR, pValues, dwTemp, DEFAULT_QUALIFIER_FLAVOUR);
	}
	*/

	if(SUCCEEDED(result))
		result = CWBEMHelper::PutBSTRQualifier(pQualifierSet, DEFAULT_OBJECTCATEGORY_ATTR_BSTR, SysAllocString(pADSIClass->GetDefaultObjectCategory()), DEFAULT_QUALIFIER_FLAVOUR);

	pQualifierSet->Release();
	return result;
}

//***************************************************************************
//
// CLDAPClassProvider :: MapClassPropertiesToWBEM
//
// Purpose: Creates the class properties for a WBEM class from the ADSI class
//
// Parameters:
//	pADSIClass : The LDAP class that is being mapped
//	pWbemClass : The WBEM class object being created. 
//	pCtx : The context object that was used in this provider call
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CLDAPClassProvider :: MapClassPropertiesToWBEM(CADSIClass *pADSIClass, IWbemClassObject *pWbemClass, IWbemContext *pCtx)
{
	HRESULT result = S_OK;

	//////////////////////////////////////////////////
	// Go thru the set of Auxiliary Classes 
	//////////////////////////////////////////////////
	DWORD dwCount = 0;
	LPCWSTR *lppszPropertyList = pADSIClass->GetAuxiliaryClasses(&dwCount);
	CADSIClass *pNextClass = NULL;
	if(dwCount)
	{
		for(DWORD dwNextClass=0; dwNextClass<dwCount; dwNextClass++)
		{
			LPWSTR lpszWBEMClassName = CLDAPHelper::MangleLDAPNameToWBEM(lppszPropertyList[dwNextClass]);
			if(SUCCEEDED(result = s_pLDAPCache->GetClass(lpszWBEMClassName, lppszPropertyList[dwNextClass], &pNextClass)))
			{
				if(SUCCEEDED(result = MapClassPropertiesToWBEM(pNextClass, pWbemClass, pCtx)))
				{
				}
				pNextClass->Release();
			}
			delete [] lpszWBEMClassName;
		}
	}
	if(FAILED(result))
		return result;

	//////////////////////////////////////////////////
	// Go thru the set of System Auxiliary Classes 
	//////////////////////////////////////////////////
	dwCount = 0;
	lppszPropertyList = pADSIClass->GetSystemAuxiliaryClasses(&dwCount);
	pNextClass = NULL;
	if(dwCount)
	{
		for(DWORD dwNextClass=0; dwNextClass<dwCount; dwNextClass++)
		{
			LPWSTR lpszWBEMClassName = CLDAPHelper::MangleLDAPNameToWBEM(lppszPropertyList[dwNextClass]);
			if(SUCCEEDED(result = s_pLDAPCache->GetClass(lpszWBEMClassName, lppszPropertyList[dwNextClass], &pNextClass)))
			{
				if(SUCCEEDED(result = MapClassPropertiesToWBEM(pNextClass, pWbemClass, pCtx)))
				{
				}
				pNextClass->Release();
			}
			delete [] lpszWBEMClassName;
		}
	}
	if(FAILED(result))
		return result;

	//////////////////////////////////////////////////
	// Go thru the set of System May Contains
	//////////////////////////////////////////////////
	dwCount = 0;
	lppszPropertyList = pADSIClass->GetSystemMayContains(&dwCount);
	if(SUCCEEDED(result = MapPropertyListToWBEM(pWbemClass, lppszPropertyList, dwCount, TRUE, FALSE)))
	{
		//////////////////////////////////////////////////
		// Go thru the set of May Contains
		//////////////////////////////////////////////////
		dwCount = 0;
		lppszPropertyList = pADSIClass->GetMayContains(&dwCount);
		if(SUCCEEDED(result = MapPropertyListToWBEM(pWbemClass, lppszPropertyList, dwCount, FALSE, FALSE)))
		{
			//////////////////////////////////////////////////
			// Go thru the set of System Must Contains
			//////////////////////////////////////////////////
			dwCount = 0;
			lppszPropertyList = pADSIClass->GetSystemMustContains(&dwCount);
			if(SUCCEEDED(result = MapPropertyListToWBEM(pWbemClass, lppszPropertyList, dwCount, TRUE, TRUE)))
			{
				//////////////////////////////////////////////////
				// Go thru the set of Must Contains
				//////////////////////////////////////////////////
				dwCount = 0;
				lppszPropertyList = pADSIClass->GetMustContains(&dwCount);
				if(SUCCEEDED(result = MapPropertyListToWBEM(pWbemClass, lppszPropertyList, dwCount, FALSE, TRUE)))
				{

				} // MapPropertyListToWBEM
			} // MapPropertyListToWBEM
		} // MapPropertyListToWBEM
	} // MapPropertyListToWBEM
		
	// Do not map any other properties, if failed
	if(FAILED(result))
		return result;

	// Map the RDN property as indexed
	LPWSTR lpszRDNAttribute = NULL;
	lpszRDNAttribute = CLDAPHelper::MangleLDAPNameToWBEM(pADSIClass->GetRDNAttribute());
	if(lpszRDNAttribute)
	{
		BSTR strRDNAttribute = SysAllocString(lpszRDNAttribute);
		IWbemQualifierSet *pQualifierSet = NULL;
		if(SUCCEEDED(result = pWbemClass->GetPropertyQualifierSet(strRDNAttribute, &pQualifierSet)))
		{
			IWbemQualifierSet *pClassQualifiers = NULL;
			if(SUCCEEDED(result = pWbemClass->GetQualifierSet(&pClassQualifiers)))
			{
				// ALso put a qualifier on the class that indicates that this is the RDNAttId
				if(SUCCEEDED(result = CWBEMHelper::PutBSTRQualifier(pClassQualifiers, RDN_ATT_ID_ATTR_BSTR, SysAllocString(pADSIClass->GetRDNAttribute()), DEFAULT_QUALIFIER_FLAVOUR, TRUE)))
				{
					if(SUCCEEDED(result = CWBEMHelper::PutBOOLQualifier(pQualifierSet, INDEXED_BSTR, VARIANT_TRUE, DEFAULT_QUALIFIER_FLAVOUR)))
					{

					}
					// It is fine if this property has already been designated as indexed in the base class
					else if (result == WBEM_E_OVERRIDE_NOT_ALLOWED)
						result = S_OK;
				}
				pClassQualifiers->Release();
			}
			// Release the Qualifer Set
			pQualifierSet->Release();
		}
		SysFreeString(strRDNAttribute);
	}
	delete [] lpszRDNAttribute;

	return result;
}


//***************************************************************************
//
// CLDAPClassProvider :: MapPropertyListToWBEM
//
// Purpose: Maps a list of class properties for a WBEM class from the ADSI class
//
// Parameters:
//	pWbemClass : The WBEM class object being created. 
//	lppszPropertyList : A list of propery names
//	dwCOunt : The number of items in the above list
//	bMapSystemQualifier : Whether the "system" qualifier should be mapped
//	bMapNotNullQualifier: Whether the "notNull" qualifier should be mapped
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CLDAPClassProvider :: MapPropertyListToWBEM(IWbemClassObject *pWbemClass, 
													LPCWSTR *lppszPropertyList, 
													DWORD dwCount, 
													BOOLEAN bMapSystemQualifier, 
													BOOLEAN bMapNotNullQualifier)
{
	HRESULT result = S_OK;
	CADSIProperty *pNextProperty;
	IWbemQualifierSet *pQualifierSet;
	if(dwCount)
	{
		for(DWORD dwNextProperty=0; dwNextProperty<dwCount; dwNextProperty++)
		{
			// Get the property from the cache. The name of the property will be the LDAP name
			if(SUCCEEDED(result = s_pLDAPCache->GetProperty(lppszPropertyList[dwNextProperty], &pNextProperty, FALSE)))
			{
				// Map the basic property
				if(SUCCEEDED(result = CreateWBEMProperty(pWbemClass, &pQualifierSet, pNextProperty)))
				{
					// Map the "system" qualifier
					if(bMapSystemQualifier && SUCCEEDED(result = CWBEMHelper::PutBOOLQualifier(pQualifierSet, SYSTEM_BSTR, VARIANT_TRUE, DEFAULT_QUALIFIER_FLAVOUR)))
					{
					}

					// Map the "not_null" qualifier
					if(bMapNotNullQualifier && SUCCEEDED(result = CWBEMHelper::PutBOOLQualifier(pQualifierSet, NOT_NULL_BSTR, VARIANT_TRUE, DEFAULT_QUALIFIER_FLAVOUR)))
					{
					}

					// Release the qualifier set
					pQualifierSet->Release();
				}
				// Release the property
				pNextProperty->Release();
			}
			// Do not map any other properties
			if(FAILED(result))
				break;
		}
	}

	return result;
}

//***************************************************************************
//
// CLDAPClassProvider :: CreateWBEMProperty
//
// Purpose: Creates a WBEM property from an LDAP property
//
// Parameters:
//	pWbemClass : The WBEM class in which the property is created
//	ppQualiferSet : The address of the pointer to IWbemQualiferSet where the qualifier set
//		of this property will be placed
//	pADSIProperty : The ADSI Property object that is being mapped to the property being created
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CLDAPClassProvider :: CreateWBEMProperty(IWbemClassObject *pWbemClass, IWbemQualifierSet **ppQualifierSet, CADSIProperty *pADSIProperty)
{
	HRESULT result = E_FAIL;

	// Get all the attributes of the ADSI class
	LPCWSTR lpszSyntaxOid = pADSIProperty->GetSyntaxOID();
	BSTR strCimTypeQualifier = NULL;

	// Note that strCimTypeQualifier is not allocated in this call, so it is not freed.
	CIMTYPE theCimType = MapLDAPSyntaxToWBEM(pADSIProperty, &strCimTypeQualifier);

	if(lpszSyntaxOid)
	{
		// Create the property
		BSTR strPropertyName = SysAllocString(pADSIProperty->GetWBEMPropertyName());
		if(SUCCEEDED(result = pWbemClass->Put(strPropertyName, 0, NULL, theCimType)))
		{
			// Get the Qualifier Set in ppQualifierSet
			if(SUCCEEDED(result = pWbemClass->GetPropertyQualifierSet(strPropertyName, ppQualifierSet)))
			{
				// Map the property attributes to WBEM qualifiers
				if(SUCCEEDED(result = CWBEMHelper::PutBSTRQualifier(*ppQualifierSet, 
							ATTRIBUTE_SYNTAX_ATTR_BSTR, 
							SysAllocString(lpszSyntaxOid),
							DEFAULT_QUALIFIER_FLAVOUR)))
				{
					/* Commented to reduce size of classes
					if(SUCCEEDED(result = CWBEMHelper::PutBSTRQualifier(*ppQualifierSet, 
								ATTRIBUTE_ID_ATTR_BSTR, 
								SysAllocString(pADSIProperty->GetAttributeID()),
								DEFAULT_QUALIFIER_FLAVOUR)))
					{
					*/
						if(SUCCEEDED(result = CWBEMHelper::PutBSTRQualifier(*ppQualifierSet, 
								COMMON_NAME_ATTR_BSTR, 
								SysAllocString(pADSIProperty->GetCommonName()),
								DEFAULT_QUALIFIER_FLAVOUR)))
						{
							/* Commented to reduce size of classes
							if(SUCCEEDED(result = CWBEMHelper::PutI4Qualifier(*ppQualifierSet, 
									MAPI_ID_ATTR_BSTR,
									pADSIProperty->GetMAPI_ID(),
									DEFAULT_QUALIFIER_FLAVOUR)))
							{
								if(SUCCEEDED(result = CWBEMHelper::PutI4Qualifier(*ppQualifierSet, 
										OM_SYNTAX_ATTR_BSTR,
										pADSIProperty->GetOMSyntax(),
										DEFAULT_QUALIFIER_FLAVOUR)))
								{
									if(pADSIProperty->IsSystemOnly())
									{
										if(SUCCEEDED(result = CWBEMHelper::PutBOOLQualifier(*ppQualifierSet, 
												SYSTEM_ONLY_ATTR_BSTR,
												VARIANT_TRUE,
												DEFAULT_QUALIFIER_FLAVOUR)))
										{
										}
									}
								*/

									// If this is an embedded property, then use the cimType qualifier on the property
									if(strCimTypeQualifier)
									{
										result = CWBEMHelper::PutBSTRQualifier(*ppQualifierSet, 
													CIMTYPE_STR, 
													strCimTypeQualifier,
													DEFAULT_QUALIFIER_FLAVOUR, FALSE); 
									}

									if(SUCCEEDED(result) && pADSIProperty->GetSearchFlags() == 1)
									{
										if(SUCCEEDED(result = CWBEMHelper::PutBOOLQualifier(*ppQualifierSet, 
											INDEXED_BSTR,
											VARIANT_TRUE,
											DEFAULT_QUALIFIER_FLAVOUR)))
										{
										}
										else if (result == WBEM_E_OVERRIDE_NOT_ALLOWED)
											result = S_OK;
									}
								}
							/*
							}
						}
					}
					*/
				}
			}
			else
				m_pLogObject->WriteW( L"CLDAPClassProvider :: CreateWBEMProperty FAILED to get qualifier set for %s", pADSIProperty->GetADSIPropertyName());
		}
		else
			m_pLogObject->WriteW( L"CLDAPClassProvider :: CreateWBEMProperty FAILED to put property : %s", pADSIProperty->GetADSIPropertyName());

		SysFreeString(strPropertyName);
	}
	else
	{
		m_pLogObject->WriteW( L"CLDAPClassProvider :: CreateWBEMProperty FAILED to get Syntax OID property for %s", pADSIProperty->GetADSIPropertyName());
		result = E_FAIL;
	}

	return result;
}


//***************************************************************************
//
// CLDAPClassProvider :: MapLDAPSyntaxToWBEM
//
// Purpose: See Header
//
//***************************************************************************
CIMTYPE CLDAPClassProvider :: MapLDAPSyntaxToWBEM(CADSIProperty *pADSIProperty, BSTR *pstrCimTypeQualifier)
{
	*pstrCimTypeQualifier = NULL;
	LPCWSTR lpszSyntaxOid = pADSIProperty->GetSyntaxOID();
	CIMTYPE retValue = (pADSIProperty->IsMultiValued())? CIM_FLAG_ARRAY : 0;

	if(wcscmp(lpszSyntaxOid, UNICODE_STRING_OID) == 0)
		return retValue | CIM_STRING;
	else if(wcscmp(lpszSyntaxOid, INTEGER_OID) == 0)
		return retValue | CIM_SINT32;
	else if(wcscmp(lpszSyntaxOid, LARGE_INTEGER_OID) == 0)
		return retValue | CIM_SINT64;
	else if(wcscmp(lpszSyntaxOid, BOOLEAN_OID) == 0)
		return retValue | CIM_BOOLEAN;
	else if(wcscmp(lpszSyntaxOid, OBJECT_IDENTIFIER_OID) == 0)
		return retValue | CIM_STRING;
	else if(wcscmp(lpszSyntaxOid, DISTINGUISHED_NAME_OID) == 0)
		return retValue | CIM_STRING;
	else if(wcscmp(lpszSyntaxOid, CASE_SENSITIVE_STRING_OID) == 0)
		return retValue | CIM_STRING;
	else if(wcscmp(lpszSyntaxOid, CASE_INSENSITIVE_STRING_OID) == 0)
		return retValue | CIM_STRING;
	else if(wcscmp(lpszSyntaxOid, PRINT_CASE_STRING_OID) == 0)
		return retValue | CIM_STRING;
	else if(wcscmp(lpszSyntaxOid, OCTET_STRING_OID) == 0)
	{
		*pstrCimTypeQualifier = EMBED_UINT8ARRAY;
		return retValue | CIM_OBJECT;
	}
	else if(wcscmp(lpszSyntaxOid, NUMERIC_STRING_OID) == 0)
		return retValue | CIM_STRING;
	else if(wcscmp(lpszSyntaxOid, PRINT_CASE_STRING_OID) == 0)
		return retValue | CIM_STRING;
	else if(wcscmp(lpszSyntaxOid, DN_WITH_BINARY_OID) == 0)
	{
		// DN_With_Binary and OR_Name have the same syntax oid.
		// They are differentiated base on the value of the OMObjectClass value
		if(pADSIProperty->IsORName())
			return retValue | CIM_STRING;
		else // It is DN_With_Binary
		{
			*pstrCimTypeQualifier = EMBED_DN_WITH_BINARY;
			return retValue | CIM_OBJECT;
		}
	}
	else if(wcscmp(lpszSyntaxOid, NT_SECURITY_DESCRIPTOR_OID) == 0)
	{
		*pstrCimTypeQualifier = EMBED_UINT8ARRAY;
		return retValue | CIM_OBJECT;
	}
	else if(wcscmp(lpszSyntaxOid, PRESENTATION_ADDRESS_OID) == 0)
	{
		*pstrCimTypeQualifier = EMBED_UINT8ARRAY;
		return retValue | CIM_OBJECT;
	}
	else if(wcscmp(lpszSyntaxOid, DN_WITH_STRING_OID) == 0)
	{
		*pstrCimTypeQualifier = EMBED_DN_WITH_BINARY;
		return retValue | CIM_OBJECT;
	}
	else if(wcscmp(lpszSyntaxOid, SID_OID) == 0)
	{
		*pstrCimTypeQualifier = EMBED_UINT8ARRAY;
		return retValue | CIM_OBJECT;
	}
	else if(wcscmp(lpszSyntaxOid, TIME_OID) == 0)
		return retValue | CIM_DATETIME;
	else 
	{
		m_pLogObject->WriteW( L"CLDAPClassProvider :: MapLDAPSyntaxToWBEM FAILED to map syntax for OID: %s\r\n", lpszSyntaxOid);
		return retValue | CIM_STRING;
	}
}

//***************************************************************************
//
// CLDAPClassProvider :: CreateClassEnumAsync
//
// Purpose: Enumerates the classes 
//
// Parameters:
//	Standard parmaters as described by the IWbemServices interface
//
//
// Return Value: As described by the IWbemServices interface
//
//***************************************************************************
HRESULT CLDAPClassProvider :: CreateClassEnumAsync( 
    /* [in] */ const BSTR strSuperclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	if(!m_bInitializedSuccessfully)
	{
		m_pLogObject->WriteW( L"CLDAPClassProvider :: Initialization status is FAILED, hence returning failure\r\n");
		return WBEM_E_FAILED;
	}

	m_pLogObject->WriteW( L"CLDAPClassProvider :: CreateClassEnumAsync() called for %s SuperClass and %s \r\n",
		((strSuperclass)? strSuperclass : L" "), ((lFlags & WBEM_FLAG_SHALLOW)? L"SHALLOW" : L"DEEP"));

	// Impersonate the client
	//=======================
	HRESULT result = WBEM_E_FAILED;
	if(!SUCCEEDED(result = WbemCoImpersonateClient()))
	{
		m_pLogObject->WriteW( L"CDSClassProvider :: CreateClassEnumAsync() CoImpersonate FAILED for %s with %x\r\n", strSuperclass, result);
		return WBEM_E_FAILED;
	}

	try
	{

		BSTR strTheSuperClass = strSuperclass;
		
		// CIMOM seems to give the strSuperClass as NULL sometimes and as "" sometimes. Make it unambiguous
		if(!strTheSuperClass || wcscmp(strTheSuperClass, L"") == 0)
		{
			if( lFlags & WBEM_FLAG_SHALLOW) 
			{
				// Nothing to be done since we do not provide cany classes that fit this
				strTheSuperClass = NULL;
				result = S_OK;
			}
			else
			{
				strTheSuperClass = LDAP_BASE_CLASS_STR; // Recursive enumeration handled below
			}
		}

		// Take the special cases first
		//	1. Where the strSuperClass is LDAP_BASE_CLASS_STR and lFlags is Shallow
		//	Nothing to be returned here, since we are not supplying the LDAP_BASE_CLASS_STR
		//	which is statically supplied.
		//=======================================================================
		if(strTheSuperClass && _wcsicmp(strTheSuperClass, LDAP_BASE_CLASS_STR) == 0 )
		{
			// First the TOP class needs to be returned
			IWbemClassObject *pReturnObject = NULL;
			if(SUCCEEDED(result = GetClassFromCacheOrADSI(TOP_CLASS, &pReturnObject, pCtx)))
			{
				result = pResponseHandler->Indicate(1, &pReturnObject);
				pReturnObject->Release();

				if( lFlags & WBEM_FLAG_SHALLOW) // Notheing more to be done
				{
				}
				else // We've to return all the sub classes of top too, recursively
				{
					if(SUCCEEDED(result = HandleRecursiveEnumeration(TOP_CLASS, pCtx, pResponseHandler)))
					{
						m_pLogObject->WriteW( L"CLDAPClassProvider :: CreateClassEnumAsync() Recursive enumeration for %s succeeded\r\n", strTheSuperClass);
					}
					else
					{
						m_pLogObject->WriteW( L"CLDAPClassProvider :: CreateClassEnumAsync() Recursive enumeration for %s FAILED\r\n", strTheSuperClass);
					}
				}
			}
		}
		// 2. Where the superClass is specified
		//=======================================================================
		else if(strTheSuperClass)
		{
			// Optimize the operation by seeing if it is one of the static classes and
			// its name does not start with "ADS_" or "DS_". Then we dont know anything about it
			//============================================================================
			if(IsUnProvidedClass(strTheSuperClass))
			{
				result = S_OK;
			}
			else
			{
				BOOLEAN bArtificialClass = FALSE;

				// First check if this is one our "artificial" classes. All "aritificial" classes start with "ads_".
				// All non artificial classes start with "ds_"
				if(_wcsnicmp(strTheSuperClass, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX_LENGTH) == 0)
					bArtificialClass = TRUE;

				// When the search is shallow
				if( lFlags & WBEM_FLAG_SHALLOW)
				{
					// The ADSI classes
					LPWSTR *ppADSIClasses = NULL;
					// The number of ADSI classes
					DWORD dwNumClasses = 0;

					if(SUCCEEDED(result = GetOneLevelDeep(strTheSuperClass, bArtificialClass, &ppADSIClasses, &dwNumClasses, pCtx)))
					{
						// Interact with CIMOM
						//=====================
						if(SUCCEEDED(result = WrapUpEnumeration(ppADSIClasses, dwNumClasses, pCtx, pResponseHandler)))
						{
						}

						// Release the list of ADSI classes and its contents
						//==================================================
						for(DWORD j=0; j<dwNumClasses; j++)
							delete [] ppADSIClasses[j];
						delete[] ppADSIClasses;
					}
				}
				else // the search is deep
				{
					if(SUCCEEDED(result = HandleRecursiveEnumeration(strTheSuperClass, pCtx, pResponseHandler)))
					{
						m_pLogObject->WriteW( L"CLDAPClassProvider :: CreateClassEnumAsync() Recursive enumeration for %s succeeded\r\n", strTheSuperClass);
					}
					else
					{
						m_pLogObject->WriteW( L"CLDAPClassProvider :: CreateClassEnumAsync() Recursive enumeration for %s FAILED\r\n", strTheSuperClass);
					}
				}

			}
		}

				
		if(SUCCEEDED(result))
		{
			pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_S_NO_ERROR, NULL, NULL);
			m_pLogObject->WriteW( L"CLDAPClassProvider :: CreateClassEnumAsync() Non-Recursive enumeration succeeded\r\n");
		}
		else
		{
			pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_E_FAILED, NULL, NULL);
			m_pLogObject->WriteW( L"CLDAPClassProvider :: CreateClassEnumAsync() Non-Recursive enumeration FAILED for superclass %s \r\n", strTheSuperClass);
		}
	}
	catch(Heap_Exception e_HE)
	{
		pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE , WBEM_E_OUT_OF_MEMORY, NULL, NULL);
	}
	return WBEM_S_NO_ERROR;
}
    

//***************************************************************************
//
// CLDAPClassProvider :: GetOneLevelDeep
//
// Purpose: Enumerates the sub classes of a superclass non-recursively
//
// Parameters:
//
//	lpszSuperClass : The super class name
//	pResponseHandler : The interface where the resulting classes are put
//
//
// Return Value: As described by the IWbemServices interface
//
//***************************************************************************
HRESULT CLDAPClassProvider :: GetOneLevelDeep( 
    LPCWSTR lpszWBEMSuperclass,
	BOOLEAN bArtificialClass,
	LPWSTR ** pppADSIClasses,
	DWORD *pdwNumClasses,
	IWbemContext *pCtx)
{
	// The ADSI classes
	*pppADSIClasses = NULL;
	// The number of ADSI classes
	*pdwNumClasses = 0;
	HRESULT result = WBEM_E_FAILED;

	// See if the super class
	IWbemClassObject *pSuperClass = NULL;
	if(!SUCCEEDED(result = GetClassFromCacheOrADSI(lpszWBEMSuperclass, &pSuperClass, pCtx)))
	{
		return WBEM_E_NOT_FOUND;
	}
	pSuperClass->Release();

	// If the WBEM class is concrete, we dont need to do anything
	if (SUCCEEDED(result = IsConcreteClass(lpszWBEMSuperclass, pCtx)))
	{
		if(result == S_OK)
			return S_OK;
	}
	else
		return result;

	// See the cache first
	//====================
	CEnumInfo *pEnumInfo = NULL;
	if(SUCCEEDED(result = s_pWbemCache->GetEnumInfo(lpszWBEMSuperclass, &pEnumInfo)))
	{
		CNamesList *pNamesList = pEnumInfo->GetSubClassNames();
		*pdwNumClasses = pNamesList->GetAllNames(pppADSIClasses);
		pEnumInfo->Release();
	}
	else // Go to ADSI 
		//============
	{
		// The following are the possibilities now"
		// 1. The Class starts with "ADS_". It is abstract by definition. All its sub-classes except one are abstract,artificial.
		// 2. The Class starts with "DS_" and it is abstract. It being concrete is ruled out since it was handled at the
		// top of this function

		// Get all the ADSI classes 
		if(SUCCEEDED(result = s_pLDAPCache->EnumerateClasses(
			lpszWBEMSuperclass,
			FALSE,
			pppADSIClasses,
			pdwNumClasses,
			bArtificialClass)))
		{

			// Create a list of names for holding the subclasses
			CNamesList *pNewList = new CNamesList;
			LPWSTR pszWBEMName = NULL;

			// The First case in the 2 cases above
			if(bArtificialClass)
			{
				// The first element is just the super class without the A
				// Example if the super class is "ADS_User", the first element is DS_user
				pNewList->AddName((*pppADSIClasses)[0]);


				// Start from the secodn element
				for(DWORD i=1; i<*pdwNumClasses; i++)
				{
					// Convert names to WBEM And add them to the new list
					pszWBEMName = CLDAPHelper::MangleLDAPNameToWBEM((*pppADSIClasses)[i], TRUE);
					pNewList->AddName(pszWBEMName);

					delete [] (*pppADSIClasses)[i];
					(*pppADSIClasses)[i] = pszWBEMName;
				}
			}
			else // The Second case
			{
				for(DWORD i=0; i<*pdwNumClasses; i++)
				{
					// Convert names to WBEM And add them to the new list
					pszWBEMName = CLDAPHelper::MangleLDAPNameToWBEM((*pppADSIClasses)[i], FALSE);

					LPWSTR pszRealClassName = NULL;

					if(SUCCEEDED(result = IsConcreteClass(pszWBEMName, pCtx)))
					{
						if(result == S_OK)
						{
							pszRealClassName = CLDAPHelper::MangleLDAPNameToWBEM((*pppADSIClasses)[i], TRUE);
							delete[] pszWBEMName;
							pNewList->AddName(pszRealClassName);
							delete [] (*pppADSIClasses)[i];
							(*pppADSIClasses)[i] = pszRealClassName;
						}
						else
						{
							pNewList->AddName(pszWBEMName);
							delete [] (*pppADSIClasses)[i];
							(*pppADSIClasses)[i] = pszWBEMName;
						}
					}
					else
						m_pLogObject->WriteW( L"CLDAPClassProvider :: GetOneLevelDeep() UNKNOWN FAILED for %s \r\n", lpszWBEMSuperclass);
				}
			}

			// Add the new EnumInfo to the Enum cache
			pEnumInfo = new CEnumInfo(lpszWBEMSuperclass, pNewList);
			s_pWbemCache->AddEnumInfo(pEnumInfo);
			pEnumInfo->Release();
			
		}
		else
			m_pLogObject->WriteW( L"CLDAPClassProvider :: CreateClassEnumAsync() GetOneLevelDeep() FAILED for %s \r\n", lpszWBEMSuperclass);
	}
	return result;
}

//***************************************************************************
//
// CLDAPClassProvider :: HandleRecursiveEnumeration
//
// Purpose: Enumerates the sub classes of a superclass recursively
//
// Parameters:
//
//	lpszSuperClass : The super class name
//	pResponseHandler : The interface where the resulting classes are put
//
//
// Return Value: As described by the IWbemServices interface
//
//***************************************************************************
HRESULT CLDAPClassProvider :: HandleRecursiveEnumeration( 
    LPCWSTR lpszWBEMSuperclass,
    IWbemContext *pCtx,
    IWbemObjectSink *pResponseHandler)
{
	m_pLogObject->WriteW( L"CLDAPClassProvider :: HandleRecursiveEnumeration() called for %s SuperClass \r\n",
			((lpszWBEMSuperclass)? lpszWBEMSuperclass : L" "));
	HRESULT result = E_FAIL;

	// The ADSI classes
	LPWSTR *ppADSIClasses = NULL;
	// The number of ADSI classes
	DWORD dwNumClasses = 0;

	// First check if this is one our "artificial" classes. All "aritificial" classes start with "ads_".
	// All non artificial classes start with "ds_"
	BOOLEAN bArtificialClass = FALSE;
	if(_wcsnicmp(lpszWBEMSuperclass, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX_LENGTH) == 0)
		bArtificialClass = TRUE;

	if(SUCCEEDED(result = GetOneLevelDeep(lpszWBEMSuperclass, bArtificialClass, &ppADSIClasses, &dwNumClasses, pCtx)))
	{
		// Interact with CIMOM
		//=====================
		if(SUCCEEDED(result = WrapUpEnumeration(ppADSIClasses, dwNumClasses, pCtx, pResponseHandler)))
		{
		}

		if(!SUCCEEDED(result))
			m_pLogObject->WriteW( L"CLDAPClassProvider :: HandleRecursiveEnumeration() WrapUpEnumeration() for Superclass %s FAILED with %x \r\n",
				((lpszWBEMSuperclass)? lpszWBEMSuperclass : L" "), result);

		// Release the list of ADSI classes and its contents. Enumerate into them too
		for(DWORD j=0; j<dwNumClasses; j++)
		{
			HandleRecursiveEnumeration(ppADSIClasses[j], pCtx, pResponseHandler);
			delete [] ppADSIClasses[j];
		}

		delete[] ppADSIClasses;
	}
	return result;
}

//***************************************************************************
//
// CLDAPClassProvider :: WrapUpEnumeration
//
// Purpose: Creates WBEM classes from ADSI classes and Indicates them to CIMOM
//
// Parameters:
//
//	lpszSuperClass : The super class name
//	pResponseHandler : The interface where the resulting classes are put
//
//
// Return Value: As described by the IWbemServices interface
//
//***************************************************************************
HRESULT CLDAPClassProvider :: WrapUpEnumeration( 
	LPWSTR *ppADSIClasses,
	DWORD dwNumClasses,
    IWbemContext *pCtx,
    IWbemObjectSink *pResponseHandler)
{
	// The WBEM Class objects created
	IWbemClassObject **ppReturnWbemClassObjects = NULL;
	// The number of WBEM class objects that were successfully created
	DWORD i=0;
	DWORD j=0;
	HRESULT result = S_OK;
	if(dwNumClasses != 0)
	{
		// Allocate an array of IWbemClassObject pointers
		ppReturnWbemClassObjects = new IWbemClassObject *[dwNumClasses];

		for(i=0; i<dwNumClasses; i++)
		{
			// Get the class
			if(!SUCCEEDED(result = GetClassFromCacheOrADSI(ppADSIClasses[i], ppReturnWbemClassObjects + i, pCtx)))
			{
				m_pLogObject->WriteW( L"CLDAPClassProvider :: WrapUpEnumeration() GetClassFromCacheOrADSI() FAILED with %x \r\n", result);
				break;
			}
		}
	}

	// Indicate(), but do not SetStatus()
	if(SUCCEEDED(result))
	{
		// result = pResponseHandler->Indicate(i, ppReturnWbemClassObjects);
		////////////////////////////////////

		//
		// Break it up into 4 objects at a time - JUST FOR TESTING AGAINST BUG 39838
		// 

		DWORD dwMaxObjectsAtATime  = 4;
		j = 0;
		while ( j<i )
		{
			DWORD dwThisIndicationsCount = ((i-j) > dwMaxObjectsAtATime)? dwMaxObjectsAtATime : (i-j);
			if(FAILED(result = pResponseHandler->Indicate(dwThisIndicationsCount, ppReturnWbemClassObjects + j)))
				m_pLogObject->WriteW( L"CLDAPClassProvider :: WrapUpEnumeration() Indicate() FAILED with %x \r\n", result);

			j+= dwThisIndicationsCount;
		}
	}
	else
		m_pLogObject->WriteW( L"CLDAPClassProvider :: HandleRecursiveEnumeration() WrapUpEnumeration() FAILED with %x \r\n", result);

	// Delete the list of WBEM Classes and its contents. 
	for(j=0; j<i; j++)
		(ppReturnWbemClassObjects[j])->Release();
	delete[] ppReturnWbemClassObjects;

	return result;
}

//***************************************************************************
//
// CLDAPClassProvider :: IsConcreteClass
//
// Purpose: Find out whether a WBEM class is concrete. 
//
// Parameters:
//
//	pszWBEMName : The class name
//
//
// Return Value: As described by the IWbemServices interface
//
//***************************************************************************
HRESULT CLDAPClassProvider :: IsConcreteClass( 
	LPCWSTR pszWBEMName,
    IWbemContext *pCtx)
{
	// The call to IsConcreteClass is optimized if the class is artificial,
	// since all artificial classes are non-concrete
	if(_wcsnicmp(pszWBEMName, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX_LENGTH) == 0)
		return S_FALSE;

	IWbemClassObject *pWbemClass = NULL;
	HRESULT result = E_FAIL;

	if(SUCCEEDED(GetClassFromCacheOrADSI(pszWBEMName,  &pWbemClass, pCtx)))
	{
		IWbemQualifierSet *pQualifierSet = NULL;
		if(SUCCEEDED(result = pWbemClass->GetQualifierSet(&pQualifierSet)))
		{
			VARIANT_BOOL bAbstract = VARIANT_FALSE;
			if(SUCCEEDED(CWBEMHelper::GetBOOLQualifier(pQualifierSet, ABSTRACT_BSTR, &bAbstract, NULL)))
			{
				if(bAbstract == VARIANT_TRUE)
					result = S_FALSE;
				else
					result = S_OK;
			}
			pQualifierSet->Release();
		}
		pWbemClass->Release();
	}
	return result;
}

void CLDAPClassProvider :: SanitizedClassName(LPWSTR lpszClassName)
{
	while(*lpszClassName)
	{
		*lpszClassName = towlower(*lpszClassName);
		lpszClassName++;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\classprovider\ldapcach.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:ldapcach.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Cache for LDAP Schema objects. 
//
//***************************************************************************

#include <tchar.h>
#include <stdio.h>
#include <assert.h>
#include <windows.h>
#include <objbase.h>

/* ADSI includes */
#include <activeds.h>

#include "provlog.h"
#include "attributes.h"
#include "refcount.h"
#include "adsiprop.h"
#include "adsiclas.h"
#include "adsiinst.h"
#include "ldaphelp.h"
#include "tree.h"
#include "ldapcach.h"

// Initialize the statics
LPCWSTR CLDAPCache :: ROOT_DSE_PATH			= L"LDAP://RootDSE";
LPCWSTR CLDAPCache :: SCHEMA_NAMING_CONTEXT = L"schemaNamingContext";
LPCWSTR CLDAPCache :: LDAP_PREFIX			= L"LDAP://";	
LPCWSTR CLDAPCache :: LDAP_TOP_PREFIX		= L"LDAP://CN=top,";
LPCWSTR CLDAPCache :: RIGHT_BRACKET			= L")";
LPCWSTR CLDAPCache :: OBJECT_CATEGORY_EQUALS_ATTRIBUTE_SCHEMA	= L"(objectCategory=attributeSchema)";

DWORD CLDAPCache::dwLDAPCacheCount = 0;

//***************************************************************************
//
// CLDAPCache::CLDAPCache
//
// Purpose : Constructor. Fills in the cache with all the properties in LDAP.
//
// Parameters: 
//	dsLog : The CDSLog object  onto which logging will be done.
//***************************************************************************

CLDAPCache :: CLDAPCache(ProvDebugLog *pLogObject)
{
	dwLDAPCacheCount++;
	m_isInitialized = FALSE;
	m_pLogObject = pLogObject;
	m_pDirectorySearchSchemaContainer = NULL;

	// Initialize the search preferences often used
	m_pSearchInfo[0].dwSearchPref		= ADS_SEARCHPREF_SEARCH_SCOPE;
	m_pSearchInfo[0].vValue.dwType		= ADSTYPE_INTEGER;
	m_pSearchInfo[0].vValue.Integer		= ADS_SCOPE_ONELEVEL;

	m_pSearchInfo[1].dwSearchPref		= ADS_SEARCHPREF_PAGESIZE;
	m_pSearchInfo[1].vValue.dwType		= ADSTYPE_INTEGER;
	m_pSearchInfo[1].vValue.Integer		= 64;

	/*
	m_pSearchInfo[2].dwSearchPref		= ADS_SEARCHPREF_CACHE_RESULTS;
	m_pSearchInfo[2].vValue.dwType		= ADSTYPE_BOOLEAN;
	m_pSearchInfo[2].vValue.Boolean		= 0;
	*/

	m_lpszSchemaContainerSuffix = NULL;
	m_lpszSchemaContainerPath = NULL;
	// Get the ADSI path of the schema container and store it for future use
	//========================================================================
	IADs *pRootDSE = NULL;
	HRESULT result;
	if(SUCCEEDED(result = ADsOpenObject((LPWSTR)ROOT_DSE_PATH, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IADs, (LPVOID *) &pRootDSE)))
	{
		// Get the location of the schema container
		BSTR strSchemaPropertyName = SysAllocString((LPWSTR) SCHEMA_NAMING_CONTEXT);


		// Get the schemaNamingContext property. This property contains the ADSI path
		// of the schema container
		VARIANT variant;
		VariantInit(&variant);
		if(SUCCEEDED(result = pRootDSE->Get(strSchemaPropertyName, &variant)))
		{
			// Store the ADSI path to the schema container
			m_lpszSchemaContainerSuffix = new WCHAR[wcslen(variant.bstrVal) + 1];
			wcscpy(m_lpszSchemaContainerSuffix, variant.bstrVal );
			m_pLogObject->WriteW( L"CLDAPCache :: Got Schema Container as : %s\r\n", m_lpszSchemaContainerSuffix);

			// Form the schema container path
			//==================================
			m_lpszSchemaContainerPath = new WCHAR[wcslen(LDAP_PREFIX) + wcslen(m_lpszSchemaContainerSuffix) + 1];
			wcscpy(m_lpszSchemaContainerPath, LDAP_PREFIX);
			wcscat(m_lpszSchemaContainerPath, m_lpszSchemaContainerSuffix);
			
			m_isInitialized = TRUE;
			/*
			if(SUCCEEDED(result = ADsOpenObject(m_lpszSchemaContainerPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectorySearch, (LPVOID *) &m_pDirectorySearchSchemaContainer)))
			{

				m_pLogObject->WriteW( L"CLDAPCache :: Got IDirectorySearch on Schema Container \r\n");

				if(SUCCEEDED(result = InitializeObjectTree()))
				{
						m_isInitialized = TRUE;
				}
				else
					m_pLogObject->WriteW( L"CLDAPCache :: InitializeObjectTree() FAILED : %x \r\n", result);
			}
			else
				m_pLogObject->WriteW( L"CLDAPCache :: FAILED to get IDirectorySearch on Schema Container : %x\r\n", result);
			*/
		}
		else
			m_pLogObject->WriteW( L"CLDAPCache :: Get on RootDSE FAILED : %x\r\n", result);

		SysFreeString(strSchemaPropertyName);
		VariantClear(&variant);
		pRootDSE->Release();

	}
	else
		m_pLogObject->WriteW( L"CLDAPClassProvider :: InitializeLDAPProvider ADsOpenObject on RootDSE FAILED : %x\r\n", result);

}

//***************************************************************************
//
// CLDAPCache::~CLDAPCache
//
// Purpose : Destructor 
//
//***************************************************************************

CLDAPCache :: ~CLDAPCache()
{
	dwLDAPCacheCount--;
	if(m_pDirectorySearchSchemaContainer)
		m_pDirectorySearchSchemaContainer->Release();

	delete [] m_lpszSchemaContainerSuffix;
	delete [] m_lpszSchemaContainerPath;
}

//***************************************************************************
//
// CLDAPCache::GetProperty
//
// Purpose : Retreives the IDirectory interface of an LDAP property
//
// Parameters: 
//	lpszPropertyName : The name of the LDAP Property to be retreived
//	ppADSIProperty : The address of the pointer where the CADSIProperty object will be placed
//	bWBEMName : True if the lpszPropertyName is the WBEM name. False, if it is the LDAP name
//
//	Return value:
//		The COM value representing the return status. The user should release the object when done.
//		
//***************************************************************************
HRESULT CLDAPCache :: GetProperty(LPCWSTR lpszPropertyName, CADSIProperty **ppADSIProperty, BOOLEAN bWBEMName)
{
	HRESULT result = E_FAIL;

	// Get the LDAP property name from the WBEM class name
	LPWSTR lpszLDAPPropertyName = NULL;
	if(bWBEMName)
		lpszLDAPPropertyName = CLDAPHelper::UnmangleWBEMNameToLDAP(lpszPropertyName);
	else
		lpszLDAPPropertyName = (LPWSTR)lpszPropertyName; // Save a copy by casting, be careful when deleting

	// This is a cached implementation
	// Check the object tree first
	//===================================

	if((*ppADSIProperty) = (CADSIProperty *) m_objectTree.GetElement(lpszLDAPPropertyName))
	{
		// Found it in the tree. Nothing more to be done. It has already been 'addreff'ed
		result = S_OK;
	}
	else // Get it from ADSI 
	{
		if(!m_pDirectorySearchSchemaContainer)
		{
			if(!SUCCEEDED(result = ADsOpenObject(m_lpszSchemaContainerPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectorySearch, (LPVOID *) &m_pDirectorySearchSchemaContainer)))
				result = E_FAIL;
		}
		else
			result = S_OK;

		if(SUCCEEDED(result))
		{
			// Search for the property
			LPWSTR lpszQuery = NULL;
			lpszQuery = new WCHAR[ wcslen(OBJECT_CATEGORY_EQUALS_ATTRIBUTE_SCHEMA) + wcslen(LDAP_DISPLAY_NAME_ATTR) + wcslen(lpszLDAPPropertyName) + 20];
			wcscpy(lpszQuery, LEFT_BRACKET_STR);
			wcscat(lpszQuery, AMPERSAND_STR);
			wcscat(lpszQuery, OBJECT_CATEGORY_EQUALS_ATTRIBUTE_SCHEMA);
			wcscat(lpszQuery, LEFT_BRACKET_STR);
			wcscat(lpszQuery, LDAP_DISPLAY_NAME_ATTR);
			wcscat(lpszQuery, EQUALS_STR);
			wcscat(lpszQuery, lpszLDAPPropertyName);
			wcscat(lpszQuery, RIGHT_BRACKET_STR);
			wcscat(lpszQuery, RIGHT_BRACKET_STR);

			ADS_SEARCH_HANDLE hADSSearchOuter;
			if(SUCCEEDED(result = m_pDirectorySearchSchemaContainer->ExecuteSearch(lpszQuery, NULL, -1, &hADSSearchOuter)))
			{
				if(SUCCEEDED(result = m_pDirectorySearchSchemaContainer->GetNextRow(hADSSearchOuter)) &&
					result != S_ADS_NOMORE_ROWS)
				{
					*ppADSIProperty = new CADSIProperty();

					// Fill in the details of the property
					if(SUCCEEDED(result = FillInAProperty(*ppADSIProperty, hADSSearchOuter)))
					{
						// Add the property to the tree
						m_objectTree.AddElement((*ppADSIProperty)->GetADSIPropertyName(), *ppADSIProperty);
						// No need to release it since we're returning it
					}
					else
					{
						delete *ppADSIProperty;
						*ppADSIProperty = NULL;
					}

				}
				m_pDirectorySearchSchemaContainer->CloseSearchHandle(hADSSearchOuter);
			}
			delete [] lpszQuery;
		}
	}

	// Delete only what was allocated in this function
	//================================================
	if(bWBEMName)
		delete[] lpszLDAPPropertyName;

	return result;
}

//***************************************************************************
//
// CLDAPCache::GetClass
//
// Purpose : See Header File
//		
//***************************************************************************
HRESULT CLDAPCache :: GetClass(LPCWSTR lpszWBEMClassName, LPCWSTR lpszLDAPClassName, CADSIClass **ppADSIClass)
{
	/************************************************************
	*************************************************************
	***** NO Cache implementation for now. Always fetch everytime
	*************************************************************
	*************************************************************/

	*ppADSIClass = new CADSIClass(lpszWBEMClassName, lpszLDAPClassName);

	HRESULT result = E_FAIL;
	if(!m_pDirectorySearchSchemaContainer)
	{
		if(!SUCCEEDED(result = ADsOpenObject(m_lpszSchemaContainerPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectorySearch, (LPVOID *) &m_pDirectorySearchSchemaContainer)))
			result = E_FAIL;
	}
	else
		result = S_OK;

	if(SUCCEEDED(result))
	{
		result = CLDAPHelper::GetLDAPClassFromLDAPName(m_pDirectorySearchSchemaContainer,
			m_lpszSchemaContainerSuffix,
			m_pSearchInfo,
			2,
			*ppADSIClass
			);
	}

	if(!SUCCEEDED(result))
	{
		delete *ppADSIClass;
		*ppADSIClass = NULL;
	}

	return result;
}

//***************************************************************************
//
// CLDAPCache::GetSchemaContainerSearch
//
// Purpose : To return the IDirectorySearch interface on the schema container
//
// Parameters:
//	ppDirectorySearch : The address where the pointer to the required interface will
//		be stored.
//
// 
//	Return Value: The COM result representing the status. The user should release
//	the interface pointer when done with it.
//***************************************************************************
HRESULT CLDAPCache :: GetSchemaContainerSearch(IDirectorySearch ** ppDirectorySearch)
{
	if(m_pDirectorySearchSchemaContainer)
	{
		*ppDirectorySearch = m_pDirectorySearchSchemaContainer;
		(*ppDirectorySearch)->AddRef();
		return S_OK;
	}
	else
		return E_FAIL;

}

//***************************************************************************
//
// CLDAPCache::EnumerateClasses
//
// Purpose : See Header
//		
//***************************************************************************
HRESULT CLDAPCache::EnumerateClasses(LPCWSTR lpszWBEMSuperclass,
	BOOLEAN bDeep,
	LPWSTR **pppADSIClasses,
	DWORD *pdwNumRows,
	BOOLEAN bArtificialClass)
{
	// Get the LDAP name of the super class
	// Do not mangle if it one of the classes that we know
	//=====================================================
	LPWSTR lpszLDAPSuperClassName = NULL;
	if(_wcsicmp(lpszWBEMSuperclass, LDAP_BASE_CLASS) != 0)
	{
		lpszLDAPSuperClassName = CLDAPHelper::UnmangleWBEMNameToLDAP(lpszWBEMSuperclass);
		if(!lpszLDAPSuperClassName) // We were returned a NULL by the Unmangler, so not a DS class
		{
			*pppADSIClasses = NULL;
			*pdwNumRows = 0;
			return S_OK;
		}
	}

	HRESULT result = E_FAIL;
	if(!m_pDirectorySearchSchemaContainer)
	{
		if(!SUCCEEDED(result = ADsOpenObject(m_lpszSchemaContainerPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectorySearch, (LPVOID *) &m_pDirectorySearchSchemaContainer)))
			result = E_FAIL;
	}
	else
		result = S_OK;

	if(SUCCEEDED(result))
	{
		result = CLDAPHelper::EnumerateClasses(m_pDirectorySearchSchemaContainer, 
							m_lpszSchemaContainerSuffix, 
							m_pSearchInfo,
							2,
							lpszLDAPSuperClassName, 
							bDeep, 
							pppADSIClasses, 
							pdwNumRows,
							bArtificialClass);
	}

	// If the superclass is an artificial class like "ADS_User", then a concrete sub-class "DS_User" exists.
	// This is added manually here, to both the EnumInfoList as well as the structure being returned
	// The above call to EnumerateClasses would have helpfully left an extra element unfilled at the beginning
	// of the array
	if(SUCCEEDED(result) && bArtificialClass)
	{
		(*pppADSIClasses)[0] = new WCHAR[wcslen(lpszWBEMSuperclass+1) + 1];
		wcscpy((*pppADSIClasses)[0], lpszWBEMSuperclass+1); 
	}

	delete[] lpszLDAPSuperClassName;
	return result;
}

//***************************************************************************
//
// CLDAPCache::IsInitialized
//
// Purpose : Indicates whether the cache was created and initialized succeddfully
//
// Parameters: 
//	None
//
//	Return value:
//		A boolean value indicating the status
//		
//***************************************************************************

BOOLEAN CLDAPCache :: IsInitialized()
{
	return m_isInitialized;
}




//***************************************************************************
//
// CLDAPCache :: InitializeObjectTree
//
// Purpose : Initialize the lexically ordered binary tree with all the properties 
//	LDAP
//
// Parameters:
//	None
// 
//	Return Value: The COM status representing the return value
//***************************************************************************

HRESULT CLDAPCache :: InitializeObjectTree()
{
	// Get the attributes of all the instances of the
	// class "AttributeSchema"
	//=================================================
	HRESULT result = E_FAIL;

/*
	// Now perform a search for all the attributes
	//============================================
	if(SUCCEEDED(result = m_pDirectorySearchSchemaContainer->SetSearchPreference(m_pSearchInfo, 2)))
	{
		ADS_SEARCH_HANDLE hADSSearchOuter;
		
		// Count of attributes
		DWORD dwCount = 0;

		if(SUCCEEDED(result = m_pDirectorySearchSchemaContainer->ExecuteSearch((LPWSTR)OBJECT_CATEGORY_EQUALS_ATTRIBUTE_SCHEMA, NULL, -1, &hADSSearchOuter)))
		{
			CADSIProperty *pNextProperty;
			while(SUCCEEDED(result = m_pDirectorySearchSchemaContainer->GetNextRow(hADSSearchOuter)) &&
				result != S_ADS_NOMORE_ROWS)
			{
				pNextProperty = new CADSIProperty();
				dwCount ++;

				// Fill in the details of the property
				FillInAProperty(pNextProperty, hADSSearchOuter);

				// Add the property to the tree
				m_objectTree.AddElement(pNextProperty->GetADSIPropertyName(), pNextProperty);
				pNextProperty->Release();
			}
			m_pDirectorySearchSchemaContainer->CloseSearchHandle(hADSSearchOuter);
		}

		m_pLogObject->WriteW( L"CLDAPCache :: InitializeObjectTree() Initialized with %d attributes\r\n", dwCount);
	}
	else
		m_pLogObject->WriteW( L"CLDAPCache :: InitializeObjectTree() SetSearchPreference() FAILED with %x\r\n", result);

*/
	return result;
}

HRESULT CLDAPCache :: FillInAProperty(CADSIProperty *pNextProperty, ADS_SEARCH_HANDLE hADSSearchOuter)
{
	ADS_SEARCH_COLUMN adsNextColumn;
	HRESULT result = E_FAIL;
	LPWSTR lpszWBEMName = NULL;
	BOOLEAN bNeedToCheckForORName = FALSE;
	if(SUCCEEDED(result = m_pDirectorySearchSchemaContainer->GetColumn( hADSSearchOuter, (LPWSTR)ATTRIBUTE_SYNTAX_ATTR, &adsNextColumn )))
	{
		if(adsNextColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
			result = E_FAIL;
		else
		{
			pNextProperty->SetSyntaxOID(adsNextColumn.pADsValues->CaseIgnoreString);
			if(_wcsicmp(adsNextColumn.pADsValues->CaseIgnoreString, DN_WITH_BINARY_OID) == 0)
				bNeedToCheckForORName = TRUE;
		}
		m_pDirectorySearchSchemaContainer->FreeColumn( &adsNextColumn );
	}

	if(SUCCEEDED(result) && SUCCEEDED(result = m_pDirectorySearchSchemaContainer->GetColumn( hADSSearchOuter, (LPWSTR)IS_SINGLE_VALUED_ATTR, &adsNextColumn )))
	{
		if(adsNextColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
			result = E_FAIL;
		else
			pNextProperty->SetMultiValued( (adsNextColumn.pADsValues->Boolean)? FALSE : TRUE);
		m_pDirectorySearchSchemaContainer->FreeColumn( &adsNextColumn );
	}

	if(SUCCEEDED(result) && SUCCEEDED(result = m_pDirectorySearchSchemaContainer->GetColumn( hADSSearchOuter, (LPWSTR)ATTRIBUTE_ID_ATTR, &adsNextColumn )))
	{
		if(adsNextColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
			result = E_FAIL;
		else
			pNextProperty->SetAttributeID(adsNextColumn.pADsValues->CaseIgnoreString);
		m_pDirectorySearchSchemaContainer->FreeColumn( &adsNextColumn );
	}

	if(SUCCEEDED(result) && SUCCEEDED(result = m_pDirectorySearchSchemaContainer->GetColumn( hADSSearchOuter, (LPWSTR)COMMON_NAME_ATTR, &adsNextColumn )))
	{
		if(adsNextColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
			result = E_FAIL;
		else
			pNextProperty->SetCommonName(adsNextColumn.pADsValues->CaseIgnoreString);
		m_pDirectorySearchSchemaContainer->FreeColumn( &adsNextColumn );
	}

	if(SUCCEEDED(result) && SUCCEEDED(result = m_pDirectorySearchSchemaContainer->GetColumn( hADSSearchOuter, (LPWSTR)LDAP_DISPLAY_NAME_ATTR, &adsNextColumn )))
	{
		if(adsNextColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
			result = E_FAIL;
		else
		{
			pNextProperty->SetADSIPropertyName(adsNextColumn.pADsValues->CaseIgnoreString);
			lpszWBEMName = CLDAPHelper::MangleLDAPNameToWBEM(adsNextColumn.pADsValues->CaseIgnoreString);
			pNextProperty->SetWBEMPropertyName(lpszWBEMName);
			delete []lpszWBEMName;
		}
		m_pDirectorySearchSchemaContainer->FreeColumn( &adsNextColumn );
	}

	if(SUCCEEDED(result) && SUCCEEDED(m_pDirectorySearchSchemaContainer->GetColumn( hADSSearchOuter, (LPWSTR)MAPI_ID_ATTR, &adsNextColumn )))
	{
		if(adsNextColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
			result = E_FAIL;
		else
			pNextProperty->SetMAPI_ID(adsNextColumn.pADsValues->Integer);
		m_pDirectorySearchSchemaContainer->FreeColumn( &adsNextColumn );
	}

	if(SUCCEEDED(result) && SUCCEEDED(result = m_pDirectorySearchSchemaContainer->GetColumn( hADSSearchOuter, (LPWSTR)OM_SYNTAX_ATTR, &adsNextColumn )))
	{
		if(adsNextColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
			result = E_FAIL;
		else
			pNextProperty->SetOMSyntax(adsNextColumn.pADsValues->Integer);
		m_pDirectorySearchSchemaContainer->FreeColumn( &adsNextColumn );
	}

	if(bNeedToCheckForORName && SUCCEEDED(result) && SUCCEEDED(m_pDirectorySearchSchemaContainer->GetColumn( hADSSearchOuter, (LPWSTR)OM_OBJECT_CLASS_ATTR, &adsNextColumn )))
	{
		if(adsNextColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
			result = E_FAIL;
		else
		{
			// Just the first octet in the LPBYTE array is enough for differntiating between ORName and DNWithBinary
			if((adsNextColumn.pADsValues->OctetString).lpValue[0] == 0x56)
				pNextProperty->SetORName(TRUE);
		}
		m_pDirectorySearchSchemaContainer->FreeColumn( &adsNextColumn );
	}

	if(SUCCEEDED(result) && SUCCEEDED(m_pDirectorySearchSchemaContainer->GetColumn( hADSSearchOuter, (LPWSTR)SEARCH_FLAGS_ATTR, &adsNextColumn )))
	{
		if(adsNextColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
			result = E_FAIL;
		else
			pNextProperty->SetSearchFlags(adsNextColumn.pADsValues->Integer);
		m_pDirectorySearchSchemaContainer->FreeColumn( &adsNextColumn );
	}

	if(SUCCEEDED(result) && SUCCEEDED(m_pDirectorySearchSchemaContainer->GetColumn( hADSSearchOuter, (LPWSTR)SYSTEM_ONLY_ATTR, &adsNextColumn )))
	{
		if(adsNextColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
			result = E_FAIL;
		else
			pNextProperty->SetSystemOnly(TRUE);
		m_pDirectorySearchSchemaContainer->FreeColumn( &adsNextColumn );
	}

	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\classprovider\include\dscpguid.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:guids.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains GUID definitions used in this project
//
//***************************************************************************

//
// The CLSID of the DS Provider - {1EF94880-01A8-11d2-A90B-00AA00BF3363}
//
DEFINE_GUID(CLSID_DSProvider, 0x1ef94880, 0x1a8, 0x11d2, 0xa9, 0xb, 0x0, 0xaa, 0x0, 0xbf, 0x33, 0x63);

//
// The CLSID of the DS Class ASsociations Provider - {33831ED4-42B8-11d2-93AD-00805F853771}
//
DEFINE_GUID(CLSID_DSClassAssocProvider, 0x33831ed4, 0x42b8, 0x11d2, 0x93, 0xad, 0x0, 0x80, 0x5f, 0x85, 0x37, 0x71);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\classprovider\ldapproi.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:ldapproi.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains implementation of the class that is used to initialize the
//	CLDAPClassProvider class
//
//***************************************************************************

#include <tchar.h>
#include <stdio.h>

#include <windows.h>
#include <objbase.h>

/* WBEM includes */
#include <wbemcli.h>
#include <wbemprov.h>
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>

/* ADSI includes */
#include <activeds.h>

/* DS Provider includes */
#include "clsname.h"
#include "attributes.h"
#include "dscpguid.h"
#include "provlog.h"
#include "refcount.h"
#include "adsiprop.h"
#include "adsiclas.h"
#include "tree.h"
#include "wbemcach.h"
#include "classpro.h"
#include "clsproi.h"
#include "ldapcach.h"
#include "ldapprov.h"
#include "ldapproi.h"


//***************************************************************************
//
// CLDAPClassProviderInitializer::CLDAPClassProviderInitializer
//
// Constructor Parameters:
//		None
//
//  
//***************************************************************************

CLDAPClassProviderInitializer :: CLDAPClassProviderInitializer (ProvDebugLog *pLogObject)
{
	CLDAPClassProvider :: LDAP_BASE_CLASS_STR			= SysAllocString(LDAP_BASE_CLASS);
	CLDAPClassProvider :: LDAP_CLASS_PROVIDER_NAME		= SysAllocString(L"Microsoft|DSLDAPClassProvider|V1.0");
	CLDAPClassProvider :: LDAP_INSTANCE_PROVIDER_NAME	= SysAllocString(L"Microsoft|DSLDAPInstanceProvider|V1.0");

	// WBEM Class Qualfiers
	CLDAPClassProvider :: DYNAMIC_BSTR						= SysAllocString(L"dynamic");
	CLDAPClassProvider :: PROVIDER_BSTR						= SysAllocString(L"provider");
	CLDAPClassProvider :: ABSTRACT_BSTR						= SysAllocString(L"abstract");
	CLDAPClassProvider :: COMMON_NAME_ATTR_BSTR				= SysAllocString(COMMON_NAME_ATTR);
	CLDAPClassProvider :: LDAP_DISPLAY_NAME_ATTR_BSTR		= SysAllocString(LDAP_DISPLAY_NAME_ATTR);
	CLDAPClassProvider :: GOVERNS_ID_ATTR_BSTR				= SysAllocString(GOVERNS_ID_ATTR);
	CLDAPClassProvider :: SCHEMA_ID_GUID_ATTR_BSTR			= SysAllocString(SCHEMA_ID_GUID_ATTR);
	CLDAPClassProvider :: MAPI_DISPLAY_TYPE_ATTR_BSTR		= SysAllocString(MAPI_DISPLAY_TYPE_ATTR);
	CLDAPClassProvider :: RDN_ATT_ID_ATTR_BSTR				= SysAllocString(RDN_ATT_ID_ATTR);
	CLDAPClassProvider :: SYSTEM_MUST_CONTAIN_ATTR_BSTR		= SysAllocString(SYSTEM_MUST_CONTAIN_ATTR);
	CLDAPClassProvider :: MUST_CONTAIN_ATTR_BSTR			= SysAllocString(MUST_CONTAIN_ATTR);
	CLDAPClassProvider :: SYSTEM_MAY_CONTAIN_ATTR_BSTR		= SysAllocString(SYSTEM_MAY_CONTAIN_ATTR);
	CLDAPClassProvider :: MAY_CONTAIN_ATTR_BSTR				= SysAllocString(MAY_CONTAIN_ATTR);
	CLDAPClassProvider :: SYSTEM_POSS_SUPERIORS_ATTR_BSTR	= SysAllocString(SYSTEM_POSS_SUPERIORS_ATTR);
	CLDAPClassProvider :: POSS_SUPERIORS_ATTR_BSTR			= SysAllocString(POSS_SUPERIORS_ATTR);
	CLDAPClassProvider :: SYSTEM_AUXILIARY_CLASS_ATTR_BSTR	= SysAllocString(SYSTEM_AUXILIARY_CLASS_ATTR);
	CLDAPClassProvider :: AUXILIARY_CLASS_ATTR_BSTR			= SysAllocString(AUXILIARY_CLASS_ATTR);
	CLDAPClassProvider :: DEFAULT_SECURITY_DESCRP_ATTR_BSTR	= SysAllocString(DEFAULT_SECURITY_DESCRP_ATTR);
	CLDAPClassProvider :: OBJECT_CLASS_CATEGORY_ATTR_BSTR	= SysAllocString(OBJECT_CLASS_CATEGORY_ATTR);
	CLDAPClassProvider :: SYSTEM_ONLY_ATTR_BSTR				= SysAllocString(SYSTEM_ONLY_ATTR);
	CLDAPClassProvider :: NT_SECURITY_DESCRIPTOR_ATTR_BSTR	= SysAllocString(NT_SECURITY_DESCRIPTOR_ATTR);
	CLDAPClassProvider :: DEFAULT_OBJECTCATEGORY_ATTR_BSTR	= SysAllocString(DEFAULT_OBJECTCATEGORY_ATTR);

	// WBEM Property Qualifiers
	CLDAPClassProvider :: SYSTEM_BSTR						= SysAllocString(L"system");
	CLDAPClassProvider :: NOT_NULL_BSTR						= SysAllocString(L"not_null");
	CLDAPClassProvider :: INDEXED_BSTR						= SysAllocString(L"indexed");
	CLDAPClassProvider :: ATTRIBUTE_SYNTAX_ATTR_BSTR		= SysAllocString(L"attributeSyntax");
	CLDAPClassProvider :: ATTRIBUTE_ID_ATTR_BSTR			= SysAllocString(L"attributeID");
	CLDAPClassProvider :: MAPI_ID_ATTR_BSTR					= SysAllocString(L"MAPI_ID");
	CLDAPClassProvider :: OM_SYNTAX_ATTR_BSTR				= SysAllocString(L"OM_Syntax");
	CLDAPClassProvider :: RANGE_LOWER_ATTR_BSTR				= SysAllocString(L"Range_Lower");
	CLDAPClassProvider :: RANGE_UPPER_ATTR_BSTR				= SysAllocString(L"Range_Upper");
	CLDAPClassProvider :: CIMTYPE_STR						= SysAllocString(L"Cimtype");
	CLDAPClassProvider :: EMBED_UINT8ARRAY					= SysAllocString(L"object:Uint8Array");
	CLDAPClassProvider :: EMBED_DN_WITH_STRING				= SysAllocString(L"object:DN_With_String");
	CLDAPClassProvider :: EMBED_DN_WITH_BINARY				= SysAllocString(L"object:DN_WIth_Binary");

	// WBEM Property names
	CLDAPClassProvider :: DYNASTY_BSTR						= SysAllocString(L"__DYNASTY");

	// The property cache
	CLDAPClassProvider :: s_pLDAPCache = new CLDAPCache(pLogObject);
}

//***************************************************************************
//
// CLDAPClassProviderInitializer::CLDAPClassProviderInitializer
//
// Destructor
//
//***************************************************************************
CLDAPClassProviderInitializer :: ~CLDAPClassProviderInitializer ()
{
	SysFreeString(CLDAPClassProvider::LDAP_BASE_CLASS_STR);
	SysFreeString(CLDAPClassProvider::LDAP_CLASS_PROVIDER_NAME);
	SysFreeString(CLDAPClassProvider::LDAP_INSTANCE_PROVIDER_NAME);

	// Class Qualifiers
	SysFreeString(CLDAPClassProvider::DYNAMIC_BSTR);
	SysFreeString(CLDAPClassProvider::PROVIDER_BSTR);
	SysFreeString(CLDAPClassProvider::ABSTRACT_BSTR);
	SysFreeString(CLDAPClassProvider::COMMON_NAME_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::LDAP_DISPLAY_NAME_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::GOVERNS_ID_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::SCHEMA_ID_GUID_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::MAPI_DISPLAY_TYPE_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::RDN_ATT_ID_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::SYSTEM_MUST_CONTAIN_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::MUST_CONTAIN_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::SYSTEM_MAY_CONTAIN_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::MAY_CONTAIN_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::SYSTEM_POSS_SUPERIORS_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::POSS_SUPERIORS_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::SYSTEM_AUXILIARY_CLASS_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::AUXILIARY_CLASS_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::DEFAULT_SECURITY_DESCRP_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::OBJECT_CLASS_CATEGORY_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::SYSTEM_ONLY_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::NT_SECURITY_DESCRIPTOR_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::DEFAULT_OBJECTCATEGORY_ATTR_BSTR);

	// Property Qualifiers
	SysFreeString(CLDAPClassProvider::SYSTEM_BSTR);
	SysFreeString(CLDAPClassProvider::NOT_NULL_BSTR);
	SysFreeString(CLDAPClassProvider::INDEXED_BSTR);
	SysFreeString(CLDAPClassProvider::ATTRIBUTE_SYNTAX_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::ATTRIBUTE_ID_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::MAPI_ID_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::OM_SYNTAX_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::RANGE_LOWER_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::RANGE_UPPER_ATTR_BSTR);
	SysFreeString(CLDAPClassProvider::CIMTYPE_STR);
	SysFreeString(CLDAPClassProvider::EMBED_UINT8ARRAY);
	SysFreeString(CLDAPClassProvider::EMBED_DN_WITH_STRING);
	SysFreeString(CLDAPClassProvider::EMBED_DN_WITH_BINARY);

	// WBEM Property names
	SysFreeString(CLDAPClassProvider::DYNASTY_BSTR);

	// The property cache
	delete CLDAPClassProvider :: s_pLDAPCache;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\classprovider\include\assocprov.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:assocprov.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the DS Class Provider class. This is
//	the base class for all DS Class Providers. Note that an instance of the CLDAPClassAsssociationsProviderInitializer
//	class has to be created to initialize the static members of the CLDAPClassAsssociationsProvider class. Hence exactly
//	one instance of the CLDAPClassAsssociationsProviderInitializer class should be created for this
//	class to function properly.
//
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef DS_CLASS_ASSOC_PROVIDER_H
#define DS_CLASS_ASSOC_PROVIDER_H


class CLDAPClassAsssociationsProvider : public IWbemProviderInit, public IWbemServices
{

public:

	// Create the object 
    CLDAPClassAsssociationsProvider (ProvDebugLog *pLogObject) ;
    virtual ~CLDAPClassAsssociationsProvider () ;

	////////////////////////////////////////
	//IUnknown members
	////////////////////////////////////////
	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;


	////////////////////////////////////////
	//IWbemProviderInit members
	////////////////////////////////////////
	virtual HRESULT STDMETHODCALLTYPE Initialize( 
            LPWSTR wszUser,
            LONG lFlags,
            LPWSTR wszNamespace,
            LPWSTR wszLocale,
            IWbemServices __RPC_FAR *pNamespace,
            IWbemContext __RPC_FAR *pCtx,
            IWbemProviderInitSink __RPC_FAR *pInitSink) ;

		
	////////////////////////////////////////
	//IWbemServices members
	////////////////////////////////////////
    virtual HRESULT STDMETHODCALLTYPE OpenNamespace( 
        /* [in] */ const BSTR strNamespace,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult);
    
    virtual HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink);
    
    virtual HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE GetObject( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE GetObjectAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE PutClass( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE PutClassAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteClass( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE CreateClassEnum( 
        /* [in] */ const BSTR strSuperclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
        /* [in] */ const BSTR strSuperclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE PutInstance( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteInstance( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE ExecQuery( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE ExecMethod( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ const BSTR strMethodName,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ const BSTR strMethodName,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);




protected:
	// Checks whether a containment is valid
	HRESULT IsContainedIn(LPCWSTR lpszChildClass, LPCWSTR lpszParentClass);

	// A helper function to do the ADSI LDAP provider specific initialization.
	BOOLEAN InitializeAssociationsProvider(IWbemContext *pCtx);

	// The Logging object
	ProvDebugLog *m_pLogObject;

	// The IWbemServices pointer stored from Initialize()
	IWbemServices *m_IWbemServices;

	// Creates an instance of the association class
	HRESULT CreateInstance(BSTR strChildName, BSTR strParentName, IWbemClassObject **ppInstance);

	// Does enumeration of instnaces of the association class
	HRESULT DoEnumeration(IWbemObjectSink *pResponseHandler);

private:

	// The Log File name
	static LPCWSTR s_LogFileName;

	// Indicates whether the call to Initialize() was successful
	BOOLEAN m_bInitializedSuccessfully;

	// The COM Reference count
    long m_lReferenceCount ;

	// The class for which instances are provider
	IWbemClassObject *m_pAssociationClass;

	// The path to the schema container
	LPWSTR m_lpszSchemaContainerSuffix;

	// The IDirectorySearch interface of the schema container
	IDirectorySearch *m_pDirectorySearchSchemaContainer;

	// Some literals
	static LPCWSTR CHILD_CLASS_PROPERTY;
	static LPCWSTR PARENT_CLASS_PROPERTY;
	static LPCWSTR POSSIBLE_SUPERIORS;
	BSTR CHILD_CLASS_PROPERTY_STR;
	BSTR PARENT_CLASS_PROPERTY_STR;
	BSTR CLASS_ASSOCIATION_CLASS_STR;
	BSTR POSSIBLE_SUPERIORS_STR;
	static LPCWSTR SCHEMA_NAMING_CONTEXT;
	static LPCWSTR LDAP_SCHEMA;
	static LPCWSTR LDAP_SCHEMA_SLASH;
};


#endif // DS_CLASS_ASSOC_PROVIDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\classprovider\wbemcach.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include <stdio.h>
#include <windows.h>

/* WBEM includes */
#include <wbemcli.h>

#include "provlog.h"
#include "refcount.h"
#include "tree.h"
#include "clsname.h"
#include "wbemcach.h"

// Initialize the statics
const __int64 CWbemCache :: MAX_CACHE_AGE = 60*60*20; // In seconds, 4 Hours
const DWORD CWbemCache :: MAX_CACHE_SIZE = 500;

DWORD CWbemCache:: dwWBEMCacheCount = 0;
DWORD CEnumInfo:: dwCEnumInfoCount = 0;
DWORD CWbemClass:: dwCWbemClassCount = 0;

//***************************************************************************
//
// CWbemCache::CWbemCache
//
// Purpose : Constructor. Creates an empty cache
//
// Parameters: 
//***************************************************************************

CWbemCache :: CWbemCache(ProvDebugLog *pLogObject)
{
	dwWBEMCacheCount ++;
	m_pLogObject = pLogObject;
}

//***************************************************************************
//
// CWbemCache::GetClass
//
// Purpose : Retreives the CWbemClass object, if present in the cache. Otherwise returns NULL
//
// Parameters: 
//	lpszClassName : The WBEM name of the Class to be retreived. 
//	ppWbemClass : The address of the pointer where the CWbemClass object will be placed
//
//	Return value:
//		The COM value representing the return status. The user should release the WBEM cclass
// when done.
//		
//***************************************************************************
HRESULT CWbemCache :: GetClass(LPCWSTR lpszWbemClassName, CWbemClass **ppWbemClass )
{
#ifdef NO_WBEM_CACHE
	return E_FAIL;
#else
	if(*ppWbemClass = (CWbemClass *)m_objectTree.GetElement(lpszWbemClassName))
	{
		// Get the current time
		FILETIME fileTime;
		GetSystemTimeAsFileTime(&fileTime);
		LARGE_INTEGER currentTime;
		memcpy((LPVOID)&currentTime, (LPVOID)&fileTime, sizeof LARGE_INTEGER);

		// The QuadPart is in number of 100s of NanoSeconds.
		// Delete the object if is too old, and return failure
		// timeElapsed is the amount of time in seconds
		__int64 timeElapsed = ( currentTime.QuadPart - (*ppWbemClass)->GetCreationTime());
		timeElapsed = timeElapsed/(__int64)10000000;
		if( timeElapsed	> MAX_CACHE_AGE ) // in Seconds
		{
			(*ppWbemClass)->Release();
			*ppWbemClass = NULL;
			m_objectTree.DeleteElement(lpszWbemClassName);
			m_pLogObject->WriteW( L"CWbemCache :: GetClass() Deleted senile class : %s\r\n", lpszWbemClassName);
			return E_FAIL;
		}

		// Set its last accessed time
		(*ppWbemClass)->SetLastAccessTime(currentTime.QuadPart);

		return S_OK;
	}

	return E_FAIL;
#endif
}

//***************************************************************************
//
// CWbemCache::AddClass
//
// Purpose : Adds the CWbemClass object to the cache
//
// Parameters: 
//	ppWbemClass : The CWbemClass pointer of the object to be added
//
//	Return value:
//		The COM value representing the return status. 
// when done.
//		
//***************************************************************************
HRESULT CWbemCache :: AddClass(CWbemClass *pWbemClass )
{
#ifdef NO_WBEM_CACHE
	return E_FAIL;
#else
	// Delete an element from the tree if its size has reached a limit of 100 nodes
	if(m_objectTree.GetNumberOfElements() >= MAX_CACHE_SIZE)
	{
		if(!m_objectTree.DeleteLeastRecentlyAccessedElement())
			return E_FAIL;
		m_pLogObject->WriteW( L"CWbemCache :: AddClass() Deleted LRU class from cache\r\n");
	}

	// Add the new element
	if(m_objectTree.AddElement(pWbemClass->GetName(), pWbemClass))
	{
		m_pLogObject->WriteW( L"CWbemCache :: AddClass() Added a class %s to cache\r\n", pWbemClass->GetName());
		return S_OK;
	}
	return E_FAIL;
#endif
}

//***************************************************************************
//
// CWbemCache::GetEnumInfo
//
// Purpose : Retreives the CEnumInfo object, if present in the cache. Otherwise returns NULL
//
// Parameters: 
//	lpszClassName : The WBEM name of the Class to be retreived. 
//	ppEnumInfo : The address of the pointer where the CEnumInfo object will be placed
//
//	Return value:
//		The COM value representing the return status. The user should release the EnumInfo object
// when done.
//		
//***************************************************************************
HRESULT CWbemCache :: GetEnumInfo(LPCWSTR lpszWbemClassName, CEnumInfo **ppEnumInfo )
{
#ifdef NO_WBEM_CACHE
	return E_FAIL;
#else
	if(*ppEnumInfo = (CEnumInfo *)m_EnumTree.GetElement(lpszWbemClassName))
	{
		// Get the current time
		FILETIME fileTime;
		GetSystemTimeAsFileTime(&fileTime);
		LARGE_INTEGER currentTime;
		memcpy((LPVOID)&currentTime, (LPVOID)&fileTime, sizeof LARGE_INTEGER);

		// The QuadPart is in number of 100s of NanoSeconds.
		// Delete the object if is too old, and return failure
		// timeElapsed is the amount of time in seconds
		__int64 timeElapsed = ( currentTime.QuadPart - (*ppEnumInfo)->GetCreationTime());
		timeElapsed = timeElapsed/(__int64)10000000;
		if( timeElapsed	> MAX_CACHE_AGE ) // in Seconds
		{
			(*ppEnumInfo)->Release();
			*ppEnumInfo = NULL;
			m_EnumTree.DeleteElement(lpszWbemClassName);
			m_pLogObject->WriteW( L"CEnumCache :: GetClass() Deleted senile EnumInfo : %s\r\n", lpszWbemClassName);
			return E_FAIL;
		}

		// Set its last accessed time
		(*ppEnumInfo)->SetLastAccessTime(currentTime.QuadPart);

		return S_OK;
	}

	return E_FAIL;
#endif
}

//***************************************************************************
//
// CWbemCache::AddEnumInfo
//
// Purpose : Adds the CEnumInfo object to the cache
//
// Parameters: 
//	ppEnumInfo : The CEnumInfo pointer of the object to be added
//
//	Return value:
//		The COM value representing the return status. 
// when done.
//		
//***************************************************************************
HRESULT CWbemCache :: AddEnumInfo(CEnumInfo *pEnumInfo )
{
#ifdef NO_WBEM_CACHE
	return E_FAIL;
#else
	// Delete an element from the tree if its size has reached a limit of 100 nodes
	if(m_EnumTree.GetNumberOfElements() >= MAX_CACHE_SIZE)
	{
		if(!m_EnumTree.DeleteLeastRecentlyAccessedElement())
			return E_FAIL;
		m_pLogObject->WriteW( L"CEnumCache :: AddClass() Deleted LRU class from cache\r\n");
	}

	// Add the new element
	if(m_EnumTree.AddElement(pEnumInfo->GetName(), pEnumInfo))
	{
		m_pLogObject->WriteW( L"CEnumCache :: AddClass() Added a EnumInfo %s to cache\r\n", pEnumInfo->GetName());
		return S_OK;
	}
	return E_FAIL;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\classprovider\include\classpro.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:classpro.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the DS Class Provider class. This is
//	the base class for all DS Class Providers. Note that an instance of the CDSClassProviderInitializer
//	class has to be created to initialize the static members of the CDSClassProvider class. Hence exactly
//	one instance of the CDSClassProviderInitializer class should be created for this
//	class to function properly.
//
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef DS_CLASS_PROVIDER_H
#define DS_CLASS_PROVIDER_H

 
// Forward declaration for the initializer class
class CDSClassProviderInitializer;

class CDSClassProvider : public IWbemProviderInit, public IWbemServices
{
	// The initialization class is a friend of this class
	friend CDSClassProviderInitializer;

public:

	static DWORD dwClassProviderCount;
	// Create the object by passing the log object
    CDSClassProvider (ProvDebugLog *pLogObject) ;
    virtual ~CDSClassProvider () ;

	////////////////////////////////////////
	//IUnknown members
	////////////////////////////////////////
	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;


	////////////////////////////////////////
	//IWbemProviderInit members
	////////////////////////////////////////
	virtual HRESULT STDMETHODCALLTYPE Initialize( 
            LPWSTR wszUser,
            LONG lFlags,
            LPWSTR wszNamespace,
            LPWSTR wszLocale,
            IWbemServices __RPC_FAR *pNamespace,
            IWbemContext __RPC_FAR *pCtx,
            IWbemProviderInitSink __RPC_FAR *pInitSink) ;

		
	////////////////////////////////////////
	//IWbemServices members
	////////////////////////////////////////
    virtual HRESULT STDMETHODCALLTYPE OpenNamespace( 
        /* [in] */ const BSTR strNamespace,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult);
    
    virtual HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink);
    
    virtual HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE GetObject( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE GetObjectAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE PutClass( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE PutClassAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteClass( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE CreateClassEnum( 
        /* [in] */ const BSTR strSuperclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
        /* [in] */ const BSTR strSuperclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE PutInstance( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteInstance( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE ExecQuery( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE ExecMethod( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ const BSTR strMethodName,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ const BSTR strMethodName,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);




protected:

#ifdef PROFILING
	// Used for profiling. Should be removed.
	DWORD dwStartTime;
#endif

	////////////////////////////////////////////////
	// Functions for interacting with ADSI providers
	////////////////////////////////////////////////
	//***************************************************************************
	//
	// CDSClassProvider::GetWBEMProviderName
	//
	// Purpose : Returns the name of the provider. This should be the same as the
	// value of the field Name in the __Win32Provider instance used for registration
	// of the provider
	//
	// Parameters:
	//	None
	// 
	//	Return Value: The name of the provider
	//***************************************************************************
	virtual const BSTR GetWBEMProviderName() = 0;

	//***************************************************************************
	//
	// CDSClassProvider::IsUnProvidedClass
	//
	// Purpose : To check whether a class is one that the provider does not provide
	//
	// Parameters:
	//	lpszClassName : The WBEM Name of the class to be checked
	//
	// 
	//	Return Value: TRUE is this is one of the classes not provided by the provider
	//***************************************************************************
	virtual BOOLEAN IsUnProvidedClass(LPCWSTR lpszClassName) = 0;

	//***************************************************************************
	//
	// CDSClassProvider::GetClassFromCacheOrADSI
	//
	// Purpose : To create a WBEM class from an ADSI Class
	//
	// Parameters:
	//	lpszClassName : The WBEM Name of the class to be retreived
	//	pCtx : A pointer to the context object that was used in this call. This
	//		may be used by this function to make calls to CIMOM
	//
	// 
	//	Return Value: The COM result representing the status. 
	//***************************************************************************
	virtual HRESULT GetClassFromCacheOrADSI(LPCWSTR pszWBEMClassName, 
		IWbemClassObject **ppReturnObject,
		IWbemContext *pCtx);

	//***************************************************************************
	//
	// CDSClassProvider::GetClassFromADSI
	//
	// Purpose : To create a WBEM class from an ADSI Class
	//
	// Parameters:
	//	lpszClassName : The WBEM Name of the class to be retreived
	//	pCtx : A pointer to the context object that was used in this call. This
	//		may be used by this function to make calls to CIMOM
	//	ppWbemClass : The resulting WBEM Class. This has to be released once the
	//		user is done with it.
	//
	// 
	//	Return Value: The COM result representing the status. 
	//***************************************************************************
	virtual HRESULT GetClassFromADSI( 
		LPCWSTR lpszClassName,
		IWbemContext *pCtx,
		IWbemClassObject ** ppWbemClass
		) = 0;	

	//***************************************************************************
	//
	// CDSClassProvider::GetADSIClass
	//
	// Purpose : To Create a CADSIClass from an ADSI classSchema object
	// Parameters:
	//		lpszWBEMClassName : The WBEM Name of the class to be fetched. 
	//		ppADSIClass : The address where the pointer to the CADSIClass will be stored.
	//			It is the caller's responsibility to Release() the object when done with it
	// 
	//	Return Value: The COM status value indicating the status of the request.
	//***************************************************************************
	virtual HRESULT GetADSIClass(LPCWSTR lpszClassName, 
		CADSIClass ** ppADSIClass) = 0;

	//***************************************************************************
	//
	// CDSClassProvider::GetADSIProperty
	//
	// Purpose : To create an CADSIProperty object from an LDAP AttributeSchema object
	// Parameters:
	//		lpszPropertyName : The LDAPDisplayName of the LDAP property to be fetched. 
	//		ppADSIProperty : The address where the pointer to the IDirectoryObject interface will be stored
	//			It is the caller's responsibility to Release() the interface when done with it
	// 
	//	Return Value: The COM status value indicating the status of the request
	//***************************************************************************
	virtual HRESULT GetADSIProperty(
		LPCWSTR lpszPropertyName, 
		CADSIProperty **ppADSIProperty) = 0;

	//***************************************************************************
	//
	// CDSClassProvider::GetWBEMBaseClassName
	//
	// Purpose : Returns the name of the class that is the base class of all classes
	//	provided by this provider.
	//
	// Parameters:
	//	None
	// 
	//	Return Value: The name of the base class. NULL if such a class doesnt exist.
	//***************************************************************************
	virtual const BSTR GetWBEMBaseClassName() = 0;
	//***************************************************************************
	//
	// CDSClassProvider::GetWBEMBaseClass
	//
	// Purpose : Returns a pointer to the class that is the base class of all classes
	//	provided by this provider.
	//
	// Parameters:
	//	None
	// 
	//	Return Value: The IWbemClassObject pointer to the base class. It is the duty of 
	//	user to release the class when done with using it.
	//***************************************************************************
	virtual IWbemClassObject * GetWBEMBaseClass() = 0;

	// Returns whether the class name is present in the list of classes authorized for this user
	BOOLEAN IsClassAccessible();

	// The Logging object
	ProvDebugLog *m_pLogObject;

	// The IWbemServices pointer stored from Initialize()
	IWbemServices *m_IWbemServices;

	// Indicates whether the call to Initialize() was successful
	BOOLEAN m_bInitializedSuccessfully;

	// Creates a log file using the m_lpszLogFileName member
	BOOLEAN CreateLogFile();

	// Some literals
	static BSTR CLASS_STR;

	// A cache of wbem classes
	static CWbemCache *s_pWbemCache;

	// A list of classes to which access has been granted for this user
	CNamesList m_AccessAllowedClasses;

private:

	// The COM Reference count
    long m_lReferenceCount ;
};


#endif // DS_CLASS_PROVIDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\classprovider\include\clsproi.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:clsproi.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the CDSClassProviderInitializer class. This class
// is used to initialize the static members of the CDSCLassProvider class
//
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef DS_CLASS_PROVIDER_INIT_H
#define DS_CLASS_PROVIDER_INIT_H

class CDSClassProviderInitializer
{

public:
	CDSClassProviderInitializer(ProvDebugLog *pLogObject);
	~CDSClassProviderInitializer();
};

#endif /* DS_CLASS_PROVIDER_INIT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\common\adsihelp.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:adsihelp.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the implementation the CADSIHelper class. This is
//	a class that has many static helper functions pertaining to ADSI
//***************************************************************************
/////////////////////////////////////////////////////////////////////////



#include <windows.h>
#include <activeds.h>

#include "adsihelp.h"


//***************************************************************************
//
// CADSiHelper::ProcessBSTRArrayProperty
//
// Purpose: Processes a variant containing an array of BSTR or a single BSTR
//
// Parameters:
//	pVariant : The variant to be processed
//	ppStrPropertyValue : The addres of the pointer to a BSTR array where the list of BSTRS representing
//		the ADSI paths of the derived classes will be put
//	lNumber : The number of elements in the retrieved array.
//
//
// Return Value: The COM value representing the return status. It is the responsibility
//	of the caller to release the array that is returned, as well as its contents. The varinat
//	passed in is not cleared
//
//***************************************************************************
HRESULT CADSIHelper :: ProcessBSTRArrayProperty(VARIANT *pVariant, BSTR **ppStrPropertyValues, LONG *lpNumber)
{
	HRESULT result = S_OK;
	VARIANT vTemp;
	if(pVariant->vt == VT_BSTR) // When the number of values is 1
	{
		*lpNumber = 1;
		*ppStrPropertyValues = new BSTR[*lpNumber];
		(*ppStrPropertyValues)[0] = SysAllocString(pVariant->bstrVal);
	}
	else if (pVariant->vt == (VT_VARIANT|VT_ARRAY) )
	{
		SAFEARRAY *pSafeArray = pVariant->parray;
		*lpNumber = 0;
		if(SUCCEEDED(result = SafeArrayGetUBound(pSafeArray, 1, lpNumber)) )
		{
			*ppStrPropertyValues = new BSTR[*lpNumber];
			for(LONG index=0L; index<(*lpNumber); index++)
			{
				if( FAILED( result = SafeArrayGetElement(pSafeArray, &index, (LPVOID)&vTemp) ))
				{
					// Reset the count to the actual number retrieved
					*lpNumber = index;
					break;
				}
				(*ppStrPropertyValues)[index] = SysAllocString(vTemp.bstrVal);
				VariantClear(&vTemp);
			}
		}
	}
	else
		result = E_FAIL;
	return result;
}

//***************************************************************************
//
// CADSiHelper :: DeallocateBSTRArray
//
// Purpose: Deallocates an array of BSTRs and its contents
//
// Parameters:
//	pStrPropertyValue : The pointer to the array to be deallocated
//	lNumber : The number of elements in the array.
//
//
// Return Value: None
//
//***************************************************************************
void CADSIHelper :: DeallocateBSTRArray(BSTR *pStrPropertyValue, LONG lNumber)
{
	for(lNumber--; lNumber>=0; lNumber--)
		SysFreeString(pStrPropertyValue[lNumber]);

	delete[] pStrPropertyValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\classprovider\include\ldapproi.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:ldapproi.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the CLDAPClassProviderInitializer class. This class
// is used to initialize the static members of the CLDAPCLassProvider class
//
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef DS_LDAP_CLASS_PROVIDER_INIT_H
#define DS_LDAP_CLASS_PROVIDER_INIT_H

class CLDAPClassProviderInitializer
{

public:
	CLDAPClassProviderInitializer(ProvDebugLog *pLogObject);
	~CLDAPClassProviderInitializer();
};

#endif /* DS_LDAP_CLASS_PROVIDER_INIT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\classprovider\include\ldapprov.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:ldapprov.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the DS LDAP Class Provider class. This
// class provides the classes in the DS LDAP namespace to WBEM. Note that an instance of the CDSClassProviderInitializer
//	class has to be created to initialize the static members of the CDSClassProvider class. Hence exactly
//	one instance of the CLDAPClassProviderInitializer class should be created for this
//	class to function properly.
//
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef LDAP_CLASS_PROVIDER_H
#define LDAP_CLASS_PROVIDER_H

// Forward declaration for the initializer class
class CLDAPClassProviderInitializer;

class CLDAPClassProvider : public CDSClassProvider
{
	// The initializer class is a friend of this class
	friend CLDAPClassProviderInitializer;

public:

	//***************************************************************************
	//
	// CLDAPClassProvider::CLDAPClassProvider
	// CLDAPClassProvider::~CLDAPClassProvider
	//
	// Constructor Parameters:
	//  None
	//***************************************************************************
    CLDAPClassProvider (ProvDebugLog *pLogObject) ;
    ~CLDAPClassProvider () ;

	//***************************************************************************
	//
	// CLDAPClassProvider::Initialize
	//
	// Purpose:
	//		As defined by the IWbemProviderInit interface
	//
	// Parameters:
	//		As defined by IWbemProviderInit interface
	// 
	//	Return Value: The COM status value indicating the status of the request
	//***************************************************************************
	HRESULT STDMETHODCALLTYPE Initialize( 
            LPWSTR wszUser,
            LONG lFlags,
            LPWSTR wszNamespace,
            LPWSTR wszLocale,
            IWbemServices __RPC_FAR *pNamespace,
            IWbemContext __RPC_FAR *pCtx,
            IWbemProviderInitSink __RPC_FAR *pInitSink) ;

	//***************************************************************************
	//
	// CLDAPClassProvider :: CreateClassEnumAsync
	//
	// Purpose: Enumerates the classes 
	//
	// Parameters:
	//	Standard parmaters as described by the IWbemServices interface
	//
	//
	// Return Value: As described by the IWbemServices interface
	//
	//***************************************************************************
	HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
		const BSTR strSuperclass,
		long lFlags,
		IWbemContext __RPC_FAR *pCtx,
		IWbemObjectSink __RPC_FAR *pResponseHandler);


protected:

	//***************************************************************************
	//
	// CLDAPClassProvider::InitializeLDAPProvider
	//
	// Purpose: A helper function to do the ADSI LDAP provider specific initialization.
	//
	// Parameters:
	//		pCtx	The context object used in this call initialization
	// 
	// Return Value: TRUE if the function successfully finishes the initializaion. FALSE
	//	otherwise
	//***************************************************************************
	BOOLEAN InitializeLDAPProvider(IWbemContext *pCtx);

	////////////////////////////////////////////////////////
	// Functions for interacting with the LDAP ADSI provider
	////////////////////////////////////////////////////////
	//***************************************************************************
	//
	// CLDAPClassProvider::GetADSIClass
	//
	// Purpose : To Create a CADSIClass from an ADSI classSchema object
	// Parameters:
	//		lpszWBEMClassName : The WBEM Name of the class to be fetched. 
	//		ppADSIClass : The address where the pointer to the CADSIClass will be stored.
	//			It is the caller's responsibility to Release() the object when done with it
	// 
	//	Return Value: The COM status value indicating the status of the request.
	//***************************************************************************
	HRESULT GetADSIClass(
		LPCWSTR lpszClassName, 
		CADSIClass ** ppADSIClass);

	//***************************************************************************
	//
	// CLDAPClassProvider::GetADSIProperty
	//
	// Purpose : To create an CADSIProperty object from an LDAP AttributeSchema object
	// Parameters:
	//		lpszPropertyName : The LDAPDisplayName of the LDAP property to be fetched. 
	//		ppADSIProperty : The address where the pointer to the IDirectoryObject interface will be stored
	//			It is the caller's responsibility to Release() the interface when done with it
	// 
	//	Return Value: The COM status value indicating the status of the request
	//***************************************************************************
	HRESULT GetADSIProperty(
		LPCWSTR lpszPropertyName, 
		CADSIProperty **ppADSIProperty);

	//***************************************************************************
	//
	// CLDAPClassProvider::GetWBEMBaseClassName
	//
	// Purpose : Returns the name of the class that is the base class of all classes
	//	provided by this provider.
	//
	// Parameters:
	//	None
	// 
	//	Return Value: The name of the base class. NULL if such a class doesnt exist.
	//***************************************************************************
	const BSTR GetWBEMBaseClassName();

	//***************************************************************************
	//
	// CLDAPClassProvider::GetWBEMBaseClass
	//
	// Purpose : Returns a pointer to the class that is the base class of all classes
	//	provided by this provider.
	//
	// Parameters:
	//	None
	// 
	//	Return Value: The IWbemClassObject pointer to the base class. It is the duty of 
	//	user to release the class when done with using it.
	//***************************************************************************
	IWbemClassObject * GetWBEMBaseClass();

	//***************************************************************************
	//
	// CLDAPClassProvider::GetWBEMProviderName
	//
	// Purpose : Returns the name of the provider. This should be the same as the
	// value of the field Name in the __Win32Provider instance used for registration
	// of the provider
	//
	// Parameters:
	//	None
	// 
	//	Return Value: The name of the provider
	//***************************************************************************
	const BSTR GetWBEMProviderName();

	//***************************************************************************
	//
	// CLDAPClassProvider::IsUnProvidedClass
	//
	// Purpose : To check whether a class is one that the provider does not provide
	//
	// Parameters:
	//	lpszClassName : The WBEM Name of the class to be checked
	//
	// 
	//	Return Value: TRUE is this is one of the classes not provided by the provider
	//***************************************************************************
	BOOLEAN IsUnProvidedClass(LPCWSTR lpszClassName);

	////////////////////////////////////////////////////////
	// Functions for handling a Get()
	////////////////////////////////////////////////////////
	//***************************************************************************
	//
	// CLDAPClassProvider::GetClassFromADSI
	//
	// Purpose : To create a WBEM class from an ADSI Class
	//
	// Parameters:
	//	lpszClassName : The WBEM Name of the class to be retreived
	//	pCtx : A pointer to the context object that was used in this call. This
	//		may be used by this function to make calls to CIMOM
	//	ppWbemClass : The resulting WBEM Class. This has to be released once the
	//		user is done with it.
	//
	// 
	//	Return Value: The COM result representing the status. 
	//***************************************************************************
	HRESULT GetClassFromADSI( 
		LPCWSTR lpszClassName,
		IWbemContext *pCtx,
		IWbemClassObject ** ppWbemClass
		);	
	
	//***************************************************************************
	//
	// CDSClassProvider::CreateWBEMClass
	//
	// Purpose: Creates WBEM Class corresponding an ADSI Class
	//
	// Parameters:
	//	pADSIClass : A pointer to a CADSI class object that is to be mapped to WBEM.
	//	ppWbemClass : The WBEM class object retrieved. This is created by this function.
	//		The caller should release it when done
	//	pCtx : The context object that was used in this provider call
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	virtual HRESULT CreateWBEMClass (CADSIClass *pADSIClass, int iCaseNumber, IWbemClassObject **ppWbemClass, IWbemContext *pCtx);

	//***************************************************************************
	//
	// CDSClassProvider::MapClassSystemProperties
	//
	// Purpose: Creates an appropriately derived WBEM class and names it (__CLASS)
	//
	// Parameters:
	//	pADSIClass : The ADSI class that is being mapped
	//	ppWbemClass : The WBEM class object retrieved. This is created by this function.
	//		The caller should release it when done
	//	pCtx : The context object that was used in this provider call
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	virtual HRESULT MapClassSystemProperties(CADSIClass *pADSIClass, int iCaseNumber, IWbemClassObject **ppWbemClass, IWbemContext *pCtx);

	//***************************************************************************
	//
	// CDSClassProvider :: MapClassQualifiersToWBEM
	//
	// Purpose: Creates the class qualifiers for a WBEM class from the ADSI class
	//
	// Parameters:
	//	pADSIClass : The LDAP class that is being mapped
	//	pWbemClass : The WBEM class object being created. T
	//	pCtx : The context object that was used in this provider call
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	virtual HRESULT MapClassQualifiersToWBEM(CADSIClass *pADSIClass, int iCaseNumber, IWbemClassObject *pWbemClass, IWbemContext *pCtx);

	//***************************************************************************
	//
	// CDSClassProvider :: MapClassPropertiesToWBEM
	//
	// Purpose: Creates the class properties for a WBEM class from the ADSI class
	//
	// Parameters:
	//	pADSIClass : The LDAP class that is being mapped
	//	pWbemClass : The WBEM class object being created. 
	//	pCtx : The context object that was used in this provider call
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	virtual HRESULT MapClassPropertiesToWBEM(CADSIClass *pADSIClass, IWbemClassObject *pWbemClass, IWbemContext *pCtx);

	//***************************************************************************
	//
	// CLDAPClassProvider :: MapPropertyListToWBEM
	//
	// Purpose: Maps a list of class properties for a WBEM class from the ADSI class
	//
	// Parameters:
	//	pWbemClass : The WBEM class object being created. 
	//	lppszPropertyList : A list of propery names
	//	dwCOunt : The number of items in the above list
	//	bMapSystemQualifier : Whether the "system" qualifier should be mapped
	//	bMapNotNullQualifier: Whether the "notNull" qualifier should be mapped
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	HRESULT MapPropertyListToWBEM(IWbemClassObject *pWbemClass, 
									LPCWSTR *lppszPropertyList, 
									DWORD dwCount, 
									BOOLEAN bMapSystemQualifier, 
									BOOLEAN bMapNotNullQualifier);

	//***************************************************************************
	//
	// CLDAPClassProvider :: CreateWBEMProperty
	//
	// Purpose: Creates a WBEM property from an LDAP property
	//
	// Parameters:
	//	pWbemClass : The WBEM class in which the property is created
	//	ppQualiferSet : The address of the pointer to IWbemQualiferSet where the qualifier set
	//		of this property will be placed
	//	pADSIProperty : The ADSI Property object that is being mapped to the property being created
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************	
	HRESULT CreateWBEMProperty(IWbemClassObject *pWbemClass, IWbemQualifierSet **ppQualifierSet, CADSIProperty *pNextProperty);

	//***************************************************************************
	//
	// CLDAPClassProvider :: MapLDAPSyntaxToWBEM
	//
	// Purpose: Maps the LDAP Syntax to WBEM
	//
	// Parameters:
	//	pADSIProperty = Pointer to the CADSIProperty object representing this attribute
	//
	// Return Value: The CIMTYPE value representing the WBEM Syntax for the LDAP Syntax. If
	// the syntax is unmappable, then CIM_STRING or CIM_STRING | CIM_FLAG_ARRAY is returned
	//
	//***************************************************************************
	CIMTYPE MapLDAPSyntaxToWBEM(CADSIProperty *pADSIProperty, BSTR *pstrCimTypeQualifier);

	/////////////////////////////////////
	/// Functions for Enumeration
	//////////////////////////////////////
	//***************************************************************************
	//
	// CLDAPClassProvider :: GetOneLevelDeep
	//
	// Purpose: Enumerates the sub classes of a superclass non-recursively
	//
	// Parameters:
	//
	//	lpszSuperClass : The super class name
	//	pResponseHandler : The interface where the resulting classes are put
	//
	//
	// Return Value: As described by the IWbemServices interface
	//
	//***************************************************************************
	HRESULT GetOneLevelDeep( 
		LPCWSTR lpszWBEMSuperclass,
		BOOLEAN bArtificialClass,
		LPWSTR ** pppADSIClasses,
		DWORD *pdwNumClasses,
		IWbemContext *pCtx);

	//***************************************************************************
	//
	// CLDAPClassProvider :: HandleRecursiveEnumeration
	//
	// Purpose: Enumerates the sub classes of a superclass recursively
	//
	// Parameters:
	//
	//	lpszSuperClass : The super class name
	//	pResponseHandler : The interface where the resulting classes are put
	//
	//
	// Return Value: As described by the IWbemServices interface
	//
	//***************************************************************************
	HRESULT HandleRecursiveEnumeration( 
		LPCWSTR lpszSuperclass,
		IWbemContext *pCtx,
		IWbemObjectSink *pResponseHandler);

	//***************************************************************************
	//
	// CLDAPClassProvider :: WrapUpEnumeration
	//
	// Purpose: Creates WBEM classes from ADSI classes 
	//
	// Parameters:
	//
	//	lpszSuperClass : The super class name
	//	pResponseHandler : The interface where the resulting classes are put
	//
	//
	// Return Value: As described by the IWbemServices interface
	//
	//***************************************************************************
	HRESULT WrapUpEnumeration( 
		LPWSTR *ppADSIClasses,
		DWORD dwNumClasses,
		IWbemContext *pCtx,
		IWbemObjectSink *pResponseHandler);

	//***************************************************************************
	//
	// CLDAPClassProvider :: IsConcreteClass
	//
	// Purpose: Find out whether a WBEM class is concrete. First checks in the WBEM Cache and then calls GetClassFromCacheorADSI()
	//
	// Parameters:
	//
	//	pszWBEMName : The class name
	//
	//
	// Return Value: As described by the IWbemServices interface
	//
	//***************************************************************************
	HRESULT IsConcreteClass( 
		LPCWSTR pszWBEMName,
		IWbemContext *pCtx);

	// Convert all characters to lower case
	void SanitizedClassName(LPWSTR lpszClassName);

private:

	// LDAP Class attribute names 
	static BSTR COMMON_NAME_ATTR_BSTR;
	static BSTR LDAP_DISPLAY_NAME_ATTR_BSTR;
	static BSTR GOVERNS_ID_ATTR_BSTR;
	static BSTR SCHEMA_ID_GUID_ATTR_BSTR;
	static BSTR MAPI_DISPLAY_TYPE_ATTR_BSTR;
	static BSTR RDN_ATT_ID_ATTR_BSTR;
	static BSTR SYSTEM_MUST_CONTAIN_ATTR_BSTR;
	static BSTR MUST_CONTAIN_ATTR_BSTR;
	static BSTR SYSTEM_MAY_CONTAIN_ATTR_BSTR;
	static BSTR MAY_CONTAIN_ATTR_BSTR;
	static BSTR SYSTEM_POSS_SUPERIORS_ATTR_BSTR;
	static BSTR POSS_SUPERIORS_ATTR_BSTR;
	static BSTR SYSTEM_AUXILIARY_CLASS_ATTR_BSTR;
	static BSTR AUXILIARY_CLASS_ATTR_BSTR;
	static BSTR DEFAULT_SECURITY_DESCRP_ATTR_BSTR;
	static BSTR OBJECT_CLASS_CATEGORY_ATTR_BSTR;
	static BSTR SYSTEM_ONLY_ATTR_BSTR;
	static BSTR NT_SECURITY_DESCRIPTOR_ATTR_BSTR;
	static BSTR DEFAULT_OBJECTCATEGORY_ATTR_BSTR;

	// Provider specific literals
	static BSTR	LDAP_BASE_CLASS_STR;
	static BSTR	LDAP_CLASS_PROVIDER_NAME;
	static BSTR	LDAP_INSTANCE_PROVIDER_NAME;

	// WBEM Class Qualifier names
	static BSTR	DYNAMIC_BSTR;
	static BSTR	PROVIDER_BSTR;
	static BSTR	ABSTRACT_BSTR;

	// WBEM Property Qualifier names
	static BSTR SYSTEM_BSTR;
	static BSTR NOT_NULL_BSTR;
	static BSTR INDEXED_BSTR;
	static BSTR ATTRIBUTE_SYNTAX_ATTR_BSTR;
	static BSTR ATTRIBUTE_ID_ATTR_BSTR;
	static BSTR MAPI_ID_ATTR_BSTR;
	static BSTR OM_SYNTAX_ATTR_BSTR;
	static BSTR RANGE_LOWER_ATTR_BSTR;
	static BSTR RANGE_UPPER_ATTR_BSTR;

	// Qualifiers for embedded objects
	static BSTR CIMTYPE_STR;
	static BSTR EMBED_UINT8ARRAY;
	static BSTR EMBED_DN_WITH_STRING;
	static BSTR EMBED_DN_WITH_BINARY;

	// WBEM Property names
	static BSTR DYNASTY_BSTR;

	// The default flavor for qualifiers
	static LONG DEFAULT_QUALIFIER_FLAVOUR;

	// These are the search preferences often used
	ADS_SEARCHPREF_INFO m_searchInfo1;

	// The LDAP property cache
	static CLDAPCache *s_pLDAPCache;

	// The base class of all the LDAP Provider Classes.
	IWbemClassObject *m_pLDAPBaseClass;

};


#endif // LDAP_CLASS_PROVIDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\classprovider\include\ldapcach.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:ldapcach.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Cache for LDAP Schema objects (Properties and Classes)
//
//***************************************************************************


#ifndef LDAP_CACHE_H
#define LDAP_CACHE_H


class CLDAPCache
{
public:
	static DWORD dwLDAPCacheCount;

	//***************************************************************************
	//
	// CLDAPCache::CLDAPCache
	//
	// Purpose : Constructor. Fills in the cache with all the properties in LDAP.
	//
	// Parameters: 
	//	plogObject : Pointer to the ProvDebugLog object  onto which logging will be done.
	//***************************************************************************
	CLDAPCache(ProvDebugLog *plogObject);

	//***************************************************************************
	//
	// CLDAPCache::~CLDAPCache
	//
	// Purpose : Destructor 
	//
	//***************************************************************************
	~CLDAPCache();

	//***************************************************************************
	//
	// CLDAPCache::IsInitialized
	//
	// Purpose : Indicates whether the cache was created and initialized succeddfully
	//
	// Parameters: 
	//	None
	//
	//	Return value:
	//		A boolean value indicating the status
	//		
	//***************************************************************************
	BOOLEAN IsInitialized();

	//***************************************************************************
	//
	// CLDAPCache::GetProperty
	//
	// Purpose : Retreives the IDirectory interface of an LDAP property. 
	//
	// Parameters: 
	//	lpszPropertyName : The name of the LDAP Property to be retreived
	//	ppADSIProperty : The address of the pointer where the CADSIProperty object will be placed
	//	bWBEMName : True if the lpszPropertyName is the WBEM name. False, if it is the LDAP name
	//
	//	Return value:
	//		The COM value representing the return status. The user should delete the returned object when done.
	//		
	//***************************************************************************
	HRESULT GetProperty(LPCWSTR lpszPropertyName, CADSIProperty **ppADSIProperty, BOOLEAN bWBEMName);

	//***************************************************************************
	//
	// CLDAPCache::GetClass
	//
	// Purpose : Retreives the IDirectory interface of an LDAP Class
	//
	// Parameters: 
	//	lpszClassName : The name of the Class to be retreived. 
	//	ppADSIClass : The address of the pointer where the CADSIClass object will be placed
	//
	//	Return value:
	//		The COM value representing the return status. The user should delete the returned object when done.
	//		
	//***************************************************************************
	HRESULT GetClass(LPCWSTR lpszWBEMClassName, LPCWSTR lpszClassName, CADSIClass **ppADSIClass);

	//***************************************************************************
	//
	// CLDAPCache::EnumerateClasses
	//
	// Purpose : Retreives the IDirectory interface of an LDAP Class
	//
	// Parameters: 
	//		lppszWBEMSuperClass : The WBEM name of the immediate superclass of the classes to be retreived. This is optional
	//			and is ignored if NULL
	//		bDeep : Indicates whether a deep enumeration is required. Otherwise a shallow enumeration is done
	//		pppszClassNames : The address of the array of LPWSTR pointers where the resulting objects will be
	//			placed. The user should deallocate this array as well as its contents when done with them.
	//		pdwNumRows : The number of elements in the above array returned
	//
	//	Return value:
	//		The COM value representing the return status. The user should delete the returned object when done.
	//		
	//***************************************************************************
	HRESULT EnumerateClasses(LPCWSTR lpszSuperclass,
		BOOLEAN bDeep,
		LPWSTR **pppADSIClasses,
		DWORD *pdwNumRows,
		BOOLEAN bArtificialClass
		);

	//***************************************************************************
	//
	// CLDAPCache::GetSchemaContainerSearch
	//
	// Purpose : To return the IDirectorySearch interface on the schema container
	//
	// Parameters:
	//	ppDirectorySearch : The address where the pointer to the required interface will
	//		be stored.
	//
	// 
	//	Return Value: The COM result representing the status. The user should release
	//	the interface pointer when done with it.
	//***************************************************************************
	HRESULT GetSchemaContainerSearch(IDirectorySearch ** ppDirectorySearch);

	//***************************************************************************
	//
	// CLDAPCache::GetSchemaContainerObject
	//
	// Purpose : To return the IDirectoryObject interface on the schema container
	//
	// Parameters:
	//	ppDirectoryObject : The address where the pointer to the required interface will
	//		be stored.
	//
	// 
	//	Return Value: The COM result representing the status. The user should release
	//	the interface pointer when done with it.
	//***************************************************************************
	HRESULT GetSchemaContainerObject(IDirectoryObject ** ppDirectorySearch);
	
	//***************************************************************************
	//
	// CLDAPCache :: CreateEmptyADSIClass
	//
	// Purpose: Creates a new ADSI class from a WBEM class
	//
	// Parameters:
	//	lpszWBEMName : The WBEM Name of the class
	//
	//
	// Return Value: 
	//
	//***************************************************************************
	HRESULT CreateEmptyADSIClass( 
		LPCWSTR lpszWBEMName,
		CADSIClass **ppADSIClass);


	HRESULT FillInAProperty(CADSIProperty *pNextProperty, ADS_SEARCH_HANDLE hADSSearchOuter);


private:

	// The storage for cached properties
	CObjectTree m_objectTree;

	// The object on whihc all logging is done
	ProvDebugLog *m_pLogObject;

	// Whether the cache was created successfully
	BOOLEAN m_isInitialized;

	// These are the search preferences often used
	ADS_SEARCHPREF_INFO m_pSearchInfo[3];

	// The path to the schema container
	LPWSTR m_lpszSchemaContainerSuffix;
	LPWSTR m_lpszSchemaContainerPath;
	// The IDirectorySearch interface of the schema container
	IDirectorySearch *m_pDirectorySearchSchemaContainer;

	// Some other literals
	static LPCWSTR ROOT_DSE_PATH;
	static LPCWSTR SCHEMA_NAMING_CONTEXT;
	static LPCWSTR LDAP_PREFIX;
	static LPCWSTR LDAP_TOP_PREFIX;
	static LPCWSTR RIGHT_BRACKET;
	static LPCWSTR OBJECT_CATEGORY_EQUALS_ATTRIBUTE_SCHEMA;

	// A function to fill in the object tree
	// This can be called only after the m_pDirectorySearchSchemaContainer member
	// is initialized
	HRESULT InitializeObjectTree();


};

#endif /* LDAP_CACHE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\common\log.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include <stdio.h>
#include <time.h>
#include <tchar.h>
#include <windows.h>
#include <comdef.h>

#include "provlog.h"


//***************************************************************************
//
// CDsLog::CDsLog
//
// Purpose: Contructs an empty CDsLog object.
//
// Parameters:
//  None
//
//***************************************************************************
CDsLog :: CDsLog()
{
	m_lpszLogFileName = NULL;
	m_fpLogFile = NULL;

	// Turn on logging by default
	m_bEnabled = TRUE;

	// Enable all severity levels
	m_iLevel = NONE;
}

//***************************************************************************
//
// CDsLog::~CDsLog
//
// Purpose: Destructor
//
//
//***************************************************************************
CDsLog :: ~CDsLog()
{
	delete [] m_lpszLogFileName;

	if(m_fpLogFile)
		fclose(m_fpLogFile);
}

//***************************************************************************
//
// CDsLog::LogMessage
//
// Purpose: See Header
//
//***************************************************************************
BOOLEAN CDsLog :: Initialise(LPCWSTR lpszRegistrySubTreeRoot) 
{
	// Get the various values from the registry
	if(!GetRegistryValues(lpszRegistrySubTreeRoot))
		return FALSE;

	// Open the Log File
	m_fpLogFile = _tfopen((LPTSTR)(_bstr_t)(m_lpszLogFileName), __TEXT("w"));
	if(m_fpLogFile)
		WriteInitialMessage();
	return (m_fpLogFile != NULL);
}

//***************************************************************************
//
// CDsLog::LogMessage
//
// Purpose: See Header
//
//***************************************************************************
BOOLEAN CDsLog :: Initialise(LPCWSTR lpszFileName, BOOLEAN bEnabled, UINT iLevel)
{
	m_bEnabled = bEnabled;
	m_iLevel = iLevel;

	m_fpLogFile = _tfopen((LPTSTR)(_bstr_t)(lpszFileName), __TEXT("w"));
	if(m_fpLogFile)
		WriteInitialMessage();
	return (m_fpLogFile != NULL);
}


//***************************************************************************
//
// CDsLog::LogMessage
//
// Purpose: See Header
//
//***************************************************************************
void CDsLog :: LogMessage(UINT iLevel, LPCWSTR lpszMessage, ...)
{

	va_list marker;
	va_start(marker, lpszMessage);

	if(m_bEnabled && iLevel >= m_iLevel)
	{
		EnterCriticalSection(&m_FileCriticalSection);

		_vftprintf(m_fpLogFile, lpszMessage, marker);
		fflush(m_fpLogFile);

		LeaveCriticalSection(&m_FileCriticalSection);
	}

	va_end(marker);

}

//***************************************************************************
//
// CDsLog::GetRegistryValues
//
// Purpose: See Header
//***************************************************************************
BOOLEAN CDsLog :: GetRegistryValues(LPCWSTR lpszRegistrySubTreeRoot)
{
	HKEY subtreeRootKey;
	if( RegOpenKeyEx(HKEY_LOCAL_MACHINE,
					(LPTSTR)(_bstr_t)(lpszRegistrySubTreeRoot),
					0,
					KEY_READ,
					&subtreeRootKey) != ERROR_SUCCESS)
		return FALSE;

	BOOLEAN retVal = TRUE;

	// Retrieve the "File" value
	LONG lDataLength = 0;
	if(RegQueryValue(subtreeRootKey,
		FILE_STRING,
		NULL,	
		&lDataLength) == ERROR_SUCCESS)
	{
		m_lpszLogFileName = new TCHAR [lDataLength + 1];


		if(RegQueryValue(subtreeRootKey,
			FILE_STRING,
			m_lpszLogFileName,	
			&lDataLength) != ERROR_SUCCESS)
		{
			retVal = FALSE;
		}
	}
	else
		retVal = FALSE;

	// Retrieve the "Enabled" value
	lDataLength = 0;
	if(RegQueryValue(subtreeRootKey,
		ENABLED_STRING,
		NULL,	
		&lDataLength) == ERROR_SUCCESS)
	{
		LPTSTR lpszEnabled = new TCHAR [lDataLength + 1];

		if(RegQueryValue(subtreeRootKey,
			FILE_STRING,
			lpszEnabled,	
			&lDataLength) != ERROR_SUCCESS)
		{
			retVal = FALSE;
		}
		else // Convert the string to boolena
		{
			if(_tcscmp(lpszEnabled, ONE_STRING) == 0)
				m_bEnabled = TRUE;
			else
				m_bEnabled = FALSE;
		}

		delete [] lpszEnabled;
	}
	else
		retVal = FALSE;

	// Retrieve the "Level" value
	lDataLength = 0;
	if(RegQueryValue(subtreeRootKey,
		LEVEL_STRING,
		NULL,	
		&lDataLength) == ERROR_SUCCESS)
	{
		LPTSTR lpszEnabled = new TCHAR [lDataLength + 1];

		if(RegQueryValue(subtreeRootKey,
			FILE_STRING,
			lpszEnabled,	
			&lDataLength) != ERROR_SUCCESS)
		{
			retVal = FALSE;
		}
		else // Convert the string to boolena
		{
			if(_tcscmp(lpszEnabled, ONE_STRING) == 0)
				m_bEnabled = TRUE;
			else
				m_bEnabled = FALSE;
		}

		delete [] lpszEnabled;
	}
	else
		retVal = FALSE;

	// Close the registry key
	RegCloseKey(subtreeRootKey);
	return retVal;
}

//***************************************************************************
//
// CDsLog::WriteInitialMessage
//
// Purpose: See Header
//***************************************************************************
void CDsLog :: WriteInitialMessage()
{
	if(m_bEnabled)
	{
		EnterCriticalSection(&m_FileCriticalSection);

		// Get the DateTime in Ascii format
		struct tm *newtime;        
		time_t long_time;
		time( &long_time );                /* Get time as long integer. */
		newtime = localtime( &long_time ); /* Convert to local time. */
		_ftprintf(m_fpLogFile, __TEXT("Log File Created at : %s\n"), _tasctime(newtime));
		_ftprintf(m_fpLogFile, __TEXT("================================================\n\n"));
		fflush(m_fpLogFile);
		LeaveCriticalSection(&m_FileCriticalSection);

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\common\adsiclas.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:adsiclas.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the implementation of the CADSIClass which encapsulates an ADSI class
//
//***************************************************************************

#include <tchar.h>
#include <stdio.h>

#include <windows.h>
#include <objbase.h>

/* ADSI includes */
#include <activeds.h>

#include "refcount.h"
#include "adsiclas.h"

//***************************************************************************
//
// CADSIClass::CADSIClass
//
// Purpose : Constructor 
//
// Parameters:
//  lpszWBEMClassName : The WBEM name of the Class being created. A copy of this is made
//  lpszADSIClassName : The ADSI name of the Class being created. A copy of this is made
//***************************************************************************
CADSIClass :: CADSIClass(LPCWSTR lpszWBEMClassName, LPCWSTR lpszADSIClassName)
	: CRefCountedObject(lpszADSIClassName)
{
	if(lpszWBEMClassName)
	{
		m_lpszWBEMClassName = new WCHAR[wcslen(lpszWBEMClassName) + 1];
		wcscpy(m_lpszWBEMClassName, lpszWBEMClassName);
	}
	else
	{
		m_lpszWBEMClassName = NULL;
	}

	// Set the attributes to theri default values
	m_lpszCommonName = NULL;
	m_lpszSuperClassLDAPName = NULL;
	m_lpszGovernsID = NULL;
	m_pSchemaIDGUIDOctets = NULL;
	m_dwSchemaIDGUIDLength = 0;
	m_lpszRDNAttribute = NULL;
	m_lpszDefaultSecurityDescriptor = NULL;
	m_dwObjectClassCategory = 0;
	m_dwNTSecurityDescriptorLength = 0;
	m_pNTSecurityDescriptor = NULL;
	m_lpszDefaultObjectCategory = NULL;
	m_bSystemOnly = FALSE;

	// Initialize the property book keeping
	m_lppszAuxiliaryClasses = NULL;
	m_dwAuxiliaryClassesCount = 0;
	m_lppszSystemAuxiliaryClasses = NULL;
	m_dwSystemAuxiliaryClassesCount = 0;
	m_lppszPossibleSuperiors = NULL;
	m_dwPossibleSuperiorsCount = 0;
	m_lppszSystemPossibleSuperiors = NULL;
	m_dwSystemPossibleSuperiorsCount = 0;
	m_lppszMayContains = NULL;
	m_dwMayContainsCount = 0;
	m_lppszSystemMayContains = NULL;
	m_dwSystemMayContainsCount = 0;
	m_lppszMustContains = NULL;
	m_dwMustContainsCount = 0;
	m_lppszSystemMustContains = NULL;
	m_dwSystemMustContainsCount = 0;
}


//***************************************************************************
//
// CADSIClass :: ~CADSIClass
// 
// Purpose : Destructor
//***************************************************************************
CADSIClass :: ~CADSIClass()
{
	// Delete the WBEM Name. The ADSI Name is deleted in the base class destructor
	delete [] m_lpszWBEMClassName;

	// Delete the attributes
	delete [] m_lpszCommonName;
	delete [] m_lpszSuperClassLDAPName;
	delete [] m_lpszGovernsID;
	delete [] m_pSchemaIDGUIDOctets;
	delete [] m_lpszRDNAttribute;
	delete [] m_lpszDefaultSecurityDescriptor;
	delete [] m_pNTSecurityDescriptor;
	delete [] m_lpszDefaultObjectCategory;

	DWORD i;
	// Delete the list of Auxiliary Classes
	for(i=0; i<m_dwAuxiliaryClassesCount; i++)
		delete [] m_lppszAuxiliaryClasses[i];
	delete[] m_lppszAuxiliaryClasses;

	// Delete the list of System Auxiliary Classes
	for(i=0; i<m_dwSystemAuxiliaryClassesCount; i++)
		delete [] m_lppszSystemAuxiliaryClasses[i];
	delete[] m_lppszSystemAuxiliaryClasses;

	// Delete the list of possible superiors
	for(i=0; i<m_dwPossibleSuperiorsCount; i++)
		delete [] m_lppszPossibleSuperiors[i];
	delete[] m_lppszPossibleSuperiors;

	// Delete the list of System possible superiors
	for(i=0; i<m_dwSystemPossibleSuperiorsCount; i++)
		delete [] m_lppszSystemPossibleSuperiors[i];
	delete[] m_lppszSystemPossibleSuperiors;

	// Delete the list of may contains
	for(i=0; i<m_dwMayContainsCount; i++)
		delete [] m_lppszMayContains[i];
	delete[] m_lppszMayContains;

	// Delete the list of System may contains
	for(i=0; i<m_dwSystemMayContainsCount; i++)
		delete [] m_lppszSystemMayContains[i];
	delete[] m_lppszSystemMayContains;

	// Delete the list of Must Contains
	for(i=0; i<m_dwMustContainsCount; i++)
		delete [] m_lppszMustContains[i];
	delete[] m_lppszMustContains;

	// Delete the list of System Must Contains
	for(i=0; i<m_dwSystemMustContainsCount; i++)
		delete [] m_lppszSystemMustContains[i];
	delete[] m_lppszSystemMustContains;

}


//***************************************************************************
//
// CADSIClass :: GetWBEMClassName
// 
// Purpose : Returns the WBEM  Class name of this Class
//***************************************************************************
LPCWSTR CADSIClass :: GetWBEMClassName()
{
	return m_lpszWBEMClassName;
}

//***************************************************************************
//
// CADSIClass :: GetWBEMClassName
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass::SetWBEMClassName(LPCWSTR lpszName)
{
	delete[] m_lpszWBEMClassName;
	if(lpszName)
	{
		m_lpszWBEMClassName = new WCHAR[wcslen(lpszName) + 1];
		wcscpy(m_lpszWBEMClassName, lpszName);
	}
	else
		m_lpszWBEMClassName = NULL;
}

//***************************************************************************
//
// CADSIClass :: GetADSIClassName
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR CADSIClass :: GetADSIClassName()
{
	return GetName();
}

//***************************************************************************
//
// CADSIClass :: GetADSIClassName
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetADSIClassName(LPCWSTR lpszName)
{
	SetName(lpszName);
}

//***************************************************************************
//
// CADSIClass :: GetCommonName
// 
// Purpose : See Header
//
//***************************************************************************
LPCWSTR CADSIClass :: GetCommonName()
{
	return m_lpszCommonName;
}

//***************************************************************************
//
// CADSIClass :: SetCommonName
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetCommonName(LPCWSTR lpszCommonName)
{
	delete[] m_lpszCommonName;
	if(lpszCommonName)
	{
		m_lpszCommonName = new WCHAR[wcslen(lpszCommonName) + 1];
		wcscpy(m_lpszCommonName, lpszCommonName);
	}
	else
		m_lpszCommonName = NULL;
}


//***************************************************************************
//
// CADSIClass :: GetSuperClassLDAPName
// 
// Purpose : See Header
//
//***************************************************************************
LPCWSTR CADSIClass :: GetSuperClassLDAPName()
{
	return m_lpszSuperClassLDAPName;
}

//***************************************************************************
//
// CADSIClass :: SetSuperClassLDAPName
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetSuperClassLDAPName(LPCWSTR lpszSuperClassLDAPName)
{
	delete[] m_lpszSuperClassLDAPName;
	if(lpszSuperClassLDAPName)
	{
		m_lpszSuperClassLDAPName = new WCHAR[wcslen(lpszSuperClassLDAPName) + 1];
		wcscpy(m_lpszSuperClassLDAPName, lpszSuperClassLDAPName);
	}
	else
		m_lpszSuperClassLDAPName = NULL;

}

//***************************************************************************
//
// CADSIClass :: GetGovernsID
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR CADSIClass :: GetGovernsID()
{
	return m_lpszGovernsID;
}

//***************************************************************************
//
// CADSIClass :: SetGovernsID
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetGovernsID(LPCWSTR lpszGovernsID)
{
	delete[] m_lpszGovernsID;
	if(lpszGovernsID)
	{
		m_lpszGovernsID = new WCHAR[wcslen(lpszGovernsID) + 1];
		wcscpy(m_lpszGovernsID, lpszGovernsID);
	}
	else
		m_lpszGovernsID = NULL;
}

//***************************************************************************
//
// CADSIClass :: GetSchemaIDGUID
// 
// Purpose : See Header
//***************************************************************************
const LPBYTE CADSIClass :: GetSchemaIDGUID(DWORD *pdwLength)
{
	*pdwLength = m_dwSchemaIDGUIDLength;
	return m_pSchemaIDGUIDOctets;
}

//***************************************************************************
//
// CADSIClass :: SetSchemaIDGUID
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetSchemaIDGUID(LPBYTE pOctets, DWORD dwLength)
{
	delete[] m_pSchemaIDGUIDOctets;
	if(pOctets)
	{
		m_dwSchemaIDGUIDLength = dwLength;
		m_pSchemaIDGUIDOctets = new BYTE[dwLength];
		for(DWORD i=0; i<dwLength; i++)
			m_pSchemaIDGUIDOctets[i] = pOctets[i];
	}
	else
	{
		m_pSchemaIDGUIDOctets = NULL;
		m_dwSchemaIDGUIDLength = 0;
	}
}

//***************************************************************************
//
// CADSIClass :: GetRDNAttribute
// 
// Purpose : See Header
//
//***************************************************************************
LPCWSTR CADSIClass :: GetRDNAttribute()
{
	return m_lpszRDNAttribute;
}

//***************************************************************************
//
// CADSIClass :: SetRDNAttribute
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetRDNAttribute(LPCWSTR lpszRDNAttribute)
{
	delete[] m_lpszRDNAttribute;
	if(lpszRDNAttribute)
	{
		m_lpszRDNAttribute = new WCHAR[wcslen(lpszRDNAttribute) + 1];
		wcscpy(m_lpszRDNAttribute, lpszRDNAttribute);
	}
	else
		m_lpszRDNAttribute = NULL;
}


//***************************************************************************
//
// CADSIClass :: GetDefaultSecurityDescriptor
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR CADSIClass :: GetDefaultSecurityDescriptor()
{
	return m_lpszDefaultSecurityDescriptor;
}

//***************************************************************************
//
// CADSIClass :: SetDefaultSecurityDescriptor
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetDefaultSecurityDescriptor(LPCWSTR lpszDefaultSecurityDescriptor)
{
	delete[] m_lpszDefaultSecurityDescriptor;
	if( lpszDefaultSecurityDescriptor)
	{
		m_lpszDefaultSecurityDescriptor = new WCHAR[wcslen(lpszDefaultSecurityDescriptor) + 1];
		wcscpy(m_lpszDefaultSecurityDescriptor, lpszDefaultSecurityDescriptor);
	}
	else
		m_lpszDefaultSecurityDescriptor = NULL;
}

//***************************************************************************
//
// CADSIClass :: GetObjectClassCategory
// 
// Purpose : See Header
//***************************************************************************
DWORD CADSIClass :: GetObjectClassCategory()
{
	return m_dwObjectClassCategory;
}

//***************************************************************************
//
// CADSIClass :: SetObjectClassCategory
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetObjectClassCategory(DWORD dwObjectClassCategory)
{
	m_dwObjectClassCategory = dwObjectClassCategory;
}

//***************************************************************************
//
// CADSIClass :: GetNTSecurityDescriptor
// 
// Purpose : See Header
//***************************************************************************
const LPBYTE CADSIClass :: GetNTSecurityDescriptor(DWORD *pdwLength)
{
	*pdwLength = m_dwNTSecurityDescriptorLength;
	return m_pNTSecurityDescriptor;
}

//***************************************************************************
//
// CADSIClass :: SetNTSecurityDescriptor
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetNTSecurityDescriptor(LPBYTE pOctets, DWORD dwLength)
{
	delete[] m_pNTSecurityDescriptor;
	if(pOctets)
	{
		m_dwNTSecurityDescriptorLength = dwLength;
		m_pNTSecurityDescriptor = new BYTE[dwLength];
		for(DWORD i=0; i<dwLength; i++)
			m_pNTSecurityDescriptor[i] = pOctets[i];
	}
	else
	{
		m_pNTSecurityDescriptor = NULL;
		m_dwNTSecurityDescriptorLength = 0;
	}

}

//***************************************************************************
//
// CADSIClass :: GetDefaultObjectCategory
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR CADSIClass :: GetDefaultObjectCategory()
{
	return m_lpszDefaultObjectCategory;
}

//***************************************************************************
//
// CADSIClass :: SetDefaultObjectCategory
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetDefaultObjectCategory(LPCWSTR lpszDefaultObjectCategory)
{
	delete[] m_lpszDefaultObjectCategory;
	if (lpszDefaultObjectCategory)
	{
		m_lpszDefaultObjectCategory = new WCHAR[wcslen(lpszDefaultObjectCategory) + 1];
		wcscpy(m_lpszDefaultObjectCategory, lpszDefaultObjectCategory);
	}
	else
		m_lpszDefaultObjectCategory = NULL;
}

//***************************************************************************
//
// CADSIClass :: GetSystemOnly
// 
// Purpose : See Header
//***************************************************************************
BOOLEAN CADSIClass :: GetSystemOnly()
{
	return m_bSystemOnly;
}

//***************************************************************************
//
// CADSIClass :: SetSystemOnly
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetSystemOnly(BOOLEAN bSystemOnly)
{
	m_bSystemOnly = bSystemOnly;
}

//***************************************************************************
//
// CADSIClass :: GetAuxiliaryClasses
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR *CADSIClass :: GetAuxiliaryClasses(DWORD *pdwCount)
{
	*pdwCount = m_dwAuxiliaryClassesCount;
	return (LPCWSTR *)m_lppszAuxiliaryClasses;
}

//***************************************************************************
//
// CADSIClass :: SetAuxiliaryClasses
// 
// Purpose : See Header

//***************************************************************************
void CADSIClass :: SetAuxiliaryClasses(PADSVALUE pValues, DWORD dwNumValues)
{
	// Delete the list of possible superiors
	for(DWORD i = 0; i<m_dwAuxiliaryClassesCount; i++)
		delete [] m_lppszAuxiliaryClasses[i];
	delete[] m_lppszAuxiliaryClasses;

	m_lppszAuxiliaryClasses = NULL;
	m_dwAuxiliaryClassesCount = 0;

	// Set the new list of values
	m_dwAuxiliaryClassesCount = dwNumValues;
	m_lppszAuxiliaryClasses = new LPWSTR[m_dwAuxiliaryClassesCount];
	for(i=0; i<m_dwAuxiliaryClassesCount; i++)
	{
		m_lppszAuxiliaryClasses[i] = new WCHAR[wcslen(pValues->CaseIgnoreString) + 1];
		wcscpy(m_lppszAuxiliaryClasses[i], pValues->CaseIgnoreString);
		pValues ++;
	}
}

//***************************************************************************
//
// CADSIClass :: GetSystemAuxiliaryClasses
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR *CADSIClass :: GetSystemAuxiliaryClasses(DWORD *pdwCount)
{
	*pdwCount = m_dwSystemAuxiliaryClassesCount;
	return (LPCWSTR *)m_lppszSystemAuxiliaryClasses;
}

//***************************************************************************
//
// CADSIClass :: SetSystemAuxiliaryClasses
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetSystemAuxiliaryClasses(PADSVALUE pValues, DWORD dwNumValues)
{
	// Delete the list of possible superiors
	for(DWORD i = 0; i<m_dwSystemAuxiliaryClassesCount; i++)
		delete [] m_lppszSystemAuxiliaryClasses[i];
	delete[] m_lppszSystemAuxiliaryClasses;
	
	m_lppszSystemAuxiliaryClasses = NULL;
	m_dwSystemAuxiliaryClassesCount = 0;

	// Set the new list of values
	m_dwSystemAuxiliaryClassesCount = dwNumValues;
	m_lppszSystemAuxiliaryClasses = new LPWSTR[m_dwSystemAuxiliaryClassesCount];
	for(i=0; i<m_dwSystemAuxiliaryClassesCount; i++)
	{
		m_lppszSystemAuxiliaryClasses[i] = new WCHAR[wcslen(pValues->CaseIgnoreString) + 1];
		wcscpy(m_lppszSystemAuxiliaryClasses[i], pValues->CaseIgnoreString);
		pValues ++;
	}
}

//***************************************************************************
//
// CADSIClass :: GetPossibleSuperiors
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR *CADSIClass :: GetPossibleSuperiors(DWORD *pdwCount)
{
	*pdwCount = m_dwPossibleSuperiorsCount;
	return (LPCWSTR *)m_lppszPossibleSuperiors;
}

//***************************************************************************
//
// CADSIClass :: SetPossibleSuperiors
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetPossibleSuperiors(PADSVALUE pValues, DWORD dwNumValues)
{
	// Delete the list of possible superiors
	for(DWORD i = 0; i<m_dwPossibleSuperiorsCount; i++)
		delete [] m_lppszPossibleSuperiors[i];
	delete[] m_lppszPossibleSuperiors;

	m_lppszPossibleSuperiors = NULL;
	m_dwPossibleSuperiorsCount = 0;

	// Set the new list of values
	m_dwPossibleSuperiorsCount = dwNumValues;
	m_lppszPossibleSuperiors = new LPWSTR[m_dwPossibleSuperiorsCount];
	for(i=0; i<m_dwPossibleSuperiorsCount; i++)
	{
		m_lppszPossibleSuperiors[i] = new WCHAR[wcslen(pValues->CaseIgnoreString) + 1];
		wcscpy(m_lppszPossibleSuperiors[i], pValues->CaseIgnoreString);
		pValues ++;
	}
}

//***************************************************************************
//
// CADSIClass :: GetSystemPossibleSuperiors
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR *CADSIClass :: GetSystemPossibleSuperiors(DWORD *pdwCount)
{
	*pdwCount = m_dwSystemPossibleSuperiorsCount;
	return (LPCWSTR *)m_lppszSystemPossibleSuperiors;
}

//***************************************************************************
//
// CADSIClass :: SetSystemPossibleSuperiors
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetSystemPossibleSuperiors(PADSVALUE pValues, DWORD dwNumValues)
{
	// Delete the list of possible superiors
	for(DWORD i = 0; i<m_dwSystemPossibleSuperiorsCount; i++)
		delete [] m_lppszSystemPossibleSuperiors[i];
	delete[] m_lppszSystemPossibleSuperiors;

	m_lppszSystemPossibleSuperiors = NULL;
	m_dwSystemPossibleSuperiorsCount = 0;

	// Set the new list of values
	m_dwSystemPossibleSuperiorsCount = dwNumValues;
	m_lppszSystemPossibleSuperiors = new LPWSTR[m_dwSystemPossibleSuperiorsCount];
	for(i=0; i<m_dwSystemPossibleSuperiorsCount; i++)
	{
		m_lppszSystemPossibleSuperiors[i] = new WCHAR[wcslen(pValues->CaseIgnoreString) + 1];
		wcscpy(m_lppszSystemPossibleSuperiors[i], pValues->CaseIgnoreString);
		pValues ++;
	}
}


//***************************************************************************
//
// CADSIClass :: GetMayContains
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR *CADSIClass :: GetMayContains(DWORD *pdwCount)
{
	*pdwCount = m_dwMayContainsCount;
	return (LPCWSTR *)m_lppszMayContains;
}

//***************************************************************************
//
// CADSIClass :: SetMayContains
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetMayContains(PADSVALUE pValues, DWORD dwNumValues)
{
	// Delete the list of possible superiors
	for(DWORD i = 0; i<m_dwMayContainsCount; i++)
		delete [] m_lppszMayContains[i];
	delete[] m_lppszMayContains;

	m_lppszMayContains = NULL;
	m_dwMayContainsCount = 0;

	// Set the new list of values
	m_dwMayContainsCount = dwNumValues;
	m_lppszMayContains = new LPWSTR[m_dwMayContainsCount];
	for(i=0; i<m_dwMayContainsCount; i++)
	{
		m_lppszMayContains[i] = new WCHAR[wcslen(pValues->CaseIgnoreString) + 1];
		wcscpy(m_lppszMayContains[i], pValues->CaseIgnoreString);
		pValues ++;
	}
}

//***************************************************************************
//
// CADSIClass :: GetSystemMayContains
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR *CADSIClass :: GetSystemMayContains(DWORD *pdwCount)
{
	*pdwCount = m_dwSystemMayContainsCount;
	return (LPCWSTR *)m_lppszSystemMayContains;
}

//***************************************************************************
//
// CADSIClass :: SetSystemMayContains
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetSystemMayContains(PADSVALUE pValues, DWORD dwNumValues)
{
	// Delete the list of possible superiors
	for(DWORD i = 0; i<m_dwSystemMayContainsCount; i++)
		delete [] m_lppszSystemMayContains[i];
	delete[] m_lppszSystemMayContains;

	m_lppszSystemMayContains = NULL;
	m_dwSystemMayContainsCount = 0;

	// Set the new list of values
	m_dwSystemMayContainsCount = dwNumValues;
	m_lppszSystemMayContains = new LPWSTR[m_dwSystemMayContainsCount];
	for(i=0; i<m_dwSystemMayContainsCount; i++)
	{
		m_lppszSystemMayContains[i] = new WCHAR[wcslen(pValues->CaseIgnoreString) + 1];
		wcscpy(m_lppszSystemMayContains[i], pValues->CaseIgnoreString);
		pValues ++;
	}
}

//***************************************************************************
//
// CADSIClass :: GetMustContains
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR *CADSIClass :: GetMustContains(DWORD *pdwCount)
{
	*pdwCount = m_dwMustContainsCount;
	return (LPCWSTR *)m_lppszMustContains;
}

//***************************************************************************
//
// CADSIClass :: SetMustContains
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetMustContains(PADSVALUE pValues, DWORD dwNumValues)
{
	// Delete the list of possible superiors
	for(DWORD i = 0; i<m_dwMustContainsCount; i++)
		delete [] m_lppszMustContains[i];
	delete[] m_lppszMustContains;

	m_lppszMustContains = NULL;
	m_dwMustContainsCount = 0;

	// Set the new list of values
	m_dwMustContainsCount = dwNumValues;
	m_lppszMustContains = new LPWSTR[m_dwMustContainsCount];
	for(i=0; i<m_dwMustContainsCount; i++)
	{
		m_lppszMustContains[i] = new WCHAR[wcslen(pValues->CaseIgnoreString) + 1];
		wcscpy(m_lppszMustContains[i], pValues->CaseIgnoreString);
		pValues ++;
	}
}

//***************************************************************************
//
// CADSIClass :: GetSystemMustContains
// 
// Purpose : See Header
//***************************************************************************
LPCWSTR *CADSIClass :: GetSystemMustContains(DWORD *pdwCount)
{
	*pdwCount = m_dwSystemMustContainsCount;
	return (LPCWSTR *)m_lppszSystemMustContains;
}

//***************************************************************************
//
// CADSIClass :: SetSystemMustContains
// 
// Purpose : See Header
//***************************************************************************
void CADSIClass :: SetSystemMustContains(PADSVALUE pValues, DWORD dwNumValues)
{
	// Delete the list of possible superiors
	for(DWORD i = 0; i<m_dwSystemMustContainsCount; i++)
		delete [] m_lppszSystemMustContains[i];
	delete[] m_lppszSystemMustContains;

	m_lppszSystemMustContains = NULL;
	m_dwSystemMustContainsCount = 0;

	// Set the new list of values
	m_dwSystemMustContainsCount = dwNumValues;
	m_lppszSystemMustContains = new LPWSTR[m_dwSystemMustContainsCount];
	for(i=0; i<m_dwSystemMustContainsCount; i++)
	{
		m_lppszSystemMustContains[i] = new WCHAR[wcslen(pValues->CaseIgnoreString) + 1];
		wcscpy(m_lppszSystemMustContains[i], pValues->CaseIgnoreString);
		pValues ++;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\common\adsiprop.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:adsiprop.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the implementation of the CADSIProperty which encapsulates an ADSI property
//
//***************************************************************************

#include <tchar.h>
#include <stdio.h>

#include <windows.h>
#include <objbase.h>

/* ADSI includes */
#include <activeds.h>

/* Provider includes */
#include "refcount.h"
#include "adsiprop.h"

//***************************************************************************
//
// CADSIProperty::CADSIProperty
//
// Purpose : Constructor 
//
// Parameters:
//	None
//***************************************************************************
CADSIProperty :: CADSIProperty()
	: CRefCountedObject()
{
	m_lpszWBEMPropertyName = NULL;
	m_lpszSyntaxOID = NULL;
	m_bMultiValued = FALSE;
	m_lpszAttributeID = NULL;
	m_lpszCommonName = NULL;
	m_bSystemOnly = FALSE;
	m_pDirectoryObject = NULL;
	m_bORName = FALSE;
}

//***************************************************************************
//
// CADSIProperty::CADSIProperty
//
// Purpose : Constructor 
//
// Parameters:
//  lpszWBEMPropertyName : The WBEM name of the property being created. A copy of this is made
//  lpszADSIPropertyName : The ADSI name of the property being created. A copy of this is made
//***************************************************************************
CADSIProperty :: CADSIProperty(LPCWSTR lpszWBEMPropertyName, LPCWSTR lpszADSIPropertyName)
	: CRefCountedObject(lpszADSIPropertyName)
{
	m_lpszWBEMPropertyName = new WCHAR[wcslen(lpszWBEMPropertyName) + 1];
	wcscpy(m_lpszWBEMPropertyName, lpszWBEMPropertyName);

	m_lpszSyntaxOID = NULL;
	m_bMultiValued = FALSE;
	m_lpszAttributeID = NULL;
	m_lpszCommonName = NULL;
	m_bSystemOnly = FALSE;
	m_pDirectoryObject = NULL;
	m_bORName = FALSE;
}


//***************************************************************************
//
// CADSIProperty :: ~CADSIProperty
// 
// Purpose : Destructor
//***************************************************************************
CADSIProperty :: ~CADSIProperty()
{
	delete [] m_lpszWBEMPropertyName;
	delete [] m_lpszSyntaxOID;
	delete [] m_lpszAttributeID;
	delete [] m_lpszCommonName;

	if(m_pDirectoryObject)
		m_pDirectoryObject->Release();
}


//***************************************************************************
//
// CADSIProperty :: GetWBEMPropertyName
// 
// Purpose : Returns the WBEM  property name of this property
//***************************************************************************
LPCWSTR CADSIProperty :: GetWBEMPropertyName()
{
	return m_lpszWBEMPropertyName;
}

//***************************************************************************
//
// CADSIProperty :: SetWBEMPropertyName
// 
// Purpose : Sets the WBEM name of this property
//***************************************************************************
void CADSIProperty :: SetWBEMPropertyName(LPCWSTR lpszWBEMName)
{
	delete [] m_lpszWBEMPropertyName;
	if(lpszWBEMName)
	{
		m_lpszWBEMPropertyName = new WCHAR[wcslen(lpszWBEMName) + 1];
		wcscpy(m_lpszWBEMPropertyName, lpszWBEMName);
	}
	else
		m_lpszWBEMPropertyName = NULL;
}

//***************************************************************************
//
// CADSIProperty :: GetADSIPropertyName
// 
// Purpose : Returns the ADSI  property name of this property
//***************************************************************************
LPCWSTR CADSIProperty :: GetADSIPropertyName()
{
	return GetName();
}

//***************************************************************************
//
// CADSIProperty :: SetADSIPropertyName
// 
// Purpose : Sets the ADSI name of this property
//***************************************************************************
void CADSIProperty :: SetADSIPropertyName(LPCWSTR lpszADSIName)
{
	SetName(lpszADSIName);
}

//***************************************************************************
//
// CADSIProperty :: GetSyntaxOID
// 
// Purpose : Returns the ADSI Syntax OID of this property
//***************************************************************************
LPCWSTR CADSIProperty :: GetSyntaxOID()
{
	return m_lpszSyntaxOID;
}

//***************************************************************************
//
// CADSIProperty :: SetSyntaxOID
// 
// Purpose : Sets the ADSI Syntax OID of this property
//***************************************************************************
void CADSIProperty :: SetSyntaxOID(LPCWSTR lpszSyntaxOID)
{
	delete [] m_lpszSyntaxOID;
	if(lpszSyntaxOID)
	{
		m_lpszSyntaxOID = new WCHAR[wcslen(lpszSyntaxOID) + 1];
		wcscpy(m_lpszSyntaxOID, lpszSyntaxOID);
	}
	else
		m_lpszSyntaxOID = NULL;
}

//***************************************************************************
//
// CADSIProperty :: IsORName
// 
// Purpose : Returns whether the property is m_bORName
//***************************************************************************
BOOLEAN CADSIProperty :: IsORName()
{
	return m_bORName;
}

//***************************************************************************
//
// CADSIProperty :: SetORName
// 
// Purpose : Sets the m_bORName property of this property
//***************************************************************************
void CADSIProperty :: SetORName(BOOLEAN bORName)
{
	m_bORName = bORName;
}


//***************************************************************************
//
// CADSIProperty :: IsMultiValued
// 
// Purpose : Returns whether the property is multi valued
//***************************************************************************
BOOLEAN CADSIProperty :: IsMultiValued()
{
	return m_bMultiValued;
}

//***************************************************************************
//
// CADSIProperty :: SetMultiValued
// 
// Purpose : Sets the multi-valued property of this property
//***************************************************************************
void CADSIProperty :: SetMultiValued(BOOLEAN bMultiValued)
{
	m_bMultiValued = bMultiValued;
}

//***************************************************************************
//
// CADSIProperty :: IsSystemOnly
// 
// Purpose : Returns whether the property is SystemOnly
//***************************************************************************
BOOLEAN CADSIProperty :: IsSystemOnly()
{
	return m_bSystemOnly;
}

//***************************************************************************
//
// CADSIProperty :: SetSystemOnly
// 
// Purpose : Sets the SystemOnly property of this property
//***************************************************************************
void CADSIProperty :: SetSystemOnly(BOOLEAN bSystemOnly)
{
	m_bSystemOnly = bSystemOnly;
}

//***************************************************************************
//
// CADSIProperty :: GetSearchFlags
// 
// Purpose : Returns the SearchFlags property of the property
//***************************************************************************
DWORD CADSIProperty :: GetSearchFlags()
{
	return m_dwSearchFlags;
}

//***************************************************************************
//
// CADSIProperty :: SetSearchFlags
// 
// Purpose : Sets the SearchFlags property of this property
//***************************************************************************
void CADSIProperty :: SetSearchFlags(DWORD dwSearchFlags)
{
	m_dwSearchFlags = dwSearchFlags;
}

//***************************************************************************
//
// CADSIProperty :: GetOMSyntax
// 
// Purpose : Returns the OMSyntax property of the property
//***************************************************************************
DWORD CADSIProperty :: GetOMSyntax()
{
	return m_dwOMSyntax;
}

//***************************************************************************
//
// CADSIProperty :: SetOMSyntax
// 
// Purpose : Sets the OMSyntax property of this property
//***************************************************************************
void CADSIProperty :: SetOMSyntax(DWORD dwOMSyntax)
{
	m_dwOMSyntax = dwOMSyntax;
}

//***************************************************************************
//
// CADSIProperty :: GetMAPI_ID
// 
// Purpose : Returns the MAPI_ID property of the property
//***************************************************************************
DWORD CADSIProperty :: GetMAPI_ID()
{
	return m_dwMAPI_ID;
}

//***************************************************************************
//
// CADSIProperty :: SetMAPI_ID
// 
// Purpose : Sets the MAPI_ID property of this property
//***************************************************************************
void CADSIProperty :: SetMAPI_ID(DWORD dwMAPI_ID)
{
	m_dwMAPI_ID = dwMAPI_ID;
}

//***************************************************************************
//
// CADSIProperty :: GetAttributeID
// 
// Purpose : Returns the Attribute ID of this property
//***************************************************************************
LPCWSTR CADSIProperty :: GetAttributeID()
{
	return m_lpszAttributeID;
}

//***************************************************************************
//
// CADSIProperty :: SetAttributeID
// 
// Purpose : Sets the Attribute ID of this property
//***************************************************************************
void CADSIProperty :: SetAttributeID(LPCWSTR lpszAttributeID)
{
	delete [] m_lpszAttributeID;
	if(lpszAttributeID)
	{
		m_lpszAttributeID = new WCHAR[wcslen(lpszAttributeID) + 1];
		wcscpy(m_lpszAttributeID, lpszAttributeID);
	}
	else
		m_lpszAttributeID = NULL;
}

//***************************************************************************
//
// CADSIProperty :: GetCommonName
// 
// Purpose : Returns the Common Name of this property
//***************************************************************************
LPCWSTR CADSIProperty :: GetCommonName()
{
	return m_lpszCommonName;
}

//***************************************************************************
//
// CADSIProperty :: SetCommonName
// 
// Purpose : Sets the CommonName of this property
//***************************************************************************
void CADSIProperty :: SetCommonName(LPCWSTR lpszCommonName)
{
	delete [] m_lpszCommonName;
	if(lpszCommonName)
	{
		m_lpszCommonName = new WCHAR[wcslen(lpszCommonName) + 1];
		wcscpy(m_lpszCommonName, lpszCommonName);
	}
	else
		m_lpszCommonName = NULL;
}

//***************************************************************************
//
// CADSIProperty :: GetDirectoryObject
// 
// Purpose : Returns the ADSI object pertaining to this property
//	It is the user's duty to release it when done
// 
// Parameters:
//	None
//
// Return Value:
//	The ADSI object interface pertaining to this property	
//***************************************************************************
IDirectoryObject *CADSIProperty :: GetDirectoryObject()
{
	if(m_pDirectoryObject)
		m_pDirectoryObject->AddRef();
	return m_pDirectoryObject;
}

//***************************************************************************
//
// CADSIProperty :: SetDirectoryObject
// 
// Purpose : Sets the ADSI object pertaining to this property
//
// Parameter : The directory object pertaining to this property
//***************************************************************************
void CADSIProperty :: SetDirectoryObject(IDirectoryObject * pDirectoryObject)
{
	if(m_pDirectoryObject)
		m_pDirectoryObject->Release();
	m_pDirectoryObject = pDirectoryObject;
	m_pDirectoryObject->AddRef();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\classprovider\include\wbemcach.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:wbemcach.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Cache for WBEM Class objects 
//
//***************************************************************************

#ifndef WBEM_CACHE_H
#define WBEM_CACHE_H

// This encapsulates a WBEM Class object
class CWbemClass : public CRefCountedObject
{
private:
	IWbemClassObject *m_pWbemClass;

public:
	static DWORD dwCWbemClassCount;

	CWbemClass(LPCWSTR pszWbemClassName, IWbemClassObject *pWbemClass)
		: CRefCountedObject(pszWbemClassName)
	{
		dwCWbemClassCount++;
		m_pWbemClass = pWbemClass;
		m_pWbemClass->AddRef();
	}
	~CWbemClass()
	{
		dwCWbemClassCount--;
		m_pWbemClass->Release();
	}

	IWbemClassObject *GetWbemClass()
	{
		m_pWbemClass->AddRef();
		return m_pWbemClass;
	}

};

// This encapsulates subclass enumeration (deep) of a WBEM class
class CEnumInfo : public CRefCountedObject
{
private:
	CNamesList *m_pClassNameList;

public:
	static DWORD dwCEnumInfoCount;
	CEnumInfo(LPCWSTR pszWbemSuperClassName, CNamesList *pClassNameList)
		: CRefCountedObject(pszWbemSuperClassName)
	{
		dwCEnumInfoCount++;
		m_pClassNameList = pClassNameList;
	}
	~CEnumInfo()
	{
		dwCEnumInfoCount--;
		delete m_pClassNameList;
	}

	CNamesList *GetSubClassNames() 
	{
		return m_pClassNameList;
	}
};

class CWbemCache
{
private:
	// The storage for cached classes
	CObjectTree m_objectTree;
	// The storage for enumeration information
	CObjectTree m_EnumTree;


	// The Log object
	ProvDebugLog *m_pLogObject;

	// Cache configuration parameters
	static const __int64 MAX_CACHE_AGE; // In seconds
	static const DWORD MAX_CACHE_SIZE;
	static DWORD dwWBEMCacheCount;

public:
	//***************************************************************************
	//
	// CWbemCache::CLDAPCache
	//
	// Purpose : Constructor. Creates an empty cache
	//
	// Parameters: 
	//***************************************************************************
	CWbemCache(ProvDebugLog *pLogObject);

	//***************************************************************************
	//
	// CWbemCache::GetClass
	//
	// Purpose : Retreives the IDirectory interface of an LDAP Class
	//
	// Parameters: 
	//	lpszClassName : The WBEM name of the Class to be retreived. 
	//	ppWbemClass : The address of the pointer where the CWbemClass object will be placed
	//
	//	Return value:
	//		The COM value representing the return status. The user should release the WBEM cclass
	// when done.
	//		
	//***************************************************************************
	HRESULT GetClass(LPCWSTR lpszWbemClassName, CWbemClass **ppWbemClass );

	//***************************************************************************
	//
	// CWbemCache::AddClass
	//
	// Purpose : Adds the CWbemClass object to the cache
	//
	// Parameters: 
	//	ppWbemClass : The CWbemClass pointer of the object to be added
	//
	//	Return value:
	//		The COM value representing the return status. 
	// when done.
	//		
	//***************************************************************************
	HRESULT AddClass(CWbemClass *pWbemClass );

	//***************************************************************************
	//
	// CEnumCache::GetEnumInfo
	//
	// Purpose : Retreives the CEnumInfo object of a WBEM class
	//
	// Parameters: 
	//	lpszWbemClassName : The WBEM name of the Class to be retreived. 
	//	ppEnumInfo : The address of the pointer where the CEnumInfo object will be placed
	//
	//	Return value:
	//		The COM value representing the return status. The user should release the WBEM cclass
	// when done.
	//		
	//***************************************************************************
	HRESULT GetEnumInfo(LPCWSTR lpszWbemClassName, CEnumInfo **ppEnumInfo );

	//***************************************************************************
	//
	// CEnumCache::AddEnumInfo
	//
	// Purpose : Adds the CEnumInfo object to the cache
	//
	// Parameters: 
	//	ppWbemClass : The CEnumInfo pointer of the object to be added
	//
	//	Return value:
	//		The COM value representing the return status. 
	// when done.
	//		
	//***************************************************************************
	HRESULT AddEnumInfo(CEnumInfo *pEnumInfo);


};

#endif /* WBEM_CACHE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\common\clsname.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include <windows.h>
#include <objbase.h>
#include <comdef.h>
#include <cominit.h>

#include "clsname.h"

CNamesList :: CNamesList()
{
	m_pListOfClassNames = NULL;
	m_dwElementCount = 0;
	InitializeCriticalSection(&m_AccessibleClassesSection);
}

CNamesList :: ~CNamesList()
{
	EnterCriticalSection(&m_AccessibleClassesSection);
	CLPWSTR *pTemp1 = m_pListOfClassNames;
	CLPWSTR *pNext = m_pListOfClassNames;
	while(pTemp1)
	{
		pNext = pTemp1->pNext;
		delete pTemp1;
		pTemp1 = pNext;
	}
	LeaveCriticalSection(&m_AccessibleClassesSection);
	DeleteCriticalSection(&m_AccessibleClassesSection);
}

BOOLEAN CNamesList :: IsNamePresent(LPCWSTR pszClassName) 
{
	// Get the current impersonation level
	DWORD dwCurrentImpersonationLevel = 0;
	if(FAILED(GetImpersonationLevel(&dwCurrentImpersonationLevel)))
		return FALSE;

	// Look for a name in the list that has an impersonation level of current or greater
	BOOLEAN bRetVal = FALSE;
	EnterCriticalSection(&m_AccessibleClassesSection);
	CLPWSTR *pCurrent = m_pListOfClassNames;
	while(pCurrent)
	{
		if(_wcsicmp(pCurrent->pszVal, pszClassName) == 0 && pCurrent->dwImpersonationLevel <= dwCurrentImpersonationLevel)
		{
			bRetVal = TRUE;
			break;
		}
		pCurrent = pCurrent->pNext;
	}
	LeaveCriticalSection(&m_AccessibleClassesSection);

	return bRetVal;
}

BOOLEAN CNamesList :: RemoveName(LPCWSTR pszClassName)
{
#ifdef NO_WBEM_CACHE
	return FALSE;
#else
	BOOLEAN bRetVal = FALSE;
	EnterCriticalSection(&m_AccessibleClassesSection);
	if(m_pListOfClassNames)
	{
		// Is it the first node ?
		if(_wcsicmp(m_pListOfClassNames->pszVal, pszClassName) == 0)
		{
			bRetVal = TRUE;
			CLPWSTR *pTemp = m_pListOfClassNames->pNext;
			delete m_pListOfClassNames;
			m_pListOfClassNames = pTemp;
			m_dwElementCount--;
		}
		else
		{
			CLPWSTR *pPrev = m_pListOfClassNames;
			CLPWSTR *pCurrent = m_pListOfClassNames->pNext;

			while(pCurrent)
			{
				if(_wcsicmp(pCurrent->pszVal, pszClassName) == 0)
				{
					bRetVal = TRUE;
					pPrev->pNext = pCurrent->pNext;
					delete pCurrent;
					m_dwElementCount --;
					break;
				}
				pPrev = pCurrent;
				pCurrent = pCurrent->pNext;
			}
		}
	}
	LeaveCriticalSection(&m_AccessibleClassesSection);

	return bRetVal;
#endif
}

BOOLEAN CNamesList :: AddName(LPCWSTR pszClassName)
{
#ifdef NO_WBEM_CACHE
	return FALSE;
#else

	// Get the current impersonation level
	DWORD dwCurrentImpersonationLevel = 0;
	if(!SUCCEEDED(GetImpersonationLevel(&dwCurrentImpersonationLevel)))
		return FALSE;
	
	
	// Add it only if it doesnt already exist in the list
	BOOLEAN bFound = FALSE;
	EnterCriticalSection(&m_AccessibleClassesSection);
	CLPWSTR *pCurrent = m_pListOfClassNames;
	while(pCurrent)
	{
		if(_wcsicmp(pCurrent->pszVal, pszClassName) == 0)
		{
			bFound = TRUE;
			break;
		}
		pCurrent = pCurrent->pNext;
	}

	// Add it at the head
	if(!bFound)
	{
		pCurrent = m_pListOfClassNames;
		m_pListOfClassNames = new CLPWSTR;
		m_pListOfClassNames->pszVal = new WCHAR[wcslen(pszClassName) + 1];
		m_pListOfClassNames->dwImpersonationLevel = dwCurrentImpersonationLevel;
		wcscpy(m_pListOfClassNames->pszVal, pszClassName);
		m_pListOfClassNames->pNext = pCurrent;
		m_dwElementCount ++;
	}
	else	// update the impersonation level if necessary
	{
		if(pCurrent->dwImpersonationLevel < dwCurrentImpersonationLevel)
			pCurrent->dwImpersonationLevel = dwCurrentImpersonationLevel;
	}
	LeaveCriticalSection(&m_AccessibleClassesSection);

	return !bFound;
#endif
}

DWORD CNamesList :: GetAllNames(LPWSTR **pppszNames) 
{
	EnterCriticalSection(&m_AccessibleClassesSection);
	DWORD retVal = m_dwElementCount;
	*pppszNames = NULL;
	if(m_dwElementCount)
	{
		*pppszNames = new LPWSTR[m_dwElementCount];
		CLPWSTR *pCurrent = m_pListOfClassNames;
		for(DWORD i=0; i<m_dwElementCount; i++)
		{
			(*pppszNames)[i] = new WCHAR[wcslen(pCurrent->pszVal) + 1];
			wcscpy((*pppszNames)[i], pCurrent->pszVal);
			pCurrent = pCurrent->pNext;
		}
	}
	LeaveCriticalSection(&m_AccessibleClassesSection);

	return retVal;
}

HRESULT CNamesList :: GetImpersonationLevel(DWORD *pdwImpLevel)
{
	//get implevel...
	HANDLE hThreadTok = NULL;
	HRESULT hr = E_FAIL;

	if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hThreadTok) )
	{
		WbemCoImpersonateClient();
		DWORD dwBytesReturned = 0;
		DWORD dwThreadImpLevel = 0;

		if (GetTokenInformation(hThreadTok, TokenImpersonationLevel, &dwThreadImpLevel,
									sizeof(DWORD), &dwBytesReturned)) 
		{
			WbemCoImpersonateClient();
			hr = S_OK;

			switch(dwThreadImpLevel)
			{
				case SecurityAnonymous:
				{
					*pdwImpLevel = RPC_C_IMP_LEVEL_ANONYMOUS;
				}
				break;

				case SecurityIdentification:
				{
					*pdwImpLevel = RPC_C_IMP_LEVEL_IDENTIFY;
				}
				break;

				case SecurityImpersonation:
				{
					*pdwImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
				}
				break;

				case SecurityDelegation:
				{
					*pdwImpLevel = RPC_C_IMP_LEVEL_DELEGATE;
				}
				break;
				
				default:
				{
					hr = E_FAIL;
				}
			}
		}
		CloseHandle(hThreadTok);
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\common\adsiinst.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:adsiinst.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the implementation of the CADSIInstance which encapsulates an ADSI instance
//
//***************************************************************************

#include <tchar.h>
#include <stdio.h>

#include <windows.h>
#include <objbase.h>

/* ADSI includes */
#include <activeds.h>

#include "attributes.h"
#include "refcount.h"
#include "adsiinst.h"

//***************************************************************************
//
// CADSIInstance::CADSIInstance
//
// Purpose : Constructor 
//
// Parameters:
	//  lpszADSIPath : The ADSI Path to the object
//***************************************************************************
CADSIInstance :: CADSIInstance(LPCWSTR lpszADSIPath, IDirectoryObject *pDirectoryObject)
	: CRefCountedObject(lpszADSIPath)
{
	m_pAttributes = NULL;
	m_dwNumAttributes = 0;
	m_pObjectInfo = NULL;

	m_pDirectoryObject = pDirectoryObject;
	m_pDirectoryObject->AddRef();
}


//***************************************************************************
//
// CADSIInstance :: ~CADSIInstance
// 
// Purpose : Destructor
//***************************************************************************
CADSIInstance :: ~CADSIInstance()
{
	// Free the attributes
	if(m_pAttributes)
		FreeADsMem((LPVOID *) m_pAttributes);

	if(m_pObjectInfo)
		FreeADsMem((LPVOID *) m_pObjectInfo);

	if(m_pDirectoryObject)
		m_pDirectoryObject->Release();
}

IDirectoryObject *CADSIInstance :: GetDirectoryObject()
{
	m_pDirectoryObject->AddRef();
	return m_pDirectoryObject;
}

//***************************************************************************
//
// CADSIInstance :: GetAttributes
// 
// Purpose : See header for details
//***************************************************************************
PADS_ATTR_INFO CADSIInstance :: GetAttributes(DWORD *pdwNumAttributes)
{
	*pdwNumAttributes = m_dwNumAttributes;
	return m_pAttributes;
}

//***************************************************************************
//
// CADSIInstance :: SetAttributes
// 
// Purpose : See header for details
//***************************************************************************
void  CADSIInstance :: SetAttributes(PADS_ATTR_INFO pAttributes, DWORD dwNumAttributes)
{
	// Go thru the attributes and release them
	if(m_pAttributes)
		FreeADsMem((LPVOID *) m_pAttributes);
	m_pAttributes = pAttributes;
	m_dwNumAttributes = dwNumAttributes;
}

//***************************************************************************
//
// CADSIInstance :: GetObjectInfo
// 
// Purpose : See header for details
//***************************************************************************
PADS_OBJECT_INFO CADSIInstance :: GetObjectInfo()
{
	return m_pObjectInfo;
}

//***************************************************************************
//
// CADSIInstance :: SetObjectInfo
// 
// Purpose : See header for details
//***************************************************************************
void  CADSIInstance :: SetObjectInfo(PADS_OBJECT_INFO pObjectInfo)
{
	// Go thru the attributes and release them
	if(m_pObjectInfo)
		FreeADsMem((LPVOID *) m_pObjectInfo);
	m_pObjectInfo = pObjectInfo;
}

//***************************************************************************
//
// CADSIInstance :: GetADSIClassName
// 
// Purpose : See header for details
//***************************************************************************
LPCWSTR CADSIInstance :: GetADSIClassName()
{
	if(m_pObjectInfo)
		return m_pObjectInfo->pszClassName;
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\common\ldaphelp.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:ldaphelp.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the implementation the CLDAPHelper class. This is
//	a class that has many static helper functions pertaining to ADSI LDAP Provider
//***************************************************************************
/////////////////////////////////////////////////////////////////////////


#include <tchar.h>
#include <windows.h>
#include <assert.h>
#include <activeds.h>

#include "attributes.h"
#include "refcount.h"
#include "adsiclas.h"
#include "adsiinst.h"
#include "provlog.h"
#include "ldaphelp.h"

LPCWSTR CLDAPHelper :: LDAP_CN_EQUALS						= L"LDAP://CN=";	
LPCWSTR CLDAPHelper :: LDAP_DISP_NAME_EQUALS				= L"(lDAPDisplayName=";
LPCWSTR CLDAPHelper :: OBJECT_CATEGORY_EQUALS_CLASS_SCHEMA		= L"(objectCategory=classSchema)";
LPCWSTR CLDAPHelper	:: SUB_CLASS_OF_EQUALS				= L"(subclassOf=";
LPCWSTR CLDAPHelper :: NOT_LDAP_NAME_EQUALS				= L"(!ldapDisplayName=";
LPCWSTR CLDAPHelper :: LEFT_BRACKET_AND					= L"(&";
LPCWSTR CLDAPHelper :: GOVERNS_ID_EQUALS				= L"(governsId=";
LPCWSTR CLDAPHelper :: CLASS_SCHEMA						= L"classSchema";
LPCWSTR CLDAPHelper :: CN_EQUALS						= L"cn=";

//***************************************************************************
//
// CLDAPHelper :: GetLDAPClassFromLDAPName
//
// Purpose : See Header
//***************************************************************************
HRESULT CLDAPHelper :: GetLDAPClassFromLDAPName(
	IDirectorySearch *pDirectorySearchSchemaContainer,
	LPCWSTR lpszSchemaContainerSuffix,
	PADS_SEARCHPREF_INFO pSearchInfo,
	DWORD dwSearchInfoCount,
	CADSIClass *pADSIClass
)
{
	// We map the object from the LDAP Display name
	// Hence we cannot directly do an ADsOpenObject().
	// We have to send an LDAP query for the instance of ClassSchema/AttributeSchema where the
	// ldapdisplayname attribute is the lpszObjectName parameter.
	HRESULT result = E_FAIL;

	// For the search filter;
	LPCWSTR lpszLDAPObjectName = pADSIClass->GetADSIClassName();
	LPWSTR lpszSearchFilter = new WCHAR[ wcslen(LDAP_DISP_NAME_EQUALS) + wcslen(lpszLDAPObjectName) + wcslen(RIGHT_BRACKET_STR) + 1];
	wcscpy(lpszSearchFilter, LDAP_DISP_NAME_EQUALS);
	wcscat(lpszSearchFilter, lpszLDAPObjectName);
	wcscat(lpszSearchFilter, RIGHT_BRACKET_STR);
	ADS_SEARCH_HANDLE hADSSearch;
	if(SUCCEEDED(result = pDirectorySearchSchemaContainer->ExecuteSearch(lpszSearchFilter, NULL, -1, &hADSSearch)))
	{
		if(SUCCEEDED(result = pDirectorySearchSchemaContainer->GetNextRow(hADSSearch)) && result != S_ADS_NOMORE_ROWS)
		{
			// Get the column for the CN attribute
			ADS_SEARCH_COLUMN adsColumn;

			// Store each of the LDAP class attributes
			// Reset the LDAP and WBEM names to take care of change in case
			if(SUCCEEDED(result) && SUCCEEDED(result = pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)LDAP_DISPLAY_NAME_ATTR, &adsColumn)))
			{
				if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
					result = E_FAIL;
				else
				{
					pADSIClass->SetADSIClassName(adsColumn.pADsValues->CaseIgnoreString);
					LPWSTR lpszWBEMName = CLDAPHelper::MangleLDAPNameToWBEM(adsColumn.pADsValues->CaseIgnoreString);
					pADSIClass->SetWBEMClassName(lpszWBEMName);
					delete [] lpszWBEMName;
				}

				pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
			}

			// Store each of the LDAP class attributes 
			if(SUCCEEDED(result) && SUCCEEDED(result = pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)COMMON_NAME_ATTR, &adsColumn)))
			{
				if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
					result = E_FAIL;
				else
					pADSIClass->SetCommonName(adsColumn.pADsValues->CaseIgnoreString);
				pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
			}

			// Special case for top since ADSI returns "top" as the parent class of "top" and we
			// will go into an infinite loop later if we dont check this
			if(pADSIClass->GetCommonName() && _wcsicmp(pADSIClass->GetCommonName(), TOP_CLASS) != 0)
			{
				if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
					result = E_FAIL;
				else
				{
					if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)SUB_CLASS_OF_ATTR, &adsColumn)))
					{
						pADSIClass->SetSuperClassLDAPName(adsColumn.pADsValues->CaseIgnoreString);
						pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
					}
				}
			}

			if(SUCCEEDED(result) && SUCCEEDED(result = pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)GOVERNS_ID_ATTR, &adsColumn)))
			{
				if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
					result = E_FAIL;
				else
					pADSIClass->SetGovernsID(adsColumn.pADsValues->CaseIgnoreString);
				pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
			}

			if(SUCCEEDED(result) && SUCCEEDED(result = pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)SCHEMA_ID_GUID_ATTR, &adsColumn)))
			{
				if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
					result = E_FAIL;
				else
					pADSIClass->SetSchemaIDGUID((adsColumn.pADsValues->OctetString).lpValue, (adsColumn.pADsValues->OctetString).dwLength);
				pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
			}

			if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)RDN_ATT_ID_ATTR, &adsColumn)))
			{
				if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
					result = E_FAIL;
				else
					pADSIClass->SetRDNAttribute(adsColumn.pADsValues->CaseIgnoreString);
				pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
			}

			if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)DEFAULT_SECURITY_DESCRP_ATTR, &adsColumn)))
			{
				if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
					result = E_FAIL;
				else
					pADSIClass->SetDefaultSecurityDescriptor(adsColumn.pADsValues->CaseIgnoreString);
				pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
			}

			if(SUCCEEDED(result) && SUCCEEDED(result = pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)OBJECT_CLASS_CATEGORY_ATTR, &adsColumn)))
			{
				if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
					result = E_FAIL;
				else
					pADSIClass->SetObjectClassCategory(adsColumn.pADsValues->Integer);
				pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
			}

			/*
			if(SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)NT_SECURITY_DESCRIPTOR_ATTR, &adsColumn)))
			{
				pADSIClass->SetNTSecurityDescriptor((adsColumn.pADsValues->SecurityDescriptor).lpValue, (adsColumn.pADsValues->SecurityDescriptor).dwLength);
				pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
			}
			*/
			if(SUCCEEDED(result) && SUCCEEDED(result = pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)DEFAULT_OBJECTCATEGORY_ATTR, &adsColumn)))
			{
				if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
					result = E_FAIL;
				else
				{
					// Get the LDAPDIpslayName of the class
					LPWSTR lpszLDAPName = NULL;
					if(SUCCEEDED(result) && SUCCEEDED(result = GetLDAPClassNameFromCN(adsColumn.pADsValues->DNString, &lpszLDAPName)))
					{
						pADSIClass->SetDefaultObjectCategory(lpszLDAPName);
						delete [] lpszLDAPName;
					}
				}
				pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
			}

			if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)SYSTEM_ONLY_ATTR, &adsColumn)))
			{
				if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
					result = E_FAIL;
				else
					pADSIClass->SetSystemOnly((BOOLEAN)adsColumn.pADsValues->Boolean);
				pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
			}

			if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)AUXILIARY_CLASS_ATTR, &adsColumn)))
			{
				if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
					result = E_FAIL;
				else
					pADSIClass->SetAuxiliaryClasses(adsColumn.pADsValues, adsColumn.dwNumValues);
				pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
			}

			if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)SYSTEM_AUXILIARY_CLASS_ATTR, &adsColumn)))
			{
				if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
					result = E_FAIL;
				else
					pADSIClass->SetSystemAuxiliaryClasses(adsColumn.pADsValues, adsColumn.dwNumValues);
				pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
			}

			if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)SYSTEM_MAY_CONTAIN_ATTR, &adsColumn)))
			{
				if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
					result = E_FAIL;
				else
					pADSIClass->SetSystemMayContains(adsColumn.pADsValues, adsColumn.dwNumValues);
				pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
			}
			if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)MAY_CONTAIN_ATTR, &adsColumn)))
			{
				if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
					result = E_FAIL;
				else
					pADSIClass->SetMayContains(adsColumn.pADsValues, adsColumn.dwNumValues);
				pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
			}
			if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)SYSTEM_MUST_CONTAIN_ATTR, &adsColumn)))
			{
				if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
					result = E_FAIL;
				else
					pADSIClass->SetSystemMustContains(adsColumn.pADsValues, adsColumn.dwNumValues);
				pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
			}
			if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)MUST_CONTAIN_ATTR, &adsColumn)))
			{
				if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
					result = E_FAIL;
				else
					pADSIClass->SetMustContains(adsColumn.pADsValues, adsColumn.dwNumValues);
				pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
			}
			if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)SYSTEM_POSS_SUPERIORS_ATTR, &adsColumn)))
			{
				if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
					result = E_FAIL;
				else
					pADSIClass->SetSystemPossibleSuperiors(adsColumn.pADsValues, adsColumn.dwNumValues);
				pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
			}
			if(SUCCEEDED(result) && SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearch, (LPWSTR)POSS_SUPERIORS_ATTR, &adsColumn)))
			{
				if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
					result = E_FAIL;
				else
					pADSIClass->SetPossibleSuperiors(adsColumn.pADsValues, adsColumn.dwNumValues);
				pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
			}
		}
		else
			result = E_FAIL;

		// Close the search
		pDirectorySearchSchemaContainer->CloseSearchHandle(hADSSearch);
	}

	// Delete the filter
	delete [] lpszSearchFilter;

	return result;
}


//***************************************************************************
//
// CLDAPHelper :: GetLDAPSchemaObjectFromCommonName
//
// Purpose : To fetch the IDirectoryObject interface on a class/property provided by the LDAP Provider
// Parameters:
//		lpszSchemaContainerSuffix : The suffix to be used. The actual object fetced will be:
//			LDAP://CN=<lpszCommonName>,<lpszSchemaContainerSuffix>
//		lpszCommonName : The 'cn' attribute of the LDAP class or property to be fetched. 
//		ppLDAPObject : The address where the pointer to IDirectoryObject will be stored
//			It is the caller's responsibility to delete the object when done with it
// 
//	Return Value: The COM status value indicating the status of the request.
//***************************************************************************
HRESULT CLDAPHelper :: GetLDAPSchemaObjectFromCommonName(
	LPCWSTR lpszSchemaContainerSuffix,
	LPCWSTR lpszCommonName, 
	IDirectoryObject **ppLDAPObject)
{
	// Form the ADSI path to the LDAP object
	LPWSTR lpszLDAPObjectPath = new WCHAR[wcslen(LDAP_CN_EQUALS) + wcslen(lpszCommonName) + wcslen(COMMA_STR) + wcslen(lpszSchemaContainerSuffix) + 1];
	wcscpy(lpszLDAPObjectPath, LDAP_CN_EQUALS);
	wcscat(lpszLDAPObjectPath, lpszCommonName);
	wcscat(lpszLDAPObjectPath, COMMA_STR);
	wcscat(lpszLDAPObjectPath, lpszSchemaContainerSuffix);

	HRESULT result = ADsOpenObject(lpszLDAPObjectPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectoryObject, (LPVOID *)ppLDAPObject);

	delete[] lpszLDAPObjectPath;
	return result;
}

//***************************************************************************
//
// CLDAPHelper :: GetLDAPClassNameFromCN
//
// Purpose : To fetch the LDAPDisplayNAme of a class from its path
// Parameters:
// 
//	lpszLDAPClassPath : The path to the class object without the LDAP prefix. Ex CN=user,CN=Schema, CN=COnfiguration ...
//	Return Value: The COM status value indicating the status of the request. The user should delete the
// name returned, when done
//***************************************************************************
HRESULT CLDAPHelper :: GetLDAPClassNameFromCN(LPCWSTR lpszLDAPClassPath, 
	LPWSTR *lppszLDAPName)
{
	IDirectoryObject *pLDAPClass = NULL;

	// Prepend the LDAP:// perfix
	LPWSTR lpszRealPath = new WCHAR[ wcslen(LDAP_PREFIX) + wcslen(lpszLDAPClassPath) + 1];
	wcscpy(lpszRealPath, LDAP_PREFIX);
	wcscat(lpszRealPath, lpszLDAPClassPath);

	HRESULT result = ADsOpenObject(lpszRealPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectoryObject, (LPVOID *)&pLDAPClass);
	delete [] lpszRealPath;

	// Get the attribute LDAPDisplayName
	if(SUCCEEDED(result))
	{
		PADS_ATTR_INFO pAttributes = NULL;
		DWORD dwReturnCount = 0;
		if(SUCCEEDED(result = pLDAPClass->GetObjectAttributes((LPWSTR *)&LDAP_DISPLAY_NAME_ATTR, 1, &pAttributes, &dwReturnCount)) && dwReturnCount == 1)
		{
			if(pAttributes->pADsValues->dwType == ADSTYPE_PROV_SPECIFIC)
				result = E_FAIL;
			else
			{
				*lppszLDAPName = new WCHAR[wcslen(pAttributes->pADsValues->DNString) + 1];
				wcscpy(*lppszLDAPName, pAttributes->pADsValues->DNString);
			}
			FreeADsMem((LPVOID *)pAttributes);
		}

		pLDAPClass->Release();
	}
	return result;
}

//***************************************************************************
//
// CLDAPHelper :: EnumerateClasses
//
// Purpose : See Header
//***************************************************************************
HRESULT CLDAPHelper :: EnumerateClasses(
	IDirectorySearch *pDirectorySearchSchemaContainer,
	LPCWSTR lpszSchemaContainerSuffix,
	PADS_SEARCHPREF_INFO pSearchInfo,
	DWORD dwSearchInfoCount,
	LPCWSTR lpszLDAPSuperClass,
	BOOLEAN bDeep,
	LPWSTR **pppszClassNames,
	DWORD *pdwNumRows,
	BOOLEAN bArtificialClass)
{
	// Initialize the return values
	HRESULT result = E_FAIL;
	*pdwNumRows = 0;

	// The search filter;
	LPWSTR lpszSearchFilter = NULL;

	// There's various cases to be considered here.
	// if(lpszLDAPSuperClass is NULL)
	// then
	//		if bDeep is false, then no objects is returned (since we do not provide the LDAP base class
	//		else all the classes are returned using the filter (objectCategory=classSchema)
	//	else
	//		if bDeep is false, then the filter (&(objectCategory=classSchema)(subClassOf=lpszLDAPSuperClass)) is used
	//		else a lot of work has to be done!
	if(lpszLDAPSuperClass == NULL)
	{
		if(!bDeep)
		{
			*pppszClassNames = NULL;
			*pdwNumRows = 0;
			return S_OK;
		}
		else
		{
			lpszSearchFilter = new WCHAR[ wcslen(OBJECT_CATEGORY_EQUALS_CLASS_SCHEMA) + 1];
			wcscpy(lpszSearchFilter, OBJECT_CATEGORY_EQUALS_CLASS_SCHEMA);
		}
	}
	else
	{
		if(!bDeep)
		{
			// One would imagine that a filter of the kind
			 //(&(objectClass=classSchema)(subClassOf=<lpszLDAPSuperClass>))
			// would be enough. Unfortunately it also gives the Top class
			//in the results when the value of lpszLDAPSuperClass is Top
			// we dont need that. Hnce we form the filter
			 //(&(objectClass=classSchema)(subClassOf=<lpszLDAPSuperClass>)(!ldapDisplayName=<lpszLDAPSuperClass>))
			lpszSearchFilter = new WCHAR[ wcslen(LEFT_BRACKET_AND)					// (&
									+ wcslen(OBJECT_CATEGORY_EQUALS_CLASS_SCHEMA)		// (objectCategory=classSchema)
									+ wcslen(SUB_CLASS_OF_EQUALS)					// (subClassOf=
									+ wcslen(lpszLDAPSuperClass)					// superClass
									+ wcslen(RIGHT_BRACKET_STR)							// )
									+ wcslen(NOT_LDAP_NAME_EQUALS)					// (!ldapDisplayName=
									+ wcslen(lpszLDAPSuperClass)					// superClass
									+ 2*wcslen(RIGHT_BRACKET_STR)						// ))
									+1];
			wcscpy(lpszSearchFilter, LEFT_BRACKET_AND);
			wcscat(lpszSearchFilter, OBJECT_CATEGORY_EQUALS_CLASS_SCHEMA);
			wcscat(lpszSearchFilter, SUB_CLASS_OF_EQUALS);
			wcscat(lpszSearchFilter, lpszLDAPSuperClass);
			wcscat(lpszSearchFilter, RIGHT_BRACKET_STR);
			wcscat(lpszSearchFilter, NOT_LDAP_NAME_EQUALS);					// (!ldapDisplayName=
			wcscat(lpszSearchFilter, lpszLDAPSuperClass);
			wcscat(lpszSearchFilter, RIGHT_BRACKET_STR);
			wcscat(lpszSearchFilter, RIGHT_BRACKET_STR);
		}
		else
			lpszSearchFilter = NULL; // THIS SPECIAL CASE IS TACKLED LATER
	}

	if(lpszSearchFilter)
	{
		ADS_SEARCH_HANDLE hADSSearchOuter;
		if(SUCCEEDED(result = pDirectorySearchSchemaContainer->ExecuteSearch(lpszSearchFilter, (LPWSTR *)&LDAP_DISPLAY_NAME_ATTR, 1, &hADSSearchOuter)))
		{
			*pdwNumRows = 0;
			DWORD dwFirstCount = 0; // Number of rows retreived on the first count

			// Calculate the number of rows first. 
			while(SUCCEEDED(result = pDirectorySearchSchemaContainer->GetNextRow(hADSSearchOuter)) &&
				result != S_ADS_NOMORE_ROWS)
				dwFirstCount ++;

			// Allocate enough memory for the classes and names
			if(bArtificialClass)
			{
				dwFirstCount ++;
				*pppszClassNames = new LPWSTR [dwFirstCount];
				(*pppszClassNames)[0] = NULL;
			}
			else
			{
				*pppszClassNames = new LPWSTR [dwFirstCount];
			}

			// The index of the attribute being processed
			DWORD dwSecondCount = 0;
			if(bArtificialClass)
				dwSecondCount ++;

			// Get the columns for the attributes
			ADS_SEARCH_COLUMN adsColumn;

			// Move to the beginning of the search
			if(SUCCEEDED(result = pDirectorySearchSchemaContainer->GetFirstRow(hADSSearchOuter)) 
				&& result != S_ADS_NOMORE_ROWS)
			{
				// Store each of the LDAP class attributes 
				if(SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearchOuter, (LPWSTR)LDAP_DISPLAY_NAME_ATTR, &adsColumn)))
				{
					if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
					{
						result = E_FAIL;
						pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
					}
					else
					{
						// Create the CADSIClass
						(*pppszClassNames)[dwSecondCount] = new WCHAR[wcslen(adsColumn.pADsValues->CaseIgnoreString) + 1];
						wcscpy((*pppszClassNames)[dwSecondCount], adsColumn.pADsValues->CaseIgnoreString);
						pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
	
						dwSecondCount++;

						// Get the rest of the rows
						while(SUCCEEDED(result = pDirectorySearchSchemaContainer->GetNextRow(hADSSearchOuter))&&
								result != S_ADS_NOMORE_ROWS)
						{
							// Store each of the LDAP class attributes 
							if(SUCCEEDED(pDirectorySearchSchemaContainer->GetColumn(hADSSearchOuter, (LPWSTR)LDAP_DISPLAY_NAME_ATTR, &adsColumn)))
							{
								if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
								{
									result = E_FAIL;
									pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );
								}
								else
								{
									// Create the CADSIClass
									(*pppszClassNames)[dwSecondCount] = new WCHAR[wcslen(adsColumn.pADsValues->CaseIgnoreString) + 1];
									wcscpy((*pppszClassNames)[dwSecondCount], adsColumn.pADsValues->CaseIgnoreString);
									pDirectorySearchSchemaContainer->FreeColumn( &adsColumn );

									dwSecondCount++;
								}
							}
						}
					}
				}
			}

			// Something went wrong? Release allocated resources
			if(dwSecondCount != dwFirstCount)
			{
				// Delete the contents of the array
				for(DWORD j=0; j<dwSecondCount; j++)
				{
					delete [] (*pppszClassNames)[j];
				}

				// Delete the array itself
				delete [] (*pppszClassNames);

				// Set return values to empty
				*pppszClassNames = NULL;
				*pdwNumRows = 0;

				result = E_FAIL;
			}
			else
				*pdwNumRows = dwFirstCount;

			// Close the search
			pDirectorySearchSchemaContainer->CloseSearchHandle(hADSSearchOuter);

		} // ExecuteSearch() - Outer
		delete [] lpszSearchFilter;
	}
	else // THIS IS THE SPECIAL CASE WHERE ALL SUBCLASSES (RECURSIVELY) OF A GIVEN CLASS ARE REQUIRED
	{
		// A lot of work has to be done. THis is handled by CLDAPClassProvider. Hence control shold never reach here
		result = E_FAIL;
	}
	return result;
}


// Gets the IDIrectoryObject interface on an ADSI instance
HRESULT CLDAPHelper :: GetADSIInstance(LPCWSTR szADSIPath, CADSIInstance **ppADSIObject, ProvDebugLog *pLogObject)
{
	HRESULT result;
	IDirectoryObject *pDirectoryObject;
	*ppADSIObject = NULL;


	if(SUCCEEDED(result = ADsOpenObject((LPWSTR)szADSIPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectoryObject, (LPVOID *)&pDirectoryObject)))
	{

		*ppADSIObject = new CADSIInstance(szADSIPath, pDirectoryObject);

		PADS_ATTR_INFO pAttributeEntries;
		DWORD dwNumAttributes;
		if(SUCCEEDED(result = pDirectoryObject->GetObjectAttributes(NULL, -1, &pAttributeEntries, &dwNumAttributes)))
		{
			(*ppADSIObject)->SetAttributes(pAttributeEntries, dwNumAttributes);
			PADS_OBJECT_INFO pObjectInfo = NULL;
			if(SUCCEEDED(result = pDirectoryObject->GetObjectInformation(&pObjectInfo)))
			{
				(*ppADSIObject)->SetObjectInfo(pObjectInfo);
			}
			else
				pLogObject->WriteW( L"CLDAPHelper :: GetADSIInstance GetObjectInformation() FAILED on %s with %x\r\n", szADSIPath, result);
		}
		else
			pLogObject->WriteW( L"CLDAPHelper :: GetADSIInstance GetObjectAttributes() FAILED on %s with %x\r\n", szADSIPath, result);
		pDirectoryObject->Release();
	}
	else
		pLogObject->WriteW( L"CLDAPHelper :: GetADSIInstance ADsOpenObject() FAILED on %s with %x\r\n", szADSIPath, result);

	if(!SUCCEEDED(result))
		delete *ppADSIObject;
	return result;
}

//***************************************************************************
//
// CLDAPHelper :: CreateADSIPath
//
// Purpose : Forms the ADSI path from a class or property name
//
// Parameters:
//	lpszLDAPSchemaObjectName : The LDAP class or property name
//	lpszSchemaContainerSuffix : The suffix to be used. The actual object fetced will be:
//			LDAP://CN=<lpszLDAPSchemaObjectName>,<lpszSchemaContainerSuffix>
// 
//	Return Value: The ADSI path to the class or property object. This has to
//	be deallocated by the user
//***************************************************************************
LPWSTR CLDAPHelper :: CreateADSIPath(LPCWSTR lpszLDAPSchemaObjectName,	
									 LPCWSTR lpszSchemaContainerSuffix)
{
	LPWSTR lpszADSIObjectPath = new WCHAR[wcslen(LDAP_CN_EQUALS) + wcslen(lpszLDAPSchemaObjectName) + wcslen(COMMA_STR) + wcslen(lpszSchemaContainerSuffix) + 1];
	wcscpy(lpszADSIObjectPath, LDAP_CN_EQUALS);
	wcscat(lpszADSIObjectPath, lpszLDAPSchemaObjectName);
	wcscat(lpszADSIObjectPath, COMMA_STR);
	wcscat(lpszADSIObjectPath, lpszSchemaContainerSuffix);

	return lpszADSIObjectPath;

}

//***************************************************************************
//
// CLDAPHelper :: UnmangleWBEMNameToLDAP
//
// Purpose : Converts a mangled WBEM name to LDAP
//	An underscore in LDAP maps to two underscores in WBEM
//	An hyphen in LDAP maps to one underscore in WBEM
//
// Parameters:
//	lpszWBEMName : The WBEM class or property name
// 
//	Return Value: The LDAP name to the class or property object. This has to
//	be deallocated by the user
//***************************************************************************
LPWSTR CLDAPHelper :: UnmangleWBEMNameToLDAP(LPCWSTR lpszWBEMName)
{
	DWORD iPrefixLength = 0;
	if(_wcsnicmp(lpszWBEMName, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX_LENGTH) == 0)
	{
		iPrefixLength = LDAP_ARTIFICIAL_CLASS_NAME_PREFIX_LENGTH;
	}
	else if (_wcsnicmp(lpszWBEMName, LDAP_CLASS_NAME_PREFIX, LDAP_CLASS_NAME_PREFIX_LENGTH) == 0)
	{
		iPrefixLength = LDAP_CLASS_NAME_PREFIX_LENGTH;
	}
	else
		return NULL;

	// The length of the resulting string (LDAP Name) is bound to be less than of equal to the length of WBEM name
	// So let's allocate the same as the wbem name length
	DWORD dwWbemNameLength = wcslen(lpszWBEMName) - iPrefixLength;
	LPWSTR lpszLDAPName = new WCHAR[dwWbemNameLength + 1];
	LPCWSTR lpszWBEMNameWithoutPrefix = lpszWBEMName + iPrefixLength;

	DWORD j=0;
	for(DWORD i=0; i<dwWbemNameLength; )
	{
		switch(lpszWBEMNameWithoutPrefix[i])
		{
			case (L'_'):
				if(lpszWBEMNameWithoutPrefix[i+1] == L'_')
				{
					i += 2;
					lpszLDAPName[j++] = L'_';
				}
				else
				{
					i++;
					lpszLDAPName[j++] = L'-';
				}
				break;

			default:
				lpszLDAPName[j++] = lpszWBEMNameWithoutPrefix[i++];

		}
	}
	lpszLDAPName[j] = NULL;
	return lpszLDAPName;
}

//***************************************************************************
//
// CLDAPHelper :: MangleLDAPNameToWBEM
//
// Purpose : Converts a LDAP name to WBEM by mangling it
//	An underscore in LDAP maps to two underscores in WBEM
//	An hyphen in LDAP maps to one underscore in WBEM
//
// Parameters:
//	lpszLDAPName : The LDAP class or property name
// 
//	Return Value: The LDAP name to the class or property object. This has to
//	be deallocated by the user
//***************************************************************************
LPWSTR CLDAPHelper :: MangleLDAPNameToWBEM(LPCWSTR lpszLDAPName, BOOLEAN bArtificalName)
{
	if(!lpszLDAPName)
		return NULL;

	// The length of the resulting string (WBEM Name) is bound to be less than of equal to twice the length of LDAP name
	// So let's allocate double the LDAP name length
	DWORD dwLDAPNameLength = wcslen(lpszLDAPName);
	DWORD dwPrefixLength = (bArtificalName)? LDAP_ARTIFICIAL_CLASS_NAME_PREFIX_LENGTH : LDAP_CLASS_NAME_PREFIX_LENGTH;
	LPWSTR lpszWBEMName = new WCHAR[2*dwLDAPNameLength + dwPrefixLength + 1];

	// Prefix "DS_" or "ADS_"
	if(bArtificalName)
		wcscpy(lpszWBEMName, LDAP_ARTIFICIAL_CLASS_NAME_PREFIX);
	else
		wcscpy(lpszWBEMName, LDAP_CLASS_NAME_PREFIX);

	DWORD j=dwPrefixLength;

	for(DWORD i=0; i<dwLDAPNameLength; i++)
	{
		switch(lpszLDAPName[i])
		{
			case (__TEXT('-')):
				lpszWBEMName[j++] = L'_';
				break;

			case (__TEXT('_')):
				lpszWBEMName[j++] = L'_';
				lpszWBEMName[j++] = L'_';
				break;

			default:
				lpszWBEMName[j++] = lpszLDAPName[i];

		}
	}
	lpszWBEMName[j] = NULL;
	return lpszWBEMName;
}

void CLDAPHelper :: DeleteAttributeContents(PADS_ATTR_INFO pAttribute)
{
	// delete the name
	delete [] pAttribute->pszAttrName;

	// Delete each value
	for(DWORD i=0; i<pAttribute->dwNumValues; i++)
		DeleteADsValueContents(pAttribute->pADsValues + i);

	// Delete the array of values
	delete [] pAttribute->pADsValues;
}

void CLDAPHelper :: DeleteADsValueContents(PADSVALUE pValue)
{
	switch(pValue->dwType)
	{
		// Nothing to delete
		case ADSTYPE_BOOLEAN:
		case ADSTYPE_INTEGER:
		case ADSTYPE_LARGE_INTEGER:
			break;
		
		case ADSTYPE_UTC_TIME:
		case ADSTYPE_DN_STRING:
		case ADSTYPE_CASE_EXACT_STRING:
		case ADSTYPE_CASE_IGNORE_STRING:
		case ADSTYPE_PRINTABLE_STRING:
		case ADSTYPE_NUMERIC_STRING:
			delete [] pValue->DNString;
			break;
		
		case ADSTYPE_OCTET_STRING:
		case ADSTYPE_NT_SECURITY_DESCRIPTOR:
			delete [] (pValue->OctetString.lpValue);
			break;
		case ADSTYPE_DN_WITH_BINARY:
			delete [] (pValue->pDNWithBinary->lpBinaryValue);
			delete [] (pValue->pDNWithBinary->pszDNString);
			delete pValue->pDNWithBinary;
			break;

		case ADSTYPE_DN_WITH_STRING:
			delete [] (pValue->pDNWithString->pszStringValue);
			delete [] (pValue->pDNWithString->pszDNString);
			delete pValue->pDNWithString;
			break;

		default:
		// Cause a Null Pointer violation intentionally
		// Otherwise we leak memory
		{
			assert(0);
		}
		break;
	}
}

//***************************************************************************
//
// CLDAPHelper :: ExecuteQuery
//
// Purpose : See Header
//***************************************************************************
HRESULT CLDAPHelper :: ExecuteQuery(
	LPCWSTR pszPathToRoot,
	PADS_SEARCHPREF_INFO pSearchInfo,
	DWORD dwSearchInfoCount,
	LPCWSTR pszLDAPQuery,
	CADSIInstance ***pppADSIInstances,
	DWORD *pdwNumRows,
	ProvDebugLog *pLogObject)
{
	// Initialize the return values
	HRESULT result = E_FAIL;
	*pdwNumRows = 0;
	*pppADSIInstances = NULL;

	// Bind to the node from which the search should start
	IDirectorySearch *pDirectorySearchContainer = NULL;
	if(SUCCEEDED(result = ADsOpenObject((LPWSTR)pszPathToRoot, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectorySearch, (LPVOID *)&pDirectorySearchContainer)))
	{
		// Now perform a search for the attribute DISTINGUISHED_NAME_ATTR name
		if(SUCCEEDED(result = pDirectorySearchContainer->SetSearchPreference(pSearchInfo, dwSearchInfoCount)))
		{
			ADS_SEARCH_HANDLE hADSSearchOuter;

			if(SUCCEEDED(result = pDirectorySearchContainer->ExecuteSearch((LPWSTR) pszLDAPQuery, (LPWSTR *)&ADS_PATH_ATTR, 1, &hADSSearchOuter)))
			{
				*pdwNumRows = 0;
				// Calculate the number of rows first. 
				while(SUCCEEDED(result = pDirectorySearchContainer->GetNextRow(hADSSearchOuter)) &&
					result != S_ADS_NOMORE_ROWS)
					(*pdwNumRows) ++;

				// Do only if there were any rows
				if(*pdwNumRows)
				{
					// The index of the attribute being processed
					DWORD i = 0;

					// Allocate enough memory for the classes and names
					*pppADSIInstances = new CADSIInstance * [*pdwNumRows];

					// Get the columns for the attributes
					ADS_SEARCH_COLUMN adsColumn;
					CADSIInstance *pADSIInstance = NULL;

					// Move to the first row
					if (SUCCEEDED(result = pDirectorySearchContainer->GetFirstRow(hADSSearchOuter))&&
							result != S_ADS_NOMORE_ROWS)
					{
						// Store each of the LDAP class attributes 
						if(SUCCEEDED(pDirectorySearchContainer->GetColumn(hADSSearchOuter, (LPWSTR)ADS_PATH_ATTR, &adsColumn)))
						{
							if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
								result = E_FAIL;
							else
							{
								// Create the CADSIInstance
								// Now get the attributes on this object

								if(SUCCEEDED(result = GetADSIInstance(adsColumn.pADsValues->DNString, &pADSIInstance, pLogObject)))
								{
									(*pppADSIInstances)[i] = pADSIInstance;
									i++;
								}
								else
									pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery GetADSIInstance() FAILED on %s with %x\r\n", adsColumn.pADsValues->DNString, result);
							}

							// Free resouces
							pDirectorySearchContainer->FreeColumn( &adsColumn );
						}
						else
							pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery GetColumn() FAILED on %s with %x\r\n", pszLDAPQuery, result);

						// Get the other rows now
						if(SUCCEEDED(result))
						{
							while(SUCCEEDED(result = pDirectorySearchContainer->GetNextRow(hADSSearchOuter))&&
									result != S_ADS_NOMORE_ROWS)
							{

								// Store each of the LDAP class attributes 
								if(SUCCEEDED(pDirectorySearchContainer->GetColumn(hADSSearchOuter, (LPWSTR)ADS_PATH_ATTR, &adsColumn)))
								{
									if(adsColumn.dwADsType == ADSTYPE_PROV_SPECIFIC)
										result = E_FAIL;
									else
									{
										// Create the CADSIInstance
										// Now get the attributes on this object
										if(SUCCEEDED(result = GetADSIInstance(adsColumn.pADsValues->DNString, &pADSIInstance, pLogObject)))
										{
											(*pppADSIInstances)[i] = pADSIInstance;
											i++;
										}
										else
											pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery GetADSIInstance() FAILED on %s with %x\r\n", adsColumn.pADsValues->DNString, result);
									}
									// Free resouces
									pDirectorySearchContainer->FreeColumn( &adsColumn );
								}
								else
									pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery GetColumn() FAILED on %s with %x\r\n", pszLDAPQuery, result);
							}
						}
					}
					else
						pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery GetFirstRow() FAILED on %s with %x\r\n", pszLDAPQuery, result);


					// Something went wrong? Release allocated resources
					if(i != *pdwNumRows)
					{
						pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery() Difference between Number of rows in 2 searches %d %d on %s Am invalidating the search as FAILED\r\n", i, *pdwNumRows, pszLDAPQuery);
						
						// Delete the contents of the array
						for(DWORD j=0; j<i; j++)
							delete (*pppADSIInstances)[j];

						// Delete the array itself
						delete [] (*pppADSIInstances);

						// Set return values to empty
						*pppADSIInstances = NULL;
						*pdwNumRows = 0;

						result = E_FAIL;

					}
				}

				// Close the search. 
				pDirectorySearchContainer->CloseSearchHandle(hADSSearchOuter);
			} // ExecuteSearch() 
			else
				pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery ExecuteSearch() %s FAILED with %x\r\n", pszLDAPQuery, result);
		} // SetSearchPreference()
		else
			pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery SetSearchPreference() on %s FAILED with %x \r\n", pszPathToRoot, result);
		pDirectorySearchContainer->Release();
	} // ADsOpenObject
	else
		pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery ADsOpenObject() on %s FAILED with %x \r\n", pszPathToRoot, result);

	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\common\main.cpp ===
//



// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

//

//***************************************************************************

//

//  MAIND.CPP

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains the global EXE functions

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************


#include <tchar.h>
#include <stdio.h>

#include <windows.h>
#include <objbase.h>
#include <olectl.h>

/* WBEM includes */
#include <wbemcli.h>
#include <wbemprov.h>
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include <sqllex.h>
#include <sql_1.h>

/* ADSI includes */
#include <activeds.h>

/* DS Provider includes */
#include "provlog.h"
#include "maindll.h"
#include "clsname.h"
#include <initguid.h>
#include "dscpguid.h"
#include "dsipguid.h"
#include "refcount.h"
#include "adsiprop.h"
#include "adsiclas.h"
#include "adsiinst.h"
#include "provlog.h"
#include "provexpt.h"
#include "tree.h"
#include "ldapcach.h"
#include "wbemcach.h"
#include "classpro.h"
#include "ldapprov.h"
#include "clsproi.h"
#include "ldapproi.h"
#include "classfac.h"
#include "instprov.h"
#include "instproi.h"
#include "instfac.h"

// Count of locks
long g_lComponents = 0;
// Count of active locks
long g_lServerLocks = 0;

// A critical section to create/delete statics 
CRITICAL_SECTION g_StaticsCreationDeletion;

ProvDebugLog *g_pLogObject = NULL;
BOOL s_Exiting = FALSE ;

typedef HRESULT (WINAPI* PFNCOINITIALIZEEX)(void* pvReserved,  //Reserved  
                                            DWORD dwCoInit      //COINIT value
                                            );

typedef HRESULT (WINAPI* PFNCOINITIALIZESECURITY)(
								PSECURITY_DESCRIPTOR         pSecDesc,
								LONG                         cAuthSvc,
								SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
								void                        *pReserved1,
								DWORD                        dwAuthnLevel,
								DWORD                        dwImpLevel,
								void                        *pReserved2,
								DWORD                        dwCapabilities,
								void                        *pReserved3 );

HRESULT COMInit();
STDAPI ExeRegisterServer(void);
STDAPI ExeUnregisterServer(void);


BOOL StartupProvider (DWORD *pdwClassFac)
{
	// Initialize the critical section to access the static initializer objects
	InitializeCriticalSection(&g_StaticsCreationDeletion);

	// Initialize the static Initializer objects. These are destroyed in DllCanUnloadNow
	CDSClassProviderClassFactory :: s_pDSClassProviderInitializer = NULL;
	CDSClassProviderClassFactory ::s_pLDAPClassProviderInitializer = NULL;
	CDSInstanceProviderClassFactory :: s_pDSInstanceProviderInitializer = NULL;
	CDSClassProviderClassFactory *lpunk1 = new CDSClassProviderClassFactory;
	CDSInstanceProviderClassFactory *lpunk2 = new CDSInstanceProviderClassFactory;
	CDSClassAssociationsProviderClassFactory *lpunk3 = new CDSClassAssociationsProviderClassFactory;
	lpunk1->AddRef();
	lpunk2->AddRef();
	lpunk3->AddRef();

	HRESULT hr = CoRegisterClassObject(
						  CLSID_DSProvider,			//Class identifier (CLSID) to be registered
						  (IUnknown *) lpunk1,						//Pointer to the class object
						  CLSCTX_LOCAL_SERVER|CLSCTX_INPROC_SERVER,	//Context for running executable code
						  REGCLS_MULTIPLEUSE,						//How to connect to the class object
						  &pdwClassFac[0]							//Pointer to the value returned
						  );

	if(SUCCEEDED(hr))
	{
		hr = CoRegisterClassObject(
						  CLSID_DSInstanceProvider,			//Class identifier (CLSID) to be registered
						  (IUnknown *) lpunk2,						//Pointer to the class object
						  CLSCTX_LOCAL_SERVER|CLSCTX_INPROC_SERVER,	//Context for running executable code
						  REGCLS_MULTIPLEUSE,						//How to connect to the class object
						  &pdwClassFac[1]							//Pointer to the value returned
						  );
	}

	if(SUCCEEDED(hr))
	{
		hr = CoRegisterClassObject(
						  CLSID_DSClassAssocProvider,			//Class identifier (CLSID) to be registered
						  (IUnknown *) lpunk3,						//Pointer to the class object
						  CLSCTX_LOCAL_SERVER|CLSCTX_INPROC_SERVER,	//Context for running executable code
						  REGCLS_MULTIPLEUSE,						//How to connect to the class object
						  &pdwClassFac[3]							//Pointer to the value returned
						  );
	}

	return (SUCCEEDED(hr));
}

void ShutdownProvider(DWORD *pdwClassFac)
{
	// Delete the Initializer objects
	EnterCriticalSection(&g_StaticsCreationDeletion);
	if(g_pLogObject)
		g_pLogObject->WriteW(L"DllCanUnloadNow called\r\n");
	delete CDSClassProviderClassFactory::s_pDSClassProviderInitializer;
	delete CDSClassProviderClassFactory::s_pLDAPClassProviderInitializer;
	delete CDSInstanceProviderClassFactory::s_pDSInstanceProviderInitializer;
	delete g_pLogObject;
	CDSClassProviderClassFactory::s_pDSClassProviderInitializer = NULL;
	CDSClassProviderClassFactory::s_pLDAPClassProviderInitializer = NULL;
	CDSInstanceProviderClassFactory::s_pDSInstanceProviderInitializer = NULL;
	g_pLogObject = NULL;
	LeaveCriticalSection(&g_StaticsCreationDeletion);


	CoRevokeClassObject(pdwClassFac[0]);
	CoRevokeClassObject(pdwClassFac[1]);
	CoRevokeClassObject(pdwClassFac[2]);
	DeleteCriticalSection(&g_StaticsCreationDeletion);
}

BOOL ParseCommandLine () 
{
	BOOL t_Exit = FALSE ;

	LPTSTR t_CommandLine = GetCommandLine () ;
	if ( t_CommandLine )
	{
		TCHAR *t_Arg = NULL ;
		TCHAR *t_ApplicationArg = NULL ;
		t_ApplicationArg = _tcstok ( t_CommandLine , _TEXT ( " \t" ) ) ;
		t_Arg = _tcstok ( NULL , _TEXT ( " \t" ) ) ;

		if ( t_Arg ) 
		{
			if ( _tcsicmp ( t_Arg , _TEXT ( "/RegServer" ) ) == 0 )
			{
				t_Exit = TRUE ;
			    ExeRegisterServer();
			}
			else if ( _tcsicmp ( t_Arg , _TEXT ( "/UnRegServer" ) ) == 0 )
			{
				t_Exit = TRUE ;
			    ExeUnregisterServer();
			}
            else if(_tcsicmp(t_Arg, _TEXT ( "/EMBEDDING" ) ) == 0)
		    {
			    // COM called us, so this is the real thing...
                t_Exit = FALSE;
		    }
		}
	}

	return t_Exit ;
}

LONG CALLBACK WindowsMainProc ( HWND a_hWnd , UINT a_message , WPARAM a_wParam , LPARAM a_lParam )
{
	long t_rc = 0 ;

	switch ( a_message )
	{
        case WM_CLOSE:
        {
            s_Exiting = TRUE ;
        }
        break ;

		case WM_DESTROY:
		{
			PostMessage ( a_hWnd , WM_QUIT , 0 , 0 ) ;
		}
		break ;

		default:
		{		
			t_rc = DefWindowProc ( a_hWnd , a_message , a_wParam , a_lParam ) ;
		}
		break ;
	}

	return ( t_rc ) ;
}

HWND WindowsInit ( HINSTANCE a_HInstance )
{
	static wchar_t *t_TemplateCode = L"DS Provider" ;

	WNDCLASS  t_wc ;
 
	t_wc.style            = CS_HREDRAW | CS_VREDRAW ;
	t_wc.lpfnWndProc      = WindowsMainProc ;
	t_wc.cbClsExtra       = 0 ;
	t_wc.cbWndExtra       = 0 ;
	t_wc.hInstance        = a_HInstance ;
	t_wc.hIcon            = LoadIcon(NULL, IDI_HAND) ;
	t_wc.hCursor          = LoadCursor(NULL, IDC_ARROW) ;
	t_wc.hbrBackground    = (HBRUSH) (COLOR_WINDOW + 1) ;
	t_wc.lpszMenuName     = NULL ;
	t_wc.lpszClassName    = t_TemplateCode ;
 
	ATOM t_winClass = RegisterClass ( &t_wc ) ;

	HWND t_HWnd = CreateWindow (

		t_TemplateCode ,              // see RegisterClass() call
		t_TemplateCode ,                      // text for window title bar
		WS_OVERLAPPEDWINDOW ,               // window style
		CW_USEDEFAULT ,                     // default horizontal position
		CW_USEDEFAULT ,                     // default vertical position
		CW_USEDEFAULT ,                     // default width
		CW_USEDEFAULT ,                     // default height
		NULL ,                              // overlapped windows have no parent
		NULL ,                              // use the window class menu
		a_HInstance ,
		NULL                                // pointer not needed
	) ;

	if (t_HWnd)
	{
		ShowWindow ( t_HWnd, SW_SHOW ) ;
	}

	return t_HWnd ;
}

void WindowsStop ( HWND a_HWnd )
{
	DestroyWindow ( a_HWnd ) ;
}

HWND WindowsStart ( HINSTANCE a_Handle )
{
	HWND t_HWnd = WindowsInit(a_Handle);

	return t_HWnd;
}

void WindowsDispatch ()
{
	BOOL t_GetMessage ;
	MSG t_lpMsg ;

	while (	( t_GetMessage = GetMessage ( & t_lpMsg , NULL , 0 , 0 ) ) == TRUE )
	{
		TranslateMessage ( & t_lpMsg ) ;
		DispatchMessage ( & t_lpMsg ) ;

        if ( s_Exiting ) 
            return ;
	}
}


int WINAPI WinMain (
  
    HINSTANCE hInstance,		// handle to current instance
    HINSTANCE hPrevInstance,	// handle to previous instance
    LPSTR lpCmdLine,			// pointer to command line
    int nShowCmd 				// show state of window
)
{
    // Initialize the COM Library.
	HRESULT hr = COMInit();

	BOOL t_Exit = ParseCommandLine();

	if (!t_Exit) 
	{
		HWND hWnd = WindowsStart(hInstance);

		if (hWnd)
		{
			DWORD dwArray[] = {0, 0, 0};

			if (StartupProvider(dwArray))
			{
				WindowsDispatch();
				ShutdownProvider(dwArray);
			}

			WindowsStop(hWnd);
		}
	}

	// Uninitialize the COM Library.
	::CoUninitialize() ;

	return 0 ;
}


////////////////////////////////////////////////////////////////////
// Strings used during self registration
////////////////////////////////////////////////////////////////////
LPCTSTR THREADING_MODEL_STR		= __TEXT("ThreadingModel");
LPCTSTR APARTMENT_STR			= __TEXT("Both");

LPCTSTR CLSID_STR				= __TEXT("CLSID\\");

// DS Class Provider
LPCTSTR DSPROVIDER_NAME_STR		= __TEXT("Microsoft NT DS Class Provider for WBEM");

// DS Class Associations provider
LPCTSTR DS_ASSOC_PROVIDER_NAME_STR		= __TEXT("Microsoft NT DS Class Associations Provider for WBEM");

// DS Instance provider
LPCTSTR DS_INSTANCE_PROVIDER_NAME_STR		= __TEXT("Microsoft NT DS Instance Provider for WBEM");

#define REG_FORMAT2_STR			_T("%s%s")
#define REG_FORMAT3_STR			_T("%s%s\\%s")
#define VER_IND_STR				_T("VersionIndependentProgID")
#define NOT_INTERT_STR			_T("NotInsertable")
#define LOCALSRV32_STR			_T("LocalServer32")
#define PROGID_STR				_T("ProgID")
#define THREADING_MODULE_STR	_T("ThreadingModel")
#define APARTMENT_STR			_T("Both")

#define CLSID_STR				_T("CLSID\\")


/***************************************************************************
 * SetKeyAndValue
 *
 * Purpose:
 *  Private helper function for DllRegisterServer that creates
 *  a key, sets a value, and closes that key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the ame of the key
 *  pszSubkey       LPTSTR ro the name of a subkey
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue(LPCTSTR pszKey, LPCTSTR pszSubkey, LPCTSTR pszValueName, LPCTSTR pszValue)
{
    HKEY        hKey;
    TCHAR       szKey[256];

    _tcscpy(szKey, pszKey);

	// If a sub key is mentioned, use it.
    if (NULL != pszSubkey)
    {
		_tcscat(szKey, __TEXT("\\"));
        _tcscat(szKey, pszSubkey);
    }

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
		szKey, 0, NULL, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

    if (NULL != pszValue)
    {
        if (ERROR_SUCCESS != RegSetValueEx(hKey, pszValueName, 0, REG_SZ, (BYTE *)pszValue,
			(_tcslen(pszValue)+1)*sizeof(TCHAR)))
			return FALSE;
    }
    RegCloseKey(hKey);
    return TRUE;
}

BOOL DeleteKey(LPCTSTR pszKey, LPCTSTR pszSubkey)
{
    HKEY        hKey;

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
		pszKey, 0, NULL, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

	if(ERROR_SUCCESS != RegDeleteKey(hKey, pszSubkey))
		return FALSE;

    RegCloseKey(hKey);
    return TRUE;
}


//***************************************************************************
//
// ExeRegisterServer
//
// Purpose: Called when /register is specified on the command line.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI ExeRegisterServer(void)
{   

	TCHAR szModule[MAX_PATH + 1];
	HINSTANCE hInst = GetModuleHandle(_T("DSPROV"));
	GetModuleFileName(hInst,(TCHAR*)szModule, MAX_PATH + 1);

	TCHAR szDSProviderClassID[128];
	TCHAR szDSProviderCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_DSProvider, szDSProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszDSProviderClassID[128];
	if(StringFromGUID2(CLSID_DSProvider, wszDSProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszDSProviderClassID, -1, szDSProviderCLSIDClassID, 128, NULL, NULL);

#endif

	_tcscpy(szDSProviderCLSIDClassID, CLSID_STR);
	_tcscat(szDSProviderCLSIDClassID, szDSProviderClassID);

	//
	// Create entries under CLSID for DS Class Provider
	//
	if (FALSE == SetKeyAndValue(szDSProviderCLSIDClassID, NULL, NULL, DSPROVIDER_NAME_STR))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szDSProviderCLSIDClassID, LOCALSRV32_STR, NULL, szModule))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szDSProviderCLSIDClassID, LOCALSRV32_STR, THREADING_MODEL_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;


	TCHAR szDSClassAssocProviderClassID[128];
	TCHAR szDSClassAssocProviderCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_DSClassAssocProvider, szDSClassAssocProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszDSClassAssocProviderClassID[128];
	if(StringFromGUID2(CLSID_DSClassAssocProvider, wszDSClassAssocProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszDSClassAssocProviderClassID, -1, szDSClassAssocProviderCLSIDClassID, 128, NULL, NULL);

#endif

	_tcscpy(szDSClassAssocProviderCLSIDClassID, CLSID_STR);
	_tcscat(szDSClassAssocProviderCLSIDClassID, szDSClassAssocProviderClassID);

	//
	// Create entries under CLSID for DS Class Associations Provider
	//
	if (FALSE == SetKeyAndValue(szDSClassAssocProviderCLSIDClassID, NULL, NULL, DS_ASSOC_PROVIDER_NAME_STR))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szDSClassAssocProviderCLSIDClassID, LOCALSRV32_STR, NULL, szModule))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szDSClassAssocProviderCLSIDClassID, LOCALSRV32_STR, THREADING_MODEL_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;




	TCHAR szDSInstanceProviderClassID[128];
	TCHAR szDSInstanceProviderCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_DSInstanceProvider, szDSInstanceProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszDSInstanceProviderClassID[128];
	if(StringFromGUID2(CLSID_DSInstanceProvider, wszDSInstanceProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszDSInstanceProviderClassID, -1, szDSInstanceProviderCLSIDClassID, 128, NULL, NULL);

#endif


	_tcscpy(szDSInstanceProviderCLSIDClassID, CLSID_STR);
	_tcscat(szDSInstanceProviderCLSIDClassID, szDSInstanceProviderClassID);

	//
	// Create entries under CLSID for DS Instance Provider
	//
	if (FALSE == SetKeyAndValue(szDSInstanceProviderCLSIDClassID, NULL, NULL, DS_INSTANCE_PROVIDER_NAME_STR))
		return SELFREG_E_CLASS;

	if (FALSE == SetKeyAndValue(szDSInstanceProviderCLSIDClassID, LOCALSRV32_STR, NULL, szModule))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szDSInstanceProviderCLSIDClassID, LOCALSRV32_STR, THREADING_MODEL_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;

	return S_OK;
}

//***************************************************************************
//
// ExeUnregisterServer
//
// Purpose: Called when /unregister is specified on the command line.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI ExeUnregisterServer(void)
{
	TCHAR szModule[MAX_PATH + 1];
	HINSTANCE hInst = GetModuleHandle(_T("DSPROV"));
	GetModuleFileName(hInst,(TCHAR*)szModule, MAX_PATH + 1);


	TCHAR szDSProviderClassID[128];
	TCHAR szDSProviderCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_DSProvider, szDSProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszDSProviderClassID[128];
	if(StringFromGUID2(CLSID_DSProvider, wszDSProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszDSProviderClassID, -1, szDSProviderCLSIDClassID, 128, NULL, NULL);

#endif

	_tcscpy(szDSProviderCLSIDClassID, CLSID_STR);
	_tcscat(szDSProviderCLSIDClassID, szDSProviderClassID);

	//
	// Delete the keys for DS Class Provider in the reverse order of creation in DllRegisterServer()
	//
	if(FALSE == DeleteKey(szDSProviderCLSIDClassID, LOCALSRV32_STR))
		return SELFREG_E_CLASS;
	if(FALSE == DeleteKey(CLSID_STR, szDSProviderClassID))
		return SELFREG_E_CLASS;

	TCHAR szDSClassAssocProviderClassID[128];
	TCHAR szDSClassAssocProviderCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_DSClassAssocProvider, szDSClassAssocProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszDSClassAssocProviderClassID[128];
	if(StringFromGUID2(CLSID_DSClassAssocProvider, wszDSClassAssocProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszDSClassAssocProviderClassID, -1, szDSClassAssocProviderCLSIDClassID, 128, NULL, NULL);

#endif

	_tcscpy(szDSClassAssocProviderCLSIDClassID, CLSID_STR);
	_tcscat(szDSClassAssocProviderCLSIDClassID, szDSClassAssocProviderClassID);

	//
	// Delete the keys for DS Class Provider in the reverse order of creation in DllRegisterServer()
	//
	if(FALSE == DeleteKey(szDSClassAssocProviderCLSIDClassID, LOCALSRV32_STR))
		return SELFREG_E_CLASS;
	if(FALSE == DeleteKey(CLSID_STR, szDSClassAssocProviderClassID))
		return SELFREG_E_CLASS;

	TCHAR szDSInstanceProviderClassID[128];
	TCHAR szDSInstanceProviderCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_DSInstanceProvider, szDSInstanceProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszDSInstanceProviderClassID[128];
	if(StringFromGUID2(CLSID_DSInstanceProvider, wszDSInstanceProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszDSInstanceProviderClassID, -1, szDSInstanceProviderCLSIDClassID, 128, NULL, NULL);

#endif

	_tcscpy(szDSInstanceProviderCLSIDClassID, CLSID_STR);
	_tcscat(szDSInstanceProviderCLSIDClassID, szDSInstanceProviderClassID);

	//
	// Delete the keys in the reverse order of creation in DllRegisterServer()
	//
	if(FALSE == DeleteKey(szDSInstanceProviderCLSIDClassID, LOCALSRV32_STR))
		return SELFREG_E_CLASS;
	if(FALSE == DeleteKey(CLSID_STR, szDSInstanceProviderClassID))
		return SELFREG_E_CLASS;
	return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
HRESULT COMInit()
{
    HRESULT hr;
    PFNCOINITIALIZESECURITY pfnCoInitializeSecurity = NULL;
    PFNCOINITIALIZEEX pfnCoInitializeEx = NULL;

   	
    //Get handle to COM library 
    HMODULE ghOle32 = LoadLibraryEx(_T("ole32.dll"), NULL, 0);

    if(ghOle32 != NULL) 
    {                                            
	    //Get ptr to functions CoInitialize and CoInitializeSecurity.
        pfnCoInitializeEx = (PFNCOINITIALIZEEX) GetProcAddress(ghOle32, 
                                                   "CoInitializeEx");
        pfnCoInitializeSecurity = (PFNCOINITIALIZESECURITY) GetProcAddress(ghOle32, 
                                             "CoInitializeSecurity");

        //Initialize COM
	    if (pfnCoInitializeEx) 
	    {
	        hr = pfnCoInitializeEx(NULL, COINIT_MULTITHREADED);
        }
	    else 
	    {
            hr = CoInitialize(NULL);
	    }

	    if(FAILED(hr))
	    {
		    FreeLibrary(ghOle32);
            ghOle32 = NULL;
            return E_FAIL;
	    }
	  
	    //Initialize Security
	    if (pfnCoInitializeSecurity)
	    {
		    hr = pfnCoInitializeSecurity(NULL, -1, NULL, NULL, 
		      							   RPC_C_AUTHN_LEVEL_NONE, 
			       						   RPC_C_IMP_LEVEL_IMPERSONATE, 
     				   					   NULL, EOAC_NONE, 0);
        }
	
	    if(FAILED(hr))
	    {
	        CoUninitialize();
	        FreeLibrary(ghOle32);
            ghOle32 = NULL;
	        return E_FAIL;
	    }

    }
    else
    {
	    return E_FAIL;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\common\include\adsiinst.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:adsiinst.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the CADSIInstance which encapsulates an ADSI instance
//
//***************************************************************************

#ifndef ADSI_INSTANCE_H
#define ADSI_INSTANCE_H


class CADSIInstance : public CRefCountedObject
{

public:
	//***************************************************************************
	//
	// CADSIInstance::CADSIInstance
	//
	// Purpose : Constructor 
	//
	// Parameters:
	//  lpszADSIPath : The ADSI Path to the object
	//***************************************************************************
	CADSIInstance(LPCWSTR lpszADSIPath, IDirectoryObject *pObject);
	virtual ~CADSIInstance();

	//***************************************************************************
	//
	// CADSIInstance::GetDirectoryObject
	//
	// Purpose : Returns the IDirectoryObject interface on the Directory object 
	// It is the responsibility of the caller to Release() it when done.
	//
	//***************************************************************************
	IDirectoryObject *GetDirectoryObject();

	//***************************************************************************
	//
	// CADSIInstance :: GetADSIClassName
	// 
	// Purpose : Returns the class name of this instance
	//***************************************************************************
	LPCWSTR GetADSIClassName();

	PADS_ATTR_INFO GetAttributes(DWORD *pdwNumAttributes);
	void SetAttributes(PADS_ATTR_INFO pAttributes, DWORD dwNumAttributes);

	PADS_OBJECT_INFO GetObjectInfo();
	void SetObjectInfo(PADS_OBJECT_INFO pObjectInfo);

protected:
	// The Attribute list
	PADS_ATTR_INFO m_pAttributes;
	DWORD m_dwNumAttributes;

	// The object info
	PADS_OBJECT_INFO m_pObjectInfo;

	// The IDirectoryObject pointer
	IDirectoryObject *m_pDirectoryObject;
};

#endif /* ADSI_INSTANCE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\common\refcount.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:refcount.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the imlementation for a basic reference counted object
//
//***************************************************************************
#include <tchar.h>
#include <windows.h>

#include "refcount.h"

CRefCountedObject::CRefCountedObject()
{
	m_dwRefCount = 1;
	// Initialize the critical section 
	InitializeCriticalSection(&m_ReferenceCountSection);

	m_lpszName = NULL;
	FILETIME fileTime;
	GetSystemTimeAsFileTime(&fileTime);
	LARGE_INTEGER creationTime;
	memcpy((LPVOID)&creationTime, (LPVOID)&fileTime, sizeof LARGE_INTEGER);
	m_CreationTime = creationTime.QuadPart;
	m_LastAccessTime = creationTime.QuadPart;
}

CRefCountedObject::CRefCountedObject(LPCWSTR lpszName)
{
	m_dwRefCount = 1;
	// Initialize the critical section 
	InitializeCriticalSection(&m_ReferenceCountSection);

	if(lpszName)
	{
		m_lpszName = new WCHAR[wcslen(lpszName) + 1];
		wcscpy(m_lpszName, lpszName);
	}
	else
		m_lpszName = NULL;

	FILETIME fileTime;
	GetSystemTimeAsFileTime(&fileTime);
	LARGE_INTEGER creationTime;
	memcpy((LPVOID)&creationTime, (LPVOID)&fileTime, sizeof LARGE_INTEGER);
	m_CreationTime = creationTime.QuadPart;
}

CRefCountedObject::~CRefCountedObject()
{
	delete[] m_lpszName;

	// Destroy the critical section
	DeleteCriticalSection(&m_ReferenceCountSection);
}


void CRefCountedObject::AddRef()
{
	EnterCriticalSection(&m_ReferenceCountSection);
	m_dwRefCount ++;
	LeaveCriticalSection(&m_ReferenceCountSection);
}

void CRefCountedObject::Release()
{
	EnterCriticalSection(&m_ReferenceCountSection);
	DWORD dwCount = --m_dwRefCount;
	LeaveCriticalSection(&m_ReferenceCountSection);

	if( dwCount == 0)
		delete this;
}

LPCWSTR CRefCountedObject::GetName()
{
	return m_lpszName;
}

void CRefCountedObject::SetName(LPCWSTR lpszName)
{
	delete[] m_lpszName;
	if(lpszName)
	{
		m_lpszName = new WCHAR[wcslen(lpszName) + 1];
		wcscpy(m_lpszName, lpszName);
	}
	else
		m_lpszName = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\common\include\attributes.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef ATTRIBUTES_H
#define ATTRIBUTES_H

// The Key used in the registry for logging
static LPCTSTR DSPROVIDER = __TEXT("DSProvider");

// Names of the LDAP class attributes
static LPCWSTR ADS_PATH_ATTR				= L"ADsPath";
static LPCWSTR LDAP_DISPLAY_NAME_ATTR		= L"ldapDisplayName";
static LPCWSTR COMMON_NAME_ATTR				= L"cn";
static LPCWSTR GOVERNS_ID_ATTR				= L"governsID";
static LPCWSTR SUB_CLASS_OF_ATTR			= L"subClassOf";
static LPCWSTR SCHEMA_ID_GUID_ATTR			= L"schemaIDGUID";
static LPCWSTR MAPI_DISPLAY_TYPE_ATTR		= L"mAPIDisplayType";
static LPCWSTR RDN_ATT_ID_ATTR				= L"rDNAttID";
static LPCWSTR SYSTEM_MUST_CONTAIN_ATTR		= L"systemMustContain";
static LPCWSTR MUST_CONTAIN_ATTR			= L"mustContain";
static LPCWSTR SYSTEM_MAY_CONTAIN_ATTR		= L"systemMayContain";
static LPCWSTR MAY_CONTAIN_ATTR				= L"mayContain";
static LPCWSTR SYSTEM_POSS_SUPERIORS_ATTR	= L"systemPossSuperiors";
static LPCWSTR POSS_SUPERIORS_ATTR			= L"possSuperiors";
static LPCWSTR SYSTEM_AUXILIARY_CLASS_ATTR	= L"systemAuxiliaryClass";
static LPCWSTR AUXILIARY_CLASS_ATTR			= L"auxiliaryClass";
static LPCWSTR DEFAULT_SECURITY_DESCRP_ATTR	= L"defaultSecurityDescriptor";
static LPCWSTR OBJECT_CLASS_CATEGORY_ATTR	= L"objectClassCategory";
static LPCWSTR SYSTEM_ONLY_ATTR				= L"systemOnly";
static LPCWSTR NT_SECURITY_DESCRIPTOR_ATTR	= L"nTSecurityDescriptor";
static LPCWSTR DEFAULT_OBJECTCATEGORY_ATTR	= L"defaultObjectCategory";

// Names of properties in WBEM/LDAP classes
static LPCWSTR ADSI_PATH_ATTR				= L"ADSIPath";
static LPCWSTR OBJECT_CLASS_PROPERTY		= L"ds_objectClass";

// Names of the LDAP property attributes
static LPCWSTR ATTRIBUTE_SYNTAX_ATTR		= L"attributeSyntax";
static LPCWSTR ATTRIBUTE_ID_ATTR			= L"attributeID";
static LPCWSTR IS_SINGLE_VALUED_ATTR		= L"isSingleValued";
static LPCWSTR MAPI_ID_ATTR					= L"mAPIID";
static LPCWSTR OM_SYNTAX_ATTR				= L"oMSyntax";
static LPCWSTR OM_OBJECT_CLASS_ATTR			= L"oMObjectClass";
static LPCWSTR SEARCH_FLAGS_ATTR			= L"searchFlags";
static LPCWSTR RANGE_LOWER_ATTR				= L"rangeLower";
static LPCWSTR RANGE_UPPER_ATTR				= L"rangeUpper";

// Names of the LDAP instance attributes
static LPCWSTR OBJECT_CLASS_ATTR				= L"objectClass";
static LPCWSTR DISTINGUISHED_NAME_ATTR			= L"distinguishedName";

// The OIDs for various LDAP syntaxes
// These values are used to map LDAP Syntax to CIM type
static LPCWSTR DISTINGUISHED_NAME_OID		= L"2.5.5.1";
static LPCWSTR OBJECT_IDENTIFIER_OID		= L"2.5.5.2";
static LPCWSTR CASE_SENSITIVE_STRING_OID	= L"2.5.5.3";
static LPCWSTR CASE_INSENSITIVE_STRING_OID	= L"2.5.5.4";
static LPCWSTR PRINT_CASE_STRING_OID		= L"2.5.5.5";
static LPCWSTR NUMERIC_STRING_OID			= L"2.5.5.6";
static LPCWSTR DN_WITH_BINARY_OID			= L"2.5.5.7";
static LPCWSTR BOOLEAN_OID					= L"2.5.5.8";
static LPCWSTR INTEGER_OID					= L"2.5.5.9";
static LPCWSTR OCTET_STRING_OID				= L"2.5.5.10";
static LPCWSTR TIME_OID						= L"2.5.5.11";
static LPCWSTR UNICODE_STRING_OID			= L"2.5.5.12";
static LPCWSTR PRESENTATION_ADDRESS_OID		= L"2.5.5.13";
static LPCWSTR DN_WITH_STRING_OID			= L"2.5.5.14";
static LPCWSTR NT_SECURITY_DESCRIPTOR_OID	= L"2.5.5.15";
static LPCWSTR LARGE_INTEGER_OID			= L"2.5.5.16";
static LPCWSTR SID_OID						= L"2.5.5.17";

// The name of the top classes
static LPCWSTR TOP_CLASS					= L"ds_top";
static LPCWSTR LDAP_BASE_CLASS				= L"DS_LDAP_Root_Class";

// Some WBEM class names 
static LPCWSTR UINT8ARRAY_CLASS				= L"Uint8Array";
static LPCWSTR DN_WITH_STRING_CLASS			= L"DN_With_String";
static LPCWSTR DN_WITH_BINARY_CLASS			= L"DN_With_Binary";
static LPCWSTR ROOTDSE_CLASS				= L"RootDSE";
static LPCWSTR INSTANCE_ASSOCIATION_CLASS	= L"DS_LDAP_Instance_Containment";
static LPCWSTR CLASS_ASSOCIATION_CLASS		= L"DS_LDAP_Class_Containment";
static LPCWSTR DN_CLASS						= L"DN_Class";
static LPCWSTR DN_ASSOCIATION_CLASS			= L"DSClass_To_DNInstance";

// Some othe literals common to the project
static LPCWSTR LDAP_PREFIX				= L"LDAP://";	
static LPCWSTR ROOT_DSE_PATH			= L"LDAP://RootDSE";
static LPCWSTR RIGHT_BRACKET_STR		= L")";
static LPCWSTR LEFT_BRACKET_STR			= L"(";
static LPCWSTR AMPERSAND_STR			= L"&";
static LPCWSTR PIPE_STR					= L"|";
static LPCWSTR SPACE_STR				= L" ";
static LPCWSTR COMMA_STR				= L",";
static LPCWSTR EQUALS_STR				= L"=";

// Prefixes for class names
static LPCWSTR LDAP_CLASS_NAME_PREFIX							= L"DS_";
static const DWORD LDAP_CLASS_NAME_PREFIX_LENGTH				= 3;
static LPCWSTR LDAP_ARTIFICIAL_CLASS_NAME_PREFIX				= L"ADS_";
static const DWORD LDAP_ARTIFICIAL_CLASS_NAME_PREFIX_LENGTH	= 4;

static LPCWSTR WBEMPERFORMANCEDATAMUTEX		=	L"WbemPerformanceDataMutex";

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\common\wbemhelp.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:wbemhelp.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the implementation the CWBEMHelper class. This is
//	a class that has many static helper functions pertaining to WBEM
//***************************************************************************
/////////////////////////////////////////////////////////////////////////


#include <tchar.h>
#include <windows.h>

/* WBEM includes */
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include <wbemcli.h>

#include "attributes.h"
#include "wbemhelp.h"

LPCWSTR CWBEMHelper :: EQUALS_QUOTE					= L"=\"";
LPCWSTR CWBEMHelper :: QUOTE						= L"\"";
LPCWSTR CWBEMHelper :: OBJECT_CATEGORY_EQUALS		= L"objectCategory=";
LPCWSTR CWBEMHelper :: OBJECT_CLASS_EQUALS			= L"objectClass=";

//***************************************************************************
//
// CWBEMHelper::PutBSTRProperty
//
// Purpose: Puts a BSTR property
//
// Parameters:
//	pWbemClass : The WBEM class on which the property has to be put
//	strPropertyName : The name of the property to be put
//	strPropertyValue : The value of the property to be put
//	deallocatePropertyValue : whether to deallocate the parameter strPropertyValue before
//		the function returns
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: PutBSTRProperty(IWbemClassObject *pWbemClass, 
									   const BSTR strPropertyName, 
									   BSTR strPropertyValue, 
									   BOOLEAN deallocatePropertyValue)
{
	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_BSTR;
	variant.bstrVal = strPropertyValue;

	HRESULT result = pWbemClass->Put(strPropertyName, 0, &variant, 0);
	if (!deallocatePropertyValue)
		variant.bstrVal = NULL;

	VariantClear(&variant);
	return result;
}

//***************************************************************************
//
// CWBEMHelper::GetBSTRProperty
//
// Purpose: Gets a BSTR property
//
// Parameters:
//	pWbemClass : The WBEM class on which the property has to be gotten
//	strPropertyName : The name of the property to be gotten
//	pStrPropertyValue : The address where the value of the property to should be put
//
// Return Value: The COM value representing the return status. The user should delete the
// string allocated when done
//
//***************************************************************************
HRESULT CWBEMHelper :: GetBSTRProperty(IWbemClassObject *pWbemClass, 
	const BSTR strPropertyName, 
	BSTR *pStrPropertyValue)
{
	VARIANT variant;
	HRESULT result = pWbemClass->Get(strPropertyName, 0, &variant, NULL, NULL);
	if(variant.vt == VT_BSTR && variant.bstrVal)
		*pStrPropertyValue = SysAllocString(variant.bstrVal);
	else
		*pStrPropertyValue = NULL;
	VariantClear(&variant);
	return result;
}

//***************************************************************************
//
// CWBEMHelper::PutBSTRPropertyT
//
// Purpose: Puts a BSTR property
//
// Parameters:
//	pWbemClass : The WBEM class on which the property has to be put
//	strPropertyName : The name of the property to be put
//	lpszPropertyValue : The value of the property to be put
//	deallocatePropertyValue : whether to deallocate the parameter lpszPropertyValue before
//		the function returns
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: PutBSTRPropertyT(IWbemClassObject *pWbemClass, 
	const BSTR strPropertyName, 
	LPWSTR lpszPropertyValue, 
	BOOLEAN deallocatePropertyValue)
{
	BSTR strPropertyValue = SysAllocString(lpszPropertyValue);
	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_BSTR;
	variant.bstrVal = strPropertyValue;

	HRESULT result = pWbemClass->Put(strPropertyName, 0, &variant, 0);
	if (deallocatePropertyValue)
		delete[] lpszPropertyValue;

	VariantClear(&variant);
	return result;
}

//***************************************************************************
//
// CWBEMHelper::GetBSTRPropertyT
//
// Purpose: Gets a BSTR property
//
// Parameters:
//	pWbemClass : The WBEM class on which the property has to be put
//	strPropertyName : The name of the property to be put
//	lppszPropertyValue : The pointer to LPWSTR where the value of the property will be placed. The user should
//		delete this once he is done with it.
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: GetBSTRPropertyT(IWbemClassObject *pWbemClass, 
	const BSTR strPropertyName, 
	LPWSTR *lppszPropertyValue)
{
	VARIANT variant;
	HRESULT result = pWbemClass->Get(strPropertyName, 0, &variant, NULL, NULL);
	if(SUCCEEDED(result))
	{
		*lppszPropertyValue = new WCHAR[wcslen(variant.bstrVal) + 1];
		wcscpy(*lppszPropertyValue, variant.bstrVal);
	}
	VariantClear(&variant);
	return result;
}

//***************************************************************************
//
// CWBEMHelper::PutBSTRArrayProperty
//
// Purpose: Puts a BSTR Array property
//
// Parameters:
//	pWbemClass : The WBEM class on which the property has to be put
//	strPropertyName : The name of the property to be put
//	pStrPropertyValue : The array of BSTRS  that have the values of the property to be put
//	lCount : The number of elements in the above array
//	deallocatePropertyValue : whether to deallocate the parameter strPropertyValue before
//		the function returns
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: PutBSTRArrayProperty(IWbemClassObject *pWbemClass, 
											const BSTR strPropertyName, 
											VARIANT *pInputVariant)
{
	// THe input is a safe array of variants of type VT_BSTR
	// The output is a safe array for VT_BSTRs

    LONG lstart, lend;
    SAFEARRAY *inputSafeArray = pInputVariant->parray;
 
    // Get the lower and upper bound of the inpute safe array
    SafeArrayGetLBound( inputSafeArray, 1, &lstart );
    SafeArrayGetUBound( inputSafeArray, 1, &lend );
 

	// Create the output SAFEARRAY
	SAFEARRAY *outputSafeArray = NULL;
	SAFEARRAYBOUND safeArrayBounds [ 1 ] ;
	safeArrayBounds[0].lLbound = lstart ;
	safeArrayBounds[0].cElements = lend - lstart + 1 ;
	outputSafeArray = SafeArrayCreate (VT_BSTR, 1, safeArrayBounds);

	// Fill it
   VARIANT inputItem;
    for ( long idx=lstart; idx <=lend; idx++ )
    {
	    VariantInit(&inputItem);
        SafeArrayGetElement( inputSafeArray, &idx, &inputItem );
		SafeArrayPutElement(outputSafeArray, &idx, inputItem.bstrVal);
        VariantClear(&inputItem);
    }
 

	// Create the variant
	VARIANT outputVariant;
	outputVariant.vt = VT_ARRAY | VT_BSTR ;
	outputVariant.parray = outputSafeArray ; 		

	HRESULT result = pWbemClass->Put (strPropertyName, 0, &outputVariant, 0);
	VariantClear(&outputVariant);
	return result;
}


//***************************************************************************
//
// CWBEMHelper :: PutBOOLQualifier
//
// Purpose: Puts a BOOLEAN Qualifier
//
// Parameters:
//	pQualifierSet : The Qualifier set on which this qualifier has to be put
//	strQualifierName : The name of the qualifier to be put
//	bQualifierValue : The value of the qualifier to be put
//	lFlavour : The flavour of the qualifer
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: PutBOOLQualifier(IWbemQualifierSet *pQualifierSet, 
	const BSTR strQualifierName, 
	VARIANT_BOOL bQualifierValue,
	LONG lFlavour)
{

	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_BOOL;
	variant.boolVal = bQualifierValue;
	HRESULT result = pQualifierSet->Put(strQualifierName, &variant, lFlavour);
	VariantClear(&variant);
	return result;
}

//***************************************************************************
//
// CWBEMHelper :: GetBOOLQualifier
//
// Purpose: Gets a BOOLEAN Qualifier
//
// Parameters:
//	pQualifierSet : The Qualifier set on which this qualifier has to be put
//	strQualifierName : The name of the qualifier to get
//	bQualifierValue : The value of the qualifier to get
//	lFlavour : The flavour of the qualifer
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: GetBOOLQualifier(IWbemQualifierSet *pQualifierSet, 
	const BSTR strQualifierName, 
	VARIANT_BOOL *pbQualifierValue,
	LONG *plFlavour)
{
	VARIANT variant;
	HRESULT result = pQualifierSet->Get(strQualifierName, 0, &variant, plFlavour);
	if(SUCCEEDED(result))
		*pbQualifierValue = variant.boolVal;
	VariantClear(&variant);
	return result;
}


//***************************************************************************
//
// CWBEMHelper :: PutI4Qualifier
//
// Purpose: Puts a VT_I4 Qualifier
//
// Parameters:
//	pQualifierSet : The Qualifier set on which this qualifier has to be put
//	strQualifierName : The name of the qualifier to be put
//	lQualifierValue : The value of the qualifier to be put
//	lFlavour : The flavour of the qualifer
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: PutI4Qualifier(IWbemQualifierSet *pQualifierSet, 
	const BSTR strQualifierName, 
	long lQualifierValue,
	LONG lFlavour)
{

	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_I4;
	variant.lVal = lQualifierValue;
	HRESULT result = pQualifierSet->Put(strQualifierName, &variant, lFlavour);
	VariantClear(&variant);
	return result;
}


//***************************************************************************
//
// CWBEMHelper :: PutLONGQualifier
//
// Purpose: Puts a LONG Qualifier
//
// Parameters:
//	pQualifierSet : The Qualifier set on which this qualifier has to be put
//	strQualifierName : The name of the qualifier to be put
//	lQualifierValue : The value of the qualifier to be put
//	lFlavour : The flavour of the qualifer
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: PutLONGQualifier(IWbemQualifierSet *pQualifierSet, 
	const BSTR strQualifierName, 
	LONG lQualifierValue,
	LONG lFlavour)
{

	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_I4;
	variant.lVal = lQualifierValue;
	HRESULT result = pQualifierSet->Put(strQualifierName, &variant, lFlavour);
	VariantClear(&variant);
	return result;
}

//***************************************************************************
//
// CWBEMHelper :: PutBSTRQualifier
//
// Purpose: Puts a BSTR Qualifier
//
// Parameters:
//	pQualifierSet : The Qualifier set on which this qualifier has to be put
//	strQualifierName : The name of the qualifier to be put
//	strQualifierValue : The value of the qualifier to be put
//	lFlavour : The flavour of the qualifer
//	deallocateQualifierValue : whether to deallocate the parameter strQualifierValue 
//	before the function returns
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: PutBSTRQualifier(IWbemQualifierSet *pQualifierSet, 
	const BSTR strQualifierName, 
	BSTR strQualifierValue,
	LONG lFlavour,
	BOOLEAN deallocateQualifierValue)
{
	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_BSTR;
	variant.bstrVal = strQualifierValue;
	HRESULT result = pQualifierSet->Put(strQualifierName, &variant, lFlavour);
	if(!deallocateQualifierValue)
		variant.bstrVal = NULL;
	VariantClear(&variant);
	return result;
}

//***************************************************************************
//
// CWBEMHelper :: GetBSTRQualifierT
//
// Purpose: Gets a BSTR Qualifier
//
// Parameters:
//	pQualifierSet : The Qualifier set on which this qualifier has to be put
//	strQualifierName : The name of the qualifier to be put
//	lppszQualifierValue : The address of the LPWSTR where the qualifier value will be put/
//		It is the duty of the caller to free this memory when done
//	plFlavour : The address where the qualifier flavor will be put. This is optional
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: GetBSTRQualifierT(
	IWbemQualifierSet *pQualifierSet, 
	const BSTR strQualifierName, 
	LPWSTR *lppszQualifierValue,
	LONG *plFlavour)
{
	VARIANT variant;
	HRESULT result = pQualifierSet->Get(strQualifierName, 0, &variant, plFlavour);
	if(SUCCEEDED(result))
	{
		*lppszQualifierValue = new WCHAR [ wcslen(variant.bstrVal) + 1];
		wcscpy(*lppszQualifierValue, variant.bstrVal);
	}
	VariantClear(&variant);
	return result;
}

//***************************************************************************
//
// CWBEMHelper :: PutUint8ArrayQualifier
//
// Purpose: Puts a Uint8 array  Qualifier
//
// Parameters:
//	pQualifierSet : The Qualifier set on which this qualifier has to be put
//	strQualifierName : The name of the qualifier to be put
//	lpQualifierValue : The value of the qualifier to be put. An array of BYTEs
//	dwLenght : The number of elements in the above array
//	lFlavour : The flavour of the qualifer
//
// Return Value: The COM value representing the return status
//
//***************************************************************************
HRESULT CWBEMHelper :: PutUint8ArrayQualifier(IWbemQualifierSet *pQualifierSet, 
	const BSTR strQualifierName, 
	LPBYTE lpQualifierValue,
	DWORD dwLength,
	LONG lFlavour)
{

	// Create the variant
	VARIANT variant;
	VariantInit(&variant);

	// Create the SAFEARRAY
	SAFEARRAY *safeArray ;
	SAFEARRAYBOUND safeArrayBounds [ 1 ] ;
	safeArrayBounds[0].lLbound = 0 ;
	safeArrayBounds[0].cElements = dwLength ;
	safeArray = SafeArrayCreate (VT_I4, 1, safeArrayBounds);

	// Fill it
	UINT temp;
	for (LONG index = 0; index<(LONG)dwLength; index++)
	{
		temp = (UINT)lpQualifierValue[index];
		SafeArrayPutElement(safeArray , &index,  (LPVOID)&temp);
	}

	variant.vt = VT_ARRAY | VT_I4 ;
	variant.parray = safeArray ; 		

	HRESULT result = pQualifierSet->Put (strQualifierName, &variant, lFlavour);

	VariantClear(&variant);

	return result;

}

//***************************************************************************
//
// CWBEMHelper::GetADSIPathFromObjectPath
//
// Purpose: See Header File
//
//***************************************************************************
LPWSTR CWBEMHelper :: GetADSIPathFromObjectPath(LPCWSTR pszObjectRef)
{
	// Parse the object path
	CObjectPathParser theParser;
	ParsedObjectPath *theParsedObjectPath = NULL;
	LPWSTR pszADSIPath = NULL;
	switch(theParser.Parse((LPWSTR)pszObjectRef, &theParsedObjectPath))
	{
		case CObjectPathParser::NoError:
		{
			KeyRef *pKeyRef = *(theParsedObjectPath->m_paKeys);
			// Check to see that there is 1 key specified and that its type is VT_BSTR
			if(theParsedObjectPath->m_dwNumKeys == 1 && pKeyRef->m_vValue.vt == VT_BSTR)
			{
				// If the name of the key is specified, check the name
				if(pKeyRef->m_pName && _wcsicmp(pKeyRef->m_pName, ADSI_PATH_ATTR) != 0)
					break;

				pszADSIPath = new WCHAR[wcslen((*theParsedObjectPath->m_paKeys)->m_vValue.bstrVal) + 1];
				wcscpy(pszADSIPath, (*theParsedObjectPath->m_paKeys)->m_vValue.bstrVal);
			}
			break;
		}	
		default:
			break;
	}

	// Free the parser object path
	theParser.Free(theParsedObjectPath);
	return pszADSIPath;
}

//***************************************************************************
//
// CWBEMHelper::GetObjectRefFromADSIPath
//
// Purpose: See Header File
//
//***************************************************************************
BSTR CWBEMHelper :: GetObjectRefFromADSIPath(LPCWSTR pszADSIPath, LPCWSTR pszWBEMClassName)
{
	// We need the object path parser to add WMI escape characters
	// from the key value which is an ADSI Path
	ParsedObjectPath t_ObjectPath;

	// Add a key value binding for the ADSIPath
	//===========================================
	VARIANT vKeyValue;
	VariantInit(&vKeyValue);
	vKeyValue.vt = VT_BSTR;
	vKeyValue.bstrVal = SysAllocString(pszADSIPath);
	t_ObjectPath.SetClassName(pszWBEMClassName);
	t_ObjectPath.AddKeyRef(ADSI_PATH_ATTR, &vKeyValue);
	VariantClear(&vKeyValue);


	// Get the Object Path value now
	//================================
	CObjectPathParser t_Parser;
	LPWSTR t_pszObjectPath = NULL;
	BSTR retVal = NULL;
	if(CObjectPathParser::NoError == t_Parser.Unparse(&t_ObjectPath, &t_pszObjectPath))
	{
		retVal = SysAllocString(t_pszObjectPath);
		delete [] t_pszObjectPath;
	}
	return retVal;
}

//***************************************************************************
//
// CWBEMHelper::GetUint8ArrayProperty
//
// Purpose: See Header file
//
//***************************************************************************	
HRESULT CWBEMHelper :: GetUint8ArrayProperty(IWbemClassObject *pWbemClass, 
	const BSTR strPropertyName, 
	LPBYTE *ppPropertyValues, 
	ULONG *plCount)
{
	VARIANT variant;
	HRESULT result = pWbemClass->Get(strPropertyName, 0, &variant, NULL, NULL);
	if(SUCCEEDED(result))
	{
		if(variant.vt == (VT_ARRAY|VT_UI1))
		{
			SAFEARRAY *pArray = variant.parray;
			BYTE HUGEP *pb;
			LONG lUbound = 0, lLbound = 0;
			if(SUCCEEDED(result = SafeArrayAccessData(pArray, (void HUGEP* FAR*)&pb)))
			{
				if(SUCCEEDED (result = SafeArrayGetLBound(pArray, 1, &lLbound)))
				{
					if (SUCCEEDED (result = SafeArrayGetUBound(pArray, 1, &lUbound)))
					{
						if(*plCount = lUbound - lLbound + 1)
						{
							*ppPropertyValues = new BYTE[*plCount];
							for(DWORD i=0; i<*plCount; i++)
								(*ppPropertyValues)[i] = pb[i];
						}
					}
				}
				SafeArrayUnaccessData(pArray);
			}
		}
		else
		{
			*ppPropertyValues = NULL;
			*plCount = 0;
		}
	}
	VariantClear(&variant);
	return result;
}

//***************************************************************************
//
// CWBEMHelper::FormulateInstanceQuery
//
// Purpose: See Header file
//
//***************************************************************************	
HRESULT CWBEMHelper :: FormulateInstanceQuery(IWbemServices *pServices, IWbemContext *pCtx, BSTR strClass, IWbemClassObject *pWbemClass, LPWSTR pszObjectCategory, BSTR strClassQualifier, BSTR strCategoryQualifier)
{
	DWORD dwOutput = 0;
	pszObjectCategory[dwOutput++] = LEFT_BRACKET_STR[0];
	DWORD dwOrPosition = dwOutput;
	pszObjectCategory[dwOutput++] = PIPE_STR[0];

	HRESULT result = E_FAIL;
	if(SUCCEEDED(result = AddSingleCategory(pszObjectCategory, &dwOutput, pWbemClass, strClassQualifier, strCategoryQualifier)))
	{
	}
/*
	IEnumWbemClassObject *pEnum = NULL;
	DWORD dwNumObjects = 0;
	HRESULT result = pServices->CreateClassEnum(strClass, WBEM_FLAG_DEEP, pCtx, &pEnum);
	if(SUCCEEDED(result))
	{
		IWbemClassObject *pNextObject = NULL;
		ULONG lNum = 0;
		while(SUCCEEDED(pEnum->Next(WBEM_INFINITE, 1, &pNextObject, &lNum)) && lNum )
		{
			if(!SUCCEEDED(AddSingleCategory(pszObjectCategory, &dwOutput, pNextObject, strClassQualifier, strCategoryQualifier)))
			{
				pNextObject->Release();
				break;
			}
			dwNumObjects ++;
			pNextObject->Release();
		}
		pEnum->Release();
	}

	// Remove the '|' if there is only one element
	if(!dwNumObjects)
	*/
		pszObjectCategory[dwOrPosition] = SPACE_STR[0];

	// Terminate the query
	pszObjectCategory[dwOutput++] = RIGHT_BRACKET_STR[0];
	pszObjectCategory[dwOutput] = NULL;
	return result;
}

//***************************************************************************
//
// CWBEMHelper::AddSingleCategory
//
// Purpose: See Header file
//
//***************************************************************************	
HRESULT CWBEMHelper :: AddSingleCategory(LPWSTR pszObjectCategory, DWORD *pdwOutput, IWbemClassObject *pNextObject, BSTR strLDAPNameQualifier, BSTR strCategoryQualifier)
{
	pszObjectCategory[(*pdwOutput)++] = SPACE_STR[0];
	pszObjectCategory[(*pdwOutput)++] = LEFT_BRACKET_STR[0];
	IWbemQualifierSet *pQualifierSet = NULL;
	HRESULT result;
	if(SUCCEEDED(result = pNextObject->GetQualifierSet(&pQualifierSet)))
	{
		VARIANT classNameVariant;
		if(SUCCEEDED(result = pQualifierSet->Get(strLDAPNameQualifier, 0, &classNameVariant, NULL)))
		{
			VARIANT categoryVariant;

			if(SUCCEEDED(result = pQualifierSet->Get(strCategoryQualifier, 0, &categoryVariant, NULL)))
			{
				pszObjectCategory[(*pdwOutput)++] = AMPERSAND_STR[0];

				pszObjectCategory[(*pdwOutput)++] = LEFT_BRACKET_STR[0];
				wcscpy(pszObjectCategory + *pdwOutput, OBJECT_CATEGORY_EQUALS);
				*pdwOutput += wcslen(OBJECT_CATEGORY_EQUALS);
				wcscpy(pszObjectCategory + *pdwOutput, categoryVariant.bstrVal);
				*pdwOutput += wcslen(categoryVariant.bstrVal);
				pszObjectCategory[(*pdwOutput)++] = RIGHT_BRACKET_STR[0];

				pszObjectCategory[(*pdwOutput)++] = LEFT_BRACKET_STR[0];
				wcscpy(pszObjectCategory + *pdwOutput, OBJECT_CLASS_EQUALS);
				*pdwOutput += wcslen(OBJECT_CLASS_EQUALS);
				wcscpy(pszObjectCategory + *pdwOutput, classNameVariant.bstrVal);
				*pdwOutput += wcslen(classNameVariant.bstrVal);
				pszObjectCategory[(*pdwOutput)++] = RIGHT_BRACKET_STR[0];

				VariantClear(&categoryVariant);
			}
			VariantClear(&classNameVariant);
		}
		pQualifierSet->Release();
	}
	pszObjectCategory[(*pdwOutput)++] = RIGHT_BRACKET_STR[0];
	pszObjectCategory[(*pdwOutput)++] = SPACE_STR[0];
	return result;
}


//***************************************************************************
//
// CWBEMHelper::IsPresentInBstrList
//
// Purpose: See Header file
//
//***************************************************************************	
BOOLEAN CWBEMHelper :: IsPresentInBstrList(BSTR *pstrProperyNames, DWORD dwNumPropertyNames, BSTR strPropertyName)
{
	for(DWORD i=0; i<dwNumPropertyNames; i++)
	{
		if(_wcsicmp(pstrProperyNames[i], strPropertyName) == 0)
			return TRUE;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\common\maindll.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile: maindll.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $
//	$Nokeywords:  $
//
//
//  Description: Contains DLL entry points.  Also has code that controls
//  when the DLL can be unloaded by tracking the number of objects and locks.
//
//***************************************************************************

#include <tchar.h>
#include <stdio.h>

#include <windows.h>
#include <objbase.h>
#include <olectl.h>

/* WBEM includes */
#include <wbemcli.h>
#include <wbemprov.h>
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include <sqllex.h>
#include <sql_1.h>

/* ADSI includes */
#include <activeds.h>

/* DS Provider includes */
#include "provlog.h"
#include "maindll.h"
#include "clsname.h"
#include <initguid.h>
#include "dscpguid.h"
#include "dsipguid.h"
#include "refcount.h"
#include "adsiprop.h"
#include "adsiclas.h"
#include "adsiinst.h"
#include "provlog.h"
#include "provexpt.h"
#include "tree.h"
#include "ldapcach.h"
#include "wbemcach.h"
#include "classpro.h"
#include "ldapprov.h"
#include "clsproi.h"
#include "ldapproi.h"
#include "classfac.h"
#include "instprov.h"
#include "instproi.h"
#include "instfac.h"


// HANDLE of the DLL
HINSTANCE   g_hInst = NULL;

// Count of locks
long g_lComponents = 0;
// Count of active locks
long g_lServerLocks = 0;

// A critical section to create/delete statics 
CRITICAL_SECTION g_StaticsCreationDeletion;

ProvDebugLog *g_pLogObject = NULL;

//***************************************************************************
//
// DllMain
//
// Description: Entry point for DLL.  Good place for initialization.
// Parameters: The standard DllMain() parameters
// Return: TRUE if OK.
//***************************************************************************

BOOL APIENTRY DllMain (
	HINSTANCE hInstance,
	ULONG ulReason ,
	LPVOID pvReserved
)
{
	g_hInst = hInstance;
	BOOL status = TRUE ;

    if ( DLL_PROCESS_ATTACH == ulReason )
	{
		// Initialize the critical section to access the static initializer objects
		InitializeCriticalSection(&g_StaticsCreationDeletion);

		// Initialize the static Initializer objects. These are destroyed in DllCanUnloadNow
		CDSClassProviderClassFactory :: s_pDSClassProviderInitializer = NULL;
		CDSClassProviderClassFactory ::s_pLDAPClassProviderInitializer = NULL;
		CDSInstanceProviderClassFactory :: s_pDSInstanceProviderInitializer = NULL;
		DisableThreadLibraryCalls(g_hInst);			// 158024 

		status = TRUE ;
    }
    else if ( DLL_PROCESS_DETACH == ulReason )
	{
		DeleteCriticalSection(&g_StaticsCreationDeletion);
		status = TRUE ;
    }
    else if ( DLL_THREAD_DETACH == ulReason )
	{
		status = TRUE ;
    }
    else if ( DLL_THREAD_ATTACH == ulReason )
	{
		status = TRUE ;
    }

    return status ;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Description: Called by COM when some client wants a a class factory.
//
//	Parameters: Ths standard DllGetClassObject() parameters
//
//	Return Value: S_OK only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject (
	REFCLSID rclsid ,
	REFIID riid,
	void **ppv
)
{
	HRESULT status = S_OK ;

	try
	{
		if ( rclsid == CLSID_DSProvider )
		{
			CDSClassProviderClassFactory *lpunk = NULL;
			lpunk = new CDSClassProviderClassFactory ;

			status = lpunk->QueryInterface ( riid , ppv ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;
			}
		}
		else if ( rclsid == CLSID_DSClassAssocProvider )
		{
			CDSClassAssociationsProviderClassFactory *lpunk = new CDSClassAssociationsProviderClassFactory ;
			status = lpunk->QueryInterface ( riid , ppv ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;
			}
		}
		else if ( rclsid == CLSID_DSInstanceProvider )
		{
			CDSInstanceProviderClassFactory *lpunk = new CDSInstanceProviderClassFactory ;
			status = lpunk->QueryInterface ( riid , ppv ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;
			}
		}
		else
		{
			status = CLASS_E_CLASSNOTAVAILABLE ;
		}
	}
	catch(Heap_Exception e_HE)
	{
		status = E_OUTOFMEMORY ;
	}

	return status ;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Description: Called periodically by COM in order to determine if the
// DLL can be unloaded.
//
// Return Value: S_OK if there are no objects in use and the class factory
// isn't locked.
//***************************************************************************

STDAPI DllCanUnloadNow ()
{
	if(g_lServerLocks == 0 && g_lComponents == 0)
	{
		// Delete the Initializer objects
		EnterCriticalSection(&g_StaticsCreationDeletion);
		if(g_pLogObject)
			g_pLogObject->WriteW(L"DllCanUnloadNow called\r\n");
		delete CDSClassProviderClassFactory::s_pDSClassProviderInitializer;
		delete CDSClassProviderClassFactory::s_pLDAPClassProviderInitializer;
		delete CDSInstanceProviderClassFactory::s_pDSInstanceProviderInitializer;
		delete g_pLogObject;
		CDSClassProviderClassFactory::s_pDSClassProviderInitializer = NULL;
		CDSClassProviderClassFactory::s_pLDAPClassProviderInitializer = NULL;
		CDSInstanceProviderClassFactory::s_pDSInstanceProviderInitializer = NULL;
		g_pLogObject = NULL;
		LeaveCriticalSection(&g_StaticsCreationDeletion);

		return S_OK;
	}
	else
		return S_FALSE;
}

/***************************************************************************
 *
 * SetKeyAndValue
 *
 * Description: Helper function for DllRegisterServer that creates
 * a key, sets a value, and closes that key. If pszSubkey is NULL, then
 * the value is created for the pszKey key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the name of the key
 *  pszSubkey       LPTSTR to the name of a subkey
 *  pszValueName    LPTSTR to the value name to use
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue(LPCTSTR pszKey, LPCTSTR pszSubkey, LPCTSTR pszValueName, LPCTSTR pszValue)
{
    HKEY        hKey;
    TCHAR       szKey[256];

    _tcscpy(szKey, pszKey);

	// If a sub key is mentioned, use it.
    if (NULL != pszSubkey)
    {
		_tcscat(szKey, __TEXT("\\"));
        _tcscat(szKey, pszSubkey);
    }

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE,
		szKey, 0, NULL, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

    if (NULL != pszValue)
    {
        if (ERROR_SUCCESS != RegSetValueEx(hKey, pszValueName, 0, REG_SZ, (BYTE *)pszValue,
			(_tcslen(pszValue)+1)*sizeof(TCHAR)))
			return FALSE;
    }
    RegCloseKey(hKey);
    return TRUE;
}

/***************************************************************************
 *
 * DeleteKey
 *
 * Description: Helper function for DllUnRegisterServer that deletes the subkey
 * of a key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the name of the key
 *  pszSubkey       LPTSTR ro the name of a subkey
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL DeleteKey(LPCTSTR pszKey, LPCTSTR pszSubkey)
{
    HKEY        hKey;

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE,
		pszKey, 0, NULL, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

	if(ERROR_SUCCESS != RegDeleteKey(hKey, pszSubkey))
		return FALSE;

    RegCloseKey(hKey);
    return TRUE;
}


////////////////////////////////////////////////////////////////////
// Strings used during self registration
////////////////////////////////////////////////////////////////////
LPCTSTR INPROC32_STR			= __TEXT("InprocServer32");
LPCTSTR INPROC_STR				= __TEXT("InprocServer");
LPCTSTR THREADING_MODEL_STR		= __TEXT("ThreadingModel");
LPCTSTR APARTMENT_STR			= __TEXT("Both");

LPCTSTR CLSID_STR				= __TEXT("SOFTWARE\\CLASSES\\CLSID\\");

// DS Class Provider
LPCTSTR DSPROVIDER_NAME_STR		= __TEXT("Microsoft NT DS Class Provider for WBEM");

// DS Class Associations provider
LPCTSTR DS_ASSOC_PROVIDER_NAME_STR		= __TEXT("Microsoft NT DS Class Associations Provider for WBEM");

// DS Instance provider
LPCTSTR DS_INSTANCE_PROVIDER_NAME_STR		= __TEXT("Microsoft NT DS Instance Provider for WBEM");

STDAPI DllRegisterServer()
{
	TCHAR szModule[512];
	GetModuleFileName(g_hInst, szModule, sizeof(szModule)/sizeof(TCHAR));

	TCHAR szDSProviderClassID[128];
	TCHAR szDSProviderCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_DSProvider, szDSProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszDSProviderClassID[128];
	if(StringFromGUID2(CLSID_DSProvider, wszDSProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszDSProviderClassID, -1, szDSProviderCLSIDClassID, 128, NULL, NULL);

#endif

	_tcscpy(szDSProviderCLSIDClassID, CLSID_STR);
	_tcscat(szDSProviderCLSIDClassID, szDSProviderClassID);

	//
	// Create entries under CLSID for DS Class Provider
	//
	if (FALSE == SetKeyAndValue(szDSProviderCLSIDClassID, NULL, NULL, DSPROVIDER_NAME_STR))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szDSProviderCLSIDClassID, INPROC32_STR, NULL, szModule))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szDSProviderCLSIDClassID, INPROC32_STR, THREADING_MODEL_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;


	TCHAR szDSClassAssocProviderClassID[128];
	TCHAR szDSClassAssocProviderCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_DSClassAssocProvider, szDSClassAssocProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszDSClassAssocProviderClassID[128];
	if(StringFromGUID2(CLSID_DSClassAssocProvider, wszDSClassAssocProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszDSClassAssocProviderClassID, -1, szDSClassAssocProviderCLSIDClassID, 128, NULL, NULL);

#endif

	_tcscpy(szDSClassAssocProviderCLSIDClassID, CLSID_STR);
	_tcscat(szDSClassAssocProviderCLSIDClassID, szDSClassAssocProviderClassID);

	//
	// Create entries under CLSID for DS Class Associations Provider
	//
	if (FALSE == SetKeyAndValue(szDSClassAssocProviderCLSIDClassID, NULL, NULL, DS_ASSOC_PROVIDER_NAME_STR))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szDSClassAssocProviderCLSIDClassID, INPROC32_STR, NULL, szModule))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szDSClassAssocProviderCLSIDClassID, INPROC32_STR, THREADING_MODEL_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;




	TCHAR szDSInstanceProviderClassID[128];
	TCHAR szDSInstanceProviderCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_DSInstanceProvider, szDSInstanceProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszDSInstanceProviderClassID[128];
	if(StringFromGUID2(CLSID_DSInstanceProvider, wszDSInstanceProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszDSInstanceProviderClassID, -1, szDSInstanceProviderCLSIDClassID, 128, NULL, NULL);

#endif


	_tcscpy(szDSInstanceProviderCLSIDClassID, CLSID_STR);
	_tcscat(szDSInstanceProviderCLSIDClassID, szDSInstanceProviderClassID);

	//
	// Create entries under CLSID for DS Instance Provider
	//
	if (FALSE == SetKeyAndValue(szDSInstanceProviderCLSIDClassID, NULL, NULL, DS_INSTANCE_PROVIDER_NAME_STR))
		return SELFREG_E_CLASS;

	if (FALSE == SetKeyAndValue(szDSInstanceProviderCLSIDClassID, INPROC32_STR, NULL, szModule))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szDSInstanceProviderCLSIDClassID, INPROC32_STR, THREADING_MODEL_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;



	return S_OK;
}


STDAPI DllUnregisterServer(void)
{
	TCHAR szModule[512];
	GetModuleFileName(g_hInst,szModule, sizeof(szModule)/sizeof(TCHAR));

	TCHAR szDSProviderClassID[128];
	TCHAR szDSProviderCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_DSProvider, szDSProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszDSProviderClassID[128];
	if(StringFromGUID2(CLSID_DSProvider, wszDSProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszDSProviderClassID, -1, szDSProviderCLSIDClassID, 128, NULL, NULL);

#endif

	_tcscpy(szDSProviderCLSIDClassID, CLSID_STR);
	_tcscat(szDSProviderCLSIDClassID, szDSProviderClassID);

	//
	// Delete the keys for DS Class Provider in the reverse order of creation in DllRegisterServer()
	//
	if(FALSE == DeleteKey(szDSProviderCLSIDClassID, INPROC32_STR))
		return SELFREG_E_CLASS;
	if(FALSE == DeleteKey(CLSID_STR, szDSProviderClassID))
		return SELFREG_E_CLASS;

	TCHAR szDSClassAssocProviderClassID[128];
	TCHAR szDSClassAssocProviderCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_DSClassAssocProvider, szDSClassAssocProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszDSClassAssocProviderClassID[128];
	if(StringFromGUID2(CLSID_DSClassAssocProvider, wszDSClassAssocProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszDSClassAssocProviderClassID, -1, szDSClassAssocProviderCLSIDClassID, 128, NULL, NULL);

#endif

	_tcscpy(szDSClassAssocProviderCLSIDClassID, CLSID_STR);
	_tcscat(szDSClassAssocProviderCLSIDClassID, szDSClassAssocProviderClassID);

	//
	// Delete the keys for DS Class Provider in the reverse order of creation in DllRegisterServer()
	//
	if(FALSE == DeleteKey(szDSClassAssocProviderCLSIDClassID, INPROC32_STR))
		return SELFREG_E_CLASS;
	if(FALSE == DeleteKey(CLSID_STR, szDSClassAssocProviderClassID))
		return SELFREG_E_CLASS;

	TCHAR szDSInstanceProviderClassID[128];
	TCHAR szDSInstanceProviderCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_DSInstanceProvider, szDSInstanceProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszDSInstanceProviderClassID[128];
	if(StringFromGUID2(CLSID_DSInstanceProvider, wszDSInstanceProviderClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszDSInstanceProviderClassID, -1, szDSInstanceProviderCLSIDClassID, 128, NULL, NULL);

#endif

	_tcscpy(szDSInstanceProviderCLSIDClassID, CLSID_STR);
	_tcscat(szDSInstanceProviderCLSIDClassID, szDSInstanceProviderClassID);

	//
	// Delete the keys in the reverse order of creation in DllRegisterServer()
	//
	if(FALSE == DeleteKey(szDSInstanceProviderCLSIDClassID, INPROC32_STR))
		return SELFREG_E_CLASS;
	if(FALSE == DeleteKey(CLSID_STR, szDSInstanceProviderClassID))
		return SELFREG_E_CLASS;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\common\tree.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include <tchar.h>
#include <windows.h>

#include "refcount.h"
#include "tree.h"

CTreeElement :: CTreeElement(LPCWSTR lpszHashedName, CRefCountedObject *pObject)
{
	m_lpszHashedName = new WCHAR[wcslen(lpszHashedName) + 1];
	wcscpy(m_lpszHashedName, lpszHashedName);

	m_pObject = pObject;
	m_pObject->AddRef();
	m_pLeft = NULL;
	m_pRight = NULL;
}

CTreeElement :: ~CTreeElement()
{
	delete [] m_lpszHashedName;
	m_pObject->Release();
}

LPCWSTR CTreeElement :: GetHashedName() const
{
	return m_lpszHashedName;
}

CRefCountedObject *CTreeElement :: GetObject() const
{
	m_pObject->AddRef();
	return m_pObject;
}

CTreeElement *CTreeElement :: GetRight() const
{
	return m_pRight;
}

CTreeElement *CTreeElement :: GetLeft() const
{
	return m_pLeft;
}

void CTreeElement :: SetRight(CTreeElement *pNext)
{
	m_pRight = pNext;
}

void CTreeElement :: SetLeft(CTreeElement *pNext)
{
	m_pLeft = pNext;
}

CObjectTree :: CObjectTree()
{
	// Initialize the critical section 
	InitializeCriticalSection(&m_ModificationSection);

	m_dwNumElements = 0;
	m_pHead = NULL;

}

CObjectTree :: ~CObjectTree()
{
	// Destroy the data
	DeleteTree();

	// Destroy the critical section
	DeleteCriticalSection(&m_ModificationSection);

}

void CObjectTree :: DeleteTree()
{
	EnterCriticalSection(&m_ModificationSection);
	if(m_pHead)
		DeleteSubTree(m_pHead);
	m_dwNumElements = 0;
	LeaveCriticalSection(&m_ModificationSection);
}


void CObjectTree :: DeleteSubTree(CTreeElement *pRoot)
{
	if(pRoot->GetLeft())
		DeleteSubTree(pRoot->GetLeft());
	if(pRoot->GetRight())
		DeleteSubTree(pRoot->GetRight());
	delete pRoot;
}

BOOLEAN CObjectTree :: AddElement(LPCWSTR lpszHashedName, CRefCountedObject *pObject)
{
	BOOLEAN retVal = TRUE;

	EnterCriticalSection(&m_ModificationSection);
	CTreeElement *pCurrent = m_pHead;
	CTreeElement *pParent = NULL;
	int iCompare;
	// Locate the position where the new element is to be inserted
	while(pCurrent)
	{
		iCompare = _wcsicmp(lpszHashedName, pCurrent->GetHashedName());
		if(iCompare == 0)
		{
			retVal = FALSE; // The element already exists
			break;
		}
		else if(iCompare > 0)
		{
			pParent = pCurrent;
			pCurrent = pCurrent->GetRight();
		}
		else
		{
			pParent = pCurrent;
			pCurrent = pCurrent->GetLeft();
		}
	}

	// Create the new element at the appropriate position
	if(retVal == TRUE && pParent)
	{
		iCompare = _wcsicmp(lpszHashedName, pParent->GetHashedName());
		if(iCompare == 0)
			retVal = FALSE;
		else if(iCompare > 0)
		{
			retVal = TRUE;
			pParent->SetRight(new CTreeElement(lpszHashedName, pObject));
		}
		else
		{
			retVal = TRUE;
			pParent->SetLeft(new CTreeElement(lpszHashedName, pObject));
		}
	}
	else if (retVal == TRUE)
	{
		m_pHead = new CTreeElement(lpszHashedName, pObject);
		retVal =  TRUE;
	}
	// Increment the object count if the insertion was successful
	if(retVal)
		m_dwNumElements ++;

	LeaveCriticalSection(&m_ModificationSection);
	return retVal;
}

BOOLEAN CObjectTree :: DeleteElement(LPCWSTR lpszHashedName)
{
	BOOLEAN retVal = FALSE;
	int iDirection = 0; // 0 indicates Unknown, 1 indicates LEFT and 2 indicates RIGHT
	EnterCriticalSection(&m_ModificationSection);
	if(m_pHead == NULL)
		retVal = FALSE;
	else
	{
		// Find the node to be deleted and its parent
		CTreeElement *pParent = NULL;
		CTreeElement *pCurrent = m_pHead;
		int iCompare;
		while(pCurrent)
		{
			iCompare = _wcsicmp(lpszHashedName, pCurrent->GetHashedName());
			if(iCompare == 0)
				break;
			else if(iCompare < 0)
			{
				iDirection = 1;
				pParent = pCurrent;
				pCurrent = pCurrent->GetLeft();
			}
			else
			{
				iDirection = 2;
				pParent = pCurrent;
				pCurrent = pCurrent->GetRight();
			}
		}

		if(!pCurrent) 
			// The element was not found
			retVal = FALSE;
		else
		{
			CTreeElement *pCutPart = NULL;

			// If its left child is null, attach the right subtree to parent
			if(pCurrent->GetLeft() == NULL)
				pCutPart = pCurrent->GetRight();
			// If its right child is null, attach the left subtree to parent
			else if(pCurrent->GetRight() == NULL)
				pCutPart = pCurrent->GetLeft();
			else // We need to find the inorder successor
			{
				CTreeElement *pInorderSuccessor = pCurrent->GetRight();
				if(pInorderSuccessor->GetLeft() == NULL)
				{
					pInorderSuccessor->SetLeft(pCurrent->GetLeft());
					pCutPart = pInorderSuccessor;
				}
				else
				{
					CTreeElement *pPredecessor = pCurrent->GetRight();
					pInorderSuccessor = pPredecessor->GetLeft();
					while(pInorderSuccessor->GetLeft())
					{
						pPredecessor = pInorderSuccessor;
						pInorderSuccessor = pPredecessor->GetLeft();
					}
					pPredecessor->SetLeft(pInorderSuccessor->GetRight());
					pInorderSuccessor->SetLeft(pCurrent->GetLeft());
					pInorderSuccessor->SetRight(pCurrent->GetRight());
					pCutPart = pInorderSuccessor;
				}
			}

			if(iDirection == 0)
				m_pHead = pCutPart;
			else if (iDirection == 1)
				pParent->SetLeft(pCutPart);
			else
				pParent->SetRight(pCutPart);

			delete pCurrent;
			retVal = TRUE;

		}
	}
	// Decrement the count of items in the tree
	if(retVal)
		m_dwNumElements --;

	LeaveCriticalSection(&m_ModificationSection);

	return retVal;
}


CRefCountedObject * CObjectTree :: GetElement(LPCWSTR lpszHashedName)
{
	EnterCriticalSection(&m_ModificationSection);
	CTreeElement *pCurrent = m_pHead;
	CRefCountedObject *pRetVal = NULL;

	int iCompare;
	while(pCurrent)
	{
		iCompare = _wcsicmp(lpszHashedName, pCurrent->GetHashedName());
		if(iCompare == 0)
		{
			pRetVal = pCurrent->GetObject();
			break;
		}
		else if (iCompare > 0) 
			pCurrent = pCurrent->GetRight();
		else 
			pCurrent = pCurrent->GetLeft();
	}
	LeaveCriticalSection(&m_ModificationSection);
	return pRetVal;
}

BOOLEAN CObjectTree :: DeleteLeastRecentlyAccessedElement()
{
	BOOLEAN retVal = FALSE;
	EnterCriticalSection(&m_ModificationSection);
	if(m_pHead)
	{
		CRefCountedObject *pOldestElement = m_pHead->GetObject();
		CRefCountedObject *pLeftOldestElement = GetLeastRecentlyAccessedElementRecursive(m_pHead->GetLeft());
		CRefCountedObject *pRightOldestElement = GetLeastRecentlyAccessedElementRecursive(m_pHead->GetRight());

		if (pLeftOldestElement)
		{
			if(pLeftOldestElement->GetLastAccessTime() < pOldestElement->GetLastAccessTime())
			{
				pOldestElement->Release();
				pOldestElement = pLeftOldestElement;
			}
			else
				pLeftOldestElement->Release();
		}

		if (pRightOldestElement)
		{
			if(pRightOldestElement->GetLastAccessTime() < pOldestElement->GetLastAccessTime())
			{
				pOldestElement->Release();
				pOldestElement = pRightOldestElement;
			}
			else
				pRightOldestElement->Release();
		}

		retVal = DeleteElement(pOldestElement->GetName());
		pOldestElement->Release();
	}
	LeaveCriticalSection(&m_ModificationSection);
	return retVal;
}

CRefCountedObject * CObjectTree :: GetLeastRecentlyAccessedElementRecursive(CTreeElement *pElement)
{
	CRefCountedObject *pObject = NULL;
	if(pElement)
	{
		pObject = pElement->GetObject();
		CRefCountedObject *pLeftObject = GetLeastRecentlyAccessedElementRecursive(pElement->GetLeft());
		if(pLeftObject)
		{
			if(pLeftObject->GetCreationTime() < pObject->GetCreationTime())
			{
				pObject->Release();
				pObject = pLeftObject;
			}
			else
				pLeftObject->Release();
		}

		CRefCountedObject *pRightObject = GetLeastRecentlyAccessedElementRecursive(pElement->GetRight());
		if(pRightObject)
		{
			if (pRightObject->GetCreationTime() < pObject->GetCreationTime())
			{
				pObject->Release();
				pObject = pRightObject;
			}
			else
				pRightObject->Release();
		}

	}

	return pObject;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\common\include\adsiclas.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:adsiclas.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the CADSIClass which encapsulates an ADSI class
//
//***************************************************************************

#ifndef ADSI_CLASS_H
#define ADSI_CLASS_H


class CADSIClass : public CRefCountedObject
{

public:
	//***************************************************************************
	//
	// CADSIClass::CADSIClass
	//
	// Purpose : Constructor 
	//
	// Parameters:
	//  lpszWBEMClassName : The WBEM name of the Class being created. A copy of this is made
	//  lpszADSIClassName : The ADSI name of the Class being created. A copy of this is made
	//***************************************************************************
	CADSIClass(LPCWSTR lpszWBEMClassName, LPCWSTR lpszADSIClassName);
	virtual ~CADSIClass();

	//***************************************************************************
	//
	// CADSIClass :: GetWBEMClassName
	// 
	// Purpose : Returns the WBEM  Class name of this Class
	//***************************************************************************
	LPCWSTR GetWBEMClassName();
	//***************************************************************************
	//
	// CADSIClass :: GetWBEMClassName
	// 
	// Purpose : Sets the WBEM  Class name of this Class
	//***************************************************************************
	void CADSIClass::SetWBEMClassName(LPCWSTR lpszName);

	//***************************************************************************
	//
	// CADSIClass :: GetADSIClassName
	// 
	// Purpose : Returns the ADSI  Class name of this Class
	//***************************************************************************
	LPCWSTR GetADSIClassName();

	//***************************************************************************
	//
	// CADSIClass :: SetADSIClassName
	// 
	// Purpose : Sets the ADSI  Class name of this Class
	//***************************************************************************
	void SetADSIClassName(LPCWSTR lpszName);

	//***************************************************************************
	//
	// CADSIClass :: GetCommonName
	// 
	// Purpose : Returns the CommonName attribute name
	//
	// Parameters:
	//	None
	//
	// Return Value:
	//	The the CommonName attribute name
	//
	//***************************************************************************
	LPCWSTR GetCommonName();

	//***************************************************************************
	//
	// CADSIClass :: SetCommonName
	// 
	// Purpose : Sets the CommonName attribute name for this class
	//
	// Parameters:
	//	The CommonName attribute name for this class
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetCommonName(LPCWSTR lpszCommonName);

	//***************************************************************************
	//
	// CADSIClass :: GetSuperClassLDAPName
	// 
	// Purpose : Returns the SuperClassLDAPName name
	//
	// Parameters:
	//	None
	//
	// Return Value:
	//	The the SuperClassLDAPName name
	//
	//***************************************************************************
	LPCWSTR GetSuperClassLDAPName();

	//***************************************************************************
	//
	// CADSIClass :: SetSuperClassLDAPName
	// 
	// Purpose : Sets the SuperClassLDAPName for this class
	//
	// Parameters:
	//	The SuperClassLDAPName for this class
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetSuperClassLDAPName(LPCWSTR lpszSuperClassLDAPName);

	//***************************************************************************
	//
	// CADSIClass :: GetGovernsID
	// 
	// Purpose : Returns the GovernsID attribute name
	//
	// Parameters:
	//	None
	//
	// Return Value:
	//	The the GovernsID attribute name
	//
	//***************************************************************************
	LPCWSTR GetGovernsID();

	//***************************************************************************
	//
	// CADSIClass :: SetGovernsID
	// 
	// Purpose : Sets the GovernsID attribute name for this class
	//
	// Parameters:
	//	The GovernsID attribute name for this class
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetGovernsID(LPCWSTR lpszGovernsID);

	//***************************************************************************
	//
	// CADSIClass :: GetSchemaIDGUID
	// 
	// Purpose : Returns the SchemaIDGUID attribute name
	//
	// Parameters:
	//	None
	//
	// Return Value:
	//	The the SchemaIDGUID attribute name
	//
	//***************************************************************************
	const LPBYTE GetSchemaIDGUID(DWORD *pdwLength);

	//***************************************************************************
	//
	// CADSIClass :: SetSchemaIDGUID
	// 
	// Purpose : Sets the SchemaIDGUID attribute name for this class
	//
	// Parameters:
	//	The SchemaIDGUID attribute name for this class
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetSchemaIDGUID(LPBYTE pOctets, DWORD dwLength);

	//***************************************************************************
	//
	// CADSIClass :: GetRDNAttribute
	// 
	// Purpose : Returns the RDN attribute name
	//
	// Parameters:
	//	None
	//
	// Return Value:
	//	The the RDN attribute name
	//
	//***************************************************************************
	LPCWSTR GetRDNAttribute();

	//***************************************************************************
	//
	// CADSIClass :: SetRDNAttribute
	// 
	// Purpose : Sets the RDN attribute name for this class
	//
	// Parameters:
	//	The RDN attribute name for this class
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetRDNAttribute(LPCWSTR lpszRDNName);

	//***************************************************************************
	//
	// CADSIClass :: GetDefaultSecurityDescriptor
	// 
	// Purpose : Returns the DefaultSecurityDescriptor attribute name
	//
	// Parameters:
	//	None
	//
	// Return Value:
	//	The the DefaultSecurityDescriptor attribute name
	//
	//***************************************************************************
	LPCWSTR GetDefaultSecurityDescriptor();

	//***************************************************************************
	//
	// CADSIClass :: SetDefaultSecurityDescriptor
	// 
	// Purpose : Sets the DefaultSecurityDescriptor attribute name for this class
	//
	// Parameters:
	//	The DefaultSecurityDescriptor attribute name for this class
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetDefaultSecurityDescriptor(LPCWSTR lpszDefaultSecurityDescriptor);

	//***************************************************************************
	//
	// CADSIClass :: GetObjectClassCategory
	// 
	// Purpose : Returns the ObjectClassCategory attribute name
	//
	// Parameters:
	//	None
	//
	// Return Value:
	//	The the ObjectClassCategory attribute name
	//
	//***************************************************************************
	DWORD GetObjectClassCategory();

	//***************************************************************************
	//
	// CADSIClass :: SetObjectClassCategory
	// 
	// Purpose : Sets the ObjectClassCategory attribute name for this class
	//
	// Parameters:
	//	The ObjectClassCategory attribute name for this class
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetObjectClassCategory(DWORD dwObjectClassCategory);

	//***************************************************************************
	//
	// CADSIClass :: GetNTSecurityDescriptor
	// 
	// Purpose : Returns the SchemaIDGUID attribute name
	//
	// Parameters:
	//	None
	//
	// Return Value:
	//	The the SchemaIDGUID attribute name
	//
	//***************************************************************************
	const LPBYTE GetNTSecurityDescriptor(DWORD *pdwLength);

	//***************************************************************************
	//
	// CADSIClass :: SetNTSecurityDescriptor
	// 
	// Purpose : Sets the SetNTSecurityDescriptor attribute name for this class
	//
	// Parameters:
	//	The SetNTSecurityDescriptor attribute name for this class
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetNTSecurityDescriptor(LPBYTE pOctets, DWORD dwLength);

	//***************************************************************************
	//
	// CADSIClass :: GetDefaultObjectCategory
	// 
	// Purpose : Returns the DefaultObjectCategory attribute name
	//
	// Parameters:
	//	None
	//
	// Return Value:
	//	The the DefaultObjectCategory attribute name
	//
	//***************************************************************************
	LPCWSTR GetDefaultObjectCategory();

	//***************************************************************************
	//
	// CADSIClass :: SetDefaultObjectCategory
	// 
	// Purpose : Sets the DefaultObjectCategory attribute name for this class
	//
	// Parameters:
	//	The DefaultObjectCategory attribute name for this class
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetDefaultObjectCategory(LPCWSTR lpszDefaultObjectCategory);

	//***************************************************************************
	//
	// CADSIClass :: GetSystemOnly
	// 
	// Purpose : Returns the SystemOnly attribute name
	//
	// Parameters:
	//	None
	//
	// Return Value:
	//	The the SystemOnly attribute name
	//
	//***************************************************************************
	BOOLEAN GetSystemOnly();

	//***************************************************************************
	//
	// CADSIClass :: SetSystemOnly
	// 
	// Purpose : Sets the SystemOnly attribute name for this class
	//
	// Parameters:
	//	The SystemOnly attribute name for this class
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetSystemOnly(BOOLEAN bSystemOnly);

	//***************************************************************************
	//
	// CADSIClass :: GetAuxiliaryClasses
	// 
	// Purpose : Gets the list of auxiliary classes for this class
	//
	// Parameters:
	//	pdwCount : The address where the number of elements in the returned array will be put
	//
	// Return Value:
	//	An array of strings which are the names of the auxiliary of this class
	//***************************************************************************
	LPCWSTR *GetAuxiliaryClasses(DWORD *pdwCount);

	//***************************************************************************
	//
	// CADSIClass :: SetAuxiliaryClasses
	// 
	// Purpose : Sets the list of auxiliary classes for this class
	//
	// Parameters:
	//	pValues : The values of this property
	//	dwNumValues : The number of values
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetAuxiliaryClasses(PADSVALUE pValues, DWORD dwNumValues);

	//***************************************************************************
	//
	// CADSIClass :: GetSystemAuxiliaryClasses
	// 
	// Purpose : Gets the list of System auxiliary classes for this class
	//
	// Parameters:
	//	pdwCount : The address where the number of elements in the returned array will be put
	//
	// Return Value:
	//	An array of strings which are the names of the System auxiliary of this class
	//***************************************************************************
	LPCWSTR *GetSystemAuxiliaryClasses(DWORD *pdwCount);

	//***************************************************************************
	//
	// CADSIClass :: SetSystemAuxiliaryClasses
	// 
	// Purpose : Sets the list of System auxiliary classes for this class
	//
	// Parameters:
	//	pValues : The values of this property
	//	dwNumValues : The number of values
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetSystemAuxiliaryClasses(PADSVALUE pValues, DWORD dwNumValues);

	//***************************************************************************
	//
	// CADSIClass :: GetPossibleSuperiors
	// 
	// Purpose : Gets the list of possible superiors for this class
	//
	// Parameters:
	//	pdwCount : The address where the number of elements in the returned array will be put
	//
	// Return Value:
	//	An array of strings which are the names of the possible superiors of this class
	//***************************************************************************
	LPCWSTR *GetPossibleSuperiors(DWORD *pdwCount);

	//***************************************************************************
	//
	// CADSIClass :: SetPossibleSuperiors
	// 
	// Purpose : Sets the list of possible superiors for this class
	//
	// Parameters:
	//	pValues : The values of this property
	//	dwNumValues : The number of values
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetPossibleSuperiors(PADSVALUE pValues, DWORD dwNumValues);

	//***************************************************************************
	//
	// CADSIClass :: GetSystemPossibleSuperiors
	// 
	// Purpose : Gets the list of System possible superiors for this class
	//
	// Parameters:
	//	pdwCount : The address where the number of elements in the returned array will be put
	//
	// Return Value:
	//	An array of strings which are the names of the System possible superiors of this class
	//***************************************************************************
	LPCWSTR *GetSystemPossibleSuperiors(DWORD *pdwCount);

	//***************************************************************************
	//
	// CADSIClass :: SetSystemPossibleSuperiors
	// 
	// Purpose : Sets the list of System possible superiors for this class
	//
	// Parameters:
	//	pValues : The values of this property
	//	dwNumValues : The number of values
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetSystemPossibleSuperiors(PADSVALUE pValues, DWORD dwNumValues);

	//***************************************************************************
	//
	// CADSIClass :: GetMayContains
	// 
	// Purpose : Gets the list of May Contains for this class
	//
	// Parameters:
	//	pdwCount : The address where the number of elements in the returned array will be put
	//
	// Return Value:
	//	An array of strings which are the names of the May Contains of this class
	//***************************************************************************
	LPCWSTR *GetMayContains(DWORD *pdwCount);

	//***************************************************************************
	//
	// CADSIClass :: SetMayContains
	// 
	// Purpose : Sets the list of MayContains for this class
	//
	// Parameters:
	//	pValues : The values of this property
	//	dwNumValues : The number of values
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetMayContains(PADSVALUE pValues, DWORD dwNumValues);

	//***************************************************************************
	//
	// CADSIClass :: GetSystemMayContains
	// 
	// Purpose : Gets the list of System MayC ontains for this class
	//
	// Parameters:
	//	pdwCount : The address where the number of elements in the returned array will be put
	//
	// Return Value:
	//	An array of strings which are the names of the System May Contains of this class
	//***************************************************************************
	LPCWSTR *GetSystemMayContains(DWORD *pdwCount);

	//***************************************************************************
	//
	// CADSIClass :: SetSystemMayContains
	// 
	// Purpose : Sets the list of System May Contains for this class
	//
	// Parameters:
	//	pValues : The values of this property
	//	dwNumValues : The number of values
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetSystemMayContains(PADSVALUE pValues, DWORD dwNumValues);

	//***************************************************************************
	//
	// CADSIClass :: GetMustContains
	// 
	// Purpose : Gets the list of Must Contains for this class
	//
	// Parameters:
	//	pdwCount : The address where the number of elements in the returned array will be put
	//
	// Return Value:
	//	An array of strings which are the names of the Must Contains of this class
	//***************************************************************************
	LPCWSTR *GetMustContains(DWORD *pdwCount);

	//***************************************************************************
	//
	// CADSIClass :: SetMustContains
	// 
	// Purpose : Sets the list of Must Contains for this class
	//
	// Parameters:
	//	pValues : The values of this property
	//	dwNumValues : The number of values
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetMustContains(PADSVALUE pValues, DWORD dwNumValues);

	//***************************************************************************
	//
	// CADSIClass :: GetSystemMustContains
	// 
	// Purpose : Gets the list of System Must Contains for this class
	//
	// Parameters:
	//	pdwCount : The address where the number of elements in the returned array will be put
	//
	// Return Value:
	//	An array of strings which are the names of the System Must Contains of this class
	//***************************************************************************
	LPCWSTR *GetSystemMustContains(DWORD *pdwCount);

	//***************************************************************************
	//
	// CADSIClass :: SetSystemMustContains
	// 
	// Purpose : Sets the list of System Must Contains for this class
	//
	// Parameters:
	//	pValues : The values of this property
	//	dwNumValues : The number of values
	//
	// Return Value:
	//	None
	//***************************************************************************
	void SetSystemMustContains(PADSVALUE pValues, DWORD dwNumValues);

protected:
	// The WBEM name of this class
	LPWSTR m_lpszWBEMClassName;

	// The Common Name (cn) of this class
	LPWSTR m_lpszCommonName;

	// The LDAP Name of the super class
	LPWSTR m_lpszSuperClassLDAPName;

	// The GovernsID attribute
	LPWSTR m_lpszGovernsID;

	// The SchemaIDGUID attribute
	LPBYTE m_pSchemaIDGUIDOctets;
	DWORD m_dwSchemaIDGUIDLength;

	// The RDN Attribute for this class
	LPWSTR m_lpszRDNAttribute;

	// The Default Security Descriptor Attribute for this class
	LPWSTR m_lpszDefaultSecurityDescriptor;

	// The Object Class Category
	DWORD m_dwObjectClassCategory;

	// The NT Security Descriptor Attribute for this class
	LPBYTE m_pNTSecurityDescriptor;
	DWORD m_dwNTSecurityDescriptorLength;

	// The system-only attribute
	BOOLEAN m_bSystemOnly;

	// The Default Object Category
	LPWSTR m_lpszDefaultObjectCategory;

	// The list of auxiliary classes and its count
	LPWSTR *m_lppszAuxiliaryClasses;
	DWORD m_dwAuxiliaryClassesCount;

	// The list of System auxiliary classes and its count
	LPWSTR *m_lppszSystemAuxiliaryClasses;
	DWORD m_dwSystemAuxiliaryClassesCount;

	// The list of possible superiors and its count
	LPWSTR *m_lppszPossibleSuperiors;
	DWORD m_dwPossibleSuperiorsCount;

	// The list of System possible superiors and its count
	LPWSTR *m_lppszSystemPossibleSuperiors;
	DWORD m_dwSystemPossibleSuperiorsCount;

	// The list of may contains and its count
	LPWSTR *m_lppszMayContains;
	DWORD m_dwMayContainsCount;

	// The list of System may contains and its count
	LPWSTR *m_lppszSystemMayContains;
	DWORD m_dwSystemMayContainsCount;

	// The list of must contains and its count
	LPWSTR *m_lppszMustContains;
	DWORD m_dwMustContainsCount;

	// The list of System must contains and its count
	LPWSTR *m_lppszSystemMustContains;
	DWORD m_dwSystemMustContainsCount;

};

#endif /* ADSI_CLASS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\common\include\clsname.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:clasname.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for a list of class names. This user
// the templates from SNMPProvider\Common
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef NAME_LIST_H
#define NAME_LIST_H

// Need to encapsulate LPWSTR to avoid conversion to CString

class CLPWSTR
{
	public :
		LPWSTR pszVal;
		DWORD dwImpersonationLevel;
		CLPWSTR * pNext;

		CLPWSTR()
		{
			pszVal = NULL;
			pNext = NULL;
		}

		~CLPWSTR()
		{
			delete [] pszVal;
		}
};

class CNamesList
{

private:
	CRITICAL_SECTION m_AccessibleClassesSection;
	CLPWSTR *m_pListOfClassNames;
	DWORD m_dwElementCount;
	HRESULT GetImpersonationLevel(DWORD *pdwImpLevel);

public:
	CNamesList();
	virtual ~CNamesList();
	BOOLEAN IsNamePresent(LPCWSTR pszClassName);
	BOOLEAN RemoveName(LPCWSTR pszClassName);
	BOOLEAN AddName(LPCWSTR pszClassName);
	DWORD GetAllNames(LPWSTR **ppszNames);

};

#endif /*NAME_LIST_H*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\common\include\maindll.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Count of locks
extern long g_lComponents;

// Count of active locks
extern long g_lServerLocks;

// Critical section to access the static initializers of all classes in the DLL
extern CRITICAL_SECTION g_StaticsCreationDeletion;

// The log object for all providers
extern ProvDebugLog *g_pLogObject;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\common\include\log.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:log.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the Logging object which supplies
// basic thread-safe logging capabilities.  The behaviour of this log object depends on
// 3 keys in the registry under a root key whose path is supplied in the construction
// of this object. The 3 keys are:
//	File: The path to the file where the logging is done
//	Enabled: 1 if logging is enabled, any other value disables logging
//	Level: Severity level. Only messages tagged with severity levels greater than
//		or equal to this level are logged/ 
//
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

class CDsLog : ProvDebugLog
{
public:

	//***************************************************************************
	//
	// CDsLog::CDsLog
	//
	// Purpose: Contructs an empty CDsLog object.
	//
	// Parameters:
	//  None
	//
	//***************************************************************************
	CDsLog(const TCHAR *a_DebugComponent );

	//***************************************************************************
	//
	// CDsLog::~CDsLog
	//
	// Purpose: Destructor
	//
	//
	//***************************************************************************
	virtual ~CDsLog();

	//***************************************************************************
	//
	// CDsLog::LogMessage
	//
	// Purpose: Initialise it by supplying the registry key that stores the
	//		configuration information
	//
	// Parameters:
	//  lpszRegistrySubTreeRoot: The root of the subtree from which the configuration
	//	values ("File", "Enabled" and "Level") are read
	//
	// Return Value:
	//  TRUE  If the object was initialized successfully. else, FALSE.
	//
	//***************************************************************************
	BOOLEAN Initialise(LPCWSTR lpRegistryRoot);

	//***************************************************************************
	//
	// CDsLog::LogMessage
	//
	// Purpose: Initialise it by supplying the values for File, Level and Enabled keys
	//
	// Parameters:
	//	lpszFileName: The name of the file to which log messages are written
	//  bEnabled: Whether ;pgging is enabled to start with
	//	iLevel : The severity level. Any messages at or above this level are logged.
	//
	// Return Value:
	//	TRUE if successfully initialized. Else, FALSE
	//
	//***************************************************************************
	BOOLEAN Initialise(LPCWSTR lpszFileName, BOOLEAN bEnabled, UINT iLevel);

	//***************************************************************************
	//
	// CDsLog::LogMessage
	//
	// Purpose: Logs a message. The actual message is written on to the log file
	//	only if logging has been enabled and the severity level of the message is
	//	greater than the severity level currently logged
	//
	// Parameters:
	//  iLevel : The severity level of this message
	//	lpszMessage : The message which is formatted according to the 
	//		standard printf() format
	//	The rest of the arguments required for above string to be pronted follow
	//
	// Return Value:
	//	None
	//
	//***************************************************************************
	void LogMessage(UINT iLevel, LPCWSTR lpszMessage, ...);

	// The various severity levels
	enum SeverityLevels
	{
		NONE,
		INFORMATION,
		WARNING,
		FATAL
	};

private:
	//***************************************************************************
	//
	// CDsLog::WriteInitialMessage
	//
	// Purpose: Writes the time the log was created into the log file
	//
	// Parameters:
	//
	// Return Value: None
	//
	//***************************************************************************
	void WriteInitialMessage();

	//***************************************************************************
	//
	// CDsLog::GetRegistryValues
	//
	// Purpose: Reads the registry values and fills in the members.
	//
	// Parameters:
	//  lpszRegistrySubTreeRoot: The root of the subtree from which the configuration
	//	values ("File", "Enabled" and "Level") are read
	//
	// Return Value:
	//  TRUE         If the reading of the registry was done successflly, FALSE otherwise
	//
	//***************************************************************************
	BOOLEAN GetRegistryValues(LPCWSTR lpRegistryRoot);

	// The Log File name
	LPTSTR m_lpszLogFileName;

	// Pointer to the log file
	ProvDebugLog *m_pProvLog;
	// Logging level till which logging is enabled
	UINT m_iLevel;
	// Whether logging is enabled
	BOOLEAN m_bEnabled;

	// The key in the registry below which the File, Enabled and Type keys are
	// defined
	LPTSTR m_lpszRegistryRoot;

	// Literals for "FILE", "ENABLED" and "TYPE"
	static LPCTSTR FILE_STRING;
	static LPCTSTR ENABLED_STRING;
	static LPCTSTR LEVEL_STRING;
	static LPCTSTR ONE_STRING;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\common\include\queryconv.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#ifndef QUERY_H
#define QUERY_H


struct StackElement
{
	int m_iOperator;
	int m_iNumOperandsLeft;
};

class Stack
{
	StackElement m_stack[100];
	int m_iTop;
	static int s_iMax;

	public:
		Stack()
		{
			m_iTop = 0;
		}

		BOOLEAN Push(int iOperator, int iNumOperandsLeft)
		{
			if(m_iTop == s_iMax)
				return FALSE;
			m_stack[m_iTop].m_iOperator = iOperator;
			m_stack[m_iTop].m_iNumOperandsLeft = iNumOperandsLeft;
			m_iTop ++;
			return TRUE;
		}

		BOOLEAN Pop(int *piOperator, int *piNumOperandsLeft)
		{
			if(m_iTop == 0)
				return FALSE;
			m_iTop --;
			*piOperator = 	m_stack[m_iTop].m_iOperator;
			*piNumOperandsLeft = m_stack[m_iTop].m_iNumOperandsLeft;
			return TRUE;
		}

};

class QueryConvertor
{
private:
	static const WCHAR wchAND;
	static const WCHAR wchOR;
	static const WCHAR wchNOT;
	static const WCHAR wchEQUAL;
	static const WCHAR wchSTAR;
	static const WCHAR wchLEFT_BRACKET;
	static const WCHAR wchRIGHT_BRACKET;
	static LPCWSTR pszGE;
	static LPCWSTR pszLE;

	// Special characters excluding ( and ) and *
	static const WCHAR wchBACK_SLASH;

	static BOOLEAN TranslateExpression(LPWSTR pszLDAPQuery, int *piOutputIndex, 
											int iOperator, LPCWSTR pszPropertyName, VARIANT *pValue);
	static BOOLEAN TranslateValueToLDAP(LPWSTR pszLDAPQuery, int *piOutputIndex, VARIANT *pValue);

	static LPWSTR EscapeStringValue(LPCWSTR pszValue);

public:
	// This assumes that enough memory has been allocated to the resulting query
	static BOOLEAN ConvertQueryToLDAP(SQL_LEVEL_1_RPN_EXPRESSION *pExp, LPWSTR pszLDAPQuery);


};	

#endif /* QUERY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\common\include\refcount.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:refcount.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for a basic reference counted object, that
//	also stores a timestamp (in 100-nanosecond intervals since January 1, 1601. This
//	is copatible with the definition of the Win32 FILETIME struture)
//
//***************************************************************************

#ifndef REFCOUNTED_OBJECT_H
#define REFCOUNTED_OBJECT_H


class CRefCountedObject
{

public:

	CRefCountedObject();
	CRefCountedObject(LPCWSTR lpszName);
	virtual ~CRefCountedObject();

	LPCWSTR GetName();
	void SetName(LPCWSTR lpszName);
	void AddRef();
	void Release();
	// Returns the time of creation 
	__int64 GetCreationTime()
	{
		return m_CreationTime;
	}

	// Returns the last time of access 
	__int64 GetLastAccessTime()
	{
		return m_LastAccessTime;
	}
	// Sets the last time of access 
	void SetLastAccessTime(__int64 lastAccessTime)
	{
		m_LastAccessTime = lastAccessTime;
	}


private:
	// A critical section object for synchronizing modifications to refcount
	CRITICAL_SECTION m_ReferenceCountSection;

	unsigned m_dwRefCount;
	LPWSTR m_lpszName;
	__int64 m_CreationTime; 
	__int64 m_LastAccessTime; 

	
};

#endif /* REFCOUNTED_OBJECT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\common\queryconv.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include <stdio.h>
#include <windows.h>
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include <sqllex.h>
#include <sql_1.h>

#include <activeds.h>

#include "attributes.h"
#include "refcount.h"
#include "adsiclas.h"
#include "adsiinst.h"
#include "provlog.h"
#include "ldaphelp.h"
#include "queryconv.h"

const WCHAR QueryConvertor::wchAND		= L'&';
const WCHAR QueryConvertor::wchOR			= L'|';
const WCHAR QueryConvertor::wchNOT		= L'!';
const WCHAR QueryConvertor::wchSTAR		= L'*';
const WCHAR QueryConvertor::wchEQUAL		= L'=';
const WCHAR QueryConvertor::wchLEFT_BRACKET	= L'(';
const WCHAR QueryConvertor::wchRIGHT_BRACKET	= L')';
const WCHAR QueryConvertor::wchBACK_SLASH		= L'\\';
LPCWSTR QueryConvertor::pszGE	= L">=";
LPCWSTR QueryConvertor::pszLE	= L"<=";

int Stack::s_iMax = 100;

// This assumes that enough memory has been allocated to the resulting query
BOOLEAN QueryConvertor::ConvertQueryToLDAP(SQL_LEVEL_1_RPN_EXPRESSION *pExp, LPWSTR pszLDAPQuery)
{
	Stack t_stack;

	int iCurrentOperator = 0, idwNumOperandsLeft = 0;
	int iOutputIndex = 0;

	if(pExp->nNumTokens == 0)
		return TRUE;

	int iCurrentToken = pExp->nNumTokens -1;

	SQL_LEVEL_1_TOKEN *pNextToken = pExp->pArrayOfTokens + iCurrentToken;

	BOOLEAN retVal = FALSE, done = FALSE;

	// Write a '(' at the head of the LDAP Query
	pszLDAPQuery[iOutputIndex ++] = wchLEFT_BRACKET;

	while (!done && iCurrentToken >= 0)
	{
		switch(pNextToken->nTokenType)
		{
			case SQL_LEVEL_1_TOKEN::OP_EXPRESSION:
			{
				// Try to tranlsate expression to LDAP
				if(TranslateExpression(pszLDAPQuery, &iOutputIndex, pNextToken->nOperator, pNextToken->pPropertyName, &pNextToken->vConstValue))
				{
					// If we've finished all the operands for the current operator, get the next one
					idwNumOperandsLeft --;
					while(idwNumOperandsLeft == 0)
					{
						pszLDAPQuery[iOutputIndex ++] = wchRIGHT_BRACKET;
						if(!t_stack.Pop(&iCurrentOperator, &idwNumOperandsLeft))
							done = TRUE;
						idwNumOperandsLeft --;
					}
					iCurrentToken --;
				}
				else
					done = TRUE;
				pNextToken --;
				break;
			}

			case SQL_LEVEL_1_TOKEN::TOKEN_AND:
			{
				if(iCurrentOperator)
				{
					if(!t_stack.Push(iCurrentOperator, idwNumOperandsLeft))
						done = TRUE;
					iCurrentOperator = SQL_LEVEL_1_TOKEN::TOKEN_AND;
					idwNumOperandsLeft = 2;
					pszLDAPQuery[iOutputIndex ++] = wchLEFT_BRACKET;
					pszLDAPQuery[iOutputIndex ++] = wchAND;
				}
				else
				{
					pszLDAPQuery[iOutputIndex ++] = wchLEFT_BRACKET;
					pszLDAPQuery[iOutputIndex ++] = wchAND;
					iCurrentOperator = SQL_LEVEL_1_TOKEN::TOKEN_AND;
					idwNumOperandsLeft = 2;
				}
				iCurrentToken --;
				pNextToken --;

				break;
			}

			case SQL_LEVEL_1_TOKEN::TOKEN_OR:
			{
				if(iCurrentOperator)
				{
					if(!t_stack.Push(iCurrentOperator, idwNumOperandsLeft))
						done = TRUE;
					iCurrentOperator = SQL_LEVEL_1_TOKEN::TOKEN_OR;
					idwNumOperandsLeft = 2;
					pszLDAPQuery[iOutputIndex ++] = wchLEFT_BRACKET;
					pszLDAPQuery[iOutputIndex ++] = wchOR;
				}
				else
				{
					pszLDAPQuery[iOutputIndex ++] = wchLEFT_BRACKET;
					pszLDAPQuery[iOutputIndex ++] = wchOR;
					iCurrentOperator = SQL_LEVEL_1_TOKEN::TOKEN_OR;
					idwNumOperandsLeft = 2;
				}
				iCurrentToken --;
				pNextToken --;
				break;
			}

			case SQL_LEVEL_1_TOKEN::TOKEN_NOT:
			{
				if(iCurrentOperator)
				{
					if(!t_stack.Push(iCurrentOperator, idwNumOperandsLeft))
						done = TRUE;
					iCurrentOperator = SQL_LEVEL_1_TOKEN::TOKEN_NOT;
					idwNumOperandsLeft = 1;
					pszLDAPQuery[iOutputIndex ++] = wchLEFT_BRACKET;
					pszLDAPQuery[iOutputIndex ++] = wchNOT;
				}
				else
				{
					pszLDAPQuery[iOutputIndex ++] = wchLEFT_BRACKET;
					pszLDAPQuery[iOutputIndex ++] = wchNOT;
					iCurrentOperator = SQL_LEVEL_1_TOKEN::TOKEN_NOT;
					idwNumOperandsLeft = 1;
				}
				iCurrentToken --;
				pNextToken --;
				break;
			}

			default:
				done = TRUE;
				break;
		}

	}

	// Check if we used up all the tokens
	if(iCurrentToken == -1)
		retVal = TRUE;

	// Write a ')' at the end of the LDAP Query
	pszLDAPQuery[iOutputIndex ++] = wchRIGHT_BRACKET;
	pszLDAPQuery[iOutputIndex ++] = NULL;
	return retVal;
}



BOOLEAN QueryConvertor::TranslateExpression(LPWSTR pszLDAPQuery, int *piOutputIndex, 
											int iOperator, LPCWSTR pszPropertyName, VARIANT *pValue)
{
	// If it is a CIMOM System property, then dont attempt to map it to LDAP
	if(pszPropertyName[0] == L'_' &&
		pszPropertyName[1] == L'_' )
		return TRUE;

	// If it is ADSIPath, convert it to distinguishedName attribute
	if(_wcsicmp(pszPropertyName, ADSI_PATH_ATTR) == 0 )
	{
		if(pValue== NULL || pValue->vt == VT_NULL)
		{
			if(iOperator == SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL)
			{
				// Put the property name as DistiguishedName
				wcscpy(pszLDAPQuery + *piOutputIndex, DISTINGUISHED_NAME_ATTR);
				*piOutputIndex += wcslen(DISTINGUISHED_NAME_ATTR);


				*(pszLDAPQuery + *piOutputIndex) = wchEQUAL;
				(*piOutputIndex) ++;

				*(pszLDAPQuery + *piOutputIndex) = wchSTAR;
				(*piOutputIndex) ++;
				return TRUE;
			}
			else
			{
				// The '!'
				*(pszLDAPQuery + *piOutputIndex) = wchNOT;
				(*piOutputIndex) ++;

				// The '('
				*(pszLDAPQuery + *piOutputIndex) = wchLEFT_BRACKET;
				(*piOutputIndex) ++;
				if(TranslateExpression(pszLDAPQuery, piOutputIndex, SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL, pszPropertyName, NULL))
				{
					// The ')'
					*(pszLDAPQuery + *piOutputIndex) = wchRIGHT_BRACKET;
					(*piOutputIndex) ++;
					return TRUE;
				}
				else 
					return FALSE;
			}
		}

		// TODO - WinMgmt should not allow this. It should check that the property type matches the property value
		// As soon as Winmgmt has fixed this bug, the next 2 lines may be deleted
		if(pValue->vt != VT_BSTR)
			return FALSE;

		// Get the parentADSI path and RDN from the ADSI Path
		IADsPathname *pADsPathName = NULL;
		BSTR strADSIPath = SysAllocString(pValue->bstrVal);
		BSTR strDN = NULL;
		BOOLEAN bRetVal = FALSE;
		HRESULT result = E_FAIL;
		if(SUCCEEDED(result = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_ALL, IID_IADsPathname, (LPVOID *)&pADsPathName)))
		{
			if(SUCCEEDED(result = pADsPathName->Set(strADSIPath, ADS_SETTYPE_FULL)))
			{
				// This gives the DN
				if(SUCCEEDED(result = pADsPathName->Retrieve(ADS_FORMAT_X500_DN, &strDN)))
				{
					// Put the property name as DistiguishedName
					wcscpy(pszLDAPQuery + *piOutputIndex, DISTINGUISHED_NAME_ATTR);
					*piOutputIndex += wcslen(DISTINGUISHED_NAME_ATTR);

					// Put the LDAP Operator
					if(iOperator == SQL_LEVEL_1_TOKEN::OP_EQUAL)
					{
						*(pszLDAPQuery + *piOutputIndex) = wchEQUAL;
						(*piOutputIndex) ++;
					}
					else
					{
						// The '!'
						*(pszLDAPQuery + *piOutputIndex) = wchNOT;
						(*piOutputIndex) ++;

						*(pszLDAPQuery + *piOutputIndex) = wchEQUAL;
						(*piOutputIndex) ++;
					}

					// Look for the special characters ( ) * and \ and escape them with a \ 
					LPWSTR pszEscapedValue = EscapeStringValue(strDN);
					wcscpy(pszLDAPQuery + *piOutputIndex, pszEscapedValue);
					(*piOutputIndex) += wcslen(pszEscapedValue);
					delete [] pszEscapedValue;

					SysFreeString(strDN);
					bRetVal = TRUE;
				}
			}
			pADsPathName->Release();
		}
		SysFreeString(strADSIPath);

		return bRetVal;
	}

	// Write a '('
	pszLDAPQuery[(*piOutputIndex) ++] = wchLEFT_BRACKET;

	switch(iOperator)
	{
		case SQL_LEVEL_1_TOKEN::OP_EQUAL:
		{
			// Special case where we use '*' LDAP operator
			// is NULL translates to !( x=*)
			if(pValue->vt == VT_NULL)
			{
				// The '!'
				*(pszLDAPQuery + *piOutputIndex) = wchNOT;
				(*piOutputIndex) ++;

				// The '('
				*(pszLDAPQuery + *piOutputIndex) = wchLEFT_BRACKET;
				(*piOutputIndex) ++;

				if(!TranslateExpression(pszLDAPQuery, piOutputIndex, SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL, pszPropertyName, NULL))
					return FALSE;

				// The ')'
				*(pszLDAPQuery + *piOutputIndex) = wchRIGHT_BRACKET;
				(*piOutputIndex) ++;

				break;
			}
			else
			{
				// Followthru
			}
		}
		case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
		case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
		{
			// Get the LDAP name of the property
			LPWSTR pszLDAPName = CLDAPHelper::UnmangleWBEMNameToLDAP(pszPropertyName);
			wcscpy(pszLDAPQuery + *piOutputIndex, pszLDAPName);
			*piOutputIndex += wcslen(pszLDAPName);
			delete [] pszLDAPName;

			// Put the LDAP Operator
			if(iOperator == SQL_LEVEL_1_TOKEN::OP_EQUAL)
			{
				*(pszLDAPQuery + *piOutputIndex) = wchEQUAL;
				(*piOutputIndex) ++;
			}
			else if(iOperator == SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN)
			{
				wcscpy(pszLDAPQuery + *piOutputIndex, pszGE);
				*piOutputIndex += 2;
			}
			else
			{
				wcscpy(pszLDAPQuery + *piOutputIndex, pszLE);
				*piOutputIndex += 2;
			}

			// Put the value of the property
			if(!TranslateValueToLDAP(pszLDAPQuery, piOutputIndex, pValue))
				return FALSE;

		}
		break;

		case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
		{
			// Special case for use of '*'
			if(pValue == NULL || pValue->vt == VT_NULL)
			{

				// Get the LDAP name of the property
				LPWSTR pszLDAPName = CLDAPHelper::UnmangleWBEMNameToLDAP(pszPropertyName);
				wcscpy(pszLDAPQuery + *piOutputIndex, pszLDAPName);
				*piOutputIndex += wcslen(pszLDAPName);
				delete [] pszLDAPName;

				*(pszLDAPQuery + *piOutputIndex) = wchEQUAL;
				(*piOutputIndex) ++;

				*(pszLDAPQuery + *piOutputIndex) = wchSTAR;
				(*piOutputIndex) ++;

			}
			else 			
			{
				// The '!'
				*(pszLDAPQuery + *piOutputIndex) = wchNOT;
				(*piOutputIndex) ++;

				// The '('
				*(pszLDAPQuery + *piOutputIndex) = wchLEFT_BRACKET;
				(*piOutputIndex) ++;

				if(TranslateExpression(pszLDAPQuery, piOutputIndex, SQL_LEVEL_1_TOKEN::OP_EQUAL, pszPropertyName, pValue))
				{
					// The ')'
					*(pszLDAPQuery + *piOutputIndex) = wchRIGHT_BRACKET;
					(*piOutputIndex) ++;
				}
				else
					return FALSE;
			}
		}
		break;

		case SQL_LEVEL_1_TOKEN::OP_LESSTHAN:
		{
			// The '!'
			*(pszLDAPQuery + *piOutputIndex) = wchNOT;
			(*piOutputIndex) ++;

			// The '('
			*(pszLDAPQuery + *piOutputIndex) = wchLEFT_BRACKET;
			(*piOutputIndex) ++;

			if(TranslateExpression(pszLDAPQuery, piOutputIndex, SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN, pszPropertyName, pValue))
			{
				// The ')'
				*(pszLDAPQuery + *piOutputIndex) = wchRIGHT_BRACKET;
				(*piOutputIndex) ++;
			}
			else
				return FALSE;
		}
		break;

		case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN:
		{
			// The '!'
			*(pszLDAPQuery + *piOutputIndex) = wchNOT;
			(*piOutputIndex) ++;

			// The '('
			*(pszLDAPQuery + *piOutputIndex) = wchLEFT_BRACKET;
			(*piOutputIndex) ++;

			if(TranslateExpression(pszLDAPQuery, piOutputIndex, SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN, pszPropertyName, pValue))
			{
				// The ')'
				*(pszLDAPQuery + *piOutputIndex) = wchRIGHT_BRACKET;
				(*piOutputIndex) ++;
			}
			else
				return FALSE;
		}
		break;
		default:
			return FALSE;
	}

	// Write a ')'
	pszLDAPQuery[(*piOutputIndex) ++] = wchRIGHT_BRACKET;
	return TRUE;
}

BOOLEAN QueryConvertor::TranslateValueToLDAP(LPWSTR pszLDAPQuery, int *piOutputIndex, VARIANT *pValue)
{
	switch(pValue->vt)
	{
		case VT_BSTR:
			{ 
				// Look for the special characters ( ) * and \ and escape them with a \ 
				LPWSTR pszEscapedValue = EscapeStringValue(pValue->bstrVal);
				wcscpy(pszLDAPQuery + *piOutputIndex, pszEscapedValue);
				(*piOutputIndex) += wcslen(pszEscapedValue);
				delete [] pszEscapedValue;
		}
		break;
			
		case VT_I4:
		{
			WCHAR temp[18];
			swprintf(temp, L"%d", pValue->lVal);
			wcscpy(pszLDAPQuery + *piOutputIndex, temp);
			(*piOutputIndex) += wcslen(temp);
		}
		break;

		case VT_BOOL:
		{
			if(pValue->boolVal == VARIANT_TRUE)
			{
				wcscpy(pszLDAPQuery + *piOutputIndex, L"TRUE");
				(*piOutputIndex) += wcslen(L"TRUE");
			}
			else
			{
				wcscpy(pszLDAPQuery + *piOutputIndex, L"FALSE");
				(*piOutputIndex) += wcslen(L"FALSE");
			}
		}
		break;
		default:
			return FALSE;
	}
	return TRUE;
}

LPWSTR QueryConvertor::EscapeStringValue(LPCWSTR pszValue)
{
	// Escape the special characters in a string value in a query
	LPWSTR pszRetValue = new WCHAR [wcslen(pszValue)*2 + 1];
	DWORD j=0;
	for(DWORD i=0; i<wcslen(pszValue); i++)
	{
		switch(pszValue[i])
		{
			case wchLEFT_BRACKET:
				pszRetValue[j++] = wchBACK_SLASH;
				pszRetValue[j++] = '2';
				pszRetValue[j++] = '8';
				break;
			case wchRIGHT_BRACKET:
				pszRetValue[j++] = wchBACK_SLASH;
				pszRetValue[j++] = '2';
				pszRetValue[j++] = '9';
				break;
			case wchSTAR:
				pszRetValue[j++] = wchBACK_SLASH;
				pszRetValue[j++] = '2';
				pszRetValue[j++] = 'a';
				break;
			case wchBACK_SLASH:
				pszRetValue[j++] = wchBACK_SLASH;
				pszRetValue[j++] = '5';
				pszRetValue[j++] = 'c';
				break;

			default:
				pszRetValue[j++] = pszValue[i];
				break;
		}
	}
	pszRetValue[j] = NULL;
	return 	pszRetValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\common\include\adsihelp.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:adsihelp.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the CADSIHelper class. This is
//	a class that has many static helper functions pertaining to ADSI
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef ADSI_HELPER_H
#define ADSI_HELPER_H

class CADSIHelper
{
public:

	// Deallocates an array of BSTRs and its contents
	static void DeallocateBSTRArray(BSTR *pStrPropertyValue, LONG lNumber);

private:
	static HRESULT ProcessBSTRArrayProperty(
		VARIANT *pVariant, 
		BSTR **ppStrPropertyValues,
		LONG *pLong);
};

#endif /* ADSI_HELPER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\common\include\tree.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#ifndef OBJECT_TREE_H
#define OBJECT_TREE_H


class CTreeElement
{
public:
	CTreeElement(LPCWSTR lpszHashedName, CRefCountedObject *pObject);
	~CTreeElement();

	LPCWSTR GetHashedName() const;
	CRefCountedObject *GetObject() const;
	CTreeElement *GetLeft() const;
	CTreeElement *GetRight() const;

	void SetLeft(CTreeElement *pNext);
	void SetRight(CTreeElement *pNext);
private:
	LPWSTR m_lpszHashedName;
	CRefCountedObject *m_pObject;
	CTreeElement *m_pLeft;
	CTreeElement *m_pRight;
};

class CObjectTree
{

public:
	CObjectTree();
	~CObjectTree();

	BOOLEAN AddElement(LPCWSTR lpszHashedName, CRefCountedObject *pObject);
	BOOLEAN DeleteElement(LPCWSTR lpszHashedName);
	BOOLEAN DeleteLeastRecentlyAccessedElement();
	CRefCountedObject *GetElement(LPCWSTR lpszHashedName);
	void DeleteTree();
	DWORD GetNumberOfElements() const
	{
		return m_dwNumElements;
	}

private:

	CTreeElement *m_pHead;

	// The number of elements in the tree currently
	DWORD m_dwNumElements;

	// A critical section object for synchronizing modifications
	CRITICAL_SECTION m_ModificationSection;

	// Private fucntions for recursive calls
	void DeleteSubTree(CTreeElement *pRoot);
	
	CRefCountedObject * GetLeastRecentlyAccessedElementRecursive(CTreeElement *pElement);

};	

#endif /* OBJECT_TREE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\instanceprovider\dsipguid.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 9/16/98 4:43p $
// 	$Workfile: dsipguid.cpp $
//
//	$Modtime: 9/16/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
//	Description: This file is used to generate definitions of the GUIDs in the project
//
// ***************************************************************************

#include <objbase.h>
#include <initguid.h>

#include "dsipguid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\instanceprovider\include\dsipguid.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 9/16/98 4:43p $
// 	$Workfile:dsipguid.h $
//
//	$Modtime: 9/16/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains GUID definitions used in this project
//
//***************************************************************************

//
// The CLSID of the DS Instance Provider - {AA527A40-4D9A-11d2-93AD-00805F853771}
//
// {AA527A40-4D9A-11d2-93AD-00805F853771}
DEFINE_GUID(CLSID_DSInstanceProvider, 
0xaa527a40, 0x4d9a, 0x11d2, 0x93, 0xad, 0x0, 0x80, 0x5f, 0x85, 0x37, 0x71);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\common\include\adsiprop.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:adsiprop.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the CADSIProperty which encapsulates an ADSI property. The syntax of an ADSI Property
// is based on the values of the following 3 attributes:
// Attribute Syntax : This is an OID
// OMSyntax: This is an integer
// OMObjectClass : This is an octet string
// For all the syntaxes in the AD, the value om Attribute Syntax is enough for our purposes of
// mapping to a CIM Syntax since values of instances of these properties come mapped to the same
// ADS_TYPE if the value of their OMSyntax is same. Except for the syntaxes Object(OR-Name) and DN_With_Binary
// which have the same value for OMSyntax and Attribute Syntax, but are differentiated based on the value
// of the OMObjectClass. Hence instead of storing the value of OMObjectClass (which is an LPBYTE value) for
// every attribute, we just store one BOOLEAN value isORName which tells us whether the syntax is OR-Name or DN_With_Binary.
// Call it a hack, optimization whatever.
//
//***************************************************************************

#ifndef ADSI_PROPERTY_H
#define ADSI_PROPERTY_H


class CADSIProperty : public CRefCountedObject
{

public:

	//***************************************************************************
	//
	// CADSIProperty::CADSIProperty
	//
	// Purpose : Constructor 
	//
	// Parameters:
	//	
	//	None
	//***************************************************************************
	CADSIProperty();

	//***************************************************************************
	//
	// CADSIProperty::CADSIProperty
	//
	// Purpose : Constructor 
	//
	// Parameters:
	//  lpszWBEMPropertyName : The WBEM name of the property being created. A copy of this is made
	//  lpszADSIPropertyName : The ADSI name of the property being created. A copy of this is made
	//***************************************************************************
	CADSIProperty(LPCWSTR lpszWBEMPropertyName, LPCWSTR lpszADSIPropertyName);

	//***************************************************************************
	//
	// CADSIProperty :: ~CADSIProperty
	// 
	// Purpose : Destructor
	//***************************************************************************
	virtual ~CADSIProperty();

	//***************************************************************************
	//
	// CADSIProperty :: GetWBEMPropertyName
	// 
	// Purpose : Returns the WBEM  property name of this property
	//***************************************************************************
	LPCWSTR GetWBEMPropertyName();

	//***************************************************************************
	//
	// CADSIProperty :: SetWBEMPropertyName
	// 
	// Purpose : Sets the WBEM name of this property
	//***************************************************************************
	void SetWBEMPropertyName(LPCWSTR lpszWBEMName);

	//***************************************************************************
	//
	// CADSIProperty :: GetADSIPropertyName
	// 
	// Purpose : Returns the ADSI  property name of this property
	//***************************************************************************
	LPCWSTR GetADSIPropertyName();

	//***************************************************************************
	//
	// CADSIProperty :: SetADSIPropertyName
	// 
	// Purpose : Sets the ADSI name of this property
	//***************************************************************************
	void SetADSIPropertyName(LPCWSTR lpszADSIName);

	//***************************************************************************
	//
	// CADSIProperty :: GetSyntaxOID
	// 
	// Purpose : Returns the ADSI Syntax OID of this property
	//***************************************************************************
	LPCWSTR GetSyntaxOID();

	//***************************************************************************
	//
	// CADSIProperty :: SetSyntaxOID
	// 
	// Purpose : Sets the ADSI Syntax OID of this property
	//***************************************************************************
	void SetSyntaxOID(LPCWSTR lpszSystaxOID);

	//***************************************************************************
	//
	// CADSIProperty :: IsORName
	// 
	// Purpose : Returns whether the property has a syntax of Object(OR-Name).
	//***************************************************************************
	BOOLEAN IsORName();

	//***************************************************************************
	//
	// CADSIProperty :: SetORName
	// 
	// Purpose : Sets the m_bORName property of this property
	//***************************************************************************
	void SetORName(BOOLEAN bORName);


	//***************************************************************************
	//
	// CADSIProperty :: IsMultiValued
	// 
	// Purpose : Returns whether the property is multi valued
	//***************************************************************************
	BOOLEAN IsMultiValued();

	//***************************************************************************
	//
	// CADSIProperty :: SetMultiValued
	// 
	// Purpose : Sets the multi-valued property of this property
	//***************************************************************************
	void SetMultiValued(BOOLEAN bMultiValued);

	//***************************************************************************
	//
	// CADSIProperty :: IsSystemOnly
	// 
	// Purpose : Returns whether the property is SystemOnly
	//***************************************************************************
	BOOLEAN IsSystemOnly();

	//***************************************************************************
	//
	// CADSIProperty :: SetSystemOnly
	// 
	// Purpose : Sets the SystemOnly property of this property
	//***************************************************************************
	void SetSystemOnly(BOOLEAN bSystemOnly);

	//***************************************************************************
	//
	// CADSIProperty :: GetSearchFlags
	// 
	// Purpose : Returns the SearchFlags property of the property
	//***************************************************************************
	DWORD GetSearchFlags();

	//***************************************************************************
	//
	// CADSIProperty :: SetSearchFlags
	// 
	// Purpose : Sets the SearchFlags property of this property
	//***************************************************************************
	void SetSearchFlags(DWORD dwSearchFlags);

	//***************************************************************************
	//
	// CADSIProperty :: GetOMSyntax
	// 
	// Purpose : Returns the OMSyntax property of the property
	//***************************************************************************
	DWORD GetOMSyntax();

	//***************************************************************************
	//
	// CADSIProperty :: SetOMSyntax
	// 
	// Purpose : Sets the OMSyntax property of this property
	//***************************************************************************
	void SetOMSyntax(DWORD dwOMSyntax);

	//***************************************************************************
	//
	// CADSIProperty :: GetMAPI_ID
	// 
	// Purpose : Returns the MAPI_ID property of the property
	//***************************************************************************
	DWORD GetMAPI_ID();

	//***************************************************************************
	//
	// CADSIProperty :: SetMAPI_ID
	// 
	// Purpose : Sets the MAPI_ID property of this property
	//***************************************************************************
	void SetMAPI_ID(DWORD dwMAPI_ID);


	//***************************************************************************
	//
	// CADSIProperty :: GetAttributeID
	// 
	// Purpose : Returns the Attribute ID of this property
	//***************************************************************************
	LPCWSTR GetAttributeID();

	//***************************************************************************
	//
	// CADSIProperty :: SetAttributeID
	// 
	// Purpose : Sets the Attribute ID of this property
	//***************************************************************************
	void SetAttributeID(LPCWSTR lpszAttributeID);

	//***************************************************************************
	//
	// CADSIProperty :: GetCommonName
	// 
	// Purpose : Returns the Common Name of this property
	//***************************************************************************
	LPCWSTR GetCommonName();

	//***************************************************************************
	//
	// CADSIProperty :: SetCommonName
	// 
	// Purpose : Sets the CommonName of this property
	//***************************************************************************
	void SetCommonName(LPCWSTR lpszCommonName);

	//***************************************************************************
	//
	// CADSIProperty :: GetDirectoryObject
	// 
	// Purpose : Returns the ADSI object pertaining to this property
	//	It is the user's duty to release it when done
	// 
	// Parameters:
	//	None
	//
	// Return Value:
	//	The ADSI object interface pertaining to this property	
	//***************************************************************************
	IDirectoryObject *GetDirectoryObject();

	//***************************************************************************
	//
	// CADSIProperty :: SetDirectoryObject
	// 
	// Purpose : Sets the ADSI object pertaining to this property
	//
	// Parameter : The directory object pertaining to this property
	//***************************************************************************
	void SetDirectoryObject(IDirectoryObject *pDirectoryObject);


protected:
	// The WBEM name of this property
	LPWSTR m_lpszWBEMPropertyName;

	// The ADSI interface for the object representing this property
	IDirectoryObject * m_pDirectoryObject;

	// The Syntax OID
	LPWSTR m_lpszSyntaxOID;

	// Used to differentiate between the syntaxes Object(OR-Name) and DN_with_Binary
	// See the beginning of this file for a detailed explanation of this.
	BOOLEAN m_bORName;

	// Whether it is multi valued
	BOOLEAN m_bMultiValued;

	// The Attribute ID
	LPWSTR m_lpszAttributeID;

	// The Common Name
	LPWSTR m_lpszCommonName;

	// Whether this property is SystemOnly
	BOOLEAN m_bSystemOnly;

	// Search Flags
	DWORD m_dwSearchFlags;

	// MAPI ID
	DWORD m_dwMAPI_ID;

	// OM Syntax
	DWORD m_dwOMSyntax;
};

#endif /* ADSI_PROPERTY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\instanceprovider\include\instproi.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:instproi.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the CDSInstanceProviderInitializer class. This class
// is used to initialize the static members of the CLDAPInstanceProvider class
//
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef DS_INSTANCE_PROVIDER_INIT_H
#define DS_INSTANCE_PROVIDER_INIT_H

class CDSInstanceProviderInitializer
{

public:
	CDSInstanceProviderInitializer();
	~CDSInstanceProviderInitializer();
};

#endif /* DS_INSTANCE_PROVIDER_INIT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\instanceprovider\instproi.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:instproi.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $
//	$Nokeywords:  $
//
//
//  Description: Contains implementation of the class that is used to initialize the
//	CLDAPInstanceProvider class
//
//***************************************************************************

#include <tchar.h>
#include <stdio.h>

#include <windows.h>
#include <objbase.h>
#include <comdef.h>

/* WBEM includes */
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include <sqllex.h>
#include <sql_1.h>
#include <wbemcli.h>
#include <wbemprov.h>

/* ADSI includes */
#include <activeds.h>

/* DS Provider includes */
#include "clsname.h"
#include "attributes.h"
#include "provlog.h"
#include "maindll.h"
#include "dsipguid.h"
#include "refcount.h"
#include "adsiinst.h"
#include "adsiprop.h"
#include "adsiclas.h"
#include "ldaphelp.h"
#include "wbemhelp.h"
#include "instprov.h"
#include "instproi.h"


//***************************************************************************
//
// CDSInstanceProviderInitializer::CDSInstanceProviderInitializer
//
// Constructor Parameters:
//		None
//
//
//***************************************************************************

CDSInstanceProviderInitializer :: CDSInstanceProviderInitializer ()
{
	CLDAPInstanceProvider :: CLASS_STR						= SysAllocString(L"__CLASS");
	CLDAPInstanceProvider :: DN_PROPERTY					= SysAllocString(L"DN");
	CLDAPInstanceProvider :: ROOT_DN_PROPERTY				= SysAllocString(L"RootDNForSearchAndQuery");
	CLDAPInstanceProvider :: QUERY_LANGUAGE					= SysAllocString(L"WQL");
	CLDAPInstanceProvider :: RELPATH_STR					= SysAllocString(L"__RELPATH");
	CLDAPInstanceProvider :: VALUE_PROPERTY_STR				= SysAllocString(L"value");
	CLDAPInstanceProvider :: DN_STRING_PROPERTY_STR			= SysAllocString(L"dnString");
	CLDAPInstanceProvider :: UINT8ARRAY_STR					= SysAllocString(L"Uint8Array");
	CLDAPInstanceProvider :: DN_WITH_BINARY_CLASS_STR		= SysAllocString(L"DN_With_Binary");
	CLDAPInstanceProvider :: DN_WITH_STRING_CLASS_STR		= SysAllocString(L"DN_With_String");
	CLDAPInstanceProvider :: ADSI_PATH_STR					= SysAllocString(ADSI_PATH_ATTR);
	CLDAPInstanceProvider :: INSTANCE_ASSOCIATION_CLASS_STR	= SysAllocString(INSTANCE_ASSOCIATION_CLASS);
	CLDAPInstanceProvider :: CHILD_INSTANCE_PROPERTY_STR	= SysAllocString(L"ChildInstance");
	CLDAPInstanceProvider :: PARENT_INSTANCE_PROPERTY_STR	= SysAllocString(L"ParentInstance");
	CLDAPInstanceProvider :: ATTRIBUTE_SYNTAX_STR			= SysAllocString(L"attributeSyntax");
	CLDAPInstanceProvider :: DEFAULT_OBJECT_CATEGORY_STR	= SysAllocString(L"defaultObjectCategory");
	CLDAPInstanceProvider :: LDAP_DISPLAY_NAME_STR			= SysAllocString(L"ldapDisplayName");
	CLDAPInstanceProvider :: PUT_EXTENSIONS_STR				= SysAllocString(L"__PUT_EXTENSIONS");
	CLDAPInstanceProvider :: PUT_EXT_PROPERTIES_STR			= SysAllocString(L"__PUT_EXT_PROPERTIES");
	CLDAPInstanceProvider :: CIMTYPE_STR					= SysAllocString(L"Cimtype");

	// LDAP://RootDSE Properties
	CLDAPInstanceProvider :: SUBSCHEMASUBENTRY_STR			= SysAllocString(L"subschemaSubentry");
	CLDAPInstanceProvider :: CURRENTTIME_STR				= SysAllocString(L"currentTime");
	CLDAPInstanceProvider :: SERVERNAME_STR					= SysAllocString(L"serverName");
	CLDAPInstanceProvider :: NAMINGCONTEXTS_STR				= SysAllocString(L"namingContexts");
	CLDAPInstanceProvider :: DEFAULTNAMINGCONTEXT_STR		= SysAllocString(L"defaultNamingContext");
	CLDAPInstanceProvider :: SCHEMANAMINGCONTEXT_STR		= SysAllocString(L"schemaNamingContext");
	CLDAPInstanceProvider :: CONFIGURATIONNAMINGCONTEXT_STR	= SysAllocString(L"configurationNamingContext");
	CLDAPInstanceProvider :: ROOTDOMAINNAMINGCONTEXT_STR	= SysAllocString(L"rootDomainNamingContext");
	CLDAPInstanceProvider :: SUPPORTEDCONTROLS_STR			= SysAllocString(L"supportedControl");
	CLDAPInstanceProvider :: SUPPORTEDVERSION_STR			= SysAllocString(L"supportedLDAPVersion");
	CLDAPInstanceProvider :: DNSHOSTNAME_STR				= SysAllocString(L"dnsHostName");
	CLDAPInstanceProvider :: DSSERVICENAME_STR				= SysAllocString(L"dsServiceName");
	CLDAPInstanceProvider :: HIGHESTCOMMITEDUSN_STR			= SysAllocString(L"highestCommittedUSN");
	CLDAPInstanceProvider :: LDAPSERVICENAME_STR			= SysAllocString(L"LDAPServiceName");
	CLDAPInstanceProvider :: SUPPORTEDCAPABILITIES_STR		= SysAllocString(L"supportedCapabilities");
	CLDAPInstanceProvider :: SUPPORTEDLDAPPOLICIES_STR		= SysAllocString(L"supportedLDAPPolicies");
	CLDAPInstanceProvider :: SUPPORTEDSASLMECHANISMS_STR	= SysAllocString(L"supportedSASLMechanisms");
}

//***************************************************************************
//
// CDSInstanceProviderInitializer::CDSInstanceProviderInitializer
//
// Destructor
//
//
//***************************************************************************
CDSInstanceProviderInitializer :: ~CDSInstanceProviderInitializer ()
{
	SysFreeString(CLDAPInstanceProvider::CLASS_STR);
	SysFreeString(CLDAPInstanceProvider::DN_PROPERTY);
	SysFreeString(CLDAPInstanceProvider::ROOT_DN_PROPERTY);
	SysFreeString(CLDAPInstanceProvider::QUERY_LANGUAGE);
	SysFreeString(CLDAPInstanceProvider::RELPATH_STR);
	SysFreeString(CLDAPInstanceProvider::VALUE_PROPERTY_STR);
	SysFreeString(CLDAPInstanceProvider::DN_STRING_PROPERTY_STR);
	SysFreeString(CLDAPInstanceProvider::UINT8ARRAY_STR);
	SysFreeString(CLDAPInstanceProvider::DN_WITH_STRING_CLASS_STR);
	SysFreeString(CLDAPInstanceProvider::DN_WITH_BINARY_CLASS_STR);
	SysFreeString(CLDAPInstanceProvider::ADSI_PATH_STR);
	SysFreeString(CLDAPInstanceProvider::INSTANCE_ASSOCIATION_CLASS_STR);
	SysFreeString(CLDAPInstanceProvider::CHILD_INSTANCE_PROPERTY_STR);
	SysFreeString(CLDAPInstanceProvider::PARENT_INSTANCE_PROPERTY_STR);
	SysFreeString(CLDAPInstanceProvider::ATTRIBUTE_SYNTAX_STR);
	SysFreeString(CLDAPInstanceProvider::DEFAULT_OBJECT_CATEGORY_STR);
	SysFreeString(CLDAPInstanceProvider::LDAP_DISPLAY_NAME_STR);
	SysFreeString(CLDAPInstanceProvider::PUT_EXTENSIONS_STR);
	SysFreeString(CLDAPInstanceProvider::PUT_EXT_PROPERTIES_STR);
	SysFreeString(CLDAPInstanceProvider::CIMTYPE_STR);

	// LDAP://RootDSE Properties
	SysFreeString(CLDAPInstanceProvider::SUBSCHEMASUBENTRY_STR);
	SysFreeString(CLDAPInstanceProvider::CURRENTTIME_STR);
	SysFreeString(CLDAPInstanceProvider::SERVERNAME_STR);
	SysFreeString(CLDAPInstanceProvider::NAMINGCONTEXTS_STR);
	SysFreeString(CLDAPInstanceProvider::DEFAULTNAMINGCONTEXT_STR);
	SysFreeString(CLDAPInstanceProvider::SCHEMANAMINGCONTEXT_STR);
	SysFreeString(CLDAPInstanceProvider::CONFIGURATIONNAMINGCONTEXT_STR);
	SysFreeString(CLDAPInstanceProvider::ROOTDOMAINNAMINGCONTEXT_STR);
	SysFreeString(CLDAPInstanceProvider::SUPPORTEDCONTROLS_STR);
	SysFreeString(CLDAPInstanceProvider::SUPPORTEDVERSION_STR);
	SysFreeString(CLDAPInstanceProvider::DNSHOSTNAME_STR);
	SysFreeString(CLDAPInstanceProvider::DSSERVICENAME_STR);
	SysFreeString(CLDAPInstanceProvider::HIGHESTCOMMITEDUSN_STR);
	SysFreeString(CLDAPInstanceProvider::LDAPSERVICENAME_STR);
	SysFreeString(CLDAPInstanceProvider::SUPPORTEDCAPABILITIES_STR);
	SysFreeString(CLDAPInstanceProvider::SUPPORTEDLDAPPOLICIES_STR);
	SysFreeString(CLDAPInstanceProvider::SUPPORTEDSASLMECHANISMS_STR);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\common\include\wbemhelp.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:wbemhelp.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the CWBEMHelper class. This is
//	a class that has many static helper functions pertaining to WBEM
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef WBEM_HELPER_H
#define WBEM_HELPER_H

class CWBEMHelper
{
protected:
	static LPCWSTR EQUALS_QUOTE;
	static LPCWSTR QUOTE;
	static LPCWSTR OBJECT_CATEGORY_EQUALS;
	static LPCWSTR OBJECT_CLASS_EQUALS;
public:

	//***************************************************************************
	//
	// CWBEMHelper::PutBSTRProperty
	//
	// Purpose: Puts a BSTR property
	//
	// Parameters:
	//	pWbemClass : The WBEM class on which the property has to be put
	//	strPropertyName : The name of the property to be put
	//	strPropertyValue : The value of the property to be put
	//	deallocatePropertyValue : whether to deallocate the parameter strPropertyValue before
	//		the function returns
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	static HRESULT PutBSTRProperty(IWbemClassObject *pWbemClass, 
		const BSTR strPropertyName, 
		BSTR strPropertyValue, 
		BOOLEAN deallocatePropertyValue = TRUE);

	//***************************************************************************
	//
	// CWBEMHelper::GetBSTRProperty
	//
	// Purpose: Gets a BSTR property
	//
	// Parameters:
	//	pWbemClass : The WBEM class on which the property has to be gotten
	//	strPropertyName : The name of the property to be gotten
	//	pStrPropertyValue : The address where the value of the property to should be put
	//
	// Return Value: The COM value representing the return status. The user should delete the
	// string allocated when done
	//
	//***************************************************************************
	static HRESULT GetBSTRProperty(IWbemClassObject *pWbemClass, 
		const BSTR strPropertyName, 
		BSTR *pStrPropertyValue);

	//***************************************************************************
	//
	// CWBEMHelper::PutBSTRPropertyT
	//
	// Purpose: Puts a BSTR property
	//
	// Parameters:
	//	pWbemClass : The WBEM class on which the property has to be put
	//	strPropertyName : The name of the property to be put
	//	lpszPropertyValue : The value of the property to be put
	//	deallocatePropertyValue : whether to deallocate the parameter lpszPropertyValue before
	//		the function returns
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	static HRESULT PutBSTRPropertyT(IWbemClassObject *pWbemClass, 
		const BSTR strPropertyName, 
		LPWSTR lpszPropertyValue, 
		BOOLEAN deallocatePropertyValue = TRUE);

	//***************************************************************************
	//
	// CWBEMHelper::GetBSTRPropertyT
	//
	// Purpose: Gets a BSTR property
	//
	// Parameters:
	//	pWbemClass : The WBEM class on which the property has to be put
	//	strPropertyName : The name of the property to be put
	//	lppszPropertyValue : The pointer to LPWSTR where the value of the property will be placed. The user should
	//		delete this once he is done with it.
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	static HRESULT GetBSTRPropertyT(IWbemClassObject *pWbemClass, 
		const BSTR strPropertyName, 
		LPWSTR *lppszPropertyValue);

	//***************************************************************************
	//
	// CWBEMHelper::PutBSTRArrayProperty
	//
	// Purpose: Puts a BSTR Array property
	//
	// Parameters:
	//	pWbemClass : The WBEM class on which the property has to be put
	//	strPropertyName : The name of the property to be put
	//	pStrPropertyValue : The array of BSTRS  that have the values of the property to be put
	//	lCount : The number of elements in the above array
	//	deallocatePropertyValue : whether to deallocate the parameter strPropertyValue before
	//		the function returns
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************	
	static HRESULT PutBSTRArrayProperty(IWbemClassObject *pWbemClass, 
		const BSTR strPropertyName, 
		VARIANT *pVariant);

	//***************************************************************************
	//
	// CWBEMHelper::GetUint8ArrayProperty
	//
	// Purpose: Gets a VT_UI1 Array property
	//
	// Parameters:
	//	pWbemClass : The WBEM class on which the property has to be gotten
	//	strPropertyName : The name of the property 
	//	ppPropertyValuea : The address of a pointer to BYTE  where an array of values will be places
	//	plCount : The address where the count of elements will be placed
	//
	// Return Value: The COM value representing the return status. The user should deallocate the array
	//	returned when done.
	//
	//***************************************************************************	
	static HRESULT GetUint8ArrayProperty(IWbemClassObject *pWbemClass, 
		const BSTR strPropertyName, 
		LPBYTE *ppPropertyValues, 
		ULONG *plCount);


	//***************************************************************************
	//
	// CWBEMHelper :: PutBOOLQualifier
	//
	// Purpose: Puts a BOOLEAN Qualifier
	//
	// Parameters:
	//	pQualifierSet : The Qualifier set on which this qualifier has to be put
	//	strQualifierName : The name of the qualifier to be put
	//	bQualifierValue : The value of the qualifier to be put
	//	lFlavour : The flavour of the qualifer
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	static HRESULT PutBOOLQualifier(IWbemQualifierSet *pQualifierSet, 
		const BSTR strQualifierName, 
		VARIANT_BOOL bQualifierValue,
		LONG lFlavour);

	//***************************************************************************
	//
	// CWBEMHelper :: GetBOOLQualifier
	//
	// Purpose: Gets a BOOLEAN Qualifier
	//
	// Parameters:
	//	pQualifierSet : The Qualifier set on which this qualifier has to be put
	//	strQualifierName : The name of the qualifier to get
	//	bQualifierValue : The value of the qualifier to get
	//	lFlavour : The flavour of the qualifer
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	static HRESULT GetBOOLQualifier(IWbemQualifierSet *pQualifierSet, 
		const BSTR strQualifierName, 
		VARIANT_BOOL *pbQualifierValue,
		LONG *plFlavour);

	//***************************************************************************
	//
	// CWBEMHelper :: PutI4Qualifier
	//
	// Purpose: Puts a VT_I4 Qualifier
	//
	// Parameters:
	//	pQualifierSet : The Qualifier set on which this qualifier has to be put
	//	strQualifierName : The name of the qualifier to be put
	//	lQualifierValue : The value of the qualifier to be put
	//	lFlavour : The flavour of the qualifer
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************	
	static HRESULT PutI4Qualifier(IWbemQualifierSet *pQualifierSet, 
		const BSTR strQualifierName, 
		long lQualifierValue,
		LONG lFlavour);

	//***************************************************************************
	//
	// CWBEMHelper :: PutBSTRQualifier
	//
	// Purpose: Puts a BSTR Qualifier
	//
	// Parameters:
	//	pQualifierSet : The Qualifier set on which this qualifier has to be put
	//	strQualifierName : The name of the qualifier to be put
	//	strQualifierValue : The value of the qualifier to be put
	//	lFlavour : The flavour of the qualifer
	//	deallocateQualifierValue : whether to deallocate the parameter strQualifierValue 
	//	before the function returns
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	static HRESULT PutBSTRQualifier(IWbemQualifierSet *pQualifierSet, 
		const BSTR strQualifierName, 
		BSTR strQualifierValue,
		LONG lFlavour,
		BOOLEAN deallocateQualifierValue = TRUE);

	//***************************************************************************
	//
	// CWBEMHelper :: GetBSTRQualifierT
	//
	// Purpose: Gets a BSTR Qualifier
	//
	// Parameters:
	//	pQualifierSet : The Qualifier set on which this qualifier has to be put
	//	strQualifierName : The name of the qualifier to be put
	//	lppszQualifierValue : The address of the LPWSTR where the qualifier value will be put/
	//		It is the duty of the caller to free this memory when done
	//	plFlavour : The address where the qualifier flavor will be put. This is optional
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	static HRESULT GetBSTRQualifierT(IWbemQualifierSet *pQualifierSet, 
		const BSTR strQualifierName, 
		LPWSTR *lppszQualifierValue,
		LONG *plFlavour);

	//***************************************************************************
	//
	// CWBEMHelper :: PutLONGQualifier
	//
	// Purpose: Puts a LONG Qualifier
	//
	// Parameters:
	//	pQualifierSet : The Qualifier set on which this qualifier has to be put
	//	strQualifierName : The name of the qualifier to be put
	//	lQualifierValue : The value of the qualifier to be put
	//	lFlavour : The flavour of the qualifer
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	static HRESULT PutLONGQualifier(IWbemQualifierSet *pQualifierSet, 
		const BSTR strQualifierName, 
		LONG lQualifierValue,
		LONG lFlavour);

	//***************************************************************************
	//
	// CWBEMHelper :: PutUint8ArrayQualifier
	//
	// Purpose: Puts a Uint8 array  Qualifier
	//
	// Parameters:
	//	pQualifierSet : The Qualifier set on which this qualifier has to be put
	//	strQualifierName : The name of the qualifier to be put
	//	lpQualifierValue : The value of the qualifier to be put. An array of BYTEs
	//	dwLenght : The number of elements in the above array
	//	lFlavour : The flavour of the qualifer
	//
	// Return Value: The COM value representing the return status
	//
	//***************************************************************************
	static HRESULT PutUint8ArrayQualifier(IWbemQualifierSet *pQualifierSet, 
		const BSTR strQualifierName, 
		LPBYTE lpQualifierValue,
		DWORD dwLength,
		LONG lFlavour);

	//***************************************************************************
	//
	// CWBEMHelper::GetADSIPathFromObjectPath
	//
	// Purpose: Gets the ADSI Path from an object ref of a WBEM object
	//
	// Parameters :
	//	pszObjectRef : The object ref to a WBEM instance
	//
	// Return Value : The ADSI Path in the key of the object ref. The user should delete this
	//	when done
	//
	//***************************************************************************
	static LPWSTR GetADSIPathFromObjectPath(LPCWSTR pszObjectRef);

	//***************************************************************************
	//
	// CWBEMHelper::GetObjectRefFromADSIPath
	//
	// Purpose: Gets the object ref of a WBEM object from its ADSI path
	//
	// Parameters :
	//	pszADSIPath : The ADSI path to an ADSI instance
	//	pszWbemClassName : The WBEM class name of the instance
	//
	// Return Value : The WBEM object ref of the ADSI instance. The user should delete this
	//	when done
	//
	//***************************************************************************
	static BSTR GetObjectRefFromADSIPath(LPCWSTR pszADSIPath, LPCWSTR pszWBEMClassName);

	static HRESULT FormulateInstanceQuery(IWbemServices *pServices, IWbemContext *pContext, BSTR strClass, IWbemClassObject *pWbemClass, LPWSTR pszObjectCategory, BSTR strClassQualifier, BSTR strCategoryQualifier);
	static HRESULT AddSingleCategory(LPWSTR pszObjectCategory, DWORD *pdwOutput, IWbemClassObject *pNextObject, BSTR strClassQualifier, BSTR strCategoryQualifier);

	static BOOLEAN IsPresentInBstrList(BSTR *pstrProperyNames, DWORD dwNumPropertyNames, BSTR strPropertyName);

};

#endif /* WBEM_HELPER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\instanceprovider\include\instfac.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 9/16/98 4:43p $
// 	$Workfile:classfac.cpp $
//
//	$Modtime: 9/16/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the DS Instnace Provider class factory
//
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef DS_INSTANCE_PROVIDER_CLASS_FACTORY_H
#define DS_INSTANCE_PROVIDER_CLASS_FACTORY_H


class CDSInstanceProviderClassFactory : public IClassFactory
{
private:

    long m_ReferenceCount ;

protected:
public:

	// Initializer objects required by the classes used by the DLL
	static CDSInstanceProviderInitializer *s_pDSInstanceProviderInitializer;
	static ProvDebugLog *s_pLogObject;

    CDSInstanceProviderClassFactory () ;
    ~CDSInstanceProviderClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;
};


#endif // DS_INSTANCE_PROVIDER_CLASS_FACTORY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\common\include\ldaphelp.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 6/11/98 4:43p $
// 	$Workfile:ldaphelp.h $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the CLDAPHelper class. This is
//	a class that has many static helper functions pertaining to ADSI LDAP Provider
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef LDAP_HELPER_H
#define LDAP_HELPER_H

class CLDAPHelper
{

public:

	//***************************************************************************
	//
	// CLDAPHelper :: GetLDAPClassFromLDAPName
	//
	// Purpose : To fill in a CADSIClass object on a class/property provided by the LDAP Provider
	// Parameters:
	//		pDirectorySearchSchemaContainer : The IDirectorySearch interface where the schema object should be looked for
	//		lpszSchemaContainerSuffix : The suffix to be used. The actual object fetched will be:
	//			LDAP://CN=<lpszCommonName>,<lpszSchemaContainerSuffix>, where lpszCommonName is the
	//			'cn' attribute of the object having the ldapdisplayname attribute as lpszLDAPObjectName
	//		pSearchInfo: An array of ADS_SEARCHPREF_INFO to be used in the search
	//		dwSearchInfoCount : The number of elements in the above array
	//		lpszLDAPObjectName : The LDAPDisplayName of the LDAP class or property to be fetched. 
	//		ppLDAPObject : The address where the pointer to IDirectoryObject will be stored
	//			It is the caller's responsibility to delete the object when done with it
	// 
	//	Return Value: The COM status value indicating the status of the request.
	//***************************************************************************
	static HRESULT GetLDAPClassFromLDAPName(
		IDirectorySearch *pDirectorySearchSchemaContainer,
		LPCWSTR lpszSchemaContainerSuffix,
		PADS_SEARCHPREF_INFO pSearchInfo,
		DWORD dwSearchInfoCount,
		CADSIClass *pADSIClass);


	//***************************************************************************
	//
	// CLDAPHelper :: GetLDAPSchemaObjectFromCommonName
	//
	// Purpose : To fetch the IDirectoryObject interface on a class/property provided by the LDAP Provider
	// Parameters:
	//		lpszSchemaContainerSuffix : The suffix to be used. The actual object fetced will be:
	//			LDAP://CN=<lpszCommonName>,<lpszSchemaContainerSuffix>
	//		lpszCommonName : The 'cn' attribute of the LDAP class or property to be fetched. 
	//		ppLDAPObject : The address where the pointer to IDirectoryObject will be stored
	//			It is the caller's responsibility to delete the object when done with it
	// 
	//	Return Value: The COM status value indicating the status of the request.
	//***************************************************************************
	static HRESULT GetLDAPSchemaObjectFromCommonName(
		LPCWSTR lpszSchemaContainerSuffix,
		LPCWSTR lpszCommonName, 
		IDirectoryObject **ppLDAPObject);

	//***************************************************************************
	//
	// CLDAPHelper :: GetLDAPClassNameFromCN
	//
	// Purpose : To fetch the LDAPDisplayNAme of a class from its path
	// Parameters:
	// 
	//	Return Value: The COM status value indicating the status of the request. The user should delete the
	// name returned, when done
	//***************************************************************************
	static HRESULT GetLDAPClassNameFromCN(LPCWSTR lpszLDAPClassPath, 
		LPWSTR *lppszLDAPName);

	//***************************************************************************
	//
	// CLDAPHelper :: EnumerateClasses
	//
	// Purpose : To fetch the list of names of subclasses (immediate) of an LDAP class
	// Parameters:
	//		pDirectorySearchSchemaContainer : The IDirectorySearch interface where the schema object should be looked for
	//		lpszSchemaContainerSuffix : The suffix to be used. The actual object fetced will be:
	//			LDAP://CN=<lpszObjectName>,<lpszSchemaContainerSuffix>
	//		pSearchInfo: An array of ADS_SEARCHPREF_INFO to be used in the search
	//		dwSearchInfoCount : The number of elements in the above array
	//		lppszLDAPSuperClass : The immediate superclass of the classes to be retreived. This is optional
	//			and is ignored if NULL
	//		bDeep : Indicates whether a deep enumeration is required. Otherwise a shallow enumeration is done
	//		pppszClassNames : The address of the array of LPWSTR pointers where the resulting objects will be
	//			placed. The user should deallocate this array as well as its contents when done with them.
	//		pdwNumRows : The number of elements in the above array returned
	// 
	//	Return Value: The COM status value indicating the status of the request.
	//***************************************************************************
	static HRESULT EnumerateClasses(
		IDirectorySearch *pDirectorySearchSchemaContainer,
		LPCWSTR lpszSchemaContainerSuffix,
		PADS_SEARCHPREF_INFO pSearchInfo,
		DWORD dwSearchInfoCount,
		LPCWSTR lpszSuperClass,
		BOOLEAN bDeep,
		LPWSTR **pppszClassNames,
		DWORD *pdwNumRows,
		BOOLEAN bArtificialClass);

	// Gets the IDIrectoryObject interface on an ADSI instance
	static HRESULT GetADSIInstance(LPCWSTR szADSIPath, CADSIInstance **ppADSIInstance, ProvDebugLog *pLogObject);

	//***************************************************************************
	//
	// CLDAPHelper :: ExecuteQuery
	//
	// Purpose : To fetch the IDirectoryObject interface on a class/property provided by the LDAP Provider
	// Parameters:
	//		pszPathToRoot : The ADSI path to the node from which the search should start
	//		pSearchInfo: A pointer to a ADS_SEARCHPREF_INFO to be used in the search
	//		dwSearchInfoCount: The number of elements in pSearchInfo array
	//		pszLDAPQuery : The LDAP query to be executed
	//		pppADSIInstances : The address of the array of CADSIInstance pointers where the resulting objects will be
	//			placed. The user should deallocate this array as well as its contents when done with them.
	//		pdwNumRows : The number of elements in the above array returned
	// 
	//	Return Value: The COM status value indicating the status of the request.
	//***************************************************************************
	static HRESULT ExecuteQuery(
		LPCWSTR pszPathToRoot,
		PADS_SEARCHPREF_INFO pSearchInfo,
		DWORD dwSearchInfoCount,
		LPCWSTR pszLDAPQuery,
		CADSIInstance ***pppADSIInstances,
		DWORD *pdwNumRows,
		ProvDebugLog *pLogObject);

	// Helper functions to delete a ADS_ATTR_INFO structure
	static void DeleteAttributeContents(PADS_ATTR_INFO pAttribute);
	static void DeleteADsValueContents(PADSVALUE pValue);


	//***************************************************************************
	//
	// CLDAPHelper :: UnmangleWBEMNameToLDAP
	//
	// Purpose : Converts a mangled WBEM name to LDAP
	//	An underscore in LDAP maps to two underscores in WBEM
	//	An hyphen in LDAP maps to one underscore in WBEM
	//
	// Parameters:
	//	lpszWBEMName : The WBEM class or property name
	// 
	//	Return Value: The LDAP name to the class or property object. This has to
	//	be deallocated by the user
	//***************************************************************************
	static LPWSTR UnmangleWBEMNameToLDAP(LPCWSTR lpszWBEMName);

	//***************************************************************************
	//
	// CLDAPHelper :: MangleLDAPNameToWBEM
	//
	// Purpose : Converts a LDAP name to WBEM by mangling it
	//	An underscore in LDAP maps to two underscores in WBEM
	//	An hyphen in LDAP maps to one underscore in WBEM
	//
	// Parameters:
	//	lpszLDAPName : The LDAP class or property name
	// 
	//	Return Value: The LDAP name to the class or property object. This has to
	//	be deallocated by the user
	//***************************************************************************
	static LPWSTR MangleLDAPNameToWBEM(LPCWSTR lpszLDAPName, BOOLEAN bArtificalName = FALSE);

private:

	// Forms the ADSI path from a class or property name
	static LPWSTR CreateADSIPath(LPCWSTR lpszLDAPSchemaObjectName,	LPCWSTR lpszSchemaContainerSuffix);

	// Some literals
	static LPCWSTR LDAP_CN_EQUALS;
	static LPCWSTR LDAP_DISP_NAME_EQUALS;
	static LPCWSTR OBJECT_CATEGORY_EQUALS_CLASS_SCHEMA;
	static LPCWSTR SUB_CLASS_OF_EQUALS;
	static LPCWSTR NOT_LDAP_NAME_EQUALS;
	static LPCWSTR LEFT_BRACKET_AND;
	static LPCWSTR GOVERNS_ID_EQUALS;
	static LPCWSTR CLASS_SCHEMA;
	static LPCWSTR CN_EQUALS;
};

#endif /* LDAP_HELPER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\mofs\makefile.inc ===
$(O)\dsprov.mof $(O)\dsprov.mfl: dsprov.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\dsprovTmp.mof -MFL:$(O)\dsprovTmp.mfl dsprov.mof
    copy copyright.mof+$(O)\dsprovTmp.mof+$(O)\dsprovTmp.mfl $(O)\dsprov.mof
    copy copyright.mof+$(O)\dsprovTmp.mfl $(O)\dsprov.mfl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\unicode\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\instanceprovider\instprov.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 9/16/98 4:43p $
// 	$Workfile:instprov.cpp $
//
//	$Modtime: 9/16/98 11:21a $
//	$Revision: 1 $
//	$Nokeywords:  $
//
//
//  Description: Contains implementation of the DS Instance Provider class.
//
//***************************************************************************

#include <tchar.h>
#include <stdio.h>

#include <windows.h>
#include <objbase.h>
#include <comdef.h>

/* WBEM includes */
#include <wbemtime.h>
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include <sqllex.h>
#include <sql_1.h>
#include <cominit.h>
#include <wbemcli.h>
#include <wbemprov.h>

/* ADSI includes */
#include <activeds.h>

/* DS Provider includes */
#include "clsname.h"
#include "provlog.h"
#include "attributes.h"
#include "maindll.h"
#include "dsipguid.h"
#include "refcount.h"
#include "adsiinst.h"
#include "adsiprop.h"
#include "adsiclas.h"
#include "ldaphelp.h"
#include "wbemhelp.h"
#include "clsname.h"
#include "instprov.h"
#include "queryconv.h"

/////////////////////////////////////////
// Initialize the static members
/////////////////////////////////////////
LPCWSTR CLDAPInstanceProvider :: DEFAULT_NAMING_CONTEXT_ATTR	= L"defaultNamingContext";
LPCWSTR CLDAPInstanceProvider :: OBJECT_CLASS_EQUALS			= L"(objectClass=";
LPCWSTR CLDAPInstanceProvider :: QUERY_FORMAT					= L"select * from DSClass_To_DNInstance where DSClass=\"%s\"";
BSTR CLDAPInstanceProvider :: CLASS_STR							= NULL;
BSTR CLDAPInstanceProvider :: DN_PROPERTY						= NULL;
BSTR CLDAPInstanceProvider :: ROOT_DN_PROPERTY					= NULL;
BSTR CLDAPInstanceProvider :: QUERY_LANGUAGE					= NULL;
BSTR CLDAPInstanceProvider :: ADSI_PATH_STR						= NULL;
BSTR CLDAPInstanceProvider :: UINT8ARRAY_STR					= NULL;
BSTR CLDAPInstanceProvider :: DN_WITH_STRING_CLASS_STR			= NULL;
BSTR CLDAPInstanceProvider :: DN_WITH_BINARY_CLASS_STR			= NULL;
BSTR CLDAPInstanceProvider :: VALUE_PROPERTY_STR				= NULL;
BSTR CLDAPInstanceProvider :: DN_STRING_PROPERTY_STR			= NULL;
BSTR CLDAPInstanceProvider :: INSTANCE_ASSOCIATION_CLASS_STR	= NULL;
BSTR CLDAPInstanceProvider :: CHILD_INSTANCE_PROPERTY_STR		= NULL;
BSTR CLDAPInstanceProvider :: PARENT_INSTANCE_PROPERTY_STR		= NULL;
BSTR CLDAPInstanceProvider :: RELPATH_STR						= NULL;
BSTR CLDAPInstanceProvider :: ATTRIBUTE_SYNTAX_STR				= NULL;
BSTR CLDAPInstanceProvider :: DEFAULT_OBJECT_CATEGORY_STR		= NULL;
BSTR CLDAPInstanceProvider :: LDAP_DISPLAY_NAME_STR				= NULL;
BSTR CLDAPInstanceProvider :: PUT_EXTENSIONS_STR				= NULL;
BSTR CLDAPInstanceProvider :: PUT_EXT_PROPERTIES_STR			= NULL;
BSTR CLDAPInstanceProvider :: CIMTYPE_STR						= NULL;

// Names of the RootDSE attributes
BSTR CLDAPInstanceProvider :: SUBSCHEMASUBENTRY_STR							= NULL;
BSTR CLDAPInstanceProvider :: CURRENTTIME_STR								= NULL;
BSTR CLDAPInstanceProvider :: SERVERNAME_STR								= NULL;
BSTR CLDAPInstanceProvider :: NAMINGCONTEXTS_STR							= NULL;
BSTR CLDAPInstanceProvider :: DEFAULTNAMINGCONTEXT_STR						= NULL;
BSTR CLDAPInstanceProvider :: SCHEMANAMINGCONTEXT_STR						= NULL;
BSTR CLDAPInstanceProvider :: CONFIGURATIONNAMINGCONTEXT_STR				= NULL;
BSTR CLDAPInstanceProvider :: ROOTDOMAINNAMINGCONTEXT_STR					= NULL;
BSTR CLDAPInstanceProvider :: SUPPORTEDCONTROLS_STR							= NULL;
BSTR CLDAPInstanceProvider :: SUPPORTEDVERSION_STR							= NULL;
BSTR CLDAPInstanceProvider :: DNSHOSTNAME_STR								= NULL;
BSTR CLDAPInstanceProvider :: DSSERVICENAME_STR								= NULL;
BSTR CLDAPInstanceProvider :: HIGHESTCOMMITEDUSN_STR						= NULL;
BSTR CLDAPInstanceProvider :: LDAPSERVICENAME_STR							= NULL;
BSTR CLDAPInstanceProvider :: SUPPORTEDCAPABILITIES_STR						= NULL;
BSTR CLDAPInstanceProvider :: SUPPORTEDLDAPPOLICIES_STR						= NULL;
BSTR CLDAPInstanceProvider :: SUPPORTEDSASLMECHANISMS_STR					= NULL;



//***************************************************************************
//
// CLDAPInstanceProvider::CLDAPInstanceProvider
// CLDAPInstanceProvider::~CLDAPInstanceProvider
//
// Constructor Parameters:
//
//
//***************************************************************************

CLDAPInstanceProvider :: CLDAPInstanceProvider (ProvDebugLog * pLogObject)
{
	InterlockedIncrement(&g_lComponents);

	// Initialize the search preferences often used
	m_pSearchInfo[0].dwSearchPref		= ADS_SEARCHPREF_SEARCH_SCOPE;
	m_pSearchInfo[0].vValue.dwType		= ADSTYPE_INTEGER;
	m_pSearchInfo[0].vValue.Integer		= ADS_SCOPE_SUBTREE;

	m_pSearchInfo[1].dwSearchPref		= ADS_SEARCHPREF_PAGESIZE;
	m_pSearchInfo[1].vValue.dwType		= ADSTYPE_INTEGER;
	m_pSearchInfo[1].vValue.Integer		= 1024;

	m_pLogObject = pLogObject;
	m_lReferenceCount = 0 ;
	m_IWbemServices = NULL;
	m_pWbemUin8ArrayClass = NULL;
	m_pWbemDNWithBinaryClass = NULL;
	m_pWbemDNWithStringClass = NULL;
	m_pAssociationsClass = NULL;
	m_lpszTopLevelContainerPath = NULL;
	m_bInitializedSuccessfully = FALSE;

	if(m_pLogObject)
		m_pLogObject->WriteW( L"CLDAPInstanceProvider :: CONSTRUCTOR\r\n");
}

CLDAPInstanceProvider::~CLDAPInstanceProvider ()
{
	if(m_pLogObject)
		m_pLogObject->WriteW( L"CLDAPInstanceProvider :: DESCTRUVTOR\r\n");

	InterlockedDecrement(&g_lComponents);

	delete [] m_lpszTopLevelContainerPath;
	if(m_IWbemServices)
		m_IWbemServices->Release();
	if(m_pWbemUin8ArrayClass)
		m_pWbemUin8ArrayClass->Release();
	if(m_pWbemDNWithBinaryClass)
		m_pWbemDNWithBinaryClass->Release();
	if(m_pWbemDNWithStringClass)
		m_pWbemDNWithStringClass->Release();
	if(m_pAssociationsClass)
		m_pAssociationsClass->Release();
}

//***************************************************************************
//
// CLDAPInstanceProvider::QueryInterface
// CLDAPInstanceProvider::AddRef
// CLDAPInstanceProvider::Release
//
// Purpose: Standard COM routines needed for all COM objects
//
//***************************************************************************

STDMETHODIMP CLDAPInstanceProvider :: QueryInterface (

	REFIID iid ,
	LPVOID FAR *iplpv
)
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) (IUnknown *)(IWbemProviderInit *)this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) (IWbemServices *)this ;
	}
	else if ( iid == IID_IWbemProviderInit )
	{
		*iplpv = ( LPVOID ) (IWbemProviderInit *)this ;
	}
	else
	{
		return E_NOINTERFACE;
	}

	( ( LPUNKNOWN ) *iplpv )->AddRef () ;
	return  S_OK;
}


STDMETHODIMP_( ULONG ) CLDAPInstanceProvider :: AddRef ()
{
	return InterlockedIncrement ( & m_lReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CLDAPInstanceProvider :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_lReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}


HRESULT CLDAPInstanceProvider :: Initialize(
        LPWSTR wszUser,
        LONG lFlags,
        LPWSTR wszNamespace,
        LPWSTR wszLocale,
        IWbemServices __RPC_FAR *pNamespace,
        IWbemContext __RPC_FAR *pCtx,
        IWbemProviderInitSink __RPC_FAR *pInitSink)
{
	// Validate the arguments
	if(pNamespace == NULL || lFlags != 0)
	{
		m_pLogObject->WriteW( L"CLDAPInstanceProvider :: Argument validation FAILED\r\n");
		pInitSink->SetStatus(WBEM_E_FAILED, 0);
		return WBEM_S_NO_ERROR;
	}

	// Store the IWbemServices pointer for future use
	m_IWbemServices = pNamespace;
	m_IWbemServices->AddRef();

	// Get the DefaultNamingContext to get at the top level container
	// Get the ADSI path of the schema container and store it for future use
	IADs *pRootDSE = NULL;
	HRESULT result;

	if(SUCCEEDED(result = ADsOpenObject((LPWSTR)ROOT_DSE_PATH, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IADs, (LPVOID *) &pRootDSE)))
	{
		// Get the location of the schema container
		BSTR strDefaultNamingContext = SysAllocString((LPWSTR) DEFAULT_NAMING_CONTEXT_ATTR);

		// Get the DEFAULT_NAMING_CONTEXT property. This property contains the ADSI path
		// of the top level container
		VARIANT variant;
		VariantInit(&variant);
		if(SUCCEEDED(result = pRootDSE->Get(strDefaultNamingContext, &variant)))
		{
			m_pLogObject->WriteW( L"CLDAPInstanceProvider :: Got Top Level Container as : %s\r\n", variant.bstrVal);

			// Form the top level container path
			m_lpszTopLevelContainerPath = new WCHAR[wcslen(LDAP_PREFIX) + wcslen(variant.bstrVal) + 1];
			wcscpy(m_lpszTopLevelContainerPath, LDAP_PREFIX);
			wcscat(m_lpszTopLevelContainerPath, variant.bstrVal);
			// Get the Uint8Array Class
			if(SUCCEEDED(result = m_IWbemServices->GetObject(UINT8ARRAY_STR, 0, pCtx, &m_pWbemUin8ArrayClass, NULL)))
			{
				// Get the DNWIthBinary Class
				if(SUCCEEDED(result = m_IWbemServices->GetObject(DN_WITH_BINARY_CLASS_STR, 0, pCtx, &m_pWbemDNWithBinaryClass, NULL)))
				{
					// Get the DNWIthBinary Class
					if(SUCCEEDED(result = m_IWbemServices->GetObject(DN_WITH_STRING_CLASS_STR, 0, pCtx, &m_pWbemDNWithStringClass, NULL)))
					{
						// Get the Associations Class
						if(SUCCEEDED(result = m_IWbemServices->GetObject(INSTANCE_ASSOCIATION_CLASS_STR, 0, pCtx, &m_pAssociationsClass, NULL)))
						{
						}
						else
						{
							m_pLogObject->WriteW( L"CLDAPInstanceProvider :: FAILED to get Instance Associations class %x\r\n", result);
						}
					}
					else
					{
						m_pLogObject->WriteW( L"CLDAPInstanceProvider :: FAILED to get DNWithString class %x\r\n", result);
					}
				}
				else
				{
					m_pLogObject->WriteW( L"CLDAPInstanceProvider :: FAILED to get DNWithBinary class %x\r\n", result);
				}
			}
			else
			{
				m_pLogObject->WriteW( L"CLDAPInstanceProvider :: FAILED to get Uint8Array class %x\r\n", result);
			}
			VariantClear(&variant);
		}
		SysFreeString(strDefaultNamingContext);
		pRootDSE->Release();
	}

	if(SUCCEEDED(result))
	{
		m_bInitializedSuccessfully = TRUE;
		pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
	}
	else
	{
		m_bInitializedSuccessfully = FALSE;
		m_pLogObject->WriteW( L"CLDAPInstanceProvider :: Initialize() FAILED \r\n");
		pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
	}

	return WBEM_S_NO_ERROR;
}

HRESULT CLDAPInstanceProvider :: OpenNamespace(
    /* [in] */ const BSTR strNamespace,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: CancelAsyncCall(
    /* [in] */ IWbemObjectSink __RPC_FAR *pSink)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: QueryObjectSink(
    /* [in] */ long lFlags,
    /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: GetObject(
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: GetObjectAsync(
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	if(!m_bInitializedSuccessfully)
	{
		m_pLogObject->WriteW( L"CLDAPInstanceProvider :: Initialization status is FAILED, hence returning failure\n");
		return WBEM_E_FAILED;
	}

	m_pLogObject->WriteW( L"CLDAPInstanceProvider :: GetObjectAsync() called for %s \r\n", strObjectPath);

	HRESULT result = S_OK;
	// Impersonate the client
	if(!SUCCEEDED(result = WbemCoImpersonateClient()))
	{
		m_pLogObject->WriteW( L"CLDAPInstanceProvider :: GetObjectAsync() CoImpersonate FAILED for %s with %x\r\n", strObjectPath, result);
		return WBEM_E_FAILED;
	}

	// Validate the arguments
	if(strObjectPath == NULL)
	{
		m_pLogObject->WriteW( L"CLDAPInstanceProvider :: GetObjectAsync() argument validation FAILED\r\n");
		return WBEM_E_INVALID_PARAMETER;
	}

	// Parse the object path
	CObjectPathParser theParser;
	ParsedObjectPath *theParsedObjectPath = NULL;
	switch(theParser.Parse(strObjectPath, &theParsedObjectPath))
	{
		case CObjectPathParser::NoError:
			break;
		default:
			m_pLogObject->WriteW( L"CLDAPInstanceProvider :: GetObjectAsync() object path parsing FAILED\r\n");
			return WBEM_E_INVALID_PARAMETER;
	}

	// Check if this is for associations
	if(_wcsicmp(theParsedObjectPath->m_pClass, INSTANCE_ASSOCIATION_CLASS_STR) == 0)
	{
		// Check whether there are exactly 2 keys specified
		if(theParsedObjectPath->m_dwNumKeys != 2)
			result = WBEM_E_INVALID_PARAMETER;

		// Check whether these keys are
		KeyRef *pChildKeyRef = *(theParsedObjectPath->m_paKeys);
		KeyRef *pParentKeyRef = *(theParsedObjectPath->m_paKeys + 1);

		if(_wcsicmp(pChildKeyRef->m_pName, CHILD_INSTANCE_PROPERTY_STR) != 0)
		{
			// Exchange them
			KeyRef *temp = pChildKeyRef;
			pChildKeyRef = pParentKeyRef;
			pParentKeyRef = pChildKeyRef;
		}

		// The status on the sink
		IWbemClassObject *ppReturnWbemClassObjects[1];
		ppReturnWbemClassObjects[0] = NULL;

		if(SUCCEEDED(result))
		{
			// Convert the key values to ADSI paths
			LPWSTR pszChildADSIPath = CWBEMHelper::GetADSIPathFromObjectPath(pChildKeyRef->m_vValue.bstrVal);
			LPWSTR pszParentADSIPath = CWBEMHelper::GetADSIPathFromObjectPath(pParentKeyRef->m_vValue.bstrVal);

			if(SUCCEEDED(result = IsContainedIn(pszChildADSIPath, pszParentADSIPath)))
			{
				if(result == S_OK)
				{
					if(SUCCEEDED(result = CreateWBEMInstance(pChildKeyRef->m_vValue.bstrVal, pParentKeyRef->m_vValue.bstrVal, ppReturnWbemClassObjects)))
					{
						result = pResponseHandler->Indicate(1, ppReturnWbemClassObjects);
						ppReturnWbemClassObjects[0]->Release();
					}
				}
				else // the instance was not found
				{
					m_pLogObject->WriteW( L"CLDAPInstanceProvider :: returning WBEM_E_NOT_FOUND for %s \r\n", strObjectPath);
					result = WBEM_E_NOT_FOUND;
				}
			}
			else
			{
				m_pLogObject->WriteW( L"CLDAPInstanceProvider :: IsContainedIn() FAILED with %x \r\n", result);
			}
			delete [] pszChildADSIPath;
			delete [] pszParentADSIPath;
		}
	}
	// Check if this is for the RootDSE class
	else if(_wcsicmp(theParsedObjectPath->m_pClass, ROOTDSE_CLASS) == 0)
	{
		result = ProcessRootDSEGetObject(theParsedObjectPath->m_pClass, pResponseHandler, pCtx);
	}
	else // It is for ADSI instances
	{
		// Check whether there is exactly 1 key specified
		if(theParsedObjectPath->m_dwNumKeys != 1 )
			result = WBEM_E_INVALID_PARAMETER;

		// Get the key
		KeyRef *pKeyRef = *(theParsedObjectPath->m_paKeys);

		// Check to see that the key name is correct, if it is present
		if(pKeyRef->m_pName && _wcsicmp(pKeyRef->m_pName, ADSI_PATH_STR) != 0)
			result = WBEM_E_INVALID_PARAMETER;

		// The status on the sink
		IWbemClassObject *ppReturnWbemClassObjects[1];
		ppReturnWbemClassObjects[0] = NULL;

		if(SUCCEEDED(result))
		{
			// Get the ADSI object
			CADSIInstance *pADSIObject = NULL;
			if(SUCCEEDED(result = CLDAPHelper::GetADSIInstance(pKeyRef->m_vValue.bstrVal, &pADSIObject, m_pLogObject)))
			{
				// Get the class to spawn an instance
				IWbemClassObject *pWbemClass = NULL;
				if(SUCCEEDED(result = m_IWbemServices->GetObject(theParsedObjectPath->m_pClass, 0, pCtx, &pWbemClass, NULL)))
				{
	
					// Spawn a instance of the WBEM Class
					if(SUCCEEDED(result = pWbemClass->SpawnInstance(0, ppReturnWbemClassObjects)))
					{
						// Map it to WBEM
						if(SUCCEEDED(result = MapADSIInstance(pADSIObject, ppReturnWbemClassObjects[0], pWbemClass)))
						{
							// Indicate the result
							if(FAILED(result = pResponseHandler->Indicate(1, ppReturnWbemClassObjects)))
							{
								m_pLogObject->WriteW( L"CLDAPInstanceProvider :: GetObjectAsync : Indicate() for %s FAILED with %x \r\n", theParsedObjectPath->m_pClass, result);
							}
						}
						else
						{
							m_pLogObject->WriteW( L"CLDAPInstanceProvider :: GetObjectAsync : MapADSIInstance() for %s FAILED with %x \r\n", theParsedObjectPath->m_pClass, result);
						}
						ppReturnWbemClassObjects[0]->Release();
					}
					else
					{
						m_pLogObject->WriteW( L"CLDAPInstanceProvider :: SpawnInstance() for %s FAILED with %x \r\n", theParsedObjectPath->m_pClass, result);
					}

					pWbemClass->Release();
				}
				else
				{
					m_pLogObject->WriteW( L"CLDAPInstanceProvider :: GetObjectAsync() GetObject() for %s FAILED with %x \r\n", theParsedObjectPath->m_pClass, result);
				}
				pADSIObject->Release();
			}
			else
			{
				m_pLogObject->WriteW( L"CLDAPInstanceProvider :: GetObjectAsync : GetADSIInstance() FAILED with %x \r\n", result);
			}
		}
		else
		{
			m_pLogObject->WriteW( L"CLDAPInstanceProvider :: GetObjectAsync() Argument processing FAILED \r\n");
		}
	}

	// Free the parser object path
	theParser.Free(theParsedObjectPath);

	// Set the status of the request
	result = (SUCCEEDED(result)? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND);
	pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, result, NULL, NULL);

	if(SUCCEEDED(result))
		m_pLogObject->WriteW( L"XXXXXXXXXXXXXXXXX CLDAPInstanceProvider :: GetObjectAsync() succeeded for %s\r\n", strObjectPath);
	else
		m_pLogObject->WriteW( L"XXXXXXXXXXXXXXXXX CLDAPInstanceProvider :: GetObjectAsync() FAILED for %s\r\n", strObjectPath);
	return WBEM_S_NO_ERROR;
}

HRESULT CLDAPInstanceProvider :: PutClass(
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: PutClassAsync(
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: DeleteClass(
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: DeleteClassAsync(
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: CreateClassEnum(
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: CreateClassEnumAsync(
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: PutInstance(
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	m_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstance() called\r\n");
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: PutInstanceAsync(
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	if(!m_bInitializedSuccessfully)
	{
		m_pLogObject->WriteW( L"CLDAPInstanceProvider :: Initialization status is FAILED, hence returning failure\n");
		return WBEM_E_FAILED;
	}

	m_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstanceAsync() called\r\n");

	HRESULT result = WBEM_S_NO_ERROR;
	// Impersonate the client
	if(!SUCCEEDED(result = WbemCoImpersonateClient()))
	{
		m_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstanceAsync() CoImpersonate FAILED forwith %x\r\n", result);
		return WBEM_E_FAILED;
	}

	// Get the object ref of the instance being put
	BSTR strRelPath = NULL;
	if(SUCCEEDED(CWBEMHelper::GetBSTRProperty(pInst, RELPATH_STR, &strRelPath)))
	{
		m_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstanceAsync()  calledfor %s\r\n", strRelPath);
		// Check to see if the ADSI Path is present.
		// Parse the object path
		// Parse the object path
		CObjectPathParser theParser;
		ParsedObjectPath *theParsedObjectPath = NULL;
		LPWSTR pszADSIPath = NULL;
		LPWSTR pszWBEMClass = NULL;
		switch(theParser.Parse((LPWSTR)strRelPath, &theParsedObjectPath))
		{
			case CObjectPathParser::NoError:
			{
				KeyRef *pKeyRef = *(theParsedObjectPath->m_paKeys);
				// Check to see that there is 1 key specified and that its type is VT_BSTR
				if(pKeyRef && theParsedObjectPath->m_dwNumKeys == 1 && pKeyRef->m_vValue.vt == VT_BSTR)
				{
					// If the name of the key is specified, check the name
					if(pKeyRef->m_pName && _wcsicmp(pKeyRef->m_pName, ADSI_PATH_STR) != 0)
						break;

					pszADSIPath = new WCHAR[wcslen((*theParsedObjectPath->m_paKeys)->m_vValue.bstrVal) + 1];
					wcscpy(pszADSIPath, (*theParsedObjectPath->m_paKeys)->m_vValue.bstrVal);
					pszWBEMClass = new WCHAR[wcslen(theParsedObjectPath->m_pClass) + 1];
					wcscpy(pszWBEMClass, theParsedObjectPath->m_pClass);
				}
				break;
			}
			default:
				m_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstanceAsync() Parsing of RELPATH FAILED\r\n");
				SysFreeString(strRelPath);
				return WBEM_E_FAILED;
				break;
		}


		LPWSTR pszADSIClass = NULL;
		if(pszWBEMClass)
		{
			// CHeck to see if the class is the containment/RootDSE class, if so disallow the operation
			if(_wcsicmp(theParsedObjectPath->m_pClass, INSTANCE_ASSOCIATION_CLASS_STR) == 0 ||
				_wcsicmp(theParsedObjectPath->m_pClass, ROOTDSE_CLASS) == 0 )
			{
				result =  WBEM_E_PROVIDER_NOT_CAPABLE;
			}
			else
				pszADSIClass = CLDAPHelper::UnmangleWBEMNameToLDAP(pszWBEMClass);
		}
		// Free the parser object path
		theParser.Free(theParsedObjectPath);
		SysFreeString(strRelPath);
		delete [] pszWBEMClass;


		if(pszADSIPath && pszADSIClass && SUCCEEDED(result))
		{
			// Try to retreive the existing object
			// Get the ADSI object
			CADSIInstance *pADSIObject = NULL;
			result = CLDAPHelper::GetADSIInstance(pszADSIPath, &pADSIObject, m_pLogObject);

			// Check if the WBEM_FLAG_UPDATE_ONLY flag is specified
			if(lFlags & WBEM_FLAG_UPDATE_ONLY)
			{
				if(!pADSIObject)
					result = WBEM_E_FAILED;
			}
			// Check if the WBEM_FLAG_CREATE_ONLY flag is specified
			if(SUCCEEDED(result) && lFlags & WBEM_FLAG_CREATE_ONLY)
			{
				if(pADSIObject)
					result = WBEM_E_ALREADY_EXISTS;
			}
			else
				result = WBEM_S_NO_ERROR;

			if(SUCCEEDED(result))
			{
				if(pADSIObject)
				{
					if(SUCCEEDED(result = ModifyExistingADSIInstance(pInst, pszADSIPath, pADSIObject, pszADSIClass, pCtx)))
						m_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstanceAsync()  ModifyExistingInstance succeeded for %s\r\n", pszADSIPath);
					else
						m_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstanceAsync() ModifyExistingInstance FAILED for %s with %x\r\n", pszADSIPath, result);
				}
				else
				{
					if(SUCCEEDED(result = CreateNewADSIInstance(pInst, pszADSIPath, pszADSIClass)))
						m_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstanceAsync() CreateNewInstance succeeded for %s\r\n", pszADSIPath);
					else
						m_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstanceAsync() CreateNewInstance FAILED for %s with %x\r\n", pszADSIPath, result);
				}
			}

			// Release any existing object
			if(pADSIObject)
				pADSIObject->Release();

		}
		else
			m_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstanceAsync() one of ADSIPath or ADSIClass is NULL\r\n");

		delete [] pszADSIClass;
		delete [] pszADSIPath;
	}
	else
		m_pLogObject->WriteW( L"CLDAPInstanceProvider :: PutInstanceAsync()  FAILED to get RELPATH \r\n");

	// Set the status of the request
	result = (SUCCEEDED(result)? WBEM_S_NO_ERROR : WBEM_E_FAILED);
	pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, result, NULL, NULL);
	return result;
}

HRESULT CLDAPInstanceProvider :: DeleteInstance(
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: DeleteInstanceAsync(
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	if(!m_bInitializedSuccessfully)
	{
		m_pLogObject->WriteW( L"CLDAPInstanceProvider :: Initialization status is FAILED, hence returning failure\n");
		return WBEM_E_FAILED;
	}

	m_pLogObject->WriteW( L"CLDAPInstanceProvider :: DeleteInstanceAsync() called for %s\r\n", strObjectPath);

	HRESULT result = S_OK;
	// Impersonate the client
	if(!SUCCEEDED(result = WbemCoImpersonateClient()))
	{
		m_pLogObject->WriteW( L"CLDAPInstanceProvider :: DeleteInstanceAsync() CoImpersonate FAILED for %s with %x\r\n", strObjectPath, result);
		return WBEM_E_FAILED;
	}

	// Validate the arguments
	if(strObjectPath == NULL)
	{
		m_pLogObject->WriteW( L"CLDAPInstanceProvider :: DeleteInstanceAsync() argument validation FAILED\r\n");
		return WBEM_E_INVALID_PARAMETER;
	}

	// Parse the object path
	CObjectPathParser theParser;
	ParsedObjectPath *theParsedObjectPath = NULL;
	switch(theParser.Parse(strObjectPath, &theParsedObjectPath))
	{
		case CObjectPathParser::NoError:
			break;
		default:
			m_pLogObject->WriteW( L"CLDAPInstanceProvider :: DeleteInstanceAsync() object path parsing FAILED\r\n");
			return WBEM_E_INVALID_PARAMETER;
	}

	// CHeck to see if the class is the containment/RootDSE class, if so disallow the operation
	if(_wcsicmp(theParsedObjectPath->m_pClass, INSTANCE_ASSOCIATION_CLASS_STR) == 0 ||
		_wcsicmp(theParsedObjectPath->m_pClass, ROOTDSE_CLASS) == 0 )
	{
		result =  WBEM_E_PROVIDER_NOT_CAPABLE;
	}

	// Check whether there is exactly 1 key specified
	if(theParsedObjectPath->m_dwNumKeys != 1 )
		result = WBEM_E_INVALID_PARAMETER;

	// Get the key
	KeyRef *pKeyRef = *(theParsedObjectPath->m_paKeys);

	// Check to see that the key name is correct, if it is present
	if(pKeyRef->m_pName && _wcsicmp(pKeyRef->m_pName, ADSI_PATH_STR) != 0)
		result = WBEM_E_INVALID_PARAMETER;

	// Unfortunately, ADSI uses different interfaces to delete containers and non-containers
	// Try the containers first (IADsDeleteOps)
	// Then try the IDirectoryObject
	//=======================================================================================
	if(SUCCEEDED(result))
	{
		IADsDeleteOps *pDirectoryObject = NULL;
		if(SUCCEEDED(result = ADsOpenObject(pKeyRef->m_vValue.bstrVal, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IADsDeleteOps, (LPVOID *)&pDirectoryObject)))
		{
			if(SUCCEEDED(result = pDirectoryObject->DeleteObject(0)))
			{
			}
			else
				result = WBEM_E_FAILED;
			pDirectoryObject->Release();
		}
		else // Try the IDirectoryObject interface
		{
			IDirectoryObject *pDirectoryObject = NULL;
			if(SUCCEEDED(result = ADsOpenObject(pKeyRef->m_vValue.bstrVal, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectoryObject, (LPVOID *)&pDirectoryObject)))
			{
				PADS_OBJECT_INFO pObjectInfo = NULL;
				if(SUCCEEDED(result = pDirectoryObject->GetObjectInformation(&pObjectInfo)))
				{
					// CHeck whether it is the same class as the class being deleted.
					LPWSTR pszWbemClass = CLDAPHelper::MangleLDAPNameToWBEM(pObjectInfo->pszClassName);
					if(_wcsicmp(theParsedObjectPath->m_pClass, pszWbemClass) == 0)
					{
						// Get its parent. THis should be the container from which the child is deleted
						IDirectoryObject *pParent = NULL;
						if(SUCCEEDED(result = ADsOpenObject(pObjectInfo->pszParentDN, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectoryObject, (LPVOID *)&pParent)))
						{
							if(SUCCEEDED(result = pParent->DeleteDSObject(pObjectInfo->pszRDN)))
							{
								m_pLogObject->WriteW( L"CLDAPInstanceProvider :: DeleteInstanceAsync() Deleted %s successfully\r\n", pKeyRef->m_vValue.bstrVal);
								result = WBEM_S_NO_ERROR;
							}
							else
							{
								m_pLogObject->WriteW( L"CLDAPInstanceProvider :: DeleteInstanceAsync() DeleteDSObject FAILED on %s with %x\r\n", pKeyRef->m_vValue.bstrVal, result);
								result = WBEM_E_FAILED;
							}
							pParent->Release();
						}
						else
						{
							m_pLogObject->WriteW( L"CLDAPInstanceProvider :: DeleteInstanceAsync() ADsOpenObject on parent FAILED on %s with %x\r\n", pKeyRef->m_vValue.bstrVal, result);
							result = WBEM_E_FAILED;
						}
					}
					else
					{
						m_pLogObject->WriteW( L"CLDAPInstanceProvider :: DeleteInstanceAsync() wrong class returning success\r\n");
						result = WBEM_S_NO_ERROR;
					}

					delete [] pszWbemClass;
					FreeADsMem((LPVOID *) pObjectInfo);
				}
				else
				{
					m_pLogObject->WriteW( L"CLDAPInstanceProvider :: DeleteInstanceAsync() GetObjectInformation FAILED on %s with %x\r\n", pKeyRef->m_vValue.bstrVal, result);
					result = WBEM_E_NOT_FOUND;
				}
				pDirectoryObject->Release();
			}
			else
			{
				m_pLogObject->WriteW( L"CLDAPInstanceProvider :: DeleteInstanceAsync() ADsOpenObject FAILED on %s with %x\r\n", pKeyRef->m_vValue.bstrVal, result);
				result = WBEM_E_NOT_FOUND;
			}
		}
	}
	// Free the parser object path
	theParser.Free(theParsedObjectPath);

	pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE , result, NULL, NULL);

	return WBEM_S_NO_ERROR;
}

HRESULT CLDAPInstanceProvider :: CreateInstanceEnum(
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: CreateInstanceEnumAsync(
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	if(!m_bInitializedSuccessfully)
	{
		m_pLogObject->WriteW( L"CLDAPInstanceProvider :: Initialization status is FAILED, hence returning failure\n");
		return WBEM_E_FAILED;
	}
	m_pLogObject->WriteW( L"CLDAPInstanceProvider :: CreateInstanceEnumAsync() called for %s Class \r\n", strClass  );

	HRESULT result;
	// Impersonate the client
	if(!SUCCEEDED(result = WbemCoImpersonateClient()))
	{
		m_pLogObject->WriteW( L"CLDAPInstanceProvider :: CreateInstanceEnumAsync() CoImpersonate FAILED for %s with %x\r\n", strClass, result);
		return WBEM_E_FAILED;
	}

	// CHeck to see if the class is the containment class, if so disallow an enumeration
	if(_wcsicmp(strClass, INSTANCE_ASSOCIATION_CLASS_STR) == 0)
	{
		m_pLogObject->WriteW( L"CLDAPInstanceProvider :: CLDAPInstanceProvider() Enumeration called on the containment class. Returning FAILED : WBEM_E_PROVIDER_NOT_CAPABLE\r\n");
		return WBEM_E_PROVIDER_NOT_CAPABLE;
	}
	// Check if this is for the RootDSE class
	else if(_wcsicmp(strClass, ROOTDSE_CLASS) == 0)
	{
		result = ProcessRootDSEGetObject(strClass, pResponseHandler, pCtx);
	}
	else // The rest of the classes
	{

		// Fetch the class from CIMOM
		IWbemClassObject *pWbemClass = NULL;
		if(SUCCEEDED(result = m_IWbemServices->GetObject(strClass, 0, pCtx, &pWbemClass, NULL)))
		{
			// We need the object category information
			LPWSTR pszLDAPQuery = new WCHAR[10*(wcslen(strClass) + 25) + 50];
			if(SUCCEEDED(CWBEMHelper::FormulateInstanceQuery(m_IWbemServices, pCtx, strClass, pWbemClass, pszLDAPQuery, LDAP_DISPLAY_NAME_STR, DEFAULT_OBJECT_CATEGORY_STR)))
			{
		
				// Check to see if the client has specified any hints as to the DN of the object from
				// which the search should start
				BOOLEAN bRootDNSpecified = FALSE;
				LPWSTR *ppszRootDN = NULL;
				DWORD dwRootDNCount = 0;
				if(SUCCEEDED(GetRootDN(strClass, &ppszRootDN, &dwRootDNCount, pCtx)) && dwRootDNCount)
					bRootDNSpecified = TRUE;

				// Enumerate the ADSI Instances
				// If any RootDNs were specified, use them. Otherwise use the default naming context

				if(bRootDNSpecified)
				{
					for( DWORD i=0; i<dwRootDNCount; i++)
					{
						DoSingleQuery(strClass, pWbemClass, ppszRootDN[i], pszLDAPQuery,  pResponseHandler);
					}
				}
				else
				{
					DoSingleQuery(strClass, pWbemClass, m_lpszTopLevelContainerPath, pszLDAPQuery,  pResponseHandler);
				}

				if(bRootDNSpecified)
				{
					for(DWORD i=0; i<dwRootDNCount; i++)
					{
						delete [] ppszRootDN[i];
					}
					delete [] ppszRootDN;
				}

			}
			else
				m_pLogObject->WriteW( L"CLDAPInstanceProvider :: CreateInstanceEnumAsync : FormulateInstanceQuery() FAILED for %s with %x \r\n", strClass, result);
			delete [] pszLDAPQuery;
			pWbemClass->Release();
		}
		else
			m_pLogObject->WriteW( L"CLDAPInstanceProvider :: CreateInstanceEnumAsync : GetObject() FAILED for %s with %x \r\n", strClass, result);
	}

	if(SUCCEEDED(result))
	{
		pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_S_NO_ERROR, NULL, NULL);
		m_pLogObject->WriteW( L"XXXXXXXXXXXXX CLDAPInstanceProvider :: CreateInstanceEnumAsync() Enumeration succeeded for %s\r\n", strClass);
		return WBEM_S_NO_ERROR;
	}
	else
	{
		pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_E_FAILED, NULL, NULL);
		m_pLogObject->WriteW( L"XXXXXXXXXXXXX CLDAPInstanceProvider :: CreateInstanceEnumAsync() Enumeration FAILED for %s\r\n", strClass);
		return WBEM_S_NO_ERROR;
	}
}

HRESULT CLDAPInstanceProvider :: ExecQuery(
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: ExecQueryAsync(
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	if(!m_bInitializedSuccessfully)
	{
		m_pLogObject->WriteW( L"CLDAPInstanceProvider :: Initialization status is FAILED, hence returning failure\n");
		return WBEM_E_FAILED;
	}

	m_pLogObject->WriteW( L"CLDAPInstanceProvider :: ExecQueryAsync() called with %s\r\n", strQuery);

	HRESULT result;
	// Impersonate the client
	if(!SUCCEEDED(result = WbemCoImpersonateClient()))
	{
		m_pLogObject->WriteW( L"CLDAPInstanceProvider :: ExecQueryAsync() CoImpersonate FAILED for %s with %x\r\n", strQuery, result);
		return WBEM_E_FAILED;
	}

	// Create Parser for the Query.
    CTextLexSource src(strQuery);
    SQL1_Parser parser(&src);

    // Get the class name
    wchar_t classbuf[128];
    *classbuf = 0;
    parser.GetQueryClass(classbuf, 127);

	// Compare to see if it is the association class, Otherwise do an enuemration
	if(_wcsicmp(classbuf, INSTANCE_ASSOCIATION_CLASS_STR) != 0)
	{
		BSTR strClass = SysAllocString((LPWSTR)classbuf);

		// Ask CIMOM to postprocess the result
		pResponseHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, WBEM_S_NO_ERROR, NULL, NULL);

		// Try to process the query myself. If not successful, enumerate
		if(SUCCEEDED(result = ProcessInstanceQuery(strClass, strQuery, pCtx, pResponseHandler, &parser)))
		{
			pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_S_NO_ERROR, NULL, NULL);
		}
		else
		{
			m_pLogObject->WriteW( L"CLDAPInstanceProvider :: ExecQueryAsync() FAILED to process query %s. Resorting to enumeration\r\n", strQuery);
			CreateInstanceEnumAsync(strClass, 0, pCtx, pResponseHandler);
		}

		SysFreeString(strClass);
	}
	else
	{
		// Process query for associations
		result = ProcessAssociationQuery(pCtx, pResponseHandler, &parser);
	}

	return WBEM_S_NO_ERROR;
}

HRESULT CLDAPInstanceProvider :: ExecNotificationQuery(
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: ExecNotificationQueryAsync(
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: ExecMethod(
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CLDAPInstanceProvider :: ExecMethodAsync(
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_NOT_SUPPORTED;
}


// Maps an ADSI Instance to WBEM
HRESULT CLDAPInstanceProvider :: MapADSIInstance(CADSIInstance *pADSIObject, IWbemClassObject *pWbemObject, IWbemClassObject *pWbemClass)
{
	DWORD dwNumAttributes = 0;
	PADS_ATTR_INFO pAttributeEntries = pADSIObject->GetAttributes(&dwNumAttributes);
	HRESULT result;
	for(DWORD i=0; i<dwNumAttributes; i++)
	{
		PADS_ATTR_INFO pNextAttribute = pAttributeEntries+i;

		// Get the WBEM Property Name
		LPWSTR pszWbemName = CLDAPHelper::MangleLDAPNameToWBEM(pNextAttribute->pszAttrName);
		BSTR strWbemName = SysAllocString(pszWbemName);
		delete[] pszWbemName;

		// No point in checking the return code, except for logging
		if(SUCCEEDED(result = MapPropertyValueToWBEM(strWbemName, pWbemClass, pWbemObject, pNextAttribute)))
		{
		}
		else if( result != WBEM_E_NOT_FOUND )
		{
			m_pLogObject->WriteW( L"CLDAPInstanceProvider :: MapADSIInstance() MapPropertyValueToWBEM FAILED with %x for attribute %s\r\n", result, strWbemName);
		}
		SysFreeString(strWbemName);
	}

	// Map the key property and other properties of the base-most class
	PADS_OBJECT_INFO pObjectInfo = pADSIObject->GetObjectInfo();
	if(!SUCCEEDED(result = CWBEMHelper::PutBSTRPropertyT(pWbemObject, ADSI_PATH_STR, pObjectInfo->pszObjectDN, FALSE)))
		m_pLogObject->WriteW( L"CLDAPInstanceProvider :: MapADSIInstance() Put FAILED for Key Property  with %x\r\n", result);

	return S_OK;
}

// Gets the IDIrectoryObject interface on an ADSI instance
HRESULT CLDAPInstanceProvider :: MapPropertyValueToWBEM(BSTR strWbemName, IWbemClassObject *pWbemClass, IWbemClassObject *pWbemObject, PADS_ATTR_INFO pAttribute)
{
	// This happens in WMI Stress sometimes.
	if(pAttribute->dwADsType == ADSTYPE_INVALID || pAttribute->dwADsType == ADSTYPE_PROV_SPECIFIC)
		return E_FAIL;

	VARIANT variant;
	VariantInit(&variant);
	CIMTYPE cimType;

	// Get the CIM TYPE of the property
	VARIANT dummyUnused;
	VariantInit(&dummyUnused);

	HRESULT result = pWbemClass->Get(strWbemName, 0, &dummyUnused, &cimType, NULL);

	VariantClear(&dummyUnused);

	// Whether the value was mapped successfully;
	BOOLEAN bMappedValue = FALSE;

	if(SUCCEEDED(result))
	{
		if(cimType & CIM_FLAG_ARRAY)
		{
			switch(cimType & ~CIM_FLAG_ARRAY)
			{
				case CIM_BOOLEAN:
				{
					// Create the safe array elements
					SAFEARRAY *safeArray;
					DWORD dwLength = pAttribute->dwNumValues;
					SAFEARRAYBOUND safeArrayBounds [ 1 ];
					safeArrayBounds[0].lLbound = 0;
					safeArrayBounds[0].cElements = dwLength;
					safeArray = SafeArrayCreate(VT_BOOL, 1, safeArrayBounds);
					PADSVALUE pNextValue = pAttribute->pADsValues;
					for ( long index = 0; index<(long)dwLength; index ++ )
					{
						SafeArrayPutElement ( safeArray , &index ,  &(pNextValue->Boolean));
						pNextValue ++;
					}
					variant.vt = VT_ARRAY | VT_BOOL;
					variant.parray = safeArray;
					bMappedValue = TRUE;
					break;
				}
				case CIM_SINT32:
				{
					// Create the safe array elements
					SAFEARRAY *safeArray;
					DWORD dwLength = pAttribute->dwNumValues;
					SAFEARRAYBOUND safeArrayBounds [ 1 ];
					safeArrayBounds[0].lLbound = 0;
					safeArrayBounds[0].cElements = dwLength;
					safeArray = SafeArrayCreate(VT_I4, 1, safeArrayBounds);
					PADSVALUE pNextValue = pAttribute->pADsValues;
					for ( long index = 0; index<(long)dwLength; index ++ )
					{
						SafeArrayPutElement ( safeArray , &index ,  &(pNextValue->Integer));
						pNextValue ++;
					}
					variant.vt = VT_ARRAY | VT_I4;
					variant.parray = safeArray;
					bMappedValue = TRUE;
					break;
				}
				case CIM_SINT64:
				{
					// Create the safe array elements
					SAFEARRAY *safeArray;
					DWORD dwLength = pAttribute->dwNumValues;
					SAFEARRAYBOUND safeArrayBounds [ 1 ];
					safeArrayBounds[0].lLbound = 0;
					safeArrayBounds[0].cElements = dwLength;
					safeArray = SafeArrayCreate(VT_BSTR, 1, safeArrayBounds);
					PADSVALUE pNextValue = pAttribute->pADsValues;
					WCHAR temp[20];
					BSTR strTemp = NULL;
					for ( long index = 0; index<(long)dwLength; index ++ )
					{
						swprintf(temp, L"%I64d", (pNextValue->LargeInteger).QuadPart);
						SafeArrayPutElement ( safeArray , &index ,  strTemp = SysAllocString(temp));
						SysFreeString(strTemp);
						pNextValue ++;
					}
					variant.vt = VT_ARRAY | VT_BSTR;
					variant.parray = safeArray;
					bMappedValue = TRUE;
					break;
				}
				case CIM_STRING:
				{
					// Create the safe array elements
					SAFEARRAY *safeArray;
					DWORD dwLength = pAttribute->dwNumValues;
					SAFEARRAYBOUND safeArrayBounds [ 1 ];
					safeArrayBounds[0].lLbound = 0;
					safeArrayBounds[0].cElements = dwLength;
					safeArray = SafeArrayCreate(VT_BSTR, 1, safeArrayBounds);
					PADSVALUE pNextValue = pAttribute->pADsValues;
					BSTR strTemp = NULL;
					for ( long index = 0; index<(long)dwLength; index ++ )
					{
						SafeArrayPutElement ( safeArray , &index ,  strTemp = SysAllocString(pNextValue->DNString));
						SysFreeString(strTemp);
						pNextValue ++;
					}
					variant.vt = VT_ARRAY | VT_BSTR;
					variant.parray = safeArray;
					bMappedValue = TRUE;
					break;
				}

				case CIM_DATETIME:
				{
					// Create the safe array elements
					SAFEARRAY *safeArray;
					DWORD dwLength = pAttribute->dwNumValues;
					SAFEARRAYBOUND safeArrayBounds [ 1 ];
					safeArrayBounds[0].lLbound = 0;
					safeArrayBounds[0].cElements = dwLength;
					safeArray = SafeArrayCreate(VT_BSTR, 1, safeArrayBounds);
					PADSVALUE pNextValue = pAttribute->pADsValues;
					BSTR strTemp = NULL;
					for ( long index = 0; index<(long)dwLength; index ++ )
					{
						WBEMTime wbemValue(pNextValue->UTCTime);
						SafeArrayPutElement ( safeArray , &index ,  strTemp = wbemValue.GetDMTF(TRUE));
						SysFreeString(strTemp);
						pNextValue ++;
					}
					variant.vt = VT_ARRAY | VT_BSTR;
					variant.parray = safeArray;
					bMappedValue = TRUE;
					break;
				}

				case CIM_OBJECT:
				{
					// Get its cimType Qualifier to determine the "type" of the embedded object
					IWbemQualifierSet *pQualifierSet = NULL;
					if(SUCCEEDED(pWbemClass->GetPropertyQualifierSet(strWbemName, &pQualifierSet)))
					{
						LPWSTR pszQualifierValue = NULL;
						if(SUCCEEDED(CWBEMHelper::GetBSTRQualifierT(pQualifierSet, CIMTYPE_STR, &pszQualifierValue, NULL)))
						{

							// Create the safe array elements
							SAFEARRAY *safeArray;
							DWORD dwLength = pAttribute->dwNumValues;
							SAFEARRAYBOUND safeArrayBounds [ 1 ];
							safeArrayBounds[0].lLbound = 0;
							safeArrayBounds[0].cElements = dwLength;
							safeArray = SafeArrayCreate(VT_UNKNOWN, 1, safeArrayBounds);
							PADSVALUE pNextValue = pAttribute->pADsValues;
							IUnknown *pNextObject = NULL;
							for ( long index = 0; index<(long)dwLength; index ++ )
							{
								// Put the Embedded object in the array
								if(SUCCEEDED(MapEmbeddedObjectToWBEM(pNextValue, pszQualifierValue, &pNextObject)))
								{
									SafeArrayPutElement ( safeArray , &index ,  pNextObject);
									pNextObject->Release();
									pNextObject = NULL;
								}
								else
									break;

								pNextValue ++;
							}
							variant.vt = VT_ARRAY | VT_UNKNOWN;
							variant.parray = safeArray;
							if(index == (long)dwLength)
								bMappedValue = TRUE;

							delete[] pszQualifierValue;
						}
						pQualifierSet->Release();
					}
					break;
				}
				default:
					break;
			}
		}
		else
		{
			switch(cimType)
			{
			case CIM_BOOLEAN:
				variant.vt = VT_BOOL;
				variant.boolVal = (pAttribute->pADsValues->Boolean)? VARIANT_TRUE : VARIANT_FALSE;
				bMappedValue = TRUE;
				break;

			case CIM_SINT32:
				variant.vt = VT_I4;
				variant.lVal = pAttribute->pADsValues->Integer;
				bMappedValue = TRUE;
				break;

			case CIM_SINT64:
				variant.vt = VT_BSTR;
				WCHAR temp[20];
				swprintf(temp, L"%I64d", (pAttribute->pADsValues->LargeInteger).QuadPart);
				variant.bstrVal = SysAllocString(temp);
				bMappedValue = TRUE;
				break;

			case CIM_STRING:
				variant.vt = VT_BSTR;
				if(pAttribute->pADsValues->DNString)
				{
					variant.bstrVal = SysAllocString(pAttribute->pADsValues->DNString);
					bMappedValue = TRUE;
				}
				break;

			case CIM_OBJECT:
			{
				// Get its cimType Qualifier to determine the "type" of the embedded object
				IWbemQualifierSet *pQualifierSet = NULL;
				if(SUCCEEDED(pWbemClass->GetPropertyQualifierSet(strWbemName, &pQualifierSet)))
				{
					LPWSTR pszQualifierValue = NULL;
					if(SUCCEEDED(CWBEMHelper::GetBSTRQualifierT(pQualifierSet, CIMTYPE_STR, &pszQualifierValue, NULL)))
					{
						IUnknown *pEmbeddedObject = NULL;
						if(SUCCEEDED(MapEmbeddedObjectToWBEM(pAttribute->pADsValues, pszQualifierValue, &pEmbeddedObject)))
						{
							variant.vt = VT_UNKNOWN;
							variant.punkVal = pEmbeddedObject;
							bMappedValue = TRUE;
						}

						delete[] pszQualifierValue;
					}
					pQualifierSet->Release();
				}

			}
			break;

			case CIM_DATETIME:
			{
				variant.vt = VT_BSTR;
				WBEMTime wbemValue(pAttribute->pADsValues->UTCTime);
				if(variant.bstrVal = wbemValue.GetDMTF(TRUE))
					bMappedValue = TRUE;
			}
			break;

			default:
				break;
			}
		}
	}


	if(bMappedValue && FAILED(result = pWbemObject->Put(strWbemName, 0, &variant, NULL)))
		m_pLogObject->WriteW( L"CLDAPInstanceProvider :: MapADSIInstance() Put FAILED for %s with %x\r\n", strWbemName, result);

	VariantClear(&variant);
	return result;
}

HRESULT CLDAPInstanceProvider :: MapEmbeddedObjectToWBEM(PADSVALUE pAttribute, LPCWSTR pszQualifierName, IUnknown **ppEmbeddedObject)
{
	HRESULT result = WBEM_E_FAILED;

	// Skip the "object:" prefix while comparing
	//===========================================
	if (_wcsicmp(pszQualifierName+7, UINT8ARRAY_STR) == 0)
		result = MapUint8ArrayToWBEM(pAttribute, ppEmbeddedObject);
	else if(_wcsicmp(pszQualifierName+7, DN_WITH_BINARY_CLASS_STR) == 0)
		result = MapDNWithBinaryToWBEM(pAttribute, ppEmbeddedObject);
	else if (_wcsicmp(pszQualifierName+7, DN_WITH_STRING_CLASS_STR) == 0)
		result = MapDNWithStringToWBEM(pAttribute, ppEmbeddedObject);
	else
		result = E_FAIL;
	return result;
}

HRESULT CLDAPInstanceProvider :: MapUint8ArrayToWBEM(PADSVALUE pAttribute, IUnknown **ppEmbeddedObject)
{
	HRESULT result = E_FAIL;

	*ppEmbeddedObject = NULL;
	IWbemClassObject *pEmbeddedObject;
	if(SUCCEEDED(result = m_pWbemUin8ArrayClass->SpawnInstance(0, &pEmbeddedObject)))
	{
		if(SUCCEEDED(result = MapByteArray((pAttribute->OctetString).lpValue ,(pAttribute->OctetString).dwLength, VALUE_PROPERTY_STR, pEmbeddedObject)))
		{
			// Get the IUnknown interface of the embedded object
			if(SUCCEEDED(result = pEmbeddedObject->QueryInterface(IID_IUnknown, (LPVOID *)ppEmbeddedObject)))
			{
			}
		}
		pEmbeddedObject->Release();
	}
	return result;
}

HRESULT CLDAPInstanceProvider :: MapByteArray(LPBYTE lpBinaryValue, DWORD dwLength, const BSTR strPropertyName, IWbemClassObject *pInstance)
{
	HRESULT result = E_FAIL;
	// Create the safe array of uint8 elements
	SAFEARRAY *safeArray = NULL;
	SAFEARRAYBOUND safeArrayBounds [ 1 ];
	safeArrayBounds[0].lLbound = 0;
	safeArrayBounds[0].cElements = dwLength;
	safeArray = SafeArrayCreate(VT_UI1, 1, safeArrayBounds);
	for ( long index = 0; index<(long)dwLength; index ++ )
	{
		SafeArrayPutElement ( safeArray , &index ,  lpBinaryValue+index);
	}
	VARIANT embeddedVariant;
	VariantInit(&embeddedVariant);
	embeddedVariant.vt = VT_ARRAY | VT_UI1;
	embeddedVariant.parray = safeArray;

	result = pInstance->Put(strPropertyName, 0, &embeddedVariant, 0);
	VariantClear(&embeddedVariant);

	return result;
}

HRESULT CLDAPInstanceProvider :: MapDNWithBinaryToWBEM(PADSVALUE pAttribute, IUnknown **ppEmbeddedObject)
{
	
	HRESULT result = E_FAIL;
	IWbemClassObject *pEmbeddedObject;
	if(SUCCEEDED(result = m_pWbemDNWithBinaryClass->SpawnInstance(0, &pEmbeddedObject)))
	{
		if(pAttribute->pDNWithBinary->pszDNString && SUCCEEDED(result = CWBEMHelper::PutBSTRProperty(pEmbeddedObject, DN_STRING_PROPERTY_STR, SysAllocString(pAttribute->pDNWithBinary->pszDNString), TRUE)))
		{
			if(SUCCEEDED(result = MapByteArray(pAttribute->pDNWithBinary->lpBinaryValue, pAttribute->pDNWithBinary->dwLength, VALUE_PROPERTY_STR, pEmbeddedObject)))
			{
				// Get the IUnknown interface of the embedded object
				if(SUCCEEDED(result = pEmbeddedObject->QueryInterface(IID_IUnknown, (LPVOID *)ppEmbeddedObject)))
				{
				}
			}
		}
		pEmbeddedObject->Release();
	}
	return result;
}

HRESULT CLDAPInstanceProvider :: MapDNWithStringToWBEM(PADSVALUE pAttribute, IUnknown **ppEmbeddedObject)
{
	HRESULT result = E_FAIL;

	IWbemClassObject *pEmbeddedObject;
	if(SUCCEEDED(result = m_pWbemDNWithStringClass->SpawnInstance(0, &pEmbeddedObject)))
	{

		if(pAttribute->pDNWithString->pszDNString && SUCCEEDED(result = CWBEMHelper::PutBSTRProperty(pEmbeddedObject, DN_STRING_PROPERTY_STR, SysAllocString(pAttribute->pDNWithString->pszDNString), TRUE)))
		{
			if(pAttribute->pDNWithString->pszStringValue && SUCCEEDED(result = CWBEMHelper::PutBSTRProperty(pEmbeddedObject, VALUE_PROPERTY_STR, SysAllocString(pAttribute->pDNWithString->pszStringValue), TRUE)))
			{
				// Get the IUnknown interface of the embedded object
				if(SUCCEEDED(result = pEmbeddedObject->QueryInterface(IID_IUnknown, (LPVOID *)ppEmbeddedObject)))
				{
				}
			}
		}
		pEmbeddedObject->Release();
	}
	return result;
}


//***************************************************************************
//
// CLDAPInstanceProvider::IsContainedIn
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: IsContainedIn(LPCWSTR pszChildInstance, LPCWSTR pszParentInstance)
{
	IDirectoryObject *pDirectoryObject = NULL;
	HRESULT result = S_FALSE;
	if(SUCCEEDED(result = ADsOpenObject((LPWSTR)pszChildInstance, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectoryObject, (LPVOID *) &pDirectoryObject)))
	{
		PADS_OBJECT_INFO pObjectInfo = NULL;
		if(SUCCEEDED(result = pDirectoryObject->GetObjectInformation(&pObjectInfo)))
		{
			if(_wcsicmp(pszParentInstance, pObjectInfo->pszParentDN) == 0)
				result = S_OK;
			else
				result = S_FALSE;
			FreeADsMem((LPVOID *)pObjectInfo);
		}
		pDirectoryObject->Release();
	}
	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::CreateWBEMInstance
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: CreateWBEMInstance(BSTR strChildName, BSTR strParentName, IWbemClassObject **ppInstance)
{
	HRESULT result;
	if(SUCCEEDED(result = m_pAssociationsClass->SpawnInstance(0, ppInstance)))
	{
		// Put the property values
		if(SUCCEEDED(result = CWBEMHelper::PutBSTRProperty(*ppInstance, CHILD_INSTANCE_PROPERTY_STR, strChildName, FALSE)))
		{
			if(SUCCEEDED(result = CWBEMHelper::PutBSTRProperty(*ppInstance, PARENT_INSTANCE_PROPERTY_STR, strParentName, FALSE)))
			{
			}
			else
				m_pLogObject->WriteW( L"CLDAPInstanceProvider :: CreateWBEMInstance() PutBSTRProperty on parent property FAILED %x \r\n", result);
		}
		else
			m_pLogObject->WriteW( L"CLDAPInstanceProvider :: CreateWBEMInstance() PutBSTRProperty on child property FAILED %x \r\n", result);
	}
	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::DoChildContainmentQuery
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: DoChildContainmentQuery(LPCWSTR pszChildPath, IWbemObjectSink *pResponseHandler, CNamesList *pListIndicatedSoFar)
{
	IDirectoryObject *pChildObject = NULL;
	HRESULT result = S_FALSE;
	if(SUCCEEDED(result = ADsOpenObject((LPWSTR)pszChildPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectoryObject, (LPVOID *) &pChildObject)))
	{
		PADS_OBJECT_INFO pChildInfo = NULL;
		if(SUCCEEDED(result = pChildObject->GetObjectInformation(&pChildInfo)))
		{
			IDirectoryObject *pParentObject = NULL;
			if(SUCCEEDED(result = ADsOpenObject(pChildInfo->pszParentDN, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectoryObject, (LPVOID *) &pParentObject)))
			{
				PADS_OBJECT_INFO pParentInfo = NULL;
				if(SUCCEEDED(result = pParentObject->GetObjectInformation(&pParentInfo)))
				{
					IWbemClassObject *pAssociationInstance = NULL;
					// Get the WBEM names of the LDAP classes
					LPWSTR pszChildClassWbemName = CLDAPHelper::MangleLDAPNameToWBEM(pChildInfo->pszClassName);
					LPWSTR pszParentClassWbemName = CLDAPHelper::MangleLDAPNameToWBEM(pParentInfo->pszClassName);
					BSTR strChildPath = CWBEMHelper::GetObjectRefFromADSIPath(pszChildPath, pszChildClassWbemName);
					BSTR strParentPath = CWBEMHelper::GetObjectRefFromADSIPath(pParentInfo->pszObjectDN, pszParentClassWbemName);
					delete [] pszChildClassWbemName;
					delete [] pszParentClassWbemName;

					// Check to see if it has already been indicated
					LPWSTR pszCombinedName = new WCHAR[wcslen(pszChildPath) + wcslen(pParentInfo->pszObjectDN) + 1];
					wcscpy(pszCombinedName,pszChildPath);
					wcscat(pszCombinedName,pParentInfo->pszObjectDN);
					if(!pListIndicatedSoFar->IsNamePresent(pszCombinedName))
					{
						if(SUCCEEDED(result = CreateWBEMInstance(strChildPath, strParentPath, &pAssociationInstance)))
						{
							result = pResponseHandler->Indicate(1, &pAssociationInstance);
							pAssociationInstance->Release();

							// Add it to the list of objects indicated so far
							pListIndicatedSoFar->AddName(pszCombinedName);
						}
					}
					delete [] pszCombinedName;
					SysFreeString(strChildPath);
					SysFreeString(strParentPath);
					FreeADsMem((LPVOID *)pParentInfo);
				}

				pParentObject->Release();
			}
			FreeADsMem((LPVOID *)pChildInfo);
		}
		pChildObject->Release();
	}
	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::DoParentContainmentQuery
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: DoParentContainmentQuery(LPCWSTR pszParentPath, IWbemObjectSink *pResponseHandler, CNamesList *pListIndicatedSoFar)
{
	// We *have* to use the IADs interfaces since there are no container in
	IADsContainer *pContainer = NULL;
	IADs *pChild = NULL;
	VARIANT variant;
	VariantInit(&variant);
	HRESULT result;
	if(SUCCEEDED(result = ADsOpenObject((LPWSTR)pszParentPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IADsContainer, (LPVOID *) &pContainer)))
	{
		IADs *pParent = NULL;
		if(SUCCEEDED(result = pContainer->QueryInterface(IID_IADs, (LPVOID *)&pParent)))
		{
			BSTR strParentClass = NULL;
			if(SUCCEEDED(result = pParent->get_Class(&strParentClass)))
			{
				// Get the WBEM names of the LDAP class
				LPWSTR pszParentClassWbemName = CLDAPHelper::MangleLDAPNameToWBEM(strParentClass);
				BSTR strParentWBEMPath = CWBEMHelper::GetObjectRefFromADSIPath(pszParentPath, pszParentClassWbemName);
				delete [] pszParentClassWbemName;
				SysFreeString(strParentClass);
				IEnumVARIANT *pEnum = NULL;
				if(SUCCEEDED(result = ADsBuildEnumerator(pContainer, &pEnum)))
				{
					while(SUCCEEDED(result = ADsEnumerateNext(pEnum, 1, &variant, NULL)) && result != S_FALSE)
					{
						if(SUCCEEDED(result = (variant.pdispVal)->QueryInterface(IID_IADs, (LPVOID *)&pChild)))
						{
							BSTR strChildADSIPath = NULL;
							if(SUCCEEDED(result = pChild->get_ADsPath(&strChildADSIPath)))
							{
								BSTR strChildClass = NULL;
								if(SUCCEEDED(result = pChild->get_Class(&strChildClass)))
								{
									// Create an instance of the association class
									IWbemClassObject *pAssociationInstance = NULL;
									// Get the WBEM Name oo the child class
									LPWSTR pszChildClassWbemName = CLDAPHelper::MangleLDAPNameToWBEM(strChildClass);
									BSTR strChildWBEMPath = CWBEMHelper::GetObjectRefFromADSIPath(strChildADSIPath, pszChildClassWbemName);
									delete [] pszChildClassWbemName;

									// Check to see if it has already been indicated
									LPWSTR pszCombinedName = new WCHAR[wcslen(strChildADSIPath) + wcslen(pszParentPath) + 1];
									wcscpy(pszCombinedName,strChildADSIPath);
									wcscat(pszCombinedName,pszParentPath);

									if(!pListIndicatedSoFar->IsNamePresent(pszCombinedName))
									{
										if(SUCCEEDED(result = CreateWBEMInstance(strChildWBEMPath, strParentWBEMPath, &pAssociationInstance)))
										{
											result = pResponseHandler->Indicate(1, &pAssociationInstance);
											pAssociationInstance->Release();

											// Add it to the list of objects indicated so far
											pListIndicatedSoFar->AddName(pszCombinedName);
										}
									}
									delete [] pszCombinedName;
									SysFreeString(strChildClass);
									SysFreeString(strChildWBEMPath);
								}
								SysFreeString(strChildADSIPath);
							}
							pChild->Release();
						}

						VariantClear(&variant);
						VariantInit(&variant);
					}
					ADsFreeEnumerator(pEnum);
				}
				SysFreeString(strParentWBEMPath);
			}
			pParent->Release();
		}
		pContainer->Release();
	}
	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::ModifyExistingADSIInstance
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: ModifyExistingADSIInstance(IWbemClassObject *pWbemInstance,
															LPCWSTR pszADSIPath,
															CADSIInstance *pExistingObject,
															LPCWSTR pszADSIClass,
															IWbemContext *pCtx)
{
	HRESULT result = S_OK;
	BOOLEAN bPartialUpdate = FALSE;
	DWORD dwPartialUpdateCount = 0;
	BSTR *pstrProperyNames = NULL;
	SAFEARRAY *pArray = NULL;
	// See if the partial property list is indicated in the context
	VARIANT v1, v2;
	if(SUCCEEDED(result = pCtx->GetValue(PUT_EXTENSIONS_STR, 0, &v1)))
	{
		if(SUCCEEDED(result = pCtx->GetValue(PUT_EXT_PROPERTIES_STR, 0, &v2)))
		{

			switch(v2.vt)
			{
				case VT_BSTR | VT_ARRAY:
				{
					pArray = v2.parray;
					LONG lUbound = 0, lLbound = 0;
					if(SUCCEEDED(result = SafeArrayAccessData(pArray, (void HUGEP* FAR*)&pstrProperyNames) ) &&
						SUCCEEDED (result = SafeArrayGetLBound(pArray, 1, &lLbound)) &&
						SUCCEEDED (result = SafeArrayGetUBound(pArray, 1, &lUbound)) )
					{
						dwPartialUpdateCount = lUbound - lLbound + 1;
						bPartialUpdate = TRUE;
					}
				}
				break;
				default:
					result = WBEM_E_FAILED;
					break;
			}
		}
		VariantClear(&v1);
	}
	else
		result = S_OK; // Reset it, there was no request for partial update

	if (FAILED(result))
		return WBEM_E_FAILED;

	// Find the number of properties first by doing an enumeration
	if(SUCCEEDED(result = pWbemInstance->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY)))
	{
		DWORD dwNumProperties = 0;
		while(SUCCEEDED(result = pWbemInstance->Next(0, NULL, NULL, NULL, NULL)) && result != WBEM_S_NO_MORE_DATA )
			dwNumProperties ++;
		pWbemInstance->EndEnumeration();

		// Allocate ADSI structures for these properties
		PADS_ATTR_INFO pAttributeEntries = new ADS_ATTR_INFO [dwNumProperties];

		// Now go thru each wbem property and map it
		if(SUCCEEDED(result = pWbemInstance->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY)))
		{
			DWORD dwNumPropertiesMapped = 0;
			BSTR strPropertyName = NULL;
			VARIANT vPropertyValue;
			CIMTYPE cType;
			LONG lFlavour;

			while(SUCCEEDED(result = pWbemInstance->Next(0,  &strPropertyName, &vPropertyValue, &cType, &lFlavour)) && result != WBEM_S_NO_MORE_DATA )
			{
				// Skip those properties that should not go to ADSI
				if(_wcsicmp(strPropertyName, ADSI_PATH_STR) == 0 )
				{
				}
				else // Map the property to ADSI
				{
					BOOLEAN bMapProperty = FALSE;
					if(bPartialUpdate)
					{
						if(CWBEMHelper::IsPresentInBstrList(pstrProperyNames, dwPartialUpdateCount, strPropertyName))
							bMapProperty = TRUE;
					}
					else
						bMapProperty = TRUE;

					if(bMapProperty)
					{

						if(vPropertyValue.vt == VT_NULL)
						{
							(pAttributeEntries + dwNumPropertiesMapped)->dwControlCode = ADS_ATTR_CLEAR;
							(pAttributeEntries + dwNumPropertiesMapped)->pszAttrName = CLDAPHelper::UnmangleWBEMNameToLDAP(strPropertyName);
							dwNumPropertiesMapped ++;
						}
						else if(SUCCEEDED(MapPropertyValueToADSI(pWbemInstance, strPropertyName, vPropertyValue, cType, lFlavour,  pAttributeEntries + dwNumPropertiesMapped)))
						{
							// Set the "attribute has been modified" flag
							(pAttributeEntries + dwNumPropertiesMapped)->dwControlCode = ADS_ATTR_UPDATE;
							dwNumPropertiesMapped ++;
						}
						else
							m_pLogObject->WriteW( L"CLDAPInstanceProvider :: ModifyExistingADSIInstance() MapPropertyValueToADSI FAILED %x for %s\r\n", result, strPropertyName);
					}
					else
						m_pLogObject->WriteW( L"CLDAPInstanceProvider :: ModifyExistingADSIInstance() Skipping %s since it is not in Context list\r\n", strPropertyName);
				}

				SysFreeString(strPropertyName);
				VariantClear(&vPropertyValue);
			}
			pWbemInstance->EndEnumeration();

			// Logging
			m_pLogObject->WriteW( L"CLDAPInstanceProvider :: The %d attributes being put are:\r\n", dwNumPropertiesMapped);
			for(DWORD i=0; i<dwNumPropertiesMapped; i++)
				m_pLogObject->WriteW( L"%s\r\n", (pAttributeEntries + i)->pszAttrName);

			// Get the actual object from ADSI to find out which attributes have changed.
			DWORD dwNumModified = 0;
			IDirectoryObject *pDirectoryObject = pExistingObject->GetDirectoryObject();
			if(SUCCEEDED(result = pDirectoryObject->SetObjectAttributes(pAttributeEntries, dwNumPropertiesMapped, &dwNumModified)))
			{
			}
			else
				m_pLogObject->WriteW( L"CLDAPInstanceProvider :: SetObjectAttributes FAILED with %x\r\n", result);
			pDirectoryObject->Release();

			// Delete the contents of each of the attributes
			for(i=0; i<dwNumPropertiesMapped; i++)
			{
				if((pAttributeEntries + i)->dwControlCode != ADS_ATTR_CLEAR)
					CLDAPHelper::DeleteAttributeContents(pAttributeEntries + i);
			}
		}

		delete [] pAttributeEntries;
	}

	if(bPartialUpdate)
	{
		SafeArrayUnaccessData(pArray);
		VariantClear(&v2);
	}


	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::CreateNewADSIInstance
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: CreateNewADSIInstance(IWbemClassObject *pWbemInstance, LPCWSTR pszADSIPath, LPCWSTR pszADSIClass)
{
	// Find the ADSI path of the parent and the RDN of the child
	BSTR strRDNName = NULL;
	BSTR strParentADSIPath = NULL;
	BSTR strParentADSIPathWithoutLDAP = NULL;
	BSTR strParentPlusRDNADSIPath = NULL;
	HRESULT result = WBEM_E_FAILED;

	// Get the parentADSI path and RDN from the ADSI Path
	IADsPathname *pADsPathName = NULL;
	BSTR strADSIPath = SysAllocString(pszADSIPath);
	if(SUCCEEDED(result = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_ALL, IID_IADsPathname, (LPVOID *)&pADsPathName)))
	{
		if(SUCCEEDED(result = pADsPathName->Set(strADSIPath, ADS_SETTYPE_FULL)))
		{
			// This gives "<Parent>" without the "LDAP://" prefix
			if(SUCCEEDED(result = pADsPathName->Retrieve(ADS_FORMAT_X500_PARENT, &strParentADSIPathWithoutLDAP)))
			{
				// This gives "CN=Administrator,<Parent>"
				if(SUCCEEDED(result = pADsPathName->Retrieve(ADS_FORMAT_X500_DN, &strParentPlusRDNADSIPath)))
				{
					// Form the RDN - Dont ignore the comma.
					DWORD dwRDNLength = wcslen(strParentPlusRDNADSIPath) - wcslen(strParentADSIPathWithoutLDAP);
					LPWSTR pszRDN = new WCHAR [dwRDNLength];
					wcsncpy(pszRDN, strParentPlusRDNADSIPath, dwRDNLength-1);
					pszRDN[dwRDNLength-1] = NULL;
					strRDNName = SysAllocString(pszRDN);
					delete [] pszRDN;

					LPWSTR pszParentADSIPath  = new WCHAR[wcslen(strParentADSIPathWithoutLDAP) + wcslen(LDAP_PREFIX) + 1];
					wcscpy(pszParentADSIPath, LDAP_PREFIX);
					wcscat(pszParentADSIPath, strParentADSIPathWithoutLDAP);
					strParentADSIPath = SysAllocString(pszParentADSIPath);
					delete [] pszParentADSIPath;

					// Find the number of properties first by doing an enumeration
					if(SUCCEEDED(result = pWbemInstance->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY)))
					{
						DWORD dwNumProperties = 0;
						while(SUCCEEDED(result = pWbemInstance->Next(0, NULL, NULL, NULL, NULL)) && result != WBEM_S_NO_MORE_DATA )
							dwNumProperties ++;
						pWbemInstance->EndEnumeration();

						// Allocate ADSI structures for these properties. An additional one for the "objectclass" property
						PADS_ATTR_INFO pAttributeEntries = new ADS_ATTR_INFO [dwNumProperties + 1];

						// Now go thru each wbem property and map it
						if(SUCCEEDED(result = pWbemInstance->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY)))
						{
							DWORD dwNumPropertiesMapped = 0;
							BSTR strPropertyName = NULL;
							VARIANT vPropertyValue;
							CIMTYPE cType;
							LONG lFlavour;

							while(SUCCEEDED(result = pWbemInstance->Next(0,  &strPropertyName, &vPropertyValue, &cType, &lFlavour)) && result != WBEM_S_NO_MORE_DATA )
							{
								if(vPropertyValue.vt != VT_NULL)
								{
									// Skip those properties that should not go to ADSI
									if(_wcsicmp(strPropertyName, ADSI_PATH_STR) == 0 ||
										_wcsicmp(strPropertyName, OBJECT_CLASS_PROPERTY) == 0)
									{
									}
									else // Map the property to ADSI
									{
										if(SUCCEEDED(MapPropertyValueToADSI(pWbemInstance, strPropertyName, vPropertyValue, cType, lFlavour,  pAttributeEntries + dwNumPropertiesMapped)))
											dwNumPropertiesMapped ++;
										else
											m_pLogObject->WriteW( L"CLDAPInstanceProvider :: CreateNewADSIInstance() MapPropertyValueToADSI FAILED %x for %s\r\n", result, strPropertyName);
									}
								}

								SysFreeString(strPropertyName);
								VariantClear(&vPropertyValue);
							}
							pWbemInstance->EndEnumeration();


							// Set the objectClass attribute too
							SetObjectClassAttribute(pAttributeEntries + dwNumPropertiesMapped, pszADSIClass);
							dwNumPropertiesMapped++;


							// Now get the parent ADSI object
							IDirectoryObject *pParentObject = NULL;
							if(SUCCEEDED(result = ADsOpenObject(strParentADSIPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectoryObject, (LPVOID *)&pParentObject)))
							{
								if(SUCCEEDED(result = pParentObject->CreateDSObject(strRDNName, pAttributeEntries, dwNumPropertiesMapped, NULL)))
								{
								}
								else
									m_pLogObject->WriteW( L"CLDAPInstanceProvider :: CreateDSObject on parent FAILED with %x\r\n", result);
								pParentObject->Release();
							}
							else
								m_pLogObject->WriteW( L"CLDAPInstanceProvider :: ADsOpenObject on parent %s FAILED with %x\r\n", strParentADSIPath, result);

							// Delete the contents of each of the attributes
							for(DWORD i=0; i<dwNumPropertiesMapped; i++)
								CLDAPHelper::DeleteAttributeContents(pAttributeEntries + i);

						}

						delete [] pAttributeEntries;
					}
					SysFreeString(strParentPlusRDNADSIPath);
					SysFreeString(strParentADSIPath);
				}
				SysFreeString(strParentADSIPathWithoutLDAP);
			}
		}

		pADsPathName->Release();
	}
	else
		m_pLogObject->WriteW( L"CLDAPInstanceProvider :: CoCreateInstance() on IADsPathName FAILED %x\r\n", result);

	SysFreeString(strADSIPath);
	return result;
}


//***************************************************************************
//
// CLDAPInstanceProvider::MapPropertyValueToADSI
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: MapPropertyValueToADSI(IWbemClassObject *pWbemInstance, BSTR strPropertyName, VARIANT vPropertyValue, CIMTYPE cType, LONG lFlavour,  PADS_ATTR_INFO pAttributeEntry)
{
	// Set its fields to 0;
	memset((LPVOID)pAttributeEntry, 0, sizeof(ADS_ATTR_INFO));

	HRESULT result = E_FAIL;

	// Set the name
	pAttributeEntry->pszAttrName = CLDAPHelper::UnmangleWBEMNameToLDAP(strPropertyName);
	IWbemQualifierSet *pQualifierSet = NULL;

	if(SUCCEEDED(result = pWbemInstance->GetPropertyQualifierSet(strPropertyName, &pQualifierSet)))
	{
		// Get its attributeSyntax qualifer
		LPWSTR pszAttributeSyntax = NULL;
		if(SUCCEEDED(CWBEMHelper::GetBSTRQualifierT(pQualifierSet, ATTRIBUTE_SYNTAX_STR, &pszAttributeSyntax, NULL)))
		{
			if(_wcsicmp(pszAttributeSyntax, DISTINGUISHED_NAME_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_DN_STRING;
				result = SetStringValues(pAttributeEntry, ADSTYPE_DN_STRING, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, OBJECT_IDENTIFIER_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_CASE_IGNORE_STRING;
				result = SetStringValues(pAttributeEntry, ADSTYPE_DN_STRING, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, CASE_SENSITIVE_STRING_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_CASE_EXACT_STRING;
				result = SetStringValues(pAttributeEntry, ADSTYPE_CASE_EXACT_STRING, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, CASE_INSENSITIVE_STRING_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_CASE_IGNORE_STRING;
				result = SetStringValues(pAttributeEntry, ADSTYPE_CASE_IGNORE_STRING, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, PRINT_CASE_STRING_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_PRINTABLE_STRING;
				result = SetStringValues(pAttributeEntry, ADSTYPE_PRINTABLE_STRING, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, NUMERIC_STRING_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_NUMERIC_STRING;
				result = SetStringValues(pAttributeEntry, ADSTYPE_NUMERIC_STRING, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, DN_WITH_STRING_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_DN_WITH_STRING;
				result = SetDNWithStringValues(pAttributeEntry, ADSTYPE_DN_WITH_STRING, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, DN_WITH_BINARY_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_DN_WITH_BINARY;
				result = SetDNWithBinaryValues(pAttributeEntry, ADSTYPE_DN_WITH_BINARY, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, BOOLEAN_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_BOOLEAN;
				result = SetBooleanValues(pAttributeEntry, ADSTYPE_BOOLEAN, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, INTEGER_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_INTEGER;
				result = SetIntegerValues(pAttributeEntry, ADSTYPE_INTEGER, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, OCTET_STRING_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_OCTET_STRING;
				result = SetOctetStringValues(pAttributeEntry, ADSTYPE_OCTET_STRING, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, TIME_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_CASE_IGNORE_STRING;
				result = SetTimeValues(pAttributeEntry, ADSTYPE_CASE_IGNORE_STRING, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, UNICODE_STRING_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_CASE_IGNORE_STRING;
				result = SetStringValues(pAttributeEntry, ADSTYPE_DN_STRING, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, NT_SECURITY_DESCRIPTOR_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
				result = SetOctetStringValues(pAttributeEntry, ADSTYPE_NT_SECURITY_DESCRIPTOR, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, LARGE_INTEGER_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_LARGE_INTEGER;
				result = SetLargeIntegerValues(pAttributeEntry, ADSTYPE_LARGE_INTEGER, &vPropertyValue);
			}
			else if(_wcsicmp(pszAttributeSyntax, SID_OID) == 0)
			{
				pAttributeEntry->dwADsType = ADSTYPE_OCTET_STRING;
				result = SetOctetStringValues(pAttributeEntry, ADSTYPE_OCTET_STRING, &vPropertyValue);
			}
			else
			{
				m_pLogObject->WriteW( L"CLDAPInstanceProvider :: MapPropertyValueToADSI() Unknown attributeSyntax %s\r\n", pszAttributeSyntax);
				result = E_FAIL;
			}

			delete[] pszAttributeSyntax;
		}
		else
			m_pLogObject->WriteW( L"CLDAPInstanceProvider :: MapPropertyValueToADSI() Get on attributeSyntax FAILED %x\r\n", result);
		pQualifierSet->Release();
	}

	return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
// CLDAPInstanceProvider::SetStringValues
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: SetStringValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue)
{
	HRESULT result = S_OK;
	switch(pvPropertyValue->vt)
	{
		case VT_BSTR:
		{
			if(pvPropertyValue->bstrVal)
			{
				pAttributeEntry->dwNumValues = 1;
				pAttributeEntry->pADsValues = new ADSVALUE;
				pAttributeEntry->pADsValues->dwType = adType;
				pAttributeEntry->pADsValues->DNString = new WCHAR[wcslen(pvPropertyValue->bstrVal) + 1];
				wcscpy(pAttributeEntry->pADsValues->DNString, pvPropertyValue->bstrVal);
			}
		}
		break;
		case VT_BSTR | VT_ARRAY:
		{
			SAFEARRAY *pArray = pvPropertyValue->parray;
			BSTR HUGEP *pbstr;
			LONG lUbound = 0, lLbound = 0;
			if(SUCCEEDED(result = SafeArrayAccessData(pArray, (void HUGEP* FAR*)&pbstr) ))
			{
				if(SUCCEEDED (result = SafeArrayGetLBound(pArray, 1, &lLbound)) &&
				SUCCEEDED (result = SafeArrayGetUBound(pArray, 1, &lUbound)) )
				{
					if(pAttributeEntry->dwNumValues = lUbound - lLbound + 1)
					{
						pAttributeEntry->pADsValues = new ADSVALUE[pAttributeEntry->dwNumValues];
						PADSVALUE pValues = pAttributeEntry->pADsValues;
						for(DWORD i=0; i<pAttributeEntry->dwNumValues; i++)
						{
							pValues->dwType = adType;
							pValues->DNString = new WCHAR[wcslen(pbstr[i]) + 1];
							wcscpy(pValues->DNString, pbstr[i]);
							pValues ++;
						}

					}
				}
				SafeArrayUnaccessData(pArray);
			}
		}
		break;
		default:
			return E_FAIL;
	}
	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::SetIntegerValues
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: SetIntegerValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue)
{
	HRESULT result = S_OK;
	switch(pvPropertyValue->vt)
	{
		case VT_I4:
		{
			pAttributeEntry->dwNumValues = 1;
			pAttributeEntry->pADsValues = new ADSVALUE;
			pAttributeEntry->pADsValues->dwType = adType;
			pAttributeEntry->pADsValues->Integer = pvPropertyValue->lVal;
		}
		break;
		case VT_I4 | VT_ARRAY:
		{
			SAFEARRAY *pArray = pvPropertyValue->parray;
			LONG HUGEP *pl;
			LONG lUbound = 0, lLbound = 0;
			if(SUCCEEDED(result = SafeArrayAccessData(pArray, (void HUGEP* FAR*)&pl) ) &&
				SUCCEEDED (result = SafeArrayGetLBound(pArray, 1, &lLbound)) &&
				SUCCEEDED (result = SafeArrayGetUBound(pArray, 1, &lUbound)) )
			{
				if(pAttributeEntry->dwNumValues = lUbound - lLbound + 1)
				{
					pAttributeEntry->pADsValues = new ADSVALUE[pAttributeEntry->dwNumValues];
					PADSVALUE pValues = pAttributeEntry->pADsValues;
					for(DWORD i=0; i<pAttributeEntry->dwNumValues; i++)
					{
						pValues->dwType = adType;
						pValues->Integer = pl[i];
						pValues ++;
					}

				}
				SafeArrayUnaccessData(pArray);
			}
		}
		break;
		default:
			return E_FAIL;
	}
	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::SetBooleanValues
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: SetBooleanValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue)
{
	HRESULT result = S_OK;
	switch(pvPropertyValue->vt)
	{
		case VT_BOOL:
		{
			pAttributeEntry->dwNumValues = 1;
			pAttributeEntry->pADsValues = new ADSVALUE;
			pAttributeEntry->pADsValues->dwType = adType;
			pAttributeEntry->pADsValues->Boolean = pvPropertyValue->boolVal;
		}
		break;
		case VT_BOOL | VT_ARRAY:
		{
			SAFEARRAY *pArray = pvPropertyValue->parray;
			VARIANT_BOOL HUGEP *pb;
			LONG lUbound = 0, lLbound = 0;
			if(SUCCEEDED(result = SafeArrayAccessData(pArray, (void HUGEP* FAR*)&pb) ) &&
				SUCCEEDED (result = SafeArrayGetLBound(pArray, 1, &lLbound)) &&
				SUCCEEDED (result = SafeArrayGetUBound(pArray, 1, &lUbound)) )
			{
				if(pAttributeEntry->dwNumValues = lUbound - lLbound + 1)
				{
					pAttributeEntry->pADsValues = new ADSVALUE[pAttributeEntry->dwNumValues];
					PADSVALUE pValues = pAttributeEntry->pADsValues;
					for(DWORD i=0; i<pAttributeEntry->dwNumValues; i++)
					{
						pValues->dwType = adType;
						pValues->Boolean = (pb[i] == VARIANT_TRUE)? TRUE : FALSE;
						pValues ++;
					}
				}
				SafeArrayUnaccessData(pArray);
			}
		}
		break;
		default:
			return E_FAIL;
	}
	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::SetOctetStringValues
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: SetOctetStringValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue)
{
	HRESULT result = E_FAIL;
	switch(pvPropertyValue->vt)
	{
		case VT_UNKNOWN:
		{
			pAttributeEntry->dwNumValues = 1;
			pAttributeEntry->pADsValues = new ADSVALUE;
			pAttributeEntry->pADsValues->dwType = adType;
			// Get the array
			IWbemClassObject *pEmbeddedObject = NULL;
			if(SUCCEEDED(result = (pvPropertyValue->punkVal)->QueryInterface(IID_IWbemClassObject, (LPVOID *)&pEmbeddedObject)))
			{
				if(SUCCEEDED(result = CWBEMHelper::GetUint8ArrayProperty(pEmbeddedObject, VALUE_PROPERTY_STR, &(pAttributeEntry->pADsValues->OctetString.lpValue), &(pAttributeEntry->pADsValues->OctetString.dwLength) )))
				{
				}
				pEmbeddedObject->Release();
			}
		}
		break;
		case VT_UNKNOWN | VT_ARRAY:
		{
			SAFEARRAY *pArray = pvPropertyValue->parray;
			LONG lUbound = 0, lLbound = 0;
			if(SUCCEEDED (result = SafeArrayGetLBound(pArray, 1, &lLbound)) &&
				SUCCEEDED (result = SafeArrayGetUBound(pArray, 1, &lUbound)) )
			{
				if(pAttributeEntry->dwNumValues = lUbound - lLbound + 1)
				{
					pAttributeEntry->pADsValues = new ADSVALUE[pAttributeEntry->dwNumValues];
					PADSVALUE pValues = pAttributeEntry->pADsValues;
					IUnknown *pNextElement = NULL;
					for(DWORD i=0; i<pAttributeEntry->dwNumValues; i++)
					{
						pValues->dwType = adType;
						if(SUCCEEDED(result = SafeArrayGetElement(pArray, (LONG *)&i, (LPVOID )&pNextElement )))
						{
							IWbemClassObject *pEmbeddedObject = NULL;
							if(SUCCEEDED(result = pNextElement->QueryInterface(IID_IWbemClassObject, (LPVOID *)&pEmbeddedObject)))
							{
								if(SUCCEEDED(result = CWBEMHelper::GetUint8ArrayProperty(pEmbeddedObject, VALUE_PROPERTY_STR, &(pValues->OctetString.lpValue), &(pValues->OctetString.dwLength))))
								{
								}
								pEmbeddedObject->Release();
							}
							pNextElement->Release();

						}
						pValues ++;

					}
				}
			}
		}
		break;
		default:
			return E_FAIL;
	}
	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::SetDNWithStringValues
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: SetDNWithStringValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue)
{
	HRESULT result = E_FAIL;
	switch(pvPropertyValue->vt)
	{
		case VT_UNKNOWN:
		{
			pAttributeEntry->dwNumValues = 1;
			pAttributeEntry->pADsValues = new ADSVALUE;
			pAttributeEntry->pADsValues->dwType = adType;
			pAttributeEntry->pADsValues->pDNWithString = new ADS_DN_WITH_STRING;

			IWbemClassObject *pEmbeddedObject = NULL;
			if(SUCCEEDED(result = (pvPropertyValue->punkVal)->QueryInterface(IID_IWbemClassObject, (LPVOID *)&pEmbeddedObject)))
			{
				if(SUCCEEDED(result = CWBEMHelper::GetBSTRPropertyT(pEmbeddedObject, VALUE_PROPERTY_STR, &(pAttributeEntry->pADsValues->pDNWithString->pszStringValue) )))
				{
					if(SUCCEEDED(result = CWBEMHelper::GetBSTRPropertyT(pEmbeddedObject, DN_STRING_PROPERTY_STR, &(pAttributeEntry->pADsValues->pDNWithString->pszDNString) )))
					{
					}
				}
				pEmbeddedObject->Release();
			}
		}
		break;
		case VT_UNKNOWN | VT_ARRAY:
		{
			SAFEARRAY *pArray = pvPropertyValue->parray;
			LONG lUbound = 0, lLbound = 0;
			if(SUCCEEDED (result = SafeArrayGetLBound(pArray, 1, &lLbound)) &&
				SUCCEEDED (result = SafeArrayGetUBound(pArray, 1, &lUbound)) )
			{
				if(pAttributeEntry->dwNumValues = lUbound - lLbound + 1)
				{
					pAttributeEntry->pADsValues = new ADSVALUE[pAttributeEntry->dwNumValues];
					PADSVALUE pValues = pAttributeEntry->pADsValues;
					IUnknown *pNextElement = NULL;
					for(DWORD i=0; i<pAttributeEntry->dwNumValues; i++)
					{
						pValues->dwType = adType;
						if(SUCCEEDED(result = SafeArrayGetElement(pArray, (LONG *)&i, (LPVOID )&pNextElement )))
						{

							IWbemClassObject *pEmbeddedObject = NULL;
							if(SUCCEEDED(result = pNextElement->QueryInterface(IID_IWbemClassObject, (LPVOID *)&pEmbeddedObject)))
							{
								if(SUCCEEDED(result = CWBEMHelper::GetBSTRPropertyT(pEmbeddedObject, VALUE_PROPERTY_STR, &(pValues->pDNWithString->pszStringValue) )))
								{
									if(SUCCEEDED(result = CWBEMHelper::GetBSTRPropertyT(pEmbeddedObject, DN_STRING_PROPERTY_STR, &(pValues->pDNWithString->pszDNString) )))
									{
									}
								}
								pEmbeddedObject->Release();
							}
							pNextElement->Release();
						}
						pValues ++;

					}
				}
			}
		}
		break;
		default:
			return E_FAIL;
	}
	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::SetDNWithBinaryValues
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: SetDNWithBinaryValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue)
{
	HRESULT result = E_FAIL;
	switch(pvPropertyValue->vt)
	{
		case VT_UNKNOWN:
		{
			pAttributeEntry->dwNumValues = 1;
			pAttributeEntry->pADsValues = new ADSVALUE;
			pAttributeEntry->pADsValues->dwType = adType;
			pAttributeEntry->pADsValues->pDNWithBinary = new ADS_DN_WITH_BINARY;

			IWbemClassObject *pEmbeddedObject = NULL;
			if(SUCCEEDED(result = (pvPropertyValue->punkVal)->QueryInterface(IID_IWbemClassObject, (LPVOID *)&pEmbeddedObject)))
			{
				if(SUCCEEDED(result = CWBEMHelper::GetUint8ArrayProperty(pEmbeddedObject, VALUE_PROPERTY_STR, &(pAttributeEntry->pADsValues->pDNWithBinary->lpBinaryValue), &(pAttributeEntry->pADsValues->pDNWithBinary->dwLength) )))
				{
					if(SUCCEEDED(result = CWBEMHelper::GetBSTRPropertyT(pEmbeddedObject, DN_STRING_PROPERTY_STR, &(pAttributeEntry->pADsValues->pDNWithBinary->pszDNString) )))
					{
					}
				}
				pEmbeddedObject->Release();
			}
		}
		break;
		case VT_UNKNOWN | VT_ARRAY:
		{
			SAFEARRAY *pArray = pvPropertyValue->parray;
			LONG lUbound = 0, lLbound = 0;
			if(SUCCEEDED (result = SafeArrayGetLBound(pArray, 1, &lLbound)) &&
				SUCCEEDED (result = SafeArrayGetUBound(pArray, 1, &lUbound)) )
			{
				if(pAttributeEntry->dwNumValues = lUbound - lLbound + 1)
				{
					pAttributeEntry->pADsValues = new ADSVALUE[pAttributeEntry->dwNumValues];
					PADSVALUE pValues = pAttributeEntry->pADsValues;
					IUnknown *pNextElement = NULL;
					for(DWORD i=0; i<pAttributeEntry->dwNumValues; i++)
					{
						pValues->dwType = adType;
						if(SUCCEEDED(result = SafeArrayGetElement(pArray, (LONG *)&i, (LPVOID )&pNextElement )))
						{

							IWbemClassObject *pEmbeddedObject = NULL;
							if(SUCCEEDED(result = pNextElement->QueryInterface(IID_IWbemClassObject, (LPVOID *)&pEmbeddedObject)))
							{
								if(SUCCEEDED(result = CWBEMHelper::GetUint8ArrayProperty(pEmbeddedObject, VALUE_PROPERTY_STR, &(pAttributeEntry->pADsValues->pDNWithBinary->lpBinaryValue), &(pAttributeEntry->pADsValues->pDNWithBinary->dwLength) )))
								{
									if(SUCCEEDED(result = CWBEMHelper::GetBSTRPropertyT(pEmbeddedObject, DN_STRING_PROPERTY_STR, &(pAttributeEntry->pADsValues->pDNWithBinary->pszDNString) )))
									{
									}
								}
								pEmbeddedObject->Release();
							}
							pNextElement->Release();
						}
						pValues ++;

					}
				}
			}
		}
		break;
		default:
			return E_FAIL;
	}
	return result;
}


//***************************************************************************
//
// CLDAPInstanceProvider::SetTimeValues
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: SetTimeValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue)
{
	HRESULT result = S_OK;
	switch(pvPropertyValue->vt)
	{
		case VT_BSTR:
		{
			//199880819014734.000000+000 to 19980819014734.0Z to
			pAttributeEntry->dwNumValues = 1;
			pAttributeEntry->pADsValues = new ADSVALUE;
			pAttributeEntry->pADsValues->dwType = adType;
			pAttributeEntry->pADsValues->DNString = new WCHAR[27];
			wcscpy(pAttributeEntry->pADsValues->DNString, pvPropertyValue->bstrVal);
			(pAttributeEntry->pADsValues->DNString)[16] = L'Z';
			(pAttributeEntry->pADsValues->DNString)[17] = NULL;
		}
		break;
		case VT_BSTR | VT_ARRAY:
		{
			SAFEARRAY *pArray = pvPropertyValue->parray;
			BSTR HUGEP *pbstr;
			LONG lUbound = 0, lLbound = 0;
			if(SUCCEEDED(result = SafeArrayAccessData(pArray, (void HUGEP* FAR*)&pbstr) ) &&
				SUCCEEDED (result = SafeArrayGetLBound(pArray, 1, &lLbound)) &&
				SUCCEEDED (result = SafeArrayGetUBound(pArray, 1, &lUbound)) )
			{
				if(pAttributeEntry->dwNumValues = lUbound - lLbound + 1)
				{
					pAttributeEntry->pADsValues = new ADSVALUE[pAttributeEntry->dwNumValues];
					PADSVALUE pValues = pAttributeEntry->pADsValues;
					for(DWORD i=0; i<pAttributeEntry->dwNumValues; i++)
					{
						pValues->dwType = adType;
						pValues->DNString = new WCHAR[27];
						wcscpy(pValues->DNString, pbstr[i]);
						(pValues->DNString)[16] = L'Z';
						(pValues->DNString)[17] = NULL;
						pValues ++;
					}
				}
				SafeArrayUnaccessData(pArray);
			}
		}
		break;
		default:
			return E_FAIL;
	}
	return result;
}

//***************************************************************************
//
// CLDAPInstanceProvider::SetLargeIntegerValues
//
// Purpose: See Header File
//
//***************************************************************************
HRESULT CLDAPInstanceProvider :: SetLargeIntegerValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue)
{
	HRESULT result = S_OK;
	switch(pvPropertyValue->vt)
	{
		case VT_BSTR:
		{
			pAttributeEntry->dwNumValues = 1;
			pAttributeEntry->pADsValues = new ADSVALUE;
			pAttributeEntry->pADsValues->dwType = adType;
			swscanf(pvPropertyValue->bstrVal, L"%I64d", &((pAttributeEntry->pADsValues->LargeInteger).QuadPart));
		}
		break;
		case VT_BSTR | VT_ARRAY:
		{
			SAFEARRAY *pArray = pvPropertyValue->parray;
			BSTR HUGEP *pbstr;
			LONG lUbound = 0, lLbound = 0;
			if(SUCCEEDED(result = SafeArrayAccessData(pArray, (void HUGEP* FAR*)&pbstr) ) &&
				SUCCEEDED (result = SafeArrayGetLBound(pArray, 1, &lLbound)) &&
				SUCCEEDED (result = SafeArrayGetUBound(pArray, 1, &lUbound)) )
			{
				if(pAttributeEntry->dwNumValues = lUbound - lLbound + 1)
				{
					pAttributeEntry->pADsValues = new ADSVALUE[pAttributeEntry->dwNumValues];
					PADSVALUE pValues = pAttributeEntry->pADsValues;
					for(DWORD i=0; i<pAttributeEntry->dwNumValues; i++)
					{
						pValues->dwType = adType;
						swscanf(pbstr[i], L"%I64d", &((pValues->LargeInteger).QuadPart));
						pValues ++;
					}
				}
				SafeArrayUnaccessData(pArray);
			}
		}
		break;
		default:
			return E_FAIL;
	}
	return result;
}


//***************************************************************************
//
// CLDAPInstanceProvider::SetObjectClassAttribute
//
// Purpose: See Header File
//
//***************************************************************************
void CLDAPInstanceProvider :: SetObjectClassAttribute(PADS_ATTR_INFO pAttributeEntry, LPCWSTR pszADSIClassName)
{
	// Set its fields to 0;
	memset((LPVOID)pAttributeEntry, 0, sizeof(ADS_ATTR_INFO));


	// Set the name
	pAttributeEntry->pszAttrName = CLDAPHelper::UnmangleWBEMNameToLDAP(OBJECT_CLASS_PROPERTY);

	// Set the value
	pAttributeEntry->dwADsType = ADSTYPE_CASE_IGNORE_STRING;
	pAttributeEntry->dwNumValues = 1;
	pAttributeEntry->pADsValues = new ADSVALUE;
	pAttributeEntry->pADsValues->dwType = ADSTYPE_DN_STRING;
	pAttributeEntry->pADsValues->DNString = new WCHAR[wcslen(pszADSIClassName) + 1];
	wcscpy(pAttributeEntry->pADsValues->DNString, pszADSIClassName);
}



// Process query for associations
HRESULT CLDAPInstanceProvider :: ProcessAssociationQuery(
	IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler,
	SQL1_Parser *pParser)
{
	HRESULT result = WBEM_S_NO_ERROR;
	// Parse the query
    SQL_LEVEL_1_RPN_EXPRESSION *pExp = 0;
    if(!pParser->Parse(&pExp))
    {
		// Check to see that it has exactly 1 or 2 clauses, and
		// if 2 clauses are present, these should be different ones, and the operator should be an AND
		// This is because we support only the following kinds of queries
		// Select * From DS_LDAP_CONTAINMENT_CLASS Where parentInstance = <something>
		// Select * From DS_LDAP_CONTAINMENT_CLASS Where childInstance = <something>
		// For all other queries, if there is a NOT operator, we do not support it.
		// Otherwise we just take the individual clauses and return theri union, asking CIMOM to postprocess
		int iNumTokens = pExp->nNumTokens;

		// Go thru the tokens to see that NOT is not present
		SQL_LEVEL_1_TOKEN *pNextToken = pExp->pArrayOfTokens;
		for(int i=0; i<iNumTokens; i++)
		{
			if(pNextToken->nTokenType == SQL_LEVEL_1_TOKEN::TOKEN_NOT ||
				(pNextToken->nTokenType == SQL_LEVEL_1_TOKEN::OP_EXPRESSION && pNextToken->nOperator == SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL))
			{
				result = WBEM_E_PROVIDER_NOT_CAPABLE;
				break;
			}
			pNextToken ++;
		}

		// No NOT was found
		if(result != WBEM_E_PROVIDER_NOT_CAPABLE)
		{
			// Duplicates need to be avoided. So keep a list of objects indicated so far.
			// The key in the list is formed by concatenating the child and parent ADSI paths
			//===========================================================================

			CNamesList listIndicatedSoFar;

			pNextToken = pExp->pArrayOfTokens;
			i=0;
			while(i<iNumTokens && result != WBEM_E_PROVIDER_NOT_CAPABLE)
			{
				if(pNextToken->nTokenType == SQL_LEVEL_1_TOKEN::OP_EXPRESSION)
				{
					LPWSTR pszADSIPath = CWBEMHelper::GetADSIPathFromObjectPath(pNextToken->vConstValue.bstrVal);
					if(_wcsicmp(pNextToken->pPropertyName, CHILD_INSTANCE_PROPERTY_STR) == 0)
					{
						DoChildContainmentQuery(pszADSIPath, pResponseHandler, &listIndicatedSoFar);
						result = WBEM_S_NO_ERROR;
					}
					else if (_wcsicmp(pNextToken->pPropertyName, PARENT_INSTANCE_PROPERTY_STR) == 0)
					{
						DoParentContainmentQuery(pszADSIPath, pResponseHandler, &listIndicatedSoFar);
						result = WBEM_S_NO_ERROR;
					}
					else
						result = WBEM_E_PROVIDER_NOT_CAPABLE;

					delete [] pszADSIPath;

				}
				i++;
				pNextToken ++;
			}

		}
    }
	else
		result = WBEM_E_FAILED;

    delete pExp;
	if(SUCCEEDED(result))
	{
		// Ask CIMOM to postprocess the result
		pResponseHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, WBEM_S_NO_ERROR, NULL, NULL);
		result = WBEM_S_NO_ERROR;
	}
	else
	{
		pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_E_FAILED, NULL, NULL);
		result = WBEM_S_NO_ERROR;
	}

	return result;
}


// Process Query for DS instances
HRESULT CLDAPInstanceProvider :: ProcessInstanceQuery(
    BSTR strClass,
	BSTR strQuery,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler,
	SQL1_Parser *pParser)
{
	m_pLogObject->WriteW( L"CLDAPInstanceProvider :: ProcessInstanceQuery() called for %s Class and query %s\r\n", strClass, strQuery);

	HRESULT result = WBEM_E_FAILED;

	// Parse the query
    SQL_LEVEL_1_RPN_EXPRESSION *pExp = NULL;
    if(!pParser->Parse(&pExp))
    {
		// Fetch the class from CIMOM
		IWbemClassObject *pWbemClass = NULL;
		if(SUCCEEDED(result = m_IWbemServices->GetObject(strClass, 0, pCtx, &pWbemClass, NULL)))
		{
			// We need the object category information
			LPWSTR pszLDAPQuery = new WCHAR[6*(2*wcslen(strClass) + 75) + wcslen(strQuery) + 500];
			pszLDAPQuery[0] = LEFT_BRACKET_STR[0];
			pszLDAPQuery[1] = AMPERSAND_STR[0];
			pszLDAPQuery[2] = NULL;
			if(SUCCEEDED(CWBEMHelper::FormulateInstanceQuery(m_IWbemServices, pCtx, strClass, pWbemClass, pszLDAPQuery + 2, LDAP_DISPLAY_NAME_STR, DEFAULT_OBJECT_CATEGORY_STR)))
			{
				// Check to see if it can be converted to an LDAP query
				if(SUCCEEDED(result = ConvertWQLToLDAPQuery(pExp, pszLDAPQuery)))
				{
					// Complete the query string
					DWORD dwLen = wcslen(pszLDAPQuery);
					pszLDAPQuery[dwLen] = RIGHT_BRACKET_STR[0];
					pszLDAPQuery[dwLen + 1] = NULL;

					// Check to see if the client has specified any hints as to the DN of the object from
					// which the search should start
					BOOLEAN bRootDNSpecified = FALSE;
					LPWSTR *ppszRootDN = NULL;
					DWORD dwRootDNCount = 0;
					if(SUCCEEDED(GetRootDN(strClass, &ppszRootDN, &dwRootDNCount, pCtx)) && dwRootDNCount)
						bRootDNSpecified = TRUE;

					// Enumerate the ADSI Instances
					if(bRootDNSpecified)
					{
						for( DWORD i=0; i<dwRootDNCount; i++)
						{
							DoSingleQuery(strClass, pWbemClass, ppszRootDN[i], pszLDAPQuery,  pResponseHandler);
						}
					}
					else
					{
						DoSingleQuery(strClass, pWbemClass, m_lpszTopLevelContainerPath, pszLDAPQuery,  pResponseHandler);
					}

					if(bRootDNSpecified)
					{
						for(DWORD i=0; i<dwRootDNCount; i++)
						{
							delete [] ppszRootDN[i];
						}
						delete [] ppszRootDN;
					}

				}
			}
			else
				m_pLogObject->WriteW( L"CLDAPInstanceProvider :: FormulateInstanceQuery() on WBEM class %s FAILED with %x on query %s \r\n", strClass, result, strQuery);
			pWbemClass->Release();
			delete [] pszLDAPQuery;
		}
		else
			m_pLogObject->WriteW( L"CLDAPInstanceProvider :: ProcessInstanceQuery() Getting WBEM class %s FAILED with %x on query %s \r\n", strClass, result, strQuery);
	}
	else
		m_pLogObject->WriteW( L"CLDAPInstanceProvider :: ProcessInstanceQuery() Parse() FAILED on query %s \r\n", strQuery);
    delete pExp;
	return result;
}

HRESULT CLDAPInstanceProvider :: ConvertWQLToLDAPQuery(SQL_LEVEL_1_RPN_EXPRESSION *pExp, LPWSTR pszLDAPQuery)
{
	HRESULT result = E_FAIL;
	DWORD dwLength = wcslen(pszLDAPQuery);

	// Append to the existing string
	if(QueryConvertor::ConvertQueryToLDAP(pExp, pszLDAPQuery + dwLength))
	{
		m_pLogObject->WriteW( L"CLDAPInstanceProvider :: ConvertWQLToLDAPQuery() Query converted to %s \r\n", pszLDAPQuery);
		result = S_OK;
	}
	else
		m_pLogObject->WriteW( L"CLDAPInstanceProvider :: ConvertWQLToLDAPQuery() FAILED \r\n");

	return result;
}

HRESULT CLDAPInstanceProvider :: GetRootDN( LPCWSTR pszClass, LPWSTR **pppszRootDN, DWORD *pdwCount, IWbemContext *pCtx)
{
	*pppszRootDN = NULL;
	*pdwCount = 0;
	HRESULT result = WBEM_E_FAILED;

	// For the correct query
	LPWSTR pszQuery = new WCHAR[wcslen(pszClass) + wcslen(QUERY_FORMAT) + 10];
	swprintf(pszQuery, QUERY_FORMAT, pszClass);
	BSTR strQuery = SysAllocString(pszQuery);
	delete [] pszQuery;

	IEnumWbemClassObject *pEnum = NULL;
	if(SUCCEEDED(result = m_IWbemServices->ExecQuery(QUERY_LANGUAGE, strQuery, WBEM_FLAG_BIDIRECTIONAL, pCtx, &pEnum)))
	{
		// We ignore more than one instance in this implementation
		// Walk thru the enumeration and examine each class
		IWbemClassObject *pInstance = NULL;
		ULONG dwNextReturned = 0;
		while(SUCCEEDED(result = pEnum->Next( WBEM_INFINITE, 1, &pInstance, &dwNextReturned)) && dwNextReturned == 1)
		{
			(*pdwCount)++;
			pInstance->Release();
		}

		if(*pdwCount)
		{
			if(SUCCEEDED(result = pEnum->Reset()))
			{
				*pppszRootDN  = new LPWSTR[*pdwCount];

				DWORD i =0;
				while(SUCCEEDED(result = pEnum->Next( WBEM_INFINITE, 1, &pInstance, &dwNextReturned)) && dwNextReturned == 1)
				{
					// Get the ROOT_DN_PROPERTY, which has the instance
					BSTR strInstancePath = NULL;
					if(SUCCEEDED(result = CWBEMHelper::GetBSTRProperty(pInstance, ROOT_DN_PROPERTY, &strInstancePath)))
					{
						// Now get the object
						IWbemClassObject *pDNInstance = NULL;
						if(SUCCEEDED(result = m_IWbemServices->GetObject(strInstancePath, 0, pCtx, &pDNInstance, NULL)))
						{
							// Now get the DN_PROPERTY from the instance
							BSTR strRootDN = NULL;
							if(SUCCEEDED(result = CWBEMHelper::GetBSTRProperty(pDNInstance, DN_PROPERTY, &strRootDN)))
							{
								(*pppszRootDN)[i] = new WCHAR[wcslen(strRootDN) + 1];
								wcscpy((*pppszRootDN)[i], strRootDN);
								SysFreeString(strRootDN);

								i++;
							}
							pDNInstance->Release();
						}
						SysFreeString(strInstancePath);
					}
					pInstance->Release();
				}
				*pdwCount = i;
			}
		}
		else
			result = WBEM_E_FAILED; // To satisfy the return semantics of the function

		pEnum->Release();
	}
	SysFreeString(strQuery);
	return result;
}

// Process query for associations
HRESULT CLDAPInstanceProvider :: ProcessRootDSEGetObject(BSTR strClassName, IWbemObjectSink *pResponseHandler, IWbemContext *pCtx)
{
	HRESULT result = E_FAIL;

	// First get the object rom ADSI
	//==============================

	IADs *pADSIRootDSE = NULL;
	if(SUCCEEDED(result = ADsOpenObject((LPWSTR)ROOT_DSE_PATH, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IADs, (LPVOID *) &pADSIRootDSE)))
	{
		// Get the class to spawn an instance
		IWbemClassObject *pWbemClass = NULL;
		if(SUCCEEDED(result = m_IWbemServices->GetObject(strClassName, 0, pCtx, &pWbemClass, NULL)))
		{
			IWbemClassObject *pWBEMRootDSE = NULL;
			// Spawn a instance of the WBEM Class
			if(SUCCEEDED(result = pWbemClass->SpawnInstance(0, &pWBEMRootDSE)))
			{
				// Map it to WBEM
				if(SUCCEEDED(result = MapRootDSE(pADSIRootDSE, pWBEMRootDSE)))
				{
					// Indicate the result
					result = pResponseHandler->Indicate(1, &pWBEMRootDSE);
				}
				pWBEMRootDSE->Release();
			}
			pWbemClass->Release();
		}
		pADSIRootDSE->Release();
	}

	return result;
}


HRESULT CLDAPInstanceProvider :: MapRootDSE(IADs *pADSIRootDSE, IWbemClassObject *pWBEMRootDSE)
{
	// Map the properties one-by-one
	//=================================
	VARIANT variant;

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(SUBSCHEMASUBENTRY_STR, &variant)))
		pWBEMRootDSE->Put(SUBSCHEMASUBENTRY_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(SERVERNAME_STR, &variant)))
		pWBEMRootDSE->Put(SERVERNAME_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(DEFAULTNAMINGCONTEXT_STR, &variant)))
		pWBEMRootDSE->Put(DEFAULTNAMINGCONTEXT_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(SCHEMANAMINGCONTEXT_STR, &variant)))
		pWBEMRootDSE->Put(SCHEMANAMINGCONTEXT_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(CONFIGURATIONNAMINGCONTEXT_STR, &variant)))
		pWBEMRootDSE->Put(CONFIGURATIONNAMINGCONTEXT_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(ROOTDOMAINNAMINGCONTEXT_STR, &variant)))
		pWBEMRootDSE->Put(ROOTDOMAINNAMINGCONTEXT_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(CURRENTTIME_STR, &variant)))
		pWBEMRootDSE->Put(CURRENTTIME_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(SUPPORTEDVERSION_STR, &variant)))
		CWBEMHelper::PutBSTRArrayProperty(pWBEMRootDSE, SUPPORTEDVERSION_STR, &variant);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(NAMINGCONTEXTS_STR, &variant)))
		CWBEMHelper::PutBSTRArrayProperty(pWBEMRootDSE, NAMINGCONTEXTS_STR, &variant);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(SUPPORTEDCONTROLS_STR, &variant)))
		CWBEMHelper::PutBSTRArrayProperty(pWBEMRootDSE, SUPPORTEDCONTROLS_STR, &variant);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(DNSHOSTNAME_STR, &variant)))
		pWBEMRootDSE->Put(DNSHOSTNAME_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(DSSERVICENAME_STR, &variant)))
		pWBEMRootDSE->Put(DSSERVICENAME_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(HIGHESTCOMMITEDUSN_STR, &variant)))
		pWBEMRootDSE->Put(HIGHESTCOMMITEDUSN_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(LDAPSERVICENAME_STR, &variant)))
		pWBEMRootDSE->Put(LDAPSERVICENAME_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(SUPPORTEDCAPABILITIES_STR, &variant)))
		pWBEMRootDSE->Put(SUPPORTEDCAPABILITIES_STR, 0, &variant, 0);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(SUPPORTEDLDAPPOLICIES_STR, &variant)))
		CWBEMHelper::PutBSTRArrayProperty(pWBEMRootDSE, SUPPORTEDLDAPPOLICIES_STR, &variant);
	VariantClear(&variant);

	VariantInit(&variant);
	if(SUCCEEDED(pADSIRootDSE->Get(SUPPORTEDSASLMECHANISMS_STR, &variant)))
		CWBEMHelper::PutBSTRArrayProperty(pWBEMRootDSE, SUPPORTEDSASLMECHANISMS_STR, &variant);
	VariantClear(&variant);

	return S_OK;
}

HRESULT CLDAPInstanceProvider :: DoSingleQuery(BSTR strClass, IWbemClassObject *pWbemClass, LPCWSTR pszRootDN, LPCWSTR pszLDAPQuery, IWbemObjectSink *pResponseHandler)
{
	// Initialize the return values
	HRESULT result = E_FAIL;

	// Bind to the node from which the search should start
	IDirectorySearch *pDirectorySearchContainer = NULL;
	if(SUCCEEDED(result = ADsOpenObject((LPWSTR)pszRootDN, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectorySearch, (LPVOID *)&pDirectorySearchContainer)))
	{
		// Now perform a search for the attribute DISTINGUISHED_NAME_ATTR name
		if(SUCCEEDED(result = pDirectorySearchContainer->SetSearchPreference(m_pSearchInfo, 2)))
		{
			ADS_SEARCH_HANDLE hADSSearchOuter;

			if(SUCCEEDED(result = pDirectorySearchContainer->ExecuteSearch((LPWSTR) pszLDAPQuery, (LPWSTR *)&ADS_PATH_ATTR, 1, &hADSSearchOuter)))
			{
				// Calculate the number of rows first. 
				while(SUCCEEDED(result = pDirectorySearchContainer->GetNextRow(hADSSearchOuter)) &&
					result != S_ADS_NOMORE_ROWS)
				{
					CADSIInstance *pADSIInstance = NULL;

					// Get the columns for the attributes
					ADS_SEARCH_COLUMN adsColumn;

					// Store each of the LDAP class attributes 
					if(SUCCEEDED(pDirectorySearchContainer->GetColumn(hADSSearchOuter, (LPWSTR)ADS_PATH_ATTR, &adsColumn)))
					{
						// Protect against an ADSI bug
						if(adsColumn.pADsValues->dwType != ADSTYPE_PROV_SPECIFIC)
						{
							// Create the CADSIInstance
							if(SUCCEEDED(result = CLDAPHelper:: GetADSIInstance(adsColumn.pADsValues->DNString, &pADSIInstance, m_pLogObject)))
							{
								// Spawn a instance of the WBEM Class
								IWbemClassObject *pWbemInstance = NULL;
								if(SUCCEEDED(result = pWbemClass->SpawnInstance(0, &pWbemInstance)))
								{
									// Map it to WBEM
									if(SUCCEEDED(result = MapADSIInstance(pADSIInstance, pWbemInstance, pWbemClass)))
									{
										// Indicate the result
										if(FAILED(result = pResponseHandler->Indicate(1, &pWbemInstance)))
											m_pLogObject->WriteW( L"CLDAPInstanceProvider :: CreateInstanceEnumAsync Indicate() FAILED with %x \r\n", result);
									}
									else
										m_pLogObject->WriteW( L"CLDAPInstanceProvider :: CreateInstanceEnumAsync MapADSIInstance() FAILED with %x \r\n", result);
									pWbemInstance->Release();
								}

								pADSIInstance->Release();
							}
						}

						// Free resouces
						pDirectorySearchContainer->FreeColumn( &adsColumn );
					}
				}

				// Close the search. 
				pDirectorySearchContainer->CloseSearchHandle(hADSSearchOuter);

			} // ExecuteSearch() 
			else
				m_pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery ExecuteSearch() %s FAILED with %x\r\n", pszLDAPQuery, result);
		} // SetSearchPreference()
		else
			m_pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery SetSearchPreference() on %s FAILED with %x \r\n", pszLDAPQuery, result);
		pDirectorySearchContainer->Release();
	} // ADsOpenObject
	else
		m_pLogObject->WriteW( L"CLDAPHelper :: ExecuteQuery ADsOpenObject() on %s FAILED with %x \r\n", pszRootDN, result);

	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\instanceprovider\instfac.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 9/16/98 4:43p $
// 	$Workfile:classfac.cpp $
//
//	$Modtime: 6/11/98 11:21a $
//	$Revision: 1 $
//	$Nokeywords:  $
//
//
//  Description: Contains the implementation of the DS Instance Provider factory.
//
//***************************************************************************

#include <stdio.h>
#include <tchar.h>

#include <windows.h>
#include <objbase.h>

/* WBEM includes */
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include <sqllex.h>
#include <sql_1.h>
#include <wbemcli.h>
#include <wbemprov.h>

/* ADSI includes */
#include <activeds.h>

/* DS Provider includes */
#include "clsname.h"
#include "attributes.h"
#include "provlog.h"
#include "maindll.h"
#include "provexpt.h"
#include "instproi.h"
#include "instfac.h"
#include "dsipguid.h"
#include "refcount.h"
#include "adsiinst.h"
#include "instprov.h"

CDSInstanceProviderInitializer *CDSInstanceProviderClassFactory::s_pDSInstanceProviderInitializer = NULL;

//***************************************************************************
//
// CDSInstanceProviderClassFactory::CDSInstanceProviderClassFactory
// CDSInstanceProviderClassFactory::~CDSInstanceProviderClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CDSInstanceProviderClassFactory :: CDSInstanceProviderClassFactory ()
{
	m_ReferenceCount = 0 ;
	InterlockedIncrement(&g_lComponents);
}

CDSInstanceProviderClassFactory::~CDSInstanceProviderClassFactory ()
{
	InterlockedDecrement(&g_lComponents);
}

//***************************************************************************
//
// CDSInstanceProviderClassFactory::QueryInterface
// CDSInstanceProviderClassFactory::AddRef
// CDSInstanceProviderClassFactory::Release
//
// Purpose: Standard COM routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CDSInstanceProviderClassFactory::QueryInterface (

	REFIID iid ,
	LPVOID FAR *iplpv
)
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IClassFactory )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else
	{
		return E_NOINTERFACE;
	}

	( ( LPUNKNOWN ) *iplpv )->AddRef () ;
	return  S_OK;
}


STDMETHODIMP_( ULONG ) CDSInstanceProviderClassFactory :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CDSInstanceProviderClassFactory :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

//***************************************************************************
//
// CDSInstanceProviderClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CDSInstanceProviderClassFactory :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR * ppvObject
)
{
	HRESULT status = S_OK ;

	// We do not support aggregation
	if ( pUnkOuter )
	{
		status = CLASS_E_NOAGGREGATION ;
	}
	else
	{
		// Check to see if the static members have been initialized
		// Create any initializer objects required for the classes
		EnterCriticalSection(&g_StaticsCreationDeletion);
		if(!s_pDSInstanceProviderInitializer)
		{
			try
			{
				// This might have been created by the CreateInstance() function of the
				// other DS Providers (Class, ClassAssociation)
				if(!g_pLogObject)
					g_pLogObject = new ProvDebugLog(DSPROVIDER);
				g_pLogObject->WriteW(L"CDSInstanceProviderClassFactory::CreateInstance() called\r\n");
				s_pDSInstanceProviderInitializer = new CDSInstanceProviderInitializer();
			}
			catch(Heap_Exception e_HE)
			{
				delete g_pLogObject;
				g_pLogObject = NULL;
				delete s_pDSInstanceProviderInitializer;
				s_pDSInstanceProviderInitializer = NULL;
				status = E_OUTOFMEMORY ;
			}
		}
		LeaveCriticalSection(&g_StaticsCreationDeletion);

		if(SUCCEEDED(status))
		{
			CLDAPInstanceProvider *lpunk = NULL;
			try
			{
				lpunk = new CLDAPInstanceProvider(g_pLogObject);
				status = lpunk->QueryInterface ( riid , ppvObject ) ;
				if ( FAILED ( status ) )
				{
					delete lpunk ;
				}
			}
			catch(Heap_Exception e_HE)
			{
				status = E_OUTOFMEMORY ;
			}

		}
	}

	return status ;
}

//***************************************************************************
//
// CDSInstanceProviderClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CDSInstanceProviderClassFactory :: LockServer ( BOOL fLock )
{
	if ( fLock )
	{
		InterlockedIncrement ( & g_lServerLocks ) ;
	}
	else
	{
		InterlockedDecrement ( & g_lServerLocks ) ;
	}

	return S_OK	;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\instanceprovider\include\instprov.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// ***************************************************************************
//
//	Original Author: Rajesh Rao
//
// 	$Author: rajeshr $
//	$Date: 9/16/98 4:43p $
// 	$Workfile:instprov.h $
//
//	$Modtime: 9/16/98 11:21a $
//	$Revision: 1 $	
//	$Nokeywords:  $
//
// 
//  Description: Contains the declaration for the DS Instance Provider class. 
//
//***************************************************************************
/////////////////////////////////////////////////////////////////////////

#ifndef DS_INSTANCE_PROVIDER_H
#define DS_INSTANCE_PROVIDER_H

// Forward declaration for the initializer class
class CDSInstanceProviderInitializer;

class CLDAPInstanceProvider : public IWbemProviderInit, public IWbemServices
{
	// The initialization class is a friend of this class
	friend CDSInstanceProviderInitializer;

public:

	// Create the object 
    CLDAPInstanceProvider (ProvDebugLog *) ;
    virtual ~CLDAPInstanceProvider () ;

	////////////////////////////////////////
	//IUnknown members
	////////////////////////////////////////
	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;


	////////////////////////////////////////
	//IWbemProviderInit members
	////////////////////////////////////////
	virtual HRESULT STDMETHODCALLTYPE Initialize( 
            LPWSTR wszUser,
            LONG lFlags,
            LPWSTR wszNamespace,
            LPWSTR wszLocale,
            IWbemServices __RPC_FAR *pNamespace,
            IWbemContext __RPC_FAR *pCtx,
            IWbemProviderInitSink __RPC_FAR *pInitSink) ;

		
	////////////////////////////////////////
	//IWbemServices members
	////////////////////////////////////////
    virtual HRESULT STDMETHODCALLTYPE OpenNamespace( 
        /* [in] */ const BSTR strNamespace,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult);
    
    virtual HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink);
    
    virtual HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE GetObject( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE GetObjectAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE PutClass( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE PutClassAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteClass( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE CreateClassEnum( 
        /* [in] */ const BSTR strSuperclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
        /* [in] */ const BSTR strSuperclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE PutInstance( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteInstance( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE ExecQuery( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
    
    virtual HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE ExecMethod( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ const BSTR strMethodName,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
    
    virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ const BSTR strMethodName,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

protected:

	// The Logging object
	ProvDebugLog *m_pLogObject;

	// The IWbemServices pointer stored from Initialize()
	IWbemServices *m_IWbemServices;

	// SHows whether the call to Initialize() was successful
	BOOLEAN m_bInitializedSuccessfully;

	// The IWbemClassObject pointer to the Uint8ArrayClass
	IWbemClassObject *m_pWbemUin8ArrayClass;

	// The IWbemClassObject pointer to the DNWithBinaryClass
	IWbemClassObject *m_pWbemDNWithBinaryClass;

	// The IWbemClassObject pointer to the DNWithStringClass
	IWbemClassObject *m_pWbemDNWithStringClass;

	// The IWbemClassObject interface to the associations class
	IWbemClassObject *m_pAssociationsClass;

	// The path to the top level container
	LPWSTR m_lpszTopLevelContainerPath;

	// Gets the IDIrectoryObject interface on an ADSI instance
	HRESULT MapPropertyValueToWBEM(BSTR strWbemName, IWbemClassObject *pWbemClass, IWbemClassObject *pWbemObject, PADS_ATTR_INFO pAttribute);

	//***************************************************************************
	//
	// CLDAPInstanceProvider::IsContainedIn
	//
	// Purpose: Checks whether a containment is valid
	//
	// Parameters: 
	//	pszChildInstance : The WBEM Name of the child class
	//	pszParentInstance : The WBEM Name of the parent class
	//
	// Return Value: The COM status of the request
	//
	//***************************************************************************
	HRESULT IsContainedIn(LPCWSTR pszChildInstance, LPCWSTR pszParentInstance);

	//***************************************************************************
	//
	// CLDAPInstanceProvider::CreateInstance
	//
	// Purpose: Checks whether a containment is valid
	//
	// Parameters: 
	//	strChildName : The WBEM Name of the child instance
	//	strParentName : The WBEM Name of the parent instance
	//
	// Return Value: The COM status of the request. THe user should free the returned 
	//	IWbemClassObject when done.
	//
	//***************************************************************************
	HRESULT CreateWBEMInstance(BSTR strChildName, BSTR strParentName, IWbemClassObject **ppInstance);

	//***************************************************************************
	//
	// CLDAPInstanceProvider::ModifyExistingADSIInstance
	//
	// Purpose: Modify an existing ADSI Object using information from the WBEM object
	//
	// Parameters: 
	//	pWbemInstance : The WBEM instance being mapped
	//	pszADSIPath : The path to the ADSI instance
	//	pExistingObject : The CADSIInstance pointer on the existing instance
	//	pszADSIClass : The ADSI class name of the new instance
	//
	// Return Value: The COM status of the request. 
	//
	//***************************************************************************
	HRESULT ModifyExistingADSIInstance(IWbemClassObject *pWbemInstance, LPCWSTR pszADSIPath, CADSIInstance *pExistingObject, LPCWSTR pszADSIClass, IWbemContext *pCtx);

	//***************************************************************************
	//
	// CLDAPInstanceProvider::CreateNewADSIInstance
	//
	// Purpose: To create a new ADSI instance form a WBEM instance
	//
	// Parameters: 
	//	pWbemInstance : The WBEM instance being mapped
	//	pszADSIPath : The path to the new ADSI instance
	//	pszADSIClass : The ADSI class name of the new instance
	//
	// Return Value: The COM status of the request. 
	//
	//***************************************************************************
	HRESULT CreateNewADSIInstance(IWbemClassObject *pWbemInstance, LPCWSTR pszADSIPath, LPCWSTR pszADSIClass);

	//***************************************************************************
	//
	// CLDAPInstanceProvider::MapPropertyValueToADSI
	//
	// Purpose: To map a WBEM property to ADSI
	//
	//	strPropertyName : The WBEM name of the property
	//	vPropertyValue : The variant representing the proeprty value
	//	cType : The CIMTYPE of the property
	//	lFlavour : The WBEM flavour of the proeprty
	//	pAttributeEntry : A pointer to an ADS_ATTR_INFO structure that will be filled in.
	//
	//***************************************************************************
	HRESULT MapPropertyValueToADSI(IWbemClassObject *pWbemInstance, BSTR strPropertyName, VARIANT vPropertyValue, CIMTYPE cType, LONG lFlavour,  PADS_ATTR_INFO pAttributeEntry);

	//***************************************************************************
	//
	// CLDAPInstanceProvider::DoChildContainmentQuery
	//
	// Purpose: Find the parent of a given child and create an association class
	//
	// Parameters: 
	//	pszChildPath : The ADSI path of the child instance
	//	pResponseHandler : A sink on which the resulting objects are indicated
	//	pListIndicatedSoFar : To avoid duplicate indications (WinMgmt will lot filter them), a
	//		list of objects indicated so far is kept. Any objects in this list are
	//		not indicated again
	//
	// Return Value: The COM status of the request. 
	//
	//***************************************************************************
	HRESULT DoChildContainmentQuery(LPCWSTR pszChildPath, IWbemObjectSink *pResponseHandler, CNamesList *pListIndicatedSoFar);

	//***************************************************************************
	//
	// CLDAPInstanceProvider::DoParentContainmentQuery
	//
	// Purpose: Enumerate the children of a given parent and create association classes
	//
	// Parameters: 
	//	pszParentPath : The ADSI path of the parent instance
	//	pResponseHandler : A sink on which the resulting objects are indicated
	//	pListIndicatedSoFar : To avoid duplicate indications (WinMgmt will lot filter them), a
	//		list of objects indicated so far is kept. Any objects in this list are
	//		not indicated again
	//
	// Return Value: The COM status of the request. 
	//
	//***************************************************************************
	HRESULT DoParentContainmentQuery(LPCWSTR pszParentPath, IWbemObjectSink *pResponseHandler, CNamesList *pListIndicatedSoFar);

	// Maps an ADSI Instance to WBEM
	HRESULT MapADSIInstance(CADSIInstance *pADSInstance, IWbemClassObject *pWbemClass, IWbemClassObject *pWbemObject);


private:

	// The COM Reference count
    long m_lReferenceCount ;

	// These are the search preferences often used
	ADS_SEARCHPREF_INFO m_pSearchInfo[2];

	// A query for getting the DN associators of a class
    static LPCWSTR QUERY_FORMAT;
    static BSTR QUERY_LANGUAGE;
    static BSTR DN_PROPERTY;
    static BSTR ROOT_DN_PROPERTY;

	// Some literals
	static LPCWSTR DEFAULT_NAMING_CONTEXT_ATTR;
	static LPCWSTR OBJECT_CLASS_EQUALS;
	static BSTR CLASS_STR;
	static BSTR ADSI_PATH_STR;
	static BSTR UINT8ARRAY_STR;
	static BSTR	DN_WITH_BINARY_CLASS_STR;
	static BSTR	DN_WITH_STRING_CLASS_STR;
	static BSTR VALUE_PROPERTY_STR;
	static BSTR DN_STRING_PROPERTY_STR;
	static BSTR INSTANCE_ASSOCIATION_CLASS_STR;
	static BSTR CHILD_INSTANCE_PROPERTY_STR;
	static BSTR PARENT_INSTANCE_PROPERTY_STR;
	static BSTR RELPATH_STR;
	static BSTR ATTRIBUTE_SYNTAX_STR;
	static BSTR DEFAULT_OBJECT_CATEGORY_STR;
	static BSTR LDAP_DISPLAY_NAME_STR;
	static BSTR PUT_EXTENSIONS_STR;
	static BSTR PUT_EXT_PROPERTIES_STR;
	static BSTR CIMTYPE_STR;
	// Properties of LDAP://RootDSE
	static BSTR SUBSCHEMASUBENTRY_STR;
	static BSTR CURRENTTIME_STR;
	static BSTR SERVERNAME_STR;
	static BSTR NAMINGCONTEXTS_STR;
	static BSTR DEFAULTNAMINGCONTEXT_STR;
	static BSTR SCHEMANAMINGCONTEXT_STR;
	static BSTR CONFIGURATIONNAMINGCONTEXT_STR;
	static BSTR ROOTDOMAINNAMINGCONTEXT_STR;
	static BSTR SUPPORTEDCONTROLS_STR;
	static BSTR SUPPORTEDVERSION_STR;
	static BSTR DNSHOSTNAME_STR;
	static BSTR DSSERVICENAME_STR;
	static BSTR HIGHESTCOMMITEDUSN_STR;
	static BSTR LDAPSERVICENAME_STR;
	static BSTR SUPPORTEDCAPABILITIES_STR;
	static BSTR SUPPORTEDLDAPPOLICIES_STR;
	static BSTR SUPPORTEDSASLMECHANISMS_STR;


	// Process query for DS Associations
	HRESULT ProcessAssociationQuery( 
		IWbemContext __RPC_FAR *pCtx,
		IWbemObjectSink __RPC_FAR *pResponseHandler,
		SQL1_Parser *pParser);

	// Process Query for DS Instances
	HRESULT ProcessInstanceQuery( 
		BSTR strClass,
		BSTR strQuery,
		IWbemContext __RPC_FAR *pCtx,
		IWbemObjectSink __RPC_FAR *pResponseHandler,
		SQL1_Parser *pParser);
	
	// COnverts a WQL query to an LDAP Filter. If possible
	HRESULT ConvertWQLToLDAPQuery(SQL_LEVEL_1_RPN_EXPRESSION *pExp, LPWSTR pszLDAPQuery);

	// Does a query on a specified Root DN
	HRESULT DoSingleQuery(BSTR strClass, IWbemClassObject *pWbemClass, LPCWSTR pszRootDN, LPCWSTR pszLDAPQuery, IWbemObjectSink *pResponseHandler);

	// Gets any static configuration data for enumerating/querying a given class
	HRESULT GetRootDN( LPCWSTR pszClass, LPWSTR **ppszRootDN, DWORD *pdwCount, IWbemContext *pCtx);

	HRESULT MapEmbeddedObjectToWBEM(PADSVALUE pAttribute, LPCWSTR pszQualifierName, IUnknown **ppEmbeddedObject);
	HRESULT MapUint8ArrayToWBEM(PADSVALUE pAttribute, IUnknown **ppEmbeddedObject);
	HRESULT MapDNWithBinaryToWBEM(PADSVALUE pAttribute, IUnknown **ppEmbeddedObject);
	HRESULT MapDNWithStringToWBEM(PADSVALUE pAttribute, IUnknown **ppEmbeddedObject);
	HRESULT MapByteArray(LPBYTE lpBinaryValue, DWORD dwLength, const BSTR strPropertyName, IWbemClassObject *pInstance);

	HRESULT ProcessRootDSEGetObject(BSTR strClassName, IWbemObjectSink *pResponseHandler, IWbemContext *pCtx);
	HRESULT MapRootDSE(IADs *pADSIRootDSE, IWbemClassObject *pWBEMRootDSE);

	//***************************************************************************
	//
	// CLDAPInstanceProvider::SetStringValues
	//
	// Purpose: See Header File
	//
	//***************************************************************************
	HRESULT SetStringValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue);
	
	//***************************************************************************
	//
	// CLDAPInstanceProvider::SetBooleanValues
	//
	// Purpose: See Header File
	//
	//***************************************************************************
	HRESULT SetBooleanValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue);
	
	//***************************************************************************
	//
	// CLDAPInstanceProvider::SetIntegerValues
	//
	// Purpose: See Header File
	//
	//***************************************************************************
	HRESULT SetIntegerValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue);

	
	//***************************************************************************
	//
	// CLDAPInstanceProvider::SetOctetStringValues
	//
	// Purpose: See Header File
	//
	//***************************************************************************
	HRESULT SetOctetStringValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue);
	HRESULT SetDNWithBinaryValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue);
	HRESULT SetDNWithStringValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue);
	
	//***************************************************************************
	//
	// CLDAPInstanceProvider::SetStringValues
	//
	// Purpose: See Header File
	//
	//***************************************************************************
	HRESULT SetTimeValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue);


	//***************************************************************************
	//
	// CLDAPInstanceProvider::SetStringValues
	//
	// Purpose: See Header File
	//
	//***************************************************************************
	HRESULT SetLargeIntegerValues(PADS_ATTR_INFO pAttributeEntry, ADSTYPE adType, VARIANT *pvPropertyValue);

	//***************************************************************************
	//
	// CLDAPInstanceProvider::SetObjectClassAttribute
	//
	// Purpose: See Header File
	//
	//***************************************************************************
	void SetObjectClassAttribute(PADS_ATTR_INFO pAttributeEntry, LPCWSTR pszADSIClassName);
};


#endif // DS_INSTANCE_PROVIDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\samples\main2.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#define _WIN32_WINNT    0x0500

#include <windows.h>
#include <stdio.h>

#include <objbase.h>
#include <wbemcli.h>




void main()
{
	// Initialize COM. Remember the DS Provider needs impersonation to be called
	// so you have to call the COM function CoInitializeSecurity()
	// For this, you must #define _WIN32_WINNT to be greater than 0x0400. See top of file.
	if(SUCCEEDED(CoInitialize(NULL)) && SUCCEEDED(CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, 0)))
	{
		// Create the IWbemLocator object 
		IWbemLocator *t_pLocator = NULL;
		if (SUCCEEDED(CoCreateInstance(CLSID_WbemLocator, 
			0, 
			CLSCTX_INPROC_SERVER,
            IID_IWbemLocator, (LPVOID *) &t_pLocator)))
		{
			// Connect to the correct namespace
			// The DS Provider operates in the root\directory\LDAP namespace
			IWbemServices *t_pNamespace = NULL;
			BSTR strNamespace = SysAllocString(L"root\\directory\\LDAP");
			if(SUCCEEDED(t_pLocator->ConnectServer(strNamespace, NULL, NULL, NULL, 0, NULL, NULL, &t_pNamespace)))
			{

				// This is *very important* since the DSProvider goes accross the process
				// Every IWbemServices interface obtained form the IWbemLocator has to
				// have the COM interface function IClientSecutiry::SetBlanket() called on it
				// for the DS Provider to work
				IClientSecurity *t_pSecurity = NULL ;
				if(SUCCEEDED(t_pNamespace->QueryInterface ( IID_IClientSecurity , (LPVOID *) & t_pSecurity )))
				{
					t_pSecurity->SetBlanket( 
						t_pNamespace , 
						RPC_C_AUTHN_WINNT, 
						RPC_C_AUTHZ_NONE, 
						NULL,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						RPC_C_IMP_LEVEL_IMPERSONATE, 
						NULL,
						EOAC_NONE
					);
					t_pSecurity->Release () ;
				}


				// Fetch the class from CIMOM
				IWbemClassObject *pWbemClass = NULL;
				HRESULT result;
				if(SUCCEEDED(result = t_pNamespace->GetObject(SysAllocString(L"ds_domainDNS"), 0, NULL, &pWbemClass, NULL)))
				{
						CIMTYPE cimType;

						// Get the CIM TYPE of the property
						VARIANT dummyUnused;
						VariantInit(&dummyUnused);
						BSTR strRajesh = SysAllocString(L"ds_wellKnownObjects");
						result = pWbemClass->Get(strRajesh, 0, &dummyUnused, &cimType, NULL);
						SysFreeString(strRajesh);
						VariantClear(&dummyUnused);
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\samples\main.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#define _WIN32_WINNT    0x0500

#include <windows.h>
#include <stdio.h>

#include <objbase.h>
#include <wbemcli.h>


// These are the declarations for the functions that have sample code for various operations
void GetAClass(IWbemServices *pServices);
void EnumerateSubClassesOfAClass(IWbemServices *pServices);
void GetAnInstance(IWbemServices *pServices);
void DeleteAnInstance(IWbemServices *pServices);
void CreateAnInstance(IWbemServices *pServices);
void EnumerateInstancesOfAClass(IWbemServices *pServices);
void ExecuteAQuery(IWbemServices *pServices);


void main()
{
	// Initialize COM. Remember the DS Provider needs impersonation to be called
	// so you have to call the COM function CoInitializeSecurity()
	// For this, you must #define _WIN32_WINNT to be greater than 0x0400. See top of file.
	if(SUCCEEDED(CoInitialize(NULL)) && SUCCEEDED(CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, 0)))
	{
		// Create the IWbemLocator object 
		IWbemLocator *t_pLocator = NULL;
		if (SUCCEEDED(CoCreateInstance(CLSID_WbemLocator, 
			0, 
			CLSCTX_INPROC_SERVER,
            IID_IWbemLocator, (LPVOID *) &t_pLocator)))
		{
			// Connect to the correct namespace
			// The DS Provider operates in the root\directory\LDAP namespace
			IWbemServices *t_pNamespace = NULL;
			BSTR strNamespace = SysAllocString(L"root\\directory\\LDAP");
			if(SUCCEEDED(t_pLocator->ConnectServer(strNamespace, NULL, NULL, NULL, 0, NULL, NULL, &t_pNamespace)))
			{

				// This is *very important* since the DSProvider goes accross the process
				// Every IWbemServices interface obtained form the IWbemLocator has to
				// have the COM interface function IClientSecutiry::SetBlanket() called on it
				// for the DS Provider to work
				IClientSecurity *t_pSecurity = NULL ;
				if(SUCCEEDED(t_pNamespace->QueryInterface ( IID_IClientSecurity , (LPVOID *) & t_pSecurity )))
				{
					t_pSecurity->SetBlanket( 
						t_pNamespace , 
						RPC_C_AUTHN_WINNT, 
						RPC_C_AUTHZ_NONE, 
						NULL,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						RPC_C_IMP_LEVEL_IMPERSONATE, 
						NULL,
						EOAC_NONE
					);
					t_pSecurity->Release () ;
				}

				/**************************************************************
				*
				*  THESE FUNCTIONS BELOW SHOW HOW TO DO THE VARIOUS OPERATIONS
				*  THEY ARE GROUPED ACCORDING TO THE VARIOUS DS PROVIDERS
				*
				**************************************************************/

				/************************************************************
				* DS CLASS OPERATIONS - USING THE DS CLASS PROVIDER
				************************************************************/
				GetAClass(t_pNamespace);
				EnumerateSubClassesOfAClass(t_pNamespace);


				/************************************************************
				* DS INSTANCE OPERATIONS - USING THE DS INSTANCE PROVIDER
				************************************************************/
				GetAnInstance(t_pNamespace);
				DeleteAnInstance(t_pNamespace);
				EnumerateInstancesOfAClass(t_pNamespace);
				ExecuteAQuery(t_pNamespace);

				/************************************************************
				* CLASS ASSOCIATIONS - USING THE DS CLASS ASSOCIATIONS PROVIDER
				************************************************************/

				/************************************************************
				* INSTANCE ASSOCIATIONS - USING THE DS INSTANCE ASSOCIATIONS PROVIDER
				************************************************************/


				t_pNamespace->Release();
			}
			SysFreeString(strNamespace);
			t_pLocator->Release();
		}
	}
}


void GetAClass(IWbemServices *pServices)
{
	HRESULT result = S_OK;

	// Get an Active Directory class from the DS Provider
	// Let's get the AD class "person". This will prefixed with "ds_" when it maps to WMI
	// Hence we should get the class "ds_person" in WMI

	BSTR strClassName = SysAllocString(L"ds_person");
	IWbemClassObject *pClass = NULL;
	if(SUCCEEDED(result = pServices->GetObject(strClassName, 0, NULL, &pClass, NULL)))
	{
		wprintf(L"Got the class %s successfully!\n", strClassName);

		// Now browse the properties of the class by using the 
		// functions on IWbemClassbject ...

		
		
		// Then release it
		pClass->Release();

	}
	else
		wprintf(L"Get class operation on %s failed because of WMI error %x\n", strClassName, result);
	SysFreeString(strClassName);
}

void EnumerateSubClassesOfAClass(IWbemServices *pServices)
{
	HRESULT result = S_OK;

	// Let's try to see what classes are derived in the Active Directoy Schema
	// from the Active Directory class "person"
	// Hence from WMI, we will have to do a deep enumeration of
	// all the subclasses of the WMI class "ds_user"
	BSTR strSuperClassName = SysAllocString(L"ds_person");
	IEnumWbemClassObject *pEnumClasses = NULL;
	if( SUCCEEDED(result = pServices->CreateClassEnum(strSuperClassName, WBEM_FLAG_DEEP, NULL, &pEnumClasses)))
	{
		// Walk thru the enumeration and examine each class
		IWbemClassObject *pNextSubClass = NULL;
		ULONG dwCount = 0;
		ULONG dwNextReturned = 0;
		while(SUCCEEDED(result = pEnumClasses->Next( WBEM_INFINITE, 1, &pNextSubClass, &dwNextReturned)) &&
			dwNextReturned == 1)
		{

			// Now browse the properties of the sub class by using the 
			// functions on IWbemClassbject ...

			pNextSubClass->Release();
			dwCount ++;
		}
		wprintf(L"The class %s has %d subclasses!\n", strSuperClassName, dwCount);
		// Release the enumerator when done
		pEnumClasses->Release();
	}
	else
		wprintf(L"The subclass enumeration operation failed on %s because of WMI error %x\n", strSuperClassName, result);
	SysFreeString(strSuperClassName);
}

void GetAnInstance(IWbemServices *pServices)
{
	// Let's get an instance of the Active Directory class "user"
	// A user called "administrator" typically exists in

	// You will have to change this string to actually contain the ADSI path to the
	// user object for Administrator on your domain.
	BSTR strInstancePath = SysAllocString(L"ds_user.ADSIPath=\"LDAP://CN=Administrator,CN=Users,DC=dsprovider,DC=nttest,DC=microsoft,DC=com\"");
	IWbemClassObject *pInstance = NULL;
	HRESULT result = WBEM_E_FAILED;
	if(SUCCEEDED(result = pServices->GetObject(strInstancePath, 0, NULL, &pInstance, NULL)))
	{
		// Go through some properties on the user
		// Remember all properties get prefixed with "ds_"
		BSTR strSamAccountName = SysAllocString(L"DS_sAMAccountName");
		BSTR strLogonCount = SysAllocString(L"DS_logonCount");

		VARIANT vSamAccountNameValue;
		VARIANT vLogonCountValue;
		VariantClear(&vSamAccountNameValue);
		VariantClear(&vLogonCountValue);
		if(SUCCEEDED(pInstance->Get(strSamAccountName, 0, &vSamAccountNameValue, NULL, NULL)) &&
			SUCCEEDED(pInstance->Get(strLogonCount, 0, &vLogonCountValue, NULL, NULL)) )
		{
			wprintf(L"The user object for user %s was successfully retrieved! ", vSamAccountNameValue.bstrVal);
			wprintf(L"It has a Logon Count of %d\n", vLogonCountValue.lVal);
		}
		else
			wprintf(L"The GetObject() operation failed to get the required properties on the user object\n");

		pInstance->Release();
	}
	else
		wprintf(L"The GetObject() operation failed on %s because of WMI error %x\n", strInstancePath, result);
	SysFreeString(strInstancePath);
}

void DeleteAnInstance(IWbemServices *pServices)
{
	// Let's delete an instance of the Active Directory class "user"
	// Create a user called "dummy" before executing this

	// You will have to change this string to actually contain the ADSI path to the
	// user object for "dummy" on your domain.
	BSTR strInstancePath = SysAllocString(L"ds_user.ADSIPath=\"LDAP://CN=dummy,CN=Users,DC=dsprovider,DC=nttest,DC=microsoft,DC=com\"");

	HRESULT result = WBEM_E_FAILED;
	if(SUCCEEDED(result = pServices->DeleteInstance(strInstancePath, 0, NULL, NULL)))
		wprintf(L"Deleted the user %s successfully!\n", strInstancePath);
	else
		wprintf(L"Could not delete the user %s due to WMI error %x\n", strInstancePath, result);

	SysFreeString(strInstancePath);
}

void EnumerateInstancesOfAClass(IWbemServices *pServices)
{
	HRESULT result = S_OK;

	// Let's try to see how many users are in the domain
	// For this, we have to enumerate the instances of the class "ds_user"
	BSTR strClassName = SysAllocString(L"ds_user");
	IEnumWbemClassObject *pEnumInstances = NULL;
	if( SUCCEEDED(result = pServices->CreateInstanceEnum(strClassName, WBEM_FLAG_SHALLOW, NULL, &pEnumInstances)))
	{
		// Walk thru the enumeration and print the class names
		IWbemClassObject *pNextInstance = NULL;
		ULONG dwCount = 0;
		ULONG dwNextReturned = 0;
		pEnumInstances->Reset();
		while(SUCCEEDED(result = pEnumInstances->Next( WBEM_INFINITE, 1, &pNextInstance, &dwNextReturned)) &&
			dwNextReturned == 1)
		{

			// Now browse the properties of the instance by using the 
			// functions on IWbemClassbject ...

			pNextInstance->Release();
			dwCount ++;
		}
		wprintf(L"There are %d users in the domain!\n", dwCount);
	}
	else
		wprintf(L"The instance enumeration operation failed on %s because of WMI error %x\n", strClassName, result);
	SysFreeString(strClassName);
}

void ExecuteAQuery(IWbemServices *pServices)
{
	// Let's try to find those users who have logged on more than 4 times since their accounts were created.
	// The Query is formulated like this
	BSTR strQuery = SysAllocString(L"select * from ds_user where ds_logonCount>4");

	// For this, the query language is WQL
	BSTR strQueryLanguage = SysAllocString(L"WQL");

	IEnumWbemClassObject *pEnumerator = NULL;
	HRESULT result = WBEM_E_FAILED;
	if(SUCCEEDED(result = pServices->ExecQuery(strQueryLanguage, strQuery, WBEM_FLAG_FORWARD_ONLY, NULL, &pEnumerator)))
	{
		// Walk thru the enumeration and examine each object
		IWbemClassObject *pNextInstance = NULL;
		ULONG dwCount = 0;
		ULONG dwNextReturned = 0;
		while(SUCCEEDED(result = pEnumerator->Next( WBEM_INFINITE, 1, &pNextInstance, &dwNextReturned)) &&
			dwNextReturned == 1)
		{

			// Now browse the properties of each user instance by using the 
			// functions of IWbemClassbject ...

			// Releasse it when done
			pNextInstance->Release();
			dwCount ++;
		}
		wprintf(L"There are %d users who have logged in more than 4 times!\n", dwCount);

		// Release the enumerator when done
		pEnumerator->Release();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\pathprsr\analyser.cpp ===
//***************************************************************************

//

//  ANALYSER.CPP

//

//  Module: OLE MS Provider Framework

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <instpath.h>

WbemLexicon :: WbemLexicon () : position ( 0 ) , tokenStream ( NULL ) 
{
    value.string = NULL ;
    value.token = NULL ;
}

WbemLexicon :: ~WbemLexicon ()
{
    switch ( token ) 
    {
        case TOKEN_ID:
        {
            delete [] value.token ;
        }
        break ;
    
        case STRING_ID:
        {
            delete [] value.string ;
        }
        break ;

        default:
        {
        } ;
    }
}

WbemLexicon :: LexiconToken WbemLexicon :: GetToken ()
{
    return token ;
}

WbemLexiconValue *WbemLexicon :: GetValue ()
{
    return &value ;
}

WbemAnalyser :: WbemAnalyser ( WCHAR *tokenStream ) : status ( TRUE ) , position ( 0 ) , stream ( NULL ) 
{
    if ( tokenStream )
    {
        stream = new WCHAR [ wcslen ( tokenStream ) + 1 ] ;
        wcscpy ( stream , tokenStream ) ;
    }
}

WbemAnalyser :: ~WbemAnalyser () 
{
    delete [] stream ;
}

void WbemAnalyser :: Set ( WCHAR *tokenStream ) 
{
    status = 0 ;
    position = NULL ;

    delete [] stream ;
    stream = new WCHAR [ wcslen ( tokenStream ) + 1 ] ;
    wcscpy ( stream , tokenStream ) ;
}

void WbemAnalyser :: PutBack ( WbemLexicon *token ) 
{
    position = token->position ;
}

BOOL WbemAnalyser :: IsLeadingDecimal ( WCHAR token )
{
    return iswdigit ( token ) && ( token != L'0' ) ;
}

BOOL WbemAnalyser :: IsDecimal ( WCHAR token )
{
    return iswdigit ( token ) ;
}

BOOL WbemAnalyser :: IsHex ( WCHAR token )
{
    return iswxdigit ( token ) ;
}
    
BOOL WbemAnalyser :: IsWhitespace ( WCHAR token )
{
    return iswspace ( token ) ;
}

BOOL WbemAnalyser :: IsOctal ( WCHAR token )
{
    return ( token >= L'0' && token <= L'7' ) ;
}

BOOL WbemAnalyser :: IsAlpha ( WCHAR token )
{
    return iswalpha ( token ) ;
}

BOOL WbemAnalyser :: IsAlphaNumeric ( WCHAR token )
{
    return iswalnum ( token ) || ( token == L'_' ) || ( token == L'-' ) ;
}

BOOL WbemAnalyser :: IsEof ( WCHAR token )
{
    return token == 0 ;
}

LONG WbemAnalyser :: OctToDec ( WCHAR token ) 
{
    return token - L'0' ;
}

LONG WbemAnalyser :: HexToDec ( WCHAR token ) 
{
    if ( token >= L'0' && token <= L'9' )
    {
        return token - L'0' ;
    }
    else if ( token >= L'a' && token <= L'f' )
    {
        return token - L'a' + 10 ;
    }
    else if ( token >= L'A' && token <= L'F' )
    {
        return token - L'A' + 10 ;
    }
    else
    {
        return 0 ;
    }
}

WbemAnalyser :: operator void * () 
{
    return status ? this : NULL ;
}

#define DEC_INTEGER_START 1000
#define HEX_INTEGER_START 2000
#define OCT_INTEGER_START 3000
#define STRING_START 4000
#define TOKEN_START 5000
#define OID_START 6000

#define OID_STATE 9000
#define TOKEN_STATE 9001
#define STRING_STATE 9002
#define EOF_STATE 9003
#define DEC_INTEGER_STATE 9004
#define HEX_INTEGER_STATE 9005
#define OCT_INTEGER_STATE 9006

#define ACCEPT_STATE 10000
#define REJECT_STATE 10001

WbemLexicon *WbemAnalyser :: Get () 
{
    WbemLexicon *lexicon = NULL ;

    if ( stream )
    {
        lexicon = GetToken () ;
    }
    else
    {
        lexicon = new WbemLexicon ;
        lexicon->position = position ;
        lexicon->token = WbemLexicon :: EOF_ID ;
    }

    return lexicon ;
}

WbemLexicon *WbemAnalyser :: GetToken () 
{
    WbemLexicon *lexicon = new WbemLexicon ;
    lexicon->position = position ;
    ULONG state = 0 ;

/* 
 * Integer Definitions
 */

    BOOL negative = FALSE ;
    LONG magicMult = ( LONG ) ( ( ( ULONG ) ( 1L << 31L ) ) / 10L ) ; 
    LONG magicNegDigit = 8 ;
    LONG magicPosDigit = 7 ;
    LONG datum = 0 ;    

/*
 * String Definitions
 */
    ULONG string_start = 0 ;
    ULONG string_length = 0 ;
    WCHAR *string = NULL ;

/*
 * Token Definitions
 */

    ULONG token_start = 0 ;

/*
 * OID Definitions
 */
    ULONG hex_datum = 0 ;
    ULONG brace_position = 0 ;
    ULONG hex_repetitions = 0 ;
    ULONG nybbleRepetitions = 0 ;

    while ( state != REJECT_STATE && state != ACCEPT_STATE )
    {
        WCHAR token = stream [ position ] ;
        switch ( state )
        {
            case 0:
            {
                if ( IsLeadingDecimal ( token ) )
                {
                    state = DEC_INTEGER_START + 1  ;
                    datum = ( token - 48 ) ;
                }
                else if ( token == L'@' )
                {
                    lexicon->token = WbemLexicon :: AT_ID ;
                    state = ACCEPT_STATE ;
                } 
                else if ( token == L'\\' )
                {
                    lexicon->token = WbemLexicon :: BACKSLASH_ID ;
                    state = ACCEPT_STATE ;
                } 
                else if ( token == L'\"' )
                {
                    state = STRING_START ;
                    string_start = position + 1 ;
                }
                else if ( token == L'{' )
                {
                    state = OID_START ;
                    hex_datum = 0 ;
                    brace_position = position ;
                    hex_repetitions = 0 ;
                    nybbleRepetitions = 0 ;
                }
                else if ( token == L'}' )
                {
                    lexicon->token = WbemLexicon :: CLOSE_BRACE_ID ;
                    state = ACCEPT_STATE ;
                }
                else if ( token == L'=' )
                {
                    lexicon->token = WbemLexicon :: EQUALS_ID ;
                    state = ACCEPT_STATE ;
                }
                else if ( token == L'.' )
                {
                    lexicon->token = WbemLexicon :: DOT_ID ;
                    state = ACCEPT_STATE ;
                }
                else if ( token == L',' )
                {
                    lexicon->token = WbemLexicon :: COMMA_ID ;
                    state = ACCEPT_STATE ;
                }
                else if ( token == L':' )
                {
                    lexicon->token = WbemLexicon :: COLON_ID ;
                    state = ACCEPT_STATE ;
                }
                else if ( token == L'+' )
                {
                    state = DEC_INTEGER_START ;
                }
                else if ( token == L'-' ) 
                {
                    negative = TRUE ;
                    state = DEC_INTEGER_START ;
                }
                else if ( token == L'0' )
                {
                    state = 1 ;
                }
                else if ( IsWhitespace ( token ) ) 
                {
                    state = 0 ;
                }
                else if ( IsEof ( token ) )
                {
                    lexicon->token = WbemLexicon :: EOF_ID ;
                    state = ACCEPT_STATE ;
                }
                else if ( IsAlpha ( token ) )
                {
                    state = TOKEN_START ;
                    token_start = position ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case 1:
            {
                if ( token == L'x' || token == L'X' )
                {
                    state = HEX_INTEGER_START ;             
                }
                else if ( IsOctal ( token ) )
                {
                    state = OCT_INTEGER_START ;
                    datum = ( token - 48 ) ;
                }
                else
                {
                    lexicon->token = WbemLexicon :: INTEGER_ID ;
                    lexicon->value.integer = 0 ;
                    position -- ;
                    state = ACCEPT_STATE ;
                }
            }
            break ;

            case STRING_START:
            {
                if ( token == L'\"' )
                {
                    lexicon->token = WbemLexicon :: STRING_ID ;
                    state = ACCEPT_STATE ;
        
                    if ( position == string_start )
                    {
                        lexicon->value.string = new WCHAR [ 1 ] ;
                        lexicon->value.string [ 0 ] = 0 ;
                    }
                    else
                    {
                        lexicon->value.string = new WCHAR [ string_length + 1 ] ;
                        wcsncpy ( 

                            lexicon->value.string , 
                            string ,
                            string_length
                        ) ;

                        lexicon->value.string [ string_length ] = 0 ;

                        free ( string ) ;
                    }
                }
                else if ( token == IsEof ( token ) ) 
                {
                    state = REJECT_STATE ;
                    free ( string ) ;
                }
                else 
                {
                    string = ( WCHAR * ) realloc ( string , sizeof ( WCHAR ) * ( string_length + 1 ) ) ;

                    if (string == NULL)
                    {
                        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                    }

                    string [ string_length ] = token ;
                    string_length ++ ;
                    state = STRING_START ;
                }
            }
            break ;

            case STRING_START+1:
            {
                if ( token == L'\"' )
                {
                    string = ( WCHAR * ) realloc ( string , sizeof ( WCHAR ) * ( string_length + 1 ) ) ;

                    if (string == NULL)
                    {
                        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                    }

                    string [ string_length ] = L'\"' ;
                    string_length ++ ;
                    state = STRING_START ;
                }
                else if ( token == IsEof ( token ) ) 
                {
                    state = REJECT_STATE ;
                }
                else 
                {
                    string = ( WCHAR * ) realloc ( string , sizeof ( WCHAR ) * ( string_length + 1 ) ) ;

                    if (string == NULL)
                    {
                        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                    }

                    string [ string_length ] = token ;
                    string_length ++ ;
                    state = STRING_START ;
                }
            }
            break ;

            case TOKEN_START:
            {
                if ( IsAlphaNumeric ( token ) ) 
                {
                    state = TOKEN_START ;
                }
                else 
                {
                    state = ACCEPT_STATE ;
                    lexicon->token = WbemLexicon :: TOKEN_ID ;
                    lexicon->value.token = new WCHAR [ position - token_start + 1 ] ;
                    wcsncpy ( 

                        lexicon->value.token , 
                        & stream [ token_start ] , 
                        position - token_start 
                    ) ;

                    lexicon->value.token [ position - token_start ] = 0 ;

                    position -- ;
                }
            }
            break ;

            case HEX_INTEGER_START:
            {
                if ( IsHex ( token ) )
                {
                    datum = HexToDec ( token ) ;
                    state = HEX_INTEGER_START + 1 ;
                }
                else
                {
                    state = REJECT_STATE ;
                }
            }
            break ;

            case HEX_INTEGER_START+1:
            {
                if ( IsHex ( token ) )
                {
                    state = HEX_INTEGER_START + 1 ;

                    if ( datum > magicMult )
                    {
                        state = REJECT_STATE ;
                    }
                    else if ( datum == magicMult ) 
                    {
                        if ( HexToDec ( token ) > magicPosDigit ) 
                        {
                            state = REJECT_STATE ;
                        }
                    }

                    datum = ( datum << 4 ) + HexToDec ( token ) ;
                }
                else
                {
                    lexicon->token = WbemLexicon :: INTEGER_ID ;
                    lexicon->value.integer = datum ;
                    state = ACCEPT_STATE ;

                    position -- ;
                }
            }
            break ;

            case OCT_INTEGER_START:
            {
                if ( IsOctal ( token ) )
                {
                    state = OCT_INTEGER_START ;

                    if ( datum > magicMult )
                    {
                        state = REJECT_STATE ;
                    }
                    else if ( datum == magicMult ) 
                    {
                        if ( OctToDec ( token ) > magicPosDigit ) 
                        {
                            state = REJECT_STATE ;
                        }
                    }

                    datum = ( datum << 3 ) + OctToDec ( token ) ;

                }
                else
                {
                    lexicon->token = WbemLexicon :: INTEGER_ID ;
                    lexicon->value.integer = datum ;
                    state = ACCEPT_STATE ;

                    position -- ;
                }
            }
            break ;

            case DEC_INTEGER_START:
            {
                if ( IsDecimal ( token ) )
                {
                    state = DEC_INTEGER_START + 1 ;
                    datum = ( token - 48 ) ;
                }
                else 
                if ( IsWhitespace ( token ) ) 
                {
                    state = DEC_INTEGER_START ;
                }
                else state = REJECT_STATE ;
            }   
            break ;

            case DEC_INTEGER_START+1:
            {
                if ( IsDecimal ( token ) )
                {   
                    state = DEC_INTEGER_START + 1 ;

                    if ( datum > magicMult )
                    {
                        state = REJECT_STATE ;
                    }
                    else if ( datum == magicMult ) 
                    {
                        if ( negative ) 
                        {
                            if ( ( token - 48 ) > magicNegDigit ) 
                            {
                                state = REJECT_STATE ;
                            }
                        }
                        else
                        {
                            if ( ( token - 48 ) > magicPosDigit ) 
                            {
                                state = REJECT_STATE ;
                            }
                        }
                    }

                    datum = datum * 10 + ( token - 48 ) ;
                }
                else
                {
                    lexicon->token = WbemLexicon :: INTEGER_ID ;
                    if ( negative )
                    {
                        lexicon->value.integer = datum * -1 ;
                    }
                    else
                    {
                        lexicon->value.integer = datum ;
                    }

                    state = ACCEPT_STATE ;

                    position -- ;
                }
            }   
            break ;

            case OID_START:     // {xxxxxxxx
            {
                if ( IsHex ( token ) )
                {
                    hex_datum = hex_datum + ( HexToDec ( token ) << ( ( 7 - hex_repetitions ) << 2 ) ) ;
                    hex_repetitions ++ ;
                    if ( hex_repetitions == 8 ) 
                    {
                        state = OID_START + 1 ;
                        lexicon->value.guid.Data1 = hex_datum ;
                        hex_repetitions = 0 ;
                        hex_datum = 0 ;
                    }
                }
                else
                {
                    state = ACCEPT_STATE ;
                    position = brace_position ;
                    lexicon->token = WbemLexicon :: OPEN_BRACE_ID ;
                }
            }
            break ;

            case OID_START+1:   // {xxxxxxxx-
            {
                if ( token == L'-' )
                {
                    state = OID_START + 2 ;
                }
                else
                {
                    state = ACCEPT_STATE ;
                    position = brace_position ;
                    lexicon->token = WbemLexicon :: OPEN_BRACE_ID ;
                }
            }
            break ;

            case OID_START+2:   // {xxxxxxxx-xxxx
            {
                if ( IsHex ( token ) )
                {
                    hex_datum = hex_datum + ( HexToDec ( token ) << ( ( 3 - hex_repetitions ) << 2 ) ) ;
                    hex_repetitions ++ ;
                    if ( hex_repetitions == 4 ) 
                    {
                        lexicon->value.guid.Data2 = ( USHORT ) hex_datum ;
                        hex_repetitions = 0 ;
                        hex_datum = 0 ;
                        state = OID_START + 3 ;
                    }
                }
                else
                {
                    state = ACCEPT_STATE ;
                    position = brace_position ;
                    lexicon->token = WbemLexicon :: OPEN_BRACE_ID ;
                }
            }
            break ;

            case OID_START+3:   // {xxxxxxxx-xxxx-
            {
                if ( token == L'-' )
                {
                    state = OID_START + 4 ;
                }
                else
                {
                    state = ACCEPT_STATE ;
                    position = brace_position ;
                    lexicon->token = WbemLexicon :: OPEN_BRACE_ID ;
                }
            }
            break ;

            case OID_START+4:   // {xxxxxxxx-xxxx-xxxx
            {
                if ( IsHex ( token ) )
                {
                    hex_datum = hex_datum + ( HexToDec ( token ) << ( ( 3 - hex_repetitions ) <<2 ) ) ;
                    hex_repetitions ++ ;
                    if ( hex_repetitions == 4 ) 
                    {
                        lexicon->value.guid.Data3 = ( USHORT ) hex_datum ;
                        hex_repetitions = 0 ;
                        hex_datum = 0 ;
                        state = OID_START + 5 ;
                    }
                }
                else
                {
                    state = ACCEPT_STATE ;
                    position = brace_position ;
                    lexicon->token = WbemLexicon :: OPEN_BRACE_ID ;
                }
            }
            break ;

            case OID_START+5:   // {xxxxxxxx-xxxx-xxxx-
            {
                if ( token == L'-' )
                {
                    state = OID_START + 6 ;
                }
                else
                {
                    state = ACCEPT_STATE ;
                    position = brace_position ;
                    lexicon->token = WbemLexicon :: OPEN_BRACE_ID ;
                }
            }
            break ;

            case OID_START+6:   // {xxxxxxxx-xxxx-xxxx-xxxx
            {
                if ( IsHex ( token ) )
                {
                    hex_datum = hex_datum + ( HexToDec ( token ) << ( ( 1 - nybbleRepetitions ) << 2 ) ) ;
                    hex_repetitions ++ ;
                    nybbleRepetitions ++ ;

                    if ( hex_repetitions == 2 ) 
                    {
                        lexicon->value.guid.Data4 [ 0 ] = ( char ) hex_datum ;
                        hex_datum = 0 ;
                        nybbleRepetitions = 0 ;
                    }                       
                    else if ( hex_repetitions == 4 ) 
                    {
                        lexicon->value.guid.Data4 [ 1 ] = ( char ) hex_datum ;
                        hex_repetitions = 0 ;
                        hex_datum = 0 ;
                        nybbleRepetitions = 0 ;
                        state = OID_START + 7 ;
                    }
                }
                else
                {
                    state = ACCEPT_STATE ;
                    position = brace_position ;
                    lexicon->token = WbemLexicon :: OPEN_BRACE_ID ;
                }
            }
            break ;

            case OID_START+7:   // {xxxxxxxx-xxxx-xxxx-xxxx-
            {
                if ( token == L'-' )
                {
                    state = OID_START + 8 ;
                }
                else
                {
                    state = ACCEPT_STATE ;
                    position = brace_position ;
                    lexicon->token = WbemLexicon :: OPEN_BRACE_ID ;
                }
            }
            break ;

            case OID_START+8:   // {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
            {
                if ( IsHex ( token ) )
                {
                    hex_datum = hex_datum + ( HexToDec ( token ) << ( ( 1 - nybbleRepetitions ) << 2 ) ) ;
                    hex_repetitions ++ ;
                    nybbleRepetitions ++ ;

                    if ( hex_repetitions == 12 ) 
                    {
                        lexicon->value.guid.Data4 [ 7 ] = ( char ) hex_datum ;
                        hex_repetitions = 0 ;
                        nybbleRepetitions = 0 ;
                        hex_datum = 0 ;
                        state = OID_START + 9 ;
                    }
                    else if ( hex_repetitions % 2 == 0 ) 
                    {
                        lexicon->value.guid.Data4 [ 1 + ( hex_repetitions >> 1 ) ] = ( char ) hex_datum ;
                        hex_datum = 0 ;
                        nybbleRepetitions = 0 ;
                    }                       
                }
                else
                {
                    state = ACCEPT_STATE ;
                    position = brace_position ;
                    lexicon->token = WbemLexicon :: OPEN_BRACE_ID ;
                }
            }
            break ;

            case OID_START+9:   // {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
            {
                if ( token == L'}' )
                {
                    lexicon->token = WbemLexicon :: OID_ID ;                
                    state = ACCEPT_STATE ;
                }
                else
                {
                    state = ACCEPT_STATE ;
                    position = brace_position ;
                    lexicon->token = WbemLexicon :: OPEN_BRACE_ID ;
                }
            }
            break ;

            case ACCEPT_STATE:
            case REJECT_STATE:
            default:
            {
                state = REJECT_STATE ;
            } ;
            break ;
        }

        position ++ ;
    }

    status = ( state != REJECT_STATE ) ;

    return lexicon ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\pathprsr\namepath.cpp ===
//***************************************************************************

//

//  NAMEPATH.CPP

//

//  Module: OLE MS Provider Framework

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provtempl.h>
#include <provmt.h>
#include <instpath.h>

static wchar_t *UnicodeStringAppend ( const wchar_t *prefix , const wchar_t *suffix )
{
    int prefixTextLength = 0 ;
    if ( prefix )
    {
        prefixTextLength = wcslen ( prefix ) ;
    }

    int suffixTextLength = 0 ;
    if ( suffix )
    {
        suffixTextLength = wcslen ( suffix ) ;
    }

    if ( prefix || suffix )
    {
        int textLength = prefixTextLength + suffixTextLength ;
        wchar_t *textBuffer = new wchar_t [ textLength + 1 ] ;

        if ( prefix )
        {
            wcscpy ( textBuffer , prefix ) ;
        }

        if ( suffix )
        {
            wcscpy ( & textBuffer [ prefixTextLength ] , suffix ) ;
        }

        return textBuffer ;
    }   
    else
        return NULL ;
}

static wchar_t *UnicodeStringDuplicate ( const wchar_t *string ) 
{
    if ( string )
    {
        int textLength = wcslen ( string ) ;

        wchar_t *textBuffer = new wchar_t [ textLength + 1 ] ;
        wcscpy ( textBuffer , string ) ;

        return textBuffer ;
    }
    else
    {
        return NULL ;
    }
}

WbemNamespacePath :: WbemNamespacePath () : status ( FALSE ) ,
                                            pushedBack ( FALSE ) ,
                                            pushBack ( NULL ) ,
                                            server ( NULL ) ,
                                            relative ( FALSE ) ,
                                            nameSpaceListPosition ( NULL ) 
{
    nameSpaceList = new CList <wchar_t * , wchar_t * >  ;
}

void WbemNamespacePath :: SetUp () 
{
    status = FALSE ;
    pushedBack = FALSE ;
    pushBack = NULL ;
    server = NULL ;
    relative = FALSE ;
    nameSpaceListPosition = NULL ;
    nameSpaceList = new CList <wchar_t * , wchar_t * >  ;
}

WbemNamespacePath :: WbemNamespacePath (

    const WbemNamespacePath &nameSpacePathArg 

) : status ( FALSE ) ,
    pushedBack ( FALSE ) ,
    pushBack ( NULL ) ,
    server ( NULL ) ,
    relative ( FALSE ) ,
    nameSpaceListPosition ( NULL ) 
{
    nameSpaceList = new CList <wchar_t * , wchar_t * >  ;
    CList <wchar_t * , wchar_t *> *nameList = ( CList <wchar_t * , wchar_t *> * ) nameSpaceList ;
    CList <wchar_t * , wchar_t *> *copyNameList = ( CList <wchar_t * , wchar_t *> * ) nameSpacePathArg.nameSpaceList ;

    POSITION position = copyNameList->GetHeadPosition () ;
    while ( position )
    {
        wchar_t *name = copyNameList->GetNext ( position ) ;
        nameList->AddTail ( UnicodeStringDuplicate ( name ) ) ;
    }

    server = UnicodeStringDuplicate ( nameSpacePathArg.server ) ;
}

WbemNamespacePath :: ~WbemNamespacePath () 
{
    CleanUp () ;
}

void WbemNamespacePath :: CleanUp () 
{
    CList <wchar_t * , wchar_t *> *nameList = ( CList <wchar_t * , wchar_t *> * ) nameSpaceList ;
    POSITION position = nameList->GetHeadPosition () ;
    while ( position )
    {
        wchar_t *value = nameList->GetNext ( position ) ;   
        delete [] value ;
    }

    nameList->RemoveAll () ;

    delete ( CList <wchar_t * , wchar_t * > * ) nameSpaceList ;
    nameSpaceList = NULL ;

    delete pushBack ;
    pushBack = NULL ;

    delete [] server ;
    server = NULL ;

    relative = FALSE ;
}

BOOL WbemNamespacePath :: IsEmpty () const
{
    CList <wchar_t * , wchar_t *> *list = ( CList <wchar_t * , wchar_t *> * ) nameSpaceList ;
    return list->IsEmpty () ;
} 

ULONG WbemNamespacePath :: GetCount () const
{
    CList <wchar_t * , wchar_t *> *list = ( CList <wchar_t * , wchar_t *> * ) nameSpaceList ;
    return list->GetCount () ;
} 

void WbemNamespacePath :: Reset ()
{
    CList <wchar_t * , wchar_t *> *list = ( CList <wchar_t * , wchar_t *> * ) nameSpaceList ;
    nameSpaceListPosition = list->GetHeadPosition () ;
}

wchar_t *WbemNamespacePath :: Next () 
{
    wchar_t *value = NULL ;
    POSITION position = ( POSITION ) nameSpaceListPosition ;
    if ( position ) 
    {
        CList <wchar_t * , wchar_t *> *list = ( CList <wchar_t * , wchar_t *> * ) nameSpaceList ;
        value = list->GetNext ( position ) ;
        nameSpaceListPosition = position ;
    }
    return value ;
}

void WbemNamespacePath :: SetServer ( wchar_t *serverArg ) 
{
    delete [] server ;
    server = new wchar_t [ wcslen ( serverArg) + 1 ] ;
    wcscpy ( server , serverArg ) ;
}

void WbemNamespacePath :: Add ( wchar_t *nameSpace ) 
{
    CList <wchar_t * , wchar_t * > *list = ( CList <wchar_t * , wchar_t * > * ) nameSpaceList ;
    list->AddTail ( nameSpace ) ;
}

WbemNamespacePath :: operator void *() 
{
    return status ? this : NULL ;
}

wchar_t *WbemNamespacePath :: GetNamespacePath ()
{
    if ( status ) 
    {
        wchar_t *path = NULL ;

        if ( GetServer () )
        {
            path = UnicodeStringDuplicate ( L"\\\\" ) ;
            wchar_t *concatPath = UnicodeStringAppend ( path , GetServer () ) ;
            delete [] path ;
            path = concatPath ;
        }

        if ( ! Relative () )
        {
            wchar_t *concatPath = UnicodeStringAppend ( path , L"\\" ) ;
            delete [] path ;
            path = concatPath ;
        }
        
        wchar_t *pathComponent ;

        ULONG t_ComponentCount = 0 ;
        Reset () ;
        while ( pathComponent = Next () )
        {
            wchar_t *concatPath = NULL ;

            t_ComponentCount ++ ;
            if ( t_ComponentCount != GetCount () )
            {
                
                wchar_t *t_Temp = UnicodeStringAppend ( path , pathComponent ) ;
                concatPath = UnicodeStringAppend ( t_Temp , L"\\" ) ;
                delete [] t_Temp ;
            }
            else
            {
                concatPath = UnicodeStringAppend ( path , pathComponent ) ;
            }

            delete [] path ;
            path = concatPath ;
        }

        return path ;
    }
    else
        return NULL ;
}

BOOL WbemNamespacePath :: ConcatenatePath ( WbemNamespacePath &relative )
{
    BOOL status = FALSE ;
    
    if ( relative.Relative () )
    {
        status = TRUE ;

        relative.Reset () ;
        wchar_t *namespaceComponent ;
        while ( namespaceComponent = Next () )
        {
            Add ( UnicodeStringDuplicate ( namespaceComponent ) ) ;
        }
    }

    return status ;
}

void WbemNamespacePath :: PushBack ()
{
    pushedBack = TRUE ;
}

WbemLexicon *WbemNamespacePath :: Get ()
{
    if ( pushedBack )
    {
        pushedBack = FALSE ;
    }
    else
    {
        delete pushBack ;
        pushBack = analyser.Get () ;
    }

    return pushBack ;
}
    
WbemLexicon *WbemNamespacePath :: Match ( WbemLexicon :: LexiconToken tokenType )
{
    WbemLexicon *lexicon = Get () ;
    status = ( lexicon->GetToken () == tokenType ) ;
    return status ? lexicon : NULL ;
}

BOOL WbemNamespacePath :: SetNamespacePath ( wchar_t *tokenStream )
{
    CleanUp () ;
    SetUp () ;

    analyser.Set ( tokenStream ) ;

    status = TRUE ;

    WbemLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case WbemLexicon :: DOT_ID:
        {
            PushBack () ;
            NameSpaceRel () ;
        }
        break ;

        case WbemLexicon :: TOKEN_ID:
        {
            PushBack () ;
            NameSpaceRel () ;
        }
        break ;

        case WbemLexicon :: BACKSLASH_ID:
        {
            PushBack () ;
            BackSlashFactoredServerNamespace () ;
        }
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    Match ( WbemLexicon :: EOF_ID ) ;

    return status ;
} 

BOOL WbemNamespacePath :: BackSlashFactoredServerNamespace ()
{
    if ( Match ( WbemLexicon :: BACKSLASH_ID ) )
    {
        WbemLexicon *lookAhead = Get () ;
        switch ( lookAhead->GetToken () ) 
        {
            case WbemLexicon :: BACKSLASH_ID:
            {
                PushBack () ;
                BackSlashFactoredServerSpec () ;
            }
            break ;

            case WbemLexicon :: DOT_ID:
            {
                PushBack () ;
                NameSpaceRel () ;
            }
            break ;

            case WbemLexicon :: TOKEN_ID:
            {
                PushBack () ;
                NameSpaceRel () ;
            }
            break ;

            default:
            {
                status = FALSE ;
            }
        }
    }

    return status ;
}

BOOL WbemNamespacePath :: BackSlashFactoredServerSpec ()
{
    if ( Match ( WbemLexicon :: BACKSLASH_ID ) )
    {
        WbemLexicon *lookAhead = Get () ;
        switch ( lookAhead->GetToken () ) 
        {
            case WbemLexicon :: DOT_ID:
            {
                PushBack () ;
                WbemLexicon *token ;
                if ( token = Match ( WbemLexicon :: DOT_ID ) )
                {
                    SetServer ( L"." ) ;

                    WbemLexicon *lookAhead = Get () ;
                    switch ( lookAhead->GetToken () ) 
                    {
                        case WbemLexicon :: BACKSLASH_ID:
                        {
                            PushBack () ;
                            NameSpaceAbs () ;
                        }
                        break ;

                        case WbemLexicon :: EOF_ID:
                        {
                            PushBack () ;
                        }
                        break ;

                        default:
                        {
                            status = FALSE ;
                        }
                    }
                }
            }
            break ;

            case WbemLexicon :: TOKEN_ID:
            {
                PushBack () ;
                WbemLexicon *token ;
                if ( token = Match ( WbemLexicon :: TOKEN_ID ) )
                {
                    SetServer ( token->GetValue ()->token ) ;

                    WbemLexicon *lookAhead = Get () ;
                    switch ( lookAhead->GetToken () ) 
                    {
                        case WbemLexicon :: BACKSLASH_ID:
                        {
                            PushBack () ;
                            NameSpaceAbs () ;
                        }
                        break ;

                        case WbemLexicon :: EOF_ID:
                        {
                            PushBack () ;
                        }
                        break ;

                        default:
                        {
                            status = FALSE ;
                        }
                    }
                }
            }
            break ;

            default:
            {
                status = FALSE ;
            }
            break ;
        }
    }

    return status ;
}

BOOL WbemNamespacePath :: NameSpaceName ()
{
    WbemLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case WbemLexicon :: TOKEN_ID:
        {
            PushBack () ;
            WbemLexicon *token ;
            if ( token = Match ( WbemLexicon :: TOKEN_ID ) )
            {
                wchar_t *namespaceValue = token->GetValue ()->token ;

				if ( namespaceValue )
				{
					wchar_t *copy = new wchar_t [ wcslen ( namespaceValue ) + 1 ] ;
					wcscpy ( copy , namespaceValue ) ;

					Add ( copy ) ;
				}
				else
				{
					status = FALSE ;
				}
            }
        }
        break ;

        case WbemLexicon :: DOT_ID:
        {
            PushBack () ;
            WbemLexicon *token ;
            if ( token = Match ( WbemLexicon :: DOT_ID ) )
            {
                wchar_t *copy = new wchar_t [ wcslen ( L"." ) + 1 ] ;
                wcscpy ( copy , L"." ) ;

                Add ( copy ) ;
            }
        }
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    return status ;
}

BOOL WbemNamespacePath :: NameSpaceRel ()
{
    relative = TRUE ;

    NameSpaceName () &&
    RecursiveNameSpaceRel () ;
    
    return status ;
}

BOOL WbemNamespacePath :: RecursiveNameSpaceRel ()
{
    WbemLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case WbemLexicon :: BACKSLASH_ID:
        {
            PushBack () ;
            Match ( WbemLexicon :: BACKSLASH_ID ) &&            
            NameSpaceRel () ;
        }
        break ;

        case WbemLexicon :: EOF_ID:
        {
            PushBack () ;
        }
        break ;

        default:
        {
            status = FALSE ;
        }
    }

    return status ;

}

BOOL WbemNamespacePath :: NameSpaceAbs ()
{
    Match ( WbemLexicon :: BACKSLASH_ID ) &&
    NameSpaceName () &&
    RecursiveNameSpaceAbs () ;

    return status ;
}

BOOL WbemNamespacePath :: RecursiveNameSpaceAbs ()
{
    WbemLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case WbemLexicon :: BACKSLASH_ID:
        {
            PushBack () ;

            Match ( WbemLexicon :: BACKSLASH_ID ) &&
            NameSpaceName () &&
            RecursiveNameSpaceAbs () ;
        }
        break ;

        case WbemLexicon :: EOF_ID:
        {
            PushBack () ;
        }
        break ;

        default:
        {
            status = FALSE ;
        }
    }

    return status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\pathprsr\ansi\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\dsprovider\samples\putinst.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#define _WIN32_WINNT    0x0500

#include <windows.h>
#include <stdio.h>

#include <objbase.h>
#include <wbemcli.h>



void main()
{
	// Initialize COM. Remember the DS Provider needs impersonation to be called
	// so you have to call the COM function CoInitializeSecurity()
	// For this, you must #define _WIN32_WINNT to be greater than 0x0400. See top of file.
	HRESULT result;
	if(SUCCEEDED(CoInitialize(NULL)) && SUCCEEDED(CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, 0)))
	{
		// Create the IWbemLocator object 
		IWbemLocator *t_pLocator = NULL;
		if (SUCCEEDED(result = CoCreateInstance(CLSID_WbemLocator, 
			0, 
			CLSCTX_INPROC_SERVER,
            IID_IWbemLocator, (LPVOID *) &t_pLocator)))
		{
			// Connect to the correct namespace
			// The DS Provider operates in the root\directory\LDAP namespace
			IWbemServices *t_pNamespace = NULL;
			BSTR strNamespace = SysAllocString(L"root\\directory\\LDAP");
			if(SUCCEEDED(result = t_pLocator->ConnectServer(strNamespace, NULL, NULL, NULL, 0, NULL, NULL, &t_pNamespace)))
			{

				// This is *very important* since the DSProvider goes accross the process
				// Every IWbemServices interface obtained form the IWbemLocator has to
				// have the COM interface function IClientSecutiry::SetBlanket() called on it
				// for the DS Provider to work
				IClientSecurity *t_pSecurity = NULL ;
				if(SUCCEEDED(result = t_pNamespace->QueryInterface ( IID_IClientSecurity , (LPVOID *) & t_pSecurity )))
				{
					t_pSecurity->SetBlanket( 
						t_pNamespace , 
						RPC_C_AUTHN_WINNT, 
						RPC_C_AUTHZ_NONE, 
						NULL,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						RPC_C_IMP_LEVEL_IMPERSONATE, 
						NULL,
						EOAC_NONE
					);
					t_pSecurity->Release () ;
				}

				// Get an instance 
									// ds_user="LDAP://CN=Guest,CN=Users,DC=dsprovider,DC=nttest,DC=microsoft,DC=com"
				LPCWSTR pObjPath = L"ds_user=\"LDAP://CN=Guest,CN=Users,DC=dsprovider,DC=nttest,DC=microsoft,DC=com\"";
				BSTR strObjPath = SysAllocString(pObjPath);
				IWbemClassObject *t_pUserObject = NULL;
				if(SUCCEEDED(result = t_pNamespace->GetObject(strObjPath, 0, NULL, &t_pUserObject, NULL)))
				{
					// Create an IWbemContext object
					IWbemContext *t_pCtx = NULL;
					if(SUCCEEDED(result = CoCreateInstance(CLSID_WbemContext, 
						0, 
						CLSCTX_INPROC_SERVER,
						IID_IWbemContext, (LPVOID *) &t_pCtx)))
					{
						// Set the __PUT_EXTENSIONS
						VARIANT var;
						VariantInit(&var);
						var.vt = VT_BOOL;
						var.boolVal = VARIANT_TRUE;
						if(SUCCEEDED(result = t_pCtx->SetValue(L"__PUT_EXTENSIONS", 0, &var)))
						{
							VARIANT var2;
							VariantInit(&var2);
							SAFEARRAY *outputSafeArray = NULL;
							SAFEARRAYBOUND safeArrayBounds [ 1 ] ;
							safeArrayBounds[0].lLbound = 0 ;
							safeArrayBounds[0].cElements = 1 ;
							outputSafeArray = SafeArrayCreate (VT_BSTR, 1, safeArrayBounds);

							long idx = 0;
							SafeArrayPutElement(outputSafeArray, &idx, SysAllocString(L"ds_department"));
 
							var2.vt = VT_ARRAY | VT_BSTR ;
							var2.parray = outputSafeArray ; 		

							if(SUCCEEDED(result = t_pCtx->SetValue(L"__PUT_EXT_PROPERTIES", 0, &var)))
							{
								VARIANT descripVar;
								VariantInit(&descripVar);
								descripVar.vt = VT_BSTR;
								descripVar.bstrVal = SysAllocString(L"Dept");
								if(SUCCEEDED(result = t_pUserObject->Put(SysAllocString(L"ds_department"), 0, &descripVar, 0)))
								{
									if(SUCCEEDED(result = t_pNamespace->PutInstance(t_pUserObject, WBEM_FLAG_UPDATE_ONLY, t_pCtx, NULL)))
									{
										int i=8;
									}

								}
							}
						}
					}
					else
						printf("CoCreateContext FAILED with %x\n", result);
				}
				else
					printf("GetObject FAILED with %x\n", result);
			}
			else
				printf("ConnectServer FAILED with %x\n", result);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\pathprsr\objpath.cpp ===
//***************************************************************************

//

//  OBJPATH.CPP

//

//  Module: OLE MS Provider Framework

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provtempl.h>
#include <provmt.h>
#include <instpath.h>

WbemObjectPath :: WbemObjectPath () :       status ( TRUE ) ,
                                            pushedBack ( FALSE ) ,
                                            pushBack ( NULL ) ,
                                            propertyName ( NULL ) ,
                                            propertyValue ( NULL ) ,
                                            reference ( NULL )
{
}

void WbemObjectPath :: SetUp ()
{
    status = TRUE ;
    pushedBack = FALSE ;
    pushBack = NULL ;
    propertyName = NULL ;
    propertyValue = NULL ;
    reference = NULL ;
}

WbemObjectPath :: WbemObjectPath (

    const WbemObjectPath &objectPathArg

) : status ( TRUE ) ,
    pushedBack ( FALSE ) ,
    pushBack ( NULL ) ,
    propertyName ( NULL ) ,
    propertyValue ( NULL ) ,
    reference ( NULL )
{
}

WbemObjectPath :: ~WbemObjectPath () 
{
    CleanUp () ;
}

void WbemObjectPath :: CleanUp ()
{
    delete pushBack ;
    delete [] propertyName ;
    delete propertyValue ;
    delete reference ;
}

WbemObjectPath :: operator void *() 
{
    return status ? this : NULL ;
}
    
void WbemObjectPath :: PushBack ()
{
    pushedBack = TRUE ;
}

WbemLexicon *WbemObjectPath :: Get ()
{
    if ( pushedBack )
    {
        pushedBack = FALSE ;
    }
    else
    {
        delete pushBack ;
        pushBack = analyser.Get () ;
    }

    return pushBack ;
}
    
WbemLexicon *WbemObjectPath :: Match ( WbemLexicon :: LexiconToken tokenType )
{
    WbemLexicon *lexicon = Get () ;
    status = ( lexicon->GetToken () == tokenType ) ;
    return status ? lexicon : NULL ;
}

BOOL WbemObjectPath :: SetObjectPath ( wchar_t *tokenStream )
{
    CleanUp () ;
    SetUp () ;

    analyser.Set ( tokenStream ) ;

    WbemLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case WbemLexicon :: TOKEN_ID:
        {
            PushBack () ;
            TokenFactoredObjectSpecNamespace () ;
        }
        break ;

        case WbemLexicon :: BACKSLASH_ID:
        {
            PushBack () ;
            BackSlashFactoredServerNamespace () &&
            Match ( WbemLexicon :: COLON_ID ) &&
            ObjectSpec () ;
        }
        break ;

        case WbemLexicon :: DOT_ID:
        {
            PushBack () ;
            NameSpaceRel () &&
            Match ( WbemLexicon :: COLON_ID ) &&
            ObjectSpec () ;
        }
        break ;

        case WbemLexicon ::OID_ID:
        {
            PushBack () ;
            OidReferenceSpec () ;
        } 
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    Match ( WbemLexicon :: EOF_ID ) ;

    return status ;
} 

BOOL WbemObjectPath :: BackSlashFactoredServerNamespace ()
{
    if ( Match ( WbemLexicon :: BACKSLASH_ID ) )
    {
        WbemLexicon *lookAhead = Get () ;
        switch ( lookAhead->GetToken () ) 
        {
            case WbemLexicon :: BACKSLASH_ID:
            {
                PushBack () ;
                BackSlashFactoredServerSpec () ;
            }
            break ;

            case WbemLexicon :: DOT_ID:
            {
                PushBack () ;
                NameSpaceRel () ;
            }
            break ;

            case WbemLexicon :: TOKEN_ID:
            {
                PushBack () ;
                NameSpaceRel () ;
            }
            break ;

            default:
            {
                status = FALSE ;
            }
            break ;
        }
    }

    return status ;
}

BOOL WbemObjectPath :: BackSlashFactoredServerSpec ()
{
    if ( Match ( WbemLexicon :: BACKSLASH_ID ) )
    {
        WbemLexicon *lookAhead = Get () ;
        switch ( lookAhead->GetToken () ) 
        {
            case WbemLexicon :: DOT_ID:
            {
                PushBack () ;
                WbemLexicon *token ;
                if ( token = Match ( WbemLexicon :: DOT_ID ) )
                {
                    GetNamespacePath ()->SetServer ( L"." ) ;

                    WbemLexicon *lookAhead = Get () ;
                    switch ( lookAhead->GetToken () ) 
                    {
                        case WbemLexicon :: BACKSLASH_ID:
                        {
                            PushBack () ;
                            NameSpaceAbs () ;
                        }
                        break ;

                        case WbemLexicon :: COLON_ID:
                        {
                            PushBack () ;
                        }
                        break ;

                        default:
                        {
                            status = FALSE ;
                        }
                    }
                }
            }
            break ;

            case WbemLexicon :: TOKEN_ID:
            {
                PushBack () ;
                WbemLexicon *token ;
                if ( token = Match ( WbemLexicon :: TOKEN_ID ) )
                {
                    GetNamespacePath ()->SetServer ( token->GetValue ()->token ) ;

                    WbemLexicon *lookAhead = Get () ;
                    switch ( lookAhead->GetToken () ) 
                    {
                        case WbemLexicon :: BACKSLASH_ID:
                        {
                            PushBack () ;
                            NameSpaceAbs () ;
                        }
                        break ;

                        case WbemLexicon :: COLON_ID:
                        {
                            PushBack () ;
                        }
                        break ;

                        default:
                        {
                            status = FALSE ;
                        }
                    }
                }
            }
            break ;

            default:
            {
                status = FALSE ;
            }
            break ;
        }
    }

    return status ;
}

BOOL WbemObjectPath :: TokenFactoredObjectSpecNamespace ()
{
    WbemLexicon *token ;
    if ( token = Match ( WbemLexicon :: TOKEN_ID ) )
    {
        wchar_t *classOrNamespace = token->GetValue ()->token ;

		if ( classOrNamespace )
		{
			wchar_t *copy = new wchar_t [ wcslen ( classOrNamespace ) + 1 ] ;
			wcscpy ( copy , classOrNamespace ) ;

			WbemLexicon *lookAhead = Get () ;
			switch ( lookAhead->GetToken () ) 
			{
				case WbemLexicon :: BACKSLASH_ID:
				{
					GetNamespacePath()->Add ( copy ) ;

					PushBack () ;
					NameSpaceAbs () &&
					Match ( WbemLexicon :: COLON_ID ) &&
					ObjectSpec () ;
				}
				break ;

				case WbemLexicon :: COLON_ID:
				{
					PushBack () ;
					Match ( WbemLexicon :: COLON_ID ) &&
					ObjectSpec () ;
				}
				break ;

				case WbemLexicon :: DOT_ID:
				{
					reference = new WbemInstanceSpecification ;
					( ( WbemInstanceSpecification * ) reference ) ->SetClass ( copy ) ;
					delete [] copy ;

					PushBack () ;
					Match ( WbemLexicon :: DOT_ID ) &&
					KeyPropertySpec () ;
				}
				break ;

				case WbemLexicon :: EQUALS_ID:
				{
					PushBack () ;
					Match ( WbemLexicon :: EQUALS_ID ) &&
					FactoredAtPropertyValueSpec ( copy ) ;

					delete [] copy ;
				}
				break ;

				case WbemLexicon :: EOF_ID:
				{
					reference = new WbemClassReference ;
					( ( WbemClassReference * ) reference )->SetClass ( copy ) ;
					delete [] copy ;

					PushBack () ;
				}
				break ;

				default:
				{
					status = FALSE ;
					delete [] copy ;
				}
				break ;
			}
		}
		else
		{
			status = FALSE ;
		}
    }

    return status ;
}

BOOL WbemObjectPath :: NameSpaceName ()
{
    WbemLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case WbemLexicon :: TOKEN_ID:
        {
            PushBack () ;
            WbemLexicon *token ;
            if ( token = Match ( WbemLexicon :: TOKEN_ID ) )
            {
                wchar_t *namespaceValue = token->GetValue ()->token ;

				if ( namespaceValue )
				{
					wchar_t *copy = new wchar_t [ wcslen ( namespaceValue ) + 1 ] ;
					wcscpy ( copy , namespaceValue ) ;

					GetNamespacePath ()->Add ( copy ) ;
				}
				else
				{
					status = FALSE ;
				}
            }
        }
        break ;

        case WbemLexicon :: DOT_ID:
        {
            PushBack () ;
            WbemLexicon *token ;
            if ( token = Match ( WbemLexicon :: DOT_ID ) )
            {
                wchar_t *copy = new wchar_t [ wcslen ( L"." ) + 1 ] ;
                wcscpy ( copy , L"." ) ;

                GetNamespacePath ()->Add ( copy ) ;
            }
        }
        break ;


        default:
        {
            status = FALSE ;
        }
        break ;
    }

    return status ;
}

BOOL WbemObjectPath :: NameSpaceRel ()
{
    GetNamespacePath ()->SetRelative ( TRUE ) ;

    NameSpaceName () &&
    RecursiveNameSpaceRel () ;
    
    return status ;
}

BOOL WbemObjectPath :: RecursiveNameSpaceRel ()
{
    WbemLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case WbemLexicon :: BACKSLASH_ID:
        {
            PushBack () ;
            Match ( WbemLexicon :: BACKSLASH_ID ) &&
            NameSpaceName () &&
            RecursiveNameSpaceRel () ;
        }
        break ;

        case WbemLexicon :: COLON_ID:
        {
            PushBack () ;
        }
        break ;

        default:
        {
            status = FALSE ;
        }
    }

    return status ;

}

BOOL WbemObjectPath :: NameSpaceAbs ()
{
    Match ( WbemLexicon :: BACKSLASH_ID ) &&
    NameSpaceName () &&
    RecursiveNameSpaceAbs () ;

    return status ;
}

BOOL WbemObjectPath :: RecursiveNameSpaceAbs ()
{
    WbemLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case WbemLexicon :: BACKSLASH_ID:
        {
            PushBack () ;

            Match ( WbemLexicon :: BACKSLASH_ID ) &&
            NameSpaceName () &&
            RecursiveNameSpaceAbs () ;
        }
        break ;

        case WbemLexicon :: COLON_ID:
        {
            PushBack () ;
        }
        break ;

        default:
        {
            status = FALSE ;
        }
    }

    return status ;
}

BOOL WbemObjectPath :: ObjectSpec ()
{
    WbemLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case WbemLexicon :: TOKEN_ID:
        {
            PushBack () ;
            FactoredClassSpec () ;
        }
        break ;

        case WbemLexicon :: OID_ID:
        {
            PushBack () ;
            OidReferenceSpec () ;
        } 
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    return status ;
}

BOOL WbemObjectPath :: OidReferenceSpec ()
{
    Oid () ;

    return status ;
}

BOOL WbemObjectPath :: Oid ()
{
    WbemLexicon *token ;
    if ( token = Match ( WbemLexicon :: OID_ID ) )
    {
        reference = new WbemOidReference ;
        ( ( WbemOidReference * ) reference )->Set ( token->GetValue ()->guid ) ;
    }
    else
    {
        propertyValue = NULL ;
    }

    return status ;
}

BOOL WbemObjectPath :: String ()
{
    WbemLexicon *token = NULL;
	propertyValue = NULL ;

    if ( token = Match ( WbemLexicon :: STRING_ID ) )
    {   
        wchar_t *string = token->GetValue()->string ;

		if ( string )
		{
			propertyValue = new WbemPropertyStringValue ( string ) ;
		}
		else
		{
			status = FALSE ;
		}
    }

    return status ;
}

BOOL WbemObjectPath :: Token ()
{
    WbemLexicon *token = NULL;
	propertyValue = NULL ;

    if ( token = Match ( WbemLexicon :: TOKEN_ID ) )
    {
        wchar_t *tokenString = token->GetValue()->token ;

		if ( tokenString )
		{
			propertyValue = new WbemPropertyTokenValue ( tokenString ) ;
		}
		else
		{
			status = FALSE ;
		}
    }

    return status ;
}

BOOL WbemObjectPath :: Integer ()
{
    WbemLexicon *token = NULL ;

    if ( token = Match ( WbemLexicon :: INTEGER_ID ) )
    {
        LONG integer  = token->GetValue()->integer ;
        propertyValue = new WbemPropertyIntegerValue ( integer ) ;
    }
    else
    {
        propertyValue = NULL ;
    }


    return status ;
}

BOOL WbemObjectPath :: FactoredClassSpec ()
{
    WbemLexicon *token = NULL ;
    if ( token = Match ( WbemLexicon :: TOKEN_ID ) )
    {
        wchar_t *classNameValue = token->GetValue ()->token ;

		if ( classNameValue )
		{
			wchar_t *className = new wchar_t [ wcslen ( classNameValue ) + 1 ] ;

			try
			{
				wcscpy ( className , classNameValue ) ;

				PushBack () ;
				ClassReference () ;

				WbemLexicon *lookAhead = Get () ;
				switch ( lookAhead->GetToken () ) 
				{
					case WbemLexicon :: DOT_ID:
					{
						reference = new WbemInstanceSpecification ;
						( ( WbemInstanceSpecification * ) reference )->SetClass ( className ) ;
						delete [] className ;
						className = NULL;

						PushBack () ;
						Match ( WbemLexicon :: DOT_ID ) &&
						KeyPropertySpec () ;
					}
					break ;

					case WbemLexicon :: EQUALS_ID:
					{
						PushBack () ;
						Match ( WbemLexicon :: EQUALS_ID ) &&
						FactoredAtPropertyValueSpec ( className ) ;

						delete [] className ;
						className = NULL;
					}
					break ;

					case WbemLexicon :: EOF_ID:
					{
						reference = new WbemClassReference ;
						( ( WbemClassReference * ) reference )->SetClass ( className ) ;
						delete [] className ;
						className = NULL;

						PushBack () ;
					}
					break ;

					default:
					{
						delete [] className ;
						className = NULL;
						status = FALSE ;
					}
				}
			}
			catch (...)
			{
				if (className)
				{
					delete [] className;
				}

				throw;
			}
		}
		else
		{
			status = FALSE ;
		}
    }

    return status ;
}

BOOL WbemObjectPath :: FactoredAtPropertyValueSpec ( wchar_t *className )
{
    WbemLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case WbemLexicon :: AT_ID:
        {
            reference = new WbemKeyLessClassReference ;
            ( ( WbemKeyLessClassReference * ) reference )->SetClass ( className ) ;
        }
        break ;

        default:
        {
            reference = new WbemClassKeySpecification ;
            ( ( WbemClassKeySpecification * ) reference )->SetClass ( className ) ;

            PushBack () ;
            PropertyValueSpec () ;

            ( ( WbemClassKeySpecification * ) reference )->SetClassValue ( propertyValue ) ;
            propertyValue = NULL ;
        }
        break ;
    }

    return status ;
}

BOOL WbemObjectPath :: PropertyReference ()
{
    WbemLexicon *token = NULL ;
    propertyName = NULL ;

    if ( token = Match ( WbemLexicon :: TOKEN_ID ) )
    {   
        wchar_t *tokenArg = token->GetValue()->token ;

		if ( tokenArg )
		{
			wchar_t *token = new wchar_t [ wcslen ( tokenArg ) + 1 ] ;
			wcscpy ( token , tokenArg ) ;
			propertyName = token ;
		}
		else
		{
			status = FALSE ;
		}
    }

    return status ;
}

BOOL WbemObjectPath :: ClassReference ()
{
    if ( Match ( WbemLexicon :: TOKEN_ID ) )
    {   
    }

    return status ;
}

BOOL WbemObjectPath :: KeyPropertyPair ()
{
    PropertyReference () &&
    Match ( WbemLexicon :: EQUALS_ID ) &&
    PropertyValueSpec () ;

    if ( status )
    {
        WbemPropertyNameValue *propertyNameValue = new WbemPropertyNameValue (

            propertyName ,
            propertyValue
        ) ;

        ( ( WbemInstanceSpecification * ) reference )->Add ( propertyNameValue ) ;
    }
    else
    {
        delete [] propertyName ;
        delete propertyValue ;
    }

    propertyName = NULL ;
    propertyValue = NULL ;

    return status ;
}

BOOL WbemObjectPath :: KeyPropertySpec ()
{
    KeyPropertyPair () &&
    RecursiveKeyPropertyPair () ;

    return status ;
}

BOOL WbemObjectPath :: RecursiveKeyPropertyPair ()
{
    WbemLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case WbemLexicon :: COMMA_ID:
        {
            PushBack () ;
            Match ( WbemLexicon :: COMMA_ID ) &&
            KeyPropertyPair () &&
            RecursiveKeyPropertyPair () ;
        }
        break ;

        case WbemLexicon :: EOF_ID:
        {
            PushBack () ;
        } 
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    return status ;
}

BOOL WbemObjectPath :: PropertyValueSpec () 
{
    WbemLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case WbemLexicon :: INTEGER_ID:
        {
            PushBack () ;
            AtomicPropertyValueSpec () ;
        }
        break ;

        case WbemLexicon :: TOKEN_ID:
        {
            PushBack () ;
            AtomicPropertyValueSpec () ;
        }
        break ;

        case WbemLexicon :: OID_ID:
        {
            PushBack () ;
            AtomicPropertyValueSpec () ;
        } 
        break ;

        case WbemLexicon :: STRING_ID:
        {
            PushBack () ;
            AtomicPropertyValueSpec () ;
        } 
        break ;

        case WbemLexicon :: OPEN_BRACE_ID:
        {
            PushBack () ;
            ArraySpec () ;
        }
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    return status ;
}

BOOL WbemObjectPath :: AtomicPropertyValueSpec () 
{
    WbemLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case WbemLexicon :: INTEGER_ID:
        {
            PushBack () ;
            Integer () ;
        }
        break ;

        case WbemLexicon :: TOKEN_ID:
        {
            PushBack () ;
            Token () ;
        }
        break ;
        
        case WbemLexicon :: STRING_ID:
        {
            PushBack () ;
            String () ;
        } 
        break ;

        case WbemLexicon :: OID_ID:
        default:
        {
            status = FALSE ;
        }
        break ;
    }

    return status ;
}

BOOL WbemObjectPath :: ArrayAtomicPropertyValueSpec ()
{
    AtomicPropertyValueSpec () ;
    if ( status ) 
    {
        arrayPropertyValue->Add ( propertyValue ) ;
    }
    else
    {
        delete propertyValue ;
    }

    propertyValue = NULL ;

    return status ;
}

BOOL WbemObjectPath :: ArraySpec () 
{
    arrayPropertyValue = new WbemPropertyListValue ;

    Match ( WbemLexicon :: OPEN_BRACE_ID ) &&
    PropertyAtomicValueList () &&
    Match ( WbemLexicon :: CLOSE_BRACE_ID ) ;

    propertyValue = arrayPropertyValue ;
    arrayPropertyValue = NULL ;
    return status ;
}

BOOL WbemObjectPath :: PropertyAtomicValueList ()
{
    ArrayAtomicPropertyValueSpec () &&
    RecursiveAtomicPropertyValueSpec () ;

    return status ;
}

BOOL WbemObjectPath :: RecursiveAtomicPropertyValueSpec ()
{
    WbemLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case WbemLexicon :: COMMA_ID:
        {
            PushBack () ;
            Match ( WbemLexicon :: COMMA_ID ) &&
            ArrayAtomicPropertyValueSpec () &&
            RecursiveAtomicPropertyValueSpec () ;
        }
        break ;

        case WbemLexicon :: CLOSE_BRACE_ID:
        {
            PushBack () ;
        } 
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    return status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\pathprsr\unicode\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\pathprsr\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// All Rights Reserved.
//

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
#include <provexpt.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provexpt\ansi\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\pathprsr\objvalue.cpp ===
//***************************************************************************

//

//  OBJVALUE.CPP

//

//  Module: OLE MS Provider Framework

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provtempl.h>
#include <provmt.h>
#include <instpath.h>

WbemPropertyListValue :: WbemPropertyListValue ()
{
    propertyListValue = new CList <WbemPropertyValue * , WbemPropertyValue *> ;
}

WbemPropertyListValue :: WbemPropertyListValue ( const WbemPropertyListValue &listValue ) 
{
    propertyListValue = new CList <WbemPropertyValue * , WbemPropertyValue *> ;
    CList <WbemPropertyValue * , WbemPropertyValue *> *list = ( CList <WbemPropertyValue * , WbemPropertyValue *> * ) propertyListValue ;
    CList <WbemPropertyValue * , WbemPropertyValue *> *copyList = ( CList <WbemPropertyValue * , WbemPropertyValue *> * ) listValue.propertyListValue ;

    POSITION position = copyList->GetHeadPosition () ;
    while ( position )
    {
        WbemPropertyValue *value = copyList->GetNext ( position ) ; 
        list->AddTail ( value->Copy () ) ;
    }
}

WbemPropertyListValue :: ~WbemPropertyListValue ()
{   
    CList <WbemPropertyValue * , WbemPropertyValue *> *list = ( CList <WbemPropertyValue * , WbemPropertyValue *> * ) propertyListValue ;

    POSITION position = list->GetHeadPosition () ;
    while ( position )
    {
        WbemPropertyValue *value = list->GetNext ( position ) ; 
        delete value ;
    }

    list->RemoveAll () ;

    delete ( CList <WbemPropertyValue * , WbemPropertyValue *> * ) propertyListValue ;
}

WbemPropertyValue *WbemPropertyListValue :: Copy () const
{
    return new WbemPropertyListValue ( *this ) ;
}

ULONG WbemPropertyListValue :: GetCount () const
{
    CList <WbemPropertyValue * , WbemPropertyValue *> *list = ( CList <WbemPropertyValue * , WbemPropertyValue *> * ) propertyListValue ;
    return list->GetCount () ;
} 

BOOL WbemPropertyListValue :: IsEmpty () const
{
    CList <WbemPropertyValue * , WbemPropertyValue *> *list = ( CList <WbemPropertyValue * , WbemPropertyValue *> * ) propertyListValue ;
    return list->IsEmpty () ;
}

void WbemPropertyListValue :: Reset ()
{
    CList <WbemPropertyValue * , WbemPropertyValue *> *list = ( CList <WbemPropertyValue * , WbemPropertyValue *> * ) propertyListValue ;
    listPosition = list->GetHeadPosition () ;
}

WbemPropertyValue *WbemPropertyListValue :: Next () 
{
    WbemPropertyValue *value = NULL ;
    POSITION position = ( POSITION ) listPosition ;
    if ( position )
    {
        CList <WbemPropertyValue * , WbemPropertyValue *> *list = ( CList <WbemPropertyValue * , WbemPropertyValue *> * ) propertyListValue ;
        value = list->GetNext ( position ) ;
        listPosition = position ;
    }

    return value ;
}

void WbemPropertyListValue :: Add ( WbemPropertyValue *propertyValue )
{
    CList <WbemPropertyValue * , WbemPropertyValue *> *list = ( CList <WbemPropertyValue * , WbemPropertyValue *> * ) propertyListValue ;
    list->AddTail ( propertyValue ) ;
}

WbemPropertyNameValue :: WbemPropertyNameValue (

    const WbemPropertyNameValue &propertyNameValue 
)
{
    wchar_t *name = propertyNameValue.GetName () ;
    propertyName = new wchar_t [ wcslen ( name ) + 1 ] ;
    wcscpy ( propertyName , name ) ;

    propertyValue = propertyNameValue.GetValue ()->Copy () ;
}

WbemPropertyNameValue :: WbemPropertyNameValue (

    wchar_t *name ,
    WbemPropertyValue *value 
)
{
    propertyName = name ;
    propertyValue = value ;
}

WbemPropertyNameValue :: ~WbemPropertyNameValue ()
{
    delete [] propertyName ;
    delete propertyValue ;
}

WbemOidReference :: WbemOidReference () 
{
}

WbemOidReference :: WbemOidReference ( const WbemOidReference &copy ) : guid ( copy.guid )
{
}

WbemOidReference :: ~WbemOidReference () 
{
}

WbemClassReference :: WbemClassReference () : className ( NULL )
{
}

WbemClassReference :: WbemClassReference ( const WbemClassReference &copy )
{
    className = new wchar_t [ wcslen ( copy.className ) + 1 ] ;
    wcscpy ( className , copy.className ) ;
}

WbemClassReference :: ~WbemClassReference () 
{
    delete [] className ;
}

void WbemClassReference :: SetClass ( wchar_t *classArg ) 
{
    delete [] className ;
    className = new wchar_t [ wcslen ( classArg ) + 1 ] ;
    wcscpy ( className , classArg ) ;
}

WbemKeyLessClassReference :: WbemKeyLessClassReference () : className ( NULL )
{
}

WbemKeyLessClassReference :: WbemKeyLessClassReference ( const WbemKeyLessClassReference &copy )
{
    className = new wchar_t [ wcslen ( copy.className ) + 1 ] ;
    wcscpy ( className , copy.className ) ;
}

WbemKeyLessClassReference :: ~WbemKeyLessClassReference () 
{
    delete [] className ;
}

void WbemKeyLessClassReference :: SetClass ( wchar_t *classArg ) 
{
    delete [] className ;
    className = new wchar_t [ wcslen ( classArg ) + 1 ] ;
    wcscpy ( className , classArg ) ;
}

WbemClassKeySpecification :: WbemClassKeySpecification () : className ( NULL ) , classValue ( NULL )
{
}

WbemClassKeySpecification :: WbemClassKeySpecification ( const WbemClassKeySpecification &copy ) 
{
    className = new wchar_t [ wcslen ( copy.className ) + 1 ] ;
    wcscpy ( className , copy.className ) ;

    classValue = copy.classValue->Copy () ; 
}

WbemClassKeySpecification :: ~WbemClassKeySpecification () 
{
    delete [] className ;
    delete classValue ;
}

void WbemClassKeySpecification :: SetClass ( wchar_t *classArg ) 
{
    delete [] className ;
    className = new wchar_t [ wcslen ( classArg ) + 1 ] ;
    wcscpy ( className , classArg ) ;
}

void WbemClassKeySpecification :: SetClassValue ( WbemPropertyValue *propertyValueArg )  
{ 
    delete classValue ;
    classValue = propertyValueArg ; 
} ;

WbemInstanceSpecification :: WbemInstanceSpecification ( const WbemInstanceSpecification &copy ) 
{
    className = new wchar_t [ wcslen ( copy.className ) + 1 ] ;
    wcscpy ( className , copy.className ) ;

    propertyNameValueList = new CList <WbemPropertyNameValue * , WbemPropertyNameValue *> ;
    CList <WbemPropertyNameValue *, WbemPropertyNameValue *> *propList = ( CList <WbemPropertyNameValue *, WbemPropertyNameValue *> * ) propertyNameValueList ;
    CList <WbemPropertyNameValue *, WbemPropertyNameValue *> *copyPropList = ( CList <WbemPropertyNameValue *, WbemPropertyNameValue *> * ) copy.propertyNameValueList ;

    POSITION  position = copyPropList->GetHeadPosition () ;
    while ( position )
    {
        WbemPropertyNameValue *value = copyPropList->GetNext ( position ) ; 
        propList->AddTail ( value->Copy () ) ;
        delete value ;
    }
}

WbemInstanceSpecification :: WbemInstanceSpecification () : className ( NULL ) 
{
    propertyNameValueList = new CList <WbemPropertyNameValue * , WbemPropertyNameValue *> ;
}

WbemInstanceSpecification :: ~WbemInstanceSpecification () 
{
    CList <WbemPropertyNameValue *, WbemPropertyNameValue *> *propList = ( CList <WbemPropertyNameValue *, WbemPropertyNameValue *> * ) propertyNameValueList ;
    POSITION  position = propList->GetHeadPosition () ;
    while ( position )
    {
        WbemPropertyNameValue *value = propList->GetNext ( position ) ; 
        delete value ;
    }

    propList->RemoveAll () ;

    delete [] className ;
    delete ( CList <WbemPropertyNameValue * , WbemPropertyNameValue *> * ) propertyNameValueList ;
}

void WbemInstanceSpecification :: SetClass ( wchar_t *classArg ) 
{
    delete [] className ;
    className = new wchar_t [ wcslen ( classArg ) + 1 ] ;
    wcscpy ( className , classArg ) ;
}

BOOL WbemInstanceSpecification :: IsEmpty () const
{
    CList <WbemPropertyNameValue * , WbemPropertyNameValue *> *list = ( CList <WbemPropertyNameValue * , WbemPropertyNameValue *> * ) propertyNameValueList ;
    return list->IsEmpty () ;
} 

ULONG WbemInstanceSpecification :: GetCount () const
{
    CList <WbemPropertyNameValue * , WbemPropertyNameValue *> *list = ( CList <WbemPropertyNameValue * , WbemPropertyNameValue *> * ) propertyNameValueList ;
    return list->GetCount () ;
} 

void WbemInstanceSpecification :: Reset ()
{
    CList <WbemPropertyNameValue * , WbemPropertyNameValue *> *list = ( CList <WbemPropertyNameValue * , WbemPropertyNameValue *> * ) propertyNameValueList ;
    propertyNameValueListPosition = list->GetHeadPosition () ;
}

WbemPropertyNameValue *WbemInstanceSpecification :: Next ()
{
    WbemPropertyNameValue *value = NULL ;
    POSITION position = ( POSITION ) propertyNameValueListPosition ;
    if ( position )
    {
        CList <WbemPropertyNameValue * , WbemPropertyNameValue *> *list = ( CList <WbemPropertyNameValue * , WbemPropertyNameValue *> * ) propertyNameValueList ;
        value = list->GetNext ( position ) ;
        propertyNameValueListPosition = position ;
    }
    
    return value ;
}

void WbemInstanceSpecification :: Add ( WbemPropertyNameValue *propertyNameValue )
{
    CList <WbemPropertyNameValue * , WbemPropertyNameValue *> *list = ( CList <WbemPropertyNameValue * , WbemPropertyNameValue *> * ) propertyNameValueList ;
    list->AddTail ( propertyNameValue ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provexpt\unicode\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\pathprsr\sources.inc ===
#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

WMIPRECOMPSHARED=1

!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETNAME=pathprsr
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=$(INCLUDES); \
	$(FRAMEWORK_PARSER_INC); \
	$(FRAMEWORK_EXPT_INC); \
	$(FRAMEWORK_MFC_INC)

SOURCES= \
	..\analyser.cpp \
    ..\namepath.cpp \
    ..\objpath.cpp \
    ..\objvalue.cpp

C_DEFINES=$(C_DEFINES) 
USE_RTTI=1
USE_NATIVE_EH=ASYNC
USE_MSVCRT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\pathprsr\include\instpath.h ===
//***************************************************************************

//

//  INSTPATH.H

//

//  Module: OLE MS Provider Framework

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#define OLEMS_PATH_SERVER_SEPARATOR L"\\\\"
#define OLEMS_PATH_NAMESPACE_SEPARATOR L"\\"
#define OLEMS_PATH_PROPERTY_SEPARATOR L","
#define OLEMS_PATH_CLASSOBJECT_SEPARATOR L":"
#define OLEMS_PATH_CLASSPROPERTYSPEC_SEPARATOR L"."
#define OLEMS_PATH_PROPERTYEQUIVALENCE L"="
#define OLEMS_PATH_ARRAY_START_SEPARATOR L"{"
#define OLEMS_PATH_ARRAY_END_SEPARATOR L"}"
#define OLEMS_PATH_SERVER_DEFAULT L"."
#define OLEMS_PATH_NAMESPACE_DEFAULT L"."
#define OLEMS_PATH_SINGLETON L"*"

//---------------------------------------------------------------------------
//
//	Class:		WbemLexiconValue
//
//  Purpose:	WbemLexiconValue provides a lexical token semantic value.
//
//  Description:	WbemAnalyser provides an implementation of a lexical 
//					analyser token semantic value
//
//---------------------------------------------------------------------------

union WbemLexiconValue
{
	LONG integer ;
	WCHAR *string ;
	GUID guid ;
	WCHAR *token ;
} ;

//---------------------------------------------------------------------------
//
//	Class:		WbemLexicon
//
//  Purpose:	WbemLexicon provides a lexical token creating during
//				lexical analysis.
//
//  Description:	WbemAnalyser provides an implementation of a lexical 
//					analyser token object
//
//---------------------------------------------------------------------------

class WbemAnalyser;
class WbemLexicon
{
friend WbemAnalyser ;

public:

enum LexiconToken {

	TOKEN_ID ,
	STRING_ID ,
	OID_ID ,
	INTEGER_ID ,
	COMMA_ID ,
	OPEN_BRACE_ID ,
	CLOSE_BRACE_ID ,
	COLON_ID ,
	DOT_ID ,
	AT_ID ,
	EQUALS_ID ,
	BACKSLASH_ID ,
	EOF_ID
} ;

private:

	WCHAR *tokenStream ;
	ULONG position ;
	LexiconToken token ;
	WbemLexiconValue value ;

protected:
public:

	WbemLexicon () ;
	~WbemLexicon () ;

	WbemLexicon :: LexiconToken GetToken () ;
	WbemLexiconValue *GetValue () ;
} ;

//---------------------------------------------------------------------------
//
//	Class:		WbemAnalyser
//
//  Purpose:	WbemAnalyser provides a lexical analyser for parsing.
//
//  Description:	WbemAnalyser provides an implementation of a lexical 
//					analyser used by WbemNamespacePath and WbemObjectPath
//					classes during path parsing.
//
//---------------------------------------------------------------------------

class WbemAnalyser
{
private:

	WCHAR *stream ;
	ULONG position ;
	BOOL status ;

	BOOL IsEof ( WCHAR token ) ;
	BOOL IsLeadingDecimal ( WCHAR token ) ;
	BOOL IsDecimal ( WCHAR token ) ;
	BOOL IsOctal ( WCHAR token ) ;
	BOOL IsHex ( WCHAR token ) ;	
	BOOL IsAlpha ( WCHAR token ) ;
	BOOL IsAlphaNumeric ( WCHAR token ) ;
	BOOL IsWhitespace ( WCHAR token ) ;

	LONG OctToDec ( WCHAR token ) ;
	LONG HexToDec ( WCHAR token ) ;

	WbemLexicon *GetToken () ;

protected:
public:

	WbemAnalyser ( WCHAR *tokenStream = NULL ) ;
	virtual ~WbemAnalyser () ;

	void Set ( WCHAR *tokenStream ) ;

	WbemLexicon *Get () ;

	void PutBack ( WbemLexicon *token ) ;

	virtual operator void * () ;

} ;

//---------------------------------------------------------------------------
//
//	Class:		WbemPropertyIntegerValue
//
//  Purpose:	Defines the base class for all OLE MS property value specifications
//
//  Description:	WbemPropertyIntegerValue provides no implementation, it is used
//					to form a polymorphic class hierarchy.
//
//---------------------------------------------------------------------------

class WbemPropertyValue
{
private:
protected:

	WbemPropertyValue () {} ;

public:

	virtual ~WbemPropertyValue () {} ;

	virtual WbemPropertyValue *Copy () const = 0 ;
} ;

//---------------------------------------------------------------------------
//
//	Class:		WbemPropertyIntegerValue
//
//  Purpose:	Defines an integer valued property 
//
//  Description:	WbemPropertyIntegerValue provides an implementation
//					of an integer valued WbemPropertyValue
//
//---------------------------------------------------------------------------

class WbemPropertyIntegerValue : public WbemPropertyValue
{
private:

	LONG integer ;

protected:
public:

	WbemPropertyIntegerValue ( LONG integerArg ) { integer = integerArg ; } ;
	WbemPropertyIntegerValue ( const WbemPropertyIntegerValue &value ) { integer = value.integer ; } 
	~WbemPropertyIntegerValue () {} ;

	LONG Get () { return integer ; }

	WbemPropertyValue *Copy () const { return new WbemPropertyIntegerValue ( *this ) ; }

} ;

//---------------------------------------------------------------------------
//
//	Class:		WbemPropertyStringValue
//
//  Purpose:	Defines a string valued property 
//
//  Description:	WbemPropertyStringValue provides an implementation
//					of a string valued WbemPropertyValue
//
//---------------------------------------------------------------------------

class WbemPropertyStringValue : public WbemPropertyValue
{
private:

	WCHAR *string ;

protected:
public:

	WbemPropertyStringValue ( WCHAR *stringArg ) 
	{
		string = new WCHAR [ wcslen ( stringArg ) + 1 ] ;
		wcscpy ( string , stringArg ) ;
	} ;

	WbemPropertyStringValue ( const WbemPropertyStringValue &stringValue ) 
	{
		string = new WCHAR [ wcslen ( stringValue.string ) + 1 ] ;
		wcscpy ( string , stringValue.string ) ;
	} ;

	~WbemPropertyStringValue () { delete [] string ; } ;

	WCHAR *Get () { return string ; } ;

	WbemPropertyValue *Copy () const { return new WbemPropertyStringValue ( *this ) ; }
} ;

//---------------------------------------------------------------------------
//
//	Class:		WbemPropertyTokenValue
//
//  Purpose:	Defines a token valued property 
//
//  Description:	WbemPropertyTokenValue provides an implementation
//					of a token valued WbemPropertyValue
//
//---------------------------------------------------------------------------

class WbemPropertyTokenValue : public WbemPropertyValue
{
private:

	WCHAR *token ;

protected:
public:

	WbemPropertyTokenValue ( WCHAR *tokenArg ) 
	{
		token = new WCHAR [ wcslen ( tokenArg ) + 1 ] ;
		wcscpy ( token , tokenArg ) ;
	} ;

	WbemPropertyTokenValue ( const WbemPropertyTokenValue &tokenValue ) 
	{
		token = new WCHAR [ wcslen ( tokenValue.token ) + 1 ] ;
		wcscpy ( token , tokenValue.token ) ;
	}

	~WbemPropertyTokenValue () { delete [] token ; } ;

	WCHAR *Get () { return token ; } ;

	WbemPropertyValue *Copy () const { return new WbemPropertyTokenValue ( *this ) ; }
} ;

//---------------------------------------------------------------------------
//
//	Class:		WbemPropertyGuidValue
//
//  Purpose:	Defines a guid valued property 
//
//  Description:	WbemPropertyGuidValue provides an implementation
//					of a guid valued WbemPropertyValue
//
//---------------------------------------------------------------------------

class WbemPropertyGuidValue : public WbemPropertyValue
{
private:

	GUID guid ;

protected:
public:

	WbemPropertyGuidValue ( GUID guidArg ) { guid = guidArg ; } ;
	WbemPropertyGuidValue ( const WbemPropertyGuidValue &guidValue ) { guid = guidValue.guid ; }
	~WbemPropertyGuidValue () {} ;

	GUID Get () { return guid ; }

	WbemPropertyValue *Copy () const { return new WbemPropertyGuidValue ( *this ) ; }
} ;

//---------------------------------------------------------------------------
//
//	Class:		WbemPropertyListValue
//
//  Purpose:	Defines an array valued property 
//
//  Description:	WbemPropertyListValue provides an implementation
//					of an arrayed valued WbemPropertyValue. Each element
//					of array contains a reference to a polymorphic WbemPropertyValue
//
//---------------------------------------------------------------------------

class WbemPropertyListValue : public WbemPropertyValue
{
private:

	void *listPosition ;
	void *propertyListValue ;

protected:
public:

	WbemPropertyListValue () ;
	WbemPropertyListValue ( const WbemPropertyListValue &listValue ) ;
	~WbemPropertyListValue () ;

	BOOL IsEmpty () const ;
	ULONG GetCount () const ;	
	void Reset () ;
	WbemPropertyValue *Next () ;

	void Add ( WbemPropertyValue *propertyValue ) ;

	WbemPropertyValue *Copy () const ;
} ;

//---------------------------------------------------------------------------
//
//	Class:		WbemPropertyNameValue
//
//  Purpose:	Defines a property name,property valued pair. 
//
//  Description:	WbemPropertyNameValue provides an implementation
//					of an WCHAR * / WbemPropertyValue, representing a 
//					property name / property value pair
//
//---------------------------------------------------------------------------

class WbemPropertyNameValue 
{
private:

	WCHAR *propertyName ;
	WbemPropertyValue *propertyValue ;
	
protected:
public:

	WbemPropertyNameValue ( WCHAR *name , WbemPropertyValue *value ) ;
	WbemPropertyNameValue ( const WbemPropertyNameValue &nameValue ) ;
	virtual ~WbemPropertyNameValue () ;

	WCHAR *GetName () const { return propertyName ; }
	WbemPropertyValue *GetValue () const { return propertyValue ; }

	WbemPropertyNameValue *Copy () const { return new WbemPropertyNameValue ( *this ) ; }
} ;

//---------------------------------------------------------------------------
//
//	Class:		WbemObjectReference
//
//  Purpose:	Defines the base class for all OLE MS object specifications
//
//  Description:	WbemObjectReference provides no implementation, it is used
//					to form a polymorphic class hierarchy.
//
//---------------------------------------------------------------------------

class WbemObjectReference
{
private:
protected:

	WbemObjectReference () {} ;

public:

	virtual ~WbemObjectReference () {} ;

	virtual WbemObjectReference *Copy () const = 0 ;
} ;

//---------------------------------------------------------------------------
//
//	Class:		WbemOidReference
//
//  Purpose:	Defines interface for OLE MS oid specification definitions.
//
//  Description:	WbemOidReference allows the creation of an OLE MS 
//					oid specification, i.e. specify the guid of an OLE MS 
//					class or instance object
//
//						e.g. {12345678-abcd-ef12-ABCD-ABCDEF123456} 
//
//---------------------------------------------------------------------------

class WbemOidReference : public WbemObjectReference
{
private:

	GUID guid ;

protected:
public:

	WbemOidReference () ;
	WbemOidReference ( const WbemOidReference &oidReference ) ;
	~WbemOidReference () ;

	GUID Get () const { return guid ; }
	void Set ( GUID &oid ) { guid = oid ; } ;

	WbemObjectReference *Copy () const { return new WbemOidReference ( *this ) ; }
} ;

//---------------------------------------------------------------------------
//
//	Class:		WbemClassReference
//
//  Purpose:	Defines interface for OLE MS class specification definitions.
//
//  Description:	WbemClassReference allows the creation of an OLE MS 
//					class specification, i.e. specify the name of an OLE MS 
//					class
//
//						e.g. ifTable , where ifTable is the name of a class.
//
//---------------------------------------------------------------------------

class WbemClassReference : public WbemObjectReference
{
private:

	WCHAR *className ;

protected:
public:

	WbemClassReference () ;
	WbemClassReference ( const WbemClassReference &classReference ) ;
	~WbemClassReference () ;

	WCHAR *GetClass () const { return className ; } ;
	void SetClass ( WCHAR *classNameArg ) ;

	WbemObjectReference *Copy () const { return new WbemClassReference ( *this ) ; }
} ;

//---------------------------------------------------------------------------
//
//	Class:		WbemKeyLessClassReference
//
//  Purpose:	Defines interface for OLE MS instance specification definitions.
//
//  Description:	WbemKeyLessClassReference allows the creation of an OLE MS 
//					instance specification, i.e. specify the name of the OLE MS 
//					singular instance where the class contains no keys.
//
//						e.g. system = @, where system is the name of a class.
//
//---------------------------------------------------------------------------

class WbemKeyLessClassReference : public WbemObjectReference
{
private:

	WCHAR *className ;

protected:
public:

	WbemKeyLessClassReference () ;
	WbemKeyLessClassReference ( const WbemKeyLessClassReference &classReference ) ;
	~WbemKeyLessClassReference () ;

	WCHAR *GetClass () const { return className ; } ;
	void SetClass ( WCHAR *classNameArg ) ;

	WbemObjectReference *Copy () const { return new WbemKeyLessClassReference ( *this ) ; }
} ;

//---------------------------------------------------------------------------
//
//	Class:		WbemClassKeySpecification
//
//  Purpose:	Defines interface for OLE MS instance specification definitions.
//
//  Description:	WbemClassKeySpecification allows the creation of an OLE MS 
//					instance specification, i.e. define a single key reference
//					using a programmatic interface 
//
//						e.g. ifTable = 1, where ifTable contains exactly one 
//											keyed property
//
//---------------------------------------------------------------------------

class WbemClassKeySpecification : public WbemObjectReference
{
private:

	WCHAR *className ;
	WbemPropertyValue *classValue ;

protected:
public:

	WbemClassKeySpecification () ;
	WbemClassKeySpecification ( const WbemClassKeySpecification &classKeySpecification ) ;
	~WbemClassKeySpecification  () ;

	WCHAR *GetClass () const { return className ; } ;
	WbemPropertyValue *GetClassValue () const { return classValue ; }

	void SetClass ( WCHAR *className ) ;
	void SetClassValue ( WbemPropertyValue *propertyValueArg ) ;

	WbemObjectReference *Copy () const { return new WbemClassKeySpecification ( *this ) ; }
} ;

//---------------------------------------------------------------------------
//
//	Class:		WbemInstanceSpecification
//
//  Purpose:	Defines interface for OLE MS instance specification definitions.
//
//  Description:	WbemInstanceSpecification allows the creation of an OLE MS 
//					instance specification, i.e. define a set of compound primary
//					key references using a programmatic interface 
//
//						e.g. ifTable.ifIndex = 1
//
//---------------------------------------------------------------------------

class WbemInstanceSpecification : public WbemObjectReference
{
private:

//
//	component objects associated with instance specification
//

	WCHAR *className ;
	void *propertyNameValueListPosition ;
	void *propertyNameValueList ;

protected:
public:

	WbemInstanceSpecification () ;
	WbemInstanceSpecification ( const WbemInstanceSpecification &instanceSpecification ) ;
	~WbemInstanceSpecification () ;

	WCHAR *GetClass () { return className ; } ;
	void SetClass ( WCHAR *classNameArg ) ;

	BOOL IsEmpty () const ;
	ULONG GetCount () const ;	
	void Reset () ;
	WbemPropertyNameValue *Next () ;

	void Add ( WbemPropertyNameValue *propertyNameValue ) ;

	WbemObjectReference *Copy () const { return new WbemInstanceSpecification ( *this ) ; } 
} ;

//---------------------------------------------------------------------------
//
//	Class:		WbemNamespacePath
//
//  Purpose:	Defines interface for OLE MS namespace path definitions.
//
//  Description:	WbemNamespacePath allows the creation of an OLE MS namespace
//					path definition using either a textual string convention or 
//					via a programmatic interface.
//
//---------------------------------------------------------------------------

class WbemNamespacePath
{
private:

//
//	Lexical analysis information used when parsing token stream
//

	BOOL pushedBack ;
	WbemAnalyser analyser ;
	WbemLexicon *pushBack ;

//
//	Status of the object path based on parsing process. Initially set to TRUE on 
//	object construction, set to FALSE prior to parsing process.
//

	BOOL status ;

//
//	component objects associated with namespace path
//

	BOOL relative ;
	WCHAR *server ;
	void *nameSpaceList ;
	void *nameSpaceListPosition ;

//
//	Utility Routines
//

	void CleanUp () ;
	void SetUp () ;

//
//	Recursive descent procedures
//

	BOOL NameSpaceName () ;
	BOOL NameSpaceAbs () ;
	BOOL RecursiveNameSpaceAbs () ;
	BOOL RecursiveNameSpaceRel () ;
	BOOL NameSpaceRel () ;
	BOOL BackSlashFactoredServerSpec () ;
	BOOL BackSlashFactoredServerNamespace () ;

//
//	Lexical analysis helper functions
//

	void PushBack () ;
	WbemLexicon *Get () ;
	WbemLexicon *Match ( WbemLexicon :: LexiconToken tokenType ) ;

protected:
public:

//
//	Constructor/Destructor.
//	Constructor initialises status of object to TRUE, 
//	i.e. operator void* returns this.
//

	WbemNamespacePath () ;
	WbemNamespacePath ( const WbemNamespacePath &nameSpacePathArg ) ;
	virtual ~WbemNamespacePath () ;

	BOOL Relative () const { return relative ; }

//
//	Get server component
//

	WCHAR *GetServer () const { return server ; } ;

//
//	Set server component, object must be on heap,
//	deletion of object is under control of WbemNamespacePath.
//

	void SetServer ( WCHAR *serverNameArg ) ;

//
//	Move to position prior to first element of namespace component hierarchy
//

	void Reset () ;

//
//	Move to next position in namespace component hierarchy and return namespace
//	component. Value returned is a reference to the actual component within the 
//	namespace component hierarchy container. Applications must not change contents
//	of value returned by reference. Next returns NULL when all namespace components
//	have been visited.
//

	WCHAR *Next () ;

	BOOL IsEmpty () const ;

	ULONG GetCount () const ;	

//
//	Append namespace component, object must be on heap,
//	deletion of object is under control of WbemNamespacePath.
//

	void Add ( WCHAR *namespacePath ) ;

//
//	Parse token stream to form component objects
//

	BOOL SetNamespacePath ( WCHAR *namespacePath ) ;

	void SetRelative ( BOOL relativeArg ) { relative = relativeArg ; }

//
//	Serialise component objects to form token stream
//

	WCHAR *GetNamespacePath () ;

// 
// Concatenate Absolute/Relative path with Relative path
//

	BOOL ConcatenatePath ( WbemNamespacePath &relative ) ;

//
//	Return status of WbemNamespacePath.
//	Status can only change during a call to SetNamespacePath.
//

	virtual operator void *() ;

} ;

//---------------------------------------------------------------------------
//
//	Class:		WbemObjectPath
//
//  Purpose:	Defines interface for OLE MS Object path definitions.
//
//  Description:	WbemObjectPath allows the creation of an OLE MS object path
//					definition using either a textual string convention or via a
//					programmatic interface.
//
//---------------------------------------------------------------------------

class WbemObjectPath
{
private:

//
//	Lexical analysis information used when parsing token stream
//

	BOOL pushedBack ;
	WbemAnalyser analyser ;
	WbemLexicon *pushBack ;

//
//	Status of the object path based on parsing process. Initially set to TRUE on 
//	object construction, set to FALSE prior to parsing process.
//

	BOOL status ;

//
//	Temporary variables used to track stack information, 
//	could have used proper stack mechanism, except seemed to costly.
//

	WCHAR *propertyName ;
	WbemPropertyValue *propertyValue ;
	WbemPropertyListValue *arrayPropertyValue ;

//
//	component objects associated with object path
//

	WbemNamespacePath nameSpacePath ;
	WbemObjectReference *reference ;

//
//	Utility Routines
//

	void CleanUp () ;
	void SetUp () ;

//
//	Recursive descent procedures
//

	BOOL String  () ;
	BOOL Token  () ;
	BOOL Integer () ;
	BOOL Oid () ;
	BOOL ArrayAtomicPropertyValueSpec () ;	
	BOOL AtomicPropertyValueSpec () ;
	BOOL RecursiveAtomicPropertyValueSpec () ;
	BOOL PropertyAtomicValueList () ;
	BOOL ArraySpec () ;
	BOOL PropertyValueSpec () ;
	BOOL PropertyReference () ;
	BOOL ClassReference () ;
	BOOL KeyPropertyPair () ;
	BOOL RecursiveKeyPropertyPair  () ;
	BOOL KeyPropertySpec () ;
	BOOL FactoredClassSpec () ;
	BOOL FactoredAtPropertyValueSpec ( WCHAR *className ) ;
	BOOL OidReferenceSpec () ;
	BOOL ObjectSpec () ;
	BOOL NameSpaceName () ;
	BOOL NameSpaceAbs () ;
	BOOL RecursiveNameSpaceAbs () ;
	BOOL RecursiveNameSpaceRel () ;
	BOOL NameSpaceRel () ;
	BOOL TokenFactoredObjectSpec () ;
	BOOL ColonFactoredObjectSpec () ;
	BOOL BackSlashFactoredServerSpec () ;
	BOOL TokenFactoredObjectSpecNamespace () ;
	BOOL BackSlashFactoredServerNamespace () ;

//
//	Lexical analysis helper functions
//

	void PushBack () ;
	WbemLexicon *Get () ;
	WbemLexicon *Match ( WbemLexicon :: LexiconToken tokenType ) ;

protected:
public:

//
//	Constructor/Destructor.
//	Constructor initialises status of object to TRUE, 
//	i.e. operator void* returns this.
//

	WbemObjectPath () ;
	WbemObjectPath ( const WbemObjectPath &objectPathArg ) ;
	virtual ~WbemObjectPath () ;


//
//	Parse token stream to form component objects
//

	BOOL SetObjectPath ( WCHAR *objectPath ) ;

//
//	Serialise component objects to form token stream
//

	WCHAR *GetObjectPath () ;

//
//	Set namespace path component object, object must be on heap,
//	deletion of object is under control of WbemObjectPath.
//

	void SetNamespacePath ( WbemNamespacePath &nameSpacePathArg ) { nameSpacePath = nameSpacePathArg ; } ;

//
//	Get namespace path component object.
//

	WbemNamespacePath *GetNamespacePath () { return &nameSpacePath ; } ;
	const WbemNamespacePath *GetNamespacePath () const { return &nameSpacePath ; } ;

//
//	Set object reference component object, object must be on heap,
//	deletion of object is under control of WbemObjectPath.
//

	void SetObjectReference ( WbemObjectReference *referenceArg ) { reference = referenceArg ; } ;

//
//	Get object reference component object.
//	Application must use RTTI to determine actual implementation
//	of referenced object.

	const WbemObjectReference *GetReference () const { return reference ; } ;
	WbemObjectReference *GetReference () { return reference ; } ;

//
//	Return status of WbemObjectPath.
//	Status can only change during a call to SetObjectPath.
//
	virtual operator void *() ;

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provexpt\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// All Rights Reserved.
//

#include <ole2.h>
#include <windows.h>
#include <eh.h>
#include <provexpt.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provexpt\sources.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################


!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETNAME=provexpt
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=$(INCLUDES); \
	$(FRAMEWORK_EXPT_INC)

SOURCES= \
	..\provexpt.cpp

C_DEFINES=$(C_DEFINES) 
USE_RTTI=1
USE_NATIVE_EH=ASYNC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provexpt\include\provexpt.h ===
//***************************************************************************

//

//	PROVEXPT.H

//

//  Module: OLE MS Provider Framework

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _PROVIDER_NEW_DELETE_EXCEPT_H
#define _PROVIDER_NEW_DELETE_EXCEPT_H

#include <eh.h>

void * __cdecl operator new( size_t n);
void* __cdecl operator new[]( size_t n);
void __cdecl operator delete( void *ptr );
void __cdecl operator delete[]( void *ptr );

//taken from new.h
#ifndef __PLACEMENT_NEW_INLINE
#define __PLACEMENT_NEW_INLINE
inline void *__cdecl operator new(size_t, void *_P)
        {return (_P); }
#if     _MSC_VER >= 1200
inline void __cdecl operator delete(void *, void *)
	{return; }
#endif
#endif

class CurveBall
{
private:
    UINT nSE;
	EXCEPTION_POINTERS* m_pExp;

public:
    CurveBall() {}
    CurveBall( UINT n, EXCEPTION_POINTERS* pExp ) : nSE( n ), m_pExp( pExp ) {}
    ~CurveBall() {}
    UINT GetSENumber() { return nSE; }
	EXCEPTION_POINTERS* GetExtendedInfo() { return m_pExp; }
};

class Structured_Exception
{
private:
    UINT nSE;
	EXCEPTION_POINTERS* m_pExp;

public:
    Structured_Exception() {}
    Structured_Exception( UINT n, EXCEPTION_POINTERS* pExp ) : nSE( n ), m_pExp( pExp ) {}
    ~Structured_Exception() {}
    UINT GetSENumber() { return nSE; }
	EXCEPTION_POINTERS* GetExtendedInfo() { return m_pExp; }
};

class SetStructuredExceptionHandler
{
private:

	_se_translator_function m_PrevFunc;

public:
	static void __cdecl trans_func( UINT u, EXCEPTION_POINTERS* pExp )
	{
#ifdef CRASH_ON_EXCEPTION
		throw CurveBall(u, pExp);
#else
		throw Structured_Exception(u, pExp);
#endif
	}

	SetStructuredExceptionHandler() : m_PrevFunc(NULL)
	{
		m_PrevFunc = _set_se_translator( trans_func );
	}

	~SetStructuredExceptionHandler()
	{
		_set_se_translator( m_PrevFunc );
	}
};

class Heap_Exception
{
public:
	enum HEAP_ERROR
	{
		E_ALLOCATION_ERROR = 0,
		E_FREE_ERROR
	};

private:
	HEAP_ERROR m_Error;

public:
	Heap_Exception(HEAP_ERROR e) : m_Error(e) {}
	~Heap_Exception() {}
	HEAP_ERROR GetError() { return m_Error; }
};



#endif //_PROVIDER_NEW_DELETE_EXCEPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provexpt\provexpt.cpp ===
//***************************************************************************

//

//  PROVEXPT.CPP

//

//  Module: OLE MS Provider Framework

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <malloc.h>

#ifdef COMMONALLOC

#include <corepol.h>
#include <arena.h>

#endif

#ifdef THROW_AFTER_N_NEW

UINT g_test = 0;

void *operator new( size_t n)
{
    void *ptr = (void*) LocalAlloc(LMEM_FIXED, n);

    if (ptr && (g_test < 250))
    {
        g_test++;
    }
    else
    {
        g_test = 0;
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
    }

    return ptr;
}
#else //THROW_AFTER_N_NEW

#ifdef COMMONALLOC

void *operator new( size_t n)
{
    void *ptr = (void*) CWin32DefaultArena::WbemMemAlloc(n);

    if (!ptr)
    {
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
    }

    return ptr;
}

#else

void* __cdecl operator new( size_t n)
{
    void *ptr = malloc( n );

    if (!ptr)
    {
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
    }

    return ptr;
}

void* __cdecl operator new[]( size_t n)
{
    void *ptr = malloc( n );

    if (!ptr)
    {
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
    }

    return ptr;
}

#endif // COMMONALLOC

#endif //THROW_AFTER_N_NEW

#ifdef COMMONALLOC

void operator delete( void *ptr )
{
    if (ptr)
    {
        CWin32DefaultArena::WbemMemFree(ptr);
    }
}

#else

void __cdecl operator delete( void *ptr )
{
    if (ptr)
    {
        free( ptr );
    }
}

void __cdecl operator delete[]( void *ptr )
{
    if (ptr)
    {
        free( ptr );
    }
}

#endif //COMMONALLOC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provider\classfac.cpp ===
//***************************************************************************

//

//  CLASSFAC.CPP

//

//  Module: OLE MS SNMP PROPERTY PROVIDER

//

//  Purpose: Contains the class factory.  This creates objects when

//           connections are requested.

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <provtempl.h>
#include <provmt.h>

#include <objbase.h>

#include <wbemidl.h>
#include <wbemint.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <instpath.h>
#include "classfac.h"
#include "framcomm.h"
#include "framprov.h"

#include "guids.h"

LONG CFrameworkProviderClassFactory :: s_ObjectsInProgress = 0 ;
LONG CFrameworkProviderClassFactory :: s_LocksInProgress = 0 ;

//***************************************************************************
//
// CFrameworkProviderClassFactory::CFrameworkProviderClassFactory
// CFrameworkProviderClassFactory::~CFrameworkProviderClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CFrameworkProviderClassFactory :: CFrameworkProviderClassFactory ()
{
	m_ReferenceCount = 0 ;
}

CFrameworkProviderClassFactory::~CFrameworkProviderClassFactory ()
{
}

//***************************************************************************
//
// CFrameworkProviderClassFactory::QueryInterface
// CFrameworkProviderClassFactory::AddRef
// CFrameworkProviderClassFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CFrameworkProviderClassFactory::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IClassFactory )
	{
		*iplpv = ( LPVOID ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}


STDMETHODIMP_( ULONG ) CFrameworkProviderClassFactory :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CFrameworkProviderClassFactory :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

//***************************************************************************
//
// CFrameworkProviderClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CFrameworkProviderClassFactory :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR * ppvObject
)
{
	HRESULT status = S_OK ;

	if ( pUnkOuter )
	{
		status = CLASS_E_NOAGGREGATION ;
	}
	else
	{
		IWbemServices *lpunk = ( IWbemServices * ) new CImpFrameworkProv ;
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppvObject ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;
			}
			else
			{
			}
		}			
	}

	return status ;
}

//***************************************************************************
//
// CFrameworkProviderClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CFrameworkProviderClassFactory :: LockServer ( BOOL fLock )
{
/* 
 * Place code in critical section
 */

	if ( fLock )
	{
		InterlockedIncrement ( & s_LocksInProgress ) ;
	}
	else
	{
		InterlockedDecrement ( & s_LocksInProgress ) ;
	}

	return S_OK	;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provider\dnf.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#include <windows.h> 
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <stdio.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <genlex.h>
#include <sql_1.h>
#include <tree.h>
#include "dnf.h"

WmiOrNode :: ~WmiOrNode ()
{
	delete m_Left ;
	delete m_Right ;
}

WmiAndNode :: ~WmiAndNode ()
{
	delete m_Left ;
	delete m_Right ;
}

WmiNotNode :: ~WmiNotNode ()
{
	delete m_Left ;
}

WmiOperatorEqualNode :: ~WmiOperatorEqualNode ()
{
	delete m_Left ;
}

WmiOperatorNotEqualNode :: ~WmiOperatorNotEqualNode ()
{
	delete m_Left ;
}

WmiOperatorEqualOrGreaterNode :: ~WmiOperatorEqualOrGreaterNode ()
{
	delete m_Left ;
}

WmiOperatorEqualOrLessNode :: ~WmiOperatorEqualOrLessNode ()
{
	delete m_Left ;
}

WmiOperatorGreaterNode :: ~WmiOperatorGreaterNode ()
{
	delete m_Left ;
}

WmiOperatorLessNode :: ~WmiOperatorLessNode ()
{
	delete m_Left ;
}

WmiOperatorLikeNode :: ~WmiOperatorLikeNode ()
{
	delete m_Left ;
}

WmiOperatorNotLikeNode :: ~WmiOperatorNotLikeNode ()
{
	delete m_Left ;
}

WmiTreeNode *WmiOrNode :: Copy () 
{
	void *t_DataCopy = m_Data ;
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_LeftCopy = m_Left ? m_Left->Copy () : NULL ;
	WmiTreeNode *t_RightCopy = m_Right ? m_Right->Copy () : NULL ;
	WmiTreeNode *t_Node = new WmiOrNode ( t_LeftCopy , t_RightCopy , t_Parent ) ;
	return t_Node ;
} ;

WmiTreeNode *WmiAndNode :: Copy () 
{
	void *t_DataCopy = m_Data ;
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_LeftCopy = m_Left ? m_Left->Copy () : NULL ;
	WmiTreeNode *t_RightCopy = m_Right ? m_Right->Copy () : NULL ;
	WmiTreeNode *t_Node = new WmiAndNode ( t_LeftCopy , t_RightCopy , t_Parent ) ;
	return t_Node ;
} ;

WmiTreeNode *WmiNotNode :: Copy () 
{
	WmiTreeNode *t_LeftCopy = m_Left ? m_Left->Copy () : NULL ;
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiNotNode ( t_LeftCopy , t_Parent ) ;
	return t_Node ;
} ;

WmiTreeNode *WmiOperatorEqualNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = m_Left ? m_Left->Copy () : NULL ;
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorEqualNode ( t_LeftCopy , t_Parent ) ;
	return t_Node ;
}

WmiTreeNode *WmiOperatorNotEqualNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = m_Left ? m_Left->Copy () : NULL ;
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorNotEqualNode ( t_LeftCopy , t_Parent ) ;
	return t_Node ;
}

WmiTreeNode *WmiOperatorEqualOrGreaterNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = m_Left ? m_Left->Copy () : NULL ;
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorEqualOrGreaterNode ( t_LeftCopy , t_Parent ) ;
	return t_Node ;
}

WmiTreeNode *WmiOperatorEqualOrLessNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = m_Left ? m_Left->Copy () : NULL ;
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorEqualOrLessNode ( t_LeftCopy , t_Parent ) ;
	return t_Node ;
}

WmiTreeNode *WmiOperatorGreaterNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = m_Left ? m_Left->Copy () : NULL ;
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorGreaterNode ( t_LeftCopy , t_Parent ) ;
	return t_Node ;
}

WmiTreeNode *WmiOperatorLessNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = m_Left ? m_Left->Copy () : NULL ;
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorLessNode ( t_LeftCopy , t_Parent ) ;
	return t_Node ;
}

WmiTreeNode *WmiOperatorLikeNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = m_Left ? m_Left->Copy () : NULL ;
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorLikeNode ( t_LeftCopy , t_Parent ) ;
	return t_Node ;
}

WmiTreeNode *WmiOperatorNotLikeNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = m_Left ? m_Left->Copy () : NULL ;
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorNotLikeNode ( t_LeftCopy , t_Parent ) ;
	return t_Node ;
}

WmiTreeNode *WmiSignedIntegerNode :: Copy ()
{
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiSignedIntegerNode ( m_PropertyName , m_Integer , m_Index , t_Parent ) ;
	return t_Node ;
}

WmiTreeNode *WmiUnsignedIntegerNode :: Copy ()
{
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiUnsignedIntegerNode ( m_PropertyName , m_Integer , m_Index , t_Parent ) ;
	return t_Node ;
}

WmiTreeNode *WmiStringNode :: Copy ()
{
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiStringNode ( m_PropertyName , m_String , m_PropertyFunction , m_ConstantFunction , m_Index , t_Parent ) ;
	return t_Node ;
}

WmiTreeNode *WmiNullNode :: Copy ()
{
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiNullNode ( m_PropertyName , m_Index , t_Parent ) ;
	return t_Node ;
}

WmiTreeNode *WmiSignedIntegerRangeNode :: Copy ()
{
	WmiTreeNode *t_Node = new WmiSignedIntegerRangeNode ( 

		m_PropertyName , 
		m_Index , 
		m_InfiniteLowerBound ,
		m_InfiniteUpperBound ,
		m_LowerBoundClosed ,
		m_UpperBoundClosed ,
		m_LowerBound ,
		m_UpperBound ,
		NULL , 
		NULL 
	) ;
	return t_Node ;
}

WmiTreeNode *WmiUnsignedIntegerRangeNode :: Copy ()
{
	WmiTreeNode *t_Node = new WmiUnsignedIntegerRangeNode ( 

		m_PropertyName , 
		m_Index , 
		m_InfiniteLowerBound ,
		m_InfiniteUpperBound ,
		m_LowerBoundClosed ,
		m_UpperBoundClosed ,
		m_LowerBound ,
		m_UpperBound ,
		NULL , 
		NULL 
	) ;
	return t_Node ;
}

WmiTreeNode *WmiStringRangeNode :: Copy ()
{
	WmiTreeNode *t_Node = new WmiStringRangeNode ( 

		m_PropertyName , 
		m_Index , 
		m_InfiniteLowerBound ,
		m_InfiniteUpperBound ,
		m_LowerBoundClosed ,
		m_UpperBoundClosed ,
		m_LowerBound ,
		m_UpperBound ,
		NULL , 
		NULL 
	) ;
	return t_Node ;
}

WmiTreeNode *WmiNullRangeNode :: Copy ()
{
	WmiTreeNode *t_Node = new WmiNullRangeNode ( m_PropertyName , m_Index , NULL , NULL ) ;
	return t_Node ;
}

void WmiOrNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		L" ( "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		L" ) "
	) ;
)

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		L" Or "
	) ;
)

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		L" ( "
	) ;
)

	if ( GetRight () )
		GetRight ()->Print () ;

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		L" ) "
	) ;
)

}

void WmiAndNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		L" ( "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		L" ) "
	) ;
)

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		L" And "
	) ;
)

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		L" ( "
	) ;
)

	if ( GetRight () )
		GetRight ()->Print () ;

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		L" ) "
	) ;
)
}

void WmiNotNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		L"Not"
	) ;
)

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		L" ( "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		L" ) "
	) ;
)
}

void WmiOperatorEqualNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		L" = "
	) ;
)
	if ( GetLeft () )
		GetLeft ()->Print () ;
}

void WmiOperatorNotEqualNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		L" != "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

void WmiOperatorEqualOrGreaterNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		L" >= "
	) ;
)
	if ( GetLeft () )
		GetLeft ()->Print () ;
}

void WmiOperatorEqualOrLessNode :: Print () 
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		L" <= "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

void WmiOperatorLessNode :: Print () 
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		L" < "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

void WmiOperatorGreaterNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		L" > "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

void WmiOperatorLikeNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		L" Like "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

void WmiOperatorNotLikeNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		L" NotLike "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

void WmiStringNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		L" ( %s , %s ) " ,
		GetPropertyName () ,
		GetValue ()
	) ;
)

}

void WmiUnsignedIntegerNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		L" ( %s , %ld ) " ,
		GetPropertyName () ,
		GetValue ()
	) ;
)
}

void WmiSignedIntegerNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		L" ( %s , %d ) " ,
		GetPropertyName () ,
		GetValue ()
	) ;
)
}


void WmiNullNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		L" ( %s , NULL ) " ,
		GetPropertyName ()
	) ;
)
}

void WmiStringRangeNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		L" ( %s , %s , %s , %s , %s , %s , %s ) " ,
		GetPropertyName () ,
		m_InfiniteLowerBound ? L"Infinite" : L"Finite",
		m_InfiniteUpperBound ? L"Infinite" : L"Finite",
		m_LowerBoundClosed ? L"Closed" : L"Open" ,
		m_UpperBoundClosed ? L"Closed" : L"Open",
		m_InfiniteLowerBound ? L"" : m_LowerBound ,
		m_InfiniteUpperBound ? L"" : m_UpperBound 
	) ;
)

}

void WmiUnsignedIntegerRangeNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		L" ( %s , %s , %s , %s , %s , %lu , %lu ) " ,
		GetPropertyName () ,
		m_InfiniteLowerBound ? L"Infinite" : L"Finite",
		m_InfiniteUpperBound ? L"Infinite" : L"Finite",
		m_LowerBoundClosed ? L"Closed" : L"Open" ,
		m_UpperBoundClosed ? L"Closed" : L"Open",
		m_InfiniteLowerBound ? 0 : m_LowerBound ,
		m_InfiniteUpperBound ? 0 : m_UpperBound  
	) ;
)
}

void WmiSignedIntegerRangeNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		L" ( %s , %s , %s , %s , %s , %ld , %ld ) " ,
		GetPropertyName () ,
		m_InfiniteLowerBound ? L"Infinite" : L"Finite",
		m_InfiniteUpperBound ? L"Infinite" : L"Finite",
		m_LowerBoundClosed ? L"Closed" : L"Open" ,
		m_UpperBoundClosed ? L"Closed" : L"Open",
		m_InfiniteLowerBound ? 0 : m_LowerBound ,
		m_InfiniteUpperBound ? 0 : m_UpperBound  
	) ;
)
}


void WmiNullRangeNode :: Print ()
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		L" ( %s , NULL ) " ,
		GetPropertyName ()
	) ;
)
}

BOOL CompareUnsignedIntegerLess (

	ULONG X ,
	LONG X_INFINITE ,
	ULONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X < Y ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
		return FALSE ;
	}
}

BOOL CompareUnsignedIntegerGreater (

	ULONG X ,
	LONG X_INFINITE ,
	ULONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		return FALSE ;
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X > Y ;
		}
		else
		{
			return FALSE ;
		}
	}
	else
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

BOOL CompareUnsignedIntegerEqual (

	ULONG X ,
	LONG X_INFINITE ,
	ULONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 && Y_INFINITE < 0 )
	{
		return TRUE ;
	}
	else if ( X_INFINITE == 0 && Y_INFINITE == 0 )
	{
		return X == Y ;
	}
	else if ( X_INFINITE > 0 && Y_INFINITE > 0 )
	{
		return TRUE ;
	}
	else
	{
		return FALSE ;
	}
}

BOOL CompareSignedIntegerLess (

	LONG X ,
	LONG X_INFINITE ,
	LONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X < Y ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
		return FALSE ;
	}
}

BOOL CompareSignedIntegerGreater (

	LONG X ,
	LONG X_INFINITE ,
	LONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		return FALSE ;
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X > Y ;
		}
		else
		{
			return FALSE ;
		}
	}
	else
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

BOOL CompareSignedIntegerEqual (

	LONG X ,
	LONG X_INFINITE ,
	LONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 && Y_INFINITE < 0 )
	{
		return TRUE ;
	}
	else if ( X_INFINITE == 0 && Y_INFINITE == 0 )
	{
		return X == Y ;
	}
	else if ( X_INFINITE > 0 && Y_INFINITE > 0 )
	{
		return TRUE ;
	}
	else
	{
		return FALSE ;
	}
}

BOOL CompareStringLess (

	BSTR X ,
	LONG X_INFINITE ,
	BSTR Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return wcscmp ( X , Y ) < 0 ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
		return FALSE ;
	}
}

BOOL CompareStringGreater (

	BSTR X ,
	LONG X_INFINITE ,
	BSTR Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		return FALSE ;
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return wcscmp ( X , Y ) > 0 ;
		}
		else
		{
			return FALSE ;
		}
	}
	else
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

BOOL CompareStringEqual (

	BSTR X ,
	LONG X_INFINITE ,
	BSTR Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 && Y_INFINITE < 0 )
	{
		return TRUE ;
	}
	else if ( X_INFINITE == 0 && Y_INFINITE == 0 )
	{
		return wcscmp ( X , Y ) == 0 ;
	}
	else if ( X_INFINITE > 0 && Y_INFINITE > 0 )
	{
		return TRUE ;
	}
	else
	{
		return FALSE ;
	}
}

BOOL CompareLessRangeNode ( 

	WmiRangeNode *a_LeftRange ,
	WmiRangeNode *a_RightRange
) 
{
	LONG t_State = 0 ;

	if ( typeid ( *a_LeftRange ) == typeid ( WmiStringRangeNode ) && typeid ( *a_RightRange ) == typeid ( WmiStringRangeNode ) )
	{
		WmiStringRangeNode *t_LeftString = ( WmiStringRangeNode * ) a_LeftRange ;
		WmiStringRangeNode *t_RightString = ( WmiStringRangeNode * ) a_RightRange ;

		t_State = CompareStringLess ( 

			t_LeftString->LowerBound () , 
			t_LeftString->InfiniteLowerBound () ,
			t_RightString->LowerBound () ,
			t_RightString->InfiniteLowerBound () 
		) ;
	}
	else if ( typeid ( *a_LeftRange ) == typeid ( WmiSignedIntegerRangeNode ) && typeid ( *a_RightRange ) == typeid ( WmiSignedIntegerRangeNode ) )
	{
		WmiSignedIntegerRangeNode *t_LeftInteger = ( WmiSignedIntegerRangeNode * ) a_LeftRange ;
		WmiSignedIntegerRangeNode *t_RightInteger = ( WmiSignedIntegerRangeNode * ) a_RightRange ;

		t_State = CompareSignedIntegerLess ( 

			t_LeftInteger->LowerBound () , 
			t_LeftInteger->InfiniteLowerBound () ,
			t_RightInteger->LowerBound () ,
			t_RightInteger->InfiniteLowerBound () 
		) ;
	}
	else if ( typeid ( *a_LeftRange ) == typeid ( WmiUnsignedIntegerRangeNode ) && typeid ( *a_RightRange ) == typeid ( WmiUnsignedIntegerRangeNode ) )
	{
		WmiUnsignedIntegerRangeNode *t_LeftInteger = ( WmiUnsignedIntegerRangeNode * ) a_LeftRange ;
		WmiUnsignedIntegerRangeNode *t_RightInteger = ( WmiUnsignedIntegerRangeNode * ) a_RightRange ;

		t_State = CompareUnsignedIntegerLess ( 

			t_LeftInteger->LowerBound () , 
			t_LeftInteger->InfiniteLowerBound () ,
			t_RightInteger->LowerBound () ,
			t_RightInteger->InfiniteLowerBound () 
		) ;
	}
	else if ( typeid ( *a_LeftRange ) == typeid ( WmiNullRangeNode ) && typeid ( *a_RightRange ) == typeid ( WmiNullRangeNode ) )
	{
		t_State = TRUE ;
	}
	else
	{
	}

	return t_State ;
}

BOOL WmiUnsignedIntegerRangeNode :: GetIntersectingRange ( 

	WmiUnsignedIntegerRangeNode &a_UnsignedInteger ,
	WmiUnsignedIntegerRangeNode *&a_Intersection 
)
{
// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Intersection = NULL ;

	ULONG X_S = m_LowerBound ;
	ULONG X_E = m_UpperBound ;
	ULONG Y_S = a_UnsignedInteger.m_LowerBound ;
	ULONG Y_E = a_UnsignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_UnsignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_UnsignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_UnsignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_UnsignedInteger.m_InfiniteUpperBound ;

	if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S < Y_S == X_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )
//				Non overlapping regions therefore empty set
		}
	}
	else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S == Y_S == X_E )
//				Range ( Y_S , Y_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
		}
	}
	else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( X_S_CLOSED && Y_E_CLOSED )
			{
//				Order ( Y_S < X_S == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
// Empty
		}
	}

	BOOL t_Status = a_Intersection ? TRUE : FALSE ;
	return t_Status ;
}

BOOL WmiSignedIntegerRangeNode :: GetIntersectingRange ( 

	WmiSignedIntegerRangeNode &a_SignedInteger ,
	WmiSignedIntegerRangeNode *&a_Intersection 
)
{
// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Intersection = NULL ;

	LONG X_S = m_LowerBound ;
	LONG X_E = m_UpperBound ;
	LONG Y_S = a_SignedInteger.m_LowerBound ;
	LONG Y_E = a_SignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_SignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_SignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_SignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_SignedInteger.m_InfiniteUpperBound ;

	if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S < Y_S == X_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )
//				Non overlapping regions therefore empty set
		}
	}
	else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S == Y_S == X_E )
//				Range ( Y_S , Y_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > Y_E )
		{
// Can never happen
		}
	}
	else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( X_S_CLOSED && Y_E_CLOSED )
			{
//				Order ( Y_S < X_S == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
// Empty
		}
	}

	BOOL t_Status = a_Intersection ? TRUE : FALSE ;
	return t_Status ;
}

BOOL WmiStringRangeNode :: GetIntersectingRange ( 

	WmiStringRangeNode &a_String ,
	WmiStringRangeNode *&a_Intersection 
)
{
// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Intersection = NULL ;

	BSTR X_S = m_LowerBound ;
	BSTR X_E = m_UpperBound ;
	BSTR Y_S = a_String.m_LowerBound ;
	BSTR Y_E = a_String.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_String.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_String.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_String.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_String.m_InfiniteUpperBound ;

	if ( CompareStringLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S < Y_S == X_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )
//				Non overlapping regions therefore empty set
		}
	}
	else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL 
				) ;
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S == Y_S == X_E )
//				Range ( Y_S , Y_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL 
				) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > Y_E )
		{
// Can never happen
		}
	}
	else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareStringLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( X_S_CLOSED && Y_E_CLOSED )
			{
//				Order ( Y_S < X_S == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL 
				) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
// empty
		}
	}

	BOOL t_Status = a_Intersection ? TRUE : FALSE ;
	return t_Status ;
}

BOOL WmiSignedIntegerRangeNode :: GetNonIntersectingRange ( 

	WmiSignedIntegerRangeNode &a_SignedInteger ,
	WmiSignedIntegerRangeNode *&a_Before ,
	WmiSignedIntegerRangeNode *&a_Intersection ,
	WmiSignedIntegerRangeNode *&a_After
)
{
// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Before = NULL ;
	a_Intersection = NULL ;
	a_After = NULL ;

	LONG X_S = m_LowerBound ;
	LONG X_E = m_UpperBound ;
	LONG Y_S = a_SignedInteger.m_LowerBound ;
	LONG Y_E = a_SignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_SignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_SignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_SignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_SignedInteger.m_InfiniteUpperBound ;

	if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Before = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Before = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,			
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{
					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,						
						TRUE ,			
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Before = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
			// Order ( X_S < Y_S == X_E < Y_E )

				if ( X_E_CLOSED && Y_S_CLOSED )
				{
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						FALSE ,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE ,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;
				}
				else
				{
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						X_E_CLOSED,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE ,
						Y_S_CLOSED ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED )
				{
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						FALSE ,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;
				}
				else
				{
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						X_E_CLOSED,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_S_INFINITE ,
						TRUE ,
						TRUE,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )

				a_Before = ( WmiSignedIntegerRangeNode * ) ( this->Copy () ) ;
				a_After = ( WmiSignedIntegerRangeNode * ) ( a_SignedInteger.Copy () ) ;
		}
	}
	else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;
				}

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,		
					Y_E_CLOSED ,		
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;
				}

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{				
					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,		
						TRUE ,					
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;
				}

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,
					X_E_CLOSED ,
					Y_E ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				if ( Y_S_CLOSED )
				{
					a_Intersection = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;
				}
				else
				{
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Can never happen
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
		}
	}
	else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Before = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Before = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{
					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,						
						TRUE ,			
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Before = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
// Can never happen
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				if ( Y_E_CLOSED )
				{
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						FALSE,
						Y_S_CLOSED ,
						FALSE,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_E ,
						Y_E ,
						NULL ,
						NULL
					) ;
				}
				else
				{
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						FALSE ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Before = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					FALSE  ,
					Y_S_CLOSED ,
					FALSE ,
					Y_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_After = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					Y_E_INFINITE  ,
					FALSE ,
					Y_E_CLOSED ,
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
			a_Before = ( WmiSignedIntegerRangeNode * ) ( a_SignedInteger.Copy () ) ;
			a_After = ( WmiSignedIntegerRangeNode * ) ( this->Copy () ) ;
		}
	}

	return TRUE ;
}


BOOL WmiUnsignedIntegerRangeNode :: GetNonIntersectingRange ( 

	WmiUnsignedIntegerRangeNode &a_UnsignedInteger ,
	WmiUnsignedIntegerRangeNode *&a_Before ,
	WmiUnsignedIntegerRangeNode *&a_Intersection ,
	WmiUnsignedIntegerRangeNode *&a_After
)
{
// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Before = NULL ;
	a_Intersection = NULL ;
	a_After = NULL ;

	ULONG X_S = m_LowerBound ;
	ULONG X_E = m_UpperBound ;
	ULONG Y_S = a_UnsignedInteger.m_LowerBound ;
	ULONG Y_E = a_UnsignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_UnsignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_UnsignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_UnsignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_UnsignedInteger.m_InfiniteUpperBound ;

	if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Before = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Before = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,			
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{
					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,						
						TRUE ,			
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Before = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
			// Order ( X_S < Y_S == X_E < Y_E )

				if ( X_E_CLOSED && Y_S_CLOSED )
				{
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						FALSE ,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE ,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;
				}
				else
				{
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						X_E_CLOSED,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE ,
						Y_S_CLOSED ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED )
				{
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						FALSE ,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;
				}
				else
				{
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						X_E_CLOSED,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_S_INFINITE ,
						TRUE ,
						TRUE,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )

				a_Before = ( WmiUnsignedIntegerRangeNode * ) ( this->Copy () ) ;
				a_After = ( WmiUnsignedIntegerRangeNode * ) ( a_UnsignedInteger.Copy () ) ;
		}
	}
	else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;
				}

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,		
					Y_E_CLOSED ,		
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;
				}

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{				
					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,		
						TRUE ,					
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;
				}

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,
					X_E_CLOSED ,
					Y_E ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				if ( Y_S_CLOSED )
				{
					a_Intersection = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;
				}
				else
				{
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Can never happen
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
		}
	}
	else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Before = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Before = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{
					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,						
						TRUE ,			
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Before = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
// Can never happen
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				if ( Y_E_CLOSED )
				{
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						FALSE,
						Y_S_CLOSED ,
						FALSE,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_E ,
						Y_E ,
						NULL ,
						NULL
					) ;
				}
				else
				{
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						FALSE ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Before = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					FALSE  ,
					Y_S_CLOSED ,
					FALSE ,
					Y_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_After = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					Y_E_INFINITE  ,
					FALSE ,
					Y_E_CLOSED ,
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
			a_Before = ( WmiUnsignedIntegerRangeNode * ) ( a_UnsignedInteger.Copy () ) ;
			a_After = ( WmiUnsignedIntegerRangeNode * ) ( this->Copy () ) ;
		}
	}

	return TRUE ;
}

BOOL WmiStringRangeNode :: GetNonIntersectingRange ( 

	WmiStringRangeNode &a_String ,
	WmiStringRangeNode *&a_Before ,
	WmiStringRangeNode *&a_Intersection ,
	WmiStringRangeNode *&a_After
)
{
// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Before = NULL ;
	a_Intersection = NULL ;
	a_After = NULL ;

	BSTR X_S = m_LowerBound ;
	BSTR X_E = m_UpperBound ;
	BSTR Y_S = a_String.m_LowerBound ;
	BSTR Y_E = a_String.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_String.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_String.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_String.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_String.m_InfiniteUpperBound ;

	if ( CompareStringLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Before = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Before = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,			
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{
					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,						
						TRUE ,			
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Before = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
			// Order ( X_S < Y_S == X_E < Y_E )

				if ( X_E_CLOSED && Y_S_CLOSED )
				{
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						FALSE ,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE ,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;
				}
				else
				{
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						X_E_CLOSED,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE ,
						Y_S_CLOSED ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED )
				{
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						FALSE ,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;
				}
				else
				{
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						X_E_CLOSED,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_S_INFINITE ,
						TRUE ,
						TRUE,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )

				a_Before = ( WmiStringRangeNode * ) ( this->Copy () ) ;
				a_After = ( WmiStringRangeNode * ) ( a_String.Copy () ) ;
		}
	}
	else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;
				}

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,		
					Y_E_CLOSED ,		
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;
				}

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{				
					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,		
						TRUE ,					
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;
				}

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,
					X_E_CLOSED ,
					Y_E ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				if ( Y_S_CLOSED )
				{
					a_Intersection = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;
				}
				else
				{
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Can never happen
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
		}
	}
	else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareStringLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Before = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Before = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{
					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,						
						TRUE ,			
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Before = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
// Can never happen
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				if ( Y_E_CLOSED )
				{
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						FALSE,
						Y_S_CLOSED ,
						FALSE,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_E ,
						Y_E ,
						NULL ,
						NULL
					) ;
				}
				else
				{
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						FALSE ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;
				}
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Before = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					FALSE  ,
					Y_S_CLOSED ,
					FALSE ,
					Y_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_After = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					Y_E_INFINITE  ,
					FALSE ,
					Y_E_CLOSED ,
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
			a_Before = ( WmiStringRangeNode * ) ( a_String.Copy () ) ;
			a_After = ( WmiStringRangeNode * ) ( this->Copy () ) ;
		}
	}

	return TRUE ;
}

BOOL WmiSignedIntegerRangeNode :: GetOverlappingRange ( 

	WmiSignedIntegerRangeNode &a_SignedInteger ,
	WmiSignedIntegerRangeNode *&a_Overlap
)
{
// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Overlap = NULL ;

	LONG X_S = m_LowerBound ;
	LONG X_E = m_UpperBound ;
	LONG Y_S = a_SignedInteger.m_LowerBound ;
	LONG Y_E = a_SignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_SignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_SignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_SignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_SignedInteger.m_InfiniteUpperBound ;

	if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( X_S , Y_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( X_S , X_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED || Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
// Order ( X_S < Y_S == X_E < Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE,
					Y_E_INFINITE  ,
					X_S_CLOSED ,
					Y_E_CLOSED ,
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE,
					X_S_CLOSED ,
					X_E_CLOSED || Y_E_CLOSED || Y_S_CLOSED   ,
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S ) Non overlapping
		}
	}
	else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED || Y_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED || X_E_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_S_INFINITE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Can never happen
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
		}
	}
	else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED || X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( Y_S , Y_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
// Can never happen
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE  ,
					Y_S_CLOSED ,
					TRUE ,
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
//				Order ( Y_S < Y_E < X_S ) Non Overlapping
		}
	}

	BOOL t_Status = a_Overlap ? TRUE : FALSE ;
	return t_Status ;
}

BOOL WmiUnsignedIntegerRangeNode :: GetOverlappingRange ( 

	WmiUnsignedIntegerRangeNode &a_UnsignedInteger ,
	WmiUnsignedIntegerRangeNode *&a_Overlap
)
{
// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Overlap = NULL ;

	ULONG X_S = m_LowerBound ;
	ULONG X_E = m_UpperBound ;
	ULONG Y_S = a_UnsignedInteger.m_LowerBound ;
	ULONG Y_E = a_UnsignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_UnsignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_UnsignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_UnsignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_UnsignedInteger.m_InfiniteUpperBound ;

	if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( X_S , Y_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( X_S , X_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED || Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
// Order ( X_S < Y_S == X_E < Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE,
					Y_E_INFINITE  ,
					X_S_CLOSED ,
					Y_E_CLOSED ,
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE,
					X_S_CLOSED ,
					X_E_CLOSED || Y_E_CLOSED || Y_S_CLOSED   ,
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S ) Non overlapping
		}
	}
	else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED || Y_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED || X_E_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_S_INFINITE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Can never happen
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
		}
	}
	else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED || X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( Y_S , Y_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
// Can never happen
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE  ,
					Y_S_CLOSED ,
					TRUE ,
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
//				Order ( Y_S < Y_E < X_S ) Non Overlapping
		}
	}

	BOOL t_Status = a_Overlap ? TRUE : FALSE ;
	return t_Status ;
}

BOOL WmiStringRangeNode :: GetOverlappingRange ( 

	WmiStringRangeNode &a_String ,
	WmiStringRangeNode *&a_Overlap
)
{
// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Overlap = NULL ;

	BSTR X_S = m_LowerBound ;
	BSTR X_E = m_UpperBound ;
	BSTR Y_S = a_String.m_LowerBound ;
	BSTR Y_E = a_String.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_String.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_String.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_String.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_String.m_InfiniteUpperBound ;

	if ( CompareStringLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( X_S , Y_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( X_S , X_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED || Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
// Order ( X_S < Y_S == X_E < Y_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE,
					Y_E_INFINITE  ,
					X_S_CLOSED ,
					Y_E_CLOSED ,
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE,
					X_S_CLOSED ,
					X_E_CLOSED || Y_E_CLOSED || Y_S_CLOSED   ,
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S ) Non overlapping
		}
	}
	else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED || Y_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED || X_E_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_S_INFINITE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Can never happen
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
		}
	}
	else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareStringLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED || X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( Y_S , Y_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
// Can never happen
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE  ,
					Y_S_CLOSED ,
					TRUE ,
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;
			}
		}
		else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
//				Order ( Y_S < Y_E < X_S ) Non Overlapping
		}
	}

	BOOL t_Status = a_Overlap ? TRUE : FALSE ;
	return t_Status ;
}

WmiRangeNode *WmiOperatorEqualNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( typeid ( *t_Value ) == typeid ( WmiNullNode ) )
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			t_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
		}
		else if ( typeid ( *t_Value ) == typeid ( WmiUnsignedIntegerNode ) )
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			t_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				FALSE ,
				FALSE ,
				TRUE ,
				t_Integer->GetValue () ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
		}
		else if ( typeid ( *t_Value ) == typeid ( WmiSignedIntegerNode ) )
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;
			t_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				FALSE ,
				TRUE ,
				TRUE ,
				t_Integer->GetValue () ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
		}
		else if ( typeid ( *t_Value ) == typeid ( WmiStringNode ) )
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					FALSE ,
					FALSE ,
					TRUE ,
					TRUE ,
					t_String->GetValue () ,
					t_String->GetValue () ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else
		{
// Can never happen
		}
	}

	return t_Range ;
}

WmiRangeNode *WmiOperatorEqualOrGreaterNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( typeid ( *t_Value ) == typeid ( WmiNullNode ) )
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			t_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
		}
		else if ( typeid ( *t_Value ) == typeid ( WmiUnsignedIntegerNode ) )
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			t_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				TRUE ,
				FALSE ,
				t_Integer->GetValue () ,
				0 ,
				NULL , 
				NULL 
			) ;
		}
		else if ( typeid ( *t_Value ) == typeid ( WmiSignedIntegerNode ) )
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;
			t_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				TRUE ,
				FALSE ,
				t_Integer->GetValue () ,
				0 ,
				NULL , 
				NULL 
			) ;
		}
		else if ( typeid ( *t_Value ) == typeid ( WmiStringNode ) )
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					FALSE ,
					TRUE ,
					TRUE ,
					FALSE ,
					t_String->GetValue () ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else
		{
// Can never happen
		}
	}

	return t_Range ;
}

WmiRangeNode *WmiOperatorEqualOrLessNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( typeid ( *t_Value ) == typeid ( WmiNullNode ) )
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			t_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
		}
		else if ( typeid ( *t_Value ) == typeid ( WmiUnsignedIntegerNode ) )
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			t_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				TRUE ,
				0 ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
		}
		else if ( typeid ( *t_Value ) == typeid ( WmiSignedIntegerNode ) )
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;
			t_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				TRUE ,
				0 ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
		}
		else if ( typeid ( *t_Value ) == typeid ( WmiStringNode ) )
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					FALSE ,
					FALSE ,
					TRUE ,
					NULL ,
					t_String->GetValue () ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else
		{
// Can never happen
		}
	}

	return t_Range ;
}

WmiRangeNode *WmiOperatorLessNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( typeid ( *t_Value ) == typeid ( WmiNullNode ) )
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			t_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
		}
		else if ( typeid ( *t_Value ) == typeid ( WmiUnsignedIntegerNode ) )
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			t_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				FALSE ,
				0 ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
		}
		else if ( typeid ( *t_Value ) == typeid ( WmiSignedIntegerNode ) )
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;

			t_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				FALSE ,
				0 ,
				t_Integer->GetValue ()  ,
				NULL , 
				NULL 
			) ;
		}
		else if ( typeid ( *t_Value ) == typeid ( WmiStringNode ) )
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					FALSE ,
					FALSE ,
					FALSE ,
					NULL ,
					t_String->GetValue () ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else
		{
// Can never happen
		}
	}

	return t_Range ;
}

WmiRangeNode *WmiOperatorGreaterNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( typeid ( *t_Value ) == typeid ( WmiNullNode ) )
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			t_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
		}
		else if ( typeid ( *t_Value ) == typeid ( WmiUnsignedIntegerNode ) )
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			t_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				FALSE ,
				FALSE ,
				t_Integer->GetValue () ,
				0 ,
				NULL , 
				NULL 
			) ;
		}
		else if ( typeid ( *t_Value ) == typeid ( WmiSignedIntegerNode ) )
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;

			t_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				FALSE ,
				FALSE ,
				t_Integer->GetValue (),
				0 ,
				NULL , 
				NULL 
			) ;
		}
		else if ( typeid ( *t_Value ) == typeid ( WmiStringNode ) )
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					FALSE ,
					TRUE ,
					FALSE ,
					FALSE ,
					t_String->GetValue () ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else
		{
// Can never happen
		}
	}

	return t_Range ;
}

WmiRangeNode *WmiOperatorLikeNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( typeid ( *t_Value ) == typeid ( WmiNullNode ) )
		{
		}
		else if ( typeid ( *t_Value ) == typeid ( WmiUnsignedIntegerNode ) )
		{
		}
		else if ( typeid ( *t_Value ) == typeid ( WmiSignedIntegerNode ) )
		{
		}
		else if ( typeid ( *t_Value ) == typeid ( WmiStringNode ) )
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
		}
		else
		{
// Can never happen
		}
	}

	return t_Range ;
}

WmiRangeNode *WmiOperatorNotLikeNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( typeid ( *t_Value ) == typeid ( WmiNullNode ) )
		{
		}
		else if ( typeid ( *t_Value ) == typeid ( WmiUnsignedIntegerNode ) )
		{
		}
		else if ( typeid ( *t_Value ) == typeid ( WmiSignedIntegerNode ) )
		{
		}
		else if ( typeid ( *t_Value ) == typeid ( WmiStringNode ) )
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{

				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else
		{
// Can never happen
		}
	}

	return t_Range ;
}

BOOL QueryPreprocessor :: RecursiveEvaluate ( 

	SQL_LEVEL_1_RPN_EXPRESSION &a_Expression , 
	WmiTreeNode *a_Parent , 
	WmiTreeNode **a_Node , 
	int &a_Index 
)
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"RecursiveEvaluate ( int &a_Index )"
	) ;
)

	BOOL t_Status = FALSE ;

	SQL_LEVEL_1_TOKEN *propertyValue = & ( a_Expression.pArrayOfTokens [ a_Index ] ) ;
	a_Index -- ;

	switch ( propertyValue->nTokenType )
	{
		case SQL_LEVEL_1_TOKEN :: OP_EXPRESSION:
		{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Operation = OP_EXPESSION"
	) ;
)

			WmiTreeNode *t_ParentNode = a_Parent ;
			WmiTreeNode **t_Node = a_Node ;
			WmiTreeNode *t_OperatorNode = NULL ;

			switch ( propertyValue->nOperator )
			{
				case SQL_LEVEL_1_TOKEN :: OP_EQUAL:
				{
					t_OperatorNode = new WmiOperatorEqualNode ( NULL , t_ParentNode ) ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: OP_NOT_EQUAL:
				{
					t_OperatorNode = new WmiOperatorNotEqualNode ( NULL , t_ParentNode ) ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: OP_EQUALorGREATERTHAN:
				{
					t_OperatorNode = new WmiOperatorEqualOrGreaterNode ( NULL , t_ParentNode ) ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: OP_EQUALorLESSTHAN: 
				{
					t_OperatorNode = new WmiOperatorEqualOrLessNode ( NULL , t_ParentNode ) ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: OP_LESSTHAN:
				{
					t_OperatorNode = new WmiOperatorLessNode ( NULL , t_ParentNode ) ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: OP_GREATERTHAN:
				{
					t_OperatorNode = new WmiOperatorGreaterNode ( NULL , t_ParentNode ) ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: OP_LIKE:
				{
					t_OperatorNode = new WmiOperatorLikeNode ( NULL , t_ParentNode ) ;
				}
				break ;

				default:
				{
				}
				break ;
			}

			if ( t_OperatorNode )
			{
				*t_Node = t_OperatorNode ;
				t_ParentNode = t_OperatorNode ;
				(*t_Node)->GetLeft ( t_Node ) ;

				t_Status = TRUE ;
			}

			WmiValueNode :: WmiValueFunction t_PropertyFunction = WmiValueNode :: WmiValueFunction :: Function_None ;

			switch ( propertyValue->dwPropertyFunction )
			{
				case SQL_LEVEL_1_TOKEN :: IFUNC_UPPER:
				{
					t_PropertyFunction = WmiValueNode :: WmiValueFunction :: Function_Upper ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: IFUNC_LOWER:
				{
					t_PropertyFunction = WmiValueNode :: WmiValueFunction :: Function_Lower ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: IFUNC_NONE:
				default:
				{
				}
				break ;

			}
			
			WmiValueNode :: WmiValueFunction t_ConstantFunction = WmiValueNode :: WmiValueFunction :: Function_None ;
			switch ( propertyValue->dwConstFunction )
			{
				case SQL_LEVEL_1_TOKEN :: IFUNC_UPPER:
				{
					t_ConstantFunction = WmiValueNode :: WmiValueFunction :: Function_Upper ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: IFUNC_LOWER:
				{
					t_ConstantFunction = WmiValueNode :: WmiValueFunction :: Function_Lower ;
				}
				break ;

				case SQL_LEVEL_1_TOKEN :: IFUNC_NONE:
				default:
				{
				}
				break ;
			}

			WmiTreeNode *t_ValueNode = AllocTypeNode ( 

				propertyValue->pPropertyName , 
				propertyValue->vConstValue , 
				t_PropertyFunction ,
				t_ConstantFunction ,
				t_ParentNode 
			) ;

			if ( t_ValueNode )
			{
				*t_Node = t_ValueNode ;

				t_Status = TRUE ;
			}
			else
			{				
				t_Status = FALSE ;
			}
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: TOKEN_AND:
		{
			*a_Node = new WmiAndNode ( NULL , NULL , a_Parent ) ;
			WmiTreeNode **t_Left = NULL ;
			WmiTreeNode **t_Right = NULL ;
			(*a_Node)->GetLeft ( t_Left ) ;
			(*a_Node)->GetRight ( t_Right ) ;

			t_Status =	RecursiveEvaluate ( a_Expression , *a_Node , t_Left , a_Index ) &&
						RecursiveEvaluate ( a_Expression , *a_Node , t_Right , a_Index ) ;

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Operation = TOKEN_AND"
	) ;
)

		}
		break ;

		case SQL_LEVEL_1_TOKEN :: TOKEN_OR:
		{
			*a_Node = new WmiOrNode ( NULL , NULL , a_Parent ) ;
			WmiTreeNode **t_Left = NULL ;
			WmiTreeNode **t_Right = NULL ;
			(*a_Node)->GetLeft ( t_Left ) ;
			(*a_Node)->GetRight ( t_Right ) ;

			t_Status =	RecursiveEvaluate ( a_Expression , *a_Node , t_Left , a_Index ) &&
						RecursiveEvaluate ( a_Expression , *a_Node , t_Right , a_Index ) ;

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Operation = TOKEN_OR"
	) ;
)

		}
		break ;

		case SQL_LEVEL_1_TOKEN :: TOKEN_NOT:
		{
			*a_Node = new WmiNotNode ( NULL , a_Parent ) ;
			WmiTreeNode **t_Left = NULL ;
			(*a_Node)->GetLeft ( t_Left ) ;

			t_Status = RecursiveEvaluate ( a_Expression , *a_Node , t_Left , a_Index ) ;

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Operation = TOKEN_NOT"
	) ;
)

		}
		break ;
	}

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"RecursiveEvaluation t_Status = (%lu)" ,
		( ULONG ) t_Status
	) ;

	return t_Status ;
}

BOOL QueryPreprocessor :: Evaluate ( 

	SQL_LEVEL_1_RPN_EXPRESSION &a_Expression , 
	WmiTreeNode **a_Root 
)
{
	BOOL t_Status = TRUE ;
	if ( a_Expression.nNumTokens )
	{
		int t_Count = a_Expression.nNumTokens - 1 ;
		t_Status = RecursiveEvaluate ( a_Expression , NULL , a_Root , t_Count ) ;
	}
	else
	{
	}

DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"PostEvaluation Status = (%lu)" ,
		( ULONG ) t_Status
	) ;
)

	return t_Status ;
}

void QueryPreprocessor :: PrintTree ( WmiTreeNode *a_Root )
{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Expression = "
	) ;
)

	if ( a_Root ) 
		a_Root->Print () ;
}

void QueryPreprocessor :: TransformAndOrExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_AndChild , 
	WmiTreeNode *a_OrChild 
)
{
	WmiTreeNode *t_OrLeftChild = a_OrChild->GetLeft () ;
	WmiTreeNode *t_OrRightChild = a_OrChild->GetRight () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_AndChildCopy = a_AndChild->Copy () ;

	WmiTreeNode *t_NewOrNode = new WmiOrNode ( NULL , NULL , t_Parent ) ;
	WmiTreeNode *t_NewOrNodeLeft = new WmiAndNode ( a_AndChild , t_OrLeftChild , t_NewOrNode ) ;
	WmiTreeNode *t_NewOrNodeRight = new WmiAndNode ( t_AndChildCopy , t_OrRightChild , t_NewOrNode ) ;

	t_NewOrNode->SetLeft ( t_NewOrNodeLeft ) ;
	t_NewOrNode->SetRight ( t_NewOrNodeRight) ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewOrNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewOrNode ) ;
		}	
	}

	a_Node->SetLeft ( NULL ) ;
	a_Node->SetRight ( NULL ) ;
	a_Node->SetData ( NULL ) ;

	a_OrChild->SetLeft ( NULL ) ;
	a_OrChild->SetRight ( NULL ) ;
	a_OrChild->SetData ( NULL ) ;

	delete a_Node ;
	delete a_OrChild ;

	a_Node = t_NewOrNode ;
}

void QueryPreprocessor :: TransformNotNotExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;
	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_Leaf ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_Leaf ) ;
		}	
	}

	delete a_Node ;
	delete a_Child ;

	t_Leaf->SetParent ( t_Parent ) ;

	a_Node = t_Leaf ;
}

void QueryPreprocessor :: TransformNotAndExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTreeNode *t_AndLeftChild = a_Child->GetLeft () ;
	WmiTreeNode *t_AndRightChild = a_Child->GetRight () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewOrNode = new WmiOrNode ( NULL , NULL , t_Parent ) ;
	WmiTreeNode *t_LeftNot = new WmiNotNode ( t_AndLeftChild , t_NewOrNode ) ;
	WmiTreeNode *t_RightNot= new WmiNotNode ( t_AndRightChild , t_NewOrNode ) ;

	t_NewOrNode->SetLeft ( t_LeftNot ) ;
	t_NewOrNode->SetRight ( t_RightNot ) ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewOrNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewOrNode ) ;
		}	
	}

	a_Node->SetLeft ( NULL ) ;
	a_Node->SetRight ( NULL ) ;
	a_Node->SetData ( NULL ) ;

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;
	delete a_Child ;

	a_Node = t_NewOrNode ;
}

void QueryPreprocessor :: TransformNotOrExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTreeNode *t_OrLeftChild = a_Child->GetLeft () ;
	WmiTreeNode *t_OrRightChild = a_Child->GetRight () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewAndNode = new WmiAndNode ( NULL , NULL , t_Parent ) ;
	WmiTreeNode *t_LeftNot = new WmiNotNode ( t_OrLeftChild , t_NewAndNode ) ;
	WmiTreeNode *t_RightNot= new WmiNotNode ( t_OrRightChild , t_NewAndNode ) ;

	t_NewAndNode->SetLeft ( t_LeftNot ) ;
	t_NewAndNode->SetRight ( t_RightNot ) ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewAndNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewAndNode ) ;
		}	
	}

	a_Node->SetLeft ( NULL ) ;
	a_Node->SetRight ( NULL ) ;
	a_Node->SetData ( NULL ) ;

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;
	delete a_Child ;

	a_Node = t_NewAndNode ;

}

void QueryPreprocessor :: TransformNotEqualExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *a_CopyLessChild = a_Child->Copy () ;
	WmiTreeNode *a_CopyGreaterChild = a_Child->Copy () ;

	WmiTreeNode *t_NewOrNode = new WmiOrNode ( NULL , NULL , t_Parent ) ;
	WmiTreeNode *t_LessNode = new WmiOperatorLessNode  ( a_CopyLessChild , t_NewOrNode ) ;
	WmiTreeNode *t_GreatorNode = new WmiOperatorGreaterNode  ( a_CopyGreaterChild , t_NewOrNode ) ;

	t_NewOrNode->SetLeft ( t_LessNode ) ;
	t_NewOrNode->SetRight ( t_GreatorNode ) ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewOrNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewOrNode ) ;
		}	

	}

	delete a_Node ;

	a_Node = t_NewOrNode ;
}

void QueryPreprocessor :: TransformNotOperatorEqualExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_LeafCopy = t_Leaf->Copy () ;

	WmiTreeNode *t_NewNode = new WmiOperatorNotEqualNode ( t_LeafCopy , t_Parent ) ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	delete a_Node ;

	a_Node = t_NewNode ;
}

void QueryPreprocessor :: TransformNotOperatorNotEqualExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_LeafCopy = t_Leaf->Copy () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualNode ( t_LeafCopy , t_Parent ) ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	delete a_Node ;

	a_Node = t_NewNode ;
}

void QueryPreprocessor :: TransformNotOperatorEqualOrGreaterExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_LeafCopy = t_Leaf->Copy () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualOrLessNode ( t_LeafCopy , t_Parent ) ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	

	}

	delete a_Node ;

	a_Node = t_NewNode ;
}

void QueryPreprocessor :: TransformNotOperatorEqualOrLessExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_LeafCopy = t_Leaf->Copy () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualOrGreaterNode ( t_LeafCopy , t_Parent ) ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	delete a_Node ;

	a_Node = t_NewNode ;
}

void QueryPreprocessor :: TransformNotOperatorGreaterExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_LeafCopy = t_Leaf->Copy () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualOrLessNode ( t_LeafCopy , t_Parent ) ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	delete a_Node ;

	a_Node = t_NewNode ;
}

void QueryPreprocessor :: TransformNotOperatorLessExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_LeafCopy = t_Leaf->Copy () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualOrGreaterNode ( t_LeafCopy , t_Parent ) ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	delete a_Node ;

	a_Node = t_NewNode ;
}

void QueryPreprocessor :: TransformNotOperatorLikeExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_LeafCopy = t_Leaf->Copy () ;

	WmiTreeNode *t_NewNode = new WmiOperatorNotLikeNode ( t_LeafCopy , t_Parent ) ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	

	}

	delete a_Node ;

	a_Node = t_NewNode ;
}

void QueryPreprocessor :: TransformNotOperatorNotLikeExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_LeafCopy = t_Leaf->Copy () ;

	WmiTreeNode *t_NewNode = new WmiOperatorLikeNode ( t_LeafCopy , t_Parent ) ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	delete a_Node ;

	a_Node = t_NewNode ;

}

BOOL QueryPreprocessor :: EvaluateNotExpression ( WmiTreeNode *&a_Node )
{
	if ( a_Node->GetLeft () )
	{
		WmiTreeNode *t_Left = a_Node->GetLeft () ;
		if ( typeid ( *t_Left ) == typeid ( WmiAndNode ) )
		{
			TransformNotAndExpression ( a_Node , t_Left ) ;
			return TRUE ;
		}
		else if ( typeid ( *t_Left ) == typeid ( WmiOrNode ) )
		{
			TransformNotOrExpression ( a_Node , t_Left ) ;
			return TRUE ;
		}
		else if ( typeid ( *t_Left ) == typeid ( WmiNotNode ) )
		{
			TransformNotNotExpression ( a_Node , t_Left ) ;
			return TRUE ;
		}
		else if ( typeid ( *t_Left ) == typeid ( WmiOperatorEqualNode ) )
		{
			TransformNotOperatorEqualExpression ( a_Node , t_Left ) ;
			return TRUE ;
		}
		else if ( typeid ( *t_Left ) == typeid ( WmiOperatorNotEqualNode ) )
		{
			TransformNotOperatorNotEqualExpression ( a_Node , t_Left ) ;
			return TRUE ;
		}
		else if ( typeid ( *t_Left ) == typeid ( WmiOperatorEqualOrGreaterNode ) )
		{
			TransformNotOperatorEqualOrGreaterExpression ( a_Node , t_Left ) ;
			return TRUE ;
		}
		else if ( typeid ( *t_Left ) == typeid ( WmiOperatorEqualOrLessNode ) )
		{
			TransformNotOperatorEqualOrLessExpression ( a_Node , t_Left ) ;
			return TRUE ;
		}
		else if ( typeid ( *t_Left ) == typeid ( WmiOperatorLessNode ) )
		{
			TransformNotOperatorLessExpression ( a_Node , t_Left ) ;
			return TRUE ;
		}
		else if ( typeid ( *t_Left ) == typeid ( WmiOperatorGreaterNode ) )
		{
			TransformNotOperatorGreaterExpression ( a_Node , t_Left ) ;
			return TRUE ;
		}
		else if ( typeid ( *t_Left ) == typeid ( WmiOperatorLikeNode ) )
		{
			TransformNotOperatorLikeExpression ( a_Node , t_Left ) ;
			return TRUE ;
		}
		else if ( typeid ( *t_Left ) == typeid ( WmiOperatorNotLikeNode ) )
		{
			TransformNotOperatorNotLikeExpression ( a_Node , t_Left ) ;
			return TRUE ;
		}
		else
		{
		}
	}

	return FALSE ;
}

BOOL QueryPreprocessor :: EvaluateNotEqualExpression ( WmiTreeNode *&a_Node )
{
	WmiTreeNode *t_Left = a_Node->GetLeft () ;

	TransformNotEqualExpression ( a_Node , t_Left ) ;
	return TRUE ;
}

BOOL QueryPreprocessor :: EvaluateAndExpression ( WmiTreeNode *&a_Node )
{
	WmiTreeNode *t_Left = a_Node->GetLeft () ;
	WmiTreeNode *t_Right = a_Node->GetRight () ;
	
	if ( t_Left )
	{
		if ( typeid ( *t_Left ) == typeid ( WmiAndNode ) )
		{
		}
		else if ( typeid ( *t_Left ) == typeid ( WmiOrNode ) )
		{
			TransformAndOrExpression ( a_Node , t_Right , t_Left ) ;
			return TRUE ;
		}
		else if ( typeid ( *t_Left ) == typeid ( WmiNotNode ) )
		{
		}
		else
		{
		}
	}

	if ( t_Right )
	{
		if ( typeid ( *t_Right ) == typeid ( WmiAndNode ) )
		{
		}
		else if ( typeid ( *t_Right ) == typeid ( WmiOrNode ) )
		{
			TransformAndOrExpression ( a_Node , t_Left , t_Right ) ;
			return TRUE ;
		}
		else if ( typeid ( *t_Right ) == typeid ( WmiNotNode ) )
		{
		}
		else
		{
		}
	}

	return FALSE ;
}

BOOL QueryPreprocessor :: EvaluateOrExpression ( WmiTreeNode *&a_Node )
{
	return FALSE ;
}

BOOL QueryPreprocessor :: RecursiveDisjunctiveNormalForm ( WmiTreeNode *&a_Node )
{
	BOOL t_Status = FALSE ;

	if ( a_Node ) 
	{
		if ( typeid ( *a_Node ) == typeid ( WmiAndNode ) )
		{
			if ( EvaluateAndExpression ( a_Node ) )
			{
				t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
				t_Status = TRUE ;
			}
			else
			{
				WmiTreeNode *t_Left = a_Node->GetLeft () ;
				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;
					while ( t_Status )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
					}
				}

				WmiTreeNode *t_Right = a_Node->GetRight () ;
				if ( t_Right )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Right ) ;
					while ( t_Status )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
					}
				}
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiOrNode ) )
		{
			if ( EvaluateOrExpression ( a_Node ) )
			{
				t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
				t_Status = TRUE ;
			}
			else
			{
				WmiTreeNode *t_Left = a_Node->GetLeft () ;

				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;
					while ( t_Status )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
					}

				}

				WmiTreeNode *t_Right = a_Node->GetRight () ;

				if ( t_Right  )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Right ) ;
					while ( t_Status )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
					}
				}
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiNotNode ) )
		{
			if ( EvaluateNotExpression ( a_Node ) )
			{
				t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
				t_Status = TRUE ;
			}
			else
			{
				WmiTreeNode *t_Left = a_Node->GetLeft () ;

				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;

					while ( t_Status )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
					}

				}
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiOperatorNotEqualNode ) )
		{
			if ( EvaluateNotEqualExpression ( a_Node ) )
			{
				t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
				t_Status = TRUE ;
			}
			else
			{
				WmiTreeNode *t_Left = a_Node->GetLeft () ;

				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;

					while ( t_Status )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
					}
				}
			}
		}
		else
		{
		}
	}

	return t_Status ;
}

void QueryPreprocessor :: DisjunctiveNormalForm ( WmiTreeNode *&a_Root ) 
{
	RecursiveDisjunctiveNormalForm ( a_Root ) ;
}

void QueryPreprocessor :: TransformAndTrueEvaluation ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	if ( a_Node->GetLeft () == a_Child )
	{
		a_Node->SetLeft ( NULL ) ;
	}
	else
	{
		a_Node->SetRight ( NULL ) ;
	}

	WmiTreeNode *t_Parent = a_Node->GetParent () ;
	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( a_Child ) ;
		}
		else 
		{
			t_Parent->SetRight ( a_Child ) ;
		}	
	}

	a_Child->SetParent ( t_Parent ) ;

	delete a_Node ;
	a_Node = a_Child ;
}

void QueryPreprocessor :: TransformOrFalseEvaluation ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	if ( a_Node->GetLeft () == a_Child )
	{
		a_Node->SetLeft ( NULL ) ;
	}
	else
	{
		a_Node->SetRight ( NULL ) ;
	}

	WmiTreeNode *t_Parent = a_Node->GetParent () ;
	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( a_Child ) ;
		}
		else 
		{
			t_Parent->SetRight ( a_Child ) ;
		}	

	}

	a_Child->SetParent ( t_Parent ) ;

	delete a_Node ;

	a_Node = a_Child ;
}

void QueryPreprocessor :: TransformOperatorToRange ( 

	WmiTreeNode *&a_Node 
)
{
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiOperatorNode *t_OperatorNode = ( WmiOperatorNode * ) a_Node ;
	WmiTreeNode *t_Range = t_OperatorNode->GetRange () ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_Range ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_Range) ;
		}	

	}

	t_Range->SetParent ( t_Parent ) ;

	delete a_Node ;

	a_Node = t_Range ;
}

QueryPreprocessor :: QuadState QueryPreprocessor :: RecursiveRemoveInvariants ( WmiTreeNode *&a_Node )
{
	QueryPreprocessor :: QuadState t_Status = State_Undefined ;

	if ( a_Node ) 
	{
		if ( typeid ( *a_Node ) == typeid ( WmiOrNode ) )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveRemoveInvariants ( t_Left ) ;

				if ( t_Status == State_False )
				{
					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Right
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Node ) ;
					return t_Status ;
				}
			}

			if ( t_Right )
			{
				t_Status = RecursiveRemoveInvariants ( t_Right ) ;

				if ( t_Status == State_False )
				{
					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Left
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Node ) ;
					return t_Status ;
				}
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiAndNode ) )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveRemoveInvariants ( t_Left ) ;
				if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Right
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Node ) ;
					return t_Status ;
				}
			}

			if ( t_Right )
			{
				t_Status = RecursiveRemoveInvariants ( t_Right ) ;

				if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Left
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Node ) ;
					return t_Status ;
				}
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiNotNode ) )
		{
// Should never happen, failure in DFN evaluation otherwise
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiOperatorEqualNode ) )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiOperatorNotEqualNode ) )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiOperatorEqualOrGreaterNode ) )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiOperatorEqualOrLessNode ) )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiOperatorLessNode ) )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiOperatorGreaterNode ) )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiOperatorLikeNode ) )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiOperatorNotLikeNode ) )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else
		{
// Should never happen, failure in DFN evaluation otherwise
		}
	}

	return t_Status ;
}

QueryPreprocessor :: QuadState QueryPreprocessor :: RemoveInvariants ( WmiTreeNode *&a_Root )
{
	QuadState t_Status = RecursiveRemoveInvariants ( a_Root ) ;
	if ( t_Status == State_ReEvaluate )
	{
		t_Status = RemoveInvariants ( a_Root ) ;
		if ( t_Status == State_False || t_Status == State_True )
		{
			delete a_Root ;
			a_Root = NULL ;
		}
	}

	return t_Status ;
}

BOOL QueryPreprocessor :: RecursiveInsertNode ( WmiTreeNode *&a_Node , WmiTreeNode *&a_Insertion )
{
	BOOL t_Status = FALSE ;

	if ( a_Node ) 
	{
		if ( typeid ( *a_Node ) == typeid ( WmiAndNode ) )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;

			if ( t_Left )
			{
				t_Status = RecursiveInsertNode ( t_Left , a_Insertion ) ;
				if ( t_Status == TRUE )
				{
					return t_Status ;
				}
			}

			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Right  )
			{
				t_Status = RecursiveInsertNode ( t_Right , a_Insertion ) ;
				if ( t_Status == TRUE )
				{
					return t_Status ;
				}
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiOrNode ) )
		{
// Should never happen, failure in DFN evaluation otherwise
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiNotNode ) )
		{
// Should never happen, failure in DFN evaluation otherwise
		}
		else
		{
// Operator

			WmiValueNode *t_CompareValue = ( WmiValueNode * ) a_Node->GetLeft () ;
			WmiValueNode *t_InsertionValue = ( WmiValueNode * ) a_Insertion->GetLeft () ;
			LONG t_Compare = t_InsertionValue ->ComparePropertyName ( *t_CompareValue ) ;
			if ( t_Compare < 0 )
			{
// Insert to left

				WmiTreeNode *t_Parent = a_Node->GetParent () ;
				WmiTreeNode *t_NewAndNode = new WmiAndNode ( a_Insertion , a_Node , t_Parent ) ;
				a_Node->SetParent ( t_NewAndNode ) ;
				a_Insertion->SetParent ( t_NewAndNode ) ;

				if ( t_Parent )
				{
					if ( t_Parent->GetLeft () == a_Node )
					{
						t_Parent->SetLeft ( t_NewAndNode ) ;
					}
					else
					{
						t_Parent->SetRight ( t_NewAndNode ) ;
					}
				}
				else
				{
// Must have parent !!!!
				}

				a_Node = t_NewAndNode ;

				t_Status = TRUE ;
			}
			else
			{
				t_Status = FALSE ;
			}
		}
	}
	else
	{
		a_Node = a_Insertion ;
		t_Status = TRUE ;
	}

	return t_Status ;
}

// Note, linear search to retain 'And', change later for logn search

BOOL QueryPreprocessor :: InsertNode ( WmiTreeNode *&a_NewRoot , WmiTreeNode *&a_Insertion )
{
	BOOL t_Status = RecursiveInsertNode ( a_NewRoot , a_Insertion ) ;
	if ( t_Status == FALSE )
	{
// Insert to right

		WmiTreeNode *t_Parent = a_NewRoot->GetParent () ;
		WmiTreeNode *t_NewAndNode = new WmiAndNode ( a_NewRoot , a_Insertion , t_Parent ) ;
		a_NewRoot->SetParent ( t_NewAndNode ) ;
		a_Insertion->SetParent ( t_NewAndNode ) ;

		if ( t_Parent )
		{
			if ( t_Parent->GetLeft () == a_NewRoot )
			{
				t_Parent->SetLeft ( t_NewAndNode ) ;
			}
			else
			{
				t_Parent->SetRight ( t_NewAndNode ) ;
			}
		}
		else
		{
// Must have parent !!!!
		}

		a_NewRoot = t_NewAndNode ;
	}

	return TRUE ;
}

BOOL QueryPreprocessor :: RecursiveSortConditionals ( WmiTreeNode *&a_NewRoot , WmiTreeNode *&a_Node )
{
	BOOL t_Status = FALSE ;

	if ( a_Node ) 
	{
		if ( typeid ( *a_Node ) == typeid ( WmiAndNode ) )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveSortConditionals ( a_NewRoot , t_Left  ) ;
				a_Node->SetLeft ( NULL ) ;
				delete t_Left ;
			}

			if ( t_Right  )
			{
				t_Status = RecursiveSortConditionals ( a_NewRoot , t_Right ) ;
				a_Node->SetRight ( NULL ) ;
				delete t_Right ;
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiOrNode ) )
		{
// Should never happen, failure in DFN evaluation otherwise
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiNotNode ) )
		{
// Should never happen, failure in DFN evaluation otherwise
		}
		else
		{
// Operator

			WmiTreeNode *t_Parent = a_Node->GetParent () ;
			if ( t_Parent ) 
			{
				if ( t_Parent->GetLeft () == a_Node )
				{
					t_Parent->SetLeft ( NULL ) ;
				}
				else
				{
					t_Parent->SetRight ( NULL ) ;
				}
			}

			a_Node->SetParent ( NULL ) ;

			t_Status = InsertNode ( a_NewRoot , a_Node ) ;

			a_Node = NULL ;

		}		
	}

	return t_Status ;
}

BOOL QueryPreprocessor :: SortConditionals ( WmiTreeNode *&a_Root )
{
	WmiTreeNode *t_NewRoot = NULL ;
	BOOL t_Status = RecursiveSortConditionals ( t_NewRoot , a_Root ) ;

	WmiTreeNode *t_Parent = a_Root->GetParent () ;
	if ( t_Parent ) 
	{
		if ( t_Parent->GetLeft () == a_Root )
		{
			t_Parent->SetLeft ( t_NewRoot ) ;
		}
		else
		{
			t_Parent->SetRight ( t_NewRoot ) ;
		}
	}

	t_NewRoot->SetParent ( t_Parent ) ;

	delete a_Root ;
	a_Root = t_NewRoot ;

	return t_Status ;
}

BOOL QueryPreprocessor :: RecursiveSort ( WmiTreeNode *&a_Node )
{
	BOOL t_Status = FALSE ;

	if ( a_Node ) 
	{
		if ( typeid ( *a_Node ) == typeid ( WmiOrNode ) )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveSort ( t_Left ) ;
			}

			if ( t_Right  )
			{
				t_Status = RecursiveSort ( t_Right ) ;
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiAndNode ) )
		{
			t_Status = SortConditionals ( a_Node ) ;
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiNotNode ) )
		{
// Should never happen, failure in DFN evaluation otherwise
		}
		else
		{
// Should never happen, failure in DFN evaluation otherwise
		}
	}

	return t_Status ;
}

BOOL QueryPreprocessor :: Sort ( WmiTreeNode *&a_Root )
{
	BOOL t_Status = RecursiveSort ( a_Root ) ;
	return t_Status ;
}

BOOL QueryPreprocessor :: RecursiveConvertToRanges ( WmiTreeNode *&a_Node )
{
	BOOL t_Status = TRUE ;

	if ( a_Node ) 
	{
		if ( typeid ( *a_Node ) == typeid ( WmiOrNode ) )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveConvertToRanges ( t_Left ) ;
			}

			if ( t_Right  )
			{
				t_Status = RecursiveConvertToRanges ( t_Right ) ;
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiAndNode ) )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveConvertToRanges ( t_Left ) ;
			}

			if ( t_Right  )
			{
				t_Status = RecursiveConvertToRanges ( t_Right ) ;
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiNotNode ) )
		{
// Should never happen, failure in DFN evaluation otherwise
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiOperatorEqualNode ) )
		{
			TransformOperatorToRange ( a_Node ) ; 
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiOperatorEqualOrGreaterNode ) )
		{
			TransformOperatorToRange ( a_Node ) ; 
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiOperatorEqualOrLessNode ) )
		{
			TransformOperatorToRange ( a_Node ) ; 
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiOperatorLessNode ) )
		{
			TransformOperatorToRange ( a_Node ) ; 
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiOperatorGreaterNode ) )
		{
			TransformOperatorToRange ( a_Node ) ; 
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiOperatorLikeNode ) )
		{
			TransformOperatorToRange ( a_Node ) ; 
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiOperatorNotLikeNode ) )
		{
			TransformOperatorToRange ( a_Node ) ; 
		}
		else
		{
// Should never happen, failure in DFN evaluation otherwise
		}
	}

	return t_Status ;
}

BOOL QueryPreprocessor :: ConvertToRanges ( WmiTreeNode *&a_Root )
{
	BOOL t_Status = RecursiveConvertToRanges ( a_Root ) ;
	return t_Status ;
}

void QueryPreprocessor :: TransformIntersectingRange (

	WmiTreeNode *&a_Node ,
	WmiTreeNode *a_Compare ,
	WmiTreeNode *a_Intersection
)
{
	WmiTreeNode *t_CompareParent = a_Compare->GetParent () ;
	if ( t_CompareParent )
	{
		if ( t_CompareParent->GetLeft () == a_Compare )
		{
			t_CompareParent->SetLeft ( a_Intersection ) ;
		}
		else
		{
			t_CompareParent->SetRight ( a_Intersection ) ;
		}
	}

	delete a_Compare ;
}

void QueryPreprocessor :: TransformNonIntersectingRange (

	WmiTreeNode *&a_Node ,
	WmiTreeNode *a_Compare
) 
{
}

QueryPreprocessor :: QuadState QueryPreprocessor :: RecursiveRemoveNonOverlappingRanges ( WmiTreeNode *&a_Node , WmiTreeNode *&a_Compare )
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_Undefined ;

	if ( a_Node ) 
	{
		if ( typeid ( *a_Node ) == typeid ( WmiOrNode ) )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				a_Compare = NULL ;
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Left , a_Compare ) ;
				if ( t_Status == State_False )
				{
					WmiTreeNode *t_Right = a_Node->GetRight () ;

					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Right
					) ;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}
			}

			WmiTreeNode *t_Right = a_Node->GetRight () ;
			if ( t_Right  )
			{
				a_Compare = NULL ;
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Right , a_Compare ) ;
				if ( t_Status == State_False )
				{
					WmiTreeNode *t_Left = a_Node->GetLeft () ;

					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Left
					) ;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiAndNode ) )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Left , a_Compare ) ;
				if ( t_Status == State_True )
				{
					WmiTreeNode *t_Right = a_Node->GetRight () ;

					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Right
					) ;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}
			}

			WmiTreeNode *t_Right = a_Node->GetRight () ;
			if ( t_Right  )
			{
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Right , a_Compare ) ;

				if ( t_Status == State_True )
				{
					WmiTreeNode *t_Left = a_Node->GetLeft () ;

					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Left
					) ;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}

			}
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiNullRangeNode ) )
		{
			WmiRangeNode *t_Node = ( WmiRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				WmiRangeNode *t_Range = ( WmiRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( typeid ( *t_Range ) == typeid ( WmiNullRangeNode ) )
					{
						WmiTreeNode *t_Intersection = a_Node->Copy () ;

						TransformIntersectingRange (

							a_Node ,
							a_Compare ,
							t_Intersection
						) ;

						a_Compare = t_Intersection ;

						t_Status = QueryPreprocessor :: QuadState :: State_True ;

					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiStringRangeNode ) )
		{
			WmiStringRangeNode *t_Node = ( WmiStringRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				WmiRangeNode *t_Range = ( WmiRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( typeid ( *t_Range ) == typeid ( WmiStringRangeNode ) )
					{
						WmiStringRangeNode *t_StringRange = ( WmiStringRangeNode * ) t_Range ;

						WmiStringRangeNode *t_Intersection = NULL ;
						BOOL t_Intersected = t_StringRange->GetIntersectingRange (

							*t_Node ,
							t_Intersection
						) ;

						if ( t_Intersected )
						{
							TransformIntersectingRange (

								a_Node ,
								a_Compare ,
								t_Intersection
							) ;

							a_Compare = t_Intersection ;

							t_Status = QueryPreprocessor :: QuadState :: State_True ;
						}
						else
						{
							TransformNonIntersectingRange (

								a_Node ,
								a_Compare
							) ;

							a_Compare = NULL ;

							t_Status = QueryPreprocessor :: QuadState :: State_False ;
						}
					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiUnsignedIntegerRangeNode ) )
		{
			WmiUnsignedIntegerRangeNode *t_Node = ( WmiUnsignedIntegerRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				WmiRangeNode *t_Range = ( WmiRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( typeid ( *t_Range ) == typeid ( WmiUnsignedIntegerRangeNode ) )
					{
						WmiUnsignedIntegerRangeNode *t_IntegerRange = ( WmiUnsignedIntegerRangeNode * ) t_Range ;

						WmiUnsignedIntegerRangeNode *t_Intersection = NULL ;
						BOOL t_Intersected = t_IntegerRange->GetIntersectingRange (

							*t_Node ,
							t_Intersection
						) ;

						if ( t_Intersected )
						{
							TransformIntersectingRange (

								a_Node ,
								a_Compare ,
								t_Intersection
							) ;

							a_Compare = t_Intersection ;

							t_Status = QueryPreprocessor :: QuadState :: State_True ;
						}
						else
						{
							TransformNonIntersectingRange (

								a_Node ,
								a_Compare
							) ;

							a_Compare = NULL ;

							t_Status = QueryPreprocessor :: QuadState :: State_False ;
						}
					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiSignedIntegerRangeNode ) )
		{
			WmiSignedIntegerRangeNode *t_Node = ( WmiSignedIntegerRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				WmiRangeNode *t_Range = ( WmiRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( typeid ( *t_Range ) == typeid ( WmiSignedIntegerRangeNode ) )
					{
						WmiSignedIntegerRangeNode *t_IntegerRange = ( WmiSignedIntegerRangeNode * ) t_Range ;

						WmiSignedIntegerRangeNode *t_Intersection = NULL ;
						BOOL t_Intersected = t_IntegerRange->GetIntersectingRange (

							*t_Node ,
							t_Intersection
						) ;

						if ( t_Intersected )
						{
							TransformIntersectingRange (

								a_Node ,
								a_Compare ,
								t_Intersection
							) ;

							a_Compare = t_Intersection ;

							t_Status = QueryPreprocessor :: QuadState :: State_True ;

						}
						else
						{
							TransformNonIntersectingRange (

								a_Node ,
								a_Compare
							) ;

							a_Compare = NULL ;

							t_Status = QueryPreprocessor :: QuadState :: State_False ;
						}
					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else
		{
// Should never happen, failure in DFN evaluation otherwise
		}
	}

	return t_Status ;
}


QueryPreprocessor :: QuadState QueryPreprocessor :: RemoveNonOverlappingRanges  ( WmiTreeNode *&a_Root )
{
	WmiTreeNode *t_Compare = NULL ;

	QueryPreprocessor :: QuadState t_Status = RecursiveRemoveNonOverlappingRanges ( a_Root , t_Compare ) ;
	if ( t_Status == State_ReEvaluate )
	{
		t_Status = RemoveNonOverlappingRanges ( a_Root ) ;
		if ( t_Status == State_False || t_Status == State_True )
		{
			delete a_Root ;
			a_Root = NULL ;
		}
	
	}

	return t_Status ;
}

void QueryPreprocessor :: CountDisjunctions ( WmiTreeNode *a_Node , ULONG &a_Count ) 
{
	if ( a_Node ) 
	{
		if ( typeid ( *a_Node ) == typeid ( WmiOrNode ) )
		{
			a_Count ++ ;

			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				CountDisjunctions ( t_Left , a_Count ) ;
			}

			WmiTreeNode *t_Right = a_Node->GetRight () ;
			if ( t_Right  )
			{
				CountDisjunctions ( t_Right , a_Count ) ;
			}
		}
	}
}

void QueryPreprocessor :: CreateDisjunctions ( 

	WmiTreeNode *a_Node , 
	Disjunctions *a_Disjunctions , 
	ULONG a_PropertiesToPartitionCount ,
	BSTR *a_PropertiesToPartition ,
	ULONG &a_DisjunctionIndex
) 
{
	if ( a_Node ) 
	{
		if ( typeid ( *a_Node ) == typeid ( WmiOrNode ) )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				CreateDisjunctions ( 

					t_Left , 
					a_Disjunctions ,
					a_PropertiesToPartitionCount ,
					a_PropertiesToPartition ,
					a_DisjunctionIndex 
				) ;
			}

			Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( a_DisjunctionIndex ) ;

			for ( ULONG t_Index = 0 ; t_Index < a_PropertiesToPartitionCount ; t_Index ++ )
			{
				if ( t_Disjunction->GetRange ( t_Index ) == NULL )
				{
					WmiRangeNode *t_RangeNode = AllocInfiniteRangeNode ( 

						a_PropertiesToPartition [ t_Index ] 
					) ;

					t_Disjunction->SetRange ( t_Index , t_RangeNode ) ;
				}
			}

			a_DisjunctionIndex ++ ;

			WmiTreeNode *t_Right = a_Node->GetRight () ;
			if ( t_Right )
			{
				CreateDisjunctions ( 

					t_Right , 
					a_Disjunctions ,
					a_PropertiesToPartitionCount ,
					a_PropertiesToPartition ,
					a_DisjunctionIndex
				) ;
			}

			t_Disjunction = a_Disjunctions->GetDisjunction ( a_DisjunctionIndex ) ;

			for ( t_Index = 0 ; t_Index < a_PropertiesToPartitionCount ; t_Index ++ )
			{
				if ( t_Disjunction->GetRange ( t_Index ) == NULL )
				{
					WmiRangeNode *t_RangeNode = AllocInfiniteRangeNode ( 

						a_PropertiesToPartition [ t_Index ] 
					) ;

					t_Disjunction->SetRange ( t_Index , t_RangeNode ) ;
				}
			}
		}
		else if ( typeid ( *a_Node ) == typeid ( WmiAndNode ) )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				CreateDisjunctions ( 

					t_Left , 
					a_Disjunctions ,
					a_PropertiesToPartitionCount ,
					a_PropertiesToPartition ,
					a_DisjunctionIndex
				) ;
			}

			WmiTreeNode *t_Right = a_Node->GetRight () ;
			if ( t_Right  )
			{
				CreateDisjunctions ( 

					t_Right , 
					a_Disjunctions ,
					a_PropertiesToPartitionCount ,
					a_PropertiesToPartition ,
					a_DisjunctionIndex
				) ;
			}
		}
		else
		{
			Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( a_DisjunctionIndex ) ;
			WmiRangeNode *t_Node = ( WmiRangeNode * ) a_Node ;
			BSTR t_PropertyName = t_Node->GetPropertyName () ;
			for ( ULONG t_Index = 0 ; t_Index < a_PropertiesToPartitionCount ; t_Index ++ )
			{
				if ( _wcsicmp ( t_PropertyName , a_PropertiesToPartition [ t_Index ] ) == 0 )
				{
					t_Disjunction->SetRange ( t_Index , ( WmiRangeNode * ) t_Node->Copy () ) ;
					break ;
				}
			}			
		}
	}
}

BOOL QueryPreprocessor :: CreateDisjunctionContainer ( WmiTreeNode *a_Root , Disjunctions *&a_Disjunctions )
{
	BOOL t_Status = TRUE ;

	ULONG t_PropertiesToPartitionCount = 0 ;
	BSTR *t_PropertiesToPartition = NULL ;

	GetPropertiesToPartition ( t_PropertiesToPartitionCount , t_PropertiesToPartition ) ;
	if ( t_PropertiesToPartitionCount )
	{
		ULONG t_Count = 1 ;
		CountDisjunctions ( a_Root , t_Count ) ;
		a_Disjunctions = new Disjunctions ( t_Count , t_PropertiesToPartitionCount ) ;

		t_Count = 0 ; 
		CreateDisjunctions ( 

			a_Root , 
			a_Disjunctions ,
			t_PropertiesToPartitionCount ,
			t_PropertiesToPartition ,
			t_Count
		) ;

/*
 *	Deallocate array
 */

		Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( 0 ) ;

		for ( ULONG t_Index = 0 ; t_Index < t_PropertiesToPartitionCount ; t_Index ++ )
		{
			if ( t_Disjunction->GetRange ( t_Index ) == NULL )
			{
				WmiRangeNode *t_RangeNode = AllocInfiniteRangeNode ( 

					t_PropertiesToPartition [ t_Index ] 
				) ;

				t_Disjunction->SetRange ( t_Index , t_RangeNode ) ;
			}
		}

		for ( t_Index = 0 ; t_Index < t_PropertiesToPartitionCount ; t_Index ++ )
		{
			SysFreeString ( t_PropertiesToPartition [ t_Index ] ) ;
		}

		delete [] t_PropertiesToPartition ;
	}

	return t_Status ;
}

BOOL QueryPreprocessor :: RecursivePartitionSet ( 

	Disjunctions *a_Disjunctions , 
	PartitionSet *&a_Partition , 
	ULONG a_DisjunctionSetToTestCount ,
	ULONG *a_DisjunctionSetToTest ,
	ULONG a_KeyIndex 
)
{
	BOOL t_Status = TRUE ;

	ULONG t_DisjunctionCount = a_Disjunctions->GetDisjunctionCount () ;
	ULONG t_ConjunctionCount = a_Disjunctions->GetConjunctionCount () ;

	if ( a_KeyIndex < t_ConjunctionCount )
	{
		ULONG *t_OverlappingIndex = new ULONG [ t_DisjunctionCount ] ;
		ULONG *t_SortedDisjunctionSetToTest = new ULONG [ t_DisjunctionCount ] ;
		WmiRangeNode **t_RangeTable = new WmiRangeNode * [ t_DisjunctionCount ] ;

		for ( ULONG t_Index = 0 ; t_Index < t_DisjunctionCount ; t_Index ++ )
		{
			t_OverlappingIndex [ t_Index ] = t_Index ;

			Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( t_Index ) ;
			t_RangeTable [ t_Index ] = ( WmiRangeNode * ) ( t_Disjunction->GetRange ( a_KeyIndex )->Copy () ) ;
			t_SortedDisjunctionSetToTest [ t_Index ] = t_Index ;
		}

// Sort Partitions

		for ( ULONG t_OuterIndex = 0 ; t_OuterIndex < t_DisjunctionCount ; t_OuterIndex ++ )
		{
			for ( ULONG t_InnerIndex = 0 ; t_InnerIndex < t_DisjunctionCount ; t_InnerIndex ++ )
			{
				if ( CompareLessRangeNode ( t_RangeTable [ t_InnerIndex ] , t_RangeTable [ t_OuterIndex ] ) == FALSE )
				{
					WmiRangeNode *t_Range = t_RangeTable [ t_InnerIndex ] ;
					t_RangeTable [ t_InnerIndex ] = t_RangeTable [ t_OuterIndex ] ;
					t_RangeTable [ t_OuterIndex ] = t_Range ;

					ULONG t_Overlap = t_OverlappingIndex [ t_InnerIndex ] ;
					t_OverlappingIndex [ t_InnerIndex ] = t_OverlappingIndex [ t_OuterIndex ] ;
					t_OverlappingIndex [ t_OuterIndex ] = t_Overlap ;

					ULONG t_ToTest = t_SortedDisjunctionSetToTest [ t_InnerIndex ] ;
					t_SortedDisjunctionSetToTest [ t_InnerIndex ] = t_SortedDisjunctionSetToTest [ t_OuterIndex ] ;
					t_SortedDisjunctionSetToTest [ t_OuterIndex ] = t_ToTest ;
				}	
			}
		}

		for ( t_OuterIndex = 0 ; t_OuterIndex < t_DisjunctionCount ; t_OuterIndex ++ )
		{
			for ( ULONG t_InnerIndex = 0 ; t_InnerIndex < t_DisjunctionCount ; t_InnerIndex ++ )
			{
				ULONG t_OuterToTest = a_DisjunctionSetToTest [ t_SortedDisjunctionSetToTest [ t_OuterIndex ] ] ;
				ULONG t_InnerToTest = a_DisjunctionSetToTest [ t_SortedDisjunctionSetToTest [ t_InnerIndex ] ] ;

				if ( t_OuterToTest == t_InnerToTest )
				{
					if ( t_OverlappingIndex [ t_OuterIndex ] != t_OverlappingIndex [ t_InnerIndex ] )
					{
						WmiRangeNode *t_LeftRange = t_RangeTable [ t_OuterIndex ] ;
						WmiRangeNode *t_RightRange = t_RangeTable [ t_InnerIndex ] ;

						if ( t_LeftRange && t_RightRange )
						{
							if ( typeid ( *t_LeftRange ) == typeid ( WmiStringRangeNode ) && typeid ( *t_RightRange ) == typeid ( WmiStringRangeNode ) )
							{
								WmiStringRangeNode *t_LeftString = ( WmiStringRangeNode * ) t_LeftRange ;
								WmiStringRangeNode *t_RightString = ( WmiStringRangeNode * ) t_RightRange ;

								WmiStringRangeNode *t_OverLap = NULL ;

								if ( t_LeftString->GetOverlappingRange ( *t_RightString, t_OverLap ) )
								{
									if ( t_OverlappingIndex [ t_OuterIndex ] < t_OverlappingIndex [ t_InnerIndex ] )
									{
										delete t_RangeTable [ t_OuterIndex ] ;
										t_RangeTable [ t_OuterIndex ] = t_OverLap ;

										delete t_RangeTable [ t_InnerIndex ] ;
										t_RangeTable [ t_InnerIndex ] = NULL ;
										
										t_OverlappingIndex [ t_InnerIndex ] = t_OverlappingIndex [ t_OuterIndex ] ;
									}
									else
									{
										delete t_RangeTable [ t_OuterIndex ] ;
										t_RangeTable [ t_OuterIndex ] = NULL ;

										delete t_RangeTable [ t_InnerIndex ] ;
										t_RangeTable [ t_InnerIndex ] = t_OverLap ;

										t_OverlappingIndex [ t_OuterIndex ] = t_OverlappingIndex [ t_InnerIndex ] ;
									}
								}
								else
								{
								}
							}
							else if ( typeid ( *t_LeftRange ) == typeid ( WmiSignedIntegerRangeNode ) && typeid ( *t_RightRange ) == typeid ( WmiSignedIntegerRangeNode ) )
							{
								WmiSignedIntegerRangeNode *t_LeftInteger = ( WmiSignedIntegerRangeNode * ) t_LeftRange ;
								WmiSignedIntegerRangeNode *t_RightInteger = ( WmiSignedIntegerRangeNode * ) t_RightRange ;

								WmiSignedIntegerRangeNode *t_OverLap = NULL ;

								if ( t_LeftInteger->GetOverlappingRange ( *t_RightInteger , t_OverLap ) )
								{
									if ( t_OverlappingIndex [ t_OuterIndex ] < t_OverlappingIndex [ t_InnerIndex ] )
									{
										delete t_RangeTable [ t_OuterIndex ] ;
										t_RangeTable [ t_OuterIndex ] = t_OverLap ;

										delete t_RangeTable [ t_InnerIndex ] ;
										t_RangeTable [ t_InnerIndex ] = NULL ;

										t_OverlappingIndex [ t_InnerIndex ] = t_OverlappingIndex [ t_OuterIndex ] ;
									}
									else
									{
										delete t_RangeTable [ t_OuterIndex ] ;
										t_RangeTable [ t_OuterIndex ] = NULL ;

										delete t_RangeTable [ t_InnerIndex ] ;
										t_RangeTable [ t_InnerIndex ] = t_OverLap ;

										t_OverlappingIndex [ t_OuterIndex ] = t_OverlappingIndex [ t_InnerIndex ] ;
									}
								}
								else
								{
								}
							}
							else if ( typeid ( *t_LeftRange ) == typeid ( WmiUnsignedIntegerRangeNode ) && typeid ( *t_RightRange ) == typeid ( WmiUnsignedIntegerRangeNode ) )
							{
								WmiUnsignedIntegerRangeNode *t_LeftInteger = ( WmiUnsignedIntegerRangeNode * ) t_LeftRange ;
								WmiUnsignedIntegerRangeNode *t_RightInteger = ( WmiUnsignedIntegerRangeNode * ) t_RightRange ;

								WmiUnsignedIntegerRangeNode *t_OverLap = NULL ;

								if ( t_LeftInteger->GetOverlappingRange ( *t_RightInteger , t_OverLap ) )
								{
									if ( t_OverlappingIndex [ t_OuterIndex ] < t_OverlappingIndex [ t_InnerIndex ] )
									{
										delete t_RangeTable [ t_OuterIndex ] ;
										t_RangeTable [ t_OuterIndex ] = t_OverLap ;

										delete t_RangeTable [ t_InnerIndex ] ;
										t_RangeTable [ t_InnerIndex ] = NULL ;

										t_OverlappingIndex [ t_InnerIndex ] = t_OverlappingIndex [ t_OuterIndex ] ;
									}
									else
									{
										delete t_RangeTable [ t_OuterIndex ] ;
										t_RangeTable [ t_OuterIndex ] = NULL ;

										delete t_RangeTable [ t_InnerIndex ] ;
										t_RangeTable [ t_InnerIndex ] = t_OverLap ;

										t_OverlappingIndex [ t_OuterIndex ] = t_OverlappingIndex [ t_InnerIndex ] ;
									}
								}
								else
								{
								}
							}
							else if ( typeid ( *t_LeftRange ) == typeid ( WmiNullRangeNode ) && typeid ( *t_RightRange ) == typeid ( WmiNullRangeNode ) )
							{
								WmiRangeNode *t_OverLap = ( WmiRangeNode * ) t_LeftRange->Copy () ;

								if ( t_OverlappingIndex [ t_OuterIndex ] < t_OverlappingIndex [ t_InnerIndex ] )
								{
									delete t_RangeTable [ t_OuterIndex ] ;
									t_RangeTable [ t_OuterIndex ] = t_OverLap ;

									delete t_RangeTable [ t_InnerIndex ] ;
									t_RangeTable [ t_InnerIndex ] = NULL ;

									t_OverlappingIndex [ t_InnerIndex ] = t_OverlappingIndex [ t_OuterIndex ] ;
								}
								else
								{
									delete t_RangeTable [ t_OuterIndex ] ;
									t_RangeTable [ t_OuterIndex ] = NULL ;

									delete t_RangeTable [ t_InnerIndex ] ;
									t_RangeTable [ t_InnerIndex ] = t_OverLap ;

									t_OverlappingIndex [ t_OuterIndex ] = t_OverlappingIndex [ t_InnerIndex ] ;
								}
							}
							else
							{
	// Failure
								t_Status = FALSE ;
							}
						}
					}
				}
			}
		}

		ULONG t_PartitionCount = 0 ;
		for ( t_Index = 0 ; t_Index < t_DisjunctionCount ; t_Index ++ )
		{
			if ( a_DisjunctionSetToTest [ t_SortedDisjunctionSetToTest [ t_Index ] ] && t_RangeTable [ t_Index ] )
			{
				t_PartitionCount ++ ;
			}
		}

		a_Partition->CreatePartitions ( t_PartitionCount ) ;

		ULONG t_PartitionIndex = 0 ;
		for ( t_Index = 0 ; t_Index < t_DisjunctionCount ; t_Index ++ )
		{
			WmiRangeNode *t_Range = t_RangeTable [ t_Index ] ;
			if ( a_DisjunctionSetToTest [ t_SortedDisjunctionSetToTest [ t_Index ] ] && t_Range )
			{
				PartitionSet *t_Partition = new PartitionSet ;
				a_Partition->SetPartition ( t_PartitionIndex , t_Partition ) ;

				t_Partition->SetRange ( ( WmiRangeNode * ) t_Range->Copy () ) ;
				t_Partition->SetKeyIndex ( a_KeyIndex ) ;
				t_PartitionIndex ++ ;
			}
		}

		ULONG *t_DisjunctionSetToTest = new ULONG [ t_DisjunctionCount ] ;

		t_PartitionIndex = 0 ;
		for ( t_OuterIndex = 0 ; t_OuterIndex < t_DisjunctionCount ; t_OuterIndex ++ )
		{
			BOOL t_Found = FALSE ;

			for ( t_Index = 0 ; t_Index < t_DisjunctionCount ; t_Index ++ )
			{
				t_DisjunctionSetToTest [ t_Index ] = 0 ;
			}

			for ( ULONG t_InnerIndex = 0 ; t_InnerIndex < t_DisjunctionCount ; t_InnerIndex ++ )
			{
				if ( a_DisjunctionSetToTest [ t_SortedDisjunctionSetToTest [ t_InnerIndex ] ] && ( t_OverlappingIndex [ t_InnerIndex ] == t_OuterIndex ) )
				{
					t_DisjunctionSetToTest [ t_SortedDisjunctionSetToTest [ t_InnerIndex ] ] = 1 ;
					t_Found = TRUE ;
				}
			}

			if ( t_Found )
			{
				PartitionSet *t_Partition = a_Partition->GetPartition ( t_PartitionIndex ) ;
				t_Status = RecursivePartitionSet (

					a_Disjunctions ,
					t_Partition ,
					t_DisjunctionCount ,
					t_DisjunctionSetToTest ,
					a_KeyIndex + 1
				) ;

				t_PartitionIndex ++ ;
			}
		}

		delete [] t_DisjunctionSetToTest ;

		for ( t_Index = 0 ; t_Index < t_DisjunctionCount ; t_Index ++ )
		{
			delete t_RangeTable [ t_Index ] ;
		}

		delete [] t_RangeTable ;
		delete [] t_OverlappingIndex ;
		delete [] t_SortedDisjunctionSetToTest ;
	}

	return t_Status ;
}

BOOL QueryPreprocessor :: CreatePartitionSet ( Disjunctions *a_Disjunctions , PartitionSet *&a_Partition )
{
	BOOL t_Status = FALSE ;

	a_Partition = NULL ;

	ULONG t_DisjunctionCount = a_Disjunctions->GetDisjunctionCount () ;
	ULONG *t_DisjunctionSetToTest = new ULONG [ t_DisjunctionCount ] ;
	for ( ULONG t_Index = 0 ; t_Index < t_DisjunctionCount ; t_Index ++ )
	{
		t_DisjunctionSetToTest [ t_Index ] = 1 ;
	}

	a_Partition = new PartitionSet ;

	t_Status = RecursivePartitionSet (

		a_Disjunctions ,
		a_Partition ,
		t_DisjunctionCount ,
		t_DisjunctionSetToTest ,
		0
	) ;

//

	delete [] t_DisjunctionSetToTest ;
	return t_Status;
}

QueryPreprocessor :: QuadState QueryPreprocessor :: Preprocess ( 

	SQL_LEVEL_1_RPN_EXPRESSION &a_Expression ,
	PartitionSet *&a_Partition
)
{
	QuadState t_State = State_Error ;

	WmiTreeNode *t_Root = NULL ;
	BOOL t_Status = Evaluate ( a_Expression , &t_Root ) ;
	if ( t_Status )
	{
		PrintTree ( t_Root ) ;

		DisjunctiveNormalForm ( t_Root ) ;

		PrintTree ( t_Root ) ;

		switch ( t_State = RemoveInvariants ( t_Root ) )
		{
			case QueryPreprocessor :: QuadState :: State_True:
			{		
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Expression = TRUE "
	) ;
)

			}
			break ;

			case QueryPreprocessor :: QuadState :: State_False:
			{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Expression = FALSE "
	) ;
)
			}
			break ;

			case QueryPreprocessor :: QuadState :: State_Undefined:
			{
				PrintTree ( t_Root ) ;
					
				Sort ( t_Root ) ;

				PrintTree ( t_Root ) ;

				ConvertToRanges ( t_Root ) ;

				PrintTree ( t_Root ) ;

				switch ( t_State = RemoveNonOverlappingRanges ( t_Root ) )
				{
					case QueryPreprocessor :: QuadState :: State_True:
					{		
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Expression = TRUE"
	) ;
)
					}
					break ;

					case QueryPreprocessor :: QuadState :: State_False:
					{
DebugMacro3( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Expression = FALSE"
	) ;
)
					}
					break ;

					case QueryPreprocessor :: QuadState :: State_Undefined:
					{
						PrintTree ( t_Root ) ;

						Disjunctions *t_Disjunctions = NULL ;
						if ( CreateDisjunctionContainer ( t_Root , t_Disjunctions ) )
						{
							PartitionSet *t_Partition = NULL ;
							if ( CreatePartitionSet ( t_Disjunctions , t_Partition ) )
							{
								a_Partition = t_Partition ;
							}
							else
							{
								delete t_Partition ;
							}

							delete t_Disjunctions ;
						}
					}
					break ;

					case QueryPreprocessor :: QuadState :: State_ReEvaluate:
					{
					}
					break ;

					default:
					{
					}
					break ;
				}
			}
			break ;

			case QueryPreprocessor :: QuadState :: State_ReEvaluate:
			{
			}
			break ;

			default:
			{
			}
			break ;
		}
	}
	else
	{
	}

	delete t_Root ;

	return t_State ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provider\fram.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#include <windows.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include "classfac.h"
#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "framcomm.h"
#include "framprov.h"
#include "fram.h"
#include "guids.h"

#if _MSC_VER >= 1100
template <> UINT AFXAPI HashKey <wchar_t *> ( wchar_t *key )
#else
UINT HashKey ( wchar_t *key )
#endif
{
	UCHAR *value = ( UCHAR * ) key ;
	ULONG length = wcslen ( key ) * sizeof ( wchar_t ) ;

    UINT hash;
    if (length > 1)
    {
        USHORT even = 0;
        USHORT odd = 0;

        for (ULONG i = length >> 1; i--;)
        {
            even += towlower (*value++) ;
            odd += towlower (*value++) ;
        }
        if (length & 1)
        {
            even += tolower (*value);
        }
        hash = odd>>8;
        hash |= (odd & 0xff) << 8;
        hash ^= even;
    }
    else
    {
        hash = *value;
    }

	return hash ;
}

#if _MSC_VER >= 1100
typedef wchar_t * WbemHack_wchar_t ;
template<> BOOL AFXAPI CompareElements <wchar_t *, wchar_t * > ( const WbemHack_wchar_t *pElement1, const WbemHack_wchar_t *pElement2 )
#else
BOOL CompareElements ( wchar_t **pElement1, wchar_t **pElement2 )
#endif
{
	return _wcsicmp ( *pElement1 , *pElement2 ) == 0 ;
}

CBString::CBString(int nSize)
{
    m_pString = SysAllocStringLen(NULL, nSize);
}

CBString::CBString(WCHAR* pwszString)
{
    m_pString = SysAllocString(pwszString);
}

CBString::~CBString()
{
    if(m_pString) 
	{
        SysFreeString(m_pString);
        m_pString = NULL;
    }
}


DllImportExport wchar_t *DbcsToUnicodeString ( const char *dbcsString )
{
	size_t textLength = mbstowcs ( NULL , dbcsString , 0  ) ;
	wchar_t *unicodeString = new wchar_t [ textLength + 1 ] ;
	textLength = mbstowcs ( unicodeString , dbcsString , textLength + 1 ) ;
	if ( textLength == -1 )
	{
		delete [] unicodeString ;
		unicodeString = NULL ;
	}

	return unicodeString ;
}

DllImportExport char *UnicodeToDbcsString ( const wchar_t *unicodeString )
{
	size_t textLength = wcstombs ( NULL , unicodeString , 0 ) ;
	char *dbcsString = new char [ textLength + 1 ] ;
	textLength = wcstombs ( dbcsString , unicodeString , textLength + 1 ) ;
	if ( textLength == -1 )
	{
		delete [] dbcsString ;
		dbcsString = NULL ;
	}

	return dbcsString ;
}

DllImportExport wchar_t *UnicodeStringDuplicate ( const wchar_t *string ) 
{
	if ( string )
	{
		int textLength = wcstombs ( NULL , string , 0 ) ;

		wchar_t *textBuffer = new wchar_t [ textLength + 1 ] ;
		wcscpy ( textBuffer , string ) ;

		return textBuffer ;
	}
	else
	{
		return NULL ;
	}
}

DllImportExport wchar_t *UnicodeStringAppend ( const wchar_t *prefix , const wchar_t *suffix )
{
	int prefixTextLength = 0 ;
	if ( prefix )
	{
		prefixTextLength = wcstombs ( NULL , prefix , 0 ) ;
	}

	int suffixTextLength = 0 ;
	if ( suffix )
	{
		suffixTextLength = wcstombs ( NULL , suffix , 0 ) ;
	}

	if ( prefix || suffix )
	{
		int textLength = prefixTextLength + suffixTextLength ;
		wchar_t *textBuffer = new wchar_t [ textLength + 1 ] ;

		if ( prefix )
		{
			wcscpy ( textBuffer , prefix ) ;
		}

		if ( suffix )
		{
			wcscpy ( & textBuffer [ prefixTextLength ] , suffix ) ;
		}

		return textBuffer ;
	}	
	else
		return NULL ;
}

ProviderLexicon :: ProviderLexicon () : position ( 0 ) , tokenStream ( NULL ) , token ( INVALID_ID )
{
	value.token = NULL ;
}

ProviderLexicon :: ~ProviderLexicon ()
{
	switch ( token ) 
	{
		case TOKEN_ID:
		{
			delete [] value.token ;
		}
		break ;
	
		default:
		{
		} ;
	}
}

void ProviderLexicon :: SetToken ( ProviderLexicon :: LexiconToken a_Token )
{
	token = a_Token ;
}

ProviderLexicon :: LexiconToken ProviderLexicon :: GetToken ()
{
	return token ;
}

ProviderLexiconValue *ProviderLexicon :: GetValue ()
{
	return &value ;
}

ProviderAnalyser :: ProviderAnalyser ( const wchar_t *tokenStream ) : status ( TRUE ) , position ( 0 ) , stream ( NULL ) 
{
	if ( tokenStream )
	{
		stream = new wchar_t [ wcslen ( tokenStream ) + 1 ] ;
		wcscpy ( stream , tokenStream ) ;
	}
}

ProviderAnalyser :: ~ProviderAnalyser () 
{
	delete [] stream ;
}

void ProviderAnalyser :: Set ( const wchar_t *tokenStream ) 
{
	status = 0 ;
	position = NULL ;

	delete [] stream ;
	stream = new wchar_t [ wcslen ( tokenStream ) + 1 ] ;
	wcscpy ( stream , tokenStream ) ;
}

void ProviderAnalyser :: PutBack ( const ProviderLexicon *token ) 
{
	position = token->position ;
}

ProviderAnalyser :: operator void * () 
{
	return status ? this : NULL ;
}

ProviderLexicon *ProviderAnalyser :: Get ( BOOL unSignedIntegersOnly , BOOL leadingIntegerZeros , BOOL eatSpace ) 
{
	ProviderLexicon *lexicon = NULL ;

	if ( stream )
	{
		lexicon = GetToken ( unSignedIntegersOnly , leadingIntegerZeros , eatSpace ) ;
	}
	else
	{
		lexicon = CreateLexicon () ;
		lexicon->position = position ;
		lexicon->token = ProviderLexicon :: EOF_ID ;
	}

	return lexicon ;
}

#define DEC_INTEGER_START 1000
#define HEX_INTEGER_START 2000
#define OCT_INTEGER_START 3000
#define TOKEN_START 5000
#define WHITESPACE_START 6000
#define ACCEPT_STATE ANALYSER_ACCEPT_STATE
#define REJECT_STATE ANALYSER_REJECT_STATE 

ProviderLexicon *ProviderAnalyser :: GetToken ( BOOL unSignedIntegersOnly , BOOL leadingIntegerZeros , BOOL eatSpace )  
{
	ProviderLexicon *lexicon = CreateLexicon () ;
	lexicon->position = position ;

	Initialise () ;

	ULONG state = 0 ;

/* 
 * Integer Definitions
 */

	BOOL negative = FALSE ;
	BOOL positive = FALSE ;

	ULONG positiveMagicMult = ( LONG ) ( ( ( ULONG ) -1 ) / 10L ) ; 
	ULONG positiveMagicPosDigit = 5 ;
	ULONG positiveDatum = 0 ;	

	LONG negativeMagicMult = ( LONG ) ( ( ( ULONG ) ( 1L << 31L ) ) / 10L ) ; 
	ULONG negativeMagicNegDigit = 8 ;
	ULONG negativeMagicPosDigit = 7 ;
	LONG negativeDatum = 0 ;	

/*
 * Token Definitions
 */

	ULONG token_start = 0 ;

	while ( state != REJECT_STATE && state != ACCEPT_STATE )
	{
		wchar_t token = stream [ position ] ;
		if ( Analyse ( lexicon , state , token , stream , position , unSignedIntegersOnly , leadingIntegerZeros , eatSpace ) )
		{
		}
		else
		{
			switch ( state )
			{
				case 0:
				{
					if ( IsAlpha ( token ) )
					{
						state = TOKEN_START ;
						token_start = position ;
					}
					else if ( ProviderAnalyser :: IsLeadingDecimal ( token ) )
					{
						state = DEC_INTEGER_START + 1  ;
						negativeDatum = ( token - 48 ) ;
					}
					else if ( token == L'+' )
					{
						if ( unSignedIntegersOnly ) 
						{
							state = ACCEPT_STATE ;
							lexicon->token = ProviderLexicon :: PLUS_ID ;
						}
						else
						{
							state = DEC_INTEGER_START ;
						}
					}
					else if ( token == L'-' ) 
					{
						if ( unSignedIntegersOnly )
						{
							state = ACCEPT_STATE ;
							lexicon->token = ProviderLexicon :: MINUS_ID ;
						}
						else
						{
							negative = TRUE ;
							state = DEC_INTEGER_START ;
						}
					}
					else if ( token == L'0' )
					{
						if ( ! leadingIntegerZeros ) 
						{
							state = 1 ;
						}
						else
						{
							negativeDatum = 0 ;
							state = DEC_INTEGER_START + 1 ;
						}
					}
					else if ( ProviderAnalyser :: IsWhitespace ( token ) ) 
					{
						if ( eatSpace )
						{
							state = 0 ;
						}
						else
						{
							lexicon->token = ProviderLexicon :: WHITESPACE_ID ;
							state = WHITESPACE_START ;
						}
					}
					else if ( token == L'(' )
					{
						lexicon->token = ProviderLexicon :: OPEN_PAREN_ID ;
						state = ACCEPT_STATE ;
					}
					else if ( token == L')' )
					{
						lexicon->token = ProviderLexicon :: CLOSE_PAREN_ID ;
						state = ACCEPT_STATE ;
					}
					else if ( token == L',' )
					{
						lexicon->token = ProviderLexicon :: COMMA_ID ;
						state = ACCEPT_STATE ;
					}
					else if ( token == L':' )
					{
						lexicon->token = ProviderLexicon :: COLON_ID ;
						state = ACCEPT_STATE ;
					}
					else if ( token == L'.' )
					{
						state = 2;
					}
					else if ( IsEof ( token ) )
					{
						lexicon->token = ProviderLexicon :: EOF_ID ;
						state = ACCEPT_STATE ;
					}
					else state = REJECT_STATE ;
				}
				break ;

				case 1:
				{
					if ( token == L'x' || token == L'X' )
					{
						state = HEX_INTEGER_START ;				
					}
					else if ( ProviderAnalyser :: IsOctal ( token ) )
					{
						state = OCT_INTEGER_START ;
						positiveDatum = ( token - 48 ) ;
					}
					else
					{
						if ( unSignedIntegersOnly )
						{
							lexicon->token = ProviderLexicon :: UNSIGNED_INTEGER_ID ;
							lexicon->value.unsignedInteger = 0 ;
						}
						else
						{
							lexicon->token = ProviderLexicon :: SIGNED_INTEGER_ID ;
							lexicon->value.signedInteger = 0 ;
						}

						state = ACCEPT_STATE ;
						position -- ;
					}
				}
				break ;

				case 2:
				{
					if ( token == L'.' )
					{
						lexicon->token = ProviderLexicon :: DOTDOT_ID ;
						state = ACCEPT_STATE ;
					}
					else
					{
						lexicon->token = ProviderLexicon :: DOT_ID ;
						position -- ;
						state = ACCEPT_STATE  ;
					}
				}
				break ;

				case TOKEN_START:
				{
					if ( IsAlphaNumeric ( token ) ) 
					{
						state = TOKEN_START ;
					}
					else 
					{
						state = ACCEPT_STATE ;
						lexicon->token = ProviderLexicon :: TOKEN_ID ;
						lexicon->value.token = new wchar_t [ position - token_start + 1 ] ;
						wcsncpy ( 

							lexicon->value.token , 
							& stream [ token_start ] , 
							position - token_start 
						) ;

						lexicon->value.token [ position - token_start ] = 0 ;

						position -- ;
					}
				}
				break ;

				case WHITESPACE_START:
				{
					if ( ProviderAnalyser :: IsWhitespace ( token ) ) 
					{
						state = WHITESPACE_START ;
					}
					else
					{
						state = ACCEPT_STATE ;
						position -- ;
					}
				}
				break;

				case HEX_INTEGER_START:
				{
					if ( ProviderAnalyser :: IsHex ( token ) )
					{
						positiveDatum = ProviderAnalyser :: HexWCharToDecInteger ( token ) ;
						state = HEX_INTEGER_START + 1 ;
					}
					else
					{
						state = REJECT_STATE ;
					}
				}
				break ;

				case HEX_INTEGER_START+1:
				{
					if ( ProviderAnalyser :: IsHex ( token ) )
					{
						state = HEX_INTEGER_START + 1 ;

						if ( positiveDatum > positiveMagicMult )
						{
							state = REJECT_STATE ;
						}
						else if ( positiveDatum == positiveMagicMult ) 
						{
							if ( ProviderAnalyser :: HexWCharToDecInteger ( token ) > positiveMagicPosDigit ) 
							{
								state = REJECT_STATE ;
							}
						}

						positiveDatum = ( positiveDatum << 4 ) + ProviderAnalyser :: HexWCharToDecInteger ( token ) ;
					}
					else
					{
						lexicon->token = ProviderLexicon :: UNSIGNED_INTEGER_ID ;
						lexicon->value.unsignedInteger = positiveDatum ;
						state = ACCEPT_STATE ;

						position -- ;
					}
				}
				break ;

				case OCT_INTEGER_START:
				{
					if ( ProviderAnalyser :: IsOctal ( token ) )
					{
						state = OCT_INTEGER_START ;

						if ( positiveDatum > positiveMagicMult )
						{
							state = REJECT_STATE ;
						}
						else if ( positiveDatum == positiveMagicMult ) 
						{
							if ( ProviderAnalyser :: OctWCharToDecInteger ( token ) > positiveMagicPosDigit ) 
							{
								state = REJECT_STATE ;
							}
						}

						positiveDatum = ( positiveDatum << 3 ) + ProviderAnalyser :: OctWCharToDecInteger ( token ) ;
					}
					else
					{
						lexicon->token = ProviderLexicon :: UNSIGNED_INTEGER_ID ;
						lexicon->value.unsignedInteger = positiveDatum ;
						state = ACCEPT_STATE ;

						position -- ;
					}
				}
				break ;

				case DEC_INTEGER_START:
				{
					if ( ProviderAnalyser :: IsDecimal ( token ) )
					{
						negativeDatum = ( token - 48 ) ;
						state = DEC_INTEGER_START + 1 ;
					}
					else 
					if ( ProviderAnalyser :: IsWhitespace ( token ) ) 
					{
						state = DEC_INTEGER_START ;
					}
					else state = REJECT_STATE ;
				}	
				break ;

				case DEC_INTEGER_START+1:
				{
					if ( ProviderAnalyser :: IsDecimal ( token ) )
					{	
						state = DEC_INTEGER_START + 1 ;

						if ( positive )
						{
							if ( positiveDatum > positiveMagicMult )
							{
								state = REJECT_STATE ;
							}
							else if ( positiveDatum == positiveMagicMult ) 
							{
								if ( ( ULONG ) ( token - 48 ) > positiveMagicPosDigit ) 
								{
									state = REJECT_STATE ;
								}
							}
						}
						else
						{
							if ( negativeDatum > negativeMagicMult )
							{
								state = REJECT_STATE ;
							}
							else if ( negativeDatum == negativeMagicMult ) 
							{
								if ( negative ) 
								{
									if ( ( ULONG ) ( token - 48 ) > negativeMagicNegDigit ) 
									{
										state = REJECT_STATE ;
									}
								}
								else
								{
									if ( ( ULONG ) ( token - 48 ) > negativeMagicPosDigit ) 
									{
										positiveDatum = negativeDatum ;
										positive = TRUE ;
									}
								}
							}
						}

						if ( positive )
						{
							positiveDatum = positiveDatum * 10 + ( token - 48 ) ;
						}
						else
						{
							negativeDatum = negativeDatum * 10 + ( token - 48 ) ;
						}
					}
					else
					{
						if ( negative )
						{
							if ( ! unSignedIntegersOnly )
							{
								lexicon->token = ProviderLexicon :: SIGNED_INTEGER_ID ;
								lexicon->value.signedInteger = negativeDatum * -1 ;
							}
							else
							{
								state = REJECT_STATE ;
							}
						}
						else if ( positive )
						{
							lexicon->token = ProviderLexicon :: UNSIGNED_INTEGER_ID ;
							lexicon->value.unsignedInteger = positiveDatum ;
						}
						else
						{
							if ( unSignedIntegersOnly )
							{
								lexicon->token = ProviderLexicon :: UNSIGNED_INTEGER_ID ;
								lexicon->value.signedInteger = negativeDatum ;
							}
							else
							{
								lexicon->token = ProviderLexicon :: SIGNED_INTEGER_ID ;
								lexicon->value.signedInteger = negativeDatum ;
							}
						}

						state = ACCEPT_STATE ;

						position -- ;
					}
				}	
				break ;

				case ACCEPT_STATE:
				case REJECT_STATE:
				default:
				{
					state = REJECT_STATE ;
				} ;
				break ;
			}
		}

		position ++ ;
	}

	status = ( state != REJECT_STATE ) ;

	return lexicon ;
}

BOOL ProviderAnalyser :: IsLeadingDecimal ( wchar_t token )
{
	return iswdigit ( token ) && ( token != L'0' ) ;
}

BOOL ProviderAnalyser :: IsDecimal ( wchar_t token )
{
	return iswdigit ( token ) ;
}

BOOL ProviderAnalyser :: IsHex ( wchar_t token )
{
	return iswxdigit ( token ) ;
}
	
BOOL ProviderAnalyser :: IsWhitespace ( wchar_t token )
{
	return iswspace ( token ) ;
}

BOOL ProviderAnalyser :: IsOctal ( wchar_t token )
{
	return ( token >= L'0' && token <= L'7' ) ;
}

BOOL ProviderAnalyser :: IsAlpha ( wchar_t token )
{
	return iswalpha ( token ) ;
}

BOOL ProviderAnalyser :: IsAlphaNumeric ( wchar_t token )
{
	return iswalnum ( token ) || ( token == L'_' ) || ( token == L'-' ) ;
}

BOOL ProviderAnalyser :: IsEof ( wchar_t token )
{
	return token == 0 ;
}

ULONG ProviderAnalyser :: OctWCharToDecInteger ( wchar_t token ) 
{
	return token - L'0' ;
}

ULONG ProviderAnalyser :: HexWCharToDecInteger ( wchar_t token ) 
{
	if ( token >= L'0' && token <= L'9' )
	{
		return token - L'0' ;
	}
	else if ( token >= L'a' && token <= L'f' )
	{
		return token - L'a' + 10 ;
	}
	else if ( token >= L'A' && token <= L'F' )
	{
		return token - L'A' + 10 ;
	}
	else
	{
		return 0 ;
	}
}

ULONG ProviderAnalyser :: DecWCharToDecInteger ( wchar_t token ) 
{
	if ( token >= L'0' && token <= L'9' )
	{
		return token - L'0' ;
	}
	else
	{
		return 0 ;
	}
}

wchar_t ProviderAnalyser :: DecIntegerToOctWChar ( UCHAR integer )
{
	if ( integer >= 0 && integer <= 7 )
	{
		return L'0' + integer ;
	}
	else
	{
		return L'0' ;
	}
}

wchar_t ProviderAnalyser :: DecIntegerToDecWChar ( UCHAR integer )
{
	if ( integer >= 0 && integer <= 9 )
	{
		return L'0' + integer ;
	}
	else
	{
		return L'0' ;
	}
}

wchar_t ProviderAnalyser :: DecIntegerToHexWChar ( UCHAR integer )
{
	if ( integer >= 0 && integer <= 9 )
	{
		return L'0' + integer ;
	}
	else if ( integer >= 10 && integer <= 15 )
	{
		return L'a' + ( integer - 10 ) ;
	}
	else
	{
		return L'0' ;
	}
}

ULONG ProviderAnalyser :: OctCharToDecInteger ( char token ) 
{
	return token - '0' ;
}

ULONG ProviderAnalyser :: HexCharToDecInteger ( char token ) 
{
	if ( token >= '0' && token <= '9' )
	{
		return token - '0' ;
	}
	else if ( token >= 'a' && token <= 'f' )
	{
		return token - 'a' + 10 ;
	}
	else if ( token >= 'A' && token <= 'F' )
	{
		return token - 'A' + 10 ;
	}
	else
	{
		return 0 ;
	}
}

ULONG ProviderAnalyser :: DecCharToDecInteger ( char token ) 
{
	if ( token >= '0' && token <= '9' )
	{
		return token - '0' ;
	}
	else
	{
		return 0 ;
	}
}

char ProviderAnalyser :: DecIntegerToOctChar ( UCHAR integer )
{
	if ( integer >= 0 && integer <= 7 )
	{
		return '0' + integer ;
	}
	else
	{
		return '0' ;
	}
}

char ProviderAnalyser :: DecIntegerToDecChar ( UCHAR integer )
{
	if ( integer >= 0 && integer <= 9 )
	{
		return '0' + integer ;
	}
	else
	{
		return '0' ;
	}
}

char ProviderAnalyser :: DecIntegerToHexChar ( UCHAR integer )
{
	if ( integer >= 0 && integer <= 9 )
	{
		return '0' + integer ;
	}
	else if ( integer >= 10 && integer <= 15 )
	{
		return 'a' + ( integer - 10 ) ;
	}
	else
	{
		return '0' ;
	}
}

WbemTaskObject :: WbemTaskObject (

	CImpFrameworkProv *a_Provider ,
	IWbemObjectSink *a_NotificationHandler ,
	ULONG a_OperationFlag ,
	IWbemContext *a_Ctx

) :	m_State ( WBEM_TASKSTATE_START ) ,
	m_OperationFlag ( a_OperationFlag ) ,
	m_Provider ( a_Provider ) ,
	m_NotificationHandler ( a_NotificationHandler ) ,
	m_Ctx ( a_Ctx ) ,
	m_RequestHandle ( 0 ) ,
	m_ClassObject ( NULL ) ,
	m_ReferenceCount ( 1 )
{
	m_Provider->AddRef () ;
	m_NotificationHandler->AddRef () ;
	if ( m_Ctx ) 
	{
		m_Ctx->AddRef () ;
	}
}

WbemTaskObject :: ~WbemTaskObject ()
{
	m_Provider->Release () ;
	m_NotificationHandler->Release () ;
	if ( m_Ctx )
		m_Ctx->Release () ;

	if ( m_ClassObject )
		m_ClassObject->Release () ;
}

ULONG WbemTaskObject::AddRef(void)
{
    return InterlockedIncrement ( & m_ReferenceCount ) ;
}

ULONG WbemTaskObject::Release(void)
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

WbemProviderErrorObject &WbemTaskObject :: GetErrorObject ()
{
	return m_ErrorObject ; 
}	

BOOL WbemTaskObject :: GetClassObject ( wchar_t *a_Class )
{
	IWbemCallResult *t_ErrorObject = NULL ;

	IWbemServices *t_Server = m_Provider->GetServer() ;

	HRESULT t_Result = t_Server->GetObject (

		a_Class ,
		0 ,
		m_Ctx,
		& m_ClassObject ,
		& t_ErrorObject 
	) ;

	t_Server->Release () ;

	if ( t_ErrorObject )
		t_ErrorObject->Release () ;

	return SUCCEEDED ( t_Result ) ;
}


BOOL WbemTaskObject :: GetExtendedNotifyStatusObject ( IWbemClassObject **a_NotifyObject ) 
{
	IWbemClassObject *t_NotificationClassObject = NULL ;
	IWbemClassObject *t_ErrorObject = NULL ;

	BOOL t_Status = TRUE ;

	WbemProviderErrorObject t_ErrorStatusObject ;
	if ( t_NotificationClassObject = m_Provider->GetExtendedNotificationObject ( t_ErrorStatusObject , m_Ctx ) )
	{
		HRESULT t_Result = t_NotificationClassObject->SpawnInstance ( 0 , a_NotifyObject ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			VARIANT t_Variant ;
			VariantInit ( &t_Variant ) ;

			t_Variant.vt = VT_I4 ;
			t_Variant.lVal = m_ErrorObject.GetWbemStatus () ;

			t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_STATUSCODE , 0 , & t_Variant , 0 ) ;
			VariantClear ( &t_Variant ) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Variant.vt = VT_I4 ;
				t_Variant.lVal = m_ErrorObject.GetStatus () ;

				t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_PROVIDERSTATUSCODE , 0 , & t_Variant , 0 ) ;
				VariantClear ( &t_Variant ) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					if ( m_ErrorObject.GetMessage () ) 
					{
						t_Variant.vt = VT_BSTR ;
						t_Variant.bstrVal = SysAllocString ( m_ErrorObject.GetMessage () ) ;

						t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_PROVIDERSTATUSMESSAGE , 0 , & t_Variant , 0 ) ;
						VariantClear ( &t_Variant ) ;

						if ( ! SUCCEEDED ( t_Result ) )
						{
							(*a_NotifyObject)->Release () ;
							t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
						}
					}
				}
				else
				{
					(*a_NotifyObject)->Release () ;
					t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
				}
			}
			else
			{
				(*a_NotifyObject)->Release () ;
				t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
			}

			t_NotificationClassObject->Release () ;
		}
		else
		{
			t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
		}
	}
	else
	{
		t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
	}

	return t_Status ;
}

BOOL WbemTaskObject :: GetNotifyStatusObject ( IWbemClassObject **a_NotifyObject ) 
{
	IWbemClassObject *t_NotificationClassObject = NULL ;

	BOOL t_Status = TRUE ;

	WbemProviderErrorObject t_ErrorStatusObject ;
	if ( t_NotificationClassObject = m_Provider->GetNotificationObject ( t_ErrorStatusObject , m_Ctx ) )
	{
		HRESULT t_Result = t_NotificationClassObject->SpawnInstance ( 0 , a_NotifyObject ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			VARIANT t_Variant ;
			VariantInit ( &t_Variant ) ;

			t_Variant.vt = VT_I4 ;
			t_Variant.lVal = m_ErrorObject.GetWbemStatus () ;

			t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_STATUSCODE , 0 , & t_Variant , 0 ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				if ( m_ErrorObject.GetMessage () ) 
				{
					t_Variant.vt = VT_BSTR ;
					t_Variant.bstrVal = SysAllocString ( m_ErrorObject.GetMessage () ) ;

					t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_PROVIDERSTATUSMESSAGE , 0 , & t_Variant , 0 ) ;
					VariantClear ( &t_Variant ) ;

					if ( ! SUCCEEDED ( t_Result ) )
					{
						t_Status = FALSE ;
						(*a_NotifyObject)->Release () ;
						(*a_NotifyObject)=NULL ;
					}
				}
			}
			else
			{
				(*a_NotifyObject)->Release () ;
				(*a_NotifyObject)=NULL ;
				t_Status = FALSE ;
			}

			VariantClear ( &t_Variant ) ;

			t_NotificationClassObject->Release () ;
		}
		else
		{
			t_Status = FALSE ;
		}
	}
	else
	{
		t_Status = FALSE ;
	}

	return t_Status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provider\framdecl.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the ProvGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include "classfac.h"
#include "guids.h"
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "framcomm.h"
#include "framprov.h"
#include "fram.h"

BOOL DeleteClassEventObject :: DeleteClass ( WbemProviderErrorObject &a_ErrorObject )
{
	BOOL t_Status = GetClassObject ( m_Class ) ;
	if ( t_Status )
	{
		ProcessComplete () ;
	}
	else
	{
		t_Status = FALSE ;
		a_ErrorObject.SetStatus ( WBEM_PROVIDER_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Unknown Class" ) ;
	}

	return t_Status ;
}

DeleteClassEventObject :: DeleteClassEventObject (

	CImpFrameworkProv *a_Provider , 
	BSTR a_Class ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : WbemTaskObject ( a_Provider , a_NotificationHandler , a_OperationFlag , a_Ctx )
{
	m_Class = UnicodeStringDuplicate ( a_Class ) ;
}

DeleteClassEventObject :: ~DeleteClassEventObject () 
{
// Get Status object

	delete [] m_Class ;

	if ( FAILED ( m_ErrorObject.GetWbemStatus () ) )
	{
		IWbemClassObject *t_NotifyStatus = NULL ;
		BOOL t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
		if ( t_Status )
		{
			HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , NULL , t_NotifyStatus ) ;
			t_NotifyStatus->Release () ;
		}
	}
	else
	{
		HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , NULL , NULL ) ;
	}
}

void DeleteClassEventObject :: ProcessComplete () 
{
}

void DeleteClassEventObject :: Process () 
{
	switch ( m_State )
	{
		case 0:
		{
			Complete () ;
			WaitAcknowledgement () ;
			BOOL t_Status = DeleteClass ( m_ErrorObject ) ;
			if ( t_Status )
			{
			}
			else
			{
				ProcessComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}
}


DeleteClassAsyncEventObject :: DeleteClassAsyncEventObject (

	CImpFrameworkProv *a_Provider , 
	BSTR a_Class ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : DeleteClassEventObject ( a_Provider , a_Class , a_OperationFlag , a_NotificationHandler , a_Ctx )
{
}

DeleteClassAsyncEventObject :: ~DeleteClassAsyncEventObject () 
{
}

void DeleteClassAsyncEventObject :: ProcessComplete () 
{
	DeleteClassEventObject :: ProcessComplete () ;

/*
 *	Remove worker object from worker thread container
 */

	CImpFrameworkProv:: s_DefaultThreadObject->ReapTask ( *this ) ;

	Release () ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provider\framclas.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the ProvGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include "classfac.h"
#include "guids.h"
#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "framcomm.h"
#include "framprov.h"
#include "fram.h"

BOOL CreateClassEnumEventObject :: CreateClassEnum ( WbemProviderErrorObject &a_ErrorObject )
{
	BOOL t_Status = GetClassObject ( m_SuperClass ) ;
	if ( t_Status )
	{
		ProcessComplete () ;
	}
	else
	{
		t_Status = FALSE ;
		a_ErrorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Unknown Class" ) ;
	}

	return t_Status ;
}

CreateClassEnumEventObject :: CreateClassEnumEventObject (

	CImpFrameworkProv *a_Provider , 
	BSTR a_SuperClass ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : WbemTaskObject ( a_Provider , a_NotificationHandler , a_OperationFlag , a_Ctx )
{
	m_SuperClass = UnicodeStringDuplicate ( a_SuperClass ) ;
}

CreateClassEnumEventObject :: ~CreateClassEnumEventObject () 
{
// Get Status object

	delete [] m_SuperClass ;

	if ( FAILED ( m_ErrorObject.GetWbemStatus () ) )
	{
		IWbemClassObject *t_NotifyStatus = NULL ;
		BOOL t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
		if ( t_Status )
		{
			HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , NULL , t_NotifyStatus ) ;
			t_NotifyStatus->Release () ;
		}
	}
	else
	{
		HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , NULL , NULL ) ;
	}
}

void CreateClassEnumEventObject :: ProcessComplete () 
{
}

void CreateClassEnumEventObject :: Process () 
{
	switch ( m_State )
	{
		case 0:
		{
			Complete () ;
			WaitAcknowledgement () ;
			BOOL t_Status = CreateClassEnum ( m_ErrorObject ) ;
			if ( t_Status )
			{
			}
			else
			{
				ProcessComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}
}


CreateClassEnumAsyncEventObject :: CreateClassEnumAsyncEventObject (

	CImpFrameworkProv *a_Provider , 
	BSTR a_SuperClass ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : CreateClassEnumEventObject ( a_Provider , a_SuperClass , a_OperationFlag , a_NotificationHandler , a_Ctx )
{
}

CreateClassEnumAsyncEventObject :: ~CreateClassEnumAsyncEventObject () 
{
}

void CreateClassEnumAsyncEventObject :: ProcessComplete () 
{
	CreateClassEnumEventObject :: ProcessComplete () ;

	CImpFrameworkProv:: s_DefaultThreadObject->ReapTask ( *this ) ;

	Release () ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provider\framdel.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS  Property Provider

//

//  Purpose: Implementation for the GetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include "classfac.h"
#include "guids.h"
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "framcomm.h"
#include "framprov.h"
#include "fram.h"

BOOL DeleteInstanceEventObject :: DeleteInstance ( WbemProviderErrorObject &a_ErrorObject )
{
	BOOL t_Status;
	int iParseResult = m_ObjectPathParser.Parse ( m_ObjectPath , &m_ParsedObjectPath ) ;
    
	if ( CObjectPathParser::NoError == iParseResult )
	{
		t_Status = TRUE;
        ProcessComplete () ;
	}
	else
	{
		t_Status = FALSE ;
		a_ErrorObject.SetStatus ( WBEM_PROVIDER_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Unknown Class" ) ;
	}

	return t_Status ;
}

DeleteInstanceEventObject :: DeleteInstanceEventObject (

	CImpFrameworkProv *a_Provider , 
	BSTR a_ObjectPath ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : WbemTaskObject ( a_Provider , a_NotificationHandler , a_OperationFlag , a_Ctx ) ,
	m_Class ( NULL ) 
{
	m_ObjectPath = UnicodeStringDuplicate ( a_ObjectPath ) ;
}

DeleteInstanceEventObject :: ~DeleteInstanceEventObject () 
{
// Get Status object

	delete [] m_ObjectPath ;

	if ( FAILED ( m_ErrorObject.GetWbemStatus () ) )
	{
		IWbemClassObject *t_NotifyStatus = NULL ;
		BOOL t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
		if ( t_Status )
		{
			HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , NULL , t_NotifyStatus ) ;
			t_NotifyStatus->Release () ;
		}
	}
	else
	{
		HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , NULL , NULL ) ;
	}
}

void DeleteInstanceEventObject :: ProcessComplete () 
{
}

void DeleteInstanceEventObject :: Process () 
{
	switch ( m_State )
	{
		case 0:
		{
			Complete () ;
			WaitAcknowledgement () ;
			BOOL t_Status = DeleteInstance ( m_ErrorObject ) ;
			if ( t_Status )
			{
			}
			else
			{
				ProcessComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}
}

DeleteInstanceAsyncEventObject :: DeleteInstanceAsyncEventObject (

	CImpFrameworkProv *a_Provider , 
	BSTR a_ObjectPath ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : DeleteInstanceEventObject ( a_Provider , a_ObjectPath , a_OperationFlag , a_NotificationHandler , a_Ctx )
{
}

DeleteInstanceAsyncEventObject :: ~DeleteInstanceAsyncEventObject () 
{
}

void DeleteInstanceAsyncEventObject :: ProcessComplete () 
{
	DeleteInstanceEventObject :: ProcessComplete () ;

/*
 *	Remove worker object from worker thread container
 */

	CImpFrameworkProv:: s_DefaultThreadObject->ReapTask ( *this ) ;


	Release () ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provider\framinst.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the ProvGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include "classfac.h"
#include "guids.h"
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "framcomm.h"
#include "framprov.h"
#include "fram.h"

BOOL CreateInstanceEnumEventObject :: CreateInstanceEnum ( WbemProviderErrorObject &a_ErrorObject )
{
	BOOL t_Status = GetClassObject ( m_Class ) ;
	if ( t_Status )
	{
		ProcessComplete () ;
	}
	else
	{
		t_Status = FALSE ;
		a_ErrorObject.SetStatus ( WBEM_PROVIDER_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Unknown Class" ) ;
	}

	return t_Status ;
}

CreateInstanceEnumEventObject :: CreateInstanceEnumEventObject (

	CImpFrameworkProv *a_Provider , 
	BSTR a_Class ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : WbemTaskObject ( a_Provider , a_NotificationHandler , a_OperationFlag , a_Ctx )
{
	m_Class = UnicodeStringDuplicate ( a_Class ) ;
}

CreateInstanceEnumEventObject :: ~CreateInstanceEnumEventObject () 
{
// Get Status object

	delete [] m_Class ;

	if ( FAILED ( m_ErrorObject.GetWbemStatus () ) )
	{
		IWbemClassObject *t_NotifyStatus = NULL ;
		BOOL t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
		if ( t_Status )
		{
			HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , m_ErrorObject.GetMessage () , t_NotifyStatus ) ;
			t_NotifyStatus->Release () ;
		}
	}
	else
	{
		HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , NULL , NULL ) ;
	}
}

void CreateInstanceEnumEventObject :: ProcessComplete () 
{
}

void CreateInstanceEnumEventObject :: Process () 
{
	switch ( m_State )
	{
		case 0:
		{
			Complete () ;
			WaitAcknowledgement () ;
			BOOL t_Status = CreateInstanceEnum ( m_ErrorObject ) ;
			if ( t_Status )
			{
			}
			else
			{
				ProcessComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}
}

CreateInstanceEnumAsyncEventObject :: CreateInstanceEnumAsyncEventObject (

	CImpFrameworkProv *a_Provider , 
	BSTR a_Class ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : CreateInstanceEnumEventObject ( a_Provider , a_Class , a_OperationFlag , a_NotificationHandler , a_Ctx )
{
}

CreateInstanceEnumAsyncEventObject :: ~CreateInstanceEnumAsyncEventObject () 
{
}

void CreateInstanceEnumAsyncEventObject :: ProcessComplete () 
{
	CreateInstanceEnumEventObject :: ProcessComplete () ;

/*
 *	Remove worker object from worker thread container
 */

	CImpFrameworkProv:: s_DefaultThreadObject->ReapTask ( *this ) ;

	Release () ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provider\framget.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS  Property Provider

//

//  Purpose: Implementation for the GetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include "classfac.h"
#include "guids.h"
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "framcomm.h"
#include "framprov.h"
#include "fram.h"

BOOL GetObjectEventObject :: GetObject ( WbemProviderErrorObject &a_ErrorObject )
{
	
	BOOL t_Status;
    int iParseResult = m_ObjectPathParser.Parse ( m_ObjectPath , &m_ParsedObjectPath ) ;
	if ( CObjectPathParser::NoError == iParseResult )
	{
		t_Status = TRUE;
        ProcessComplete () ;
	}
	else
	{
		t_Status = FALSE ;
		a_ErrorObject.SetStatus ( WBEM_PROVIDER_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Unknown Class" ) ;
	}

	return t_Status ;
}

GetObjectEventObject :: GetObjectEventObject (

	CImpFrameworkProv *a_Provider , 
	BSTR a_ObjectPath ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : WbemTaskObject ( a_Provider , a_NotificationHandler , a_OperationFlag , a_Ctx ) ,
	m_Class ( NULL ) 
{
	m_ObjectPath = UnicodeStringDuplicate ( a_ObjectPath ) ;
}

GetObjectEventObject :: ~GetObjectEventObject () 
{
// Get Status object

	delete [] m_ObjectPath ;


	if ( FAILED ( m_ErrorObject.GetWbemStatus () ) )
	{
		IWbemClassObject *t_NotifyStatus = NULL ;
		BOOL t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
		if ( t_Status )
		{
			HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , m_ErrorObject.GetMessage () , t_NotifyStatus ) ;
			t_NotifyStatus->Release () ;
		}
	}
	else
	{
		HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , NULL , NULL ) ;
	}
}

void GetObjectEventObject :: ProcessComplete () 
{
}

void GetObjectEventObject :: Process () 
{
	switch ( m_State )
	{
		case 0:
		{
			Complete () ;
			WaitAcknowledgement () ;
			BOOL t_Status = GetObject ( m_ErrorObject ) ;
			if ( t_Status )
			{
			}
			else
			{
				ProcessComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}
}


GetObjectAsyncEventObject :: GetObjectAsyncEventObject (

	CImpFrameworkProv *a_Provider , 
	BSTR a_ObjectPath ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : GetObjectEventObject ( a_Provider , a_ObjectPath , a_OperationFlag , a_NotificationHandler , a_Ctx ) 
{
}

GetObjectAsyncEventObject :: ~GetObjectAsyncEventObject () 
{
}

void GetObjectAsyncEventObject :: ProcessComplete () 
{
	GetObjectEventObject :: ProcessComplete () ;

/*
 *	Remove worker object from worker thread container
 */

	CImpFrameworkProv:: s_DefaultThreadObject->ReapTask ( *this ) ;

	Release () ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provider\framevt.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the ProvGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include "classfac.h"
#include "guids.h"
#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "framcomm.h"
#include "framprov.h"
#include "fram.h"

EventAsyncEventObject :: EventAsyncEventObject (

	CImpFrameworkProv *a_Provider ,
	IWbemObjectSink* pSink, 
	long lFlags

) : WbemTaskObject ( a_Provider , pSink , lFlags , NULL ) 
{
}

EventAsyncEventObject :: ~EventAsyncEventObject () 
{
}

void EventAsyncEventObject :: ProcessComplete () 
{
	if ( SUCCEEDED ( m_ErrorObject.GetWbemStatus () ) )
	{
	}
	else
	{
	}

/*
 *	Remove worker object from worker thread container
 */

	CImpFrameworkProv:: s_DefaultThreadObject->ReapTask ( *this ) ;

	delete this ;
}

void EventAsyncEventObject :: Process () 
{
	switch ( m_State )
	{
		case 0:
		{
			Complete () ;
			WaitAcknowledgement () ;
			BOOL t_Status = ProcessEvent ( m_ErrorObject ) ;
			if ( t_Status )
			{
			}
			else
			{
				ProcessComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}
}

BOOL EventAsyncEventObject :: ProcessEvent ( WbemProviderErrorObject &a_ErrorObject ) 
{
	return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provider\frammeth.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the ProvGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include "classfac.h"
#include "guids.h"
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "framcomm.h"
#include "framprov.h"
#include "fram.h"

BOOL ExecMethodEventObject :: ExecMethod ( WbemProviderErrorObject &a_ErrorObject )
{
	BOOL t_Status;
    int iParseResult = m_ObjectPathParser.Parse ( m_ObjectPath , &m_ParsedObjectPath ) ;
	if ( CObjectPathParser::NoError == iParseResult )
	{
		t_Status = TRUE;
        ProcessComplete () ;
	}
	else
	{
		t_Status = FALSE ;
		a_ErrorObject.SetStatus ( WBEM_PROVIDER_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Unknown Class" ) ;
	}

	return t_Status ;
}

ExecMethodEventObject :: ExecMethodEventObject (

	CImpFrameworkProv *a_Provider , 
    BSTR a_ObjectPath,
    BSTR a_MethodName,
    ULONG a_OperationFlag,
    IWbemContext FAR *a_Ctx,
    IWbemClassObject FAR *a_InParameters,
	IWbemObjectSink FAR *a_NotificationHandler

) : WbemTaskObject ( a_Provider , a_NotificationHandler , a_OperationFlag , a_Ctx )
{
	m_ObjectPath = UnicodeStringDuplicate ( a_ObjectPath ) ;
	m_MethodName = UnicodeStringDuplicate ( a_MethodName ) ;

	m_InParameters = a_InParameters ;
	if ( m_InParameters ) 
		m_InParameters->AddRef () ;

}

ExecMethodEventObject :: ~ExecMethodEventObject () 
{
// Get Status object

	delete [] m_ObjectPath ;
	delete [] m_MethodName ;

	if ( m_InParameters ) 
		m_InParameters->Release () ;

	if ( FAILED ( m_ErrorObject.GetWbemStatus () ) )
	{
		IWbemClassObject *t_NotifyStatus = NULL ;
		BOOL t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
		if ( t_Status )
		{
			HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , m_ErrorObject.GetMessage () , t_NotifyStatus ) ;
			t_NotifyStatus->Release () ;
		}
	}
	else
	{
		HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , NULL , NULL ) ;
	}
}

void ExecMethodEventObject :: ProcessComplete () 
{
}

void ExecMethodEventObject :: Process () 
{
	switch ( m_State )
	{
		case 0:
		{
			Complete () ;
			WaitAcknowledgement () ;
			BOOL t_Status = ExecMethod ( m_ErrorObject ) ;
			if ( t_Status )
			{
			}
			else
			{
				ProcessComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}
}

ExecMethodAsyncEventObject :: ExecMethodAsyncEventObject (

	CImpFrameworkProv *a_Provider , 
    BSTR a_ObjectPath,
    BSTR a_MethodName,
    ULONG a_OperationFlag,
    IWbemContext FAR *a_Ctx,
    IWbemClassObject FAR *a_InParameters,
	IWbemObjectSink FAR *a_NotificationHandler

) : ExecMethodEventObject ( a_Provider , a_ObjectPath , a_MethodName , a_OperationFlag , a_Ctx , a_InParameters , a_NotificationHandler )
{
}

ExecMethodAsyncEventObject :: ~ExecMethodAsyncEventObject () 
{
}

void ExecMethodAsyncEventObject :: ProcessComplete () 
{
	ExecMethodEventObject :: ProcessComplete () ;

/*
 *	Remove worker object from worker thread container
 */

	CImpFrameworkProv:: s_DefaultThreadObject->ReapTask ( *this ) ;

	Release () ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provider\framprov.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS PROVIDER Property Provider

//

//  Purpose: Implementation for the CImpFrameworkProv class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <objbase.h>
#include <stdio.h>

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <wbemidl.h>
#include <wbemint.h>
#include "classfac.h"
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "framcomm.h"
#include "framprov.h"
#include "fram.h"
#include "guids.h"

/////////////////////////////////////////////////////////////////////////////
//  Functions constructor, destructor and IUnknown

//***************************************************************************
//
// CImpFrameworkProv ::CImpFrameworkProv
// CImpFrameworkProv ::~CImpFrameworkProv
//
//***************************************************************************

DefaultThreadObject *CImpFrameworkProv :: s_DefaultThreadObject = NULL ;

CImpFrameworkProv ::CImpFrameworkProv ()
{
	m_ReferenceCount = 0 ;
	 
    InterlockedIncrement ( & CFrameworkProviderClassFactory :: s_ObjectsInProgress ) ;

/*
 * Implementation
 */

	m_Initialised = FALSE ;
	m_Server = NULL ;
	m_Namespace = NULL ;

	m_NotificationClassObject = NULL ;
	m_ExtendedNotificationClassObject = NULL ;
	m_GetNotifyCalled = FALSE ;
	m_GetExtendedNotifyCalled = FALSE ;

	m_localeId = NULL ;
}

CImpFrameworkProv ::~CImpFrameworkProv(void)
{
/* 
 * Place code in critical section
 */

	InterlockedDecrement ( & CFrameworkProviderClassFactory :: s_ObjectsInProgress ) ;

	delete [] m_localeId ;
	delete [] m_Namespace ;

	if ( m_Server ) 
		m_Server->Release () ;

	if ( m_NotificationClassObject )
		m_NotificationClassObject->Release () ;

	if ( m_ExtendedNotificationClassObject )
		m_ExtendedNotificationClassObject->Release () ;

}

//***************************************************************************
//
// CImpFrameworkProv ::QueryInterface
// CImpFrameworkProv ::AddRef
// CImpFrameworkProv ::Release
//
// Purpose: IUnknown members for CImpFrameworkProv object.
//***************************************************************************

STDMETHODIMP CImpFrameworkProv ::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) ( IWbemServices * ) this ;		
	}	
	else if ( iid == IID_IWbemEventProvider )
	{
        *iplpv = ( LPVOID ) ( IWbemEventProvider * ) this ;
	}
	else if ( iid == IID_IWbemHiPerfProvider )
	{
        *iplpv = ( LPVOID ) ( IWbemHiPerfProvider * ) this ;
	}
	else if ( iid == IID_IWbemProviderInit )
	{
		*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;		
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return S_OK ;
	}
	else
	{
		return E_NOINTERFACE ;
	}
}

STDMETHODIMP_(ULONG) CImpFrameworkProv ::AddRef(void)
{
    return InterlockedIncrement ( & m_ReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CImpFrameworkProv ::Release(void)
{
	LONG t_Ref ;
	if ( ( t_Ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_Ref ;
	}
}

void CImpFrameworkProv :: SetServer ( IWbemServices *a_Server ) 
{
	m_Server = a_Server ; 
	m_Server->AddRef () ; 
}

IWbemServices *CImpFrameworkProv :: GetServer () 
{ 
	if ( m_Server )
		m_Server->AddRef () ; 

	return m_Server ; 
}

void CImpFrameworkProv :: SetLocaleId ( wchar_t *localeId )
{
	m_localeId = UnicodeStringDuplicate ( localeId ) ;
}

wchar_t *CImpFrameworkProv :: GetNamespace () 
{
	return m_Namespace ; 
}

void CImpFrameworkProv :: SetNamespace ( wchar_t *a_Namespace ) 
{
	m_Namespace = UnicodeStringDuplicate ( a_Namespace ) ; 
}

IWbemClassObject *CImpFrameworkProv :: GetNotificationObject ( WbemProviderErrorObject &a_errorObject , IWbemContext *a_Ctx ) 
{
	if ( m_NotificationClassObject )
	{
		m_NotificationClassObject->AddRef () ;
	}
	else
	{
		BOOL t_Status = CreateNotificationObject ( a_errorObject , a_Ctx ) ;
		if ( t_Status )
		{
/* 
 * Keep around until we close
 */
			m_NotificationClassObject->AddRef () ;
		}

	}

	return m_NotificationClassObject ; 
}

IWbemClassObject *CImpFrameworkProv :: GetExtendedNotificationObject ( WbemProviderErrorObject &a_errorObject , IWbemContext *a_Ctx ) 
{
	if ( m_ExtendedNotificationClassObject )
	{
		m_ExtendedNotificationClassObject->AddRef () ;
	}
	else
	{
		BOOL t_Status = CreateExtendedNotificationObject ( a_errorObject , a_Ctx ) ;
		if ( t_Status )
		{
/* 
 * Keep around until we close
 */
			m_ExtendedNotificationClassObject->AddRef () ;
		}
	}

	return m_ExtendedNotificationClassObject ; 
}

BOOL CImpFrameworkProv :: CreateExtendedNotificationObject ( 

	WbemProviderErrorObject &a_errorObject ,
	IWbemContext *a_Ctx 
)
{
	if ( m_GetExtendedNotifyCalled )
	{
		if ( m_ExtendedNotificationClassObject )
			return TRUE ;
		else
			return FALSE ;
	}
	else
		m_GetExtendedNotifyCalled = TRUE ;

	BOOL t_Status = TRUE ;

	IWbemCallResult *t_ErrorObject = NULL ;

	HRESULT t_Result = m_Server->GetObject (

		WBEM_CLASS_EXTENDEDSTATUS ,
		0 ,
		a_Ctx,
		& m_ExtendedNotificationClassObject ,
		& t_ErrorObject 
	) ;

	if ( t_ErrorObject )
		t_ErrorObject->Release () ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		t_Status = FALSE ;
		a_errorObject.SetStatus ( WBEM_PROVIDER_E_INVALID_OBJECT ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Failed to get __ExtendedStatus" ) ;

		m_ExtendedNotificationClassObject = NULL ;
	}

	return t_Status ;
}

BOOL CImpFrameworkProv :: CreateNotificationObject ( 

	WbemProviderErrorObject &a_errorObject , 
	IWbemContext *a_Ctx 
)
{
	if ( m_GetNotifyCalled )
	{
		if ( m_NotificationClassObject )
			return TRUE ;
		else
			return FALSE ;
	}
	else
		m_GetNotifyCalled = TRUE ;

	BOOL t_Status = TRUE ;

	IWbemCallResult *t_ErrorObject = NULL ;

	HRESULT t_Result = m_Server->GetObject (

		WBEM_CLASS_EXTENDEDSTATUS ,
		0 ,
		a_Ctx,
		& m_NotificationClassObject ,
		& t_ErrorObject 
	) ;

	if ( t_ErrorObject )
		t_ErrorObject->Release () ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		t_Status = FALSE ;
		a_errorObject.SetStatus ( WBEM_PROVIDER_E_INVALID_OBJECT ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Failed to get __ExtendedStatus" ) ;
	}

	return t_Status ;
}

/////////////////////////////////////////////////////////////////////////////
//  Functions for the IWbemServices interface that are handled here

HRESULT CImpFrameworkProv ::OpenNamespace ( 

	BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemServices FAR* FAR* ppNewContext, 
	IWbemCallResult FAR* FAR* ppErrorObject
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpFrameworkProv :: CancelAsyncCall ( 
		
	IWbemObjectSink __RPC_FAR *pSink
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpFrameworkProv :: QueryObjectSink ( 

	long lFlags,		
	IWbemObjectSink FAR* FAR* ppHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpFrameworkProv :: GetObject ( 
		
	BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR* FAR *ppObject,
    IWbemCallResult FAR* FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpFrameworkProv :: GetObjectAsync ( 
		
	BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		_TEXT("\r\n")
	) ;

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		_TEXT(__FILE__),__LINE__,
		_TEXT("CImpFrameworkProv::GetObjectAsync ()") 
	) ;
) 

	HRESULT t_Result = S_OK ;

/*
 * Create Asynchronous GetObjectByPath object
 */

	GetObjectAsyncEventObject *t_AsyncEvent = new GetObjectAsyncEventObject ( this , ObjectPath , lFlags , pHandler , pCtx ) ;

	CImpFrameworkProv :: s_DefaultThreadObject->ScheduleTask ( *t_AsyncEvent ) ;

	t_AsyncEvent->Exec() ;

	t_AsyncEvent->Acknowledge () ;

#ifdef UNICODE

DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		_TEXT(__FILE__),__LINE__,
		_TEXT("Returning from CImpFrameworkProv::GetObjectAsync ( (%s) ) with Result = (%lx)") ,
		ObjectPath ,
		t_Result 
	) ;
)
#else

DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		_TEXT(__FILE__),__LINE__,
		_TEXT("Returning from CImpFrameworkProv::GetObjectAsync ( (%S) ) with Result = (%lx)") ,
		ObjectPath ,
		t_Result 
	) ;
)
#endif


	return t_Result ;
}

HRESULT CImpFrameworkProv :: PutClass ( 
		
	IWbemClassObject FAR* pClass , 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpFrameworkProv :: PutClassAsync ( 
		
	IWbemClassObject FAR* pClass, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		_TEXT("\r\n")
	) ;

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		_TEXT(__FILE__),__LINE__,
		_TEXT("CImpFrameworkProv::PutInstanceAsync ()")
	) ;
) 

	HRESULT t_Result = S_OK ;

/*
 * Create Synchronous UpdateInstance object
 */

	PutClassAsyncEventObject *t_AsyncEvent = new PutClassAsyncEventObject ( this , pClass , lFlags , pHandler , pCtx ) ;

	CImpFrameworkProv :: s_DefaultThreadObject->ScheduleTask ( *t_AsyncEvent ) ;

	t_AsyncEvent->Exec() ;

	t_AsyncEvent->Acknowledge () ;

DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		_TEXT(__FILE__),__LINE__,
		_TEXT("Returning from CImpFrameworkProv::PutInstanceAsync () with Result = (%lx)") ,
		t_Result 
	) ;
)

	return t_Result ;
}

 HRESULT CImpFrameworkProv :: DeleteClass ( 
		
	BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpFrameworkProv :: DeleteClassAsync ( 
		
	BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{

#ifdef UNICODE

DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		_TEXT("\r\n")
	) ;

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		_TEXT(__FILE__),__LINE__,
		_TEXT("CImpFrameworkProv::DeleteClassAsync ( (%s) )") ,
		Class
	) ;
)
#else

DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		_TEXT("\r\n")
	) ;

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		_TEXT(__FILE__),__LINE__,
		_TEXT("CImpFrameworkProv::DeleteClassAsync ( (%S) )") ,
		Class
	) ;
) 
#endif

	HRESULT t_Result = S_OK ;

/*
 * Create Synchronous Enum Instance object
 */

	DeleteClassAsyncEventObject *t_AsyncEvent = new DeleteClassAsyncEventObject ( this , Class , lFlags , pHandler , pCtx ) ;

	CImpFrameworkProv :: s_DefaultThreadObject->ScheduleTask ( *t_AsyncEvent ) ;

	t_AsyncEvent->Exec() ;

	t_AsyncEvent->Acknowledge () ;

#ifdef UNICODE

DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		_TEXT(__FILE__),__LINE__,
		_TEXT("ReturningFrom CImpFrameworkProv::DeleteClass ( (%s) ) with Result = (%lx)") ,
		Class ,
		t_Result
	) ;
)
#else

DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		_TEXT(__FILE__),__LINE__,
		_TEXT("ReturningFrom CImpFrameworkProv::DeleteClass ( (%S) ) with Result = (%lx)") ,
		Class ,
		t_Result
	) ;
)

#endif

	return t_Result ;

}

HRESULT CImpFrameworkProv :: CreateClassEnum ( 

	BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

SCODE CImpFrameworkProv :: CreateClassEnumAsync (

	BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpFrameworkProv :: PutInstance (

    IWbemClassObject FAR *pInstance,
    long lFlags,
    IWbemContext FAR *pCtx,
	IWbemCallResult FAR *FAR *ppCallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpFrameworkProv :: PutInstanceAsync ( 
		
	IWbemClassObject FAR* pInstance, 
	long lFlags, 
    IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		_TEXT("\r\n")
	) ;

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		_TEXT(__FILE__),__LINE__,
		_TEXT("CImpFrameworkProv::PutInstanceAsync ()")
	) ;
) 

	HRESULT t_Result = S_OK ;

/*
 * Create Synchronous UpdateInstance object
 */

	PutInstanceAsyncEventObject *t_AsyncEvent = new PutInstanceAsyncEventObject ( this , pInstance , lFlags , pHandler , pCtx ) ;

	CImpFrameworkProv :: s_DefaultThreadObject->ScheduleTask ( *t_AsyncEvent ) ;

	t_AsyncEvent->Exec() ;

	t_AsyncEvent->Acknowledge () ;

DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		_TEXT(__FILE__),__LINE__,
		_TEXT("Returning from CImpFrameworkProv::PutInstanceAsync () with Result = (%lx)") ,
		t_Result 
	) ;
)

	return t_Result ;
}

HRESULT CImpFrameworkProv :: DeleteInstance ( 

	BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}
        
HRESULT CImpFrameworkProv :: DeleteInstanceAsync (
 
	BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pHandler
)
{
DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		_TEXT("\r\n")
	) ;

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		_TEXT(__FILE__),__LINE__,
		_TEXT("CImpFrameworkProv::DeleteInstance ()")
	) ;
) 

	HRESULT t_Result = S_OK ;

/*
 * Create Asynchronous GetObjectByPath object
 */

	DeleteInstanceAsyncEventObject *t_AsyncEvent = new DeleteInstanceAsyncEventObject ( this , ObjectPath , lFlags , pHandler , pCtx ) ;

	CImpFrameworkProv :: s_DefaultThreadObject->ScheduleTask ( *t_AsyncEvent ) ;

	t_AsyncEvent->Exec() ;

	t_AsyncEvent->Acknowledge () ;

#ifdef UNICODE

DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		_TEXT(__FILE__),__LINE__,
		_TEXT("Returning from CImpFrameworkProv::DeleteInstanceAsync ( (%s) ) with Result = (%lx)") ,
		ObjectPath ,
		t_Result 
	) ;
)
#else

DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		_TEXT(__FILE__),__LINE__,
		_TEXT("Returning from CImpFrameworkProv::DeleteInstanceAsync ( (%S) ) with Result = (%lx)") ,
		ObjectPath ,
		t_Result 
	) ;
)
#endif

	return t_Result ;

}

HRESULT CImpFrameworkProv :: CreateInstanceEnum ( 

	BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx, 
	IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpFrameworkProv :: CreateInstanceEnumAsync (

 	BSTR Class, 
	long lFlags, 
	IWbemContext __RPC_FAR *pCtx,
	IWbemObjectSink FAR* pHandler 

) 
{
DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		_TEXT("\r\n")
	) ;
)

#ifdef UNICODE

DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		_TEXT(__FILE__),__LINE__,
		_TEXT("CImpFrameworkProv::CreateInstanceEnumAsync ( (%s) )") ,
		Class
	) ;
)

#else

DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		_TEXT(__FILE__),__LINE__,
		_TEXT("CImpFrameworkProv::CreateInstanceEnumAsync ( (%S) )") ,
		Class
	) ;
) 
#endif

	HRESULT t_Result = S_OK ;

/*
 * Create Synchronous Enum Instance object
 */

	CreateInstanceEnumAsyncEventObject *t_AsyncEvent = new CreateInstanceEnumAsyncEventObject ( this , Class , lFlags , pHandler , pCtx ) ;

	CImpFrameworkProv :: s_DefaultThreadObject->ScheduleTask ( *t_AsyncEvent ) ;

	t_AsyncEvent->Exec() ;

	t_AsyncEvent->Acknowledge () ;

#ifdef UNICODE

DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		_TEXT(__FILE__),__LINE__,
		_TEXT("ReturningFrom CImpFrameworkProv::CreateInstanceEnum ( (%s) ) with Result = (%lx)") ,
		Class ,
		t_Result
	) ;
)

#else

DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		_TEXT(__FILE__),__LINE__,
		_TEXT("ReturningFrom CImpFrameworkProv::CreateInstanceEnum ( (%s) ) with Result = (%lx)") ,
		Class ,
		t_Result
	) ;
)
#endif

	return t_Result ;
}

HRESULT CImpFrameworkProv :: ExecQuery ( 

	BSTR QueryLanguage, 
	BSTR Query, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpFrameworkProv :: ExecQueryAsync ( 
		
	BSTR QueryFormat, 
	BSTR Query, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		_TEXT("\r\n")
	) ;
)

#ifdef UNICODE

DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		_TEXT(__FILE__),__LINE__,
		_TEXT("CImpFrameworkProv::ExecQueryAsync ( (%s),(%s) )") ,
		QueryFormat ,
		Query 
	) ;
)

#else

DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		_TEXT(__FILE__),__LINE__,
		_TEXT("CImpFrameworkProv::ExecQueryAsync ( (%s),(%s) )") ,
		QueryFormat ,
		Query 
	) ;
)
#endif

	HRESULT t_Result = S_OK ;

/*
 * Create Synchronous Enum Instance object
 */

	ExecQueryAsyncEventObject *t_AsyncEvent = new ExecQueryAsyncEventObject ( this , QueryFormat , Query , lFlags , pHandler , pCtx ) ;

	CImpFrameworkProv :: s_DefaultThreadObject->ScheduleTask ( *t_AsyncEvent ) ;

	t_AsyncEvent->Exec() ;

	t_AsyncEvent->Acknowledge () ;

#ifdef UNICODE

DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		_TEXT(__FILE__),__LINE__,
		_TEXT("Returning from CImpFrameworkProv::ExecqQueryAsync ( (%s),(%s) ) with Result = (%lx)") ,
		QueryFormat,
		Query,
		t_Result 
	) ;
)

#else

DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		_TEXT(__FILE__),__LINE__,
		_TEXT("Returning from CImpFrameworkProv::ExecqQueryAsync ( (%S),(%S) ) with Result = (%lx)") ,
		QueryFormat,
		Query,
		t_Result 
	) ;
)
#endif

	return t_Result ;
}

HRESULT CImpFrameworkProv :: ExecNotificationQuery ( 

	BSTR QueryLanguage,
    BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}
        
HRESULT CImpFrameworkProv :: ExecNotificationQueryAsync ( 
            
	BSTR QueryLanguage,
    BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pHandler
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

HRESULT STDMETHODCALLTYPE CImpFrameworkProv :: ExecMethod ( 

	BSTR ObjectPath,
    BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
    IWbemClassObject FAR *FAR *ppOutParams,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT STDMETHODCALLTYPE CImpFrameworkProv :: ExecMethodAsync ( 

    BSTR ObjectPath,
    BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
	IWbemObjectSink FAR *pResponseHandler
) 
{
DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		_TEXT("\r\n")
	) ;
)

#ifdef UNICODE

DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		_TEXT(__FILE__),__LINE__,
		_TEXT("CImpFrameworkProv::ExecMethodAsync ( (%s),(%s) )") ,
		ObjectPath ,
		MethodName
	) ;
)

#else

DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		_TEXT(__FILE__),__LINE__,
		_TEXT("CImpFrameworkProv::ExecMethodAsync ( (%S),(%S) )") ,
		ObjectPath ,
		MethodName
	) ;
)
#endif

	HRESULT t_Result = S_OK ;

/*
 * Create Synchronous Enum Instance object
 */

	ExecMethodAsyncEventObject *t_AsyncEvent = new ExecMethodAsyncEventObject ( this , ObjectPath , MethodName , lFlags , pCtx , pInParams , pResponseHandler ) ;

	CImpFrameworkProv :: s_DefaultThreadObject->ScheduleTask ( *t_AsyncEvent ) ;

	t_AsyncEvent->Exec() ;

	t_AsyncEvent->Acknowledge () ;

#ifdef UNICODE

DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		_TEXT(__FILE__),__LINE__,
		_TEXT("Returning from CImpFrameworkProv::ExecqMethodAsync ( (%s),(%s) ) with Result = (%lx)") ,
		ObjectPath ,
		MethodName,
		t_Result 
	) ;
)
#else

DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		_TEXT(__FILE__),__LINE__,
		_TEXT("Returning from CImpFrameworkProv::ExecqMethodAsync ( (%S),(%S) ) with Result = (%lx)") ,
		ObjectPath ,
		MethodName,
		t_Result 
	) ;
)
#endif

	return t_Result ;
}

STDMETHODIMP CImpFrameworkProv :: ProvideEvents (

	IWbemObjectSink* pSink,
    LONG lFlags
)
{
	HRESULT t_Result = S_OK ;

/*
 * Create Synchronous Enum Instance object
 */

	EventAsyncEventObject *t_AsyncEvent = new EventAsyncEventObject ( 

		this , 
		pSink, 
		lFlags
	) ;

	CImpFrameworkProv :: s_DefaultThreadObject->ScheduleTask ( *t_AsyncEvent ) ;

	t_AsyncEvent->Exec() ;

	t_AsyncEvent->Acknowledge () ;

	return t_Result ;
}

HRESULT CImpFrameworkProv :: Initialize(

	LPWSTR pszUser,
	LONG lFlags,
	LPWSTR pszNamespace,
	LPWSTR pszLocale,
	IWbemServices *pCIMOM,         // For anybody
	IWbemContext *pCtx,
	IWbemProviderInitSink *pInitSink     // For init signals
)
{
DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->Write (  

		_TEXT("\r\n")
	) ;

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		_TEXT(__FILE__),__LINE__,
		_TEXT("CImpFrameworkProv::Initialize ()")
	) ;
)

	EnterCriticalSection ( & s_CriticalSection ) ;

	SetServer ( pCIMOM ) ;

	m_NamespacePath.SetNamespacePath ( pszNamespace ) ;
	SetNamespace ( pszNamespace ) ;

	BOOL status = TRUE ;

	if ( ! CImpFrameworkProv :: s_DefaultThreadObject )
	{
		ProvThreadObject :: Startup () ;
		ProvDebugLog :: Startup () ;

		CImpFrameworkProv :: s_DefaultThreadObject = new DefaultThreadObject ( _TEXT("WBEM Provider") ) ; ;
		CImpFrameworkProv :: s_DefaultThreadObject->WaitForStartup () ;
	}

	WbemProviderErrorObject errorObject ;

	IWbemClassObject *t_Object = GetNotificationObject ( errorObject , pCtx ) ;
	if ( t_Object ) 
		t_Object->Release () ;

	t_Object = GetExtendedNotificationObject ( errorObject , pCtx ) ;
	if ( t_Object ) 
		t_Object->Release () ;

	HRESULT result = errorObject.GetWbemStatus () ;

	pInitSink->SetStatus ( (result == WBEM_NO_ERROR) ? (LONG)WBEM_S_INITIALIZED : (LONG)WBEM_E_FAILED , 0 ) ;

DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		_TEXT(__FILE__),__LINE__,
		_TEXT("Returning From CImpFrameworkProv::Initialize () with Result = (%lx)") ,
		result
	) ;
)

	LeaveCriticalSection ( & s_CriticalSection ) ;
	
	return result ;
}

    // IWbemHiPerfProvider methods.
    // ============================

HRESULT STDMETHODCALLTYPE CImpFrameworkProv :: QueryInstances (

	IWbemServices *pNamespace ,
    WCHAR *wszClass ,
    long lFlags ,
    IWbemContext *pCtx , 
    IWbemObjectSink* pSink
)
{
	return WBEM_E_NOT_AVAILABLE ;
}


HRESULT STDMETHODCALLTYPE CImpFrameworkProv :: CreateRefresher (

	IWbemServices *pNamespace ,
    long lFlags ,
    IWbemRefresher **ppRefresher
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT STDMETHODCALLTYPE CImpFrameworkProv :: CreateRefreshableObject (

	IWbemServices *pNamespace,
    IWbemObjectAccess *pTemplate,
    IWbemRefresher *pRefresher,
    long lFlags,
    IWbemContext *pContext,
    IWbemObjectAccess **ppRefreshable,
    long *plId
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT STDMETHODCALLTYPE CImpFrameworkProv :: StopRefreshing (

	IWbemRefresher *pRefresher,
    long lId,
    long lFlags
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT STDMETHODCALLTYPE CImpFrameworkProv :: CreateRefreshableEnum (

    IWbemServices *pNamespace,
    LPCWSTR wszClass,
    IWbemRefresher *pRefresher,
    long lFlags,
    IWbemContext *pContext,
    IWbemHiPerfEnum *pHiPerfEnum,
    long *plId
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT STDMETHODCALLTYPE CImpFrameworkProv :: GetObjects (

    IWbemServices *pNamespace,
	long lNumObjects,
	IWbemObjectAccess **apObj,
    long lFlags,
    IWbemContext *pContext
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

CImpRefresher::CImpRefresher ()
{
DebugMacro2( 

	ProvDebugLog :: s_ProvDebugLog->WriteFileAndLine (  

		_TEXT(__FILE__),__LINE__,
		_TEXT("CImpRefresher::CImpRefresher ( this = ( %lx ) ) ") , 
		this 
	) ;
)

	m_referenceCount = 0 ;
	 
    InterlockedIncrement ( & CFrameworkProviderClassFactory :: s_ObjectsInProgress ) ;

}

CImpRefresher::~CImpRefresher(void)
{
/* 
 * Place code in critical section
 */

	InterlockedDecrement ( & CFrameworkProviderClassFactory :: s_ObjectsInProgress ) ;
}

//***************************************************************************
//
// CImpRefresher::QueryInterface
// CImpRefresher::AddRef
// CImpRefresher::Release
//
// Purpose: IUnknown members for CImpRefresher object.
//***************************************************************************

STDMETHODIMP CImpRefresher::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) ( IWbemRefresher * ) this ;
	}
	else if ( iid == IID_IWbemRefresher )
	{
		*iplpv = ( LPVOID ) ( IWbemRefresher * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return S_OK ;
	}
	else
	{
		return E_NOINTERFACE ;
	}
}

STDMETHODIMP_(ULONG) CImpRefresher::AddRef(void)
{
    return InterlockedIncrement ( & m_referenceCount ) ;
}

STDMETHODIMP_(ULONG) CImpRefresher::Release(void)
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_referenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

HRESULT CImpRefresher :: Refresh (

	/* [in] */ long lFlags
)
{
	return WBEM_E_FAILED ;
}

CImpHiPerfEnum :: CImpHiPerfEnum () : m_ReferenceCount ( 0 )
{
}

CImpHiPerfEnum :: ~CImpHiPerfEnum ()
{
}

STDMETHODIMP CImpHiPerfEnum::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) ( CImpHiPerfEnum * ) this ;
	}
	else if ( iid == IID_IWbemHiPerfEnum )
	{
		*iplpv = ( LPVOID ) ( CImpHiPerfEnum * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return S_OK ;
	}
	else
	{
		return E_NOINTERFACE ;
	}
}

STDMETHODIMP_(ULONG) CImpHiPerfEnum::AddRef(void)
{
    return InterlockedIncrement ( & m_ReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CImpHiPerfEnum::Release(void)
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

HRESULT STDMETHODCALLTYPE CImpHiPerfEnum::AddObjects (

	long lFlags ,
	ULONG uNumObjects ,
	long __RPC_FAR *apIds ,
	IWbemObjectAccess __RPC_FAR *__RPC_FAR *apObj
)
{
	return WBEM_E_NOT_AVAILABLE ;
}
    
HRESULT STDMETHODCALLTYPE CImpHiPerfEnum::RemoveObjects (

	long lFlags ,
    ULONG uNumObjects ,
    long __RPC_FAR *apIds
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT STDMETHODCALLTYPE CImpHiPerfEnum::GetObjects (

    long lFlags ,
    ULONG uNumObjects ,
    IWbemObjectAccess __RPC_FAR *__RPC_FAR *apObj ,
    ULONG __RPC_FAR *puReturned
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT STDMETHODCALLTYPE CImpHiPerfEnum::RemoveAll ( 

    long lFlags
)
{
	return WBEM_E_NOT_AVAILABLE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provider\framqury.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the ProvGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include "classfac.h"
#include "guids.h"
#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "framcomm.h"
#include "framprov.h"
#include "fram.h"

BOOL ExecQueryEventObject :: ExecQuery ( WbemProviderErrorObject &a_ErrorObject )
{
	BOOL t_Status ;

	if ( _wcsicmp ( m_QueryFormat , WBEM_QUERY_LANGUAGE_WQL ) == 0 )
	{
		t_Status = ! m_SqlParser.Parse ( & m_RPNExpression ) ;
		if ( t_Status )
		{
			t_Status = GetClassObject ( m_RPNExpression->bsClassName ) ;
			if ( t_Status )
			{
				ProcessComplete () ;
			}
			else
			{
				t_Status = FALSE ;
				a_ErrorObject.SetStatus ( WBEM_PROVIDER_E_INVALID_CLASS ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_ErrorObject.SetMessage ( L"Unknown Class" ) ;
			}
		}
		else
		{
			t_Status = FALSE ;
			a_ErrorObject.SetStatus ( WBEM_PROVIDER_E_INVALID_QUERY ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY ) ;
			a_ErrorObject.SetMessage ( L"SQL1 query was invalid" ) ;
		}
	}
	else
	{
		t_Status = FALSE ;
		a_ErrorObject.SetStatus ( WBEM_PROVIDER_E_INVALID_QUERY_TYPE ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY_TYPE ) ;
		a_ErrorObject.SetMessage ( L"Query Language not supported" ) ;
	}

	return t_Status ;
}

ExecQueryEventObject :: ExecQueryEventObject (

	CImpFrameworkProv *a_Provider , 
	BSTR a_QueryFormat , 
	BSTR a_Query , 
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : WbemTaskObject ( a_Provider , a_NotificationHandler , a_OperationFlag , a_Ctx ) ,
	m_Query ( UnicodeStringDuplicate ( a_Query ) ) ,
	m_QueryFormat ( UnicodeStringDuplicate ( a_QueryFormat ) ) ,
	m_QuerySource ( m_Query ) , 
	m_SqlParser ( &m_QuerySource ) ,
	m_RPNExpression ( NULL ) 
{
}

ExecQueryEventObject :: ~ExecQueryEventObject () 
{
// Get Status object

	delete [] m_Query ;
	delete [] m_QueryFormat ;
	delete m_RPNExpression ;

	if ( FAILED ( m_ErrorObject.GetWbemStatus () ) )
	{
		IWbemClassObject *t_NotifyStatus = NULL ;
		BOOL t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
		if ( t_Status )
		{
			HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , m_ErrorObject.GetMessage () , t_NotifyStatus ) ;
			t_NotifyStatus->Release () ;
		}
	}
	else
	{
		HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , NULL , NULL ) ;
	}
}

void ExecQueryEventObject :: ProcessComplete () 
{
}

void ExecQueryEventObject :: Process () 
{
	switch ( m_State )
	{
		case 0:
		{
			Complete () ;
			WaitAcknowledgement () ;
			BOOL t_Status = ExecQuery ( m_ErrorObject ) ;
			if ( t_Status )
			{
			}
			else
			{
				ProcessComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}
}

ExecQueryAsyncEventObject :: ExecQueryAsyncEventObject (

	CImpFrameworkProv *a_Provider , 
	BSTR a_QueryFormat , 
	BSTR a_Query , 
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : ExecQueryEventObject ( a_Provider , a_QueryFormat , a_Query , a_OperationFlag , a_NotificationHandler , a_Ctx ) 
{
}

ExecQueryAsyncEventObject :: ~ExecQueryAsyncEventObject () 
{
}

void ExecQueryAsyncEventObject :: ProcessComplete () 
{
	ExecQueryEventObject :: ProcessComplete () ;

/*
 *	Remove worker object from worker thread container
 */

	CImpFrameworkProv:: s_DefaultThreadObject->ReapTask ( *this ) ;

	Release () ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\framework\provider\framset.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the ProvSetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include "classfac.h"
#include "guids.h"
#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "framcomm.h"
#include "framprov.h"
#include "fram.h"

BOOL PutInstanceEventObject :: PutInstance ( WbemProviderErrorObject &a_ErrorObject )
{
	BOOL t_Status = FALSE ;

	if ( t_Status )
	{
		ProcessComplete () ;
	}
	else
	{
		t_Status = FALSE ;
		a_ErrorObject.SetStatus ( WBEM_PROVIDER_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Unknown Class" ) ;
	}

	return t_Status ;
}

PutInstanceEventObject :: PutInstanceEventObject (

	CImpFrameworkProv *a_Provider , 
	IWbemClassObject *a_Object ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : WbemTaskObject ( a_Provider , a_No