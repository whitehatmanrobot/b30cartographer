NEFORWARDLIST   const lpForwardList,
    DWORD               dwNumRingsNoAnswer,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineForward", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   bAllAddresses,
                   dwAddressID,
                   lpForwardList,
                   dwNumRingsNoAnswer,
                   lphConsultCall,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineForwardA(
    HLINE               hLine,
    DWORD               bAllAddresses,
    DWORD               dwAddressID,
    LPLINEFORWARDLIST   const lpForwardList,
    DWORD               dwNumRingsNoAnswer,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineForwardA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   bAllAddresses,
                   dwAddressID,
                   lpForwardList,
                   dwNumRingsNoAnswer,
                   lphConsultCall,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineForwardW(
    HLINE               hLine,
    DWORD               bAllAddresses,
    DWORD               dwAddressID,
    LPLINEFORWARDLIST   const lpForwardList,
    DWORD               dwNumRingsNoAnswer,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineForwardW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   bAllAddresses,
                   dwAddressID,
                   lpForwardList,
                   dwNumRingsNoAnswer,
                   lphConsultCall,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGatherDigits(
    HCALL               hCall,
    DWORD               dwDigitModes,
    LPSTR               lpsDigits,
    DWORD               dwNumDigits,
    LPCSTR              lpszTerminationDigits,
    DWORD               dwFirstDigitTimeout,
    DWORD               dwInterDigitTimeout
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGatherDigits", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwDigitModes,
                   lpsDigits,
                   dwNumDigits,
                   lpszTerminationDigits,
                   dwFirstDigitTimeout,
                   dwInterDigitTimeout
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGatherDigitsA(
    HCALL               hCall,
    DWORD               dwDigitModes,
    LPSTR               lpsDigits,
    DWORD               dwNumDigits,
    LPCSTR              lpszTerminationDigits,
    DWORD               dwFirstDigitTimeout,
    DWORD               dwInterDigitTimeout
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGatherDigitsA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwDigitModes,
                   lpsDigits,
                   dwNumDigits,
                   lpszTerminationDigits,
                   dwFirstDigitTimeout,
                   dwInterDigitTimeout
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGatherDigitsW(
    HCALL               hCall,
    DWORD               dwDigitModes,
    LPWSTR              lpsDigits,
    DWORD               dwNumDigits,
    LPCWSTR             lpszTerminationDigits,
    DWORD               dwFirstDigitTimeout,
    DWORD               dwInterDigitTimeout
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGatherDigitsW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwDigitModes,
                   lpsDigits,
                   dwNumDigits,
                   lpszTerminationDigits,
                   dwFirstDigitTimeout,
                   dwInterDigitTimeout
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGenerateDigits(
    HCALL               hCall,
    DWORD               dwDigitMode,
    LPCSTR              lpszDigits,
    DWORD               dwDuration
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGenerateDigits", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwDigitMode,
                   lpszDigits,
                   dwDuration
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGenerateDigitsA(
    HCALL               hCall,
    DWORD               dwDigitMode,
    LPCSTR              lpszDigits,
    DWORD               dwDuration
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGenerateDigitsA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwDigitMode,
                   lpszDigits,
                   dwDuration
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGenerateDigitsW(
    HCALL               hCall,
    DWORD               dwDigitMode,
    LPCWSTR             lpszDigits,
    DWORD               dwDuration
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGenerateDigitsW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwDigitMode,
                   lpszDigits,
                   dwDuration
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGenerateTone(
    HCALL               hCall,
    DWORD               dwToneMode,
    DWORD               dwDuration,
    DWORD               dwNumTones,
    LPLINEGENERATETONE  const lpTones
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGenerateTone", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwToneMode,
                   dwDuration,
                   dwNumTones,
                   lpTones
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAddressCaps(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEADDRESSCAPS   lpAddressCaps
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAddressCaps", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAddressID,
                   dwAPIVersion,
                   dwExtVersion,
                   lpAddressCaps
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAddressCapsA(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEADDRESSCAPS   lpAddressCaps
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAddressCapsA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAddressID,
                   dwAPIVersion,
                   dwExtVersion,
                   lpAddressCaps
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAddressCapsW(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEADDRESSCAPS   lpAddressCaps
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAddressCapsW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAddressID,
                   dwAPIVersion,
                   dwExtVersion,
                   lpAddressCaps
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAddressID(
    HLINE               hLine,
    LPDWORD             lpdwAddressID,
    DWORD               dwAddressMode,
    LPCSTR              lpsAddress,
    DWORD               dwSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAddressID", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lpdwAddressID,
                   dwAddressMode,
                   lpsAddress,
                   dwSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAddressIDA(
    HLINE               hLine,
    LPDWORD             lpdwAddressID,
    DWORD               dwAddressMode,
    LPCSTR              lpsAddress,
    DWORD               dwSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAddressIDA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lpdwAddressID,
                   dwAddressMode,
                   lpsAddress,
                   dwSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAddressIDW(
    HLINE               hLine,
    LPDWORD             lpdwAddressID,
    DWORD               dwAddressMode,
    LPCWSTR             lpsAddress,
    DWORD               dwSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAddressIDW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lpdwAddressID,
                   dwAddressMode,
                   lpsAddress,
                   dwSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAddressStatus(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAddressStatus", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   lpAddressStatus
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAddressStatusA(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAddressStatusA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   lpAddressStatus
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAddressStatusW(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAddressStatusW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   lpAddressStatus
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAgentActivityListA(
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTACTIVITYLIST lpAgentActivityList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAgentActivityListA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                       hLine,
                       dwAddressID,
                       lpAgentActivityList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAgentActivityListW(
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTACTIVITYLIST lpAgentActivityList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAgentActivityListW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                       hLine,
                       dwAddressID,
                       lpAgentActivityList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAgentCapsA(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAppAPIVersion,
    LPLINEAGENTCAPS     lpAgentCaps
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAgentCapsA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAddressID,
                   dwAppAPIVersion,
                   lpAgentCaps
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAgentCapsW(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAppAPIVersion,
    LPLINEAGENTCAPS     lpAgentCaps
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAgentCapsW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAddressID,
                   dwAppAPIVersion,
                   lpAgentCaps
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAgentGroupListA(
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTGROUPLIST    lpAgentGroupList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAgentGroupListA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                       hLine,
                       dwAddressID,
                       lpAgentGroupList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAgentGroupListW(
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTGROUPLIST    lpAgentGroupList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAgentGroupListW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                       hLine,
                       dwAddressID,
                       lpAgentGroupList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAgentInfo(                                               // TAPI v2.2
    HLINE               hLine,
    HAGENT              hAgent,
    LPLINEAGENTINFO     lpAgentInfo
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAgentInfo", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                       hLine,
                       hAgent,
                       lpAgentInfo
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAgentSessionInfo(                                        // TAPI v2.2
    HLINE                   hLine,
    HAGENTSESSION           hAgentSession,
    LPLINEAGENTSESSIONINFO  lpAgentSessionInfo
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAgentSessionInfo", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                       hLine,
                       hAgentSession,
                       lpAgentSessionInfo
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAgentSessionList(                                        // TAPI v2.2
    HLINE                   hLine,
    HAGENT                  hAgent,
    LPLINEAGENTSESSIONLIST  lpAgentSessionList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAgentSessionList", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                       hLine,
                       hAgent,
                       lpAgentSessionList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAgentStatusA(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEAGENTSTATUS   lpAgentStatus
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAgentStatusA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   lpAgentStatus
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAgentStatusW(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEAGENTSTATUS   lpAgentStatus
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAgentStatusW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   lpAgentStatus
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAppPriority(
    LPCSTR              lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPVARSTRING         lpExtensionName,
    LPDWORD             lpdwPriority
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAppPriority", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   lpszAppFilename,
                   dwMediaMode,
                   lpExtensionID,
                   dwRequestMode,
                   lpExtensionName,
                   lpdwPriority
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAppPriorityA(
    LPCSTR              lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPVARSTRING         lpExtensionName,
    LPDWORD             lpdwPriority
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAppPriorityA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   lpszAppFilename,
                   dwMediaMode,
                   lpExtensionID,
                   dwRequestMode,
                   lpExtensionName,
                   lpdwPriority
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAppPriorityW(
    LPCWSTR             lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPVARSTRING         lpExtensionName,
    LPDWORD             lpdwPriority
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAppPriorityW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   lpszAppFilename,
                   dwMediaMode,
                   lpExtensionID,
                   dwRequestMode,
                   lpExtensionName,
                   lpdwPriority
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetCallInfo(
    HCALL               hCall,
    LPLINECALLINFO      lpCallInfo
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetCallInfo", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpCallInfo
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetCallInfoA(
    HCALL               hCall,
    LPLINECALLINFO      lpCallInfo
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetCallInfoA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpCallInfo
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetCallInfoW(
    HCALL               hCall,
    LPLINECALLINFO      lpCallInfo
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetCallInfoW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpCallInfo
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetCallStatus(
    HCALL               hCall,
    LPLINECALLSTATUS    lpCallStatus
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetCallStatus", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpCallStatus
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetConfRelatedCalls(
    HCALL               hCall,
    LPLINECALLLIST      lpCallList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetConfRelatedCalls", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpCallList
                 );
}
    
//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetCountry(
    DWORD               dwCountryID,
    DWORD               dwAPIVersion,
    LPLINECOUNTRYLIST   lpLineCountryList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetCountry", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwCountryID,
                   dwAPIVersion,
                   lpLineCountryList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetCountryA(
    DWORD               dwCountryID,
    DWORD               dwAPIVersion,
    LPLINECOUNTRYLIST   lpLineCountryList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetCountryA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwCountryID,
                   dwAPIVersion,
                   lpLineCountryList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetCountryW(
    DWORD               dwCountryID,
    DWORD               dwAPIVersion,
    LPLINECOUNTRYLIST   lpLineCountryList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetCountryW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwCountryID,
                   dwAPIVersion,
                   lpLineCountryList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetDevCaps(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEDEVCAPS       lpLineDevCaps
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetDevCaps", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAPIVersion,
                   dwExtVersion,
                   lpLineDevCaps
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetDevCapsA(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEDEVCAPS       lpLineDevCaps
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetDevCapsA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAPIVersion,
                   dwExtVersion,
                   lpLineDevCaps
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetDevCapsW(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEDEVCAPS       lpLineDevCaps
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetDevCapsW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAPIVersion,
                   dwExtVersion,
                   lpLineDevCaps
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetDevConfig(
    DWORD               dwDeviceID,
    LPVARSTRING         lpDeviceConfig,
    LPCSTR              lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetDevConfig", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   lpDeviceConfig,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetDevConfigA(
    DWORD               dwDeviceID,
    LPVARSTRING         lpDeviceConfig,
    LPCSTR              lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetDevConfigA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   lpDeviceConfig,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetDevConfigW(
    DWORD               dwDeviceID,
    LPVARSTRING         lpDeviceConfig,
    LPCWSTR             lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetDevConfigW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   lpDeviceConfig,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetNewCalls(
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwSelect,
    LPLINECALLLIST      lpCallList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetNewCalls", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   dwSelect,
                   lpCallList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetGroupListA(                                              // TAPI v2.2
    HLINE                   hLine,
    LPLINEAGENTGROUPLIST    lpGroupList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetGroupListA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lpGroupList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetGroupListW(                                              // TAPI v2.2
    HLINE                   hLine,
    LPLINEAGENTGROUPLIST    lpGroupList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetGroupListW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lpGroupList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetIcon(
    DWORD               dwDeviceID,
    LPCSTR              lpszDeviceClass,
    LPHICON             lphIcon
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetIcon", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   lpszDeviceClass,
                   lphIcon
                 );
}
    
//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetIconA(
    DWORD               dwDeviceID,
    LPCSTR              lpszDeviceClass,
    LPHICON             lphIcon
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetIconA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   lpszDeviceClass,
                   lphIcon
                 );
}
    
//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetIconW(
    DWORD               dwDeviceID,
    LPCWSTR             lpszDeviceClass,
    LPHICON             lphIcon
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetIconW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   lpszDeviceClass,
                   lphIcon
                 );
}
    
//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetID(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    DWORD               dwSelect,
    LPVARSTRING         lpDeviceID,
    LPCSTR              lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetID", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   hCall,
                   dwSelect,
                   lpDeviceID,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetIDA(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    DWORD               dwSelect,
    LPVARSTRING         lpDeviceID,
    LPCSTR              lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetIDA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   hCall,
                   dwSelect,
                   lpDeviceID,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetIDW(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    DWORD               dwSelect,
    LPVARSTRING         lpDeviceID,
    LPCWSTR             lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetIDW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   hCall,
                   dwSelect,
                   lpDeviceID,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetLineDevStatus(
    HLINE               hLine,
    LPLINEDEVSTATUS     lpLineDevStatus
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetLineDevStatus", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lpLineDevStatus
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetLineDevStatusA(
    HLINE               hLine,
    LPLINEDEVSTATUS     lpLineDevStatus
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetLineDevStatusA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lpLineDevStatus
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetLineDevStatusW(
    HLINE               hLine,
    LPLINEDEVSTATUS     lpLineDevStatus
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetLineDevStatusW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lpLineDevStatus
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetMessage(
    HLINEAPP        hLineApp,
    LPLINEMESSAGE   lpMessage,
    DWORD           dwTimeout
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetMessage", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   lpMessage,
                   dwTimeout
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetNumRings(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPDWORD             lpdwNumRings
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetNumRings", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   lpdwNumRings
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetProviderList(
    DWORD               dwAPIVersion,
    LPLINEPROVIDERLIST  lpProviderList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetProviderList", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwAPIVersion,
                   lpProviderList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetProviderListA(
    DWORD               dwAPIVersion,
    LPLINEPROVIDERLIST  lpProviderList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetProviderListA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwAPIVersion,
                   lpProviderList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetProviderListW(
    DWORD               dwAPIVersion,
    LPLINEPROVIDERLIST  lpProviderList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetProviderListW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwAPIVersion,
                   lpProviderList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetProxyStatus(                                             // TAPI v2.2
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAppAPIVersion,
    LPLINEPROXYREQUESTLIST  lpLineProxyReqestList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetProxyStatus", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAppAPIVersion,
                   lpLineProxyReqestList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetQueueInfo(                                               // TAPI v2.2
    HLINE               hLine,
    DWORD               dwQueueID, 
    LPLINEQUEUEINFO     lpLineQueueInfo
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetQueueInfo", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwQueueID,
                   lpLineQueueInfo
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetQueueListA(                                              // TAPI v2.2
    HLINE               hLine,
    LPGUID              lpGroupID,
    LPLINEQUEUELIST     lpQueueList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetQueueListA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lpGroupID,
                   lpQueueList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetQueueListW(                                              // TAPI v2.2
    HLINE               hLine,
    LPGUID              lpGroupID,
    LPLINEQUEUELIST     lpQueueList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetQueueListW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lpGroupID,
                   lpQueueList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetRequest(
    HLINEAPP            hLineApp,
    DWORD               dwRequestMode,
    LPVOID              lpRequestBuffer
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetRequest", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwRequestMode,
                   lpRequestBuffer
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetRequestA(
    HLINEAPP            hLineApp,
    DWORD               dwRequestMode,
    LPVOID              lpRequestBuffer
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetRequestA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwRequestMode,
                   lpRequestBuffer
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetRequestW(
    HLINEAPP            hLineApp,
    DWORD               dwRequestMode,
    LPVOID              lpRequestBuffer
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetRequestW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwRequestMode,
                   lpRequestBuffer
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetStatusMessages(
    HLINE               hLine,
    LPDWORD             lpdwLineStates,
    LPDWORD             lpdwAddressStates
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetStatusMessages", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lpdwLineStates,
                   lpdwAddressStates
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetTranslateCaps(
    HLINEAPP hLineApp,
    DWORD dwAPIVersion,
    LPLINETRANSLATECAPS lpTranslateCaps
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetTranslateCaps", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwAPIVersion,
                   lpTranslateCaps
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetTranslateCapsA(
    HLINEAPP hLineApp,
    DWORD dwAPIVersion,
    LPLINETRANSLATECAPS lpTranslateCaps
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetTranslateCapsA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwAPIVersion,
                   lpTranslateCaps
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetTranslateCapsW(
    HLINEAPP hLineApp,
    DWORD dwAPIVersion,
    LPLINETRANSLATECAPS lpTranslateCaps
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetTranslateCapsW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwAPIVersion,
                   lpTranslateCaps
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineHandoff(
    HCALL               hCall,
    LPCSTR              lpszFileName,
    DWORD               dwMediaMode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineHandoff", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpszFileName,
                   dwMediaMode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineHandoffA(
    HCALL               hCall,
    LPCSTR              lpszFileName,
    DWORD               dwMediaMode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineHandoffA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpszFileName,
                   dwMediaMode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineHandoffW(
    HCALL               hCall,
    LPCWSTR             lpszFileName,
    DWORD               dwMediaMode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineHandoffW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpszFileName,
                   dwMediaMode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineHold(
    HCALL               hCall
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineHold", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineInitialize(
    LPHLINEAPP          lphLineApp,
    HINSTANCE           hInstance,
    LINECALLBACK        lpfnCallback,
    LPCSTR              lpszAppName,
    LPDWORD             lpdwNumDevs
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineInitialize", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   lphLineApp,
                   hInstance,
                   lpfnCallback,
                   lpszAppName,
                   lpdwNumDevs
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineInitializeExA(
    LPHLINEAPP                  lphLineApp,
    HINSTANCE                   hInstance,
    LINECALLBACK                lpfnCallback,
    LPCSTR                      lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPLINEINITIALIZEEXPARAMS    lpLineInitializeExParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineInitializeExA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   lphLineApp,
                   hInstance,
                   lpfnCallback,
                   lpszFriendlyAppName,
                   lpdwNumDevs,
                   lpdwAPIVersion,
                   lpLineInitializeExParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineInitializeExW(
    LPHLINEAPP                  lphLineApp,
    HINSTANCE                   hInstance,
    LINECALLBACK                lpfnCallback,
    LPCWSTR                     lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPLINEINITIALIZEEXPARAMS    lpLineInitializeExParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineInitializeExW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   lphLineApp,
                   hInstance,
                   lpfnCallback,
                   lpszFriendlyAppName,
                   lpdwNumDevs,
                   lpdwAPIVersion,
                   lpLineInitializeExParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineMakeCall(
    HLINE               hLine,
    LPHCALL             lphCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineMakeCall", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lphCall,
                   lpszDestAddress,
                   dwCountryCode,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineMakeCallA(
    HLINE               hLine,
    LPHCALL             lphCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineMakeCallA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lphCall,
                   lpszDestAddress,
                   dwCountryCode,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineMakeCallW(
    HLINE               hLine,
    LPHCALL             lphCall,
    LPCWSTR             lpszDestAddress,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineMakeCallW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lphCall,
                   lpszDestAddress,
                   dwCountryCode,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineMonitorDigits(
    HCALL               hCall,
    DWORD               dwDigitModes
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineMonitorDigits", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwDigitModes
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineMonitorMedia(
    HCALL               hCall,
    DWORD               dwMediaModes
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineMonitorMedia", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwMediaModes
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineMonitorTones(
    HCALL               hCall,
    LPLINEMONITORTONE   const lpToneList,
    DWORD               dwNumEntries
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineMonitorTones", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpToneList,
                   dwNumEntries
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineNegotiateAPIVersion(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPILowVersion,
    DWORD               dwAPIHighVersion,
    LPDWORD             lpdwAPIVersion,
    LPLINEEXTENSIONID   lpExtensionID
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineNegotiateAPIVersion", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAPILowVersion,
                   dwAPIHighVersion,
                   lpdwAPIVersion,
                   lpExtensionID
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineNegotiateExtVersion(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtLowVersion,
    DWORD               dwExtHighVersion,
    LPDWORD             lpdwExtVersion
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineNegotiateExtVersion", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAPIVersion,
                   dwExtLowVersion,
                   dwExtHighVersion,
                   lpdwExtVersion
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineOpen(
    HLINEAPP            hLineApp, 
    DWORD               dwDeviceID,
    LPHLINE             lphLine,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD_PTR           dwCallbackInstance,
    DWORD               dwPrivileges,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineOpen", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp, 
                   dwDeviceID,
                   lphLine,
                   dwAPIVersion,
                   dwExtVersion,
                   dwCallbackInstance,
                   dwPrivileges,
                   dwMediaModes,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineOpenA(
    HLINEAPP            hLineApp, 
    DWORD               dwDeviceID,
    LPHLINE             lphLine,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD_PTR           dwCallbackInstance,
    DWORD               dwPrivileges,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineOpenA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp, 
                   dwDeviceID,
                   lphLine,
                   dwAPIVersion,
                   dwExtVersion,
                   dwCallbackInstance,
                   dwPrivileges,
                   dwMediaModes,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineOpenW(
    HLINEAPP            hLineApp, 
    DWORD               dwDeviceID,
    LPHLINE             lphLine,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD_PTR           dwCallbackInstance,
    DWORD               dwPrivileges,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineOpenW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp, 
                   dwDeviceID,
                   lphLine,
                   dwAPIVersion,
                   dwExtVersion,
                   dwCallbackInstance,
                   dwPrivileges,
                   dwMediaModes,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
linePark(
    HCALL               hCall,
    DWORD               dwParkMode,
    LPCSTR              lpszDirAddress,
    LPVARSTRING         lpNonDirAddress
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "linePark", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwParkMode,
                   lpszDirAddress,
                   lpNonDirAddress
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineParkA(
    HCALL               hCall,
    DWORD               dwParkMode,
    LPCSTR              lpszDirAddress,
    LPVARSTRING         lpNonDirAddress
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineParkA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwParkMode,
                   lpszDirAddress,
                   lpNonDirAddress
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineParkW(
    HCALL               hCall,
    DWORD               dwParkMode,
    LPCWSTR             lpszDirAddress,
    LPVARSTRING         lpNonDirAddress
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineParkW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwParkMode,
                   lpszDirAddress,
                   lpNonDirAddress
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
linePickup(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCSTR              lpszDestAddress,
    LPCSTR              lpszGroupID
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "linePickup", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   lphCall,
                   lpszDestAddress,
                   lpszGroupID
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
linePickupA(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCSTR              lpszDestAddress,
    LPCSTR              lpszGroupID
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "linePickupA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   lphCall,
                   lpszDestAddress,
                   lpszGroupID
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
linePickupW(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCWSTR             lpszDestAddress,
    LPCWSTR             lpszGroupID
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "linePickupW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   lphCall,
                   lpszDestAddress,
                   lpszGroupID
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
linePrepareAddToConference(
    HCALL               hConfCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "linePrepareAddToConference", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hConfCall,
                   lphConsultCall,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
linePrepareAddToConferenceA(
    HCALL               hConfCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "linePrepareAddToConferenceA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hConfCall,
                   lphConsultCall,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
linePrepareAddToConferenceW(
    HCALL               hConfCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "linePrepareAddToConferenceW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hConfCall,
                   lphConsultCall,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineProxyMessage(
    HLINE               hLine,
    HCALL               hCall,
    DWORD               dwMsg,
    DWORD               dwParam1,
    DWORD               dwParam2,
    DWORD               dwParam3
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineProxyMessage", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   hCall,
                   dwMsg,
                   dwParam1,
                   dwParam2,
                   dwParam3
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineProxyResponse(
    HLINE               hLine,
    LPLINEPROXYREQUEST  lpProxyRequest,
    DWORD               dwResult
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineProxyResponse", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lpProxyRequest,
                   dwResult
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineRedirect(
    HCALL               hCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineRedirect", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpszDestAddress,
                   dwCountryCode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineRedirectA(
    HCALL               hCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineRedirectA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpszDestAddress,
                   dwCountryCode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineRedirectW(
    HCALL               hCall,
    LPCWSTR             lpszDestAddress,
    DWORD               dwCountryCode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineRedirectW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpszDestAddress,
                   dwCountryCode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineRegisterRequestRecipient(
    HLINEAPP            hLineApp,
    DWORD               dwRegistrationInstance,
    DWORD               dwRequestMode,
    DWORD               bEnable
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineRegisterRequestRecipient", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwRegistrationInstance,
                   dwRequestMode,
                   bEnable
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineReleaseUserUserInfo(
    HCALL               hCall
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineReleaseUserUserInfo", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineRemoveFromConference(
    HCALL               hCall
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineRemoveFromConference", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineRemoveProvider(
    DWORD               dwPermanentProviderID,
    HWND                hwndOwner
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineRemoveProvider", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwPermanentProviderID,
                   hwndOwner
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSecureCall(
    HCALL               hCall
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSecureCall", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSendUserUserInfo(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSendUserUserInfo", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpsUserUserInfo,
                   dwSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetAgentActivity(
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwActivityID
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetAgentActivity", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   dwActivityID
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetAgentGroup(
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTGROUPLIST    lpAgentGroupList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetAgentGroup", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   lpAgentGroupList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetAgentMeasurementPeriod(                                  // TAPI v2.2
    HLINE               hLine,
    HAGENT              hAgent,
    DWORD               dwMeasurementPeriod
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetAgentMeasurementPeriod", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   hAgent,
                   dwMeasurementPeriod
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetAgentSessionState(                                       // TAPI v2.2
    HLINE               hLine,
    HAGENTSESSION       hAgentSession,
    DWORD               dwSessionState,
    DWORD               dwNextSessionState
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetAgentSessionState", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   hAgentSession,
                   dwSessionState,
                   dwNextSessionState
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetAgentState(
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwAgentState,
    DWORD               dwNextAgentState
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetAgentState", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   dwAgentState,
                   dwNextAgentState
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetAgentStateEx(                                            // TAPI v2.2
    HLINE               hLine,
    HAGENT              hAgent,
    DWORD               dwSessionState,
    DWORD               dwNextSessionState
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetAgentStateEx", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   hAgent,
                   dwSessionState,
                   dwNextSessionState
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetAppPriority(
    LPCSTR              lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPCSTR              lpszExtensionName,
    DWORD               dwPriority
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetAppPriority", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   lpszAppFilename,
                   dwMediaMode,
                   lpExtensionID,
                   dwRequestMode,
                   lpszExtensionName,
                   dwPriority
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetAppPriorityA(
    LPCSTR              lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPCSTR              lpszExtensionName,
    DWORD               dwPriority
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetAppPriorityA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   lpszAppFilename,
                   dwMediaMode,
                   lpExtensionID,
                   dwRequestMode,
                   lpszExtensionName,
                   dwPriority
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetAppPriorityW(
    LPCWSTR             lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPCWSTR             lpszExtensionName,
    DWORD               dwPriority
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetAppPriorityW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   lpszAppFilename,
                   dwMediaMode,
                   lpExtensionID,
                   dwRequestMode,
                   lpszExtensionName,
                   dwPriority
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetAppSpecific(
    HCALL               hCall,
    DWORD               dwAppSpecific
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetAppSpecific", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwAppSpecific
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetCallData(
    HCALL               hCall,
    LPVOID              lpCallData,
    DWORD               dwSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetCallData", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpCallData,
                   dwSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetCallParams(
    HCALL               hCall,
    DWORD               dwBearerMode,
    DWORD               dwMinRate,
    DWORD               dwMaxRate,
    LPLINEDIALPARAMS    const lpDialParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetCallParams", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwBearerMode,
                   dwMinRate,
                   dwMaxRate,
                   lpDialParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetCallPrivilege(
    HCALL               hCall,
    DWORD               dwCallPrivilege
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetCallPrivilege", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwCallPrivilege
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetCallQualityOfService(
    HCALL               hCall,
    LPVOID              lpSendingFlowspec,
    DWORD               dwSendingFlowspecSize,
    LPVOID              lpReceivingFlowspec,
    DWORD               dwReceivingFlowspecSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetCallQualityOfService", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpSendingFlowspec,
                   dwSendingFlowspecSize,
                   lpReceivingFlowspec,
                   dwReceivingFlowspecSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetCallTreatment(
    HCALL               hCall,
    DWORD               dwTreatment
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetCallTreatment", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwTreatment
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetCurrentLocation(
    HLINEAPP            hLineApp,
    DWORD               dwLocation
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetCurrentLocation", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwLocation
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetDevConfig(
    DWORD               dwDeviceID,
    LPVOID              const lpDeviceConfig,
    DWORD               dwSize,
    LPCSTR              lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetDevConfig", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   lpDeviceConfig,
                   dwSize,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetDevConfigA(
    DWORD               dwDeviceID,
    LPVOID              const lpDeviceConfig,
    DWORD               dwSize,
    LPCSTR              lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetDevConfigA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   lpDeviceConfig,
                   dwSize,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetDevConfigW(
    DWORD               dwDeviceID,
    LPVOID              const lpDeviceConfig,
    DWORD               dwSize,
    LPCWSTR             lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetDevConfigW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   lpDeviceConfig,
                   dwSize,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetLineDevStatus(
    HLINE               hLine,
    DWORD               dwStatusToChange,
    DWORD               fStatus
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetLineDevStatus", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwStatusToChange,
                   fStatus
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetMediaControl(
    HLINE                       hLine,
    DWORD                       dwAddressID,
    HCALL                       hCall,
    DWORD                       dwSelect,
    LPLINEMEDIACONTROLDIGIT     const lpDigitList,
    DWORD                       dwDigitNumEntries,
    LPLINEMEDIACONTROLMEDIA     const lpMediaList,
    DWORD                       dwMediaNumEntries,
    LPLINEMEDIACONTROLTONE      const lpToneList,
    DWORD                       dwToneNumEntries,
    LPLINEMEDIACONTROLCALLSTATE const lpCallStateList, 
    DWORD                       dwCallStateNumEntries
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetMediaControl", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   hCall,
                   dwSelect,
                   lpDigitList,
                   dwDigitNumEntries,
                   lpMediaList,
                   dwMediaNumEntries,
                   lpToneList,
                   dwToneNumEntries,
                   lpCallStateList, 
                   dwCallStateNumEntries
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetMediaMode(
    HCALL               hCall,
    DWORD               dwMediaModes
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetMediaMode", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwMediaModes
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetNumRings(
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwNumRings
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetNumRings", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   dwNumRings
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetQueueMeasurementPeriod(                                  // TAPI v2.2
    HLINE               hLine,
    DWORD               dwQueueID,
    DWORD               dwMeasurementPeriod
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetQueueMeasurementPeriod", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwQueueID,
                   dwMeasurementPeriod
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetStatusMessages(
    HLINE               hLine,
    DWORD               dwLineStates,
    DWORD               dwAddressStates
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetStatusMessages", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwLineStates,
                   dwAddressStates
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetTerminal(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    DWORD               dwSelect,
    DWORD               dwTerminalModes,
    DWORD               dwTerminalID,
    DWORD               bEnable
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetTerminal", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   hCall,
                   dwSelect,
                   dwTerminalModes,
                   dwTerminalID,
                   bEnable
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetTollList(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    LPCSTR              lpszAddressIn,
    DWORD               dwTollListOption
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetTollList", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   lpszAddressIn,
                   dwTollListOption
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetTollListA(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    LPCSTR              lpszAddressIn,
    DWORD               dwTollListOption
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetTollListA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   lpszAddressIn,
                   dwTollListOption
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetTollListW(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    LPCWSTR             lpszAddressInW,
    DWORD               dwTollListOption
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetTollListW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   lpszAddressInW,
                   dwTollListOption
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetupConference(
    HCALL               hCall,
    HLINE               hLine,
    LPHCALL             lphConfCall,
    LPHCALL             lphConsultCall,
    DWORD               dwNumParties,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetupConference", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   hLine,
                   lphConfCall,
                   lphConsultCall,
                   dwNumParties,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetupConferenceA(
    HCALL               hCall,
    HLINE               hLine,
    LPHCALL             lphConfCall,
    LPHCALL             lphConsultCall,
    DWORD               dwNumParties,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetupConferenceA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   hLine,
                   lphConfCall,
                   lphConsultCall,
                   dwNumParties,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetupConferenceW(
    HCALL               hCall,
    HLINE               hLine,
    LPHCALL             lphConfCall,
    LPHCALL             lphConsultCall,
    DWORD               dwNumParties,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetupConferenceW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   hLine,
                   lphConfCall,
                   lphConsultCall,
                   dwNumParties,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetupTransfer(
    HCALL               hCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetupTransfer", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lphConsultCall,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetupTransferA(
    HCALL               hCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetupTransferA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lphConsultCall,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetupTransferW(
    HCALL               hCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetupTransferW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lphConsultCall,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineShutdown(
    HLINEAPP            hLineApp
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineShutdown", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSwapHold(
    HCALL               hActiveCall,
    HCALL               hHeldCall
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSwapHold", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hActiveCall,
                   hHeldCall
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineTranslateAddress(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAPIVersion,
    LPCSTR                  lpszAddressIn,
    DWORD                   dwCard,
    DWORD                   dwTranslateOptions,
    LPLINETRANSLATEOUTPUT   lpTranslateOutput
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineTranslateAddress", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAPIVersion,
                   lpszAddressIn,
                   dwCard,
                   dwTranslateOptions,
                   lpTranslateOutput
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineTranslateAddressA(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAPIVersion,
    LPCSTR                  lpszAddressIn,
    DWORD                   dwCard,
    DWORD                   dwTranslateOptions,
    LPLINETRANSLATEOUTPUT   lpTranslateOutput
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineTranslateAddressA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAPIVersion,
                   lpszAddressIn,
                   dwCard,
                   dwTranslateOptions,
                   lpTranslateOutput
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineTranslateAddressW(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAPIVersion,
    LPCWSTR                 lpszAddressIn,
    DWORD                   dwCard,
    DWORD                   dwTranslateOptions,
    LPLINETRANSLATEOUTPUT   lpTranslateOutput
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineTranslateAddressW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAPIVersion,
                   lpszAddressIn,
                   dwCard,
                   dwTranslateOptions,
                   lpTranslateOutput
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineTranslateDialog(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    HWND                hwndOwner,
    LPCSTR              lpszAddressIn
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineTranslateDialog", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAPIVersion,
                   hwndOwner,
                   lpszAddressIn
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineTranslateDialogA(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    HWND                hwndOwner,
    LPCSTR              lpszAddressIn
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineTranslateDialogA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAPIVersion,
                   hwndOwner,
                   lpszAddressIn
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineTranslateDialogW(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    HWND                hwndOwner,
    LPCWSTR             lpszAddressIn
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineTranslateDialogW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAPIVersion,
                   hwndOwner,
                   lpszAddressIn
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineUncompleteCall(
    HLINE               hLine,
    DWORD               dwCompletionID
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineUncompleteCall", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwCompletionID
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineUnhold(
    HCALL               hCall
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineUnhold", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineUnpark(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCSTR              lpszDestAddress
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineUnpark", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   lphCall,
                   lpszDestAddress
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineUnparkA(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCSTR              lpszDestAddress
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineUnparkA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   lphCall,
                   lpszDestAddress
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineUnparkW(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCWSTR             lpszDestAddress
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineUnparkW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   lphCall,
                   lpszDestAddress
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneClose(
    HPHONE              hPhone
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneClose", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneConfigDialog(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR              lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneConfigDialog", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   hwndOwner,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneConfigDialogA(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR              lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneConfigDialogA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   hwndOwner,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneConfigDialogW(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCWSTR             lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneConfigDialogW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   hwndOwner,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneDevSpecific(
    HPHONE              hPhone,
    LPVOID              lpParams,
    DWORD               dwSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneDevSpecific", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   lpParams,
                   dwSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetButtonInfo(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   lpButtonInfo
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetButtonInfo", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwButtonLampID,
                   lpButtonInfo
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetButtonInfoA(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   lpButtonInfo
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetButtonInfoA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwButtonLampID,
                   lpButtonInfo
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetButtonInfoW(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   lpButtonInfo
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetButtonInfoW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwButtonLampID,
                   lpButtonInfo
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetData(
    HPHONE              hPhone,
    DWORD               dwDataID,
    LPVOID              lpData,
    DWORD               dwSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetData", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwDataID,
                   lpData,
                   dwSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetDevCaps(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPPHONECAPS         lpPhoneCaps
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetDevCaps", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhoneApp,
                   dwDeviceID,
                   dwAPIVersion,
                   dwExtVersion,
                   lpPhoneCaps
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetDevCapsA(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPPHONECAPS         lpPhoneCaps
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetDevCapsA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhoneApp,
                   dwDeviceID,
                   dwAPIVersion,
                   dwExtVersion,
                   lpPhoneCaps
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetDevCapsW(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPPHONECAPS         lpPhoneCaps
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetDevCapsW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhoneApp,
                   dwDeviceID,
                   dwAPIVersion,
                   dwExtVersion,
                   lpPhoneCaps
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetDisplay(
    HPHONE              hPhone,
    LPVARSTRING         lpDisplay
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetDisplay", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   lpDisplay
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetGain(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    LPDWORD             lpdwGain
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetGain", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwHookSwitchDev,
                   lpdwGain
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetHookSwitch(
    HPHONE              hPhone,
    LPDWORD             lpdwHookSwitchDevs
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetHookSwitch", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   lpdwHookSwitchDevs
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetIcon(
    DWORD               dwDeviceID,
    LPCSTR              lpszDeviceClass,
    LPHICON             lphIcon
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetIcon", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   lpszDeviceClass,
                   lphIcon
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetIconA(
    DWORD               dwDeviceID,
    LPCSTR              lpszDeviceClass,
    LPHICON             lphIcon
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetIconA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   lpszDeviceClass,
                   lphIcon
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetIconW(
    DWORD               dwDeviceID,
    LPCWSTR             lpszDeviceClass,
    LPHICON             lphIcon
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetIconW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   lpszDeviceClass,
                   lphIcon
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetID(
    HPHONE              hPhone,
    LPVARSTRING         lpDeviceID,
    LPCSTR              lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetID", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   lpDeviceID,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetIDA(
    HPHONE              hPhone,
    LPVARSTRING         lpDeviceID,
    LPCSTR              lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetIDA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   lpDeviceID,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetIDW(
    HPHONE              hPhone,
    LPVARSTRING         lpDeviceID,
    LPCWSTR             lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetIDW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   lpDeviceID,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetLamp(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPDWORD             lpdwLampMode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetLamp", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwButtonLampID,
                   lpdwLampMode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetMessage(
    HPHONEAPP       hPhoneApp,
    LPPHONEMESSAGE  lpMessage,
    DWORD           dwTimeout
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetMessage", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhoneApp,
                   lpMessage,
                   dwTimeout
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetRing(
    HPHONE              hPhone,
    LPDWORD             lpdwRingMode,
    LPDWORD             lpdwVolume
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetRing", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   lpdwRingMode,
                   lpdwVolume
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetStatus(
    HPHONE              hPhone,
    LPPHONESTATUS       lpPhoneStatus
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetStatus", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   lpPhoneStatus
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetStatusA(
    HPHONE              hPhone,
    LPPHONESTATUS       lpPhoneStatus
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetStatusA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   lpPhoneStatus
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetStatusW(
    HPHONE              hPhone,
    LPPHONESTATUS       lpPhoneStatus
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetStatusW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   lpPhoneStatus
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetStatusMessages(
    HPHONE              hPhone,
    LPDWORD             lpdwPhoneStates,
    LPDWORD             lpdwButtonModes,
    LPDWORD             lpdwButtonStates
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetStatusMessages", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   lpdwPhoneStates,
                   lpdwButtonModes,
                   lpdwButtonStates
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetVolume(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    LPDWORD             lpdwVolume
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetVolume", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwHookSwitchDev,
                   lpdwVolume
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneInitialize(
    LPHPHONEAPP         lphPhoneApp,
    HINSTANCE           hInstance,
    PHONECALLBACK       lpfnCallback,
    LPCSTR              lpszAppName,
    LPDWORD             lpdwNumDevs
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneInitialize", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   lphPhoneApp,
                   hInstance,
                   lpfnCallback,
                   lpszAppName,
                   lpdwNumDevs
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneInitializeExA(
    LPHPHONEAPP                 lphPhoneApp,
    HINSTANCE                   hInstance,
    PHONECALLBACK               lpfnCallback,
    LPCSTR                      lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPPHONEINITIALIZEEXPARAMS   lpPhoneInitializeExParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneInitializeExA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   lphPhoneApp,
                   hInstance,
                   lpfnCallback,
                   lpszFriendlyAppName,
                   lpdwNumDevs,
                   lpdwAPIVersion,
                   lpPhoneInitializeExParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneInitializeExW(
    LPHPHONEAPP                 lphPhoneApp,
    HINSTANCE                   hInstance,
    PHONECALLBACK               lpfnCallback,
    LPCWSTR                     lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPPHONEINITIALIZEEXPARAMS   lpPhoneInitializeExParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneInitializeExW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   lphPhoneApp,
                   hInstance,
                   lpfnCallback,
                   lpszFriendlyAppName,
                   lpdwNumDevs,
                   lpdwAPIVersion,
                   lpPhoneInitializeExParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneNegotiateAPIVersion(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPILowVersion,
    DWORD               dwAPIHighVersion,
    LPDWORD             lpdwAPIVersion,
    LPPHONEEXTENSIONID  lpExtensionID
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneNegotiateAPIVersion", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhoneApp,
                   dwDeviceID,
                   dwAPILowVersion,
                   dwAPIHighVersion,
                   lpdwAPIVersion,
                   lpExtensionID
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneNegotiateExtVersion(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtLowVersion,
    DWORD               dwExtHighVersion,
    LPDWORD             lpdwExtVersion
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneNegotiateExtVersion", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhoneApp,
                   dwDeviceID,
                   dwAPIVersion,
                   dwExtLowVersion,
                   dwExtHighVersion,
                   lpdwExtVersion
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneOpen(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    LPHPHONE            lphPhone,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD_PTR           dwCallbackInstance,
    DWORD               dwPrivilege
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneOpen", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhoneApp,
                   dwDeviceID,
                   lphPhone,
                   dwAPIVersion,
                   dwExtVersion,
                   dwCallbackInstance,
                   dwPrivilege
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneSetButtonInfo(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   const lpButtonInfo
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneSetButtonInfo", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwButtonLampID,
                   lpButtonInfo
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneSetButtonInfoA(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   const lpButtonInfo
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneSetButtonInfoA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwButtonLampID,
                   lpButtonInfo
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneSetButtonInfoW(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   const lpButtonInfo
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneSetButtonInfoW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwButtonLampID,
                   lpButtonInfo
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneSetData(
    HPHONE              hPhone,
    DWORD               dwDataID,
    LPVOID              const lpData,
    DWORD               dwSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneSetData", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwDataID,
                   lpData,
                   dwSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneSetDisplay(
    HPHONE              hPhone,
    DWORD               dwRow,
    DWORD               dwColumn,
    LPCSTR              lpsDisplay,
    DWORD               dwSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneSetDisplay", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwRow,
                   dwColumn,
                   lpsDisplay,
                   dwSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneSetGain(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    DWORD               dwGain
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneSetGain", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwHookSwitchDev,
                   dwGain
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneSetHookSwitch(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDevs,
    DWORD               dwHookSwitchMode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneSetHookSwitch", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwHookSwitchDevs,
                   dwHookSwitchMode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneSetLamp(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    DWORD               dwLampMode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneSetLamp", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwButtonLampID,
                   dwLampMode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneSetRing(
    HPHONE              hPhone,
    DWORD               dwRingMode,
    DWORD               dwVolume
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneSetRing", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwRingMode,
                   dwVolume
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneSetStatusMessages(
    HPHONE              hPhone,
    DWORD               dwPhoneStates,
    DWORD               dwButtonModes,
    DWORD               dwButtonStates
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneSetStatusMessages", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwPhoneStates,
                   dwButtonModes,
                   dwButtonStates
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneSetVolume(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    DWORD               dwVolume
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneSetVolume", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwHookSwitchDev,
                   dwVolume
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneShutdown(
    HPHONEAPP           hPhoneApp
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneShutdown", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhoneApp
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
tapiGetLocationInfo(
    LPSTR               lpszCountryCode,
    LPSTR               lpszCityCode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "tapiGetLocationInfo", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return TAPIERR_REQUESTFAILED;
   }

   return (*lpfn)(
                   lpszCountryCode,
                   lpszCityCode
                 );
}
    
//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
tapiGetLocationInfoA(
    LPSTR               lpszCountryCode,
    LPSTR               lpszCityCode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "tapiGetLocationInfoA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return TAPIERR_REQUESTFAILED;
   }

   return (*lpfn)(
                   lpszCountryCode,
                   lpszCityCode
                 );
}
    
//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
tapiGetLocationInfoW(
    LPWSTR               lpszCountryCodeW,
    LPWSTR               lpszCityCodeW
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "tapiGetLocationInfoW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return TAPIERR_REQUESTFAILED;
   }

   return (*lpfn)(
                   lpszCountryCodeW,
                   lpszCityCodeW
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
tapiRequestDrop(
    HWND                hwnd,
    WPARAM              wRequestID
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "tapiRequestDrop", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return TAPIERR_REQUESTFAILED;
   }

   return (*lpfn)(
                   hwnd,
                   wRequestID
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
tapiRequestMakeCall(
    LPCSTR              lpszDestAddress,
    LPCSTR              lpszAppName,
    LPCSTR              lpszCalledParty,
    LPCSTR              lpszComment
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "tapiRequestMakeCall", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return TAPIERR_REQUESTFAILED;
   }

   return (*lpfn)(
                   lpszDestAddress,
                   lpszAppName,
                   lpszCalledParty,
                   lpszComment
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
tapiRequestMakeCallA(
    LPCSTR              lpszDestAddress,
    LPCSTR              lpszAppName,
    LPCSTR              lpszCalledParty,
    LPCSTR              lpszComment
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "tapiRequestMakeCallA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return TAPIERR_REQUESTFAILED;
   }

   return (*lpfn)(
                   lpszDestAddress,
                   lpszAppName,
                   lpszCalledParty,
                   lpszComment
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
tapiRequestMakeCallW(
    LPCWSTR             lpszDestAddress,
    LPCWSTR             lpszAppName,
    LPCWSTR             lpszCalledParty,
    LPCWSTR             lpszComment
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "tapiRequestMakeCallW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return TAPIERR_REQUESTFAILED;
   }

   return (*lpfn)(
                   lpszDestAddress,
                   lpszAppName,
                   lpszCalledParty,
                   lpszComment
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
tapiRequestMediaCall(
    HWND                hwnd,
    WPARAM              wRequestID,
    LPCSTR              lpszDeviceClass,
    LPCSTR              lpDeviceID,
    DWORD               dwSize,
    DWORD               dwSecure,
    LPCSTR              lpszDestAddress,
    LPCSTR              lpszAppName,
    LPCSTR              lpszCalledParty,
    LPCSTR              lpszComment
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "tapiRequestMediaCall", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return TAPIERR_REQUESTFAILED;
   }

   return (*lpfn)(
                   hwnd,
                   wRequestID,
                   lpszDeviceClass,
                   lpDeviceID,
                   dwSize,
                   dwSecure,
                   lpszDestAddress,
                   lpszAppName,
                   lpszCalledParty,
                   lpszComment
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
tapiRequestMediaCallA(
    HWND                hwnd,
    WPARAM              wRequestID,
    LPCSTR              lpszDeviceClass,
    LPCSTR              lpDeviceID,
    DWORD               dwSize,
    DWORD               dwSecure,
    LPCSTR              lpszDestAddress,
    LPCSTR              lpszAppName,
    LPCSTR              lpszCalledParty,
    LPCSTR              lpszComment
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "tapiRequestMediaCallA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return TAPIERR_REQUESTFAILED;
   }

   return (*lpfn)(
                   hwnd,
                   wRequestID,
                   lpszDeviceClass,
                   lpDeviceID,
                   dwSize,
                   dwSecure,
                   lpszDestAddress,
                   lpszAppName,
                   lpszCalledParty,
                   lpszComment
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
tapiRequestMediaCallW(
    HWND                hwnd,
    WPARAM              wRequestID,
    LPCWSTR             lpszDeviceClass,
    LPCWSTR             lpDeviceID,
    DWORD               dwSize,
    DWORD               dwSecure,
    LPCWSTR             lpszDestAddress,
    LPCWSTR             lpszAppName,
    LPCWSTR             lpszCalledParty,
    LPCWSTR             lpszComment
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "tapiRequestMediaCallW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return TAPIERR_REQUESTFAILED;
   }

   return (*lpfn)(
                   hwnd,
                   wRequestID,
                   lpszDeviceClass,
                   lpDeviceID,
                   dwSize,
                   dwSecure,
                   lpszDestAddress,
                   lpszAppName,
                   lpszCalledParty,
                   lpszComment
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\inc\h245if.h ===
/* Copyright (C) Microsoft Corporation 1999, All rights reserved. */

#ifndef __H245FMT_H__
#define __H245FMT_H__

#ifdef __cplusplus
extern "C" {
#endif

/*

	This file defines the structural interface that exists between
	installable H.245-compatible filter components and core TAPI MSP
	components. 

*/


// FORMAT_H245VERSION indicates the version number of H.245 that
// was in effect at the time the module was compiled.  Core MSP 
// maintain backward compatibility with modules compiled using this 
// header file. 
#define FORMAT_H245VERSION	3

/*
	The following data types are defined here to be consistent with 
	the ASN.1 library that is/was used to build TAPI core components.  
	If the ASN core files are also to be included, they must be included 
	before including this file. 
*/

#ifndef __MS_ASN1_H__ // avoid duplicate definitions when msasn1.h is included
#define __MS_ASN1_H__

/* ------ Basic integer types ------ */

typedef unsigned char   ASN1uint8_t;
typedef signed char     ASN1int8_t;

typedef unsigned short  ASN1uint16_t;
typedef signed short    ASN1int16_t;

typedef unsigned long   ASN1uint32_t;
typedef signed long     ASN1int32_t;

typedef ASN1int32_t     ASN1enum_t;     // enumerated type
typedef ASN1uint16_t    ASN1choice_t;   // choice


/* ------ Basic ASN.1 types ------ */

typedef ASN1uint8_t ASN1octet_t;
typedef ASN1uint8_t ASN1bool_t;

typedef struct ASN1objectidentifier_s
{
    struct ASN1objectidentifier_s *next;
    ASN1uint32_t value;
}*ASN1objectidentifier_t;

typedef struct tagASN1octetstring_t
{
    ASN1uint32_t length;
    ASN1octet_t *value;
}ASN1octetstring_t;

#endif __MS_ASN1_H__

#ifndef _H245ASN_Module_H_  // avoid duplicate definitions when h245asn.h is included
#define _H245ASN_Module_H_
    

/* ------ H.245 audio and video structures ------ */

typedef ASN1uint16_t CustomPictureFormat_pixelAspectInformation_pixelAspectCode_Set;
typedef ASN1uint16_t RTPH263VideoRedundancyEncoding_containedThreads_Seq;
typedef ASN1uint16_t RTPH263VideoRedundancyFrameMapping_frameSequence_Seq;

typedef struct RedundancyEncodingCapability_secondaryEncoding * PRedundancyEncodingCapability_secondaryEncoding;
typedef struct RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom * PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom;
typedef struct H263Options_customPictureFormat * PH263Options_customPictureFormat;
typedef struct H263Options_customPictureClockFrequency * PH263Options_customPictureClockFrequency;
typedef struct H263Options_modeCombos * PH263Options_modeCombos;
typedef struct EnhancementLayerInfo_bPictureEnhancement * PEnhancementLayerInfo_bPictureEnhancement;
typedef struct EnhancementLayerInfo_spatialEnhancement * PEnhancementLayerInfo_spatialEnhancement;
typedef struct EnhancementLayerInfo_snrEnhancement * PEnhancementLayerInfo_snrEnhancement;
typedef struct H2250Capability_redundancyEncodingCapability * PH2250Capability_redundancyEncodingCapability;
typedef struct EncryptionCapability * PEncryptionCapability;


typedef ASN1uint16_t CapabilityTableEntryNumber;

   
typedef struct NonStandardIdentifier_h221NonStandard {
    ASN1uint16_t t35CountryCode;
    ASN1uint16_t t35Extension;
    ASN1uint16_t manufacturerCode;
} NonStandardIdentifier_h221NonStandard;

typedef struct NonStandardIdentifier {
    ASN1choice_t choice;
    union {
#	define object_chosen 1
	ASN1objectidentifier_t object;
#	define h221NonStandard_chosen 2
	NonStandardIdentifier_h221NonStandard h221NonStandard;
    } u;
} NonStandardIdentifier;

typedef struct NonStandardParameter {
    NonStandardIdentifier nonStandardIdentifier;
    ASN1octetstring_t data;
} NonStandardParameter;

typedef struct CustomPictureFormat_pixelAspectInformation_extendedPAR_Set {
    ASN1uint16_t width;
    ASN1uint16_t height;
} CustomPictureFormat_pixelAspectInformation_extendedPAR_Set;

typedef struct CustomPictureFormat_mPI_customPCF_Set {
    ASN1uint16_t clockConversionCode;
    ASN1uint16_t clockDivisor;
    ASN1uint16_t customMPI;
} CustomPictureFormat_mPI_customPCF_Set;

typedef struct VCCapability_availableBitRates_type_rangeOfBitRates {
    ASN1uint16_t lowerBitRate;
    ASN1uint16_t higherBitRate;
} VCCapability_availableBitRates_type_rangeOfBitRates;

typedef struct CustomPictureFormat_mPI_customPCF {
    ASN1uint32_t count;
    CustomPictureFormat_mPI_customPCF_Set value[16];
} CustomPictureFormat_mPI_customPCF;

typedef struct CustomPictureFormat_pixelAspectInformation_extendedPAR {
    ASN1uint32_t count;
    CustomPictureFormat_pixelAspectInformation_extendedPAR_Set value[256];
} CustomPictureFormat_pixelAspectInformation_extendedPAR;

typedef struct CustomPictureFormat_pixelAspectInformation_pixelAspectCode {
    ASN1uint32_t count;
    CustomPictureFormat_pixelAspectInformation_pixelAspectCode_Set value[14];
} CustomPictureFormat_pixelAspectInformation_pixelAspectCode;


typedef struct H263VideoMode_resolution {
    ASN1choice_t choice;
#   define sqcif_chosen 1
#   define H263VideoMode_resolution_qcif_chosen 2
#   define H263VideoMode_resolution_cif_chosen 3
#   define cif4_chosen 4
#   define cif16_chosen 5
} H263VideoMode_resolution;

typedef struct H262VideoMode_profileAndLevel {
    ASN1choice_t choice;
#   define profileAndLevel_SPatML_chosen 1
#   define profileAndLevel_MPatLL_chosen 2
#   define profileAndLevel_MPatML_chosen 3
#   define profileAndLevel_MPatH_14_chosen 4
#   define profileAndLevel_MPatHL_chosen 5
#   define profileAndLevel_SNRatLL_chosen 6
#   define profileAndLevel_SNRatML_chosen 7
#   define profileAndLevel_SpatialatH_14_chosen 8
#   define profileAndLevel_HPatML_chosen 9
#   define profileAndLevel_HPatH_14_chosen 10
#   define profileAndLevel_HPatHL_chosen 11
} H262VideoMode_profileAndLevel;

typedef struct H261VideoMode_resolution {
    ASN1choice_t choice;
#   define H261VideoMode_resolution_qcif_chosen 1
#   define H261VideoMode_resolution_cif_chosen 2
} H261VideoMode_resolution;

typedef struct CustomPictureFormat_pixelAspectInformation {
    ASN1choice_t choice;
    union {
#	define anyPixelAspectRatio_chosen 1
	ASN1bool_t anyPixelAspectRatio;
#	define pixelAspectCode_chosen 2
	CustomPictureFormat_pixelAspectInformation_pixelAspectCode pixelAspectCode;
#	define extendedPAR_chosen 3
	CustomPictureFormat_pixelAspectInformation_extendedPAR extendedPAR;
    } u;
} CustomPictureFormat_pixelAspectInformation;

typedef struct CustomPictureFormat_mPI {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define standardMPI_present 0x80
    ASN1uint16_t standardMPI;
#   define customPCF_present 0x40
    CustomPictureFormat_mPI_customPCF customPCF;
} CustomPictureFormat_mPI;

typedef struct RefPictureSelection_videoBackChannelSend {
    ASN1choice_t choice;
#   define RefPictureSelection_videoBackChannelSend_none_chosen 1
#   define ackMessageOnly_chosen 2
#   define nackMessageOnly_chosen 3
#   define ackOrNackMessageOnly_chosen 4
#   define ackAndNackMessage_chosen 5
} RefPictureSelection_videoBackChannelSend;

typedef struct RefPictureSelection_additionalPictureMemory {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define sqcifAdditionalPictureMemory_present 0x80
    ASN1uint16_t sqcifAdditionalPictureMemory;
#   define qcifAdditionalPictureMemory_present 0x40
    ASN1uint16_t qcifAdditionalPictureMemory;
#   define cifAdditionalPictureMemory_present 0x20
    ASN1uint16_t cifAdditionalPictureMemory;
#   define cif4AdditionalPictureMemory_present 0x10
    ASN1uint16_t cif4AdditionalPictureMemory;
#   define cif16AdditionalPictureMemory_present 0x8
    ASN1uint16_t cif16AdditionalPictureMemory;
#   define bigCpfAdditionalPictureMemory_present 0x4
    ASN1uint16_t bigCpfAdditionalPictureMemory;
} RefPictureSelection_additionalPictureMemory;

typedef struct RTPH263VideoRedundancyFrameMapping_frameSequence {
    ASN1uint32_t count;
    RTPH263VideoRedundancyFrameMapping_frameSequence_Seq value[256];
} RTPH263VideoRedundancyFrameMapping_frameSequence;

typedef struct RTPH263VideoRedundancyEncoding_containedThreads {
    ASN1uint32_t count;
    RTPH263VideoRedundancyEncoding_containedThreads_Seq value[256];
} RTPH263VideoRedundancyEncoding_containedThreads;

typedef struct RTPH263VideoRedundancyEncoding_frameToThreadMapping {
    ASN1choice_t choice;
    union {
#	define roundrobin_chosen 1
#	define custom_chosen 2
	PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom custom;
    } u;
} RTPH263VideoRedundancyEncoding_frameToThreadMapping;

typedef struct RedundancyEncodingCapability_secondaryEncoding {
    PRedundancyEncodingCapability_secondaryEncoding next;
    CapabilityTableEntryNumber value;
} RedundancyEncodingCapability_secondaryEncoding_Element;


typedef struct RTPH263VideoRedundancyEncoding {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t numberOfThreads;
    ASN1uint16_t framesBetweenSyncPoints;
    RTPH263VideoRedundancyEncoding_frameToThreadMapping frameToThreadMapping;
#   define containedThreads_present 0x80
    RTPH263VideoRedundancyEncoding_containedThreads containedThreads;
} RTPH263VideoRedundancyEncoding;

typedef struct RTPH263VideoRedundancyFrameMapping {
    ASN1uint16_t threadNumber;
    RTPH263VideoRedundancyFrameMapping_frameSequence frameSequence;
} RTPH263VideoRedundancyFrameMapping;

typedef struct H261VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H261VideoCapability_qcifMPI_present 0x80
    ASN1uint16_t qcifMPI;
#   define H261VideoCapability_cifMPI_present 0x40
    ASN1uint16_t cifMPI;
    ASN1bool_t temporalSpatialTradeOffCapability;
    ASN1uint16_t maxBitRate;
    ASN1bool_t stillImageTransmission;
} H261VideoCapability;

typedef struct H262VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t profileAndLevel_SPatML;
    ASN1bool_t profileAndLevel_MPatLL;
    ASN1bool_t profileAndLevel_MPatML;
    ASN1bool_t profileAndLevel_MPatH_14;
    ASN1bool_t profileAndLevel_MPatHL;
    ASN1bool_t profileAndLevel_SNRatLL;
    ASN1bool_t profileAndLevel_SNRatML;
    ASN1bool_t profileAndLevel_SpatialatH_14;
    ASN1bool_t profileAndLevel_HPatML;
    ASN1bool_t profileAndLevel_HPatH_14;
    ASN1bool_t profileAndLevel_HPatHL;
#   define H262VideoCapability_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define H262VideoCapability_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define H262VideoCapability_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define H262VideoCapability_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define H262VideoCapability_framesPerSecond_present 0x8
    ASN1uint16_t framesPerSecond;
#   define H262VideoCapability_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} H262VideoCapability;


typedef struct EnhancementLayerInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t baseBitRateConstrained;
#   define snrEnhancement_present 0x80
    PEnhancementLayerInfo_snrEnhancement snrEnhancement;
#   define spatialEnhancement_present 0x40
    PEnhancementLayerInfo_spatialEnhancement spatialEnhancement;
#   define bPictureEnhancement_present 0x20
    PEnhancementLayerInfo_bPictureEnhancement bPictureEnhancement;
} EnhancementLayerInfo;

typedef struct TransparencyParameters {
    ASN1uint16_t presentationOrder;
    ASN1int32_t offset_x;
    ASN1int32_t offset_y;
    ASN1uint16_t scale_x;
    ASN1uint16_t scale_y;
} TransparencyParameters;

typedef struct RefPictureSelection {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define additionalPictureMemory_present 0x80
    RefPictureSelection_additionalPictureMemory additionalPictureMemory;
    ASN1bool_t videoMux;
    RefPictureSelection_videoBackChannelSend videoBackChannelSend;
} RefPictureSelection;

typedef struct CustomPictureClockFrequency {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t clockConversionCode;
    ASN1uint16_t clockDivisor;
#   define CustomPictureClockFrequency_sqcifMPI_present 0x80
    ASN1uint16_t sqcifMPI;
#   define CustomPictureClockFrequency_qcifMPI_present 0x40
    ASN1uint16_t qcifMPI;
#   define CustomPictureClockFrequency_cifMPI_present 0x20
    ASN1uint16_t cifMPI;
#   define CustomPictureClockFrequency_cif4MPI_present 0x10
    ASN1uint16_t cif4MPI;
#   define CustomPictureClockFrequency_cif16MPI_present 0x8
    ASN1uint16_t cif16MPI;
} CustomPictureClockFrequency;


typedef struct CustomPictureFormat {
    ASN1uint16_t maxCustomPictureWidth;
    ASN1uint16_t maxCustomPictureHeight;
    ASN1uint16_t minCustomPictureWidth;
    ASN1uint16_t minCustomPictureHeight;
    CustomPictureFormat_mPI mPI;
    CustomPictureFormat_pixelAspectInformation pixelAspectInformation;
} CustomPictureFormat;

typedef struct H263ModeComboFlags {
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
    ASN1bool_t advancedIntraCodingMode;
    ASN1bool_t deblockingFilterMode;
    ASN1bool_t unlimitedMotionVectors;
    ASN1bool_t slicesInOrder_NonRect;
    ASN1bool_t slicesInOrder_Rect;
    ASN1bool_t slicesNoOrder_NonRect;
    ASN1bool_t slicesNoOrder_Rect;
    ASN1bool_t improvedPBFramesMode;
    ASN1bool_t referencePicSelect;
    ASN1bool_t dynamicPictureResizingByFour;
    ASN1bool_t dynamicPictureResizingSixteenthPel;
    ASN1bool_t dynamicWarpingHalfPel;
    ASN1bool_t dynamicWarpingSixteenthPel;
    ASN1bool_t reducedResolutionUpdate;
    ASN1bool_t independentSegmentDecoding;
    ASN1bool_t alternateInterVLCMode;
    ASN1bool_t modifiedQuantizationMode;
} H263ModeComboFlags;

typedef struct IS11172VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t constrainedBitstream;
#   define IS11172VideoCapability_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define IS11172VideoCapability_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define IS11172VideoCapability_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define IS11172VideoCapability_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define IS11172VideoCapability_pictureRate_present 0x8
    ASN1uint16_t pictureRate;
#   define IS11172VideoCapability_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} IS11172VideoCapability;

typedef struct H261VideoMode {
    H261VideoMode_resolution resolution;
    ASN1uint16_t bitRate;
    ASN1bool_t stillImageTransmission;
} H261VideoMode;

typedef struct H262VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H262VideoMode_profileAndLevel profileAndLevel;
#   define H262VideoMode_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define H262VideoMode_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define H262VideoMode_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define H262VideoMode_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define H262VideoMode_framesPerSecond_present 0x8
    ASN1uint16_t framesPerSecond;
#   define H262VideoMode_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} H262VideoMode;

typedef struct IS11172VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t constrainedBitstream;
#   define IS11172VideoMode_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define IS11172VideoMode_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define IS11172VideoMode_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define IS11172VideoMode_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define IS11172VideoMode_pictureRate_present 0x8
    ASN1uint16_t pictureRate;
#   define IS11172VideoMode_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} IS11172VideoMode;


typedef struct RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom {
    PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom next;
    RTPH263VideoRedundancyFrameMapping value;
} RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_Element;

typedef struct H263VideoModeCombos_h263VideoCoupledModes {
    ASN1uint32_t count;
    H263ModeComboFlags value[16];
} H263VideoModeCombos_h263VideoCoupledModes;

typedef struct H263Options_customPictureFormat {
    PH263Options_customPictureFormat next;
    CustomPictureFormat value;
} H263Options_customPictureFormat_Element;

typedef struct H263Options_customPictureClockFrequency {
    PH263Options_customPictureClockFrequency next;
    CustomPictureClockFrequency value;
} H263Options_customPictureClockFrequency_Element;

typedef struct H263VideoModeCombos {
    H263ModeComboFlags h263VideoUncoupledModes;
    H263VideoModeCombos_h263VideoCoupledModes h263VideoCoupledModes;
} H263VideoModeCombos;

typedef struct H263Options_modeCombos {
    PH263Options_modeCombos next;
    H263VideoModeCombos value;
} H263Options_modeCombos_Element;

typedef struct H263Options {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t advancedIntraCodingMode;
    ASN1bool_t deblockingFilterMode;
    ASN1bool_t improvedPBFramesMode;
    ASN1bool_t unlimitedMotionVectors;
    ASN1bool_t fullPictureFreeze;
    ASN1bool_t partialPictureFreezeAndRelease;
    ASN1bool_t resizingPartPicFreezeAndRelease;
    ASN1bool_t fullPictureSnapshot;
    ASN1bool_t partialPictureSnapshot;
    ASN1bool_t videoSegmentTagging;
    ASN1bool_t progressiveRefinement;
    ASN1bool_t dynamicPictureResizingByFour;
    ASN1bool_t dynamicPictureResizingSixteenthPel;
    ASN1bool_t dynamicWarpingHalfPel;
    ASN1bool_t dynamicWarpingSixteenthPel;
    ASN1bool_t independentSegmentDecoding;
    ASN1bool_t slicesInOrder_NonRect;
    ASN1bool_t slicesInOrder_Rect;
    ASN1bool_t slicesNoOrder_NonRect;
    ASN1bool_t slicesNoOrder_Rect;
    ASN1bool_t alternateInterVLCMode;
    ASN1bool_t modifiedQuantizationMode;
    ASN1bool_t reducedResolutionUpdate;
#   define transparencyParameters_present 0x80
    TransparencyParameters transparencyParameters;
    ASN1bool_t separateVideoBackChannel;
#   define refPictureSelection_present 0x40
    RefPictureSelection refPictureSelection;
#   define customPictureClockFrequency_present 0x20
    PH263Options_customPictureClockFrequency customPictureClockFrequency;
#   define customPictureFormat_present 0x10
    PH263Options_customPictureFormat customPictureFormat;
#   define modeCombos_present 0x8
    PH263Options_modeCombos modeCombos;
} H263Options;


typedef struct H263VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H263VideoMode_resolution resolution;
    ASN1uint16_t bitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
#   define H263VideoMode_errorCompensation_present 0x80
    ASN1bool_t errorCompensation;
#   define H263VideoMode_enhancementLayerInfo_present 0x40
    EnhancementLayerInfo enhancementLayerInfo;
#   define H263VideoMode_h263Options_present 0x20
    H263Options h263Options;
} H263VideoMode;


typedef struct H263VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H263VideoCapability_sqcifMPI_present 0x80
    ASN1uint16_t sqcifMPI;
#   define H263VideoCapability_qcifMPI_present 0x40
    ASN1uint16_t qcifMPI;
#   define H263VideoCapability_cifMPI_present 0x20
    ASN1uint16_t cifMPI;
#   define H263VideoCapability_cif4MPI_present 0x10
    ASN1uint16_t cif4MPI;
#   define H263VideoCapability_cif16MPI_present 0x8
    ASN1uint16_t cif16MPI;
    ASN1uint32_t maxBitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
    ASN1bool_t temporalSpatialTradeOffCapability;
#   define hrd_B_present 0x4
    ASN1uint32_t hrd_B;
#   define bppMaxKb_present 0x2
    ASN1uint16_t bppMaxKb;
#   define H263VideoCapability_slowSqcifMPI_present 0x8000
    ASN1uint16_t slowSqcifMPI;
#   define H263VideoCapability_slowQcifMPI_present 0x4000
    ASN1uint16_t slowQcifMPI;
#   define H263VideoCapability_slowCifMPI_present 0x2000
    ASN1uint16_t slowCifMPI;
#   define H263VideoCapability_slowCif4MPI_present 0x1000
    ASN1uint16_t slowCif4MPI;
#   define H263VideoCapability_slowCif16MPI_present 0x800
    ASN1uint16_t slowCif16MPI;
#   define H263VideoCapability_errorCompensation_present 0x400
    ASN1bool_t errorCompensation;
#   define H263VideoCapability_enhancementLayerInfo_present 0x200
    EnhancementLayerInfo enhancementLayerInfo;
#   define H263VideoCapability_h263Options_present 0x100
    H263Options h263Options;
} H263VideoCapability;


typedef struct EnhancementOptions {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define EnhancementOptions_sqcifMPI_present 0x80
    ASN1uint16_t sqcifMPI;
#   define EnhancementOptions_qcifMPI_present 0x40
    ASN1uint16_t qcifMPI;
#   define EnhancementOptions_cifMPI_present 0x20
    ASN1uint16_t cifMPI;
#   define EnhancementOptions_cif4MPI_present 0x10
    ASN1uint16_t cif4MPI;
#   define EnhancementOptions_cif16MPI_present 0x8
    ASN1uint16_t cif16MPI;
    ASN1uint32_t maxBitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t temporalSpatialTradeOffCapability;
#   define EnhancementOptions_slowSqcifMPI_present 0x4
    ASN1uint16_t slowSqcifMPI;
#   define EnhancementOptions_slowQcifMPI_present 0x2
    ASN1uint16_t slowQcifMPI;
#   define EnhancementOptions_slowCifMPI_present 0x1
    ASN1uint16_t slowCifMPI;
#   define EnhancementOptions_slowCif4MPI_present 0x8000
    ASN1uint16_t slowCif4MPI;
#   define EnhancementOptions_slowCif16MPI_present 0x4000
    ASN1uint16_t slowCif16MPI;
    ASN1bool_t errorCompensation;
#   define EnhancementOptions_h263Options_present 0x2000
    H263Options h263Options;
} EnhancementOptions;


typedef struct BEnhancementParameters {
    EnhancementOptions enhancementOptions;
    ASN1uint16_t numberOfBPictures;
} BEnhancementParameters;

typedef struct EnhancementLayerInfo_bPictureEnhancement {
    PEnhancementLayerInfo_bPictureEnhancement next;
    BEnhancementParameters value;
} EnhancementLayerInfo_bPictureEnhancement_Element;

typedef struct VideoMode {
    ASN1choice_t choice;
    union {
#	define VideoMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h261VideoMode_chosen 2
	H261VideoMode h261VideoMode;
#	define h262VideoMode_chosen 3
	H262VideoMode h262VideoMode;
#	define h263VideoMode_chosen 4
	H263VideoMode h263VideoMode;
#	define is11172VideoMode_chosen 5
	IS11172VideoMode is11172VideoMode;
    } u;
} VideoMode;

typedef struct VideoCapability {
    ASN1choice_t choice;
    union {
#	define VideoCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h261VideoCapability_chosen 2
	H261VideoCapability h261VideoCapability;
#	define h262VideoCapability_chosen 3
	H262VideoCapability h262VideoCapability;
#	define h263VideoCapability_chosen 4
	H263VideoCapability h263VideoCapability;
#	define is11172VideoCapability_chosen 5
	IS11172VideoCapability is11172VideoCapability;
    } u;
} VideoCapability;

/******************************************************************************
Audio Format/Capability definitions and structures
*******************************************************************************
*/
typedef struct G7231AnnexCCapability_g723AnnexCAudioMode {
    ASN1uint16_t highRateMode0;
    ASN1uint16_t highRateMode1;
    ASN1uint16_t lowRateMode0;
    ASN1uint16_t lowRateMode1;
    ASN1uint16_t sidMode0;
    ASN1uint16_t sidMode1;
} G7231AnnexCCapability_g723AnnexCAudioMode;

typedef struct G7231AnnexCCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t maxAl_sduAudioFrames;
    ASN1bool_t silenceSuppression;
#   define g723AnnexCAudioMode_present 0x80
    G7231AnnexCCapability_g723AnnexCAudioMode g723AnnexCAudioMode;
} G7231AnnexCCapability;

typedef struct IS11172AudioCapability {
    ASN1bool_t audioLayer1;
    ASN1bool_t audioLayer2;
    ASN1bool_t audioLayer3;
    ASN1bool_t audioSampling32k;
    ASN1bool_t audioSampling44k1;
    ASN1bool_t audioSampling48k;
    ASN1bool_t singleChannel;
    ASN1bool_t twoChannels;
    ASN1uint16_t bitRate;
} IS11172AudioCapability;


typedef struct IS13818AudioCapability {
    ASN1bool_t audioLayer1;
    ASN1bool_t audioLayer2;
    ASN1bool_t audioLayer3;
    ASN1bool_t audioSampling16k;
    ASN1bool_t audioSampling22k05;
    ASN1bool_t audioSampling24k;
    ASN1bool_t audioSampling32k;
    ASN1bool_t audioSampling44k1;
    ASN1bool_t audioSampling48k;
    ASN1bool_t singleChannel;
    ASN1bool_t twoChannels;
    ASN1bool_t threeChannels2_1;
    ASN1bool_t threeChannels3_0;
    ASN1bool_t fourChannels2_0_2_0;
    ASN1bool_t fourChannels2_2;
    ASN1bool_t fourChannels3_1;
    ASN1bool_t fiveChannels3_0_2_0;
    ASN1bool_t fiveChannels3_2;
    ASN1bool_t lowFrequencyEnhancement;
    ASN1bool_t multilingual;
    ASN1uint16_t bitRate;
} IS13818AudioCapability;

typedef struct GSMAudioCapability {
    ASN1uint16_t audioUnitSize;
    ASN1bool_t comfortNoise;
    ASN1bool_t scrambled;
} GSMAudioCapability;

typedef struct AudioMode_g7231 {
    ASN1choice_t choice;
#   define noSilenceSuppressionLowRate_chosen 1
#   define noSilenceSuppressionHighRate_chosen 2
#   define silenceSuppressionLowRate_chosen 3
#   define silenceSuppressionHighRate_chosen 4
} AudioMode_g7231;

typedef struct AudioCapability_g7231 {
    ASN1uint16_t maxAl_sduAudioFrames;
    ASN1bool_t silenceSuppression;
} AudioCapability_g7231;

typedef struct G7231AnnexCMode_g723AnnexCAudioMode {
    ASN1uint16_t highRateMode0;
    ASN1uint16_t highRateMode1;
    ASN1uint16_t lowRateMode0;
    ASN1uint16_t lowRateMode1;
    ASN1uint16_t sidMode0;
    ASN1uint16_t sidMode1;
} G7231AnnexCMode_g723AnnexCAudioMode;

typedef struct G7231AnnexCMode {
    ASN1uint16_t maxAl_sduAudioFrames;
    ASN1bool_t silenceSuppression;
    G7231AnnexCMode_g723AnnexCAudioMode g723AnnexCAudioMode;
} G7231AnnexCMode;

typedef struct IS13818AudioMode_multichannelType {
    ASN1choice_t choice;
#   define IS13818AudioMode_multichannelType_singleChannel_chosen 1
#   define IS13818AudioMode_multichannelType_twoChannelStereo_chosen 2
#   define IS13818AudioMode_multichannelType_twoChannelDual_chosen 3
#   define threeChannels2_1_chosen 4
#   define threeChannels3_0_chosen 5
#   define fourChannels2_0_2_0_chosen 6
#   define fourChannels2_2_chosen 7
#   define fourChannels3_1_chosen 8
#   define fiveChannels3_0_2_0_chosen 9
#   define fiveChannels3_2_chosen 10
} IS13818AudioMode_multichannelType;

typedef struct IS13818AudioMode_audioSampling {
    ASN1choice_t choice;
#   define audioSampling16k_chosen 1
#   define audioSampling22k05_chosen 2
#   define audioSampling24k_chosen 3
#   define IS13818AudioMode_audioSampling_audioSampling32k_chosen 4
#   define IS13818AudioMode_audioSampling_audioSampling44k1_chosen 5
#   define IS13818AudioMode_audioSampling_audioSampling48k_chosen 6
} IS13818AudioMode_audioSampling;

typedef struct IS13818AudioMode_audioLayer {
    ASN1choice_t choice;
#   define IS13818AudioMode_audioLayer_audioLayer1_chosen 1
#   define IS13818AudioMode_audioLayer_audioLayer2_chosen 2
#   define IS13818AudioMode_audioLayer_audioLayer3_chosen 3
} IS13818AudioMode_audioLayer;

typedef struct IS11172AudioMode_multichannelType {
    ASN1choice_t choice;
#   define IS11172AudioMode_multichannelType_singleChannel_chosen 1
#   define IS11172AudioMode_multichannelType_twoChannelStereo_chosen 2
#   define IS11172AudioMode_multichannelType_twoChannelDual_chosen 3
} IS11172AudioMode_multichannelType;

typedef struct IS11172AudioMode_audioSampling {
    ASN1choice_t choice;
#   define IS11172AudioMode_audioSampling_audioSampling32k_chosen 1
#   define IS11172AudioMode_audioSampling_audioSampling44k1_chosen 2
#   define IS11172AudioMode_audioSampling_audioSampling48k_chosen 3
} IS11172AudioMode_audioSampling;

typedef struct IS11172AudioMode_audioLayer {
    ASN1choice_t choice;
#   define IS11172AudioMode_audioLayer_audioLayer1_chosen 1
#   define IS11172AudioMode_audioLayer_audioLayer2_chosen 2
#   define IS11172AudioMode_audioLayer_audioLayer3_chosen 3
} IS11172AudioMode_audioLayer;


typedef struct IS11172AudioMode {
    IS11172AudioMode_audioLayer audioLayer;
    IS11172AudioMode_audioSampling audioSampling;
    IS11172AudioMode_multichannelType multichannelType;
    ASN1uint16_t bitRate;
} IS11172AudioMode;

typedef struct IS13818AudioMode {
    IS13818AudioMode_audioLayer audioLayer;
    IS13818AudioMode_audioSampling audioSampling;
    IS13818AudioMode_multichannelType multichannelType;
    ASN1bool_t lowFrequencyEnhancement;
    ASN1bool_t multilingual;
    ASN1uint16_t bitRate;
} IS13818AudioMode;


typedef struct AudioCapability {
    ASN1choice_t choice;
    union {
#	define AudioCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define AudioCapability_g711Alaw64k_chosen 2
	ASN1uint16_t g711Alaw64k;
#	define AudioCapability_g711Alaw56k_chosen 3
	ASN1uint16_t g711Alaw56k;
#	define AudioCapability_g711Ulaw64k_chosen 4
	ASN1uint16_t g711Ulaw64k;
#	define AudioCapability_g711Ulaw56k_chosen 5
	ASN1uint16_t g711Ulaw56k;
#	define AudioCapability_g722_64k_chosen 6
	ASN1uint16_t g722_64k;
#	define AudioCapability_g722_56k_chosen 7
	ASN1uint16_t g722_56k;
#	define AudioCapability_g722_48k_chosen 8
	ASN1uint16_t g722_48k;
#	define AudioCapability_g7231_chosen 9
	AudioCapability_g7231 g7231;
#	define AudioCapability_g728_chosen 10
	ASN1uint16_t g728;
#	define AudioCapability_g729_chosen 11
	ASN1uint16_t g729;
#	define AudioCapability_g729AnnexA_chosen 12
	ASN1uint16_t g729AnnexA;
#	define is11172AudioCapability_chosen 13
	IS11172AudioCapability is11172AudioCapability;
#	define is13818AudioCapability_chosen 14
	IS13818AudioCapability is13818AudioCapability;
#	define AudioCapability_g729wAnnexB_chosen 15
	ASN1uint16_t g729wAnnexB;
#	define AudioCapability_g729AnnexAwAnnexB_chosen 16
	ASN1uint16_t g729AnnexAwAnnexB;
#	define g7231AnnexCCapability_chosen 17
	G7231AnnexCCapability g7231AnnexCCapability;
#	define AudioCapability_gsmFullRate_chosen 18
	GSMAudioCapability gsmFullRate;
#	define AudioCapability_gsmHalfRate_chosen 19
	GSMAudioCapability gsmHalfRate;
#	define AudioCapability_gsmEnhancedFullRate_chosen 20
	GSMAudioCapability gsmEnhancedFullRate;
    } u;
} AudioCapability;


typedef struct AudioMode {
    ASN1choice_t choice;
    union {
#	define AudioMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define AudioMode_g711Alaw64k_chosen 2
#	define AudioMode_g711Alaw56k_chosen 3
#	define AudioMode_g711Ulaw64k_chosen 4
#	define AudioMode_g711Ulaw56k_chosen 5
#	define AudioMode_g722_64k_chosen 6
#	define AudioMode_g722_56k_chosen 7
#	define AudioMode_g722_48k_chosen 8
#	define AudioMode_g728_chosen 9
#	define AudioMode_g729_chosen 10
#	define AudioMode_g729AnnexA_chosen 11
#	define AudioMode_g7231_chosen 12
	AudioMode_g7231 g7231;
#	define is11172AudioMode_chosen 13
	IS11172AudioMode is11172AudioMode;
#	define is13818AudioMode_chosen 14
	IS13818AudioMode is13818AudioMode;
#	define AudioMode_g729wAnnexB_chosen 15
	ASN1uint16_t g729wAnnexB;
#	define AudioMode_g729AnnexAwAnnexB_chosen 16
	ASN1uint16_t g729AnnexAwAnnexB;
#	define g7231AnnexCMode_chosen 17
	G7231AnnexCMode g7231AnnexCMode;
#	define AudioMode_gsmFullRate_chosen 18
	GSMAudioCapability gsmFullRate;
#	define AudioMode_gsmHalfRate_chosen 19
	GSMAudioCapability gsmHalfRate;
#	define AudioMode_gsmEnhancedFullRate_chosen 20
	GSMAudioCapability gsmEnhancedFullRate;
    } u;
} AudioMode;


typedef struct T84Profile_t84Restricted {
    ASN1bool_t qcif;
    ASN1bool_t cif;
    ASN1bool_t ccir601Seq;
    ASN1bool_t ccir601Prog;
    ASN1bool_t hdtvSeq;
    ASN1bool_t hdtvProg;
    ASN1bool_t g3FacsMH200x100;
    ASN1bool_t g3FacsMH200x200;
    ASN1bool_t g4FacsMMR200x100;
    ASN1bool_t g4FacsMMR200x200;
    ASN1bool_t jbig200x200Seq;
    ASN1bool_t jbig200x200Prog;
    ASN1bool_t jbig300x300Seq;
    ASN1bool_t jbig300x300Prog;
    ASN1bool_t digPhotoLow;
    ASN1bool_t digPhotoMedSeq;
    ASN1bool_t digPhotoMedProg;
    ASN1bool_t digPhotoHighSeq;
    ASN1bool_t digPhotoHighProg;
} T84Profile_t84Restricted;

typedef struct V42bis {
    ASN1uint32_t numberOfCodewords;
    ASN1uint16_t maximumStringLength;
} V42bis;

typedef struct T84Profile {
    ASN1choice_t choice;
    union {
#	define t84Unrestricted_chosen 1
#	define t84Restricted_chosen 2
	T84Profile_t84Restricted t84Restricted;
    } u;
} T84Profile;

typedef struct CompressionType {
    ASN1choice_t choice;
    union {
#	define v42bis_chosen 1
	V42bis v42bis;
    } u;
} CompressionType;

typedef struct DataProtocolCapability_v76wCompression {
    ASN1choice_t choice;
    union {
#	define transmitCompression_chosen 1
	CompressionType transmitCompression;
#	define receiveCompression_chosen 2
	CompressionType receiveCompression;
#	define transmitAndReceiveCompression_chosen 3
	CompressionType transmitAndReceiveCompression;
    } u;
} DataProtocolCapability_v76wCompression;

typedef struct DataProtocolCapability {
    ASN1choice_t choice;
    union {
#	define DataProtocolCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define v14buffered_chosen 2
#	define v42lapm_chosen 3
#	define hdlcFrameTunnelling_chosen 4
#	define h310SeparateVCStack_chosen 5
#	define h310SingleVCStack_chosen 6
#	define transparent_chosen 7
#	define segmentationAndReassembly_chosen 8
#	define hdlcFrameTunnelingwSAR_chosen 9
#	define v120_chosen 10
#	define separateLANStack_chosen 11
#	define v76wCompression_chosen 12
	DataProtocolCapability_v76wCompression v76wCompression;
    } u;
} DataProtocolCapability;


typedef struct DataMode_application_nlpid {
    DataProtocolCapability nlpidProtocol;
    ASN1octetstring_t nlpidData;
} DataMode_application_nlpid;

typedef struct DataMode_application {
    ASN1choice_t choice;
    union {
#	define DataMode_application_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define DataMode_application_t120_chosen 2
	DataProtocolCapability t120;
#	define DataMode_application_dsm_cc_chosen 3
	DataProtocolCapability dsm_cc;
#	define DataMode_application_userData_chosen 4
	DataProtocolCapability userData;
#	define DataMode_application_t84_chosen 5
	DataProtocolCapability t84;
#	define DataMode_application_t434_chosen 6
	DataProtocolCapability t434;
#	define DataMode_application_h224_chosen 7
	DataProtocolCapability h224;
#	define DataMode_application_nlpid_chosen 8
	DataMode_application_nlpid nlpid;
#	define DataMode_application_dsvdControl_chosen 9
#	define DataMode_application_h222DataPartitioning_chosen 10
	DataProtocolCapability h222DataPartitioning;
#	define DataMode_application_t30fax_chosen 11
	DataProtocolCapability t30fax;
#	define DataMode_application_t140_chosen 12
	DataProtocolCapability t140;
    } u;
} DataMode_application;

typedef struct DataMode {
    DataMode_application application;
    ASN1uint32_t bitRate;
} DataMode;

typedef struct EncryptionMode {
    ASN1choice_t choice;
    union {
#	define EncryptionMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h233Encryption_chosen 2
    } u;
} EncryptionMode;

typedef struct AuthenticationCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define AuthenticationCapability_nonStandard_present 0x80
    NonStandardParameter nonStandard;
} AuthenticationCapability;

typedef struct IntegrityCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define IntegrityCapability_nonStandard_present 0x80
    NonStandardParameter nonStandard;
} IntegrityCapability;

typedef struct EncryptionAuthenticationAndIntegrity {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define encryptionCapability_present 0x80
    PEncryptionCapability encryptionCapability;
#   define authenticationCapability_present 0x40
    AuthenticationCapability authenticationCapability;
#   define integrityCapability_present 0x20
    IntegrityCapability integrityCapability;
} EncryptionAuthenticationAndIntegrity;

typedef struct H235Mode_mediaMode {
    ASN1choice_t choice;
    union {
#	define H235Mode_mediaMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H235Mode_mediaMode_videoMode_chosen 2
	VideoMode videoMode;
#	define H235Mode_mediaMode_audioMode_chosen 3
	AudioMode audioMode;
#	define H235Mode_mediaMode_dataMode_chosen 4
	DataMode dataMode;
    } u;
} H235Mode_mediaMode;



typedef struct H235Mode {
    EncryptionAuthenticationAndIntegrity encryptionAuthenticationAndIntegrity;
    H235Mode_mediaMode mediaMode;
} H235Mode;

typedef struct ModeElement_type {
    ASN1choice_t choice;
    union {
#	define ModeElement_type_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define ModeElement_type_videoMode_chosen 2
	VideoMode videoMode;
#	define ModeElement_type_audioMode_chosen 3
	AudioMode audioMode;
#	define ModeElement_type_dataMode_chosen 4
	DataMode dataMode;
#	define encryptionMode_chosen 5
	EncryptionMode encryptionMode;
#	define h235Mode_chosen 6
	H235Mode h235Mode;
    } u;
} ModeElement_type;

#endif // _H245ASN_Module_H_ 

typedef VideoCapability H245VideoCapability; 
typedef AudioCapability H245AudioCapability; 
typedef ModeElement_type H245_MODE_ELEMENT; 

typedef struct 
{
	DWORD dwApplicationCapID;
	ASN1choice_t choiceSetupProcedure;
	BOOL fRestrictAudio;
	BOOL fRestrictVideo;
	DataProtocolCapability T120ProtocolCap;
	//NonStandardParameter *pNonStandardParameter;
}H245T120Capability;

typedef enum 
{
    H245MediaType_Audio,    
    H245MediaType_Video,
    H245MediaType_T120
}H245MediaCapabilityType;

// media capability structure 
typedef struct tag_H245MediaCapability
{
    H245MediaCapabilityType  media_type;
    union 
    {
        H245AudioCapability audio_cap; 
        H245VideoCapability video_cap;
        H245T120Capability T120_cap;
    }capability;
    
}H245MediaCapability;

typedef struct tag_FormatResourceBounds
{
    DWORD dwBitsPerSecond;
    DWORD dwCPUUtilization;
} FormatResourceBounds;

#ifdef __cplusplus

/*****************************************************************************
 *  @doc INTERNAL H245VIDCSTRUCTENUM
 *
 *  @struct H245VideoCapabilityMap | The <t H245VideoCapabilityMap> structure
 *    is used to specify the relationship between supported formats and
 *    estimated maximum system resources for the supported format.
 *
 *  @field H245MediaCapability | h245MediaCapability | Specifies the H.245
 *    video/audio format, including all parameters and options. This structure
 *    is H.245 version specific: its definition depends on the version of
 *    H.245 used by the TAPI MSP filters. For video, this structure may indicate
 *    format parameters for more than one standard video size at a time if
 *    the resource requirements are similar for all sizes.
 *
 *  @field GUID | filterGuid | Specifies a GUID value that uniquely
 *    identifies the TAPI MSP filter.
 *
 *  @field DWORD | dwUniqueID | Specifies a DWORD value that uniquely
 *    identifies the capability of the TAPI MSP filter.
 *
 *  @field UINT | uNumEntries | This indicates the number of elements
 *    referenced by <t pResourceBoundArray>.
 *
 *  @field FormatResourceBounds* | pResourceBoundArray | Specifies an array
 *    of <t FormatResourceBounds> structures that indicate the approximate
 *    resource bounds of each entry.
 ***************************************************************************/
typedef struct tag_H245MediaCapabilityMap
{
    H245MediaCapability h245MediaCapability;
    GUID filterGuid;
    DWORD dwUniqueID;
    UINT uNumEntries;
    FormatResourceBounds *pResourceBoundArray;
} H245MediaCapabilityMap;

/*****************************************************************************
 *  @doc INTERNAL H245VIDCSTRUCTENUM
 *
 *  @struct H245MediaCapabilityTable | The <t H245MediaCapabilityTable> structure
 *    is used to specify the set of formats that are supported by the TAPI MSP
 *    filters.
 *
 *  @field UINT | uMappedCapabilities | Specifies  the  number of
 *    <t H245VideoCapabilityMap> structures in <t pCapabilityArray>.
 *
 *  @field H245MediaCapabilityMap* | pCapabilityArray | Specifies a pointer
 *    to an array of <t H245MediaCapabilityMap> structures.
 ***************************************************************************/
typedef struct tag_H245MediaCapabilityTable
{
    UINT uMappedCapabilities;
    H245MediaCapabilityMap *pCapabilityArray;
} H245MediaCapabilityTable;

/*****************************************************************************
 *  @doc INTERNAL CONST
 *
 *  @const int | TAPI_H245_VERSION_ID | Specifies  the  H.245 platform
 *    version 3.
 ***************************************************************************/
#define TAPI_H245_VERSION_ID 3

// H.245 video capability interface (pin interface)
interface DECLSPEC_UUID("ec35770f-b64d-405d-a5f2-4514164ba87a") IH245Capability : public IUnknown
{
	public:
	virtual STDMETHODIMP GetH245VersionID(OUT DWORD *pdwVersionID) PURE;
	virtual STDMETHODIMP GetFormatTable(OUT H245MediaCapabilityTable *pTable) PURE;
	virtual STDMETHODIMP ReleaseFormatTable(IN H245MediaCapabilityTable *pTable) PURE;
	virtual STDMETHODIMP IntersectFormats(
        IN DWORD dwUniqueID, 
        IN const H245MediaCapability *pLocalCapability, 
        IN const H245MediaCapability *pRemoteCapability, 
        OUT H245MediaCapability **ppIntersectedCapability,
        OUT  DWORD *pdwPayloadType
        ) PURE;

	virtual STDMETHODIMP Refine(IN OUT H245MediaCapability *pLocalCapability, IN DWORD dwUniqueID, IN DWORD dwResourceBoundIndex) PURE;
	virtual STDMETHODIMP GetLocalFormat(IN DWORD dwUniqueID, IN const H245MediaCapability *pIntersectedCapability, OUT AM_MEDIA_TYPE **ppAMMediaType) PURE;
	virtual STDMETHODIMP ReleaseNegotiatedCapability(IN H245MediaCapability *pIntersectedCapability) PURE;
	virtual STDMETHODIMP FindIDByRange(IN const AM_MEDIA_TYPE *pAMMediaType, OUT DWORD *pdwUniqueID) PURE;
};

// IH245EncoderCommand interface (pin interface)
interface DECLSPEC_UUID("b4263e5b-f216-4b58-9968-ba9ab7808ab3") IH245EncoderCommand : public IUnknown
{
	public:
	virtual STDMETHODIMP videoFastUpdatePicture() PURE;
	virtual STDMETHODIMP videoFastUpdateGOB(IN DWORD dwFirstGOB, IN DWORD dwNumberOfGOBs) PURE;
	virtual STDMETHODIMP videoFastUpdateMB(IN DWORD dwFirstGOB, IN DWORD dwFirstMB, IN DWORD dwNumberOfMBs) PURE;
	virtual STDMETHODIMP videoSendSyncEveryGOB(IN BOOL fEnable) PURE;
	virtual STDMETHODIMP videoNotDecodedMBs(IN DWORD dwFirstMB, IN DWORD dwNumberOfMBs, IN DWORD dwTemporalReference) PURE;
};

// IH245DecoderCommand interface (pin interface)
interface DECLSPEC_UUID("a542d119-6abd-48a5-92db-dac1dfe6995c") IH245DecoderCommand : public IUnknown
{
	public:
	virtual STDMETHODIMP videoFreezePicture() PURE;
};

#ifdef USE_PROGRESSIVE_REFINEMENT
// Progressive refinement interface (pin interface)
interface DECLSPEC_UUID("46a02824-6d1f-49d9-9e62-e1694f28ab1a") IProgressiveRefinement : public IUnknown
{
	public:
	virtual STDMETHODIMP doOneProgression() PURE;
	virtual STDMETHODIMP doContinuousProgressions() PURE;
	virtual STDMETHODIMP doOneIndependentProgression() PURE;
	virtual STDMETHODIMP doContinuousIndependentProgressions() PURE;
	virtual STDMETHODIMP progressiveRefinementAbortOne() PURE;
	virtual STDMETHODIMP progressiveRefinementAbortContinuous() PURE;
};
#endif

#if !defined(STREAM_INTERFACES_DEFINED)

#define MAX_DESCRIPTION_LEN 256

typedef enum tagStreamConfigCapsType
{
	AudioStreamConfigCaps,
	VideoStreamConfigCaps
} StreamConfigCapsType;

typedef struct _TAPI_AUDIO_STREAM_CONFIG_CAPS
{
	WCHAR Description[MAX_DESCRIPTION_LEN];
	ULONG MinimumChannels;
	ULONG MaximumChannels;
	ULONG ChannelsGranularity;
	ULONG MinimumBitsPerSample;
	ULONG MaximumBitsPerSample;
	ULONG BitsPerSampleGranularity;
	ULONG MinimumSampleFrequency;
	ULONG MaximumSampleFrequency;
	ULONG SampleFrequencyGranularity;
    ULONG MinimumAvgBytesPerSec;
    ULONG MaximumAvgBytesPerSec;
    ULONG AvgBytesPerSecGranularity;
} TAPI_AUDIO_STREAM_CONFIG_CAPS, *PTAPI_AUDIO_STREAM_CONFIG_CAPS;

typedef struct _TAPI_VIDEO_STREAM_CONFIG_CAPS
{
	WCHAR Description[MAX_DESCRIPTION_LEN];
	ULONG VideoStandard;
	SIZE InputSize;
	SIZE MinCroppingSize;
	SIZE MaxCroppingSize;
	int CropGranularityX;
	int CropGranularityY;
	int CropAlignX;
	int CropAlignY;
	SIZE MinOutputSize;
	SIZE MaxOutputSize;
	int OutputGranularityX;
	int OutputGranularityY;
	int StretchTapsX;
	int StretchTapsY;
	int ShrinkTapsX;
	int ShrinkTapsY;
	LONGLONG MinFrameInterval;
	LONGLONG MaxFrameInterval;
	LONG MinBitsPerSecond;
	LONG MaxBitsPerSecond;
} TAPI_VIDEO_STREAM_CONFIG_CAPS, *PTAPI_VIDEO_STREAM_CONFIG_CAPS;

typedef struct tagTAPI_STREAM_CONFIG_CAPS
{
	StreamConfigCapsType CapsType;
	union
	{
		TAPI_VIDEO_STREAM_CONFIG_CAPS VideoCap;
		TAPI_AUDIO_STREAM_CONFIG_CAPS AudioCap;
	};
} TAPI_STREAM_CONFIG_CAPS, *PTAPI_STREAM_CONFIG_CAPS;

#endif


// used in SetFormat when the payload type is unknown.
const DWORD UNKNOWN_PAYLOAD = (DWORD)(-1);

// IStreamConfig interface (pin interface)
interface DECLSPEC_UUID("c5888472-8f4f-475b-8f5b-93b6c8e7567f") IStreamConfig : public IUnknown
{
// TODO, we need to introduce a new interface to handle all the RTP payload type
// related issues. The payload type info shouldn't be in this interface.

	public:
	virtual STDMETHODIMP SetFormat(IN DWORD dwRTPPayLoadType, IN AM_MEDIA_TYPE *pMediaType) PURE;
	virtual STDMETHODIMP GetFormat(OUT DWORD *pdwRTPPayLoadType, OUT AM_MEDIA_TYPE **ppMediaType) PURE;
	virtual STDMETHODIMP GetNumberOfCapabilities(OUT DWORD *pdwCount) PURE;
	virtual STDMETHODIMP GetStreamCaps(IN DWORD dwIndex, OUT AM_MEDIA_TYPE **ppMediaType, OUT TAPI_STREAM_CONFIG_CAPS *pTSCC, OUT DWORD *pdwRTPPayLoadType) PURE;
};

#endif // __cplusplus

#ifdef __cplusplus
}
#endif

#endif	// __H245FMT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\inc\msrtp.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    msrtp.h
 *
 *  Abstract:
 *
 *    RTP definitions used by applications
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/11/19 created
 *
 **********************************************************************/

#ifndef _msrtp_h_
#define _msrtp_h_

#include <evcode.h>

/**********************************************************************
 * Flags passed in IRtpSession::Init()
 **********************************************************************/
/* Helper enumeration (do not use): Init flags
 *
 * WARNING The order here is important, it matches some flags in
 * RtpAddr_t so a mapping by shifting is possible */
enum {
    RTPINITFG_FIRST, /* Internal only, do not use */

    RTPINITFG_AUTO,  /* Internal only, do not use */
    
    /* Used to enable QOS, i.e. create QOS enabled sockets */
    RTPINITFG_QOS,

    /* Used to make the SSRC persistent */
    RTPINITFG_PERSISTSSRC,

    /* Used to make the sockets persistent */
    RTPINITFG_PERSISTSOCKETS,

    /* Media class 1 to 7 */
    RTPINITFG_CLASS0,
    RTPINITFG_CLASS1,
    RTPINITFG_CLASS2,

    RTPINITFG_DUMMY8,

    RTPINITFG_MATCHRADDR, /* Discard packets not comming from the
                           * remote address */
    RTPINITFG_RADDRRESETDEMUX,/* Reset the demux (unmap all outputs)
                               * when a new remote address is set */

    RTPINITFG_LAST /* Internal only, do not use */
};

/* Helper enumeration (do not use): RTP media class */
enum {
    RTPCLASS_FIRST, /* Internal only, do not use */

    /* Audio traffic */
    RTPCLASS_AUDIO,

    /* Video traffic */
    RTPCLASS_VIDEO,
    
    RTPCLASS_LAST  /* Internal only, do not use */
};

/*
 * Flags used in IRtpSession::Init()
 */
#define RTPINIT_ENABLE_QOS      (1 << RTPINITFG_QOS)
#define RTPINIT_PERSIST_SSRC    (1 << RTPINITFG_PERSISTSSRC)
#define RTPINIT_PERSIST_SOCKETS (1 << RTPINITFG_PERSISTSOCKETS)
#define RTPINIT_CLASS_AUDIO     (RTPCLASS_AUDIO << RTPINITFG_CLASS0)
#define RTPINIT_CLASS_VIDEO     (RTPCLASS_VIDEO << RTPINITFG_CLASS0)
#define RTPINIT_CLASS_DEFAULT   (RTPCLASS_FIRST << RTPINITFG_CLASS0)
#define RTPINIT_MATCHRADDR      (1 << RTPINITFG_MATCHRADDR)
#define RTPINIT_RADDRRESETDEMUX (1 << RTPINITFG_RADDRRESETDEMUX)


/* Mask to validate valid flags in IRtpSession::Init() */
#define RTPINIT_MASK         ( (1 << RTPINITFG_AUTO)   | \
                               (1 << RTPINITFG_QOS)    | \
                               (1 << RTPINITFG_PERSISTSSRC)   | \
                               (1 << RTPINITFG_PERSISTSOCKETS)| \
                               (1 << RTPINITFG_CLASS0) | \
                               (1 << RTPINITFG_CLASS1) | \
                               (1 << RTPINITFG_CLASS2) | \
                               (1 << RTPINITFG_MATCHRADDR)      | \
                               (1 << RTPINITFG_RADDRRESETDEMUX) | \
                               0 \
                             )


/**********************************************************************
 * Multicast modes
 **********************************************************************/
enum {
    RTPMCAST_LOOPBACKMODE_FIRST, /* Internal only, do not use */
    
    /* Disable loopback in Winsock (WS2 will filter ALL packets coming
     * from any socket in the same machine, collision detection is
     * enabled) */
    RTPMCAST_LOOPBACKMODE_NONE,

    /* Enable loopback in RTP (Winsock will enable loopback and RTP
     * will filter packets with a source address equal to the local
     * address, and with the same SSRC, note that in this mode
     * collision detection is enabled but is not possible among
     * applications runing on the same machine) */
    RTPMCAST_LOOPBACKMODE_PARTIAL,
    
    /* Let everything loopback (multicast loopback is enabled in
     * Winsock, no filtering is done in RTP, and collision detection
     * is disabled) */
    RTPMCAST_LOOPBACKMODE_FULL,

    RTPMCAST_LOOPBACKMODE_LAST /* Internal only, do not use */
};

#define DEFAULT_MCAST_LOOPBACK  RTPMCAST_LOOPBACKMODE_NONE

/**********************************************************************
 * TTL defaults
 **********************************************************************/
#define DEFAULT_UCAST_TTL       127
#define DEFAULT_MCAST_TTL       4

#define RTPTTL_RTP               0x1
#define RTPTTL_RTCP              0x2
#define RTPTTL_RTPRTCP           (RTPTTL_RTP | RTPTTL_RTCP)

/**********************************************************************
 *
 * Events base
 *
 **********************************************************************/

/* Helper enumeration (do not use) */
enum {
    /* RTP */
    RTPEVENTKIND_RTP,

    /* Participants */
    RTPEVENTKIND_PINFO,

    /* QOS */
    RTPEVENTKIND_QOS,

    /* SDES info */
    RTPEVENTKIND_SDES,

    RTPEVENTKIND_LAST
};

#define RTPEVNTRANGE   100
#define RTPQOS_ADJUST    3

/* EC_USER defined in evcode.h (0x8000+32=32800) */
#define RTPEVENTBASE         (EC_USER+32)

/* Event base for RTP events */
#define RTPRTP_EVENTBASE     (RTPEVENTBASE + RTPEVNTRANGE*RTPEVENTKIND_RTP)

/* Event base for participant events */
#define RTPPARINFO_EVENTBASE (RTPEVENTBASE + RTPEVNTRANGE*RTPEVENTKIND_PINFO)

/* Event base for QOS */
#define RTPQOS_EVENTBASE     (RTPEVENTBASE + RTPEVNTRANGE*RTPEVENTKIND_QOS + \
                              RTPQOS_ADJUST)

/* Event base for SDES information */
#define RTPSDES_EVENTBASE    (RTPEVENTBASE + RTPEVNTRANGE*RTPEVENTKIND_SDES)

/**********************************************************************
 * Kind of mask (used as the dwKind parameter in ModifySessionMask)
 **********************************************************************/
/* This enum is used to select the mask on which the ModifySessionMask
 * function will modify or query zero, one, or more bits.
 *
 * E.g. ModifySessionMask(RTPMASK_SDESRECV_EVENTS,
 *                        RTPSDES_MASK_PHONE,
 *                        0,
 *                        NULL);
 *
 * This will disable firing an event to the RTP source filter when a
 * PHONE SDES item is received, the modified mask will not be returned
 * as the pointer passed is NULL
 * */
enum {
    RTPMASK_FIRST,   /* Internal only, do not use */

    /* Select the RTP features mask */
    RTPMASK_FEATURES_MASK,

    /* Select the RTP events mask of events fired to a receiver,
     * e.g. an RTP source filter */
    RTPMASK_RECV_EVENTS,

    /* Select the RTP events mask of events fired to a sender, e.g. an
     * RTP render filter */
    RTPMASK_SEND_EVENTS,

    /* Select the events mask for participants events to be fired to a
     * receiver, e.g. an RTP source filter */
    RTPMASK_PINFOR_EVENTS,

    /* Select the events mask for participants events to be fired to a
     * sender, e.g. an RTP render filter */
    RTPMASK_PINFOS_EVENTS,

    /* Select the events mask of QOS events to be fired to a receiver,
     * e.g. an RTP source filter */
    RTPMASK_QOSRECV_EVENTS,

    /* Select the events mask of QOS events to be fired to a sender,
     * e.g. an RTP render filter */
    RTPMASK_QOSSEND_EVENTS,

    /* Select what SDES items (the items must also be enabled to be
     * accepted - RTPMASK_SDES_REMMASK), when received, will fire
     * events to a receiver, e.g. an RTP source filter */
    RTPMASK_SDESRECV_EVENTS,
    
    /* Select what SDES items (the items must also be enabled to be
     * accepted - RTPMASK_SDES_REMMASK), when received, will fire
     * events to a sender, e.g. an RTP render filter */
    RTPMASK_SDESSEND_EVENTS,
    
    /* Select the SDES items to send (provided they have a default or a
     * value has been set) in RTCP reports */
    RTPMASK_SDES_LOCMASK,

    /* Select the SDES items to accept and store when they are
     * received from the remote participants in their RTCP reports,
     * regardless if they are senders or receivers or both */
    RTPMASK_SDES_REMMASK,
    
    RTPMASK_LAST    /* Internal only, do not use */
};

/**********************************************************************
 * Features in RTP (masks)
 * Will use with RTPMASK_FEATURES_MASK
 **********************************************************************/

/* Helper enumeration (do not use) for masks */
enum {
    RTPFEAT_FIRST,  /* Internal only, do not use */

    /* Generate timestamps locally (RTP render only) */
    RTPFEAT_GENTIMESTAMP,

    /* Receive in same buffer RTP header and payload, don't change the
     * RTP header except the SSRC (RTP render only) */
    RTPFEAT_PASSHEADER,

    /* Enable sending RTCP SR probe packets to do bandwidth estimation
     * (queueing latency) */
    RTPFEAT_BANDESTIMATION,
    
    RTPFEAT_LAST    /* Internal only, do not use */
};

/*
 * Masks used to enable/disable the above features (used with
 * RTPMASK_FEATURES_MASK)
 */
#define RTPFEAT_MASK_GENTIMESTAMP   (1 << RTPFEAT_GENTIMESTAMP)
#define RTPFEAT_MASK_PASSHEADER     (1 << RTPFEAT_PASSHEADER)
#define RTPFEAT_MASK_BANDESTIMATION (1 << RTPFEAT_BANDESTIMATION)

/**********************************************************************
 * RTP information (events, masks)
 * Will use with RTPMASK_RECV_EVENTS or RTPMASK_SEND_EVENTS
 **********************************************************************/

/* Helper enumeration (do not use) for events and masks */
enum {
    RTPRTP_FIRST,   /* Internal only, do not use */
    
    /* RTCP RR received */
    RTPRTP_RR_RECEIVED,
    
    /* RTCP SR received */
    RTPRTP_SR_RECEIVED,

    /* Local SSRC is in collision */
    RTPRTP_LOCAL_COLLISION,

    /* Winsock reception error */
    RTPRTP_WS_RECV_ERROR,

    /* Winsock send error */
    RTPRTP_WS_SEND_ERROR,

    /* Network failure */
    RTPRTP_WS_NET_FAILURE,

    /* Loss rate reported in RTCP RR (loss rate observed in the
     * incoming stream that we report to the sender) */
    RTPRTP_RECV_LOSSRATE,
    
    /* Loss rate received in RTCP RR (loss rate seen by our peer (and
     * reported to us) in our outgoing data stream) */
    RTPRTP_SEND_LOSSRATE,

    /* Bandwidth estimation reported back to the sender */
    RTPRTP_BANDESTIMATION,

    /* Decryption failed */
    RTPRTP_CRYPT_RECV_ERROR,
    
    /* Encryption failed */
    RTPRTP_CRYPT_SEND_ERROR,
    
    RTPRTP_LAST    /* Internal only, do not use */
};

/*
 * Events generated
 */
/* P1:Sender's SSRC, P2:0 */
#define RTPRTP_EVENT_RR_RECEIVED     (RTPRTP_EVENTBASE + RTPRTP_RR_RECEIVED)

/* P1:Sender's SSRC, P2:0 */
#define RTPRTP_EVENT_SR_RECEIVED     (RTPRTP_EVENTBASE + RTPRTP_SR_RECEIVED)

/* P1:Local SSRC, P2:Old local SSRC */
#define RTPRTP_EVENT_LOCAL_COLLISION (RTPRTP_EVENTBASE + RTPRTP_LOCAL_COLLISION)

/* P1:0=RTP|1=RTCP, P2:WS2 Error */
#define RTPRTP_EVENT_WS_RECV_ERROR   (RTPRTP_EVENTBASE + RTPRTP_WS_RECV_ERROR)

/* P1:0=RTP|1=RTCP, P2:WS2 Error */
#define RTPRTP_EVENT_WS_SEND_ERROR   (RTPRTP_EVENTBASE + RTPRTP_WS_SEND_ERROR)

/* P1:0=RTP|1=RTCP, P2:WS2 Error */
#define RTPRTP_EVENT_WS_NET_FAILURE  (RTPRTP_EVENTBASE + RTPRTP_WS_NET_FAILURE)

/* P1:Sender's SSRC, P2:Loss rate being reported (See NOTE below) */
#define RTPRTP_EVENT_RECV_LOSSRATE   (RTPRTP_EVENTBASE + RTPRTP_RECV_LOSSRATE)

/* P1:Reporter's SSRC, P2:Loss rate received in report (See NOTE below) */
#define RTPRTP_EVENT_SEND_LOSSRATE   (RTPRTP_EVENTBASE + RTPRTP_SEND_LOSSRATE)

/* NOTE Loss rate passed as (int)(dLossRate * LOSS_RATE_PRECISSION),
 * e.g. if you receive a loss rate = L, then the real percentage in a
 * 0 - 100 scale would be obtained as L / LOSS_RATE_PRECISSION */
#define LOSS_RATE_PRECISSION           1000

/* P1:Reporter's SSRC, P2:Bandwidth estimation in bps (if the
 * estimation is done but the value is undefined, will report the
 * value RTP_BANDWIDTH_UNDEFINED. If the estimation is not done at all
 * will report the value RTP_BANDWIDTH_NOTESTIMATED. If the estimation
 * is getting its initial average will report RTP_BANDWIDTH_NOTREADY)
 * */
#define RTPRTP_EVENT_BANDESTIMATION  (RTPRTP_EVENTBASE + RTPRTP_BANDESTIMATION)

#define RTP_BANDWIDTH_UNDEFINED        ((DWORD)-1)
#define RTP_BANDWIDTH_NOTESTIMATED     ((DWORD)-2)
#define RTP_BANDWIDTH_BANDESTNOTREADY  ((DWORD)-3)

/* P1:0=RTP|1=RTCP, P2:Error */
#define RTPRTP_EVENT_CRYPT_RECV_ERROR \
                                   (RTPRTP_EVENTBASE + RTPRTP_CRYPT_RECV_ERROR)

/* P1:0=RTP|1=RTCP, P2:Error */
#define RTPRTP_EVENT_CRYPT_SEND_ERROR \
                                   (RTPRTP_EVENTBASE + RTPRTP_CRYPT_SEND_ERROR)


/*
 * Masks used to enable/disable the above events (used with
 * RTPMASK_RECV_EVENTS or RTPMASK_SEND_EVENTS)
 */
#define RTPRTP_MASK_RR_RECEIVED        (1 << RTPRTP_RR_RECEIVED)
#define RTPRTP_MASK_SR_RECEIVED        (1 << RTPRTP_SR_RECEIVED)
#define RTPRTP_MASK_LOCAL_COLLISION    (1 << RTPRTP_LOCAL_COLLISION)
#define RTPRTP_MASK_WS_RECV_ERROR      (1 << RTPRTP_WS_RECV_ERROR)
#define RTPRTP_MASK_WS_SEND_ERROR      (1 << RTPRTP_WS_SEND_ERROR)
#define RTPRTP_MASK_WS_NET_FAILURE     (1 << RTPRTP_WS_NET_FAILURE)
#define RTPRTP_MASK_RECV_LOSSRATE      (1 << RTPRTP_RECV_LOSSRATE)
#define RTPRTP_MASK_SEND_LOSSRATE      (1 << RTPRTP_SEND_LOSSRATE)
#define RTPRTP_MASK_BANDESTIMATIONSEND (1 << RTPRTP_BANDESTIMATION)
#define RTPRTP_MASK_CRYPT_RECV_ERROR   (1 << RTPRTP_CRYPT_RECV_ERROR)
#define RTPRTP_MASK_CRYPT_SEND_ERROR   (1 << RTPRTP_CRYPT_SEND_ERROR)
/* RTP prefix
 *
 * A prefix is used to pass extra information from the source RTP
 * filter down stream to the other filters in DShow. There may be as
 * many RTP prefixes as needed, each one begins with a
 * RtpPrefixCommon_t followed by a structure specific to that prefix.
 * A filter not recognizing any prefix will not bother scanning them.
 * A filter expecting a prefix should skip those that it doesn't
 * undestand. Currently there is only 1 prefix used to pass the offset
 * to the payload type and avoid next filters having to compute the
 * variable size RTP header (RTPPREFIXID_HDRSIZE)
 * */
typedef struct _RtpPrefixCommon_t {
    /* Common RtpPrefix */
    WORD             wPrefixID;  /* Prefix ID */
    WORD             wPrefixLen; /* This header length in bytes */
} RtpPrefixCommon_t;

#define RTPPREFIXID_HDRSIZE         1

/*
 * Prefix header for RTP header offset (RTPPREFIXID_HDRSIZE)
 *
 * The lHdrSize field is the number of bytes from the beginnig of the
 * RTP header to the first byte of payload */
typedef struct _RtpPrefixHdr_t {
    /* Common RtpPrefix */
    WORD             wPrefixID;  /* Prefix ID */
    WORD             wPrefixLen; /* This header length in bytes
                                  * (i.e. sizeof(RtpPrefixHdr_t) */
    /* Specific prefix HDRSIZE */
    long             lHdrSize;
} RtpPrefixHdr_t;

/**********************************************************************
 * Participants information (state, events, masks)
 *
 * NOTE: In general, participants generate an event when having state
 * transitions, e.g. event RTPPARINFO_EVENT_TALKING is generated when
 * participant receives RTP packets and goes to the TALKING state.
 * Each event can be enabled or disabled using the mask provided for
 * each of them.
 * Will use with RTPMASK_PINFOR_EVENTS or RTPMASK_PINFOS_EVENTS
 **********************************************************************/

/* Helper enumeration (do not use) for events/states and masks */
enum {
    RTPPARINFO_FIRST,  /* Internal only, do not use */

    /* User was just created (RTP or RTCP packet received) */
    RTPPARINFO_CREATED,

    /* In the conference but not sending data, i.e. sending RTCP
     * packets */
    RTPPARINFO_SILENT,
    
    /* Receiving data from this participant (RTP packets) */
    RTPPARINFO_TALKING,
    
    /* Was just sending data a while ago */
    RTPPARINFO_WAS_TALKING,
    
    /* No RTP/RTCP packets have been received for some time */
    RTPPARINFO_STALL,
    
    /* Left the conference (i.e. sent a RTCP BYE packet) */
    RTPPARINFO_BYE,
    
    /* Participant context has been deleted */
    RTPPARINFO_DEL,

    /* Participant was assigned an output (i.e. mapped) */
    RTPPARINFO_MAPPED,
    
    /* Participant has released its output (i.e. unmapped) */
    RTPPARINFO_UNMAPPED,

    /* Participant has generated network quality metrics update */
    RTPPARINFO_NETWORKCONDITION,
    
    RTPPARINFO_LAST  /* Internal only, do not use */
};

/*
 * Events generated
 */
/*
 * All the events pass the same parameters (except otherwise noted):
 * P1:Remote participant's SSRC, P2:0
 */
#define RTPPARINFO_EVENT_CREATED  (RTPPARINFO_EVENTBASE + RTPPARINFO_CREATED)
#define RTPPARINFO_EVENT_SILENT   (RTPPARINFO_EVENTBASE + RTPPARINFO_SILENT)
#define RTPPARINFO_EVENT_TALKING  (RTPPARINFO_EVENTBASE + RTPPARINFO_TALKING)
#define RTPPARINFO_EVENT_WAS_TALKING (RTPPARINFO_EVENTBASE + RTPPARINFO_WAS_TALKING)
#define RTPPARINFO_EVENT_STALL    (RTPPARINFO_EVENTBASE + RTPPARINFO_STALL)
#define RTPPARINFO_EVENT_BYE      (RTPPARINFO_EVENTBASE + RTPPARINFO_BYE)
#define RTPPARINFO_EVENT_DEL      (RTPPARINFO_EVENTBASE + RTPPARINFO_DEL)

/* P1:Remote participant's SSRC, P2:IPin pointer */
#define RTPPARINFO_EVENT_MAPPED   (RTPPARINFO_EVENTBASE + RTPPARINFO_MAPPED)

/* P1:Remote participant's SSRC, P2:IPin pointer */
#define RTPPARINFO_EVENT_UNMAPPED (RTPPARINFO_EVENTBASE + RTPPARINFO_UNMAPPED)

/*
  NOTE: This event is different from all the others in the sense that
  two actions are needed in order to be generated, first, the network
  metrics computation needs to be enabled (SetNetMetricsState) in one
  or more participants (SSRCs), and second this event needs to be
  enabled
  
  P1:Remote participant's SSRC, P2:Network condition encoded as follows:
      3                   2                   1                 
    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   loss rate   |    jitter     |      RTT      | network metric|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   network metric - encoded as a 0 - 100 quality, where 0 is very bad,
   and 100 is very good.

   RTT - Encoded as 10's of milliseconds.

   jitter - Encoded as milliseconds.
   
   loss rate - encoded as a 1/256 units */
#define RTPPARINFO_EVENT_NETWORKCONDITION \
                           (RTPPARINFO_EVENTBASE + RTPPARINFO_NETWORKCONDITION)

/* Use these macros to extract each metric encoded in P2 with event
 * RTPPARINFO_EVENT_NETWORKCONDITION.
 *
 * network metric is returned as a DWORD 0 - 100 value, RTT is
 * returned as a double in secods, jitter is returned as double in
 * seconds, and loss rate is returned as a double in percentage [0 -
 * 100] */
#define RTPNET_GET_dwGLOBALMETRIC(_p2) ((DWORD) ((_p2) & 0xff))
#define RTPNET_GET_dRTT(_p2)           ((double) (((_p2) >> 8) & 0xff) / 100)
#define RTPNET_GET_dJITTER(_p2)        ((double) (((_p2) >> 16) & 0xff) / 1000)
#define RTPNET_GET_dLOSSRATE(_p2)      ((double) (((_p2)>>24)&0xff)*100.0/256)

/*
 * Masks used to enable/disable the above events (used with
 * RTPMASK_PINFOR_EVENTS or RTPMASK_PINFOS_EVENTS)
 */
#define RTPPARINFO_MASK_CREATED      (1 << RTPPARINFO_CREATED)
#define RTPPARINFO_MASK_SILENT       (1 << RTPPARINFO_SILENT)
#define RTPPARINFO_MASK_TALKING      (1 << RTPPARINFO_TALKING)
#define RTPPARINFO_MASK_WAS_TALKING  (1 << RTPPARINFO_WAS_TALKING)
#define RTPPARINFO_MASK_STALL        (1 << RTPPARINFO_STALL)
#define RTPPARINFO_MASK_BYE          (1 << RTPPARINFO_BYE)
#define RTPPARINFO_MASK_DEL          (1 << RTPPARINFO_DEL)
#define RTPPARINFO_MASK_MAPPED       (1 << RTPPARINFO_MAPPED)
#define RTPPARINFO_MASK_UNMAPPED     (1 << RTPPARINFO_UNMAPPED)
#define RTPPARINFO_MASK_NETWORKCONDITION (1 << RTPPARINFO_NETWORKCONDITION)

/* Helper enumeration (do not use) for the modifiable items in
 * participants */
enum {
    RTPPARITEM_FIRST,  /* Internal only, do not use */

    RTPPARITEM_STATE,  /* qury: e.g TALKING, SILENT, etc. */
    RTPPARITEM_MUTE,   /* set/query: muted or not muted */
    RTPPARITEM_NETEVENT, /* enable/disable/query: genarting events
                          * when network conditions change */
    
    RTPPARITEM_LAST   /* Internal only, do not use */
};

/* Indexes for the items in RtpNetInfo.dItems, used for RTT, Jitter
 * and loss rate
 *
 * WARNING
 *
 * The following enumeration and the min/max bounds
 * (e.g. NETQ_RTT_MAX) defined in struct.h and rtcpdec.c and used by
 * RtpComputNetworkMetrics() must be kept in sync */
enum {
    NETQ_RTT_IDX,         /* Average RTT in seconds */
    NETQ_JITTER_IDX,      /* Average Jitters in seconds */
    NETQ_LOSSRATE_IDX,    /* Average Loss rate is a percentage */
    
    NETQ_LAST_IDX         /* Internal (do not use) */
};

typedef struct _RtpNetInfo_t {
    /* Network quality */
    double           dAvg[NETQ_LAST_IDX];     /* Keep averages */
    double           dHowGood[NETQ_LAST_IDX]; /* Keep a 0-100 metric */
    
    /* Compound network metric as seen by this user, uses the above
     * parameters to come up with a network quality metric between 0
     * and 100, 0 is too bad, and 100 is the best */
    DWORD            dwNetMetrics;  /* 0 - 100 scale */
    union {
        double           dMetricAge;/* Elapsed time since last update (secs) */
        double           dLastUpdate;/* Last time metrics were updated */
    };
} RtpNetInfo_t;

/**********************************************************************
 * QOS (events, masks)
 *
 * NOTE Each QOS event can be enabled or disabled, using the mask
 * provided for each of them.
 * Will use with RTPMASK_QOSSEND_EVENTS or RTPMASK_QOSSEND_EVENTS
 **********************************************************************/

/* Helper enumeration (do not use) for events and masks */
enum {
    RTPQOS_FIRST,   /* Internal only, do not use */
    
    /* no QoS support is available */
    RTPQOS_NOQOS,
    
    /* at least one Reserve has arrived */
    RTPQOS_RECEIVERS,

    /* at least one Path has arrived */
    RTPQOS_SENDERS,

    /* there are no senders */
    RTPQOS_NO_SENDERS,

    /* there are no receivers */
    RTPQOS_NO_RECEIVERS,

    /* Reserve has been confirmed */
    RTPQOS_REQUEST_CONFIRMED,

    /* error due to lack of resources */
    RTPQOS_ADMISSION_FAILURE,
    
    /* rejected for administrative reasons - bad credentials */
    RTPQOS_POLICY_FAILURE,
    
    /* unknown or conflicting style */
    RTPQOS_BAD_STYLE,
    
    /* problem with some part of the filterspec or providerspecific
     * buffer in general */
    RTPQOS_BAD_OBJECT,
    
    /* problem with some part of the flowspec */
    RTPQOS_TRAFFIC_CTRL_ERROR,
    
    /* general error */
    RTPQOS_GENERIC_ERROR,
    
    /* invalid service type in flowspec */
    RTPQOS_ESERVICETYPE,

    /* invalid flowspec */
    RTPQOS_EFLOWSPEC,

    /* invalid provider specific buffer */
    RTPQOS_EPROVSPECBUF,

    /* invalid filter style */
    RTPQOS_EFILTERSTYLE,

    /* invalid filter type */
    RTPQOS_EFILTERTYPE,

    /* incorrect number of filters */
    RTPQOS_EFILTERCOUNT,

    /* invalid object length */
    RTPQOS_EOBJLENGTH,

    /* incorrect number of flows */
    RTPQOS_EFLOWCOUNT,

    /* unknown object in provider specific buffer */
    RTPQOS_EUNKOWNPSOBJ,

    /* invalid policy object in provider specific buffer */
    RTPQOS_EPOLICYOBJ,

    /* invalid flow descriptor in the list */
    RTPQOS_EFLOWDESC,

    /* inconsistent flow spec in provider specific buffer */
    RTPQOS_EPSFLOWSPEC,

    /* invalid filter spec in provider specific buffer */
    RTPQOS_EPSFILTERSPEC,

    /* invalid shape discard mode object in provider specific buffer */
    RTPQOS_ESDMODEOBJ,

    /* invalid shaping rate object in provider specific buffer */
    RTPQOS_ESHAPERATEOBJ,

    /* reserved policy element in provider specific buffer */
    RTPQOS_RESERVED_PETYPE,

    /* sender is not allowed to send */
    RTPQOS_NOT_ALLOWEDTOSEND,
    
    /* sender is allowed to send */
    RTPQOS_ALLOWEDTOSEND,

    RTPQOS_LAST    /* Internal only, do not use */
};

/*
 * Events generated
 */
/* All the events pass the same parameters:
 * P1:0, P2:0
 */
#define RTPQOS_EVENT_NOQOS           (RTPQOS_EVENTBASE + RTPQOS_NOQOS)
#define RTPQOS_EVENT_RECEIVERS       (RTPQOS_EVENTBASE + RTPQOS_RECEIVERS)
#define RTPQOS_EVENT_SENDERS         (RTPQOS_EVENTBASE + RTPQOS_SENDERS)
#define RTPQOS_EVENT_NO_SENDERS      (RTPQOS_EVENTBASE + RTPQOS_NO_SENDERS)
#define RTPQOS_EVENT_NO_RECEIVERS    (RTPQOS_EVENTBASE + RTPQOS_NO_RECEIVERS)
#define RTPQOS_EVENT_REQUEST_CONFIRMED (RTPQOS_EVENTBASE + RTPQOS_REQUEST_CONFIRMED)
#define RTPQOS_EVENT_ADMISSION_FAILURE (RTPQOS_EVENTBASE + RTPQOS_ADMISSION_FAILURE)
#define RTPQOS_EVENT_POLICY_FAILURE  (RTPQOS_EVENTBASE + RTPQOS_POLICY_FAILURE)
#define RTPQOS_EVENT_BAD_STYLE       (RTPQOS_EVENTBASE + RTPQOS_BAD_STYLE)
#define RTPQOS_EVENT_BAD_OBJECT      (RTPQOS_EVENTBASE + RTPQOS_BAD_OBJECT)
#define RTPQOS_EVENT_TRAFFIC_CTRL_ERROR (RTPQOS_EVENTBASE + RTPQOS_TRAFFIC_CTRL_ERROR)
#define RTPQOS_EVENT_GENERIC_ERROR   (RTPQOS_EVENTBASE + RTPQOS_GENERIC_ERROR)
#define RTPQOS_EVENT_ESERVICETYPE    (RTPQOS_EVENTBASE + RTPQOS_ESERVICETYPE)
#define RTPQOS_EVENT_EFLOWSPEC       (RTPQOS_EVENTBASE + RTPQOS_EFLOWSPEC)
#define RTPQOS_EVENT_EPROVSPECBUF    (RTPQOS_EVENTBASE + RTPQOS_EPROVSPECBUF)
#define RTPQOS_EVENT_EFILTERSTYLE    (RTPQOS_EVENTBASE + RTPQOS_EFILTERSTYLE)
#define RTPQOS_EVENT_EFILTERTYPE     (RTPQOS_EVENTBASE + RTPQOS_EFILTERTYPE)
#define RTPQOS_EVENT_EFILTERCOUNT    (RTPQOS_EVENTBASE + RTPQOS_EFILTERCOUNT)
#define RTPQOS_EVENT_EOBJLENGTH      (RTPQOS_EVENTBASE + RTPQOS_EOBJLENGTH)
#define RTPQOS_EVENT_EFLOWCOUNT      (RTPQOS_EVENTBASE + RTPQOS_EFLOWCOUNT)
#define RTPQOS_EVENT_EUNKOWNPSOBJ    (RTPQOS_EVENTBASE + RTPQOS_EUNKOWNPSOBJ)
#define RTPQOS_EVENT_EPOLICYOBJ      (RTPQOS_EVENTBASE + RTPQOS_EPOLICYOBJ)
#define RTPQOS_EVENT_EFLOWDESC       (RTPQOS_EVENTBASE + RTPQOS_EFLOWDESC)
#define RTPQOS_EVENT_EPSFLOWSPEC     (RTPQOS_EVENTBASE + RTPQOS_EPSFLOWSPEC)
#define RTPQOS_EVENT_EPSFILTERSPEC   (RTPQOS_EVENTBASE + RTPQOS_EPSFILTERSPEC)
#define RTPQOS_EVENT_ESDMODEOBJ      (RTPQOS_EVENTBASE + RTPQOS_ESDMODEOBJ)
#define RTPQOS_EVENT_ESHAPERATEOBJ   (RTPQOS_EVENTBASE + RTPQOS_ESHAPERATEOBJ)
#define RTPQOS_EVENT_RESERVED_PETYPE (RTPQOS_EVENTBASE + RTPQOS_RESERVED_PETYPE)
#define RTPQOS_EVENT_NOT_ALLOWEDTOSEND (RTPQOS_EVENTBASE + RTPQOS_NOT_ALLOWEDTOSEND)
#define RTPQOS_EVENT_ALLOWEDTOSEND   (RTPQOS_EVENTBASE + RTPQOS_ALLOWEDTOSEND)

/*
 * Masks used to enable/disable the above events (used with
 * RTPMASK_QOSRECV_EVENTS or RTPMASK_QOSSEND_EVENTS)
 */
#define RTPQOS_MASK_NOQOS              (1 << RTPQOS_NOQOS)
#define RTPQOS_MASK_RECEIVERS          (1 << RTPQOS_RECEIVERS)
#define RTPQOS_MASK_SENDERS            (1 << RTPQOS_SENDERS)
#define RTPQOS_MASK_NO_SENDERS         (1 << RTPQOS_NO_SENDERS)
#define RTPQOS_MASK_NO_RECEIVERS       (1 << RTPQOS_NO_RECEIVERS)
#define RTPQOS_MASK_REQUEST_CONFIRMED  (1 << RTPQOS_REQUEST_CONFIRMED)
#define RTPQOS_MASK_ADMISSION_FAILURE  (1 << RTPQOS_ADMISSION_FAILURE)
#define RTPQOS_MASK_POLICY_FAILURE     (1 << RTPQOS_POLICY_FAILURE)
#define RTPQOS_MASK_BAD_STYLE          (1 << RTPQOS_BAD_STYLE)
#define RTPQOS_MASK_BAD_OBJECT         (1 << RTPQOS_BAD_OBJECT)
#define RTPQOS_MASK_TRAFFIC_CTRL_ERROR (1 << RTPQOS_TRAFFIC_CTRL_ERROR)
#define RTPQOS_MASK_GENERIC_ERROR      (1 << RTPQOS_GENERIC_ERROR)
#define RTPQOS_MASK_ESERVICETYPE       (1 << RTPQOS_ESERVICETYPE)
#define RTPQOS_MASK_EFLOWSPEC          (1 << RTPQOS_EFLOWSPEC)
#define RTPQOS_MASK_EPROVSPECBUF       (1 << RTPQOS_EPROVSPECBUF)
#define RTPQOS_MASK_EFILTERSTYLE       (1 << RTPQOS_EFILTERSTYLE)
#define RTPQOS_MASK_EFILTERTYPE        (1 << RTPQOS_EFILTERTYPE)
#define RTPQOS_MASK_EFILTERCOUNT       (1 << RTPQOS_EFILTERCOUNT)
#define RTPQOS_MASK_EOBJLENGTH         (1 << RTPQOS_EOBJLENGTH)
#define RTPQOS_MASK_EFLOWCOUNT         (1 << RTPQOS_EFLOWCOUNT)
#define RTPQOS_MASK_EUNKOWNPSOBJ       (1 << RTPQOS_EUNKOWNPSOBJ)
#define RTPQOS_MASK_EPOLICYOBJ         (1 << RTPQOS_EPOLICYOBJ)
#define RTPQOS_MASK_EFLOWDESC          (1 << RTPQOS_EFLOWDESC)
#define RTPQOS_MASK_EPSFLOWSPEC        (1 << RTPQOS_EPSFLOWSPEC)
#define RTPQOS_MASK_EPSFILTERSPEC      (1 << RTPQOS_EPSFILTERSPEC)
#define RTPQOS_MASK_ESDMODEOBJ         (1 << RTPQOS_ESDMODEOBJ)
#define RTPQOS_MASK_ESHAPERATEOBJ      (1 << RTPQOS_ESHAPERATEOBJ)
#define RTPQOS_MASK_RESERVED_PETYPE    (1 << RTPQOS_RESERVED_PETYPE)
#define RTPQOS_MASK_NOT_ALLOWEDTOSEND  (1 << RTPQOS_NOT_ALLOWEDTOSEND)
#define RTPQOS_MASK_ALLOWEDTOSEND      (1 << RTPQOS_ALLOWEDTOSEND)

/* QOS template names */
#define RTPQOSNAME_G711                L"G711"
#define RTPQOSNAME_G723_1              L"G723.1"
#define RTPQOSNAME_GSM6_10             L"GSM6.10"
#define RTPQOSNAME_DVI4_8              L"DVI4_8"
#define RTPQOSNAME_DVI4_16             L"DVI4_16"
#define RTPQOSNAME_SIREN               L"SIREN"
#define RTPQOSNAME_G722_1              L"G722.1"
#define RTPQOSNAME_MSAUDIO             L"MSAUDIO"
#define RTPQOSNAME_H263QCIF            L"H263QCIF"
#define RTPQOSNAME_H263CIF             L"H263CIF"
#define RTPQOSNAME_H261QCIF            L"H261QCIF"
#define RTPQOSNAME_H261CIF             L"H261CIF"

/* RTP reservation styles */
enum {
    /* Use default style, i.e. FF for unicast, WF for multicast */
    RTPQOS_STYLE_DEFAULT,

    /* Wildcard-Filter (default in multicast) */
    RTPQOS_STYLE_WF,

    /* Fixed-Filter (default in unicast) */
    RTPQOS_STYLE_FF,

    /* Shared-Explicit (for multicast, typically for video) */
    RTPQOS_STYLE_SE,

    RTPQOS_STYLE_LAST
};

/* Used to derive a flow spec. This information is obtained from the
 * codecs and passed to RTP to generate a QOS flow spec that closelly
 * describes the codecs generating/receiving traffic */
typedef struct _RtpQosSpec_t {
    DWORD            dwAvgRate;       /* bits/s */
    DWORD            dwPeakRate;      /* bits/s */
    DWORD            dwMinPacketSize; /* bytes */
    DWORD            dwMaxPacketSize; /* bytes */
    DWORD            dwMaxBurst;      /* number of packets */
    DWORD            dwResvStyle;     /* maps to FF, WF, or SE */
} RtpQosSpec_t;

/* Helper enumeration (do not use) */
enum {
    RTPQOS_QOSLIST_FIRST,  /* Internal only, do not use */

    /* Enable Add/Delete */
    RTPQOS_QOSLIST_ENABLE,

    /* If Enabled, select Add */
    RTPQOS_QOSLIST_ADD,

    /* Flush */
    RTPQOS_QOSLIST_FLUSH,
    
    RTPQOS_QOSLIST_LAST    /* Internal only, do not use */
};

/* Values for parameter dwOperation in ModifyQosList().
 * They can be OR'ed */
#define RTPQOS_ADD_SSRC ((1<<RTPQOS_QOSLIST_ENABLE) | (1<<RTPQOS_QOSLIST_ADD))
#define RTPQOS_DEL_SSRC (1 << RTPQOS_QOSLIST_ENABLE)
#define RTPQOS_FLUSH    (1 << RTPQOS_QOSLIST_FLUSH)

/* Allowed to send mode */
/* Passed as parameters dwQosSendMode in SetQosByName or
 * SetQosParameters functions */
enum {
    RTPQOSSENDMODE_FIRST,   /* Internal only, do not use */

    /* Don't ask for permission to send */
    RTPQOSSENDMODE_UNRESTRICTED,

    /* Ask permission to send, if denied, keep sending at a reduced
     * rate */
    RTPQOSSENDMODE_REDUCED_RATE,

    /* Ask permission to send, if denied, DON'T SEND at all */
    RTPQOSSENDMODE_DONT_SEND,
    
    /* Ask permission to send, send at normal rate no matter what, the
     * application is supposed to stop passing data to RTP or to pass
     * the very minimum (this is the mode that should be used) */
    RTPQOSSENDMODE_ASK_BUT_SEND,
    
    RTPQOSSENDMODE_LAST     /* Internal only, do not use */
};

/* Maximum number of UNICODE chars to set in the QOS policy locator
 * and app ID */
#define MAX_QOS_APPID   128
#define MAX_QOS_APPGUID 128
#define MAX_QOS_POLICY  128

/**********************************************************************
 * SDES local/remote information (events, masks)
 * Will use with RTPMASK_SDESRECV_EVENTS or RTPMASK_SDESSEND_EVENTS or
 * RTPMASK_SDES_LOCMASK or RTPMASK_SDES_REMMASK
 **********************************************************************/

/* Helper enumeration (do not use) for events and masks */
enum {
    RTPSDES_FIRST,  /* Internal only, do not use */

    /* RTCP SDES CNAME Canonical name */
    RTPSDES_CNAME,

    /* RTCP SDES NAME User name*/
    RTPSDES_NAME,

    /* RTCP SDES EMAIL User's e-mail */
    RTPSDES_EMAIL,

    /* RTCP SDES PHONE User's phone number */
    RTPSDES_PHONE,

    /* RTCP SDES LOC User's location */
    RTPSDES_LOC,

    /* RTCP SDES TOOL Tools (application) used */
    RTPSDES_TOOL,

    /* RTCP SDES NOTE Note about the user/site */
    RTPSDES_NOTE,

    /* RTCP SDES PRIV Private information */
    RTPSDES_PRIV,

    /* RTCP SDES ANY Any of the above */
    RTPSDES_ANY,

    RTPSDES_LAST    /* Internal only, do not use */
};

#define RTPSDES_END RTPSDES_FIRST

/*
 * Events generated when the specific SDES field is received for the
 * first time (used with RTPMASK_SDES_EVENTS)
 */
/* All the events pass the same parameters:
 * P1:Remote participant's SSRC, P2:The event index (as in the above
 * enumeration.
 * Note that the event index goes from RTPSDES_CNAME to RTPSDES_PRIV
 */
#define RTPSDES_EVENT_CNAME        (RTPSDES_EVENTBASE + RTPSDES_CNAME)
#define RTPSDES_EVENT_NAME         (RTPSDES_EVENTBASE + RTPSDES_NAME)
#define RTPSDES_EVENT_EMAIL        (RTPSDES_EVENTBASE + RTPSDES_EMAIL)
#define RTPSDES_EVENT_PHONE        (RTPSDES_EVENTBASE + RTPSDES_PHONE)
#define RTPSDES_EVENT_LOC          (RTPSDES_EVENTBASE + RTPSDES_LOC)
#define RTPSDES_EVENT_TOOL         (RTPSDES_EVENTBASE + RTPSDES_TOOL)
#define RTPSDES_EVENT_NOTE         (RTPSDES_EVENTBASE + RTPSDES_NOTE)
#define RTPSDES_EVENT_PRIV         (RTPSDES_EVENTBASE + RTPSDES_PRIV)
#define RTPSDES_EVENT_ANY          (RTPSDES_EVENTBASE + RTPSDES_ANY)

/*
 * Masks used to enable/disable the above events (used with
 * RTPMASK_SDESRECV_EVENTS and RTPMASK_SDESSEND_EVENTS)
 */
#define RTPSDES_MASK_CNAME         (1 << RTPSDES_CNAME)
#define RTPSDES_MASK_NAME          (1 << RTPSDES_NAME)
#define RTPSDES_MASK_EMAIL         (1 << RTPSDES_EMAIL)
#define RTPSDES_MASK_PHONE         (1 << RTPSDES_PHONE)
#define RTPSDES_MASK_LOC           (1 << RTPSDES_LOC)
#define RTPSDES_MASK_TOOL          (1 << RTPSDES_TOOL)
#define RTPSDES_MASK_NOTE          (1 << RTPSDES_NOTE)
#define RTPSDES_MASK_PRIV          (1 << RTPSDES_PRIV)
#define RTPSDES_MASK_ANY           (1 << RTPSDES_ANY)

/*
 * Masks used to enable/disable sending each SDES field (used with
 * RTPMASK_SDES_LOCMASK)
 */
#define RTPSDES_LOCMASK_CNAME      (1 << RTPSDES_CNAME)
#define RTPSDES_LOCMASK_NAME       (1 << RTPSDES_NAME)
#define RTPSDES_LOCMASK_EMAIL      (1 << RTPSDES_EMAIL)
#define RTPSDES_LOCMASK_PHONE      (1 << RTPSDES_PHONE)
#define RTPSDES_LOCMASK_LOC        (1 << RTPSDES_LOC)
#define RTPSDES_LOCMASK_TOOL       (1 << RTPSDES_TOOL)
#define RTPSDES_LOCMASK_NOTE       (1 << RTPSDES_NOTE)
#define RTPSDES_LOCMASK_PRIV       (1 << RTPSDES_PRIV)

/*
 * Masks used to enable/disable keeping each SDES field from the
 * remote participants (used with RTPMASK_SDES_REMMASK)
 */
#define RTPSDES_REMMASK_CNAME      (1 << RTPSDES_CNAME)
#define RTPSDES_REMMASK_NAME       (1 << RTPSDES_NAME)
#define RTPSDES_REMMASK_EMAIL      (1 << RTPSDES_EMAIL)
#define RTPSDES_REMMASK_PHONE      (1 << RTPSDES_PHONE)
#define RTPSDES_REMMASK_LOC        (1 << RTPSDES_LOC)
#define RTPSDES_REMMASK_TOOL       (1 << RTPSDES_TOOL)
#define RTPSDES_REMMASK_NOTE       (1 << RTPSDES_NOTE)
#define RTPSDES_REMMASK_PRIV       (1 << RTPSDES_PRIV)

/**********************************************************************
 * RTP encryption
 **********************************************************************/

/* RTP encryption modes */
enum {
    RTPCRYPTMODE_FIRST,  /* Internal only, do not use */

    /* Encrypt/Decrypt RTP payload only */
    RTPCRYPTMODE_PAYLOAD,

    /* Encrypt/Decrypt RTP packets only */
    RTPCRYPTMODE_RTP,

    /* Encrypt/Decrypt RTP and RTCP packets */
    RTPCRYPTMODE_ALL,

    RTPCRYPTMODE_LAST    /* Internal only, do not use */
};

/* Helper enumeration (do not use) for mode flags */
enum {
    RTPCRYPTFG_FIRST = 16, /* Internal only, do not use */

    /* Use the same key for RECV, SEND, and RTCP */
    RTPCRYPTFG_SAMEKEY,
    
    RTPCRYPTFG_LAST,       /* Internal only, do not use */
};    

/*
 * Flags to modify mode
 */
#define RTPCRYPT_SAMEKEY           (1 << RTPCRYPTFG_SAMEKEY)

/* Max pass phrase in bytes (after it is converted from UNICODE to
 * UTF-8), the resulting data is stored in an array this size big */
#define RTPCRYPT_PASSPHRASEBUFFSIZE 256

/*
 * The following hashing and data encryption algorithms work on
 * Windows2000 out of the box, other algorithms may work with other
 * providers
 * */

/*
 * Hashing algorithms to use in SetEncryptionKey, default hash
 * algorithm is RTPCRYPT_HASH_MD5 */
#define  RTPCRYPT_HASH_MD2                   L"MD2"
#define  RTPCRYPT_HASH_MD4                   L"MD4"
#define  RTPCRYPT_HASH_MD5                   L"MD5"
#define  RTPCRYPT_HASH_SHA                   L"SHA"
#define  RTPCRYPT_HASH_SHA1                  L"SHA1"

/*
 * Encryption algorithms to use in SetEncryptionKey, default data
 * encryption algorithm is RTPCRYPT_DATA_DES */
#define  RTPCRYPT_DATA_DES                   L"DES"
#define  RTPCRYPT_DATA_3DES                  L"3DES"
#define  RTPCRYPT_DATA_RC2                   L"RC2"
#define  RTPCRYPT_DATA_RC4                   L"RC4"

/* NOTE
 *
 * The stack will be able to recognize the following algorithms, if
 * supported:
 *
 * L"MD2"
 * L"MD4"
 * L"MD5"
 * L"SHA"
 * L"SHA1"
 * L"MAC"
 * L"RSA_SIGN"
 * L"DSS_SIGN"
 * L"RSA_KEYX"
 * L"DES"
 * L"3DES_112"
 * L"3DES"
 * L"DESX"
 * L"RC2"
 * L"RC4"
 * L"SEAL"
 * L"DH_SF"
 * L"DH_EPHEM"
 * L"AGREEDKEY_ANY"
 * L"KEA_KEYX"
 * L"HUGHES_MD5"
 * L"SKIPJACK"
 * L"TEK"
 * L"CYLINK_MEK"
 * L"SSL3_SHAMD5"
 * L"SSL3_MASTER"
 * L"SCHANNEL_MASTER_HASH"
 * L"SCHANNEL_MAC_KEY"
 * L"SCHANNEL_ENC_KEY"
 * L"PCT1_MASTER"
 * L"SSL2_MASTER"
 * L"TLS1_MASTER"
 * L"RC5"
 * L"HMAC"
 * L"TLS1PRF"
 * */

/**********************************************************************
 * RTP Demux
 **********************************************************************/
/* Demux modes */
enum {
    RTPDMXMODE_FIRST,   /* Internal only, do not use */

    /* Manual mapping */
    RTPDMXMODE_MANUAL,

    /* Automatically map and unmap */
    RTPDMXMODE_AUTO,

    /* Automatically map, manual unmap */
    RTPDMXMODE_AUTO_MANUAL,
    
    RTPDMXMODE_LAST     /* Internal only, do not use */
};

/* State used in SetMappingState */
#define RTPDMX_PINMAPPED   TRUE
#define RTPDMX_PINUNMAPPED FALSE

/* Maximum number of payload type mappings */
#define MAX_MEDIATYPE_MAPPINGS  10

/**********************************************************************
 * DTMF (RFC2833)
 **********************************************************************/
/* Events sent */
enum {
    RTPDTMF_FIRST = 0,  /* Internal only, do not use */
    
    RTPDTMF_0 = 0,      /*  0 */
    RTPDTMF_1,          /*  1 */
    RTPDTMF_2,          /*  2 */
    RTPDTMF_3,          /*  3 */
    RTPDTMF_4,          /*  4 */
    RTPDTMF_5,          /*  5 */
    RTPDTMF_6,          /*  6 */
    RTPDTMF_7,          /*  7 */
    RTPDTMF_8,          /*  8 */
    RTPDTMF_9,          /*  9 */
    RTPDTMF_STAR,       /* 10 */
    RTPDTMF_POUND,      /* 11 */
    RTPDTMF_A,          /* 12 */
    RTPDTMF_B,          /* 13 */
    RTPDTMF_C,          /* 14 */
    RTPDTMF_D,          /* 15 */
    RTPDTMF_FLASH,      /* 16 */

    RTPDTMF_LAST        /* Internal only, do not use */
};
    
    

#endif /* _msrtp_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\inc\loc_comn.h ===
/****************************************************************************
 
  Copyright (c) 1995-1999 Microsoft Corporation
                                                              
  Module Name:  loc_comn.h
                                                              
****************************************************************************/

#ifndef __LOC_COMN_H_
#define __LOC_COMN_H_

#ifndef UNICODE

// For ANSI we need wrappers that will call the A version of the given function
// and then convert the return result to Unicode

LONG TAPIRegQueryValueExW(
                           HKEY hKey,
                           const TCHAR *SectionName,
                           LPDWORD lpdwReserved,
                           LPDWORD lpType,
                           LPBYTE  lpData,
                           LPDWORD lpcbData
                          );

LONG TAPIRegSetValueExW(
                         HKEY    hKey,
                         const TCHAR    *SectionName,
                         DWORD   dwReserved,
                         DWORD   dwType,
                         LPBYTE  lpData,
                         DWORD   cbData
                        );

int TAPILoadStringW(
                HINSTANCE hInst,
                UINT      uID,
                PWSTR     pBuffer,
                int       nBufferMax
               );

HINSTANCE TAPILoadLibraryW(
                PWSTR     pszLibraryW
               );

BOOL WINAPI TAPIIsBadStringPtrW( LPCWSTR lpsz, UINT cchMax );


#else // UNICODE is defined

// For Unicode we already get the correct return type so don't call the wrappers.

#define TAPIRegQueryValueExW    RegQueryValueExW
#define TAPIRegSetValueExW      RegSetValueExW
#define TAPILoadStringW         LoadStringW
#define TAPILoadLibraryW        LoadLibraryW
#define TAPIIsBadStringPtrW     IsBadStringPtrW

#endif  // !UNICODE


//***************************************************************************
#define LOCATION_USETONEDIALING        0x00000001
#define LOCATION_USECALLINGCARD        0x00000002
#define LOCATION_HASCALLWAITING        0x00000004
#define LOCATION_ALWAYSINCLUDEAREACODE 0x00000008


//***************************************************************************
//***************************************************************************
//***************************************************************************
#define CHANGEDFLAGS_CURLOCATIONCHANGED      0x00000001
#define CHANGEDFLAGS_REALCHANGE              0x00000002
#define CHANGEDFLAGS_TOLLLIST                0x00000004


//***************************************************************************
//***************************************************************************
//***************************************************************************
//
// These bits decide which params TAPISRV will check on READLOCATION and
// WRITELOCATION operations
//
#define CHECKPARMS_DWHLINEAPP       0x00000001
#define CHECKPARMS_DWDEVICEID       0x00000002
#define CHECKPARMS_DWAPIVERSION     0x00000004
#define GET_CURRENTLOCATION         0x00000008
#define GET_NUMLOCATIONS            0x00000010
#define CHECKPARMS_ONLY             0x00000020

//***************************************************************************
//***************************************************************************
//***************************************************************************
#define DWTOTALSIZE  0
#define DWNEEDEDSIZE 1
#define DWUSEDSIZE   2


//***************************************************************************
#define RULE_APPLIESTOALLPREFIXES   0x00000001
#define RULE_DIALAREACODE           0x00000002
#define RULE_DIALNUMBER             0x00000004



//***************************************************************************
//
// Structures used to pass location & area code rule info Client <--> TAPISRV
//
typedef struct 
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    
    DWORD       dwCurrentLocationID;
    DWORD       dwNumLocationsAvailable;

    DWORD       dwNumLocationsInList;
    DWORD       dwLocationListSize;
    DWORD       dwLocationListOffset;
    
} LOCATIONLIST,  *PLOCATIONLIST;

typedef struct
{
    DWORD       dwUsedSize;
    DWORD       dwPermanentLocationID;
    DWORD       dwCountryCode;
    DWORD       dwCountryID;
    DWORD       dwPreferredCardID;
    DWORD       dwOptions;

    DWORD       dwLocationNameSize;
    DWORD       dwLocationNameOffset;           // offset is relative to LOCATION struct
    
    DWORD       dwAreaCodeSize;
    DWORD       dwAreaCodeOffset;               // offset is relative to LOCATION struct

    DWORD       dwLongDistanceCarrierCodeSize;
    DWORD       dwLongDistanceCarrierCodeOffset; // offset is relative to LOCATION struct

    DWORD       dwInternationalCarrierCodeSize;
    DWORD       dwInternationalCarrierCodeOffset; // offset is relative to LOCATION struct

    DWORD       dwLocalAccessCodeSize;
    DWORD       dwLocalAccessCodeOffset;        // offset is relative to LOCATION struct
    
    DWORD       dwLongDistanceAccessCodeSize;
    DWORD       dwLongDistanceAccessCodeOffset; // offset is relative to LOCATION struct

    DWORD       dwCancelCallWaitingSize;
    DWORD       dwCancelCallWaitingOffset;      // offset is relative to LOCATION struct

    DWORD       dwNumAreaCodeRules;
    DWORD       dwAreaCodeRulesListSize;
    DWORD       dwAreaCodeRulesListOffset;      // offset is relative to LOCATION struct
    

} LOCATION, * PLOCATION;

typedef struct                       
{                                                
    DWORD       dwOptions;                       
                                                 
    DWORD       dwAreaCodeSize;                  
    DWORD       dwAreaCodeOffset;               // offset is relative to enclosing LOCATION struct     
                                                 
    DWORD       dwNumberToDialSize;           
    DWORD       dwNumberToDialOffset;           // offset is relative to enclosing LOCATION struct
                                                 
    DWORD       dwPrefixesListSize;             
    DWORD       dwPrefixesListOffset;           // offset is relative to enclosing LOCATION struct           
                                                 
                                                 
} AREACODERULE, * PAREACODERULE;   


#endif // __LOC_COMN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\inc\line.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    line.h

Abstract:

    Header file for tapi server line functions

Author:

    Dan Knudson (DanKn)    01-Apr-1995

Revision History:

--*/


#define MAXLEN_NAME    96
#define MAXLEN_RULE    128



#define ANY_RT_HCALL        1
#define ANY_RT_HLINE        2
#define DEVICE_ID           3


#if DBG

#define LINEPROLOG(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14) \
        LineProlog(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14)

#define LINEEPILOGSYNC(a1,a2,a3,a4,a5) LineEpilogSync(a1,a2,a3,a4,a5)

#define LINEEPILOGASYNC(a1,a2,a3,a4,a5,a6,a7) \
        LineEpilogAsync(a1,a2,a3,a4,a5,a6,a7)

#else

#define LINEPROLOG(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14) \
        LineProlog(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13)

#define LINEEPILOGSYNC(a1,a2,a3,a4,a5) LineEpilogSync(a1,a2,a3,a4)

#define LINEEPILOGASYNC(a1,a2,a3,a4,a5,a6,a7) \
        LineEpilogAsync(a1,a2,a3,a4,a5,a6)

#endif


#define AllAddressTypes                   \
    (LINEADDRESSTYPE_PHONENUMBER        | \
    LINEADDRESSTYPE_SDP                 | \
    LINEADDRESSTYPE_EMAILNAME           | \
    LINEADDRESSTYPE_DOMAINNAME          | \
    LINEADDRESSTYPE_IPADDRESS)

#define AllAddressStates1_0               \
    (LINEADDRESSSTATE_OTHER             | \
    LINEADDRESSSTATE_DEVSPECIFIC        | \
    LINEADDRESSSTATE_INUSEZERO          | \
    LINEADDRESSSTATE_INUSEONE           | \
    LINEADDRESSSTATE_INUSEMANY          | \
    LINEADDRESSSTATE_NUMCALLS           | \
    LINEADDRESSSTATE_FORWARD            | \
    LINEADDRESSSTATE_TERMINALS)

#define AllAddressStates1_4               \
    (AllAddressStates1_0                | \
    LINEADDRESSSTATE_CAPSCHANGE)

//#define AllAddressStates2_0               \
//    (AllAddressStates1_4                | \
//    LINEADDRESSSTATE_AGENT              | \
//    LINEADDRESSSTATE_AGENTSTATE         | \
//    LINEADDRESSSTATE_AGENTACTIVITY)

#define AllAgentStates                    \
    (LINEAGENTSTATE_LOGGEDOFF           | \
    LINEAGENTSTATE_NOTREADY             | \
    LINEAGENTSTATE_READY                | \
    LINEAGENTSTATE_BUSYACD              | \
    LINEAGENTSTATE_BUSYINCOMING         | \
    LINEAGENTSTATE_BUSYOUTBOUND         | \
    LINEAGENTSTATE_BUSYOTHER            | \
    LINEAGENTSTATE_WORKINGAFTERCALL     | \
    LINEAGENTSTATE_UNKNOWN              | \
    LINEAGENTSTATE_UNAVAIL              | \
    0xffff0000)

#define AllAgentStatus                    \
    (LINEAGENTSTATUS_GROUP              | \
    LINEAGENTSTATUS_STATE               | \
    LINEAGENTSTATUS_NEXTSTATE           | \
    LINEAGENTSTATUS_ACTIVITY            | \
    LINEAGENTSTATUS_ACTIVITYLIST        | \
    LINEAGENTSTATUS_GROUPLIST           | \
    LINEAGENTSTATUS_CAPSCHANGE          | \
    LINEAGENTSTATUS_VALIDSTATES         | \
    LINEAGENTSTATUS_VALIDNEXTSTATES)

#define AllAgentSessionStates             \
    (LINEAGENTSESSIONSTATE_NOTREADY     | \
    LINEAGENTSESSIONSTATE_READY         | \
    LINEAGENTSESSIONSTATE_BUSYONCALL    | \
    LINEAGENTSESSIONSTATE_BUSYWRAPUP    | \
    LINEAGENTSESSIONSTATE_ENDED         | \
    LINEAGENTSESSIONSTATE_RELEASED)

#define AllAgentSessionStatus             \
    (LINEAGENTSESSIONSTATUS_NEWSESSION  | \
    LINEAGENTSESSIONSTATUS_STATE        | \
    LINEAGENTSESSIONSTATUS_UPDATEINFO)

#define AllAgentStatusEx                  \
    (LINEAGENTSTATUSEX_NEWAGENT         | \
    LINEAGENTSTATUSEX_STATE             | \
    LINEAGENTSTATUSEX_UPDATEINFO)
                                        
#define AllAgentStatesEx                  \
    (LINEAGENTSTATEEX_NOTREADY          | \
    LINEAGENTSTATEEX_READY              | \
    LINEAGENTSTATEEX_BUSYACD            | \
    LINEAGENTSTATEEX_BUSYINCOMING       | \
    LINEAGENTSTATEEX_BUSYOUTGOING       | \
    LINEAGENTSTATEEX_UNKNOWN            | \
    LINEAGENTSTATEEX_RELEASED)    


#define AllBearerModes1_0                 \
    (LINEBEARERMODE_VOICE               | \
    LINEBEARERMODE_SPEECH               | \
    LINEBEARERMODE_MULTIUSE             | \
    LINEBEARERMODE_DATA                 | \
    LINEBEARERMODE_ALTSPEECHDATA        | \
    LINEBEARERMODE_NONCALLSIGNALING)

#define AllBearerModes1_4                 \
    (AllBearerModes1_0                  | \
    LINEBEARERMODE_PASSTHROUGH)

#define AllBearerModes2_0                 \
    (AllBearerModes1_4                  | \
    LINEBEARERMODE_RESTRICTEDDATA)

#define AllCallComplModes                 \
    (LINECALLCOMPLMODE_CAMPON           | \
    LINECALLCOMPLMODE_CALLBACK          | \
    LINECALLCOMPLMODE_INTRUDE           | \
    LINECALLCOMPLMODE_MESSAGE)

#define AllCallParamFlags1_0              \
    (LINECALLPARAMFLAGS_SECURE          | \
    LINECALLPARAMFLAGS_IDLE             | \
    LINECALLPARAMFLAGS_BLOCKID          | \
    LINECALLPARAMFLAGS_ORIGOFFHOOK      | \
    LINECALLPARAMFLAGS_DESTOFFHOOK)

#define AllCallParamFlags2_0              \
    (LINECALLPARAMFLAGS_SECURE          | \
    LINECALLPARAMFLAGS_IDLE             | \
    LINECALLPARAMFLAGS_BLOCKID          | \
    LINECALLPARAMFLAGS_ORIGOFFHOOK      | \
    LINECALLPARAMFLAGS_DESTOFFHOOK      | \
    LINECALLPARAMFLAGS_NOHOLDCONFERENCE | \
    LINECALLPARAMFLAGS_PREDICTIVEDIAL   | \
    LINECALLPARAMFLAGS_ONESTEPTRANSFER)

#define AllCallSelects                    \
    (LINECALLSELECT_LINE                | \
    LINECALLSELECT_ADDRESS              | \
    LINECALLSELECT_CALL)

#define AllForwardModes1_0                \
    (LINEFORWARDMODE_UNCOND             | \
    LINEFORWARDMODE_UNCONDINTERNAL      | \
    LINEFORWARDMODE_UNCONDEXTERNAL      | \
    LINEFORWARDMODE_UNCONDSPECIFIC      | \
    LINEFORWARDMODE_BUSY                | \
    LINEFORWARDMODE_BUSYINTERNAL        | \
    LINEFORWARDMODE_BUSYEXTERNAL        | \
    LINEFORWARDMODE_BUSYSPECIFIC        | \
    LINEFORWARDMODE_NOANSW              | \
    LINEFORWARDMODE_NOANSWINTERNAL      | \
    LINEFORWARDMODE_NOANSWEXTERNAL      | \
    LINEFORWARDMODE_NOANSWSPECIFIC      | \
    LINEFORWARDMODE_BUSYNA              | \
    LINEFORWARDMODE_BUSYNAINTERNAL      | \
    LINEFORWARDMODE_BUSYNAEXTERNAL      | \
    LINEFORWARDMODE_BUSYNASPECIFIC)

#define AllForwardModes1_4                \
    (AllForwardModes1_0                 | \
    LINEFORWARDMODE_UNKNOWN             | \
    LINEFORWARDMODE_UNAVAIL)

#define AllGroupStatus                    \
    (LINEGROUPSTATUS_NEWGROUP           | \
    LINEGROUPSTATUS_GROUPREMOVED)      


#define AllLineStates1_0                  \
    (LINEDEVSTATE_OTHER                 | \
    LINEDEVSTATE_RINGING                | \
    LINEDEVSTATE_CONNECTED              | \
    LINEDEVSTATE_DISCONNECTED           | \
    LINEDEVSTATE_MSGWAITON              | \
    LINEDEVSTATE_MSGWAITOFF             | \
    LINEDEVSTATE_INSERVICE              | \
    LINEDEVSTATE_OUTOFSERVICE           | \
    LINEDEVSTATE_MAINTENANCE            | \
    LINEDEVSTATE_OPEN                   | \
    LINEDEVSTATE_CLOSE                  | \
    LINEDEVSTATE_NUMCALLS               | \
    LINEDEVSTATE_NUMCOMPLETIONS         | \
    LINEDEVSTATE_TERMINALS              | \
    LINEDEVSTATE_ROAMMODE               | \
    LINEDEVSTATE_BATTERY                | \
    LINEDEVSTATE_SIGNAL                 | \
    LINEDEVSTATE_DEVSPECIFIC            | \
    LINEDEVSTATE_REINIT                 | \
    LINEDEVSTATE_LOCK)

#define AllLineStates1_4                  \
    (AllLineStates1_0                   | \
    LINEDEVSTATE_CAPSCHANGE             | \
    LINEDEVSTATE_CONFIGCHANGE           | \
    LINEDEVSTATE_TRANSLATECHANGE        | \
    LINEDEVSTATE_COMPLCANCEL            | \
    LINEDEVSTATE_REMOVED)

#define AllMediaModes1_0                  \
    (LINEMEDIAMODE_UNKNOWN              | \
    LINEMEDIAMODE_INTERACTIVEVOICE      | \
    LINEMEDIAMODE_AUTOMATEDVOICE        | \
    LINEMEDIAMODE_DIGITALDATA           | \
    LINEMEDIAMODE_G3FAX                 | \
    LINEMEDIAMODE_G4FAX                 | \
    LINEMEDIAMODE_DATAMODEM             | \
    LINEMEDIAMODE_TELETEX               | \
    LINEMEDIAMODE_VIDEOTEX              | \
    LINEMEDIAMODE_TELEX                 | \
    LINEMEDIAMODE_MIXED                 | \
    LINEMEDIAMODE_TDD                   | \
    LINEMEDIAMODE_ADSI)

#define AllMediaModes1_4                  \
    (AllMediaModes1_0                   | \
    LINEMEDIAMODE_VOICEVIEW)

#define AllMediaModes2_1                  \
    (AllMediaModes1_4                   | \
    LINEMEDIAMODE_VIDEO)

#define AllProxyStatus                    \
    (LINEPROXYSTATUS_OPEN               | \
    LINEPROXYSTATUS_CLOSE)

#define AllRequiredACDProxyRequests3_0                    \
     ((1<<LINEPROXYREQUEST_GETAGENTCAPS)                | \
     (1<<LINEPROXYREQUEST_CREATEAGENT)                  | \
     (1<<LINEPROXYREQUEST_SETAGENTMEASUREMENTPERIOD)    | \
     (1<<LINEPROXYREQUEST_GETAGENTINFO)                 | \
     (1<<LINEPROXYREQUEST_CREATEAGENTSESSION)           | \
     (1<<LINEPROXYREQUEST_GETAGENTSESSIONLIST)          | \
     (1<<LINEPROXYREQUEST_SETAGENTSESSIONSTATE)         | \
     (1<<LINEPROXYREQUEST_GETAGENTSESSIONINFO)          | \
     (1<<LINEPROXYREQUEST_GETQUEUELIST)                 | \
     (1<<LINEPROXYREQUEST_SETQUEUEMEASUREMENTPERIOD)    | \
     (1<<LINEPROXYREQUEST_GETQUEUEINFO)                 | \
     (1<<LINEPROXYREQUEST_GETGROUPLIST)                 | \
     (1<<LINEPROXYREQUEST_SETAGENTSTATEEX))          

#define AllQueueStatus                    \
    (LINEQUEUESTATUS_UPDATEINFO         | \
    LINEQUEUESTATUS_NEWQUEUE            | \
    LINEQUEUESTATUS_QUEUEREMOVED)

#define AllTerminalModes                  \
    (LINETERMMODE_BUTTONS               | \
    LINETERMMODE_LAMPS                  | \
    LINETERMMODE_DISPLAY                | \
    LINETERMMODE_RINGER                 | \
    LINETERMMODE_HOOKSWITCH             | \
    LINETERMMODE_MEDIATOLINE            | \
    LINETERMMODE_MEDIAFROMLINE          | \
    LINETERMMODE_MEDIABIDIRECT)


LONG
PASCAL
LineProlog(
    PTCLIENT    ptClient,
    DWORD       dwArgType,
    DWORD       dwArg,
    LPVOID      phdXxx,
    DWORD       dwPrivilege,
    HANDLE     *phMutex,
    BOOL       *pbCloseMutex,
    DWORD       dwTSPIFuncIndex,
    TSPIPROC   *ppfnTSPI_lineXxx,
    PASYNCREQUESTINFO  *ppAsyncRequestInfo,
    DWORD       dwRemoteRequestID,
    DWORD      *pObjectToDereference,
    LPVOID     *pContext
#if DBG
    ,char      *pszFuncName
#endif
    );

void
PASCAL
LineEpilogSync(
    LONG   *plResult,
    HANDLE  hMutex,
    BOOL    bCloseMutex,
    DWORD   ObjectToDereference
#if DBG
    ,char *pszFuncName
#endif
    );



PTLINEAPP
PASCAL
IsValidLineApp(
    HLINEAPP    hLineApp,
    PTCLIENT    ptClient
    );



typedef struct _LINEACCEPT_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwUserUserInfoOffset;       // valid offset or
    };

    union
    {
        IN  DWORD       dwSize;
    };

} LINEACCEPT_PARAMS, *PLINEACCEPT_PARAMS;


typedef struct _LINEADDTOCONFERENCE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hConfCall;
    };

    union
    {
        IN  HCALL       hConsultCall;
    };


} LINEADDTOCONFERENCE_PARAMS, *PLINEADDTOCONFERENCE_PARAMS;


typedef struct _LINEAGENTSPECIFIC_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    // IN  DWORD       hfnPostProcessProc;
    IN  DWORD          hfnPostProcessProc;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    union
    {
        IN  DWORD       dwAgentExtensionIDIndex;
    };

    // IN  ULONG_PTR       lpParams;                   // pointer to client buffer
    IN  DWORD           hpParams;

    union
    {
        IN  DWORD       dwParamsOffset;             // valid offset or
    };

    union
    {
        IN  DWORD       dwParamsSize;
    };

} LINEAGENTSPECIFIC_PARAMS, *PLINEAGENTSPECIFIC_PARAMS;


typedef struct _LINEANSWER_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwUserUserInfoOffset;       // valid offset or
    };

    union
    {
        IN  DWORD       dwUserUserInfoSize;
    };

} LINEANSWER_PARAMS, *PLINEANSWER_PARAMS;


typedef struct _LINEBLINDTRANSFER_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwDestAddressOffset;        // always valid offset
    };

    union
    {
        IN  DWORD       dwCountryCode;
    };

} LINEBLINDTRANSFER_PARAMS, *PLINEBLINDTRANSFER_PARAMS;


typedef struct _LINECLOSE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD			    dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    OUT DWORD           dwCallbackInstance;

} LINECLOSE_PARAMS, *PLINECLOSE_PARAMS;


typedef struct _LINECLOSEMSPINSTANCE_PARAMS
{
    union
    {
        OUT LONG            lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE           hLine;
    };
    
} LINECLOSEMSPINSTANCE_PARAMS, *PLINECLOSEMSPINSTANCE_PARAMS;


typedef struct _LINECOMPLETECALL_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD           hfnPostProcessProc;

    union
    {
        IN  HCALL       hCall;
    };

    IN  DWORD           hpdwCompletionID;

    union
    {
        IN  DWORD       dwCompletionMode;
    };

    union
    {
        IN  DWORD       dwMessageID;
    };

} LINECOMPLETECALL_PARAMS, *PLINECOMPLETECALL_PARAMS;


typedef struct _LINECOMPLETETRANSFER_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD           hfnPostProcessProc;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  HCALL       hConsultCall;
    };

    IN  DWORD           hpConfCallHandle;                // pointer to client buffer

    union
    {
        IN  DWORD       dwTransferMode;
    };

} LINECOMPLETETRANSFER_PARAMS, *PLINECOMPLETETRANSFER_PARAMS;


typedef struct _LINECONDITIONALMEDIADETECTION_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwMediaModes;
    };

    union
    {
        IN  DWORD       dwCallParamsOffset;
    };

    union
    {
        IN  DWORD       dwAsciiCallParamsCodePage;
    };

} LINECONDITIONALMEDIADETECTION_PARAMS, *PLINECONDITIONALMEDIADETECTION_PARAMS;


typedef struct _LINECONFIGPROVIDER_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD dwwndOwner;
    };

    union
    {
        IN  DWORD       dwPermanentProviderID;
    };

} LINECONFIGPROVIDER_PARAMS, *PLINECONFIGPROVIDER_PARAMS;


typedef struct _LINECREATEAGENT_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    // IN  DWORD       hfnPostProcessProc;
    IN  DWORD           hfnPostProcessProc;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAgentIDOffset;            // valid offset or
    };
                                                    //   TAPI_NO_DATA
    union
    {
        IN  DWORD       dwAgentPINOffset;           // valid offset or
                                                    //   TAPI_NO_DATA
    };

    // IN  ULONG_PTR       lphAgent;                   // pointer to client buffer
    IN  DWORD           hpAgent;                   // pointer to client buffer

} LINECREATEAGENT_PARAMS, * PLINECREATEAGENT_PARAMS;


typedef struct _LINECREATEAGENTSESSION_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    // IN  DWORD       hfnPostProcessProc;
    IN  DWORD          hfnPostProcessProc;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  HAGENT      hAgent;
    };

    union
    {
        IN  DWORD       dwAgentPINOffset;           // valid offset or
                                                    //   TAPI_NO_DATA
    };

    union
    {
        IN  DWORD       dwWorkingAddressID;
    };

    union
    {
        IN  DWORD       dwGroupIDOffset;
    };

    union
    {
        IN  DWORD       dwGroupIDSize;
    };

    IN  DWORD           hpAgentSessionHandle;            // pointer to client buffer

} LINECREATEAGENTSESSION_PARAMS, *PLINECREATEAGENTSESSION_PARAMS;

typedef struct _LINECREATEMSPINSTANCE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };
    
} LINECREATEMSPINSTANCE_PARAMS, *PLINECREATEMSPINSTANCE_PARAMS;

typedef struct _LINEDEALLOCATECALL_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALL       hCall;
    };

} LINEDEALLOCATECALL_PARAMS, *PLINEDEALLOCATECALL_PARAMS;


typedef struct _LINEDEVSPECIFIC_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    // IN  DWORD       hfnPostProcessProc;
    IN  DWORD           hfnPostProcessProc;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    union
    {
        IN  HCALL       hCall;
    };

    IN  DWORD          hpParams;                   // pointer to client buffer

    union
    {
        IN  DWORD       dwParamsOffset;             // valid offset or
    };

    union
    {
        IN  DWORD       dwParamsSize;
    };

} LINEDEVSPECIFIC_PARAMS, *PLINEDEVSPECIFIC_PARAMS;


typedef struct _LINEDEVSPECIFICEX_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    // IN  DWORD       hfnPostProcessProc;
    IN  DWORD          hfnPostProcessProc;

    union
    {
        IN  DWORD       dwProviderID;
    };

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  HCALLHUB    hCallHub;
    };

    union
    {
        IN  DWORD       dwSelect;
    };

    IN  DWORD           hpParams;                   // pointer to client buffer

    union
    {
        IN  DWORD       dwParamsOffset;             // valid offset or
                                                    //    TAPI_NO_DATA
    };

    union
    {
        IN  DWORD       dwParamsSize;
    };

} LINEDEVSPECIFICEX_PARAMS, *PLINEDEVSPECIFICEX_PARAMS;


typedef struct _LINEDEVSPECIFICFEATURE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    // IN  DWORD       hfnPostProcessProc;
    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  DWORD       hLine;
    };

    union
    {
        IN  DWORD       dwFeature;
    };

    IN  DWORD           hpParams;                   // pointer to client buffer

    union
    {
        IN  DWORD       dwParamsOffset;             // valid offset or
                                                    //   TAPI_NO_DATA
    };

    union
    {
        IN  DWORD       dwParamsSize;
    };

} LINEDEVSPECIFICFEATURE_PARAMS, *PLINEDEVSPECIFICFEATURE_PARAMS;


typedef struct _LINEDIAL_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwDestAddressOffset;        // always valid offset
    };

    union
    {
        IN  DWORD       dwCountryCode;
    };

} LINEDIAL_PARAMS, *PLINEDIAL_PARAMS;


typedef struct _LINEDROP_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwUserUserInfoOffset;       // valid offset or
    };

    union
    {
        IN  DWORD       dwSize;
    };

} LINEDROP_PARAMS, *PLINEDROP_PARAMS;


typedef struct _LINEFORWARD_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  DWORD       hLine;
    };

    union
    {
        IN  DWORD       bAllAddresses;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    union
    {
        IN  DWORD       dwForwardListOffset;        // always valid offset
    };

    union
    {
        IN  DWORD       dwNumRingsNoAnswer;
    };

    IN  DWORD           hpConsultCall;             // pointer to client buffer

    union
    {
        IN  DWORD       dwCallParamsOffset;         // valid offset or
                                                    //   TAPI_NO_DATA
    };

    union
    {
        IN  DWORD       dwAsciiCallParamsCodePage;
    };

} LINEFORWARD_PARAMS, *PLINEFORWARD_PARAMS;


typedef struct _LINEGATHERDIGITS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HCALL       hCall;
    };

#if NEWTAPI32
    union
    {
        IN  DWORD       dwEndToEndID;
    };
#endif

    union
    {
        IN  DWORD       dwDigitModes;
    };

    // IN  ULONG_PTR       lpsDigits;                  // pointer to client buffer
    IN  DWORD           hpsDigits;                  // pointer to client buffer

    union
    {
        IN  DWORD       dwNumDigits;
    };

    union
    {
        IN  DWORD       dwTerminationDigitsOffset;  // valid offset or
                                                    //   TAPI_NO_DATA
    };

    union
    {
        IN  DWORD       dwFirstDigitTimeout;
    };

    union
    {
        IN  DWORD       dwInterDigitTimeout;
    };

} LINEGATHERDIGITS_PARAMS, *PLINEGATHERDIGITS_PARAMS;


typedef struct _LINEGENERATEDIGITS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       hCall;
    };

    union
    {
        IN  DWORD       dwDigitMode;
    };

    union
    {
        IN  DWORD       dwDigitsOffset;             // always valid offset
    };

    union
    {
        IN  DWORD       dwDuration;
    };

    union
    {
        IN  DWORD       dwEndToEndID;               // Used for remotesp only
    };

} LINEGENERATEDIGITS_PARAMS, *PLINEGENERATEDIGITS_PARAMS;


typedef struct _LINEGENERATETONE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwToneMode;
    };

    union
    {
        IN  DWORD       dwDuration;
    };

    union
    {
        IN  DWORD       dwNumTones;
    };

    union
    {
        IN  DWORD       dwTonesOffset;              // valid offset or

    };

    IN  DWORD           _Unused_;                   // placeholdr for following
                                                    //   Size arg on clnt side

    union
    {
        IN  DWORD       dwEndToEndID;               // Used for remotesp only
    };

} LINEGENERATETONE_PARAMS, *PLINEGENERATETONE_PARAMS;


typedef struct _LINEGETADDRESSCAPS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    union
    {
        IN  DWORD       dwAPIVersion;
    };

    union
    {
        IN  DWORD       dwExtVersion;
    };

    union
    {
        IN  DWORD       dwAddressCapsTotalSize;     // size of client buffer
        OUT DWORD       dwAddressCapsOffset;        // valid offset on success
    };

} LINEGETADDRESSCAPS_PARAMS, *PLINEGETADDRESSCAPS_PARAMS;


typedef struct _LINEGETADDRESSID_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        OUT DWORD       dwAddressID;
    };

    union
    {
        IN  DWORD       dwAddressMode;
    };

    union
    {
        IN  DWORD       dwAddressOffset;            // always valid offset
    };

    union
    {
        IN  DWORD       dwSize;
    };

} LINEGETADDRESSID_PARAMS, *PLINEGETADDRESSID_PARAMS;


typedef struct _LINEGETADDRESSSTATUS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        OUT DWORD       dwAddressID;
    };

    union
    {
        IN  DWORD       dwAddressStatusTotalSize;   // size of client buffer
        OUT DWORD       dwAddressStatusOffset;      // valid offset on success
    };

} LINEGETADDRESSSTATUS_PARAMS, *PLINEGETADDRESSSTATUS_PARAMS;


typedef struct _LINEGETAGENTACTIVITYLIST_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    // IN  ULONG_PTR       lpAgentActivityList;        // pointer to client buffer
    IN  DWORD           hpAgentActivityList;        // pointer to client buffer

    union
    {
        IN  DWORD       dwActivityListTotalSize;
    };

} LINEGETAGENTACTIVITYLIST_PARAMS, *PLINEGETAGENTACTIVITYLIST_PARAMS;


typedef struct _LINEGETAGENTCAPS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    union
    {
        IN  DWORD       dwAppAPIVersion;
    };

    // IN  ULONG_PTR       lpAgentCaps;                // pointer to client buffer
    IN  DWORD           hpAgentCaps;                // pointer to client buffer

    union
    {
        IN  DWORD       dwAgentCapsTotalSize;

    };

} LINEGETAGENTCAPS_PARAMS, *PLINEGETAGENTCAPS_PARAMS;


typedef struct _LINEGETAGENTGROUPLIST_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    // IN  ULONG_PTR       lpAgentGroupList;           // pointer to client buffer
    IN  DWORD           hpAgentGroupList;           // pointer to client buffer

    union
    {
        IN  DWORD       dwAgentGroupListTotalSize;
    };

} LINEGETAGENTGROUPLIST_PARAMS, *PLINEGETAGENTGROUPLIST_PARAMS;


typedef struct _LINEGETAGENTINFO_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  HAGENT      hAgent;
    };

    // IN  ULONG_PTR       lpAgentInfo;                // pointer to client buffer
    IN  DWORD           hpAgentInfo;                // pointer to client buffer

    union
    {
        IN  DWORD       dwAgentInfoTotalSize;
    };

} LINEGETAGENTINFO_PARAMS, *PLINEGETAGENTINFO_PARAMS;


typedef struct _LINEGETAGENTSESSIONINFO_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;
    
    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  HAGENTSESSION   hAgentSession;
    };

    // IN  ULONG_PTR       lpAgentSessionInfo;         // pointer to client buffer
    IN  DWORD               hpAgentSessionInfo;         // pointer to client buffer

    union
    {
        IN  DWORD       dwAgentSessionInfoTotalSize;
    };

} LINEGETAGENTSESSIONINFO_PARAMS, *PLINEGETAGENTSESSIONINFO_PARAMS;


typedef struct _LINEGETAGENTSESSIONLIST_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  HAGENT      hAgent;
    };

    // IN  ULONG_PTR       lpSessionList;              // pointer to client buffer
    IN  DWORD          hpSessionList;              // pointer to client buffer

    union
    {
        IN  DWORD       dwSessionListTotalSize;
    };

} LINEGETAGENTSESSIONLIST_PARAMS, *PLINEGETAGENTSESSIONLIST_PARAMS;


typedef struct _LINEGETAGENTSTATUS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    // IN  ULONG_PTR       lpAgentStatus;              // pointer to client buffer
    IN  DWORD           hpAgentStatus;              // pointer to client buffer

    union
    {
        IN  DWORD       dwAgentStatusTotalSize;
    };

} LINEGETAGENTSTATUS_PARAMS, *PLINEGETAGENTSTATUS_PARAMS;


typedef struct _LINEGETAPPPRIORITY_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwAppNameOffset;            // always valid offset
    };

    union
    {
        IN  DWORD       dwMediaMode;
    };

    union
    {
        IN  DWORD       dwExtensionIDOffset;        // valid offset or

    };

    //IN  ULONG_PTR       _Unused_;                   // padding for Size type on
    IN  DWORD           _Unused_;                   // padding for Size type on
                                                    //   client side
    union
    {
        IN  DWORD       dwRequestMode;
    };

    union
    {
        IN  DWORD       dwExtensionNameTotalSize;   // size of client buf or
                                                    //   TAPI_NO_DATA
        OUT DWORD       dwExtensionNameOffset;      // valid offset or
                                                    //   TAPI_NO_DATA on succes
    };

    union
    {
        OUT DWORD       dwPriority;
    };

} LINEGETAPPPRIORITY_PARAMS, *PLINEGETAPPPRIORITY_PARAMS;


typedef struct _LINEGETCALLADDRESSID_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        OUT DWORD       dwAddressID;
    };

} LINEGETCALLADDRESSID_PARAMS, *PLINEGETCALLADDRESSID_PARAMS;


typedef struct _LINEGETCALLHUBTRACKING_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwTrackingInfoTotalSize;    // size of client buffer
        OUT DWORD       dwTrackingInfoOffset;       // valid offset on success
    };

} LINEGETCALLHUBTRACKING_PARAMS, *PLINEGETCALLHUBTRACKING_PARAMS;


typedef struct _LINEGETCALLIDS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        OUT DWORD       dwAddressID;
    };

    union
    {
        OUT DWORD       dwCallID;
    };

    union
    {
        OUT DWORD       dwRelatedCallID;
    };

} LINEGETCALLIDS_PARAMS, *PLINEGETCALLIDS_PARAMS;


typedef struct _LINEGETCALLINFO_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwCallInfoTotalSize;        // size of client buffer
        OUT DWORD       dwCallInfoOffset;           // valid offset on success
    };

} LINEGETCALLINFO_PARAMS, *PLINEGETCALLINFO_PARAMS;


typedef struct _LINEGETCALLSTATUS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwCallStatusTotalSize;      // size of client buffer
        OUT DWORD       dwCallStatusOffset;         // valid offset on success
    };

} LINEGETCALLSTATUS_PARAMS, *PLINEGETCALLSTATUS_PARAMS;


typedef struct _LINEGETCONFRELATEDCALLS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwCallListTotalSize;        // size of client buffer
        OUT DWORD       dwCallListOffset;           // valid offset on success
    };

} LINEGETCONFRELATEDCALLS_PARAMS, *PLINEGETCONFRELATEDCALLS_PARAMS;


typedef struct _LINEGETCOUNTRY_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwCountryID;
    };

    union
    {
        IN  DWORD       dwAPIVersion;
    };

    union
    {
        IN  DWORD       dwDestCountryID;
    };

    union
    {
        IN  DWORD       dwCountryListTotalSize;     // size of client buffer
        OUT DWORD       dwCountryListOffset;        // valid offset on success
    };

} LINEGETCOUNTRY_PARAMS, *PLINEGETCOUNTRY_PARAMS;


typedef struct _LINEGETCOUNTRYGROUP_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN DWORD       dwCountryIdOffset;
    };

    union
    {
        IN OUT DWORD    dwCountryIdSize;
    };

    union
    {
        OUT DWORD       dwCountryGroupOffset;
    };

    union
    {
        IN OUT DWORD    dwCountryGroupSize;
    };

} LINEGETCOUNTRYGROUP_PARAMS, *PLINEGETCOUNTRYGROUP_PARAMS;

typedef struct _LINEGETDEVCAPS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        IN  DWORD       dwAPIVersion;
    };

    union
    {
        IN  DWORD       dwExtVersion;
    };

    union
    {
        IN  DWORD       dwDevCapsTotalSize;         // size of client buffer
        OUT DWORD       dwDevCapsOffset;            // valid offset on success
    };

} LINEGETDEVCAPS_PARAMS, *PLINEGETDEVCAPS_PARAMS;


typedef struct _LINEGETDEVCONFIG_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        IN  DWORD       dwDeviceConfigTotalSize;    // size of client buffer
        OUT DWORD       dwDeviceConfigOffset;       // valid offset on success
    };

    union
    {
        IN  DWORD       dwDeviceClassOffset;        // always valid offset
    };

} LINEGETDEVCONFIG_PARAMS, *PLINEGETDEVCONFIG_PARAMS;


typedef struct _LINEGETGROUPLIST_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HLINE       hLine;
    };

    // IN  ULONG_PTR       lpGroupList;                // pointer to client buffer
    IN  DWORD           hpGroupList;                   // pointer to client buffer

    union
    {
        IN  DWORD       dwGroupListTotalSize;
    };

} LINEGETGROUPLIST_PARAMS, *PLINEGETGROUPLIST_PARAMS;


typedef struct _LINEGETHUBRELATEDCALLS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALLHUB    hCallHub;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwCallListTotalSize;        // size of client buffer
        OUT DWORD       dwCallListOffset;           // valid offset on success
    };

} LINEGETHUBRELATEDCALLS_PARAMS, *PLINEGETHUBRELATEDCALLS_PARAMS;


typedef struct _LINEGETICON_PARAMS
{
    OUT LONG        lResult;

    DWORD			dwUnused;

    IN  DWORD       dwDeviceID;

    IN  DWORD       dwDeviceClassOffset;        // valid offset or

    OUT HICON       hIcon;

} LINEGETICON_PARAMS, *PLINEGETICON_PARAMS;


typedef struct _LINEGETID_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    union
    {
        IN  DWORD       hCall;
    };

    union
    {
        IN  DWORD       dwSelect;
    };

    union
    {
        IN  DWORD       dwDeviceIDTotalSize;        // size of client buffer
        OUT DWORD       dwDeviceIDOffset;           // valid offset on success
    };

    union
    {
        IN  DWORD       dwDeviceClassOffset;        // always valid offset
    };

} LINEGETID_PARAMS, *PLINEGETID_PARAMS;


typedef struct _LINEGETLINEDEVSTATUS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwLineDevStatusTotalSize;   // size of client buffer
        OUT DWORD       dwLineDevStatusOffset;      // valid offset on success
    };

    union
    {
        OUT DWORD       dwAPIVersion;
    };

} LINEGETLINEDEVSTATUS_PARAMS, *PLINEGETLINEDEVSTATUS_PARAMS;


typedef struct _LINEGETPROXYSTATUS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        IN  DWORD       dwAppAPIVersion;
    };

    union
    {
        IN  DWORD       dwProxyStatusTotalSize;     // size of client buffer
        OUT DWORD       dwProxyStatusOffset;        // valid offset on success
    };

    union
    {
        OUT DWORD       dwAPIVersion;
    };

} LINEGETPROXYSTATUS_PARAMS, *PLINEGETPROXYSTATUS_PARAMS;


typedef struct _LINEGETNEWCALLS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    union
    {
        IN  DWORD       dwSelect;
    };

    union
    {
        IN  DWORD       dwCallListTotalSize;        // size of client buffer
        OUT DWORD       dwCallListOffset;           // valid offset on success
    };

} LINEGETNEWCALLS_PARAMS, *PLINEGETNEWCALLS_PARAMS;


typedef struct _LINEGETNUMADDRESSIDS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        OUT DWORD       dwNumAddresses;
    };

} LINEGETNUMADDRESSIDS_PARAMS, *PLINEGETNUMADDRESSIDS_PARAMS;


typedef struct _LINEGETNUMRINGS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    union
    {
        OUT DWORD       dwNumRings;
    };

} LINEGETNUMRINGS_PARAMS, *PLINEGETNUMRINGS_PARAMS;


typedef struct _LINEGETPROVIDERLIST_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwAPIVersion;
    };

    union
    {
        IN  DWORD       dwProviderListTotalSize;    // size of client buf
        OUT DWORD       dwProviderListOffset;       // valid offset on success
    };

} LINEGETPROVIDERLIST_PARAMS, *PLINEGETPROVIDERLIST_PARAMS;


typedef struct _LINEGETQUEUEINFO_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwQueueID;
    };

    // IN  ULONG_PTR       lpQueueInfo;                // pointer to client buffer
    IN  DWORD           phQueueInfo;                // pointer to client buffer

    union
    {
        IN  DWORD       dwQueueInfoTotalSize;
    };

} LINEGETQUEUEINFO_PARAMS, *PLINEGETQUEUEINFO_PARAMS;


typedef struct _LINEGETQUEUELIST_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwGroupIDOffset;
    };

    union
    {
        IN  DWORD       dwGroupIDSize;
    };

    //IN  ULONG_PTR       lpQueueList;                // pointer to client buffer
    IN  DWORD           hpQueueList;                // pointer to client buffer

    union
    {
        IN  DWORD       dwQueueListTotalSize;
    };

} LINEGETQUEUELIST_PARAMS, *PLINEGETQUEUELIST_PARAMS;


typedef struct _LINEGETREQUEST_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       dwRequestMode;
    };

    union
    {
        OUT DWORD       dwRequestBufferOffset;      // valid offset on success
    };

    union
    {
        IN OUT DWORD    dwSize;
    };

} LINEGETREQUEST_PARAMS, *PLINEGETREQUEST_PARAMS;


typedef struct _LINEGETSTATUSMESSAGES_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        OUT DWORD       dwLineStates;
    };

    union
    {
        OUT DWORD       dwAddressStates;
    };

} LINEGETSTATUSMESSAGES_PARAMS, *PLINEGETSTATUSMESSAGES_PARAMS;


typedef struct _LINEHANDOFF_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwFileNameOffset;           // valid offset or
    };

    union
    {
        IN  DWORD       dwMediaMode;
    };

} LINEHANDOFF_PARAMS, *PLINEHANDOFF_PARAMS;


typedef struct _LINEHOLD_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hCall;
    };

} LINEHOLD_PARAMS, *PLINEHOLD_PARAMS;


typedef struct _LINEINITIALIZE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        OUT HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       hInstance;
    };

    union
    {
        IN  DWORD       InitContext;
    };

    union
    {
        IN  DWORD       dwFriendlyNameOffset;       // always valid offset
    };

    union
    {
        OUT DWORD       dwNumDevs;
    };

    union
    {
        IN  DWORD       dwModuleNameOffset;         // always valid offset
    };

    union
    {
        IN  DWORD       dwAPIVersion;
    };

} LINEINITIALIZE_PARAMS, *PLINEINITIALIZE_PARAMS;


typedef struct _LINEMAKECALL_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD           hfnPostProcessProc;

    union
    {
        IN  HLINE       hLine;
    };

    IN  DWORD           hpCall;

    union
    {
        IN  DWORD       dwDestAddressOffset;        // valid offset or
    };

    union
    {
        IN  DWORD       dwCountryCode;
    };

    union
    {
        IN  DWORD       dwCallParamsOffset;         // valid offset or
    };

    union
    {
        IN  DWORD       dwAsciiCallParamsCodePage;
    };

} LINEMAKECALL_PARAMS, *PLINEMAKECALL_PARAMS;


typedef struct _LINEMONITORDIGITS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwDigitModes;
    };

} LINEMONITORDIGITS_PARAMS, *PLINEMONITORDIGITS_PARAMS;


typedef struct _LINEMONITORMEDIA_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwMediaModes;
    };

} LINEMONITORMEDIA_PARAMS, *PLINEMONITORMEDIA_PARAMS;


typedef struct _LINEMONITORTONES_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwTonesOffset;              // valid offset or
    };

    union
    {
        IN  DWORD       dwNumEntries;               // really dwNumEntries *
    };

    union
    {
        IN  DWORD       dwToneListID;               // Used for remotesp only
    };

} LINEMONITORTONES_PARAMS, *PLINEMONITORTONES_PARAMS;


typedef struct _LINENEGOTIATEAPIVERSION_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        IN  DWORD       dwAPILowVersion;
    };

    union
    {
        IN  DWORD       dwAPIHighVersion;
    };

    union
    {
        OUT DWORD       dwAPIVersion;
    };

    union
    {
        OUT DWORD       dwExtensionIDOffset;        // valid offset on success
    };

    union
    {
        IN OUT DWORD    dwSize;
    };

} LINENEGOTIATEAPIVERSION_PARAMS, *PLINENEGOTIATEAPIVERSION_PARAMS;


typedef struct _NEGOTIATEAPIVERSIONFORALLDEVICES_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       dwNumLineDevices;
    };

    union
    {
        IN  DWORD       dwNumPhoneDevices;
    };

    union
    {
        IN  DWORD       dwAPIHighVersion;
    };

    union
    {
        OUT DWORD       dwLineAPIVersionListOffset; // valid offset on success
    };

    union
    {
        IN OUT DWORD    dwLineAPIVersionListSize;
    };

    union
    {
        OUT DWORD       dwLineExtensionIDListOffset;// valid offset on success
    };

    union
    {
        IN OUT DWORD    dwLineExtensionIDListSize;
    };

    union
    {
        OUT DWORD       dwPhoneAPIVersionListOffset;// valid offset on success
    };

    union
    {
        IN OUT DWORD    dwPhoneAPIVersionListSize;
    };

    union
    {
        OUT DWORD       dwPhoneExtensionIDListOffset;// valid offset on success
    };

    union
    {
        IN OUT DWORD    dwPhoneExtensionIDListSize;
    };

} NEGOTIATEAPIVERSIONFORALLDEVICES_PARAMS,
    *PNEGOTIATEAPIVERSIONFORALLDEVICES_PARAMS;


typedef struct _LINENEGOTIATEEXTVERSION_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        IN  DWORD       dwAPIVersion;
    };

    union
    {
        IN  DWORD       dwExtLowVersion;
    };

    union
    {
        IN  DWORD       dwExtHighVersion;
    };

    union
    {
        OUT DWORD       dwExtVersion;
    };

} LINENEGOTIATEEXTVERSION_PARAMS, *PLINENEGOTIATEEXTVERSION_PARAMS;


typedef struct _LINEOPEN_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        OUT DWORD       hLine;
    };

    union
    {
        IN  DWORD       dwAPIVersion;
    };

    union
    {
        IN  DWORD       dwExtVersion;
    };

    IN  DWORD       OpenContext;

    union
    {
        IN  DWORD       dwPrivileges;
    };

    union
    {
        IN  DWORD       dwMediaModes;
    };

    union
    {
        IN  DWORD       dwCallParamsOffset;         // valid offset or
    };

    union
    {
        IN  DWORD       dwAsciiCallParamsCodePage;
    };

    union
    {
        IN  DWORD       dwCallParamsReturnTotalSize;// size of client buffer
        OUT DWORD       dwCallParamsReturnOffset;   // valid offset on success
    };

    //
    // The following is a "remote line handle".  When the client is
    // remotesp.tsp running on a remote machine, this will be some
    // non-NULL value, and tapisrv should use this handle in status/etc
    // indications to the client rather than the std hLine. If the
    // client is not remote.tsp then this value will be NULL.
    //

    union
    {
        IN  HLINE       hRemoteLine;
    };

} LINEOPEN_PARAMS, *PLINEOPEN_PARAMS;


typedef struct _LINEPARK_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwParkMode;
    };

    union
    {
        IN  DWORD       dwDirAddressOffset;         // valid offset or
    };
                                                    //   TAPI_NO_DATA
    // IN  ULONG_PTR       lpNonDirAddress;            // pointer to client buffer
    IN  DWORD           hpNonDirAddress;            // pointer to client buffer

    union
    {
        IN  DWORD       dwNonDirAddressTotalSize;   // size of client buffer
                                                    // for sync func would be
                                                    //   dwXxxOffset
    };

} LINEPARK_PARAMS, *PLINEPARK_PARAMS;


typedef struct _LINEPICKUP_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    // IN  ULONG_PTR       lphCall;                    // pointer to client buffer
    IN  DWORD           hpCall;                    // pointer to client buffer

    union
    {
        IN  DWORD       dwDestAddressOffset;        // valid offset or
    };

    union
    {
        IN  DWORD       dwGroupIDOffset;            // always valid offset
    };

} LINEPICKUP_PARAMS, *PLINEPICKUP_PARAMS;


typedef struct _LINEPREPAREADDTOCONFERENCE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HCALL       hConfCall;
    };

    // IN  ULONG_PTR       lphConsultCall;             // pointer to client buffer
    IN  DWORD          hpConsultCall;             // pointer to client buffer

    union
    {
        IN  DWORD       dwCallParamsOffset;         // valid offset or
    };

    union
    {
        IN  DWORD       dwAsciiCallParamsCodePage;
    };

} LINEPREPAREADDTOCONFERENCE_PARAMS, *PLINEPREPAREADDTOCONFERENCE_PARAMS;


typedef struct _LINEPROXYMESSAGE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwMsg;
    };

    union
    {
        IN  DWORD       dwParam1;
    };

    union
    {
        IN  DWORD       dwParam2;
    };

    union
    {
        IN  DWORD       dwParam3;
    };

} LINEPROXYMESSAGE_PARAMS, *PLINEPROXYMESSAGE_PARAMS;


typedef struct _LINEPROXYRESPONSE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwInstance;
    };

    union
    {
        IN  DWORD       dwProxyResponseOffset;      // valid offset or
    };

    union
    {
        IN  DWORD       dwResult;
    };

} LINEPROXYRESPONSE_PARAMS, *PLINEPROXYRESPONSE_PARAMS;


typedef struct _LINEREDIRECT_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwDestAddressOffset;        // always valid offset
    };

    union
    {
        IN  DWORD       dwCountryCode;
    };

} LINEREDIRECT_PARAMS, *PLINEREDIRECT_PARAMS;


typedef struct _LINEREGISTERREQUESTRECIPIENT_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       dwRegistrationInstance;
    };

    union
    {
        IN  DWORD       dwRequestMode;
    };

    union
    {
        IN  DWORD       bEnable;
    };

} LINEREGISTERREQUESTRECIPIENT_PARAMS, *PLINEREGISTERREQUESTRECIPIENT_PARAMS;


typedef struct _LINERELEASEUSERUSERINFO_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALL       hCall;
    };

} LINERELEASEUSERUSERINFO_PARAMS, *PLINERELEASEUSERUSERINFO_PARAMS;


typedef struct _LINEREMOVEFROMCONFERENCE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hCall;
    };

} LINEREMOVEFROMCONFERENCE_PARAMS, *PLINEREMOVEFROMCONFERENCE_PARAMS;


typedef struct _LINESECURECALL_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hCall;
    };

} LINESECURECALL_PARAMS, *PLINESECURECALL_PARAMS;


typedef struct _LINESELECTEXTVERSION_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwExtVersion;
    };

} LINESELECTEXTVERSION_PARAMS, *PLINESELECTEXTVERSION_PARAMS;


typedef struct _LINESENDUSERUSERINFO_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwUserUserInfoOffset;       // valid offset or
    };

    union
    {
        IN  DWORD       dwSize;
    };

} LINESENDUSERUSERINFO_PARAMS, *PLINESENDUSERUSERINFO_PARAMS;


typedef struct _LINESETAGENTACTIVITY_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    union
    {
        IN  DWORD       dwActivityID;
    };

} LINESETAGENTACTIVITY_PARAMS, *PLINESETAGENTACTIVITY_PARAMS;


typedef struct _LINESETAGENTGROUP_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    union
    {
        IN  DWORD       dwAgentGroupListOffset;
    };

} LINESETAGENTGROUP_PARAMS, *PLINESETAGENTGROUP_PARAMS;


typedef struct _LINESETAGENTMEASUREMENTPERIOD_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  HAGENT      hAgent;
    };

    union
    {
        IN  DWORD       dwMeasurementPeriod;
    };

} LINESETAGENTMEASUREMENTPERIOD_PARAMS, *PLINESETAGENTMEASUREMENTPERIOD_PARAMS;


typedef struct _LINESETAGENTSESSIONSTATE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  HAGENTSESSION   hAgentSession;
    };

    union
    {
        IN  DWORD       dwAgentState;
    };

    union
    {
        IN  DWORD       dwNextAgentState;
    };

} LINESETAGENTSESSIONSTATE_PARAMS, *PLINESETAGENTSESSIONSTATE_PARAMS;


typedef struct _LINESETAGENTSTATE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    union
    {
        IN  DWORD       dwAgentState;
    };

    union
    {
        IN  DWORD       dwNextAgentState;
    };

} LINESETAGENTSTATE_PARAMS, *PLINESETAGENTSTATE_PARAMS;


typedef struct _LINESETAGENTSTATEEX_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  HAGENT      hAgent;
    };

    union
    {
        IN  DWORD       dwAgentState;
    };

    union
    {
        IN  DWORD       dwNextAgentState;
    };

} LINESETAGENTSTATEEX_PARAMS, *PLINESETAGENTSTATEEX_PARAMS;


typedef struct _LINESETAPPPRIORITY_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwAppNameOffset;            // always valid offset
    };

    union
    {
        IN  DWORD       dwMediaMode;
    };

    union
    {
        IN  DWORD       dwExtensionIDOffset;        // valid offset or

    };

    // IN  ULONG_PTR       _Unused_;                   // padding for Size type on
    IN  DWORD           _Unused_;                   // padding for Size type on
                                                    //   client side
    union
    {
        IN  DWORD       dwRequestMode;
    };

    union
    {
        IN  DWORD       dwExtensionNameOffset;      // valid offset or
    };

    union
    {
        IN  DWORD       dwPriority;
    };

} LINESETAPPPRIORITY_PARAMS, *PLINESETAPPPRIORITY_PARAMS;


typedef struct _LINESETAPPSPECIFIC_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwAppSpecific;
    };

} LINESETAPPSPECIFIC_PARAMS, *PLINESETAPPSPECIFIC_PARAMS;


typedef struct _LINESETCALLDATA_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwCallDataOffset;           // valid offset or
    };

    union
    {
        IN  DWORD       dwCallDataSize;
    };

} LINESETCALLDATA_PARAMS, *PLINESETCALLDATA_PARAMS;


typedef struct _LINESETCALLHUBTRACKING_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwTrackingInfoOffset;       // always valid offset
    };

} LINESETCALLHUBTRACKING_PARAMS, *PLINESETCALLHUBTRACKING_PARAMS;


typedef struct _LINESETCALLPARAMS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwBearerMode;
    };

    union
    {
        IN  DWORD       dwMinRate;
    };

    union
    {
        IN  DWORD       dwMaxRate;
    };

    union
    {
        IN  DWORD       dwDialParamsOffset;         // valid offset or
    };

    // IN  ULONG_PTR       _Unused_;                   // placeholdr for following
    IN  DWORD           _Unused_;                   // placeholdr for following
                                                    //   Size arg on clnt side
} LINESETCALLPARAMS_PARAMS, *PLINESETCALLPARAMS_PARAMS;


typedef struct _LINESETCALLPRIVILEGE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwPrivilege;
    };

} LINESETCALLPRIVILEGE_PARAMS, *PLINESETCALLPRIVILEGE_PARAMS;


typedef struct _LINESETCALLQUALITYOFSERVICE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwSendingFlowspecOffset;    // always valid offset
    };

    union
    {
        IN  DWORD       dwSendingFlowspecSize;
    };

    union
    {
        IN  DWORD       dwReceivingFlowspecOffset;  // always valid offset
    };

    union
    {
        IN  DWORD       dwReceivingFlowspecSize;
    };

} LINESETCALLQUALITYOFSERVICE_PARAMS, *PLINESETCALLQUALITYOFSERVICE_PARAMS;


typedef struct _LINESETCALLTREATMENT_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwTreatment;
    };

} LINESETCALLTREATMENT_PARAMS, *PLINESETCALLTREATMENT_PARAMS;


typedef struct _LINESETDEFAULTMEDIADETECTION_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwMediaModes;
    };

} LINESETDEFAULTMEDIADETECTION_PARAMS, *PLINESETDEFAULTMEDIADETECTION_PARAMS;


typedef struct _LINESETDEVCONFIG_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        IN  DWORD       dwDeviceConfigOffset;       // always valid offset
    };

    union
    {
        IN  DWORD       dwSize;
    };

    union
    {
        IN  DWORD       dwDeviceClassOffset;        // always valid offset
    };

} LINESETDEVCONFIG_PARAMS, *PLINESETDEVCONFIG_PARAMS;


typedef struct _LINESETLINEDEVSTATUS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwStatusToChange;
    };

    union
    {
        IN  DWORD       fStatus;
    };

} LINESETLINEDEVSTATUS_PARAMS, *PLINESETLINEDEVSTATUS_PARAMS;


typedef struct _LINESETMEDIACONTROL_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwSelect;
    };

    union
    {
        IN  DWORD       dwDigitListOffset;          // valid offset or
    };

    union
    {
        IN  DWORD       dwDigitListNumEntries;      // actually dwNumEntries *
    };

    union
    {
        IN  DWORD       dwMediaListOffset;          // valid offset or
    };

    union
    {
        IN  DWORD       dwMediaListNumEntries;      // actually dwNumEntries *
    };

    union
    {
        IN  DWORD       dwToneListOffset;           // valid offset or
    };

    union
    {
        IN  DWORD       dwToneListNumEntries;       // actually dwNumEntries *
    };

    union
    {
        IN  DWORD       dwCallStateListOffset;      // valid offset or
    };

    union
    {
        IN  DWORD       dwCallStateListNumEntries;  // actually dwNumEntries *
    };

} LINESETMEDIACONTROL_PARAMS, *PLINESETMEDIACONTROL_PARAMS;


typedef struct _LINESETMEDIAMODE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwMediaModes;
    };

} LINESETMEDIAMODE_PARAMS, *PLINESETMEDIAMODE_PARAMS;


typedef struct _LINESETNUMRINGS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    union
    {
        IN  DWORD       dwNumRings;
    };

} LINESETNUMRINGS_PARAMS, *PLINESETNUMRINGS_PARAMS;


typedef struct _LINESETQUEUEMEASUREMENTPERIOD_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwQueueID;
    };

    union
    {
        IN  DWORD       dwMeasurementPeriod;
    };

} LINESETQUEUEMEASUREMENTPERIOD_PARAMS, *PLINESETQUEUEMEASUREMENTPERIOD_PARAMS;


typedef struct _LINESETSTATUSMESSAGES_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwLineStates;
    };

    union
    {
        IN  DWORD       dwAddressStates;
    };

} LINESETSTATUSMESSAGES_PARAMS, *PLINESETSTATUSMESSAGES_PARAMS;


typedef struct _LINESETTERMINAL_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwSelect;
    };

    union
    {
        IN  DWORD       dwTerminalModes;
    };

    union
    {
        IN  DWORD       dwTerminalID;
    };

    union
    {
        IN  DWORD       bEnable;
    };

} LINESETTERMINAL_PARAMS, *PLINESETTERMINAL_PARAMS;


typedef struct _LINESETUPCONFERENCE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  HLINE       hLine;
    };

    // IN  ULONG_PTR       lphConfCall;                // pointer to client buffer
    IN  DWORD           hpConfCall;                // pointer to client buffer

    // IN  ULONG_PTR       lphConsultCall;             // pointer to client buffer
    IN  DWORD           hpConsultCall;             // pointer to client buffer

    union
    {
        IN  DWORD       dwNumParties;
    };

    union
    {
        IN  DWORD       dwCallParamsOffset;         // valid offset or
    };

    union
    {
        IN  DWORD       dwAsciiCallParamsCodePage;
    };

} LINESETUPCONFERENCE_PARAMS, *PLINESETUPCONFERENCE_PARAMS;


typedef struct _LINESETUPTRANSFER_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HCALL       hCall;
    };

    // IN  ULONG_PTR       lphConsultCall;             // pointer to client buffer
    IN  DWORD           hpConsultCall;             // pointer to client buffer

    union
    {
        IN  DWORD       dwCallParamsOffset;         // valid offset or
    };

    union
    {
        IN  DWORD       dwAsciiCallParamsCodePage;
    };

} LINESETUPTRANSFER_PARAMS, *PLINESETUPTRANSFER_PARAMS;


typedef struct _LINESHUTDOWN_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINEAPP    hLineApp;
    };

} LINESHUTDOWN_PARAMS, *PLINESHUTDOWN_PARAMS;


typedef struct _LINESWAPHOLD_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hActiveCall;
    };

    union
    {
        IN  HCALL       hHeldCall;
    };

} LINESWAPHOLD_PARAMS, *PLINESWAPHOLD_PARAMS;


typedef struct _LINEUNCOMPLETECALL_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwCompletionID;
    };

} LINEUNCOMPLETECALL_PARAMS, *PLINEUNCOMPLETECALL_PARAMS;


typedef struct _LINEUNHOLD_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hCall;
    };

} LINEUNHOLD_PARAMS, *PLINEUNHOLD_PARAMS;


typedef struct _LINEUNPARK_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    IN  DWORD           hpCall;                    // pointer to client buffer

    union
    {
        IN  DWORD       dwDestAddressOffset;        // always valid offset
    };

} LINEUNPARK_PARAMS, *PLINEUNPARK_PARAMS;


typedef struct _LINEMSPIDENTIFY_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;
    
    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        OUT DWORD       dwCLSIDOffset;
    };

    union
    {
        IN OUT DWORD    dwCLSIDSize;
    };

} LINEMSPIDENTIFY_PARAMS, *PLINEMSPIDENTIFY_PARAMS;


typedef struct _LINERECEIVEMSPDATA_PARAMS
{
    union
    {
        OUT LONG            lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE           hLine;
    };

    union
    {
        IN  HCALL           hCall;
    };

    union
    {
        IN  DWORD           dwBufferOffset;
    };

    union
    {
        IN  DWORD           dwBufferSize;
    };

} LINERECEIVEMSPDATA_PARAMS, *PLINERECEIVEMSPDATA_PARAMS;


typedef struct _R_LOCATIONS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINEAPP    dwhLineApp;
    };

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        IN  DWORD       dwAPIVersion;
    };

    union
    {
        IN  DWORD       dwParmsToCheckFlags;
    };

    union
    {
        IN  DWORD       dwLocationsTotalSize;       // size of client buffer
        OUT DWORD       dwLocationsOffset;          // valid offset on success
    };

} R_LOCATIONS_PARAMS, *PR_LOCATIONS_PARAMS;


typedef struct _W_LOCATIONS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       nNumLocations;
    };

    union
    {
        IN  DWORD       dwChangedFlags;
    };

    union
    {
        IN  DWORD       dwCurrentLocationID;
    };

    union
    {
        IN  DWORD       dwLocationListOffset;
    };

} W_LOCATIONS_PARAMS, *PW_LOCATIONS_PARAMS;


typedef struct _ALLOCNEWID_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       hKeyToUse;
        OUT DWORD       dwNewID;
    };

} ALLOCNEWID_PARAMS, *P_ALLOCNEWID_PARAMS;


typedef struct _PERFORMANCE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwCookie;
    };

    union
    {
        IN  DWORD       dwPerformanceTotalSize;     // size of client buffer
        OUT DWORD       dwLocationsOffset;          // valid offset on success
    };

} PERFORMANCE_PARAMS, *PPERFORMANCE_PARAMS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\inc\phone.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1995  Microsoft Corporation

Module Name:

    phone.h

Abstract:

    Header file for

Author:

    Dan Knudson (DanKn)    dd-Mmm-1995

Revision History:

--*/


#define ANY_RT_HPHONE       1
#define ANY_RT_HPHONE_CLOSE 2
#define ANY_RT_HPHONEAPP    3
#define DEVICE_ID           4
#define DEVICE_ID_OPEN      5


#define AllPhoneStates1_0          \
    (PHONESTATE_OTHER            | \
    PHONESTATE_CONNECTED         | \
    PHONESTATE_DISCONNECTED      | \
    PHONESTATE_OWNER             | \
    PHONESTATE_MONITORS          | \
    PHONESTATE_DISPLAY           | \
    PHONESTATE_LAMP              | \
    PHONESTATE_RINGMODE          | \
    PHONESTATE_RINGVOLUME        | \
    PHONESTATE_HANDSETHOOKSWITCH | \
    PHONESTATE_HANDSETVOLUME     | \
    PHONESTATE_HANDSETGAIN       | \
    PHONESTATE_SPEAKERHOOKSWITCH | \
    PHONESTATE_SPEAKERVOLUME     | \
    PHONESTATE_SPEAKERGAIN       | \
    PHONESTATE_HEADSETHOOKSWITCH | \
    PHONESTATE_HEADSETVOLUME     | \
    PHONESTATE_HEADSETGAIN       | \
    PHONESTATE_SUSPEND           | \
    PHONESTATE_RESUME            | \
    PHONESTATE_DEVSPECIFIC       | \
    PHONESTATE_REINIT)

#define AllPhoneStates1_4          \
    (PHONESTATE_OTHER            | \
    PHONESTATE_CONNECTED         | \
    PHONESTATE_DISCONNECTED      | \
    PHONESTATE_OWNER             | \
    PHONESTATE_MONITORS          | \
    PHONESTATE_DISPLAY           | \
    PHONESTATE_LAMP              | \
    PHONESTATE_RINGMODE          | \
    PHONESTATE_RINGVOLUME        | \
    PHONESTATE_HANDSETHOOKSWITCH | \
    PHONESTATE_HANDSETVOLUME     | \
    PHONESTATE_HANDSETGAIN       | \
    PHONESTATE_SPEAKERHOOKSWITCH | \
    PHONESTATE_SPEAKERVOLUME     | \
    PHONESTATE_SPEAKERGAIN       | \
    PHONESTATE_HEADSETHOOKSWITCH | \
    PHONESTATE_HEADSETVOLUME     | \
    PHONESTATE_HEADSETGAIN       | \
    PHONESTATE_SUSPEND           | \
    PHONESTATE_RESUME            | \
    PHONESTATE_DEVSPECIFIC       | \
    PHONESTATE_REINIT            | \
    PHONESTATE_CAPSCHANGE        | \
    PHONESTATE_REMOVED)

#define AllButtonModes             \
    (PHONEBUTTONMODE_DUMMY       | \
    PHONEBUTTONMODE_CALL         | \
    PHONEBUTTONMODE_FEATURE      | \
    PHONEBUTTONMODE_KEYPAD       | \
    PHONEBUTTONMODE_LOCAL        | \
    PHONEBUTTONMODE_DISPLAY)

#define AllButtonStates1_0         \
    (PHONEBUTTONSTATE_UP         | \
    PHONEBUTTONSTATE_DOWN)

#define AllButtonStates1_4         \
    (PHONEBUTTONSTATE_UP         | \
    PHONEBUTTONSTATE_DOWN        | \
    PHONEBUTTONSTATE_UNKNOWN     | \
    PHONEBUTTONSTATE_UNAVAIL)

#if DBG

#define PHONEPROLOG(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12) \
        PhoneProlog(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12)

#define PHONEEPILOGSYNC(a1,a2,a3,a4) PhoneEpilogSync(a1,a2,a3,a4)

#define PHONEEPILOGASYNC(a1,a2,a3,a4,a5,a6) PhoneEpilogAsync(a1,a2,a3,a4,a5,a6)

#else

#define PHONEPROLOG(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12) \
        PhoneProlog(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)

#define PHONEEPILOGSYNC(a1,a2,a3,a4) PhoneEpilogSync(a1,a2,a3)

#define PHONEEPILOGASYNC(a1,a2,a3,a4,a5,a6) PhoneEpilogAsync(a1,a2,a3,a4,a5)

#endif


typedef struct _PPHONECLOSE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONE      hPhone;
    };

    OUT DWORD           dwCallbackInstance;

} PHONECLOSE_PARAMS, *PPHONECLOSE_PARAMS;


typedef struct _PHONECONFIGDIALOG_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        IN  HWND        hwndOwner;
    };

    union
    {
        IN  DWORD       dwDeviceClassOffset;        // valid offset or
                                                    //   TAPI_NO_DATA
    };

} PHONECONFIGDIALOG_PARAMS, *PPHONECONFIGDIALOG_PARAMS;


typedef struct _PHONEDEVSPECIFIC_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD           hfnPostProcessProc;

    union
    {
        IN  HPHONE      hPhone;
    };

    // IN  ULONG_PTR       lpParams;                   // pointer to client buffer
    IN  DWORD           hpParams;                   // pointer to client buffer

    union
    {
        IN  DWORD       dwParamsOffset;
    };

    union
    {
        IN  DWORD       dwParamsSize;
    };

} PHONEDEVSPECIFIC_PARAMS, *PPHONEDEVSPECIFIC_PARAMS;


typedef struct _PHONEGETBUTTONINFO_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwButtonLampID;
    };

    union
    {
        IN  DWORD       dwButtonInfoTotalSize;      // size of client buffer
        OUT DWORD       dwButtonInfoOffset;         // valid offset on success
    };

} PHONEGETBUTTONINFO_PARAMS, *PPHONEGETBUTTONINFO_PARAMS;


typedef struct _PHONEGETDATA_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONE      hPhone;
    };


    union
    {
        IN  DWORD       dwDataID;
    };

    union
    {
        OUT DWORD       dwDataOffset;
    };

    union
    {
        IN  DWORD       dwSize;
    };

} PHONEGETDATA_PARAMS, *PPHONEGETDATA_PARAMS;


typedef struct _PHONEGETDEVCAPS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONEAPP   hPhoneApp;
    };

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        IN  DWORD       dwAPIVersion;
    };

    union
    {
        IN  DWORD       dwExtVersion;
    };

    union
    {
        IN  DWORD       dwPhoneCapsTotalSize;       // size of client buffer
        OUT DWORD       dwPhoneCapsOffset;          // valid offset on success
    };

} PHONEGETDEVCAPS_PARAMS, *PPHONEGETDEVCAPS_PARAMS;


typedef struct _PHONEGETDISPLAY_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwDisplayTotalSize;         // size of client buffer
        OUT DWORD       dwDisplayOffset;            // valid offset on success
    };

} PHONEGETDISPLAY_PARAMS, *PPHONEGETDISPLAY_PARAMS;


typedef struct _PHONEGETGAIN_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwHookSwitchDev;
    };

    union
    {
        OUT DWORD       dwGain;
    };

} PHONEGETGAIN_PARAMS, *PPHONEGETGAIN_PARAMS;


typedef struct _PHONEGETHOOKSWITCH_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        OUT DWORD       dwHookSwitchDevs;
    };

} PHONEGETHOOKSWITCH_PARAMS, *PPHONEGETHOOKSWITCH_PARAMS;


typedef struct _PHONEGETICON_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        IN  DWORD       dwDeviceClassOffset;        // valid offset or
                                                    //   TAPI_NO_DATA
    };

    union
    {
        OUT HICON       hIcon;
    };

} PHONEGETICON_PARAMS, *PPHONEGETICON_PARAMS;


typedef struct _PHONEGETID_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwDeviceIDTotalSize;        // size of client buffer
        OUT DWORD       dwDeviceIDOffset;           // valid offset on success
    };

    union
    {
        IN  DWORD       dwDeviceClassOffset;        // always valid offset
    };

} PHONEGETID_PARAMS, *PPHONEGETID_PARAMS;


typedef struct _PHONEGETLAMP_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwButtonLampID;
    };

    union
    {
        OUT DWORD       dwLampMode;
    };

} PHONEGETLAMP_PARAMS, *PPHONEGETLAMP_PARAMS;


typedef struct _PHONEGETRING_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        OUT DWORD       dwRingMode;
    };

    union
    {
        OUT DWORD       dwVolume;
    };

} PHONEGETRING_PARAMS, *PPHONEGETRING_PARAMS;


typedef struct _PHONEGETSTATUS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONE       hPhone;
    };

    union
    {
        IN  DWORD       dwPhoneStatusTotalSize;     // size of client buffer
        OUT DWORD       dwPhoneStatusOffset;        // valid offset on success
    };

} PHONEGETSTATUS_PARAMS, *PPHONEGETSTATUS_PARAMS;


typedef struct _PHONEGETSTATUSMESSAGES_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        OUT DWORD       dwPhoneStates;
    };

    union
    {
        OUT DWORD       dwButtonModes;
    };

    union
    {
        OUT DWORD       dwButtonStates;
    };

} PHONEGETSTATUSMESSAGES_PARAMS, *PPHONEGETSTATUSMESSAGES_PARAMS;


typedef struct _PHONEGETVOLUME_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwHookSwitchDev;
    };

    union
    {
        OUT DWORD       dwVolume;
    };

} PHONEGETVOLUME_PARAMS, *PPHONEGETVOLUME_PARAMS;


typedef struct _PHONEINITIALIZE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        OUT HPHONEAPP   hPhoneApp;
    };

    union
    {
        IN  DWORD       hInstance;
    };

    union
    {
        IN  DWORD       InitContext;
    };

    union
    {
        IN  DWORD       dwFriendlyNameOffset;       // always valid offset
    };

    union
    {
        OUT DWORD       dwNumDevs;
    };

    union
    {
        IN  DWORD       dwModuleNameOffset;         // always valid offset
    };

    union
    {
        IN  DWORD       dwAPIVersion;
    };

} PHONEINITIALIZE_PARAMS, *PPHONEINITIALIZE_PARAMS;


typedef struct _PHONENEGOTIATEAPIVERSION_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONEAPP   hPhoneApp;
    };

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        IN  DWORD       dwAPILowVersion;
    };

    union
    {
        IN  DWORD       dwAPIHighVersion;
    };

    union
    {
        OUT DWORD       dwAPIVersion;
    };

    union
    {
        OUT DWORD       dwExtensionIDOffset;        // valid offset if success
    };

    union
    {
        IN OUT DWORD    dwSize;
    };

} PHONENEGOTIATEAPIVERSION_PARAMS, *PPHONENEGOTIATEAPIVERSION_PARAMS;


typedef struct _PHONENEGOTIATEEXTVERSION_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONEAPP   hPhoneApp;
    };

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        IN  DWORD       dwAPIVersion;
    };

    union
    {
        IN  DWORD       dwExtLowVersion;
    };

    union
    {
        IN  DWORD       dwExtHighVersion;
    };

    union
    {
        OUT DWORD       dwExtVersion;
    };

} PHONENEGOTIATEEXTVERSION_PARAMS, *PPHONENEGOTIATEEXTVERSION_PARAMS;


typedef struct _PHONEOPEN_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONEAPP   hPhoneApp;
    };

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        OUT HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwAPIVersion;
    };

    union
    {
        IN  DWORD       dwExtVersion;
    };

    DWORD               OpenContext;

    union
    {
        IN  DWORD       dwPrivilege;
    };

    //
    // The following is a "remote phone handle".  When the client is
    // remotesp.tsp running on a remote machine, this will be some
    // non-NULL value, and tapisrv should use this handle in status/etc
    // indications to the client rather than the std hPhone. If the
    // client is not remote.tsp thne this value will be NULL.
    //

    union
    {
        IN  HPHONE      hRemotePhone;
    };

} PHONEOPEN_PARAMS, *PPHONEOPEN_PARAMS;


typedef struct _PHONESELECTEXTVERSION_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwExtVersion;
    };

} PHONESELECTEXTVERSION_PARAMS, *PPHONESELECTEXTVERSION_PARAMS;


typedef struct _PHONESETBUTTONINFO_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwButtonLampID;
    };

    union
    {
        IN  DWORD       dwButtonInfoOffset;         // always valid offset
    };

} PHONESETBUTTONINFO_PARAMS, *PPHONESETBUTTONINFO_PARAMS;


typedef struct _PHONESETDATA_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwDataID;
    };

    union
    {
        IN  DWORD       dwDataOffset;               // always valid offset
    };

    union
    {
        IN  DWORD       dwSize;
    };

} PHONESETDATA_PARAMS, *PPHONESETDATA_PARAMS;


typedef struct _PHONESETDISPLAY_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwRow;
    };

    union
    {
        IN  DWORD       dwColumn;
    };

    union
    {
        IN  DWORD       dwDisplayOffset;            // always valid offset
    };

    union
    {
        IN  DWORD       dwSize;
    };

} PHONESETDISPLAY_PARAMS, *PPHONESETDISPLAY_PARAMS;


typedef struct _PHONESETGAIN_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwHookSwitchDev;
    };

    union
    {
        IN  DWORD       dwGain;
    };

} PHONESETGAIN_PARAMS, *PPHONESETGAIN_PARAMS;


typedef struct _PHONESETHOOKSWITCH_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwHookSwitchDevs;
    };

    union
    {
        IN  DWORD       dwHookSwitchMode;
    };

} PHONESETHOOKSWITCH_PARAMS, *PPHONESETHOOKSWITCH_PARAMS;


typedef struct _PHONESETLAMP_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwButtonLampID;
    };

    union
    {
        IN  DWORD       dwLampMode;
    };

} PHONESETLAMP_PARAMS, *PPHONESETLAMP_PARAMS;


typedef struct _PHONESETRING_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwRingMode;
    };

    union
    {
        IN  DWORD       dwVolume;
    };

} PHONESETRING_PARAMS, *PPHONESETRING_PARAMS;


typedef struct _PHONESETSTATUSMESSAGES_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwPhoneStates;
    };

    union
    {
        IN  DWORD       dwButtonModes;
    };

    union
    {
        IN  DWORD       dwButtonStates;
    };

} PHONESETSTATUSMESSAGES_PARAMS, *PPHONESETSTATUSMESSAGES_PARAMS;


typedef struct _PHONESETVOLUME_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwHookSwitchDev;
    };

    union
    {
        IN  DWORD       dwVolume;
    };

} PHONESETVOLUME_PARAMS, *PPHONESETVOLUME_PARAMS;


typedef struct _PHONESHUTDOWN_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONEAPP   hPhoneApp;
    };

} PHONESHUTDOWN_PARAMS, *PPHONESHUTDOWN_PARAMS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\inc\tapiaud.h ===
/*++

    Copyright (c) 1997 Microsoft Corporation

Module Name:

    tapiaud.h

Abstract:

    This module contains the definition of interfaces to the audio related
    filters.

Author:

    Mu Han (muhan) May-15-1999

--*/

#ifndef __tapiaud_h__
#define __tapiaud_h__

#include <mmreg.h>
#include <dsound.h>
#include "tapiqc.h"


// CLSIDs for the audio filters

struct DECLSPEC_UUID("581d09e5-0b45-11d3-a565-00c04f8ef6e3") TAPIAudioCapture;
struct DECLSPEC_UUID("8d5c6cb6-0b44-4a5a-b785-44c366d4e677") TAPIAudioEncoder;
struct DECLSPEC_UUID("65439c20-604f-49ca-aa82-dc01a10af171") TAPIAudioDecoder;
struct DECLSPEC_UUID("ad4e63da-c3ef-408f-8153-0fc7d5c29f72") TAPIAudioMixer;
struct DECLSPEC_UUID("44a3b142-cf81-42ea-b4d1-f43dd6f64ece") TAPIAudioRender;

struct DECLSPEC_UUID("3878e189-cfb5-4e75-bd92-3686ee6e6634") TAPIAudioPluginDecoder;

struct DECLSPEC_UUID("613ebf9e-c765-446f-bf96-7728ce579282") TAPIAudioDuplexController;

// It is really bad that we had to do this here.
struct DECLSPEC_UUID("b0210783-89cd-11d0-af08-00a0c925cd16") IDirectSoundNotify;
struct DECLSPEC_UUID("279AFA83-4981-11CE-A521-0020AF0BE560") IDirectSound;
struct DECLSPEC_UUID("C50A7E93-F395-4834-9EF6-7FA99DE50966") IDirectSound8;
struct DECLSPEC_UUID("b0210781-89cd-11d0-af08-00a0c925cd16") IDirectSoundCapture;
struct DECLSPEC_UUID("b0210782-89cd-11d0-af08-00a0c925cd16") IDirectSoundCaptureBuffer;
struct DECLSPEC_UUID("279AFA85-4981-11CE-A521-0020AF0BE560") IDirectSoundBuffer;


// the data structure to describe a audio device.
typedef interface tagAudioDeviceInfo
{
    UINT    WaveID;
    GUID    DSoundGUID;
	WCHAR   szDeviceDescription[MAX_PATH];

} AudioDeviceInfo, *PAudioDeviceInfo;


// device enumeration functions exposed by the tapi audio capture dll.
typedef HRESULT (WINAPI *PFNAudioGetDeviceInfo)(
    OUT DWORD * pdwNumDevices,
    OUT AudioDeviceInfo ** ppDeviceInfo
    );

typedef HRESULT (WINAPI *PFNAudioReleaseDeviceInfo)(
    IN AudioDeviceInfo * ppDeviceInfo
    );


// This interface is supported by the duplex controller. It only supports 
// dsound now.
typedef enum EFFECTS
{
    EFFECTS_AEC = 0,
    EFFECTS_AGC,
    EFFECTS_NS,
    EFFECTS_LAST

} EFFECTS;

interface DECLSPEC_UUID("864551a0-a822-48d7-a193-ddaa1c43d242") DECLSPEC_NOVTABLE 
IAudioDuplexController : public IUnknown
{
    STDMETHOD (SetCaptureBufferInfo) (
        IN  GUID *          pDSoundCaptureGUID,
        IN  DSCBUFFERDESC * pDescription
        ) PURE;

    STDMETHOD (SetRenderBufferInfo) (
        IN  GUID *          pDSoundRenderGUID,
        IN  DSBUFFERDESC *  pDescription,
        IN  HWND            hWindow,
        IN  DWORD           dwCooperateLevel
        ) PURE;

    STDMETHOD (EnableEffects) (
        IN  DWORD           dwNumberEffects,
        IN  EFFECTS *       pEffects,
        IN  BOOL *          pfEnable
        );

    STDMETHOD (GetCaptureDevice) (
        LPLPDIRECTSOUNDCAPTURE        ppDSoundCapture,
        LPLPDIRECTSOUNDCAPTUREBUFFER  ppCaptureBuffer
        ) PURE;

    STDMETHOD (GetRenderDevice) (
        LPLPDIRECTSOUND        ppDirectSound,
        LPLPDIRECTSOUNDBUFFER  ppRenderBuffer
        ) PURE;

    STDMETHOD (ReleaseCaptureDevice) () PURE;

    STDMETHOD (ReleaseRenderDevice) () PURE;

    STDMETHOD (GetEffect) (
        IN EFFECTS Effect,
        OUT BOOL *pfEnabled
        );
};


// the device configuration interface on teh tapi audio capture filter.
interface DECLSPEC_UUID("3a12e2c1-1265-11d3-a56d-00c04f8ef6e3") DECLSPEC_NOVTABLE 
IAudioDeviceConfig : public IUnknown
{
    STDMETHOD (SetDeviceID) (
        IN  REFGUID pDSoundGUID,
        IN  UINT    uiWaveID
        ) PURE;

    STDMETHOD (SetDuplexController) (
        IN  IAudioDuplexController * pIAudioDuplexController
        ) PURE;
};

#if !defined(STREAM_INTERFACES_DEFINED)

typedef enum tagAudioDeviceProperty
{
    AudioDevice_DuplexMode,
    AudioDevice_AutomaticGainControl,
    AudioDevice_AcousticEchoCancellation

} AudioDeviceProperty;

#endif

// IAudioDeviceControl interface.
interface DECLSPEC_UUID("3a12e2c2-1265-11d3-a56d-00c04f8ef6e3") DECLSPEC_NOVTABLE 
IAudioDeviceControl : public IUnknown
{
    STDMETHOD (GetRange) (
        IN AudioDeviceProperty Property, 
        OUT long *plMin, 
        OUT long *plMax, 
        OUT long *plSteppingDelta, 
        OUT long *plDefault, 
        OUT TAPIControlFlags *plFlags
        ) PURE;

    STDMETHOD (Get) (
        IN AudioDeviceProperty Property, 
        OUT long *plValue, 
        OUT TAPIControlFlags *plFlags
        ) PURE;

    STDMETHOD (Set) (
        IN AudioDeviceProperty Property, 
        IN long lValue, 
        IN TAPIControlFlags lFlags
        ) PURE;
};

// IAudioAutoPlay interface
interface DECLSPEC_UUID("c5e7c28f-1446-4ebe-b7fc-72f599a72663")  DECLSPEC_NOVTABLE
IAudioAutoPlay : public IUnknown
{
    STDMETHOD (StartAutoPlay) (IN BOOL fRun) PURE;

    STDMETHOD (StopAutoPlay) () PURE;
};

// IAudioEffectControl interface
interface DECLSPEC_UUID("8eb9f108-3447-4fee-a705-6c6cf35c660c")  DECLSPEC_NOVTABLE
IAudioEffectControl : public IUnknown
{
    // if enabled and AEC, use DSound AGC
    STDMETHOD (SetDsoundAGC) (IN BOOL fEnable) PURE;

    // if enabled and no AEC, revert gain to previous volume
    STDMETHOD (SetGainIncRevert) (IN BOOL fEnable) PURE;

    STDMETHOD (SetFixedMixLevel) (IN DOUBLE dLevel) PURE;
};

// IBasicAudioEx interface
interface DECLSPEC_UUID("9c31055a-24bd-4ac1-be2b-ebe7ce89890c")  DECLSPEC_NOVTABLE
IBasicAudioEx : public IUnknown
{
    STDMETHOD (SetMute) (IN BOOL fMute) PURE;
    STDMETHOD (GetMute) (OUT LPBOOL pfMute) PURE;
};

// IAudioDTMFControl interface
interface DECLSPEC_UUID("dd1f3c26-5524-4d77-9fb2-7df5d62ffd87")  DECLSPEC_NOVTABLE
IAudioDTMFControl : public IUnknown
{
    STDMETHOD (SendDTMFEvent) (
        IN DWORD dwEvent
        ) PURE;
};

// IAudioStatistics
interface DECLSPEC_UUID("20fc7641-f3b2-4384-96ad-bf3d986e8751")  DECLSPEC_NOVTABLE
IAudioStatistics : public IUnknown
{
    STDMETHOD (GetAudioLevel) (OUT LPLONG plAudioLevel) PURE;
    STDMETHOD (GetAudioLevelRange) (
        OUT LPLONG plMin,
        OUT LPLONG plMax
        ) PURE;
};

// ISilenceControl interface
interface DECLSPEC_UUID("8804b7e4-2ef4-489f-a31b-740ac4278304")  DECLSPEC_NOVTABLE
ISilenceControl : public IUnknown
{
    STDMETHOD (SetSilenceDetection) (IN BOOL fEnable) PURE;
    STDMETHOD (GetSilenceDetection) (OUT LPBOOL pfEnable) PURE;

    STDMETHOD (SetSilenceCompression) (IN BOOL fEnable) PURE;
    STDMETHOD (GetSilenceCompression) (OUT LPBOOL pfEnable) PURE;

    STDMETHOD (GetAudioLevel) (
        OUT LPLONG plAudioLevel
        ) PURE;

    STDMETHOD (GetAudioLevelRange) (
        OUT LPLONG plMin, 
        OUT LPLONG plMax, 
        OUT LPLONG plSteppingDelta
        ) PURE;

    STDMETHOD (SetSilenceLevel) (
        IN LONG lSilenceLevel,
        IN TAPIControlFlags lFlags
        ) PURE;

    STDMETHOD (GetSilenceLevel) (
        OUT LPLONG plSilenceLevel,
        OUT TAPIControlFlags * pFlags
        ) PURE;

    STDMETHOD (GetSilenceLevelRange) (
        OUT LPLONG plMin, 
        OUT LPLONG plMax, 
        OUT LPLONG plSteppingDelta, 
        OUT LPLONG plDefault,
        OUT TAPIControlFlags * pFlags
        ) PURE;
};

#define VAD_EVENTBASE (100000)

// events for voice activity detection.
typedef enum VAD_EVENT
{
    VAD_TALKING,
    VAD_SILENCE

} VAD_EVENT;

#ifndef WAVEFORMATEX_RTPG711
typedef struct {
	// Generic WAVEFORMATEX fields
	WAVEFORMATEX WaveFormatEx;

	// network specific field
	WORD wPacketDuration;

	// Reserved
	DWORD dwReserved[2];
} WAVEFORMATEX_RTPG711, *PWAVEFORMATEX_RTPG711;
#endif

#ifndef WAVEFORMATEX_RTPG723_1
typedef struct {
	// Generic WAVEFORMATEX fields
	WAVEFORMATEX WaveFormatEx;

	// network specific field
	WORD wPacketDuration;

	// Variable bitrate specific field
	WORD wSamplesPerBlock;

	// G.723.1 specific fields
	WORD fSilenceDetection:1;
	WORD fSilenceCompression:1;
	WORD fLowDataRate:1;
	WORD fReserved:13;

	// Reserved
	DWORD dwReserved[2];
} WAVEFORMATEX_RTPG723_1, *PWAVEFORMATEX_RTPG723_1;
#endif

#ifndef WAVEFORMATEX_RTPDVI4
typedef struct {
	// Generic WAVEFORMATEX fields
	WAVEFORMATEX WaveFormatEx;

	// network specific field
	WORD wPacketDuration;

} WAVEFORMATEX_RTPDVI4, *PWAVEFORMATEX_RTPDVI4;
#endif

#ifndef WAVEFORMATEX_RTPSIREN

/* WAVE form wFormatTag IDs (mmreg.h defines most of the tags) */
#define WAVE_FORMAT_SIREN 0x3001

typedef struct {
	// Generic WAVEFORMATEX fields
	WAVEFORMATEX WaveFormatEx;

	// network specific field
	WORD wPacketDuration;

} WAVEFORMATEX_RTPSIREN, *PWAVEFORMATEX_RTPSIREN;
#endif

#ifndef WAVEFORMATEX_RTPG722_1

#define WAVE_FORMAT_G722_1 0x3002

typedef struct {
	// Generic WAVEFORMATEX fields
	WAVEFORMATEX WaveFormatEx;

	// network specific field
	WORD wPacketDuration;

} WAVEFORMATEX_RTPG722_1, *PWAVEFORMATEX_RTPG722_1;
#endif


#ifndef WAVEFORMATEX_RTPMSAUDIO
typedef struct {
	// Generic WAVEFORMATEX fields
	WAVEFORMATEX WaveFormatEx;

	// network specific field
	WORD wPacketDuration;

} WAVEFORMATEX_RTPMSAUDIO, *PWAVEFORMATEX_RTPMSAUDIO;
#endif

#ifndef WAVEFORMATEX_RTPGSM
typedef struct {
	// Generic WAVEFORMATEX fields
	WAVEFORMATEX WaveFormatEx;

	// network specific field
	WORD wPacketDuration;

    BOOL fMbone;

} WAVEFORMATEX_RTPGSM, *PWAVEFORMATEX_RTPGSM;
#endif


// IEncoderSampleRateControl, a private interface for the test team.
interface DECLSPEC_UUID("483f56a9-513f-4f8b-b0e5-bc6a7ba3f8b9")  DECLSPEC_NOVTABLE
IEncoderSampleRateControl : public IUnknown
{
    STDMETHOD (GetSampleRate) (OUT DWORD *pdwSampleRate) PURE;
    STDMETHOD (SetSampleRate) (IN DWORD dwSampleRate) PURE;
};


#endif //__tapiaud_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\inc\server.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1995-1998  Microsoft Corporation

Module Name:

    server.h

Abstract:

    Header file for tapi server & client

Author:

    Dan Knudson (DanKn)    01-Apr-1995

Revision History:

--*/


#include "rmotsp.h"
#include "tapiclnt.h"
#include "tlnklist.h"
#include "tapievt.h"

#ifdef __cplusplus
extern "C" {
#endif

#define INVAL_KEY                   ((DWORD) 'LVNI')
#define TCALL_KEY                   ((DWORD) 'LLAC')
#define TINCOMPLETECALL_KEY         ((DWORD) 'LACI')
#define TZOMBIECALL_KEY             ((DWORD) 'LACZ')
#define TCALLCLIENT_KEY             ((DWORD) 'ILCC')
#define TCALLHUBCLIENT_KEY          ((DWORD) 'CBUH')
#define TINCOMPLETECALLCLIENT_KEY   ((DWORD) 'LCCI')
#define TLINE_KEY                   ((DWORD) 'ENIL')
#define TINCOMPLETELINE_KEY         ((DWORD) 'NILI')
#define TLINECLIENT_KEY             ((DWORD) 'ILCL')
#define TPHONE_KEY                  ((DWORD) 'NOHP')
#define TINCOMPLETEPHONE_KEY        ((DWORD) 'OHPI')
#define TPHONECLIENT_KEY            ((DWORD) 'ILCP')
#define TLINEAPP_KEY                ((DWORD) 'PPAL')
#define TPHONEAPP_KEY               ((DWORD) 'PPAP')
#define TCLIENT_KEY                 ((DWORD) 'TNLC')
#define TCLIENTCLEANUP_KEY          ((DWORD) 'CNLC')
#define TZOMBIECLIENT_KEY           ((DWORD) 'ZNLC')
#define TPROVIDER_KEY               ((DWORD) 'VORP')
#define TASYNC_KEY                  ((DWORD) 'CYSA')
#define TDLGINST_KEY                ((DWORD) 'GOLD')
#define TCONFLIST_KEY               ((DWORD) 'FNOC')
#define RSP_MSG                     ((DWORD)'RXYQ')
#define RSP_CALLPARAMS              0xFEDC

#ifdef _WIN64
#define TALIGN_MASK                 0xfffffff8
#define TALIGN_COUNT                7
#else
#define TALIGN_MASK                 0xfffffffc
#define TALIGN_COUNT                3
#endif
#define ALIGN(a)                    (((a)+TALIGN_COUNT)&TALIGN_MASK)
#define ALIGNED(a)                  (0 == (((ULONG_PTR)(a))&TALIGN_COUNT))

#define INITIAL_EVENT_BUFFER_SIZE   1024

#define DEF_NUM_LOOKUP_ENTRIES      16
#define DEF_NUM_CONF_LIST_ENTRIES   4
#define DEF_NUM_PTR_LIST_ENTRIES    8

#define LINEPROXYREQUEST_LASTVALUE  LINEPROXYREQUEST_SETAGENTSTATEEX

#define BOGUS_REQUEST_ID            0x7fffffff

#define DCF_SPIRETURNED             0x00000001
#define DCF_DRVCALLVALID            0x00000002
#define DCF_CREATEDINITIALMONITORS  0x00000004
#define DCF_INCOMINGCALL            0x00010000

#define SYNC_REQUESTS_ALL           0
#define SYNC_REQUESTS_PER_WIDGET    1
#define SYNC_REQUESTS_NONE          2

#define SP_NONE                     0xffffffff

#define DGCLIENT_TIMEOUT            1000        // milliseconds
#define DGCLIENTDISCONNECT_TIMEOUT  (5*60*1000) // milliseconds

#define SP_LINEACCEPT                       0
#define SP_LINEADDTOCONFERENCE              1
#define SP_LINEAGENTSPECIFIC                2
#define SP_LINEANSWER                       3
#define SP_LINEBLINDTRANSFER                4
#define SP_LINECLOSE                        5
#define SP_LINECLOSECALL                    6
#define SP_LINECOMPLETECALL                 7
#define SP_LINECOMPLETETRANSFER             8
#define SP_LINECONDITIONALMEDIADETECTION    9
#define SP_LINEDEVSPECIFIC                  10
#define SP_LINEDEVSPECIFICFEATURE           11
#define SP_LINEDIAL                         12
#define SP_LINEDROP                         13
#define SP_LINEFORWARD                      14
#define SP_LINEGATHERDIGITS                 15
#define SP_LINEGENERATEDIGITS               16
#define SP_LINEGENERATETONE                 17
#define SP_LINEGETADDRESSCAPS               18
#define SP_LINEGETADDRESSID                 19
#define SP_LINEGETADDRESSSTATUS             20
#define SP_LINEGETAGENTACTIVITYLIST         21
#define SP_LINEGETAGENTCAPS                 22
#define SP_LINEGETAGENTGROUPLIST            23
#define SP_LINEGETAGENTSTATUS               24
#define SP_LINEGETCALLADDRESSID             25
#define SP_LINEGETCALLINFO                  26
#define SP_LINEGETCALLSTATUS                27
#define SP_LINEGETDEVCAPS                   28
#define SP_LINEGETDEVCONFIG                 29
#define SP_LINEGETEXTENSIONID               30
#define SP_LINEGETICON                      31
#define SP_LINEGETID                        32
#define SP_LINEGETLINEDEVSTATUS             33
#define SP_LINEGETNUMADDRESSIDS             34
#define SP_LINEHOLD                         35
#define SP_LINEMAKECALL                     36
#define SP_LINEMONITORDIGITS                37
#define SP_LINEMONITORMEDIA                 38
#define SP_LINEMONITORTONES                 39
#define SP_LINENEGOTIATEEXTVERSION          40
#define SP_LINENEGOTIATETSPIVERSION         41
#define SP_LINEOPEN                         42
#define SP_LINEPARK                         43
#define SP_LINEPICKUP                       44
#define SP_LINEPREPAREADDTOCONFERENCE       45
#define SP_LINEREDIRECT                     46
#define SP_LINERELEASEUSERUSERINFO          47
#define SP_LINEREMOVEFROMCONFERENCE         48
#define SP_LINESECURECALL                   49
#define SP_LINESELECTEXTVERSION             50
#define SP_LINESENDUSERUSERINFO             51
#define SP_LINESETAGENTACTIVITY             52
#define SP_LINESETAGENTGROUP                53
#define SP_LINESETAGENTSTATE                54
#define SP_LINESETAPPSPECIFIC               55
#define SP_LINESETCALLDATA                  56
#define SP_LINESETCALLPARAMS                57
#define SP_LINESETCALLQUALITYOFSERVICE      58
#define SP_LINESETCALLTREATMENT             59
#define SP_LINESETCURRENTLOCATION           60
#define SP_LINESETDEFAULTMEDIADETECTION     61
#define SP_LINESETDEVCONFIG                 62
#define SP_LINESETLINEDEVSTATUS             63
#define SP_LINESETMEDIACONTROL              64
#define SP_LINESETMEDIAMODE                 65
#define SP_LINESETSTATUSMESSAGES            66
#define SP_LINESETTERMINAL                  67
#define SP_LINESETUPCONFERENCE              68
#define SP_LINESETUPTRANSFER                69
#define SP_LINESWAPHOLD                     70
#define SP_LINEUNCOMPLETECALL               71
#define SP_LINEUNHOLD                       72
#define SP_LINEUNPARK                       73
#define SP_PHONECLOSE                       74
#define SP_PHONEDEVSPECIFIC                 75
#define SP_PHONEGETBUTTONINFO               76
#define SP_PHONEGETDATA                     77
#define SP_PHONEGETDEVCAPS                  78
#define SP_PHONEGETDISPLAY                  79
#define SP_PHONEGETEXTENSIONID              80
#define SP_PHONEGETGAIN                     81
#define SP_PHONEGETHOOKSWITCH               82
#define SP_PHONEGETICON                     83
#define SP_PHONEGETID                       84
#define SP_PHONEGETLAMP                     85
#define SP_PHONEGETRING                     86
#define SP_PHONEGETSTATUS                   87
#define SP_PHONEGETVOLUME                   88
#define SP_PHONENEGOTIATEEXTVERSION         89
#define SP_PHONENEGOTIATETSPIVERSION        90
#define SP_PHONEOPEN                        91
#define SP_PHONESELECTEXTVERSION            92
#define SP_PHONESETBUTTONINFO               93
#define SP_PHONESETDATA                     94
#define SP_PHONESETDISPLAY                  95
#define SP_PHONESETGAIN                     96
#define SP_PHONESETHOOKSWITCH               97
#define SP_PHONESETLAMP                     98
#define SP_PHONESETRING                     99
#define SP_PHONESETSTATUSMESSAGES           100
#define SP_PHONESETVOLUME                   101
#define SP_PROVIDERCREATELINEDEVICE         102
#define SP_PROVIDERCREATEPHONEDEVICE        103
#define SP_PROVIDERENUMDEVICES              104
#define SP_PROVIDERFREEDIALOGINSTANCE       105
#define SP_PROVIDERGENERICDIALOGDATA        106
#define SP_PROVIDERINIT                     107
#define SP_PROVIDERSHUTDOWN                 108
#define SP_PROVIDERUIIDENTIFY               109
#define SP_LINEMSPIDENTIFY                  110
#define SP_LINERECEIVEMSPDATA               111
#define SP_PROVIDERCHECKFORNEWUSER          112
#define SP_LINEGETCALLIDS                   113
#define SP_LINEGETCALLHUBTRACKING           114
#define SP_LINESETCALLHUBTRACKING           115
#define SP_PROVIDERPRIVATEFACTORYIDENTIFY   116
#define SP_LINEDEVSPECIFICEX                117
#define SP_LINECREATEAGENT                  118
#define SP_LINECREATEAGENTSESSION           119
#define SP_LINEGETAGENTINFO                 120
#define SP_LINEGETAGENTSESSIONINFO          121
#define SP_LINEGETAGENTSESSIONLIST          122
#define SP_LINEGETQUEUEINFO                 123
#define SP_LINEGETGROUPLIST                 124
#define SP_LINEGETQUEUELIST                 125
#define SP_LINESETAGENTMEASUREMENTPERIOD    126
#define SP_LINESETAGENTSESSIONSTATE         127
#define SP_LINESETQUEUEMEASUREMENTPERIOD    128
#define SP_LINESETAGENTSTATEEX              129
#define SP_LINEGETPROXYSTATUS               130
#define SP_LINECREATEMSPINSTANCE            131
#define SP_LINECLOSEMSPINSTANCE             132
#define SP_LASTPROCNUMBER                   (SP_LINECLOSEMSPINSTANCE + 1)


// TAPICLIENT api

#define TC_LOAD                             0
#define TC_FREE                             1
#define TC_CLIENTINITIALIZE                 2
#define TC_CLIENTSHUTDOWN                   3
#define TC_GETDEVICEACCESS                  4
#define TC_LINEADDTOCONFERENCE              5
#define TC_LINEBLINDTRANSFER                6
#define TC_LINECONFIGDIALOG                 7
#define TC_LINEDIAL                         8
#define TC_LINEFORWARD                      9
#define TC_LINEGENERATEDIGITS               10
#define TC_LINEMAKECALL                     11
#define TC_LINEOPEN                         12
#define TC_LINEREDIRECT                     13
#define TC_LINESETCALLDATA                  14
#define TC_LINESETCALLPARAMS                15
#define TC_LINESETCALLPRIVILEGE             16
#define TC_LINESETCALLTREATMENT             17
#define TC_LINESETCURRENTLOCATION           18
#define TC_LINESETDEVCONFIG                 19
#define TC_LINESETLINEDEVSTATUS             20
#define TC_LINESETMEDIACONTROL              21
#define TC_LINESETMEDIAMODE                 22
#define TC_LINESETTERMINAL                  23
#define TC_LINESETTOLLLIST                  24
#define TC_PHONECONFIGDIALOG                25
#define TC_PHONEOPEN                        26
#define TC_LASTPROCNUMBER                   TC_PHONEOPEN+1


#define myexcept except(EXCEPTION_EXECUTE_HANDLER)

#define CN_CLIENT ((ULONG_PTR) -1)
#define DG_CLIENT ((ULONG_PTR) -2)
#define MMC_CLIENT ((ULONG_PTR) -3)

#define IS_REMOTE_CLIENT(ptClient) \
            (((((ULONG_PTR) ptClient->hProcess) & DG_CLIENT) == DG_CLIENT) || \
            (ptClient->hProcess == (HANDLE) MMC_CLIENT))

#define IS_REMOTE_CN_CLIENT(ptClient) \
            (ptClient->hProcess == (HANDLE) CN_CLIENT)

#define IS_REMOTE_DG_CLIENT(ptClient) \
            (ptClient->hProcess == (HANDLE) DG_CLIENT)

#define IS_REMOTE_MMC_CLIENT(ptClient) \
            (ptClient->hProcess == (HANDLE) MMC_CLIENT)

#define SET_FLAG(dw,fl)     (dw) |= (fl)
#define RESET_FLAG(dw,fl)   (dw) &= ~(fl)
#define IS_FLAG_SET(dw,fl)  ((dw) & (fl))

typedef LONG (PASCAL *TSPIPROC)();
typedef LONG (PASCAL *CLIENTPROC)();

typedef struct _TPOINTERLIST
{
    DWORD                   dwNumUsedEntries;

    LPVOID                  aEntries[DEF_NUM_PTR_LIST_ENTRIES];

} TPOINTERLIST, *PTPOINTERLIST;


typedef struct _THASHTABLEENTRY
{
    DWORD                       dwCallHubID;
    LONG                        lCookie;
    LIST_ENTRY                  CallHubList;
    struct _TCALLHUBCLIENT     *ptCallHubClients;
    struct _THASHTABLEENTRY    *pNext;

} THASHTABLEENTRY, *PTHASHTABLEENTRY;


typedef struct _TPROVIDER
{
    DWORD                   dwKey;
    HANDLE                  hMutex;
    HINSTANCE               hDll;
    DWORD                   dwTSPIOptions;

    DWORD                   dwSPIVersion;
    DWORD                   dwPermanentProviderID;
    struct _TPROVIDER      *pPrev;
    struct _TPROVIDER      *pNext;

    DWORD                   dwNumHashTableEntries;
    DWORD                   dwNumDynamicHashTableEntries;
    PTHASHTABLEENTRY        pHashTable;
    LONG                    lHashTableReaderCount;

    HANDLE                  hHashTableReaderEvent;

    CRITICAL_SECTION        HashTableCritSec;

    TSPIPROC                apfn[SP_LASTPROCNUMBER];

    DWORD                   dwNameHash;
    TCHAR                   szFileName[1];

} TPROVIDER, *PTPROVIDER;


typedef struct _TCALLHUBCLIENT
{
    DWORD                   dwKey;
    struct _TCLIENT *       ptClient;
    PTPROVIDER              ptProvider;
    DWORD                   dwCallHubID;

    HCALLHUB                hCallHub;
    struct _TLINEAPP       *ptLineApp;
    struct _TCALLHUBCLIENT *pNext;

} TCALLHUBCLIENT, *PTCALLHUBCLIENT;


typedef struct _TCALLCLIENT
{
    DWORD                   dwKey;
    struct _TCLIENT        *ptClient;
    struct _TLINECLIENT    *ptLineClient;
    struct _TCALL          *ptCall;

    DWORD                   dwPrivilege;
    DWORD                   dwMonitorDigitModes;
    DWORD                   dwMonitorMediaModes;

    //
    // The following field is used to determine whether we need to
    // set or zero the LINE_CALLSTATE\dwParam3 parameter to indicate
    // a privilege change to the app
    //

    BYTE                    bIndicatePrivilege;
    BYTE                    bMonitoringTones;
    BYTE                    bUnused1;
    BYTE                    bUnused2;

    struct _TCALLCLIENT    *pPrevSametCall;
    struct _TCALLCLIENT    *pNextSametCall;
    struct _TCALLCLIENT    *pPrevSametLineClient;
    struct _TCALLCLIENT    *pNextSametLineClient;

    struct _TCALLHUBCLIENT *ptCallHubClient;
    DWORD                   hCall;
    DWORD                   adwEventSubMasks[EM_NUM_MASKS];

} TCALLCLIENT, *PTCALLCLIENT;


typedef struct _TCALL
{
    DWORD                   dwKey;
    PTCALLCLIENT            ptCallClients;
    struct _TLINE          *ptLine;
    PTPROVIDER              ptProvider;

    DWORD                   dwDrvCallFlags;
    BOOL                    bCreatedInitialMonitors;
    HDRVCALL                hdCall;
    HCALL                   hCall;

    DWORD                   dwAddressID;
    DWORD                   dwCallState;
    DWORD                   dwCallStateMode;
    DWORD                   dwNumOwners;

    DWORD                   dwNumMonitors;
    BOOL                    bAlertApps;
    DWORD                   dwAppNameSize;
    LPVOID                  pszAppName;

    DWORD                   dwDisplayableAddressSize;
    LPVOID                  pszDisplayableAddress;
    DWORD                   dwCalledPartySize;
    LPVOID                  pszCalledParty;

    DWORD                   dwCommentSize;
    LPVOID                  pszComment;
    struct _TCONFERENCELIST * pConfList;
    struct _TCALL          *pPrev;

    struct _TCALL          *pNext;
    DWORD                   dwCallID;
    DWORD                   dwRelatedCallID;

    LIST_ENTRY              CallHubList;

    #define DEF_NUM_FAST_CALLCLIENTS 2

    LONG                    lUsedFastCallClients;
    LONG                    lActiveFastCallClients;

    TCALLCLIENT             aFastCallClients[DEF_NUM_FAST_CALLCLIENTS];

} TCALL, *PTCALL;


typedef struct _TCONFERENCELIST
{
    DWORD                   dwKey;
    DWORD                   dwNumTotalEntries;
    DWORD                   dwNumUsedEntries;
    struct _TCONFERENCELIST *pNext;

    PTCALL                  aptCalls[1];

} TCONFERENCELIST, *PTCONFERENCELIST;


typedef struct _TLINE
{
    DWORD                   dwKey;
    HANDLE                  hMutex;
    struct _TLINECLIENT *   ptLineClients;
    LPVOID                  apProxys[LINEPROXYREQUEST_LASTVALUE+1];

    PTPROVIDER              ptProvider;
    HDRVLINE                hdLine;
    HLINE                   hLine;
    DWORD                   dwDeviceID;

    DWORD                   dwSPIVersion;
    DWORD                   dwExtVersion;
    DWORD                   dwExtVersionCount;
    DWORD                   dwNumAddresses;

    DWORD                   dwOpenMediaModes;
    DWORD                   dwNumOpens;
    DWORD                   dwUnionLineStates;
    DWORD                   dwUnionAddressStates;

    PTCALL                  ptCalls;
    DWORD                   dwNumCallHubTrackers;
    DWORD                   dwNumCallHubTrackersSPLevel;
    DWORD                   dwBusy;

} TLINE, *PTLINE;


typedef struct _TLINECLIENT
{
    DWORD                   dwKey;
    struct _TCLIENT *       ptClient;
    struct _TLINEAPP *      ptLineApp;
    DWORD                   hLine;

    PTLINE                  ptLine;
    DWORD                   dwAddressID;
    PTCALLCLIENT            ptCallClients;
    DWORD                   hRemoteLine;

    DWORD                   dwAPIVersion;
    DWORD                   dwPrivileges;
    DWORD                   dwMediaModes;
    DWORD                   OpenContext;    // was : DWORD dwCallbackInstance;
    DWORD                   dwLineStates;

    DWORD                   dwAddressStates;
    LPDWORD                 aNumRings;
    DWORD                   dwExtVersion;

    struct _TLINECLIENT    *pPrevSametLine;
    struct _TLINECLIENT    *pNextSametLine;
    struct _TLINECLIENT    *pPrevSametLineApp;
    struct _TLINECLIENT    *pNextSametLineApp;

    LPVOID                  pPendingProxyRequests;
    DWORD                   dwCurrentTracking;
    HDRVMSPLINE             hdMSPLine;
    LPTSTR                  szProxyClsid;

    DWORD                   adwEventSubMasks[EM_NUM_MASKS];

} TLINECLIENT, *PTLINECLIENT;


typedef struct _TPHONE
{
    DWORD                   dwKey;
    HANDLE                  hMutex;
    struct _TPHONECLIENT *  ptPhoneClients;
    PTPROVIDER              ptProvider;

    HDRVPHONE               hdPhone;
    HPHONE                  hPhone;
    DWORD                   dwDeviceID;
    DWORD                   dwSPIVersion;

    DWORD                   dwExtVersion;
    DWORD                   dwExtVersionCount;
    DWORD                   dwNumOwners;
    DWORD                   dwNumMonitors;

    DWORD                   dwUnionPhoneStates;
    DWORD                   dwUnionButtonModes;
    DWORD                   dwUnionButtonStates;
    DWORD                   dwBusy;

} TPHONE, *PTPHONE;


typedef struct _TPHONECLIENT
{
    DWORD                   dwKey;
    struct _TCLIENT *       ptClient;
    struct _TPHONEAPP *     ptPhoneApp;
    PTPHONE                 ptPhone;

    DWORD                   hRemotePhone;
    DWORD                   dwAPIVersion;
    DWORD                   dwExtVersion;
    DWORD                   dwPrivilege;

    DWORD                   OpenContext;    // was : DWORD dwCallbackInstance;
    DWORD                   dwPhoneStates;
    DWORD                   dwButtonModes;
    DWORD                   dwButtonStates;

    struct _TPHONECLIENT   *pPrevSametPhone;
    struct _TPHONECLIENT   *pNextSametPhone;
    struct _TPHONECLIENT   *pPrevSametPhoneApp;
    struct _TPHONECLIENT   *pNextSametPhoneApp;

    DWORD                   hPhone;
    DWORD                   adwEventSubMasks[EM_NUM_MASKS];

} TPHONECLIENT, *PTPHONECLIENT;


typedef struct _TLINEAPP
{
    DWORD                   dwKey;
    struct _TCLIENT *       ptClient;
    PTLINECLIENT            ptLineClients;
    DWORD                   hLineApp; 

    DWORD                   InitContext;    // was: LINECALLBACK lpfnCallback;
    struct _TLINEAPP       *pPrev;
    struct _TLINEAPP       *pNext;
    DWORD                   dwAPIVersion;

    DWORD                   bReqMediaCallRecipient;
    LPVOID                  pRequestRecipient;
    DWORD                   dwFriendlyNameSize;
    WCHAR                  *pszFriendlyName;

    DWORD                   adwEventSubMasks[EM_NUM_MASKS];

    DWORD                   dwModuleNameSize;
    WCHAR                  *pszModuleName;

} TLINEAPP, *PTLINEAPP;


typedef struct _TPHONEAPP
{
    DWORD                   dwKey;
    DWORD                   hPhoneApp;
    struct _TCLIENT *       ptClient;
    DWORD                   InitContext;    // was: PHONECALLBACK lpfnCallback;

    PTPHONECLIENT           ptPhoneClients;
    struct _TPHONEAPP      *pPrev;
    struct _TPHONEAPP      *pNext;
    WCHAR                  *pszFriendlyName;

    WCHAR                  *pszModuleName;
    DWORD                   dwAPIVersion;
    DWORD                   dwFriendlyNameSize;
    DWORD                   dwModuleNameSize;

    DWORD                   adwEventSubMasks[EM_NUM_MASKS];

} TPHONEAPP, *PTPHONEAPP;


typedef struct _TAPIDIALOGINSTANCE
{
    DWORD                   dwKey;
    struct _TCLIENT *       ptClient;
    DWORD                   dwPermanentProviderID;
    HINSTANCE               hTsp;

    TSPIPROC                pfnTSPI_providerGenericDialogData;
    PTPROVIDER              ptProvider;
    HDRVDIALOGINSTANCE      hdDlgInst;
    WCHAR                  *pszProviderFilename;

    DWORD                   bRemoveProvider;
    struct _TAPIDIALOGINSTANCE *pPrev;
    struct _TAPIDIALOGINSTANCE *pNext;

    HTAPIDIALOGINSTANCE     htDlgInst;

} TAPIDIALOGINSTANCE, *PTAPIDIALOGINSTANCE;


// management DLL client info
typedef struct _TMANAGEDLLINFO
{
    HINSTANCE               hDll;
    DWORD                   dwID;
    CLIENTPROC              aProcs[TC_LASTPROCNUMBER];
    LPWSTR                  pszName;
    DWORD                   dwAPIVersion;
    struct _TMANAGEDLLINFO  *pNext;

} TMANAGEDLLINFO, *PTMANAGEDLLINFO;


typedef struct _TCLIENTHANDLE
{
    HMANAGEMENTCLIENT       hClient;
    DWORD                   dwID;
    BOOL                    fValid;
    struct _TCLIENTHANDLE   *pNext;

} TCLIENTHANDLE, *PTCLIENTHANDLE;


typedef struct _TCLIENT
{
    DWORD                   dwKey;
    HANDLE                  hProcess;
    DWORD                   dwUserNameSize;
    WCHAR                  *pszUserName;

    DWORD                   dwComputerNameSize;
    WCHAR                  *pszComputerName;
    WCHAR                  *pszDomainName;
    PCONTEXT_HANDLE_TYPE2   phContext;

    PTCLIENTHANDLE          pClientHandles;
    HMANAGEMENTCLIENT       hMapper;
    LPTAPIPERMANENTID       pLineMap;
    LPDWORD                 pLineDevices;

    DWORD                   dwLineDevices;
    LPTAPIPERMANENTID       pPhoneMap;
    LPDWORD                 pPhoneDevices;
    DWORD                   dwPhoneDevices;

    union
    {
    HANDLE                  hValidEventBufferDataEvent;
    HANDLE                  hMailslot;
    };
    DWORD                   dwEventBufferTotalSize;
    DWORD                   dwEventBufferUsedSize;
    LPBYTE                  pEventBuffer;

    LPBYTE                  pDataIn;
    LPBYTE                  pDataOut;
    PTLINEAPP               ptLineApps;
    PTPHONEAPP              ptPhoneApps;

    PTAPIDIALOGINSTANCE     pProviderXxxDlgInsts;
    PTAPIDIALOGINSTANCE     pGenericDlgInsts;
    struct _TCLIENT        *pPrev;
    struct _TCLIENT        *pNext;

    DWORD                   dwFlags;
    LIST_ENTRY              MsgPendingListEntry;
    union
    {
    DWORD                   dwDgRetryTimeoutTickCount;
    DWORD                   dwCnBusy;
    };

    DWORD                   dwDgEventsRetrievedTickCount;

    DWORD                   htClient;

    DWORD                   adwEventSubMasks[EM_NUM_MASKS];
} TCLIENT, *PTCLIENT;
#define PTCLIENT_FLAG_ADMINISTRATOR     1
#define PTCLIENT_FLAG_SKIPFIRSTMESSAGE  2
#define PTCLIENT_FLAG_LOCKEDMMCWRITE    4


typedef struct _TREQUESTRECIPIENT
{
    PTLINEAPP               ptLineApp;
    DWORD                   dwRegistrationInstance;
    struct _TREQUESTRECIPIENT  *pPrev;
    struct _TREQUESTRECIPIENT  *pNext;

} TREQUESTRECIPIENT, *PTREQUESTRECIPIENT;

typedef void (*SRVPOSTPROCESSPROC)(LPVOID, LPVOID, LPVOID);


//WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
//DEPENDENCY! DEPENDENCY! DEPENDENCY! DEPENDENCY! DEPENDENCY!
//DEPENDENCY! DEPENDENCY! DEPENDENCY! DEPENDENCY! DEPENDENCY!
//DEPENDENCY! DEPENDENCY! DEPENDENCY! DEPENDENCY! DEPENDENCY!
//
// The SPEVENT struct below must have the dwKey/dwType and ListEntry
// fields in the same relative place in the structure as ASYNCREQUESTINFO!
// Code in SERVER.C assumes this is an OK thing to do.
//
typedef struct _ASYNCREQUESTINFO
{
    DWORD                   dwKey;
    LIST_ENTRY              ListEntry;
    
    ULONG_PTR               htXxx;

    PTCLIENT                ptClient;
    LONG                    lResult;
    SRVPOSTPROCESSPROC      pfnPostProcess;
    DWORD                   dwLineFlags;

    DWORD                   InitContext;
    DWORD                   OpenContext;
    DWORD                   hfnClientPostProcessProc;
    DWORD                   dwLocalRequestID;

    DWORD                   dwRemoteRequestID;
    ULONG_PTR               dwParam1;
    ULONG_PTR               dwParam2;
    ULONG_PTR               dwParam3;
    ULONG_PTR               dwParam4;

    ULONG_PTR               dwParam5;

} ASYNCREQUESTINFO, *PASYNCREQUESTINFO;

enum {
        SP_LINE_EVENT = 1,
        SP_COMPLETION_EVENT,
        SP_PHONE_EVENT
     };


//DEPENDENCY! DEPENDENCY! DEPENDENCY! DEPENDENCY! DEPENDENCY!
//DEPENDENCY! DEPENDENCY! DEPENDENCY! DEPENDENCY! DEPENDENCY!
//
// (see above)
//
//DEPENDENCY! DEPENDENCY! DEPENDENCY! DEPENDENCY! DEPENDENCY!
//DEPENDENCY! DEPENDENCY! DEPENDENCY! DEPENDENCY! DEPENDENCY!
typedef struct _SPEVENT
{
    DWORD                   dwType;
    LIST_ENTRY              ListEntry;

    union
    {
    HTAPILINE               htLine;
    HTAPIPHONE              htPhone;
    DWORD                   dwRequestID;
    };
    union
    {
    HTAPICALL               htCall;
    LONG                    lResult;
    };

    DWORD                   dwMsg;
    ULONG_PTR               dwParam1;
    ULONG_PTR               dwParam2;
    ULONG_PTR               dwParam3;

} SPEVENT, *PSPEVENT;


typedef struct _SPEVENTHANDLERTHREADINFO
{
    LIST_ENTRY              ListHead;
    HANDLE                  hEvent;
    CRITICAL_SECTION        CritSec;

} SPEVENTHANDLERTHREADINFO, *PSPEVENTHANDLERTHREADINFO;

//
// The following XXXTUPLE types give us a quick easy way to retrieve
// the ptProvider and ptXxx associated with the widget (the widget ID
// is used as an index into a global array)
//

typedef struct _TLINELOOKUPENTRY
{
    DWORD                   dwSPIVersion;
    PTLINE                  ptLine;
    HANDLE                  hMutex;
    PTPROVIDER              ptProvider;

    DWORD                   bRemoved;
    DWORD                   bRemote;

} TLINELOOKUPENTRY, *PTLINELOOKUPENTRY;


typedef struct _TLINELOOKUPTABLE
{
    DWORD                   dwNumTotalEntries;
    DWORD                   dwNumUsedEntries;
    struct _TLINELOOKUPTABLE   *pNext;
    TLINELOOKUPENTRY        aEntries[1];

} TLINELOOKUPTABLE, *PTLINELOOKUPTABLE;


typedef struct _TPHONELOOKUPENTRY
{
    DWORD                   dwSPIVersion;
    PTPHONE                 ptPhone;
    HANDLE                  hMutex;
    PTPROVIDER              ptProvider;

    DWORD                   bRemoved;

} TPHONELOOKUPENTRY, *PTPHONELOOKUPENTRY;


typedef struct _TPHONELOOKUPTABLE
{
    DWORD                   dwNumTotalEntries;
    DWORD                   dwNumUsedEntries;
    struct _TPHONELOOKUPTABLE  *pNext;
    TPHONELOOKUPENTRY       aEntries[1];

} TPHONELOOKUPTABLE, *PTPHONELOOKUPTABLE;


typedef struct _TREQUESTMAKECALL
{
    LINEREQMAKECALLW        LineReqMakeCall;
    struct _TREQUESTMAKECALL   *pNext;

} TREQUESTMAKECALL, *PTREQUESTMAKECALL;


typedef struct _TMANAGEDLLLISTHEADER
{
    LONG                    lCount;
    PTMANAGEDLLINFO         pFirst;

} TMANAGEDLLLISTHEADER, *PTMANAGEDLLLISTHEADER;


typedef struct _PERMANENTIDELEMENT
{
    DWORD       dwPermanentID;
    DWORD       dwDeviceID;

} PERMANENTIDELEMENT, *PPERMANENTIDELEMENT;


typedef struct _PERMANENTIDARRAYHEADER
{
    LONG                    lCookie;
    DWORD                   dwPermanentProviderID;
    PPERMANENTIDELEMENT     pLineElements;
    DWORD                   dwNumLines;
    DWORD                   dwCurrentLines;
    PPERMANENTIDELEMENT     pPhoneElements;
    DWORD                   dwNumPhones;
    DWORD                   dwCurrentPhones;
    struct _PERMANENTIDARRAYHEADER *pNext;

} PERMANENTIDARRAYHEADER, *PPERMANENTIDARRAYHEADER;


typedef struct _PRILISTSTRUCT
{
    DWORD   dwMediaModes;
    LPWSTR  pszPriList;

} PRILISTSTRUCT, *PPRILISTSTRUCT;


#ifdef __TAPI_DEBUG_CS__

#define DEBUG_CS_FILENAME_LEN       16

typedef struct _DEBUG_CS_CODEPATH
{
    char    szSourceFile[ DEBUG_CS_FILENAME_LEN ];
    DWORD   dwSourceLine;
    DWORD   dwThreadId;

} DEBUG_CS_CODEPATH;

typedef struct _DEBUG_CS_CRITICAL_SECTION
{
    CRITICAL_SECTION    CriticalSection;
    DEBUG_CS_CODEPATH   LastEnter;
    DEBUG_CS_CODEPATH   LastLeave;

} DEBUG_CS_CRITICAL_SECTION, *PDEBUG_CS_CRITICAL_SECTION;

#define TapiInitializeCriticalSection(a)                    \
    ZeroMemory((a), sizeof(DEBUG_CS_CRITICAL_SECTION));     \
    InitializeCriticalSection(&((a)->CriticalSection));         

#define TapiInitializeCriticalSectionAndSpinCount(a, b)     \
    (ZeroMemory((a), sizeof(DEBUG_CS_CRITICAL_SECTION)),    \
    InitializeCriticalSectionAndSpinCount(&((a)->CriticalSection), b))         

#define TapiMyInitializeCriticalSection(a, b)               \
    (ZeroMemory((a), sizeof(DEBUG_CS_CRITICAL_SECTION)),    \
    MyInitializeCriticalSection(&((a)->CriticalSection), b))

#define TapiDeleteCriticalSection(a)                        \
    DeleteCriticalSection(&((a)->CriticalSection));

#define TapiEnterCriticalSection(a)                         \
    EnterCriticalSection(&((a)->CriticalSection));          \
    (a)->LastEnter.dwSourceLine = __LINE__;                 \
    (a)->LastEnter.dwThreadId = GetCurrentThreadId( );      \
    strcpy(                                                 \
        (a)->LastEnter.szSourceFile,                        \
        (strlen(__FILE__) < DEBUG_CS_FILENAME_LEN)?         \
        (__FILE__) : (__FILE__ + (strlen(__FILE__) + 1 - DEBUG_CS_FILENAME_LEN) ));

#define TapiLeaveCriticalSection(a)                         \
    (a)->LastLeave.dwSourceLine = __LINE__;                 \
    (a)->LastLeave.dwThreadId = GetCurrentThreadId( );      \
    strcpy(                                                 \
        (a)->LastLeave.szSourceFile,                        \
        (strlen(__FILE__) < DEBUG_CS_FILENAME_LEN)?         \
        (__FILE__) : (__FILE__ + (strlen(__FILE__) + 1 - DEBUG_CS_FILENAME_LEN) )); \
    LeaveCriticalSection(&((a)->CriticalSection));

#else // #ifdef __TAPI_DEBUG_CS__

#define TapiInitializeCriticalSection(a)                    \
    InitializeCriticalSection(a);         

#define TapiInitializeCriticalSectionAndSpinCount(a, b)     \
    InitializeCriticalSectionAndSpinCount(a, b)         

#define TapiMyInitializeCriticalSection(a, b)               \
    MyInitializeCriticalSection(a, b)

#define TapiDeleteCriticalSection(a)                        \
    DeleteCriticalSection(a);

#define TapiEnterCriticalSection(a)                         \
    EnterCriticalSection(a);

#define TapiLeaveCriticalSection(a)                         \
    LeaveCriticalSection(a);

#endif // #ifdef __TAPI_DEBUG_CS__

typedef struct _TAPIGLOBALS
{
    HINSTANCE               hinstDll;
    HICON                   hLineIcon;
    HICON                   hPhoneIcon;
    HANDLE                  hProcess;

#define TAPIGLOBALS_REINIT      (0x00000001)
#define TAPIGLOBALS_SERVER      (0x00000002)
#define TAPIGLOBALS_PAUSED      (0x00000004)

    DWORD                   dwFlags;
    PTCLIENT                ptClients;
    PTPROVIDER              ptProviders;
    DWORD                   dwNumLineInits;

    DWORD                   dwNumLines;
    PTLINELOOKUPTABLE       pLineLookup;
    DWORD                   dwNumPhoneInits;
    DWORD                   dwNumPhones;

    PTPHONELOOKUPTABLE      pPhoneLookup;
    PTREQUESTRECIPIENT      pRequestRecipients;
    PTREQUESTRECIPIENT      pHighestPriorityRequestRecipient;
    PTREQUESTMAKECALL       pRequestMakeCallList;

    PTREQUESTMAKECALL       pRequestMakeCallListEnd;
    PRILISTSTRUCT *         pPriLists;
    DWORD                   dwUsedPriorityLists;
    DWORD                   dwTotalPriorityLists;

    WCHAR                  *pszReqMakeCallPriList;
    WCHAR                  *pszReqMediaCallPriList;
    DWORD                   dwComputerNameSize;
    WCHAR                  *pszComputerName;

    SERVICE_STATUS_HANDLE   sshStatusHandle;
#if TELE_SERVER
    PTMANAGEDLLINFO         pMapperDll;
    PTMANAGEDLLLISTHEADER   pManageDllList;
    PPERMANENTIDARRAYHEADER pIDArrays;
#endif

    ULONG64                 ulPermMasks;

#ifdef __TAPI_DEBUG_CS__
    DEBUG_CS_CRITICAL_SECTION CritSec;
#else
    CRITICAL_SECTION        CritSec;
#endif

    CRITICAL_SECTION        RemoteSPCritSec;

} TAPIGLOBALS, *PTAPIGLOBALS;

typedef struct _GETEVENTS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwTotalBufferSize;
    };

    union
    {
        OUT DWORD       dwNeededBufferSize;
    };

    union
    {
        OUT DWORD       dwUsedBufferSize;
    };

} GETEVENTS_PARAMS, *PGETEVENTS_PARAMS;


typedef struct _GETUIDLLNAME_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwObjectID;
    };

    union
    {
        IN  DWORD       dwObjectType;
    };

    union
    {
        OUT DWORD       dwUIDllNameOffset;
    };

    union
    {
        IN OUT DWORD    dwUIDllNameSize;
    };


    //
    // The following fields used only for providerConfig, -Install, & -Remove
    //

    union
    {
        IN  DWORD       dwProviderFilenameOffset;
    };

    union
    {
        IN  DWORD       bRemoveProvider;
    };

    OUT HTAPIDIALOGINSTANCE htDlgInst;

} GETUIDLLNAME_PARAMS, *PGETUIDLLNAME_PARAMS;


typedef struct _UIDLLCALLBACK_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    IN  DWORD           ObjectID;

    union
    {
        IN  DWORD       dwObjectType;
    };

    union
    {
        IN  DWORD       dwParamsInOffset;
    };

    union
    {
        IN  DWORD       dwParamsInSize;
    };

    union
    {
        OUT DWORD       dwParamsOutOffset;
    };

    union
    {
        IN OUT DWORD    dwParamsOutSize;
    };

} UIDLLCALLBACK_PARAMS, *PUIDLLCALLBACK_PARAMS;


typedef struct _FREEDIALOGINSTANCE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;


    union
    {
        IN  HTAPIDIALOGINSTANCE htDlgInst;
    };

    union
    {
        IN  LONG        lUIDllResult;
    };

} FREEDIALOGINSTANCE_PARAMS, *PFREEDIALOGINSTANCE_PARAMS;


typedef struct _PROXYREQUESTWRAPPER
{
    ASYNCEVENTMSG           AsyncEventMsg;

    LINEPROXYREQUEST        ProxyRequest;

} PROXYREQUESTWRAPPER, *PPROXYREQUESTWRAPPER;


typedef struct _PRIVATEFACTORYIDENTIFY_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        OUT DWORD       dwCLSIDOffset;
    };

    union
    {
        IN OUT DWORD    dwCLSIDSize;
    };

} PRIVATEFACTORYIDENTIFY_PARAMS, *PPRIVATEFACTORYIDENTIFY_PARAMS;




#if DBG

    #define DBGOUT(arg) DbgPrt arg

    VOID
    DbgPrt(
        IN DWORD  dwDbgLevel,
        IN PUCHAR DbgMessage,
        IN ...
        );

	#define ASSERT(exp) if(!(exp)) { DbgPrt(0, "ASSERT : File : %s; Line : %d\n", __FILE__, __LINE__) ;}

typedef struct _MYMEMINFO
{
    //
    // The dwDummy field at the top of this struct is there because on
    // x86 the heap mgr seems to trash this field when you free the
    // block (uses it as a list entry pointer or some such).  We'd like
    // to see the line/file info preserved in hopes of getting more
    // clues when debugging.
    //

    DWORD               dwDummy;
    DWORD               dwLine;
    PSTR                pszFile;

} MYMEMINFO, *PMYMEMINFO;

#else

    #define DBGOUT(arg)
    #define ASSERT(exp)

#endif



#if DBG

#define ServerAlloc( __size__ ) ServerAllocReal( __size__, __LINE__, __FILE__ )

LPVOID
WINAPI
ServerAllocReal(
    DWORD dwSize,
    DWORD dwLine,
    PSTR  pszFile
    );

#else

#define ServerAlloc( __size__ ) ServerAllocReal( __size__ )

LPVOID
WINAPI
ServerAllocReal(
    DWORD dwSize
    );

#endif

VOID
WINAPI
ServerFree(
    LPVOID  lp
    );

#if DBG

#define MyCreateMutex() MyRealCreateMutex(__FILE__, __LINE__)
HANDLE
MyRealCreateMutex(PSTR pFile, DWORD dwLine);

#else

#define MyCreateMutex() MyRealCreateMutex()
HANDLE
MyRealCreateMutex(
    void
    );

#endif

void
MyCloseMutex(
    HANDLE hMutex
    );

BOOL
PASCAL
MyDuplicateHandle(
    HANDLE      hSource,
    LPHANDLE    phTarget
    );

VOID
CALLBACK
CompletionProc(
    PASYNCREQUESTINFO   pAsyncRequestInfo,
    LONG                lResult
    );

BOOL
WaitForMutex(
    HANDLE      hMutex,
    HANDLE     *phMutex,
    BOOL       *pbCloseMutex,
    LPVOID      pWidget,
    DWORD       dwKey,
    DWORD       dwTimeout
    );

void
MyReleaseMutex(
    HANDLE  hMutex,
    BOOL    bCloseMutex
    );

LONG
PASCAL
DestroytLineApp(
    HLINEAPP    hLineApp
    );

LONG
DestroytPhoneApp(
    HPHONEAPP   hPhoneApp
    );

LONG
ServerInit(
    BOOL fReinit
    );

LONG
ServerShutdown(
    void
    );

void
WriteEventBuffer(
    PTCLIENT        ptClient,
    PASYNCEVENTMSG  pMsg
    );

BOOL
PASCAL
QueueSPEvent(
    PSPEVENT    pSPEvent
    );

VOID
QueueStaleObject(
    LPVOID  pObjectToQueue
    );

#if DBG

#define SP_FUNC_SYNC  0
#define SP_FUNC_ASYNC 1

LONG
WINAPI
CallSP1(
    TSPIPROC    pfn,
    LPCSTR      lpszFuncName,
    DWORD       dwFlags,
    ULONG_PTR   Arg1
    );

LONG
WINAPI
CallSP2(
    TSPIPROC    pfn,
    LPCSTR      lpszFuncName,
    DWORD       dwFlags,
    ULONG_PTR   Arg1,
    ULONG_PTR   Arg2
    );

LONG
WINAPI
CallSP3(
    TSPIPROC    pfn,
    LPCSTR      lpszFuncName,
    DWORD       dwFlags,
    ULONG_PTR   Arg1,
    ULONG_PTR   Arg2,
    ULONG_PTR   Arg3
    );

LONG
WINAPI
CallSP4(
    TSPIPROC    pfn,
    LPCSTR      lpszFuncName,
    DWORD       dwFlags,
    ULONG_PTR   Arg1,
    ULONG_PTR   Arg2,
    ULONG_PTR   Arg3,
    ULONG_PTR   Arg4
    );

LONG
WINAPI
CallSP5(
    TSPIPROC    pfn,
    LPCSTR      lpszFuncName,
    DWORD       dwFlags,
    ULONG_PTR   Arg1,
    ULONG_PTR   Arg2,
    ULONG_PTR   Arg3,
    ULONG_PTR   Arg4,
    ULONG_PTR   Arg5
    );

LONG
WINAPI
CallSP6(
    TSPIPROC    pfn,
    LPCSTR      lpszFuncName,
    DWORD       dwFlags,
    ULONG_PTR   Arg1,
    ULONG_PTR   Arg2,
    ULONG_PTR   Arg3,
    ULONG_PTR   Arg4,
    ULONG_PTR   Arg5,
    ULONG_PTR   Arg6
    );

LONG
WINAPI
CallSP7(
    TSPIPROC    pfn,
    LPCSTR      lpszFuncName,
    DWORD       dwFlags,
    ULONG_PTR   Arg1,
    ULONG_PTR   Arg2,
    ULONG_PTR   Arg3,
    ULONG_PTR   Arg4,
    ULONG_PTR   Arg5,
    ULONG_PTR   Arg6,
    ULONG_PTR   Arg7
    );

LONG
WINAPI
CallSP8(
    TSPIPROC    pfn,
    LPCSTR      lpszFuncName,
    DWORD       dwFlags,
    ULONG_PTR   Arg1,
    ULONG_PTR   Arg2,
    ULONG_PTR   Arg3,
    ULONG_PTR   Arg4,
    ULONG_PTR   Arg5,
    ULONG_PTR   Arg6,
    ULONG_PTR   Arg7,
    ULONG_PTR   Arg8
    );

LONG
WINAPI
CallSP9(
    TSPIPROC    pfn,
    LPCSTR      lpszFuncName,
    DWORD       dwFlags,
    ULONG_PTR   Arg1,
    ULONG_PTR   Arg2,
    ULONG_PTR   Arg3,
    ULONG_PTR   Arg4,
    ULONG_PTR   Arg5,
    ULONG_PTR   Arg6,
    ULONG_PTR   Arg7,
    ULONG_PTR   Arg8,
    ULONG_PTR   Arg9
    );

LONG
WINAPI
CallSP12(
    TSPIPROC    pfn,
    LPCSTR      lpszFuncName,
    DWORD       dwFlags,
    ULONG_PTR   Arg1,
    ULONG_PTR   Arg2,
    ULONG_PTR   Arg3,
    ULONG_PTR   Arg4,
    ULONG_PTR   Arg5,
    ULONG_PTR   Arg6,
    ULONG_PTR   Arg7,
    ULONG_PTR   Arg8,
    ULONG_PTR   Arg9,
    ULONG_PTR   Arg10,
    ULONG_PTR   Arg11,
    ULONG_PTR   Arg12
    );


#else

#define CallSP1(pfn,nm,fl,a1)                   ((*pfn)(a1))
#define CallSP2(pfn,nm,fl,a1,a2)                ((*pfn)(a1,a2))
#define CallSP3(pfn,nm,fl,a1,a2,a3)             ((*pfn)(a1,a2,a3))
#define CallSP4(pfn,nm,fl,a1,a2,a3,a4)          ((*pfn)(a1,a2,a3,a4))
#define CallSP5(pfn,nm,fl,a1,a2,a3,a4,a5)       ((*pfn)(a1,a2,a3,a4,a5))
#define CallSP6(pfn,nm,fl,a1,a2,a3,a4,a5,a6)    ((*pfn)(a1,a2,a3,a4,a5,a6))
#define CallSP7(pfn,nm,fl,a1,a2,a3,a4,a5,a6,a7) ((*pfn)(a1,a2,a3,a4,a5,a6,a7))
#define CallSP8(pfn,nm,fl,a1,a2,a3,a4,a5,a6,a7,a8) \
                ((*pfn)(a1,a2,a3,a4,a5,a6,a7,a8))
#define CallSP9(pfn,nm,fl,a1,a2,a3,a4,a5,a6,a7,a8,a9) \
                ((*pfn)(a1,a2,a3,a4,a5,a6,a7,a8,a9))
#define CallSP12(pfn,nm,fl,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12) \
                ((*pfn)(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12))

#endif


#if DBG

BOOL
IsBadSizeOffset(
    DWORD dwTotalSize,
    DWORD dwFixedSize,
    DWORD dwXxxSize,
    DWORD dwXxxOffset,
    DWORD dwAlignMask,
    char *pszCallingFunc,
    char *pszFieldName
    );

#define ISBADSIZEOFFSET(a1,a2,a3,a4,a5,a6,a7) IsBadSizeOffset(a1,a2,a3,a4,a5,a6,a7)

#else

BOOL
IsBadSizeOffset(
    DWORD dwTotalSize,
    DWORD dwFixedSize,
    DWORD dwXxxSize,
    DWORD dwXxxOffset,
    DWORD dwAlignMask
    );

#define ISBADSIZEOFFSET(a1,a2,a3,a4,a5,a6,a7) IsBadSizeOffset(a1,a2,a3,a4,a5)

#endif

BOOL
IsBadStringParam(
    DWORD   dwParamsBufferSize,
    LPBYTE  pDataBuf,
    DWORD   dwStringOffset
    );

#define MAP_HANDLE_TO_SP_EVENT_QUEUE_ID(h) (h % gdwNumSPEventHandlerThreads)

#if DBG

#define DWORD_CAST(v,f,l) (((v)>MAXDWORD)?(DbgPrt(0,"DWORD_CAST: information will be lost during cast from %p in file %s, line %d",(v),(f),(l)), DebugBreak(),((DWORD)(v))):((DWORD)(v)))

#else
#define DWORD_CAST(v,f,l)   (DWORD)(v)
#endif //DBG

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\inc\tapiqc.h ===
#ifndef __tapiqc_h__
#define __tapiqc_h__

#if !defined(STREAM_INTERFACES_DEFINED)

/*****************************************************************************
 *  @doc INTERNAL CTAPISTRUCTENUM
 *
 *  @enum TAPIControlFlags | The <t TAPIControlFlags> enum is used to qualify
 *    if a control property can be set manually and/or automatically.
 *
 *  @emem TAPIControl_Flags_None | Specifies that a control property does not
 *    have any control flag. This is typical of read-only properties.
 *
 *  @emem TAPIControl_Flags_Manual | Specifies that a control property can be
 *    modified manually.
 *
 *  @emem TAPIControl_Flags_Auto | Specifies that a control property can be
 *    modified automatically.
 ****************************************************************************/
typedef enum tagTAPIControlFlags
{
	TAPIControl_Flags_None		= 0,
	TAPIControl_Flags_Auto		= 0x1,
	TAPIControl_Flags_Manual	= 0x2
}	TAPIControlFlags;
#endif

#ifdef USE_NETWORK_STATISTICS
/*****************************************************************************
 *  @doc INTERNAL CNETSTATSSTRUCTENUM
 *
 *  @struct CHANNELERRORS_S | The <t CHANNELERRORS_S> structure is used
 *    to set and retrieve the value of channel errors.
 *
 *  @field DWORD | dwRandomBitErrorRate | Specifies the random bit error rate
 *    of the channel in multiples of 10-6.
 *
 *  @field DWORD | dwBurstErrorDuration | Specifies the duration for short
 *    burst errors in ms.
 *
 *  @field DWORD | dwBurstErrorMaxFrequency | Specifies the maximum
 *    frequency for short burst errors in Hz.
 ***************************************************************************/
typedef struct {
	DWORD dwRandomBitErrorRate;
	DWORD dwBurstErrorDuration;
	DWORD dwBurstErrorMaxFrequency;
} CHANNELERRORS_S;

/*****************************************************************************
 *  @doc INTERNAL CNETSTATSSTRUCTENUM
 *
 *  @struct KSCHANNELERRORS_LIST_S | The <t KSCHANNELERRORS_LIST_S> structure is used
 *    to set and retrieve the value of channel errors.
 *
 *  @field KSPROPERTY_DESCRIPTION | PropertyDescription | Specifies access
 *    flags (KSPROPERTY_TYPE_GET and KSPROPERTY_TYPE_SET), the inclusive
 *    size of the entire values information, the property value type
 *    information, and the number of members lists that would typically
 *    follow the structure.
 *
 *  @field KSPROPERTY_MEMBERSHEADER | MembersHeader | Used to provide
 *    information on a property member header.
 *
 *  @field KSPROPERTY_STEPPING_LONG | SteppingRandomBitErrorRate | Used to
 *    specify stepping values for random bit error rate.
 *
 *  @field LONG | DefaultRandomBitErrorRate | Used to specify default
 *    values for random bit error rate.
 *
 *  @field KSPROPERTY_STEPPING_LONG | SteppingBurstErrorDuration | Used to
 *    specify stepping values for short burst errors.
 *
 *  @field LONG | DefaultBurstErrorDuration | Used to specify default values
 *    for short burst errors.
 *
 *  @field KSPROPERTY_STEPPING_LONG | SteppingBurstErrorMaxFrequency | Used
 *    to specify stepping values for the maximum frequency for short burst errors.
 *
 *  @field LONG | DefaultBurstErrorMaxFrequency | Used to specify default
 *    values for the maximum frequency for short burst errors.
 ***************************************************************************/
typedef struct {
	KSPROPERTY_DESCRIPTION   PropertyDescription;
	KSPROPERTY_MEMBERSHEADER MembersHeader;
	union {
		KSPROPERTY_STEPPING_LONG SteppingRandomBitErrorRate;
		LONG DefaultRandomBitErrorRate;
	};
	union {
		KSPROPERTY_STEPPING_LONG SteppingBurstErrorDuration;
		LONG DefaultBurstErrorDuration;
	};
	union {
		KSPROPERTY_STEPPING_LONG SteppingBurstErrorMaxFrequency;
		LONG DefaultBurstErrorMaxFrequency;
	};
} KSCHANNELERRORS_LIST_S;

// Network statistics interface
interface DECLSPEC_UUID("e4b248f9-fbb0-4056-a0e6-316b8580b957") INetworkStats : public IUnknown
{
	public:
	virtual STDMETHODIMP SetChannelErrors(IN CHANNELERRORS_S *pChannelErrors, IN DWORD dwLayerId) PURE;
	virtual STDMETHODIMP GetChannelErrors(OUT CHANNELERRORS_S *pChannelErrors, IN WORD dwLayerId) PURE;
	virtual STDMETHODIMP GetChannelErrorsRange(OUT CHANNELERRORS_S *pMin, OUT CHANNELERRORS_S *pMax, OUT CHANNELERRORS_S *pSteppingDelta, OUT CHANNELERRORS_S *pDefault, IN DWORD dwLayerId) PURE;
	virtual STDMETHODIMP SetPacketLossRate(IN DWORD dwPacketLossRate, IN DWORD dwLayerId) PURE;
	virtual STDMETHODIMP GetPacketLossRate(OUT LPDWORD pdwPacketLossRate, IN DWORD dwLayerId) PURE;
	virtual STDMETHODIMP GetPacketLossRateRange(OUT LPDWORD pdwMin, OUT LPDWORD pdwMax, OUT LPDWORD pdwSteppingDelta, OUT LPDWORD pdwDefault, IN DWORD dwLayerId) PURE;
};

// Our filter's default values
// @todo For accelerators, don't use those values
#endif

/*****************************************************************************
 *  @doc INTERNAL CFPSCSTRUCTENUM
 *
 *  @enum FrameRateControlProperty | The <t FrameRateControlProperty> enum is used
 *    to identify specific frame rate control settings.
 *
 *  @emem FrameRateControl_Maximum | Specifies the maximum frame rate not
 *    to be exceeded.
 *
 *  @emem FrameRateControl_Current | Specifies the current frame rate.
 ****************************************************************************/
typedef enum tagFrameRateControlProperty
{
	FrameRateControl_Maximum,
	FrameRateControl_Current	// Read-Only
}	FrameRateControlProperty;

// Frame rate control interface (pin interface)
interface DECLSPEC_UUID("c2bb17e3-ee63-4d54-821b-1c8cb5287087") IFrameRateControl : public IUnknown
{
	public:
	virtual STDMETHODIMP GetRange(IN FrameRateControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags) PURE;
	virtual STDMETHODIMP Set(IN FrameRateControlProperty Property, IN long lValue, IN TAPIControlFlags lFlags) PURE;
	virtual STDMETHODIMP Get(IN FrameRateControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags) PURE;
};

#ifdef USE_CPU_CONTROL
/*****************************************************************************
 *  @doc INTERNAL CCPUCSTRUCTENUM
 *
 *  @enum CPUControlProperty | The <t CPUControlProperty> enum is used
 *    to identify specific CPU control settings.
 *
 *  @emem CPUControl_MaxCPULoad | Specifies the maximum CPU load not to be
 *    exceeded.
 *
 *  @emem CPUControl_CurrentCPULoad | Specifies the current CPU load.
 *
 *  @emem CPUControl_MaxProcessingTime | Specifies the maximum processing
 *    time not to be exceeded.
 *
 *  @emem CPUControl_CurrentProcessingTime | Specifies the current processing
 *    time.
 ****************************************************************************/
typedef enum tagCPUControlProperty
{
	CPUControl_MaxCPULoad,
	CPUControl_CurrentCPULoad,			// Read-Only
	CPUControl_MaxProcessingTime,
	CPUControl_CurrentProcessingTime	// Read-Only
}	CPUControlProperty;

// CPU control interface (pin interface)
interface DECLSPEC_UUID("3808c526-de63-48da-a0c6-7792dcbbff82") ICPUControl : public IUnknown
{
	public:
	virtual STDMETHODIMP GetRange(IN CPUControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags) PURE;
	virtual STDMETHODIMP Set(IN CPUControlProperty Property, IN long lValue, IN TAPIControlFlags lFlags) PURE;
	virtual STDMETHODIMP Get(IN CPUControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags) PURE;
};
#endif

/*****************************************************************************
 *  @doc INTERNAL CBPSCSTRUCTENUM
 *
 *  @enum BitrateControlProperty | The <t BitrateControlProperty> enum is used
 *    to identify specific bitrate control settings.
 *
 *  @emem BitrateControl_Maximum | Specifies the maximum bitrate not to be
 *    exceeded.
 *
 *  @emem BitrateControl_Current | Specifies the current bitrate.
 ****************************************************************************/
typedef enum tagBitrateControlProperty
{
	BitrateControl_Maximum,
	BitrateControl_Current	// Read-Only
}	BitrateControlProperty;

// Bitrate control interface (pin interface)
interface DECLSPEC_UUID("46a1a0d7-261e-4839-80e7-8a6333466cc7") IBitrateControl : public IUnknown
{
	public:
	virtual STDMETHODIMP GetRange(IN BitrateControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags, IN DWORD dwLayerId) PURE;
	virtual STDMETHODIMP Set(IN BitrateControlProperty Property, IN long lValue, IN TAPIControlFlags lFlags, IN DWORD dwLayerId) PURE;
	virtual STDMETHODIMP Get(IN BitrateControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags, IN DWORD dwLayerId) PURE;
};

#endif // __tapiqc_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\inc\tapievt.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    tapievt.h

Abstract:

    Header file for tapi server event filtering

Author:

    Xiaohai Zhang (xzhang)    15-Oct-1999

Revision History:

--*/

#ifndef __TAPIEVT_H__
#define __TAPIEVT_H__

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//
//  Event filtering private APIs
//

LONG 
WINAPI 
tapiSetEventFilterMasks (
    DWORD           dwObjType,
    LONG_PTR        lObjectID,
    ULONG64         ulEventMasks
);

LONG 
WINAPI 
tapiSetEventFilterSubMasks (
    DWORD           dwObjType,
    LONG_PTR        lObjectID,
    ULONG64         ulEventMask,
    DWORD			dwEventSubMasks
);

LONG
WINAPI
tapiGetEventFilterMasks (
    DWORD           dwObjType,
    LONG_PTR        lObjectID,
    ULONG64 *       pulEventMasks
);

LONG
WINAPI
tapiGetEventFilterSubMasks (
    DWORD           dwObjType,
    LONG_PTR        lObjectID,
    ULONG64         ulEventMask,
    DWORD *			pdwEventSubMasks
);

LONG
WINAPI
tapiSetPermissibleMasks (
    ULONG64              ulPermMasks
);

LONG
WINAPI
tapiGetPermissibleMasks (
    ULONG64              * pulPermMasks
);

//
//  Object type constants 
//
//      object type defines the scope of the event filtering
//  i.e. EM_LINE_CALLINFO applied on TAPIOBJ_HCALL enable/disables the 
//  LINE_CALLINFO message for the particular hCall object, while 
//  EM_LINE_CALLINFO applied on TAPIOBJ_NULL enable/disables LINE_CALLINFO 
//  message for all existing and future call objects.
//

#define TAPIOBJ_NULL			0	// lObjectID is ignored, apply globally
#define TAPIOBJ_HLINEAPP		1	// lObjectID is of type HLINEAPP
#define TAPIOBJ_HLINE			2	// lObjectID is of type HLINE
#define TAPIOBJ_HCALL			3	// lObjectID is of type HCALL
#define TAPIOBJ_HPHONEAPP		4	// lObjectID is of type HPHONEAPP
#define TAPIOBJ_HPHONE			5	// lObjectID is of type HPHONE

//
//	Tapi server event filter masks
//
//      Event filter mask should be used with their submasks if exists,
//  Many of the event filter masks have their corresponding sub masks
//  defined in tapi.h. i.e. EM_LINE_CALLSTATE owns all the submasks of
//  LINECALLSTATE_constants
//

#define EM_LINE_ADDRESSSTATE        0x00000001	
#define EM_LINE_LINEDEVSTATE        0x00000002
#define EM_LINE_CALLINFO            0x00000004
#define EM_LINE_CALLSTATE           0x00000008
#define EM_LINE_APPNEWCALL          0x00000010
#define EM_LINE_CREATE              0x00000020
#define EM_LINE_REMOVE              0x00000040
#define EM_LINE_CLOSE               0x00000080
#define EM_LINE_PROXYREQUEST        0x00000100
#define EM_LINE_DEVSPECIFIC         0x00000200
#define EM_LINE_DEVSPECIFICFEATURE  0x00000400
#define EM_LINE_AGENTSTATUS         0x00000800
#define EM_LINE_AGENTSTATUSEX       0x00001000
#define EM_LINE_AGENTSPECIFIC       0x00002000
#define EM_LINE_AGENTSESSIONSTATUS  0x00004000
#define EM_LINE_QUEUESTATUS         0x00008000
#define EM_LINE_GROUPSTATUS         0x00010000
#define EM_LINE_PROXYSTATUS         0x00020000
#define EM_LINE_APPNEWCALLHUB       0x00040000
#define EM_LINE_CALLHUBCLOSE        0x00080000
#define EM_LINE_DEVSPECIFICEX       0x00100000
#define EM_LINE_QOSINFO             0x00200000
// LINE_GATHERDIGITS is controlled by lineGatherDigits
// LINE_GENERATE is controlled by lineGenerateDigits
// LINE_MONITORDIGITS is controlled by lineMonitorDigits
// LINE_MONITORMEDIA is controlled by lineMonitorMedia
// LINE_MONITORTONE is controlled by lineMonitorTone
// LINE_REQUEST is controlled by lineRegisterRequestRecipient
// LINE_REPLY can not be disabled.

#define EM_PHONE_CREATE             0x01000000
#define EM_PHONE_REMOVE             0x02000000
#define EM_PHONE_CLOSE              0x04000000
#define EM_PHONE_STATE              0x08000000
#define EM_PHONE_DEVSPECIFIC        0x10000000
#define EM_PHONE_BUTTONMODE         0x20000000
#define EM_PHONE_BUTTONSTATE        0x40000000
// PHONE_REPLY can not be disabled

#define EM_ALL						0x7fffffff
#define EM_NUM_MASKS                31

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif      // tapievt.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\inc\tapiperf.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects
  
  

Copyright (c) 1992 Microsoft Corporation

Module Name:

      datatapi.h

Abstract:

    Header file for the TAPI Extensible Object data definitions

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various driver API calls is placed into the structures shown
    here.

--*/

#ifndef _TAPIPERF_H_
#define _TAPIPERF_H_

#include <winperf.h>
//
//  The routines that load these structures assume that all fields
//  are packed and aligned on DWORD boundaries. Alpha support may 
//  change this assumption so the pack pragma is used here to insure
//  the DWORD packing assumption remains valid.
//
#pragma pack (4)

//
//  Extensible Object definitions
//

//  Update the following sort of define when adding an object type.

#define TAPI_NUM_PERF_OBJECT_TYPES 1


//
//  TAPI Resource object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
  

#define LINES_OFFSET                                                 sizeof(DWORD)
#define PHONES_OFFSET                   LINES_OFFSET               + sizeof(DWORD)
#define LINESINUSE_OFFSET               PHONES_OFFSET              + sizeof(DWORD)
#define PHONESINUSE_OFFSET              LINESINUSE_OFFSET          + sizeof(DWORD)
#define TOTALOUTGOINGCALLS_OFFSET       PHONESINUSE_OFFSET         + sizeof(DWORD)
#define TOTALINCOMINGCALLS_OFFSET       TOTALOUTGOINGCALLS_OFFSET  + sizeof(DWORD)
#define CLIENTAPPS_OFFSET               TOTALINCOMINGCALLS_OFFSET  + sizeof(DWORD)
#define ACTIVEOUTGOINGCALLS_OFFSET      CLIENTAPPS_OFFSET          + sizeof(DWORD)
#define ACTIVEINCOMINGCALLS_OFFSET      ACTIVEOUTGOINGCALLS_OFFSET + sizeof(DWORD)
//#define SIZE_OF_TAPI_PERFORMANCE_DATA   32
#define SIZE_OF_TAPI_PERFORMANCE_DATA   40


//
//  This is the counter structure presently returned by TAPI.
//

typedef struct _TAPI_DATA_DEFINITION 
{
    PERF_OBJECT_TYPE            TapiObjectType;
    PERF_COUNTER_DEFINITION     Lines;
    PERF_COUNTER_DEFINITION     Phones;
    PERF_COUNTER_DEFINITION     LinesInUse;
    PERF_COUNTER_DEFINITION     PhonesInUse;
    PERF_COUNTER_DEFINITION     TotalOutgoingCalls;
    PERF_COUNTER_DEFINITION     TotalIncomingCalls;
    PERF_COUNTER_DEFINITION     ClientApps;
    PERF_COUNTER_DEFINITION     CurrentOutgoingCalls;
    PERF_COUNTER_DEFINITION     CurrentIncomingCalls;
} TAPI_DATA_DEFINITION;

typedef struct tagPERFBLOCK
{
    DWORD           dwSize;
    DWORD           dwLines;
    DWORD           dwPhones;
    DWORD           dwLinesInUse;
    DWORD           dwPhonesInUse;
    DWORD           dwTotalOutgoingCalls;
    DWORD           dwTotalIncomingCalls;
    DWORD           dwClientApps;
    DWORD           dwCurrentOutgoingCalls;
    DWORD           dwCurrentIncomingCalls;
} PERFBLOCK, *PPERFBLOCK;

#pragma pack ()

    

/////////////////////////////////////////////////////////////////
// PERFUTIL header stuff below

// enable this define to log process heap data to the event log
#ifdef PROBE_HEAP_USAGE
#undef PROBE_HEAP_USAGE
#endif
//
  
  
//  Utility macro.  This is used to reserve a DWORD multiple of bytes for Unicode strings 
//  embedded in the definitional data, viz., object instance names.
  
  
//
  
  
#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))
  
  

//    (assumes dword is 4 bytes long and pointer is a dword in size)
  
  
#define ALIGN_ON_DWORD(x) ((VOID *)( ((DWORD) x & 0x00000003) ? ( ((DWORD) x & 0xFFFFFFFC) + 4 ) : ( (DWORD) x ) ))
  
  

extern WCHAR  GLOBAL_STRING[];      // Global command (get all local ctrs)
extern WCHAR  FOREIGN_STRING[];           // get data from foreign computers
extern WCHAR  COSTLY_STRING[];      
  
  
extern WCHAR  NULL_STRING[];
  
  

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

//
  
  
// The definition of the only routine of perfutil.c, It builds part of a performance data 
// instance (PERF_INSTANCE_DEFINITION) as described in winperf.h
  
  
//

HANDLE MonOpenEventLog ();
VOID MonCloseEventLog ();
DWORD GetQueryType (IN LPWSTR);
BOOL IsNumberInUnicodeList (DWORD, LPWSTR);

typedef struct _LOCAL_HEAP_INFO_BLOCK {
    DWORD   AllocatedEntries;
    DWORD   AllocatedBytes;
    DWORD   FreeEntries;
    DWORD   FreeBytes;
} LOCAL_HEAP_INFO, *PLOCAL_HEAP_INFO;


//
//  Memory Probe macro
//
#ifdef PROBE_HEAP_USAGE

#define HEAP_PROBE()    { \
    DWORD   dwHeapStatus[5]; \
    NTSTATUS CallStatus; \
    dwHeapStatus[4] = __LINE__; }
//    if (!(CallStatus = memprobe (dwHeapStatus, 16L, NULL))) { \
//        REPORT_INFORMATION_DATA (TAPI_HEAP_STATUS, LOG_DEBUG,    \
//            &dwHeapStatus, sizeof(dwHeapStatus));  \
//    } else {  \
//        REPORT_ERROR_DATA (TAPI_HEAP_STATUS_ERROR, LOG_DEBUG, \
//            &CallStatus, sizeof (DWORD)); \
//    } \
//}

#else

#define HEAP_PROBE()    ;
  
  

  
  
#endif


#endif //_DATATAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\inc\tapihndl.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1998  Microsoft Corporation

Module Name:

    handle.h

Abstract:

    Public definitions for handle table library

Author:

    Dan Knudson (DanKn)    15-Sep-1998

Revision History:

--*/


typedef VOID (CALLBACK * FREECONTEXTCALLBACK)(LPVOID, LPVOID);


typedef struct _MYCONTEXT
{
    LPVOID              C;

    LPVOID              C2;

} MYCONTEXT, *PMYCONTEXT;


typedef struct _HANDLETABLEENTRY
{
    // NOTE: ListEntry must be 1st field in structure so that we don't
    //       have to use CONTAINING_RECORD macro

    union
    {
        LIST_ENTRY      ListEntry;
        MYCONTEXT       Context;
    };

    DWORD	            Handle;

    union
    {
        DWORD           ReferenceCount;
        DWORD           Instance;
    };

} HANDLETABLEENTRY, *PHANDLETABLEENTRY;


typedef struct _HANDLETABLEHEADER
{
    HANDLE              Heap;
    PHANDLETABLEENTRY   Table;
    DWORD               NumEntries;
    DWORD               HandleBase;

    LIST_ENTRY          FreeList;

    FREECONTEXTCALLBACK FreeContextCallback;

    CRITICAL_SECTION    Lock;

} HANDLETABLEHEADER, *PHANDLETABLEHEADER;


HANDLE
CreateHandleTable(
    HANDLE              Heap,
    FREECONTEXTCALLBACK FreeContextCallback,
    DWORD               MinHandleValue,
    DWORD               MaxHandleValue
    );

VOID
DeleteHandleTable(
    HANDLE      HandleTable
    );

DWORD
NewObject(
    HANDLE      HandleTable,
    LPVOID      Context,
    LPVOID      Context2
    );

LPVOID
ReferenceObject(
    HANDLE      HandleTable,
    DWORD       Handle,
    DWORD       Key
    );

LPVOID
ReferenceObjectEx(
    HANDLE      HandleTable,
    DWORD       Handle,
    DWORD       Key,
    LPVOID      *Context2
    );

VOID
DereferenceObject(
    HANDLE      HandleTable,
    DWORD       Handle,
    DWORD       DereferenceCount
    );

void
ReleaseAllHandles(
    HANDLE      HandleTable,
    PVOID       Context2
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\inc\tapivid.h ===
#ifndef __tapivid_h__
#define __tapivid_h__

#include "h245if.h"
#include "tapiqc.h"

/****************************************************************************
 *  @doc INTERNAL TAPIVID
 *
 *  @module TAPIVid.h | Header file for the new TAPI internal interfaces and
 *    devine enumeration enums and struct, and our filter GUID.
 *
 *  @comm Two interface declaration changes are due to a multiple inheritance
 *    problem: <i IAMCameraControl> and <i IAMVideoProcAmp> interface methods
 *    have identical prototypes. Our Video Capture filter implements both
 *    interfaces.
 ***************************************************************************/

DEFINE_GUID(CLSID_TAPIVideoCapture,
0x70616376L, 0x5245, 0x4945, 0x52, 0x52, 0x45, 0x46, 0x4C, 0x49, 0x48, 0x50);

struct DECLSPEC_UUID("47a39f38-7f0f-4ce0-b788-d76b39fd6a4f") TAPIVideoCapture;
struct DECLSPEC_UUID("145cb377-e7bb-4adf-bd42-a42304717ede") TAPIVideoDecoder;

const WCHAR* const PNAME_PREVIEW = L"Preview";
const WCHAR* const PNAME_CAPTURE = L"Capture";
const WCHAR* const PNAME_RTPPD = L"RtpPd";

/*****************************************************************************
 *  @doc INTERNAL CDEVENUMSTRUCTENUM
 *
 *  @enum DeviceType | The <t DeviceType> enum is used to identify VfW and WDM
 *    device types.
 *
 *  @emem DeviceType_VfW | Specifies a VfW device.
 *
 *  @emem DeviceType_WDM | Specifies a WDM device.
 *
 *  @emem DeviceType_DShow | Specifies unknown DirectShow device (e.g.,
 *    DV camera)
 ****************************************************************************/
typedef enum tagDeviceType
{
        DeviceType_VfW,
        DeviceType_WDM,
        DeviceType_DShow
} DeviceType;

/*****************************************************************************
 *  @doc INTERNAL CDEVENUMSTRUCTENUM
 *
 *  @enum CaptureMode | The <t CaptureMode> enum is used to identify frame
 *    grabbing or streaming mode.
 *
 *  @emem CaptureMode_FrameGrabbing | Specifies frame grabbing mode.
 *
 *  @emem CaptureMode_Streaming | Specifies streaming mode.
 ****************************************************************************/
typedef enum tagCaptureMode
{
        CaptureMode_FrameGrabbing,
        CaptureMode_Streaming
} CaptureMode;

/*****************************************************************************
 * @doc EXTERNAL CONSTANTS
 *
 * @const 4 | MAX_CAPTURE_DEVICES | Maximum number of capture devices.
 *
 * @const MAX_PATH | MAX_CAPDEV_DESCRIPTION | Maximum length of capture
 *   device description string.
 *
 * @const 80 | MAX_CAPDEV_VERSION | Maximum length of capture device version
 *   string.
 ****************************************************************************/
#define MAX_CAPTURE_DEVICES             10
#define MAX_CAPDEV_DESCRIPTION  MAX_PATH
#define MAX_CAPDEV_VERSION              80

/*****************************************************************************
 *  @doc INTERNAL CDEVENUMSTRUCTENUM
 *
 *  @struct VIDEOCAPTUREDEVICEINFO | The <t VIDEOCAPTUREDEVICEINFO> structure is used to store capture
 *    device information.
 *
 *  @field char | szDeviceDescription[] | Specifies the description string of
 *    the capture device.
 *
 *  @field char | szDeviceVersion[] | Specifies the version string of
 *    the capture device.
 *
 *  @field BOOL | fHasOverlay | Specifies the overlay support of the capture
 *    device.
 *
 *  @field BOOL | fInUse | Set to TRUE when a device is being used by an
 *    instance of the capture filter.
 *
 *  @field DeviceType | nDeviceType | Specifies the type (VfW or WDM) of the
 *    capture device.
 *
 *  @field CaptureMode | nCaptureMode | Specifies the capture mode (frame grabbing
 *    or streaming) of the capture device.
 *
 *  @field DWORD | dwVfWIndex | Specifies the VfW index of the capture device.
 ***************************************************************************/
typedef struct tagDEVICEINFO
{
        char            szDeviceDescription[MAX_CAPDEV_DESCRIPTION];
        char            szDeviceVersion[MAX_CAPDEV_VERSION];
        char            szDevicePath[MAX_PATH];
        BOOL            fHasOverlay;
        BOOL            fInUse;
        DeviceType      nDeviceType;
        CaptureMode     nCaptureMode;
        DWORD           dwVfWIndex;
} VIDEOCAPTUREDEVICEINFO, *PDEVICEINFO;

typedef HRESULT (WINAPI *PFNGetCapDeviceInfo)(
    IN DWORD dwDeviceIndex,
    OUT PDEVICEINFO pDeviceInfo
    );

typedef HRESULT (WINAPI *PFNGetNumCapDevices)(
    OUT PDWORD pdwNumDevices
    );

// Video capture device selection/control interface (filter interface)
interface DECLSPEC_UUID("bda95399-48da-4309-af1b-9b8f65f4f9be") IVideoDeviceControl : public IUnknown
{
        public:
        virtual STDMETHODIMP GetNumDevices(OUT PDWORD pdwNumDevices) PURE;
        virtual STDMETHODIMP GetDeviceInfo(IN DWORD dwDeviceIndex, OUT VIDEOCAPTUREDEVICEINFO *pDeviceInfo) PURE;
        virtual STDMETHODIMP GetCurrentDevice(OUT DWORD *pdwDeviceIndex) PURE;
        virtual STDMETHODIMP SetCurrentDevice(IN DWORD dwDeviceIndex) PURE;
};

/*****************************************************************************
 *  @doc INTERNAL CPROCAMPSTRUCTENUM
 *
 *  @enum VideoProcAmpProperty | The <t VideoProcAmpProperty> enum is used to
 *    identify specific video quality settings.
 *
 *  @emem VideoProcAmp_Brightness | Specifies the brightness setting in IRE
 *    units * 100. The range for Value is -10000 to 10000; the default value
 *    is 750 (7.5 IRE).
 *
 *  @emem VideoProcAmp_Contrast | Specifies the contrast or luma gain setting
 *    in gain factor * 100. The Value range is from zero to 10000, and the
 *    default is 100 (1x). Note that a particular video encoder filter may
 *    only implement a subset of this range.
 *
 *  @emem VideoProcAmp_Hue | Specifies the hue setting in degrees * 100. Value
 *    range is from -18000 to 18000 ( -180 to +180 degrees), and the default
 *    is zero. Note that a particular video encoder filter may only implement
 *    a subset of this range.
 *
 *  @emem VideoProcAmp_Saturation | Specifies the saturation or chroma gain
 *    setting in gain * 100. Value ranges from zero to 10000, and the default
 *    is 100 (1x). Note that a particular video encoder filter may only
 *    implement a subset of this range.
 *
 *  @emem VideoProcAmp_Sharpness | Specifies the sharpness setting in
 *    arbitrary units. Value ranges from zero to 100, and the default is 50.
 *    Note that a particular video encoder filter may only implement a subset
 *    of this range.
 *
 *  @emem VideoProcAmp_Gamma | Specifies the gamma setting in gamma * 100.
 *    Value ranges from 1 to 500, and the default is 100 (gamma = 1). Note
 *    that a particular video encoder filter may only implement a subset of
 *    this range.
 *
 *  @emem VideoProcAmp_ColorEnable | Specifies the color enable setting as a
 *    Boolean value. Value ranges from zero to 1, and the default is 1.
 *
 *  @emem VideoProcAmp_WhiteBalance | Specifies the white balance setting
 *    expressed as a color temperature in degrees Kelvin. The range and
 *    default values for this setting are video encoder filter dependent.
 *
 *  @emem VideoProcAmp_BacklightCompensation | Specifies the backlight
 *    compensation setting which is a Boolean. Zero indicates backlight
 *    compensation is disabled, and 1 indicates backlight compensation is
 *    enabled.
 ****************************************************************************/

// IAMVideoProcAmp interface (filter interface)
interface DECLSPEC_UUID("C6E13360-30AC-11d0-A18C-00A0C9118956") IVideoProcAmp : public IUnknown
{
        public:
        virtual STDMETHODIMP GetRange(IN VideoProcAmpProperty Property, OUT long *pMin, OUT long *pMax, OUT long *pSteppingDelta, OUT long *pDefault, OUT TAPIControlFlags *pCapsFlags) PURE;
        virtual STDMETHODIMP Set(IN VideoProcAmpProperty Property, IN long lValue, IN TAPIControlFlags Flags) PURE;
        virtual STDMETHODIMP Get(IN VideoProcAmpProperty Property, OUT long *lValue, OUT TAPIControlFlags *Flags) PURE;
};

/*****************************************************************************
 *  @doc INTERNAL CCAMERACSTRUCTENUM
 *
 *  @enum TAPICameraControlProperty | The <t TAPICameraControlProperty> enum
 *     is used to identify specific camera control settings.
 *
 *  @emem TAPICameraControl_Pan | Specifies the camera pan setting in degrees.
 *    Values range from -180 to +180, and the default is zero. Positive values
 *    are clockwise from the origin (the camera rotates clockwise when viewed
 *    from above), and negative values are counterclockwise from the origin.
 *    Note that a particular video capture filter may only implement a subset
 *    of this range.
 *
 *  @emem TAPICameraControl_Tilt | Specifies the camera tilt setting in degrees.
 *    Values range from -180 to +180, and the default is zero. Positive values
 *    point the imaging plane up, and negative values point the imaging plane
 *    down. Note that a particular video capture filter may only implement a
 *    subset of this range.
 *
 *  @emem TAPICameraControl_Roll | Specifies the roll setting in degrees. Values
 *    range from -180 to +180, and the default is zero. Positive values cause
 *    a clockwise rotation of the camera along the image viewing axis, and
 *    negative values cause a counterclockwise rotation of the camera. Note
 *    that a particular video capture filter may only implement a subset of
 *    this range.
 *
 *  @emem TAPICameraControl_Zoom | Specifies the zoom setting in millimeter units.
 *    Values range from 10 to 600, and the default is video capture filter
 *    specific.
 *
 *  @emem TAPICameraControl_Exposure | Specifies the exposure setting in seconds
 *    using the following formula. For values less than zero, the exposure
 *    time is 1/2n seconds. For positive values and zero, the exposure time is
 *    2n seconds. Note that a particular video capture filter may only
 *    implement a subset of this range.
 *
 *  @emem TAPICameraControl_Iris | Specifies the iris setting expressed as the
 *    fstop * 10.
 *
 *  @emem TAPICameraControl_Focus | Specifies the camera focus setting as the
 *    distance to the optimally focused target in millimeters. The range and
 *    default values are video encoder filter specific. Note that a
 *    particular video capture filter may only implement a subset of this
 *    range.
 *
 *  @emem TAPICameraControl_FlipVertical | Specifies that the picture is
 *    flipped vertically.
 *
 *  @emem TAPICameraControl_FlipHorizontal | Specifies that the picture is
 *    flipped horizontally.
 *
 *  @comm Our software-only implementation provides zoom, pan, tilt, vertical
 *    flip and horizontal flip capabilities.
 ****************************************************************************/

typedef enum tagTAPICameraControlProperty
{
        TAPICameraControl_Pan                           = CameraControl_Pan,
        TAPICameraControl_Tilt                          = CameraControl_Tilt,
        TAPICameraControl_Roll                          = CameraControl_Roll,
        TAPICameraControl_Zoom                          = CameraControl_Zoom,
        TAPICameraControl_Exposure                      = CameraControl_Exposure,
        TAPICameraControl_Iris                          = CameraControl_Iris,
        TAPICameraControl_Focus                         = CameraControl_Focus,
        TAPICameraControl_FlipVertical          = 0x100,
        TAPICameraControl_FlipHorizontal        = 0x200
}       TAPICameraControlProperty;

// ICameraControl interface (filter interface)
interface DECLSPEC_UUID("4cda4f2d-969e-4223-801e-68267395fce4") ICameraControl : public IUnknown
{
        public:
        virtual STDMETHODIMP GetRange(IN TAPICameraControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags) PURE;
        virtual STDMETHODIMP Set(IN TAPICameraControlProperty Property, IN long lValue, IN TAPIControlFlags lFlags) PURE;
        virtual STDMETHODIMP Get(IN TAPICameraControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags) PURE;
};

// IVideoControl interface (pin interface)
interface DECLSPEC_UUID("12345678-30AC-11d0-A18C-00A0C9118956") IVideoControl : public IUnknown
{
        public:
        virtual STDMETHODIMP GetCaps(OUT long *pCapsFlags) PURE;
        virtual STDMETHODIMP SetMode(IN long Mode) PURE;
        virtual STDMETHODIMP GetMode(OUT long *Mode) PURE;
        virtual STDMETHODIMP GetCurrentActualFrameRate(OUT LONGLONG *ActualFrameRate) PURE;
        virtual STDMETHODIMP GetMaxAvailableFrameRate(IN long iIndex, IN SIZE Dimensions, OUT LONGLONG *MaxAvailableFrameRate) PURE;
        virtual STDMETHODIMP GetFrameRateList(IN long iIndex, IN SIZE Dimensions, IN long *ListSize, OUT LONGLONG **FrameRates) PURE;
};

// RTP packetization descriptor control interface (pin interface)
interface DECLSPEC_UUID("f454d51d-dfa4-4f88-ad4a-e64940eba1c0") IRTPPDControl : public IUnknown
{
        public:
        virtual STDMETHODIMP SetMaxRTPPacketSize(IN DWORD dwMaxRTPPacketSize, IN DWORD dwLayerId) PURE;
        virtual STDMETHODIMP GetMaxRTPPacketSize(OUT LPDWORD pdwMaxRTPPacketSize, IN DWORD dwLayerId) PURE;
        virtual STDMETHODIMP GetMaxRTPPacketSizeRange(OUT LPDWORD pdwMin, OUT LPDWORD pdwMax, OUT LPDWORD pdwSteppingDelta, OUT LPDWORD pdwDefault, IN DWORD dwLayerId) PURE;
};

// Interface used to pass down an addrefed pointer to the IH245EncoderCommand interface (pin interface)
interface DECLSPEC_UUID("dcbd33c7-dc65-48f1-8e83-22fdc954a8e7") IOutgoingInterface : public IUnknown
{
        public:
        virtual STDMETHODIMP Set(IN IH245EncoderCommand *pIH245EncoderCommand) PURE;
};

typedef enum tagRTPPayloadHeaderMode
{
        RTPPayloadHeaderMode_Draft = 0,         // 0 = draft payload header (as for older compatibility, like Netmeeting)
        RTPPayloadHeaderMode_RFC2190 = 1        // 1 = standard payload header (as in RFC 2190)
}       RTPPayloadHeaderMode;

// Interface used to switch the above mode in filters (TAPIVCap and TAPIVDec)
interface DECLSPEC_UUID("d884c4e3-41d9-42a6-85c0-7d00658b4a26") IRTPPayloadHeaderMode : public IUnknown
{
        public:
        virtual STDMETHODIMP SetMode(IN RTPPayloadHeaderMode rtpphmMode) PURE;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\inc\tlnklist.h ===
//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\inc\tapimmc.h ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    tapimmc.h

Abstract:

    Definitions & prototypes for TAPI MMC support APIs

Author:

    Dan Knudson (DanKn)    10-Dec-1997

Revision History:


Notes:

--*/


#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#define HMMCAPP   HANDLE
#define LPHMMCAPP LPHANDLE


#define TAPISERVERCONFIGFLAGS_ISSERVER              0x00000001
#define TAPISERVERCONFIGFLAGS_ENABLESERVER          0x00000002
#define TAPISERVERCONFIGFLAGS_SETACCOUNT            0x00000004
#define TAPISERVERCONFIGFLAGS_SETTAPIADMINISTRATORS 0x00000008
#define TAPISERVERCONFIGFLAGS_NOSERVICECONTROL      0x00000010
#define TAPISERVERCONFIGFLAGS_LOCKMMCWRITE          0x00000020
#define TAPISERVERCONFIGFLAGS_UNLOCKMMCWRITE        0x00000040

#define AVAILABLEPROVIDER_INSTALLABLE               0x00000001
#define AVAILABLEPROVIDER_CONFIGURABLE              0x00000002
#define AVAILABLEPROVIDER_REMOVABLE                 0x00000004


typedef struct _DEVICEINFO
{
    DWORD       dwPermanentDeviceID;

    DWORD       dwProviderID;

    DWORD       dwDeviceNameSize;

    DWORD       dwDeviceNameOffset;

    DWORD       dwAddressesSize;        // Valid for line devices only

    DWORD       dwAddressesOffset;      // Valid for line devices only

    DWORD       dwDomainUserNamesSize;

    DWORD       dwDomainUserNamesOffset;

    DWORD       dwFriendlyUserNamesSize;

    DWORD       dwFriendlyUserNamesOffset;

} DEVICEINFO, *LPDEVICEINFO;


typedef struct _DEVICEINFOLIST
{
    DWORD       dwTotalSize;

    DWORD       dwNeededSize;

    DWORD       dwUsedSize;

    DWORD       dwNumDeviceInfoEntries;

    DWORD       dwDeviceInfoSize;

    DWORD       dwDeviceInfoOffset;

} DEVICEINFOLIST, *LPDEVICEINFOLIST;


typedef struct _TAPISERVERCONFIG
{
    DWORD       dwTotalSize;

    DWORD       dwNeededSize;

    DWORD       dwUsedSize;

    DWORD       dwFlags;

    DWORD       dwDomainNameSize;

    DWORD       dwDomainNameOffset;

    DWORD       dwUserNameSize;

    DWORD       dwUserNameOffset;

    DWORD       dwPasswordSize;

    DWORD       dwPasswordOffset;

    DWORD       dwAdministratorsSize;

    DWORD       dwAdministratorsOffset;

} TAPISERVERCONFIG, *LPTAPISERVERCONFIG;


typedef struct _AVAILABLEPROVIDERENTRY
{
    DWORD       dwFileNameSize;

    DWORD       dwFileNameOffset;

    DWORD       dwFriendlyNameSize;

    DWORD       dwFriendlyNameOffset;

    DWORD       dwOptions;

} AVAILABLEPROVIDERENTRY, *LPAVAILABLEPROVIDERENTRY;


typedef struct _AVAILABLEPROVIDERLIST
{
    DWORD       dwTotalSize;

    DWORD       dwNeededSize;

    DWORD       dwUsedSize;

    DWORD       dwNumProviderListEntries;

    DWORD       dwProviderListSize;

    DWORD       dwProviderListOffset;

} AVAILABLEPROVIDERLIST, *LPAVAILABLEPROVIDERLIST;


LONG
WINAPI
MMCAddProvider(
    HMMCAPP             hMmcApp,
    HWND                hwndOwner,
    LPCWSTR             lpszProviderFilename,
    LPDWORD             lpdwProviderID
    );

LONG
WINAPI
MMCConfigProvider(
    HMMCAPP             hMmcApp,
    HWND                hwndOwner,
    DWORD               dwProviderID
    );

LONG
WINAPI
MMCGetAvailableProviders(
    HMMCAPP                 hMmcApp,
    LPAVAILABLEPROVIDERLIST lpProviderList
    );

LONG
WINAPI
MMCGetLineInfo(
    HMMCAPP             hMmcApp,
    LPDEVICEINFOLIST    lpDeviceInfoList
    );

LONG
WINAPI
MMCGetLineStatus(
    HMMCAPP             hMmcApp,
    HWND                hwndOwner,
    DWORD               dwStatusLevel,
    DWORD               dwProviderID,
    DWORD               dwPermanentLineID,
    LPVARSTRING         lpStatusBuffer
    );

LONG
WINAPI
MMCGetPhoneInfo(
    HMMCAPP             hMmcApp,
    LPDEVICEINFOLIST    lpDeviceInfoList
    );

LONG
WINAPI
MMCGetPhoneStatus(
    HMMCAPP             hMmcApp,
    HWND                hwndOwner,
    DWORD               dwStatusLevel,
    DWORD               dwProviderID,
    DWORD               dwPermanentPhoneID,
    LPVARSTRING         lpStatusBuffer
    );

LONG
WINAPI
MMCGetProviderList(
    HMMCAPP             hMmcApp,
    LPLINEPROVIDERLIST  lpProviderList
    );

LONG
WINAPI
MMCGetServerConfig(
    HMMCAPP             hMmcApp,
    LPTAPISERVERCONFIG  lpConfig
    );

LONG
WINAPI
MMCInitialize(
    LPCWSTR             lpszComputerName,
    LPHMMCAPP           lphMmcApp,
    LPDWORD             lpdwAPIVersion,
    HANDLE              hReinitializeEvent
    );

LONG
WINAPI
MMCRemoveProvider(
    HMMCAPP             hMmcApp,
    HWND                hwndOwner,
    DWORD               dwProviderID
    );

LONG
WINAPI
MMCSetLineInfo(
    HMMCAPP             hMmcApp,
    LPDEVICEINFOLIST    lpDeviceInfoList
    );

LONG
WINAPI
MMCSetPhoneInfo(
    HMMCAPP             hMmcApp,
    LPDEVICEINFOLIST    lpDeviceInfoList
    );

LONG
WINAPI
MMCSetServerConfig(
    HMMCAPP             hMmcApp,
    LPTAPISERVERCONFIG  lpConfig
    );

LONG
WINAPI
MMCGetDeviceFlags(
    HMMCAPP             hMmcApp,
    BOOL                bLine,
    DWORD               dwProviderID,
    DWORD               dwPermanentDeviceID,
    DWORD               * pdwFlags,
    DWORD               * pdwDeviceID
    );

LONG
WINAPI
MMCShutdown(
    HMMCAPP             hMmcApp
    );

BOOL
SecureTsecIni();

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\inc\tapirtp.h ===
#ifndef __tapirtp_h__
#define __tapirtp_h__

#include <objbase.h>
#include "msrtp.h"

/*
 * WARNING
 *
 * All the NETWORK/HOST sensitive parameters (e.g. port numbers, IP
 * addresses, SSRCs) are expected/returned in NETWORK order
 * */

/*
 * NOTE
 *
 * Most constants are defined in file msrtp.h,
 * e.g. RTPMCAST_LOOPBACKMODE_NONE, RTPSDES_CNAME, etc. msrtp.h (in
 * the same directory as this file) has all the options and a short
 * explanation
 * */

/* {5467edec-0cca-11d3-96e0-00104bc7b3a8} */
DEFINE_GUID(CLSID_MSRTPSourceFilter,
0x5467edec, 0x0cca, 0x11d3, 0x96, 0xe0, 0x00, 0x10, 0x4b, 0xc7, 0xb3, 0xa8);

struct DECLSPEC_UUID("5467edec-0cca-11d3-96e0-00104bc7b3a8") MSRTPSourceFilter;

/* {323cdf3c-0cca-11d3-96e0-00104bc7b3a8} */
DEFINE_GUID(CLSID_MSRTPRenderFilter,
0x323cdf3c, 0x0cca, 0x11d3, 0x96, 0xe0, 0x00, 0x10, 0x4b, 0xc7, 0xb3, 0xa8);

struct DECLSPEC_UUID("323cdf3c-0cca-11d3-96e0-00104bc7b3a8") MSRTPRenderFilter;


/**********************************************************************
 *  IRtpSession (Exposed by RTP Source and Render filters)
 **********************************************************************/
struct DECLSPEC_UUID("f07f3070-0cca-11d3-96e0-00104bc7b3a8") DECLSPEC_NOVTABLE 
IRtpSession : public IUnknown
{
    /* Compact form */
    
    STDMETHOD(Control)(
            DWORD            dwControl,
            DWORD_PTR        dwPar1,
            DWORD_PTR        dwPar2
        ) PURE;

    STDMETHOD(GetLastError)(
            DWORD           *pdwError
        ) PURE;

    /* Separate methods */

    /***************************
     * Initialization
     ***************************/

    /* Init is the first method to call after an RTP source or render
     * filter is created, using a cookie allows the same RTP session
     * to be shared by a source and a render. The first call will have
     * the coockie initialized to NULL, the next call will use the
     * returned cookie to lookup the same RTP session. dwFlags can be
     * RTPINIT_QOS to create QOS enabled sockets, you can find out the
     * complete list of flags that can be used in file msrtp.h */
    STDMETHOD(Init)(
            HANDLE          *phCookie,
            DWORD            dwFlags
        ) PURE;

    /* Deinit is a method used to take the filter back to a state on
     * which a new Init() can and must be done if the filter is to be
     * started again, also note that just after Init(), a filter needs
     * to be configured, that holds also when you use Deinit() taking
     * the filter to its initial state */
    STDMETHOD(Deinit)(
            void
        ) PURE;

    /***************************
     * IP adress and ports
     ***************************/
    
    /* Get the local and remote ports */
    STDMETHOD(GetPorts)(
            WORD            *pwRtpLocalPort,
            WORD            *pwRtpRemotePort,
            WORD            *pwRtcpLocalPort,
            WORD            *pwRtcpRemotePort
        ) PURE;

    /* Set the local and remote ports */
    STDMETHOD(SetPorts)(
            WORD             wRtpLocalPort,
            WORD             wRtpRemotePort,
            WORD             wRtcpLocalPort,
            WORD             wRtcpRemotePort
        ) PURE;

    /* Set the local and remote IP address */
    STDMETHOD(SetAddress)(
            DWORD            dwLocalAddr,
            DWORD            dwRemoteAddr
        ) PURE;

    /* Obtain the local and remote IP addresses */
    STDMETHOD(GetAddress)(
            DWORD           *pdwLocalAddr,
            DWORD           *pdwRemoteAddr
        ) PURE;

    /* The dwFlags parameter is used to determine if the scope is set
     * for RTP (0x1), RTCP (0x2), or both (0x3) */
    STDMETHOD(SetScope)(
            DWORD            dwTTL,
            DWORD            dwFlags
        ) PURE;

    /* Set the multicast loopback mode
     * (e.g. RTPMCAST_LOOPBACKMODE_NONE,
     * RTPMCAST_LOOPBACKMODE_PARTIAL, etc) */
    STDMETHOD(SetMcastLoopback)(
            int              iMcastLoopbackMode,
            DWORD            dwFlags /* Not used, pass 0 */
        ) PURE;

    /***************************
     * Miscelaneous
     ***************************/

    /* Modify the mask specified by dwKind (e.g. RTPMASK_RECV_EVENTS,
     * RTPMASK_SDES_LOCMASK).
     *
     * dwMask is the mask of bits to be set or reset depending on
     * dwValue (reset if 0, set otherwise).
     *
     * pdwModifiedMask will return the resulting mask if the pointer
     * is not NULL. You can just query the current mask value by
     * passing dwMask=0 */
    STDMETHOD(ModifySessionMask)(
            DWORD            dwKind,
            DWORD            dwMask,
            DWORD            dwValue,
            DWORD           *pdwModifiedMask
        ) PURE;

    /* Set the bandwidth limits. A value of -1 will make the parameter
     * to be left unchanged.
     *
     * All the parameters are in bits/sec */
    STDMETHOD(SetBandwidth)(
            DWORD            dwInboundBw,
            DWORD            dwOutboundBw,
            DWORD            dwReceiversRtcpBw,
            DWORD            dwSendersRtcpBw
        ) PURE;

    /***************************
     * Participants
     ***************************/
    
    /* pdwSSRC points to an array of DWORDs where to copy the SSRCs,
     * pdwNumber contains the maximum entries to copy, and returns the
     * actual number of SSRCs copied. If pdwSSRC is NULL, pdwNumber
     * will return the current number of SSRCs (i.e. the current
     * number of participants) */
    STDMETHOD(EnumParticipants)(
            DWORD           *pdwSSRC,
            DWORD           *pdwNumber
        ) PURE;

    /* Get the participant state. dwSSRC specifies the
     * participant. pdwState will return the current participant's
     * state (e.g. RTPPARINFO_TALKING, RTPPARINFO_SILENT). */
    STDMETHOD(GetParticipantState)(
            DWORD            dwSSRC,
            DWORD           *pdwState
        ) PURE;

    /* Get the participant's mute state. dwSSRC specifies the
     * participant. pbMuted will return the participant's mute state
     * */
    STDMETHOD(GetMuteState)(
            DWORD            dwSSRC,
            BOOL            *pbMuted
        ) PURE;

    /* Set the participant's mute state. dwSSRC specifies the
     * participant. bMuted specifies the new state. Note that mute is
     * used to refer to the permission or not to pass packets received
     * up to the application, and it applies equally to audio or video
     * */
    STDMETHOD(SetMuteState)(
            DWORD            dwSSRC,
            BOOL             bMuted
        ) PURE;

    /* Query the network metrics computation state for the specific SSRC */
    STDMETHOD(GetNetMetricsState)(
            DWORD            dwSSRC,
            BOOL            *pbState
        ) PURE;
    
    /* Enable or disable the computation of networks metrics, this is
     * mandatory in order of the corresponding event to be fired if
     * enabled. This is done for the specific SSRC or the first one
     * found if SSRC=-1, if SSRC=0, then the network metrics
     * computation will be performed for any and all the SSRCs */
    STDMETHOD(SetNetMetricsState)(
            DWORD            dwSSRC,
            BOOL             bState
        ) PURE;
    
    /* Retrieves network information, if the network metric
     * computation is enabled for the specific SSRC, all the fields in
     * the structure will be meaningful, if not, only the average
     * values will contain valid data */
    STDMETHOD(GetNetworkInfo)(
            DWORD            dwSSRC,
            RtpNetInfo_t    *pRtpNetInfo
        ) PURE;

    /***************************
     * SDES 
     ***************************/
    
    /* Set the local SDES information for item dwSdesItem (e.g
     * RTPSDES_CNAME, RTPSDES_EMAIL), psSdesData contains the UNICODE
     * NULL terminated string to be assigned to the item */
    STDMETHOD(SetSdesInfo)(
            DWORD            dwSdesItem,
            WCHAR           *psSdesData
        ) PURE;

    /* Get a local SDES item if dwSSRC=0, otherwise gets the SDES item
     * from the participant whose SSRC was specified.
     *
     * dwSdesItem is the item to get (e.g. RTPSDES_CNAME,
     * RTPSDES_EMAIL), psSdesData is the memory place where the item's
     * value will be copied, pdwSdesDataLen contains the initial size
     * in UNICODE chars, and returns the actual UNICODE chars copied
     * (including the NULL terminating char, if any), dwSSRC specify
     * which participant to retrieve the information from. If the SDES
     * item is not available, dwSdesDataLen is set to 0 and the call
     * doesn't fail */
    STDMETHOD(GetSdesInfo)(
            DWORD            dwSdesItem,
            WCHAR           *psSdesData,
            DWORD           *pdwSdesDataLen,
            DWORD            dwSSRC
        ) PURE;

    /***************************
     * QOS
     ***************************/

    /* Select a QOS template (flowspec) by passing its name in
     * psQosName, dwResvStyle specifies the RSVP style (e.g
     * RTPQOS_STYLE_WF, RTPQOS_STYLE_FF), dwMaxParticipants specifies
     * the max number of participants (1 for unicast, N for
     * multicast), this number is used to scale up the
     * flowspec. dwQosSendMode specifies the send mode (has to do with
     * allowed/not allowed to send) (e.g. RTPQOSSENDMODE_UNRESTRICTED,
     * RTPQOSSENDMODE_RESTRICTED1). dwFrameSize is the frame size (in
     * ms), used to derive several flowspec parameters, if this value
     * is not available, 0 can be set
     * */
    STDMETHOD(SetQosByName)(
            WCHAR           *psQosName,
            DWORD            dwResvStyle,
            DWORD            dwMaxParticipants,
            DWORD            dwQosSendMode,
            DWORD            dwFrameSize
        ) PURE;

    /* Not yet implemented, will have same functionality as
     * SetQosByName, except that instead of passing a name to use a
     * predefined flowspec, the caller will pass enough information in
     * the RtpQosSpec structure to obtain the customized flowspec to
     * use */
    STDMETHOD(SetQosParameters)(
            RtpQosSpec_t    *pRtpQosSpec,
            DWORD            dwMaxParticipants,
            DWORD            dwQosSendMode
        ) PURE;


    /* If AppName is specified, replaces the default AppName, as well
     * as the APP field in the policy used, with the new UNICODE
     * string, if not, sets the binary image name as the default. If
     * psAppGUID is specified, it will be prepended to the default
     * policy locator as "GUID=string_passed,". If psPolicyLocator is
     * specified, append a comma and this whole string to the default
     * policy locator, if not, just sets the default
     * */
    STDMETHOD(SetQosAppId)(
            WCHAR           *psAppName,
            WCHAR           *psAppGUID,
            WCHAR           *psPolicyLocator
        ) PURE;

    /* Adds/removes a single SSRC to/from the shared explicit list of
     * participants who receive reservation (i.e. it is used when the
     * ResvStyle=RTPQOS_STYLE_SE). */
    STDMETHOD(SetQosState)(
            DWORD            dwSSRC,
            BOOL             bEnable
        ) PURE;

    /* Adds/removes a number of SSRCs to/from the shared explicit list
     * of participants who receive reservation (i.e. it is used when
     * the ResvStyle=RTPQOS_STYLE_SE). dwNumber is the number of SSRCs
     * to add/remove, and returns the actual number of SSRCs
     * added/removed */
    STDMETHOD(ModifyQosList)(
            DWORD           *pdwSSRC,
            DWORD           *pdwNumber,
            DWORD            dwOperation
        ) PURE;

    /***************************
     * Cryptography
     ***************************/

    /* iMode defines what is going to be encrypted/decrypted,
     * e.g. RTPCRYPTMODE_PAYLOAD to encrypt/decrypt only RTP
     * payload. dwFlag can be RTPCRYPT_SAMEKEY to indicate that (if
     * applicable) the key used for RTCP is the same used for RTP */
    STDMETHOD(SetEncryptionMode)(
            int              iMode,
            DWORD            dwFlags
        ) PURE;

    /* Specifies the information needed to derive an
     * encryption/decryption key. PassPhrase is the (random) text used
     * to generate a key. HashAlg specifies the algorithm to use to
     * hash the pass phrase and generate a key. DataAlg is the
     * algorithm used to encrypt/decrypt the data. Default hash
     * algorithm is RTPCRYPT_MD5, default data algorithm is
     * RTPCRYPT_DES. If encryption is to be used, the PassPhrase is a
     * mandatory parameter to set. bRtcp specifies if the parameters
     * are for RTCP or RTP, if the SAMEKEY flag was used when setting
     * the mode, this parameter is ignored */
    STDMETHOD(SetEncryptionKey)(
            WCHAR           *psPassPhrase,
            WCHAR           *psHashAlg,
            WCHAR           *psDataAlg,
            BOOL             bRtcp
        ) PURE;
};

/**********************************************************************
 *  IRtpMediaControl (Exposed by RTP Source and Render filters)
 **********************************************************************/
struct DECLSPEC_UUID("825db25c-cbbd-4212-b10f-2e1b2ff024e7") DECLSPEC_NOVTABLE 
IRtpMediaControl : public IUnknown
{
    /* Establishes the mapping between a payload type, its sampling
     * frequency and its DShow media type (e.g. for H.261
     * {31,90000,MEDIASUBTYPE_RTP_Payload_H261} ) */
    STDMETHOD(SetFormatMapping)(
	        IN DWORD dwRTPPayLoadType, 
            IN DWORD dwFrequency,
            IN AM_MEDIA_TYPE *pMediaType
        ) PURE;

    /* Empties the format mapping table */
    STDMETHOD(FlushFormatMappings)(
            void
        ) PURE;
};

/**********************************************************************
 *  IRtpDemux (Exposed only by RTP Source filter)
 **********************************************************************/
struct DECLSPEC_UUID("1308f00a-fc1a-4d08-af3c-10a62ae70bde") DECLSPEC_NOVTABLE
IRtpDemux : public IUnknown
{
    /* Add a single pin, may return its position */
    STDMETHOD(AddPin)(
            IN  int          iOutMode,
            OUT int         *piPos
        ) PURE;

    /* Set the number of pins, can only be >= than current number of
     * pins */
    STDMETHOD(SetPinCount)(
            IN  int          iCount,
            IN  int          iOutMode
        ) PURE;

    /* Set the pin mode (e.g. RTPDMXMODE_AUTO or RTPDMXMODE_MANUAL),
     * if iPos >= 0 use it, otherwise use pIPin */
    STDMETHOD(SetPinMode)(
            IN  int          iPos,
            IN  IPin        *pIPin,
            IN  int          iOutMode
        ) PURE;

    /* Map/unmap pin i to/from user with SSRC, if iPos >= 0 use it,
     * otherwise use pIPin, when unmapping, only the pin or the SSRC
     * is required */
    STDMETHOD(SetMappingState)(
            IN  int          iPos,
            IN  IPin        *pIPin,
            IN  DWORD        dwSSRC,
            IN  BOOL         bMapped
        ) PURE;

    /* Find the Pin assigned (if any) to the SSRC, return either
     * position or pin or both */
    STDMETHOD(FindPin)(
            IN  DWORD        dwSSRC,
            OUT int         *piPos,
            OUT IPin       **ppIPin
        ) PURE;

    /* Find the SSRC mapped to the Pin, if iPos >= 0 use it, otherwise
     * use pIPin */
    STDMETHOD(FindSSRC)(
            IN  int          iPos,
            IN  IPin        *pIPin,
            OUT DWORD       *pdwSSRC
        ) PURE;
};

/**********************************************************************
 *  IRtpDtmf (Exposed only by RTP Render filter)
 **********************************************************************/
struct DECLSPEC_UUID("554438d8-a4bd-428a-aabd-1cff350eece6") DECLSPEC_NOVTABLE 
IRtpDtmf : public IUnknown
{
    /***************************
     * DTMF (RFC2833)
     ***************************/

    /* Configures DTMF parameters */
    STDMETHOD(SetDtmfParameters)(
            DWORD            dwPT_Dtmf  /* Payload type for DTMF events */
        ) PURE;
    
    /* Directs an RTP render filter to send a packet formatted
     * according to rfc2833 containing the specified event, specified
     * volume level, duration in milliseconds, and the END flag,
     * following the rules in section 3.6 for events sent in multiple
     * packets. Parameter dwId changes from one digit to the next one.
     *
     * NOTE the duration is given in milliseconds, then it is
     * converted to RTP timestamp units which are represented using 16
     * bits, the maximum value is hence dependent on the sampling
     * frequency, but for 8KHz the valid values would be 0 to 8191 ms
     * */
    STDMETHOD(SendDtmfEvent)(
            DWORD            dwId,
                                          /* As per RFC2833 */
            DWORD            dwEvent,     /* 0 - 16 */
            DWORD            dwVolume,    /* 0 - 63 */
            DWORD            dwDuration,  /* See note above */
            BOOL             bEnd         /* 0 - 1 */
        ) PURE;
};

/**********************************************************************
 *  IRtpRedundancy (Exposed by RTP Source and Render filters)
 **********************************************************************/
struct DECLSPEC_UUID("f3a9dcfe-1513-46ce-a1cb-0fcabe70ff44") DECLSPEC_NOVTABLE
IRtpRedundancy : public IUnknown
{
    /***************************
     * RTP redundancy (RFC2918)
     ***************************/

    /* Configures redundancy. For a receiver only parameter dwPT_Red
     * is used (the other are ignored) and may be set to -1 to ignore
     * it if it was already set or to assign the default. For a
     * sender, parameters dwPT_Red, dwInitialRedDistance, and
     * dwMaxRedDistance can be set to -1 to ignore the parameter if it
     * was already set or to assign the default value */
    STDMETHOD(SetRedParameters)(
            DWORD            dwPT_Red, /* Payload type for redundant packets */
            DWORD            dwInitialRedDistance,/* Initial red distance */
            DWORD            dwMaxRedDistance /* default used when passing -1*/
        ) PURE;
};

#endif // __tapirtp_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\inc\tregupr2.h ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  tregupr2.h
                                                              
       Author:  radus - 12/03/98

****************************************************************************/

// tregupr2.h - functions for converting the registry format to 
//	the new one (post NT5b2)		


#ifdef __cplusplus
extern "C" {
#endif


// should be incremented any time there's a registry structure change 
#define TAPI_CARD_LIST_VERSION      2
#define TAPI_LOCATION_LIST_VERSION  2


DWORD ConvertLocations(void);
DWORD ConvertUserLocations(HKEY hUser);
DWORD ConvertCallingCards(HKEY hUser);

DWORD RegDeleteKeyRecursive (HKEY hParentKey, LPCTSTR pszKeyName);


BOOL  IsLocationListInOldFormat(HKEY hLocations); // for both user & machine
BOOL  IsCardListInOldFormat(HKEY hCards);

DWORD TapiCryptInit();
void  TapiCryptShutdown();

DWORD TapiCryptInitialize(void);
void  TapiCryptUninitialize(void);

DWORD TapiEncrypt(PWSTR, DWORD, PWSTR, DWORD *);
DWORD TapiDecrypt(PWSTR, DWORD, PWSTR, DWORD *);

BOOL  TapiIsSafeToDisplaySensitiveData(void);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\litesabr\filters\codecs\g711\amacodec.h ===
/*--------------------------------------------------------------

 INTEL Corporation Proprietary Information  

 This listing is supplied under the terms of a license agreement  
 with INTEL Corporation and may not be copied nor disclosed 
 except in accordance with the terms of that agreement.

 Copyright (c) 1996 Intel Corporation.
 All rights reserved.

 $Workfile:   amacodec.h  $
 $Revision:   1.3  $
 $Date:   10 Dec 1996 22:40:50  $ 
 $Author:   mdeisher  $

--------------------------------------------------------------

amacodec.h

The generic ActiveMovie audio compression filter header.

--------------------------------------------------------------*/

#include "algdefs.h"
#include "iamacset.h"
#if NUMBITRATES > 0
#include "iamacbr.h"
#endif
#ifdef USESILDET
#include "iamacsd.h"
#endif
#ifdef REQUIRE_LICENSE
#include "iamaclic.h"
#endif
#if NUMSAMPRATES > 1
#include "amacsrc.h"
#endif


////////////////////////////////////////////////////////////////////
// constant and macro definitions
//

#define FLOATTOSHORT(b) ((b < -32768.) ? (short)(-32768) : \
                        ((b >  32767.) ? (short)(32767)  : \
                        ((b <      0.) ? (short)(b-0.5)  : \
                                         (short)(b+0.5))))

// with these macros it is possible to add a file name to the
// software\debug\graphedt registry to turn on logging to a file.
// this information is also available in MCVS under the output window.
// The DbgLog has 5 different types each with several different
// levels. all controllable via the registry.

#define DbgFunc(a) DbgLog(( LOG_TRACE,                      \
                            2,                              \
                            TEXT("CG711Codec(Instance %d)::%s"), \
                            m_nThisInstance,                \
                            TEXT(a)                         \
                         ));

#ifdef POPUPONERROR
#define DbgMsg(a) DbgBreak(a)
#else
#define DbgMsg(a) DbgFunc(a)
#endif


////////////////////////////////////////////////////////////////////
// CMyTransformInputPin:  Derived from CTransformInputPin to support
//                        input pin type enumeration
//
class CMyTransformInputPin
    : public CTransformInputPin
{
  public:
    HRESULT CheckMediaType(const CMediaType *mtIn);     
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);

    CMyTransformInputPin(TCHAR *pObjectName, 
                         CTransformFilter *pTransformFilter, 
                         HRESULT * phr, LPCWSTR pName);

  private:
    static int  m_nInstanceCount; // Global count of input pin instances
    int         m_nThisInstance;  // This instance's count
};


////////////////////////////////////////////////////////////////////
// CMyTransformOutputPin:  Derived from CTransformOutputPin to fix
//                         the connection model when input pin type
//                         enumeration is required.
//
class CMyTransformOutputPin
    : public CTransformOutputPin
{
  public:
    HRESULT CheckMediaType(const CMediaType *mtIn);     

    CMyTransformOutputPin(TCHAR *pObjectName, 
                          CTransformFilter *pTransformFilter, 
                          HRESULT * phr, LPCWSTR pName);

  private:
    static int  m_nInstanceCount; // Global count of input pin instances
    int         m_nThisInstance;  // This instance's count
};


////////////////////////////////////////////////////////////////////
// MyCodec:  CTranform derived Codec filter
//
class CG711Codec
    : public CTransformFilter       // perform transform across allocators
    , public CPersistStream         // implements IPersistStream
    , public ISpecifyPropertyPages  // property pages class ???
    , public ICodecSettings         // basic settings interface
#if NUMBITRATES > 0
    , public ICodecBitRate          // bit rate interface
#endif
#ifdef REQUIRE_LICENSE
    , public ICodecLicense          // license interface
#endif
#ifdef USESILDET
    , public ICodecSilDetector      // silence detector interface
#endif
{
    friend class CMyTransformInputPin;
    friend class CMyTransformOutputPin;

  public:

    static CUnknown *CreateInstance(LPUNKNOWN punk, HRESULT *phr);

    DECLARE_IUNKNOWN;

    // Basic COM - used here to reveal our persistent interface.
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // CPersistStream overrides
    HRESULT      WriteToStream(IStream *pStream);
    HRESULT      ReadFromStream(IStream *pStream);
    int          SizeMax();
    STDMETHODIMP GetClassID(CLSID *pClsid);

    // Other Methods    
    LPAMOVIESETUP_FILTER GetSetupData();    // setup helper
    STDMETHODIMP         GetPages(CAUUID *pPages);

    // ICodecSettings Interface Methods
    STDMETHODIMP         get_Channels(int *channels, int index);
    STDMETHODIMP         put_Channels(int channels);
    STDMETHODIMP         get_SampleRate(int *samprate, int index);
    STDMETHODIMP         put_SampleRate(int samprate);
    STDMETHODIMP         get_Transform(int *transform);
    STDMETHODIMP         put_Transform(int transform);
    STDMETHODIMP         get_InputBufferSize(int *numbytes);
    STDMETHODIMP         put_InputBufferSize(int numbytes);
    STDMETHODIMP         get_OutputBufferSize(int *numbytes);
    STDMETHODIMP         put_OutputBufferSize(int numbytes);
    STDMETHODIMP         put_InputMediaSubType(REFCLSID rclsid);
    STDMETHODIMP         put_OutputMediaSubType(REFCLSID rclsid);
    STDMETHODIMP         ReleaseCaps();     // for Roger
    BOOL                 IsUnPlugged();

    // ICodecBitRate Interface Methods
#if NUMBITRATES > 0
    STDMETHODIMP         get_BitRate(int *bitrate, int index);
    STDMETHODIMP         put_BitRate(int bitrate);
#endif

    // ICodecSilDetector Interface Methods
#ifdef USESILDET
    STDMETHODIMP         put_SilDetEnabled(int sdenabled);
    STDMETHODIMP         get_SilDetThresh(int *sdthreshold);
    STDMETHODIMP         put_SilDetThresh(int sdthreshold);
    BOOL                 IsSilDetEnabled();
#endif

    // ICodecLicense Interface Methods
#ifdef REQUIRE_LICENSE
    STDMETHODIMP         put_LicenseKey(DWORD magicword0, DWORD magicword1);
#endif

    // CTransformFilter Overrides
    HRESULT  Transform(IMediaSample *pIn, IMediaSample *pOut);
    HRESULT  CheckInputType(const CMediaType *mtIn);
    HRESULT  CheckTransform(const CMediaType *mtIn, const CMediaType *mtOut);
    HRESULT  GetMediaType(int iPosition, CMediaType *pMediaType);
    HRESULT  DecideBufferSize(IMemAllocator *pAlloc,
                              ALLOCATOR_PROPERTIES *pProperties);
    HRESULT  SetMediaType(PIN_DIRECTION direction, const CMediaType *pmt);
    HRESULT  StopStreaming();
    CBasePin *GetPin(int n);

    CG711Codec(TCHAR *tszName, LPUNKNOWN punk, HRESULT *phr);
    ~CG711Codec();

    HRESULT MyTransform(IMediaSample *pSource, IMediaSample *pDest);

  private:

    HRESULT InitializeState(PIN_DIRECTION direction);
    HRESULT ValidateMediaType(const CMediaType* pmt, PIN_DIRECTION direction);

    // Internally Used Methods    
    STDMETHODIMP         ResetState();
    STDMETHODIMP         RevealCaps(int *restricted);
#if NUMSAMPRATES > 1
    HRESULT SRConvert(BYTE *ibuffer, int  israte, int  ilen,
                      BYTE *obuffer, int  osrate, int  *olen);
#endif

    CCritSec      m_MyCodecLock;    // To serialise access.
    static int    m_nInstanceCount; // Global count of filter instances
    int           m_nThisInstance;  // This instance's count
    UINT          m_nBitRate;       // Coder bit rate
    UINT          m_nBitRateIndex;  // Coder bit rate index
    int           m_nChannels;      // Current sample format, mono or stereo
    UINT          m_nSampleRate;    // PCM sample rate
    int           m_RestrictCaps;   // Boolean: capabilities are restricted
    GUID          m_OutputSubType;
    DWORD         m_OutputFormatTag;
    GUID          m_InputSubType;
    DWORD         m_InputFormatTag;
    MyEncStatePtr m_EncStatePtr;    // Pointer to encoder state structure
    MyDecStatePtr m_DecStatePtr;    // Pointer to decoder state structure
    int           m_nInBufferSize;  // Size of input buffer
    int           m_nOutBufferSize; // Size of output buffer

    BYTE          *m_pPCMBuffer;    // Pointer to PCM spanning buffer
    int           m_nPCMFrameSize;  // Size of speech buffer in bytes
    int           m_nPCMLeftover;   // Number of bytes of leftover PCM

    BYTE          *m_pCODBuffer;    // Pointer to code spanning buffer
    int           m_nCODFrameSize;  // Size of code buffer in bytes
    int           m_nCODLeftover;   // Number of bytes of leftover code

#if NUMSAMPRATES > 1
    BYTE          *m_pSRCCopyBuffer; // Pointer to SRC copy buffer
    BYTE          *m_pSRCBuffer;     // Pointer to SRC spanning buffer
    short         *m_pSRCState;      // Sample rate converter state
    int           m_nSRCCBufSize;    // SRC copy buffer size
    int           m_nSRCCount;       // Cumulative bytes of leftover SRC PCM
    int           m_nSRCLeftover;    // Number of bytes of leftover SRC PCM
#endif

    UINT          *m_UseMMX;         // Ptr to boolean flag.
                                     //   TRUE=use mmx assembly paths

    int           m_nSilDetEnabled;  // silence detection enabled (boolean)
    int           m_nSilDetThresh;   // silence detection threshold
    BOOL          m_nLicensedToEnc;  // approved for encoding
    BOOL          m_nLicensedToDec;  // approved for decoding
};

/*
//$Log:   K:\proj\mycodec\quartz\vcs\amacodec.h_v  $
;// 
;//    Rev 1.3   10 Dec 1996 22:40:50   mdeisher
;// ifdef'ed out SRC vars when SRC not used.
;// 
;//    Rev 1.2   10 Dec 1996 15:22:00   MDEISHER
;// 
;// moved debug macros into header.
;// cosmetic changes.
;// made revealcaps and resetstate methods private.
;// ifdef'ed out interface methods.
;// 
;//    Rev 1.1   09 Dec 1996 09:21:40   MDEISHER
;// 
;// added $log$
;// moved SRC stuff to separate file.
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\litesabr\filters\codecs\g711\algdefs.h ===
/*--------------------------------------------------------------

 INTEL Corporation Proprietary Information  

 This listing is supplied under the terms of a license agreement  
 with INTEL Corporation and may not be copied nor disclosed 
 except in accordance with the terms of that agreement.

 Copyright (c) 1996 Intel Corporation.
 All rights reserved.

 $Workfile:   algdefs.h  $
 $Revision:   1.13  $
 $Date:   10 Dec 1996 22:31:20  $ 
 $Author:   mdeisher  $

--------------------------------------------------------------

header.h

The coder-specific header for G.711.

NOTE: GUIDs for basic companding like G711 should probably be 
      standardized by MS not me.

--------------------------------------------------------------*/

//
// Coder-specific functions
//
extern void Short2Ulaw(const unsigned short *in, unsigned char *out,long len);
extern void Ulaw2Short(const unsigned char *in, unsigned short *out,long len);
extern void Short2Alaw(const unsigned short *in, unsigned char *out,long len);
extern void Alaw2Short(const unsigned char *in, unsigned short *out,long len);

//
// GUIDs
//
// G711 Codec Filter Object
// {AF7D8180-A8F9-11cf-9A46-00AA00B7DAD1}
DEFINE_GUID(CLSID_G711Codec, 
0xaf7d8180, 0xa8f9, 0x11cf, 0x9a, 0x46, 0x0, 0xaa, 0x0, 0xb7, 0xda, 0xd1);

// G711 Codec Filter Property Page Object
// {480D5CA0-F032-11cf-A7D3-00A0C9056683}
DEFINE_GUID(CLSID_G711CodecPropertyPage, 
0x480D5CA0, 0xF032, 0x11cf, 0xA7, 0xD3, 0x0, 0xA0, 0xC9, 0x05, 0x66, 0x83);

// {827FA280-CDFC-11cf-9A9D-00AA00B7DAD1}
DEFINE_GUID(MEDIASUBTYPE_MULAWAudio, 
0x827fa280, 0xcdfc, 0x11cf, 0x9a, 0x9d, 0x0, 0xaa, 0x0, 0xb7, 0xda, 0xd1);

// {9E17EE50-CDFC-11cf-9A9D-00AA00B7DAD1}
DEFINE_GUID(MEDIASUBTYPE_ALAWAudio, 
0x9e17ee50, 0xcdfc, 0x11cf, 0x9a, 0x9d, 0x0, 0xaa, 0x0, 0xb7, 0xda, 0xd1);

//
// Some constants
//

#define ENCODERobj      int   // codec state structure
#define MyEncStatePtr   int*  // encoder state pointer type
#define DECODERobj      int   // codec state structure
#define MyDecStatePtr   int*  // decoder state pointer type
//
// Default filter transform
//
#define DEFINPUTSUBTYPE   MEDIASUBTYPE_PCM
#define DEFINPUTFORMTAG   WAVE_FORMAT_PCM
#define DEFOUTPUTSUBTYPE  MEDIASUBTYPE_MULAWAudio
#define DEFOUTPUTFORMTAG  WAVE_FORMAT_MULAW
#define DEFCODFRMSIZE     0            // G.711 is not frame-based
#define DEFPCMFRMSIZE     0            // G.711 is not frame-based
#define DEFCHANNELS       1
#define DEFSAMPRATE       8000         // well, if we have to guess...
#define DEFBITRATE        0
#define DEFSDENABLED      FALSE

#define NATURALSAMPRATE   8000         // well, if we have to guess...

#define MAXCOMPRATIO      2            // maximum compression ratio

#define CODOFFSET   0   // for unit testing

#define MINSNR    11.0  // the minimum SNR required for the encode/decode
                        //  test from the unit test suite to pass.
#define MINSEGSNR  9.0  // the minimum segmental SNR required for the

#define NUMCHANNELS  2   // number of channel configurations supported

//
//
#define NUMSUBTYPES  3   // Number of input/output buttons
#define NUMSAMPRATES 0   // no sampling rate restriction
#define NUMBITRATES  0   // number of bit rate buttons
#define NUMENCCTRLS  0   // number of encoder control buttons
#define NUMDECCTRLS  0   // number of decoder control buttons

//
// Pin types for automatic registration
//

//
// Transform types:  these must be ordered properly for SetButtons().
//
enum
{
  PCMTOPCM,   PCMTOMULAW,   PCMTOALAW, 
  MULAWTOPCM, MULAWTOMULAW, MULAWTOALAW, 
  ALAWTOPCM,  ALAWTOMULAW,  ALAWTOALAW
};


#ifdef DEFG711GLOBALS
//
// Button IDs:  these must be ordered as in .rc file for SetButtons().
//
UINT INBUTTON[]  = { IDC_PCM_IN, IDC_MULAW_IN, IDC_ALAW_IN };
UINT OUTBUTTON[] = { IDC_PCM_OUT, IDC_MULAW_OUT, IDC_ALAW_OUT };
UINT SRBUTTON[]  = { 0 };
UINT BRBUTTON[]  = { 0 };
UINT ENCBUTTON[] = { 0 };
UINT DECBUTTON[] = { 0 };

//
// Transform validity:  these must correspond to enumerated constants above
//
UINT VALIDTRANS[] =
{
  FALSE, TRUE,  TRUE,
  TRUE,  FALSE, FALSE,
  TRUE,  FALSE, FALSE
};

//
// list of valid media subtypes for pins (PCM must come first)
//
const GUID *VALIDSUBTYPE[] =
{
  &MEDIASUBTYPE_PCM,
  &MEDIASUBTYPE_MULAWAudio,
  &MEDIASUBTYPE_ALAWAudio
};

//
// list of valid format tags for pins (PCM must come first)
//
WORD VALIDFORMATTAG[] =
{
  WAVE_FORMAT_PCM,
  WAVE_FORMAT_MULAW,
  WAVE_FORMAT_ALAW
};

//
// list of valid number of channels
//
UINT VALIDCHANNELS[] =
{
  1,
  2
};

//
// list of valid format tags for pins (PCM must come first)
//
UINT VALIDBITSPERSAMP[] =
{
  16,  // PCM
   8,  // MULAW
   8   // ALAW
};

//
// List of valid sampling rates (PCM side)
//
UINT VALIDSAMPRATE[] =
{
  DEFSAMPRATE
};

//
// List of valid bit rates.
//
UINT VALIDBITRATE[] =
{
  0
};

//
// List of valid code frame sizes
//
UINT VALIDCODSIZE[] =
{
  1  // G.711 is not frame-based
};

//
// encodes 2:1, decodes 1:2
//
// NOTE: this assumes that 13 and 14 bit linear samples are left 
// justified and padded to 16 bits.
//
int COMPRESSION_RATIO[] =
{
  2
};
#else
extern UINT INBUTTON[3];
extern UINT OUTBUTTON[3];
extern UINT SRBUTTON[1];
extern UINT BRBUTTON[1];
extern UINT ENCBUTTON[1];
extern UINT DECBUTTON[1];
extern UINT VALIDTRANS[9];
extern const GUID *VALIDSUBTYPE[3];
extern WORD VALIDFORMATTAG[3];
extern UINT VALIDCHANNELS[2];
extern UINT VALIDBITSPERSAMP[3];
extern UINT VALIDSAMPRATE[1];
extern UINT VALIDBITRATE[1];
extern UINT VALIDCODSIZE[1];
extern int COMPRESSION_RATIO[1];
#endif


//
// initialization macros
//
//   a = pointer to state structure
//   b = bit rate
//   c = silence detection flag
//   d = ptr to flag enabling/disabling use of MMX assembly
//
#define ENC_create(a,b,c,d) {}    // encoder state creation function
#define DEC_create(a,b,c,d) {}    // decoder state creation function
//
// transform macros
//
//   a = pointer to input buffer
//   b = pointer to output buffer
//   c = input buffer length (bytes)
//   d = output buffer length (bytes)
//   e = pointer to state structure
//   f = media subtype guid
//   g = wave format tag
//   h = ptr to flag enabling/disabling use of MMX assembly
//
#define ENC_transform(a,b,c,d,e,f,h) \
        { \
          if (f == MEDIASUBTYPE_MULAWAudio) \
            Short2Ulaw((const unsigned short *) a, \
                       (unsigned char *) b, \
                       c / COMPRESSION_RATIO[m_nBitRate]); \
          else \
            Short2Alaw((const unsigned short *) a, \
                       (unsigned char *) b, \
                       c / COMPRESSION_RATIO[m_nBitRate]); \
        }
#define DEC_transform(a,b,c,d,e,f,g,h) \
        { \
          if ((f == MEDIASUBTYPE_MULAWAudio) \
              || ((f == MEDIASUBTYPE_WAVE || f == MEDIASUBTYPE_NULL) \
                  && (g == WAVE_FORMAT_MULAW))) \
            Ulaw2Short((const unsigned char *) a, \
                       (unsigned short *) b, c); \
          else \
            Alaw2Short((const unsigned char *) a, \
                       (unsigned short *) b, c); \
        }

//
// multiple bit-rate support is not necessary
//
#define SETCODFRAMESIZE(a,b) ;


/*

;$Log:   K:\proj\g711\quartz\src\vcs\algdefs.h_v  $
;// 
;//    Rev 1.13   10 Dec 1996 22:31:20   mdeisher
;// 
;// added ifdef DEFG711GLOBALS and prototypes.
;// 
;//    Rev 1.12   26 Nov 1996 17:06:44   MDEISHER
;// added multi-channel support for new interface.
;// 
;//    Rev 1.11   11 Nov 1996 16:04:22   mdeisher
;// added defines for unit test
;// 
;//    Rev 1.10   11 Nov 1996 16:02:56   mdeisher
;// 
;// added ifdefs for unit test
;// 
;//    Rev 1.9   21 Oct 1996 11:07:32   mdeisher
;// changed VALIDCODSIZE to { 1 }.
;// 
;//    Rev 1.8   21 Oct 1996 10:53:50   mdeisher
;// 
;// removed definition of IID.
;// 
;//    Rev 1.7   01 Oct 1996 15:38:18   MDEISHER
;// made changes to bring G.711 up-to-date with latest mycodec.
;//  - made COMPRESSION_RATIO into a single entry array.
;//  - changed definitions of DEFCODFRMSIZE and DEFPCMFRMSIZE.
;//  - added definition of NATURALSAMPRATE and MAXCOMPRATIO.
;//  - added empty VALIDCODSIZE array.
;//  - modified ENC_transform to accomodate new COMPRESSION_RATIO[].
;//  - added definition of SETCODFRAMESIZE macro.
;// 
;//    Rev 1.6   20 Sep 1996 10:08:26   MDEISHER
;// added default output format tag.
;// 
;//    Rev 1.5   10 Sep 1996 13:43:42   MDEISHER
;// put default sample rate into VALIDSAMPRATE array
;// 
;//    Rev 1.4   09 Sep 1996 11:39:06   MDEISHER
;// completed changes to add mmx flag to macros.
;// 
;//    Rev 1.3   09 Sep 1996 11:26:46   MDEISHER
;// added modifications for mmx flag
;// 
;//    Rev 1.2   04 Sep 1996 13:23:56   MDEISHER
;// 
;// brought up to date with latest mycodec interface.
;// 
;//    Rev 1.1   27 Aug 1996 14:45:06   MDEISHER
;// added pin type list for self-registration.
;// 
;//    Rev 1.0   27 Aug 1996 07:19:34   MDEISHER
;// Initial revision.
;// 
;//    Rev 1.2   26 Aug 1996 11:47:42   MDEISHER
;// changed initialization macro definitions
;// 
;//    Rev 1.1   26 Aug 1996 11:06:00   MWALKER
;// 
;// Changed ENC_create & DEC_create into macros.
;// Renamed MyEncoder & MyDecoder to ENC_transform & DEC_transform
;// 
;//    Rev 1.0   23 Aug 1996 10:07:42   MDEISHER
;// Initial revision.
;// 
;//    Rev 1.2   22 Aug 1996 20:06:18   MDEISHER
;// 
;// first complete version that compiles and passes minimal tests.
;// 
;//    Rev 1.1   13 Aug 1996 21:58:26   MDEISHER
;// 
;// further refinement
;// 
;//    Rev 1.0   13 Aug 1996 20:38:18   MDEISHER
;// Initial revision.

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\litesabr\filters\codecs\g711\amacprop.h ===
/*--------------------------------------------------------------

 INTEL Corporation Proprietary Information  

 This listing is supplied under the terms of a license agreement  
 with INTEL Corporation and may not be copied nor disclosed 
 except in accordance with the terms of that agreement.

 Copyright (c) 1996 Intel Corporation.
 All rights reserved.

 $Workfile:   amacprop.h  $
 $Revision:   1.0  $
 $Date:   09 Dec 1996 09:06:52  $ 
 $Author:   MDEISHER  $

--------------------------------------------------------------

amacprop.h

The generic ActiveMovie audio compression filter property page
header.

--------------------------------------------------------------*/

#define WM_PROPERTYPAGE_ENABLE  (WM_USER + 100)

////////////////////////////////////////////////////////////////////
// CG711CodecProperties:  Property page class definition
//
class CG711CodecProperties : public CBasePropertyPage
{
  public:

    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

  private:

    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnDeactivate();
    HRESULT OnApplyChanges();
    void    RefreshSettings();
    void    SetButtons(HWND hwndParent);

    CG711CodecProperties(LPUNKNOWN lpunk, HRESULT *phr);

    static int        m_nInstanceCount; // Global count of prop page instances
    int               m_nThisInstance;  // This instance's count
    int               m_iTransformType;
    int               m_iBitRate;
    int               m_iSampleRate;
    ICodecSettings    *m_pCodecSettings;

#if NUMBITRATES > 0
    ICodecBitRate     *m_pCodecBitRate;
#endif

#ifdef USESILDET
    ICodecSilDetector *m_pCodecSilDet;
    void        OnSliderNotification(WPARAM wParam, WORD wPosition);
    HWND        m_hwndSDThreshSlider;
    int         m_iSilDetEnabled;
    int         m_iSilDetThresh;
    int         *m_pDetection;
#endif
};

/*
//$Log:   K:\proj\mycodec\quartz\vcs\amacprop.h_v  $
;// 
;//    Rev 1.0   09 Dec 1996 09:06:52   MDEISHER
;// Initial revision.
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\litesabr\filters\codecs\g711\amacodec.cpp ===
/*--------------------------------------------------------------

 INTEL Corporation Proprietary Information  

 This listing is supplied under the terms of a license agreement  
 with INTEL Corporation and may not be copied nor disclosed 
 except in accordance with the terms of that agreement.

 Copyright (c) 1996 Intel Corporation.
 All rights reserved.

 $Workfile:   amacodec.cpp  $
 $Revision:   1.3  $
 $Date:   10 Dec 1996 22:41:18  $ 
 $Author:   mdeisher  $

--------------------------------------------------------------

amacodec.cpp

The generic ActiveMovie audio compression filter.

--------------------------------------------------------------*/

#include <streams.h>
#if !defined(CODECS_IN_DXMRTP)
#include <initguid.h>
#define INITGUID
#endif
#include <uuids.h>
#include <olectl.h>
#include <memory.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <mmsystem.h>
#include <mmreg.h>

#include "resource.h"
#define  DEFG711GLOBALS
#include "amacodec.h"
#include "amacprop.h"

#include "template.h"

///////////////////////////////////////////////////////////////////////
// *
// * Automatic registration
// *

static AMOVIESETUP_MEDIATYPE sudPinTypes[] = {
  {
     &MEDIATYPE_Audio,
     &MEDIASUBTYPE_PCM
  },
  {
     &MEDIATYPE_Audio,
     &MEDIASUBTYPE_MULAWAudio
  },
  {
     &MEDIATYPE_Audio,
     &MEDIASUBTYPE_ALAWAudio
  }
};



static AMOVIESETUP_PIN sudpPins [] =
{
  { L"Input"             // strName
    , FALSE              // bRendered
    , FALSE              // bOutput
    , FALSE              // bZero
    , FALSE              // bMany
    , &CLSID_NULL        // clsConnectsToFilter
    , L"Output"          // strConnectsToPin
    , NUMSUBTYPES        // nTypes
    , sudPinTypes        // lpTypes
  },
  { L"Output"            // strName
    , FALSE              // bRendered
    , TRUE               // bOutput
    , FALSE              // bZero
    , FALSE              // bMany
    , &CLSID_NULL        // clsConnectsToFilter
    , L"Input"           // strConnectsToPin
    , NUMSUBTYPES        // nTypes
    , sudPinTypes        // lpTypes
  }
};


AMOVIESETUP_FILTER sudG711Codec =
{
  &CLSID_G711Codec      // clsID
  , CODECG711LNAME        // strName
  , MERIT_DO_NOT_USE  // MERIT_NORMAL   // dwMerit
  , 2                 // nPins
  , sudpPins          // lpPin
};


// COM Global table of objects in this dll

#if !defined(CODECS_IN_DXMRTP)
CFactoryTemplate g_Templates[] =
{
	CFT_G711_ALL_FILTERS
};

// Count of objects listed in g_cTemplates
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);
#endif


// exported entry points for registration and unregistration (in this
// case they only call through to default implmentations).

#if !defined(CODECS_IN_DXMRTP)
HRESULT DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}


HRESULT DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}
#endif

///////////////////////////////////////////////////////////////////////
// *
// * CG711Codec
// *


// Initialise our instance count for debugging purposes
int CG711Codec::m_nInstanceCount = 0;


//
// CG711Codec Constructor
//

CG711Codec::CG711Codec(TCHAR *tszName, LPUNKNOWN punk, HRESULT *phr)
    : CTransformFilter(tszName, punk, CLSID_G711Codec)
    , CPersistStream(punk, phr)
    , m_InputSubType     (DEFINPUTSUBTYPE)
    , m_InputFormatTag   (DEFINPUTFORMTAG)
    , m_OutputSubType    (DEFOUTPUTSUBTYPE)
    , m_OutputFormatTag  (DEFOUTPUTFORMTAG)
    , m_nBitRateIndex    (0)
    , m_RestrictCaps     (FALSE)
    , m_EncStatePtr      (NULL)
    , m_DecStatePtr      (NULL)
    , m_nPCMFrameSize    (DEFPCMFRMSIZE)
    , m_nPCMLeftover     (0)
    , m_nCODLeftover     (0)
    , m_nCODFrameSize    (DEFCODFRMSIZE)
    , m_nInBufferSize    (0)
    , m_nOutBufferSize   (0)
    , m_nSilDetEnabled   (DEFSDENABLED)
#ifdef USESILDET
    , m_nSilDetThresh    (DEFSDTHRESH)
#endif
#if NUMSAMPRATES > 1
    , m_pSRCCopyBuffer   (NULL)
    , m_nSRCCBufSize     (0)
    , m_nSRCCount        (0)
    , m_nSRCLeftover     (0)
#endif
#ifdef REQUIRE_LICENSE
    , m_nLicensedToDec   (FALSE)
    , m_nLicensedToEnc   (FALSE)
#else
    , m_nLicensedToDec   (TRUE)
    , m_nLicensedToEnc   (TRUE)
#endif
{
    DbgFunc("CG711Codec");
    m_nThisInstance = ++m_nInstanceCount;
    m_nBitRate      = VALIDBITRATE[0];
    m_nChannels     = VALIDCHANNELS[0];
    m_nSampleRate   = VALIDSAMPRATE[0];

    m_pPCMBuffer  = (BYTE *) CoTaskMemAlloc(DEFPCMFRMSIZE);
    m_pCODBuffer  = (BYTE *) CoTaskMemAlloc(DEFCODFRMSIZE);

    if (m_pPCMBuffer == NULL || m_pCODBuffer == NULL)
    {
        *phr = E_OUTOFMEMORY;

        // the destructor will free all memory.
        return;
    }
} // end Constructor


//
// CG711Codec Destructor
//

CG711Codec::~CG711Codec()
{
  // free the state dword.  
  ResetState();
   
  // Delete the pins

  if (m_pInput)
  {
    delete m_pInput;
    m_pInput = NULL;
  }

  if (m_pOutput)
  {
    delete m_pOutput;
    m_pOutput = NULL;
  }

  // Free buffers

  if (m_pPCMBuffer != NULL) CoTaskMemFree(m_pPCMBuffer);
  if (m_pCODBuffer != NULL) CoTaskMemFree(m_pCODBuffer);
}


//
// CreateInstance:  Provide the way for COM to create a CG711Codec object
//

CUnknown *CG711Codec::CreateInstance(LPUNKNOWN punk, HRESULT *phr)
{
    CG711Codec *pNewObject = new CG711Codec(NAME(CODECG711NAME), punk, phr);

    if (pNewObject == NULL)
    {
      *phr = E_OUTOFMEMORY;
      return NULL;
    }

    if (FAILED(*phr))
    {
      delete pNewObject; 
      return NULL;
    }

    return pNewObject;
}


//
// GetSetupData
//

LPAMOVIESETUP_FILTER CG711Codec::GetSetupData()
{
  return &sudG711Codec;
}


//
// NonDelegatingQueryInterface
//
//   Reveals IIPEffect & ISpecifyPropertyPages
//
STDMETHODIMP CG711Codec::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
   if (riid == IID_ICodecSettings)
     return GetInterface((ICodecSettings *) this, ppv);
#if NUMBITRATES > 0
   else if (riid == IID_ICodecBitRate)
     return GetInterface((ICodecBitRate *) this, ppv);
#endif
#ifdef REQUIRE_LICENSE
   else if (riid == IID_ICodecLicense)
     return GetInterface((ICodecLicense *) this, ppv);
#endif
#ifdef USESILDET
   else if (riid == IID_ICodecSilDetector)
     return GetInterface((ICodecSilDetector *) this, ppv);
#endif
   else if (riid == IID_ISpecifyPropertyPages)
     return GetInterface((ISpecifyPropertyPages *) this, ppv);
   else
     return CTransformFilter::NonDelegatingQueryInterface(riid, ppv);
}


//
// Transform
//
// This is the generic transform member function.  It's task is to
// move data from one buffer, through the transform, and into the
// output buffer.
//
HRESULT CG711Codec::Transform(IMediaSample *pSource, IMediaSample *pDest)
{
  CAutoLock l(&m_MyCodecLock); // enter critical section auto free
                               // at end of scope

  DbgFunc("Transform");

  {
    BYTE  *pSourceBuffer, *pDestBuffer;

    // extract the actual buffer size in bytes
    unsigned long lSourceSize = pSource->GetActualDataLength();
    unsigned long lDestSize   = pDest->GetSize();

    // we need to have a sample to proceed
    ASSERT(lSourceSize);
    ASSERT(lDestSize);

    // NOTE: for stereo channels we just crank through the buffer.
    // if indivitual channel data analysis is required then m_nChannels is
    // available at (this->)

    // set i/o pointers
    pSource->GetPointer(&pSourceBuffer);
    pDest->GetPointer(&pDestBuffer);


    // call the proper transform
    // NOTE: dlg clean this up too many compares and should sizeof
    // BYTEs and format for len field, plus remove mult and divides

    if ((m_InputSubType == MEDIASUBTYPE_PCM)
        || (m_InputSubType == MEDIASUBTYPE_WAVE
            && m_InputFormatTag == WAVE_FORMAT_PCM)
        || (m_InputSubType == MEDIASUBTYPE_NULL
            && m_InputFormatTag == WAVE_FORMAT_PCM))    // compressing?
    {
#if NUMSAMPRATES > 1
      ASSERT(lDestSize
             >= lSourceSize * NATURALSAMPRATE
                / (COMPRESSION_RATIO[m_nBitRateIndex] * m_nSampleRate));
#else
      ASSERT(lDestSize >= lSourceSize / COMPRESSION_RATIO[m_nBitRateIndex]);
#endif

#ifdef REQUIRE_LICENSE
      if (!m_nLicensedToEnc)
      {
        ASSERT(NOTLICENSED);
        return E_UNEXPECTED;
      }
#endif

      if (m_nPCMFrameSize <= 2)  // *** codec is sample-based ***
      {
        ENC_transform(pSourceBuffer, pDestBuffer, lSourceSize,
                      lDestSize, m_EncStatePtr, m_OutputSubType, m_UseMMX);

        pDest->SetActualDataLength(lSourceSize
                                   / COMPRESSION_RATIO[m_nBitRateIndex]);
      }
      else                       // *** codec is frame-based ***
      {
        int  codeframesize = m_nCODFrameSize;  // actual code frame size
        BOOL done          = FALSE;
        int  inbytes;
        BYTE *inptr;
        BYTE *inend;
        int  outbytes;
        BYTE *outptr       = pDestBuffer;
        BYTE *outend       = pDestBuffer + lDestSize;

        // perform sample rate conversion if necessary

#if NUMSAMPRATES > 1
        if (m_nSampleRate != NATURALSAMPRATE)
        {
          inptr = m_pSRCCopyBuffer;
          SRConvert(pSourceBuffer, m_nSampleRate, lSourceSize, 
                    m_pSRCCopyBuffer, NATURALSAMPRATE, &inbytes);
        }
        else
        {
          inptr = pSourceBuffer;
          inbytes = lSourceSize;
        }
#else
        inptr = pSourceBuffer;
        inbytes = lSourceSize;
#endif

        inend = inptr + inbytes;

        if (inbytes + m_nPCMLeftover < m_nPCMFrameSize)
        {
          memcpy(m_pPCMBuffer + m_nPCMLeftover, inptr, inbytes);
          m_nPCMLeftover += inbytes;
          outbytes = 0;
        }
        else
        {
          // fill first speech frame

          memcpy(m_pPCMBuffer + m_nPCMLeftover, inptr,
                 m_nPCMFrameSize - m_nPCMLeftover);

          inptr += (m_nPCMFrameSize - m_nPCMLeftover);

          // start filling output buffer with leftovers from last time

          memcpy(outptr, m_pCODBuffer, m_nCODLeftover);

          outptr += m_nCODLeftover;

          // encode all of the available data, frame-by-frame

          while (!done)
          {
            // encode a frame

            ENC_transform(m_pPCMBuffer, m_pCODBuffer, m_nPCMFrameSize,
                          m_nCODFrameSize, m_EncStatePtr, m_OutputSubType,
                          m_UseMMX);

            // refill input buffer

            inbytes  = (int)(inend - inptr);
            if (inbytes > m_nPCMFrameSize)
              inbytes = m_nPCMFrameSize;

            memcpy(m_pPCMBuffer, inptr, inbytes);
            inptr += inbytes;

            // determine actual size of code frame (if applicable)

            SETCODFRAMESIZE(codeframesize, m_pCODBuffer);

            // write to output buffer

            outbytes = (int)(outend - outptr);
            if (outbytes > codeframesize)
              outbytes = codeframesize;

            memcpy(outptr, m_pCODBuffer, outbytes);
            outptr += outbytes;

            // check to see if buffers are exhausted

            if (inbytes < m_nPCMFrameSize)
            {
              m_nPCMLeftover = inbytes;

              m_nCODLeftover = codeframesize - outbytes;
              memmove(m_pCODBuffer, m_pCODBuffer + outbytes, m_nCODLeftover);

              done = TRUE;
            }
          }
        }
        pDest->SetActualDataLength((int)(outptr - pDestBuffer));
      }
    } 
    else    // decompressing
    {
#if NUMSAMPRATES > 1
      ASSERT(lDestSize >= lSourceSize * COMPRESSION_RATIO[m_nBitRateIndex]
                          * m_nSampleRate / NATURALSAMPRATE);
#else
      ASSERT(lDestSize >= lSourceSize * COMPRESSION_RATIO[m_nBitRateIndex]);
#endif

#ifdef REQUIRE_LICENSE
      if (!m_nLicensedToDec)
      {
        ASSERT(NOTLICENSED);
        return E_UNEXPECTED;
      }
#endif

      if (m_nPCMFrameSize <= 2)  // *** codec is sample-based ***
      {
        DEC_transform(pSourceBuffer, pDestBuffer, lSourceSize, lDestSize,
                      m_DecStatePtr, m_InputSubType, m_InputFormatTag, 
                      m_UseMMX);

        pDest->SetActualDataLength(lSourceSize
                                   * COMPRESSION_RATIO[m_nBitRateIndex]);
      }
      else                       // *** codec is frame-based ***
      {
        BOOL done    = FALSE;
        BYTE *inptr  = pSourceBuffer;
        BYTE *inend  = pSourceBuffer + lSourceSize;
        BYTE *outptr;
        BYTE *outend;
        int  inbytes = lSourceSize;
        int  outbytes;

#if NUMSAMPRATES > 1
        if (m_nSampleRate != NATURALSAMPRATE)
        {
          outptr = m_pSRCCopyBuffer;
          outend = m_pSRCCopyBuffer + m_nSRCCBufSize;
        }
        else
        {
          outptr = pDestBuffer;
          outend = pDestBuffer + lDestSize;
        }
#else
        outptr = pDestBuffer;
        outend = pDestBuffer + lDestSize;
#endif

        if (m_nCODLeftover == 0)  // is this a new frame?
        {
          // in multiple bit-rate decoders determine code
          // frame size from in-band information
        
          SETCODFRAMESIZE(m_nCODFrameSize,inptr);
        }
          
        if (inbytes + m_nCODLeftover < m_nCODFrameSize)
        {
          memcpy(m_pCODBuffer + m_nCODLeftover, inptr, inbytes);
          m_nCODLeftover += inbytes;
        }
        else
        {
          // complete the first code frame

          memcpy(m_pCODBuffer + m_nCODLeftover, inptr,
                 m_nCODFrameSize - m_nCODLeftover);

          inptr += (m_nCODFrameSize - m_nCODLeftover);

          // start filling output buffer with leftovers from last time

          memcpy(outptr, m_pPCMBuffer, m_nPCMLeftover);

          outptr += m_nPCMLeftover;

          // decode all of the available data, frame-by-frame

          while (!done)
          {
            // decode a frame

            DEC_transform(m_pCODBuffer, m_pPCMBuffer,
                          m_nCODFrameSize, m_nPCMFrameSize,
                          m_DecStatePtr, m_InputSubType, 
                          m_InputFormatTag, m_UseMMX);

            // determine size of next code frame (if applicable)

            inbytes  = (int)(inend - inptr);

            if (inbytes > 0)
            {
              // in multiple bit-rate decoders determine code
              // frame size from in-band information

              SETCODFRAMESIZE(m_nCODFrameSize,inptr);
            }

            // refill input buffer

            if (inbytes > m_nCODFrameSize)
              inbytes = m_nCODFrameSize;

            memcpy(m_pCODBuffer, inptr, inbytes);
            inptr += inbytes;

            // write to output buffer

            outbytes = (int)(outend - outptr);
            if (outbytes > m_nPCMFrameSize)
              outbytes = m_nPCMFrameSize;

            memcpy(outptr, m_pPCMBuffer, outbytes);
            outptr += outbytes;

            // check to see if buffers are exhausted

            if (inbytes < m_nCODFrameSize)
            {
              m_nCODLeftover = inbytes;

              m_nPCMLeftover = m_nPCMFrameSize - outbytes;
              memmove(m_pPCMBuffer, m_pPCMBuffer + outbytes, m_nPCMLeftover);

              done = TRUE;
            }
          }

#if NUMSAMPRATES > 1
          // perform sample rate conversion if necessary
          if (m_nSampleRate != NATURALSAMPRATE)
          {
            inbytes = outptr - m_pSRCCopyBuffer;

            SRConvert(m_pSRCCopyBuffer, NATURALSAMPRATE, inbytes,
                      pDestBuffer,      m_nSampleRate,   &outbytes);
          }
          else outbytes = outptr - pDestBuffer;
#else
          outbytes = (int)(outptr - pDestBuffer);
#endif
        }
        pDest->SetActualDataLength(outbytes);
      }
    }
  } // end scope for pointers 

  // transform is complete so now copy the necessary out-of-band
  // information

  {
    //
    // This section rewritten by ZoltanS 8-10-98
    //
    // Copy the sample time, making extra sure that we propagate all the
    // state from the source sample to the destination sample. (We are concerned
    // about the Sample_TimeValid and Sample_StopValid flags; see
    // amovie\sdk\blass\bases\amfilter.cpp.)
    // 

    REFERENCE_TIME TimeStart, TimeEnd;

    HRESULT hr = pSource->GetTime((REFERENCE_TIME *)&TimeStart,
                                  (REFERENCE_TIME *)&TimeEnd);

    if ( hr == VFW_S_NO_STOP_TIME )
    {
        // Got start time only; set start time only.

        pDest->SetTime( (REFERENCE_TIME *)&TimeStart,
                        NULL                          );
    }
    else if ( SUCCEEDED(hr) )
    {
        // Got both start and end times; set both.

        pDest->SetTime( (REFERENCE_TIME *)&TimeStart,
                        (REFERENCE_TIME *)&TimeEnd    );
    }
    else
    {
        // this is a hack for the media streaming terminal.
        TimeStart = 0;
        TimeEnd = 0;
        pDest->SetTime( (REFERENCE_TIME *)&TimeStart,
                        (REFERENCE_TIME *)&TimeEnd    );
    }

    //
    // ... any error return from GetTime, such as VFW_E_SAMPLE_TIME_NOT_SET,
    // means that we don't set the time on the outgoing sample.
    //
  }

  {
    // Copy the Sync point property

    HRESULT hr = pSource->IsSyncPoint();
    if (hr == S_OK) {
      pDest->SetSyncPoint(TRUE);
    }
    else if (hr == S_FALSE) {
      pDest->SetSyncPoint(FALSE);
    }
    else {      // an unexpected error has occured...
      return E_UNEXPECTED;
    }
  }

  return NOERROR;

} // end Transform


//
// ValidateMediaType
//
// This is called to check that the input or output pin type is
// appropriate.
//
HRESULT CG711Codec::ValidateMediaType(const CMediaType *pmt,
                                    PIN_DIRECTION direction)
{
  int format;
  int i;

  CAutoLock l(&m_MyCodecLock); // enter critical section auto free
                               // at end of scope

  DbgFunc("ValidateMediaType");
    
  LPWAVEFORMATEX lpWf = (LPWAVEFORMATEX)pmt->pbFormat;

  // reject up front any non-Audio types

  if (*pmt->Type() != MEDIATYPE_Audio)
  {
    DbgMsg("MediaType is not an audio type!");
    return E_INVALIDARG;
  }

  // we require that a wave format structure be present

  if (*pmt->FormatType() != FORMAT_WaveFormatEx )
  {
    DbgMsg("Invalid FormatType!");
    return E_INVALIDARG;
  }

  // reject unsupported subtypes

  if (*pmt->Subtype() != MEDIASUBTYPE_WAVE
      && *pmt->Subtype() != MEDIASUBTYPE_NULL)
  {
    for(i=0,format=-1;i<NUMSUBTYPES;i++)
      if (*pmt->Subtype() == *VALIDSUBTYPE[i])
        format = i;

    if (format == -1)
    {
      DbgMsg("Invalid MediaSubType!");
      return E_INVALIDARG;
    }
  }
  else        // format tag must be valid if subtype is not
  {
    for(i=0,format=-1;i<NUMSUBTYPES;i++)
      if (lpWf->wFormatTag == VALIDFORMATTAG[i])
        format = i;

    if (format == -1)
    {
      DbgMsg("Invalid FormatTag!");
      return E_INVALIDARG;
    }
  }

  // Reject invalid format blocks

  if (pmt->cbFormat < sizeof(PCMWAVEFORMAT))
  {
    DbgMsg("Invalid block format!");
    return E_INVALIDARG;
  }

  // Check bits per sample

  for(i=0;i<NUMSUBTYPES;i++)
    if (lpWf->wFormatTag == VALIDFORMATTAG[i])
      if (lpWf->wBitsPerSample != VALIDBITSPERSAMP[i])
      {
        DbgMsg("Wrong BitsPerSample!");
        return E_INVALIDARG;
      }
        
  // Check sampling rate

  if (lpWf->nSamplesPerSec <= 0)  // need positive rate for 
  {                               // downstream filters
    DbgMsg("Sample rate is invalid!");
    return E_INVALIDARG;
  }

#if NUMSAMPRATES > 0

  // NUMSAMPRATES==0 means that sample rate is unrestricted

  if (*pmt->Subtype() == MEDIASUBTYPE_PCM
      || ((*pmt->Subtype() == MEDIASUBTYPE_WAVE
           || *pmt->Subtype() == MEDIASUBTYPE_NULL)
          && lpWf->wFormatTag == WAVE_FORMAT_PCM))   // PCM
  {
    if (m_RestrictCaps && (lpWf->nSamplesPerSec != m_nSampleRate))
    {
      DbgMsg("Wrong SamplesPerSec in restricted mode!");
      return E_INVALIDARG;
    }

    for(int i=0;i<NUMSAMPRATES;i++)
      if (lpWf->nSamplesPerSec == VALIDSAMPRATE[i])
        break;

    if (i == NUMSAMPRATES)
    {
      DbgMsg("Wrong SamplesPerSec!");
      return E_INVALIDARG;
    }
  }
  else                                              // compressed
  {
    if (lpWf->nSamplesPerSec != NATURALSAMPRATE)
    {
      DbgMsg("Wrong SamplesPerSec!");
      return E_UNEXPECTED;
    }
  }

#endif

  // Check number of channels

#ifdef MONO_ONLY
  if (lpWf->nChannels != 1)
  {
    DbgMsg("Wrong nChannels!");
    return E_INVALIDARG;
  }
#endif

  // Pin-specific checks

  switch(direction)
  {
    case PINDIR_INPUT:

      // If capabilities are restricted, formats must match

      if (m_RestrictCaps)
      {
        if (*pmt->Subtype() != m_InputSubType)
        {
          if ((*pmt->Subtype() != MEDIASUBTYPE_WAVE
               && *pmt->Subtype() != MEDIASUBTYPE_NULL)
              || (lpWf->wFormatTag != m_InputFormatTag))
          {
            DbgMsg("Formats must match in restricted mode!");
            return E_INVALIDARG;
          }
        }
      }

      if (m_pOutput->IsConnected())
      {
        // determine output type index

        for(i=0;i<NUMSUBTYPES;i++)
          if (m_OutputSubType == *VALIDSUBTYPE[i])
            break;

        if (i == NUMSUBTYPES)
        {
          // subtype isn't valid so check format tag

          for(i=0;i<NUMSUBTYPES;i++)
            if (m_OutputFormatTag == VALIDFORMATTAG[i])
              break;

          if (((m_OutputSubType != MEDIASUBTYPE_NULL)
               && (m_OutputSubType != MEDIASUBTYPE_WAVE))
              || (i == NUMSUBTYPES))
          {
            DbgMsg("Bad output format in ValidateMediaType!");
            return E_INVALIDARG;
          }
        }

        if (!VALIDTRANS[format * NUMSUBTYPES + i])
        {
          DbgMsg("Inappropriate input type given output type!");
          return E_INVALIDARG;
        }
      }

      break;

    case PINDIR_OUTPUT:

      // If capabilities are restricted, subtypes must match

      if (m_RestrictCaps)
      {
        if (*pmt->Subtype() != m_OutputSubType)
        {
          if ((*pmt->Subtype() != MEDIASUBTYPE_WAVE
               && *pmt->Subtype() != MEDIASUBTYPE_NULL)
              || (lpWf->wFormatTag != m_OutputFormatTag))
          {
            DbgMsg("Formats must match in restricted mode!");
            return E_INVALIDARG;
          }
        }
      }

      if (m_pInput->IsConnected())
      {
        // determine input type index

        for(i=0;i<NUMSUBTYPES;i++)
          if (m_InputSubType == *VALIDSUBTYPE[i])
            break;

        if (i == NUMSUBTYPES)
        {
          // subtype isn't valid so check format tag

          for(i=0;i<NUMSUBTYPES;i++)
            if (m_InputFormatTag == VALIDFORMATTAG[i])
              break;

          if (((m_InputSubType != MEDIASUBTYPE_NULL)
               && (m_InputSubType != MEDIASUBTYPE_WAVE))
              || (i == NUMSUBTYPES))
          {
            DbgMsg("Bad input format in ValidateMediaType!");
            return E_INVALIDARG;
          }
        }

        if (!VALIDTRANS[i * NUMSUBTYPES + format])
        {
          DbgMsg("Inappropriate output type given input type!");
          return E_INVALIDARG;
        }

#if NUMSAMPRATES==0
        // if the filter has no sample rate restrictions, then we force
        // the output sampling rate to match the input

        if (lpWf->nSamplesPerSec != m_nSampleRate)
        {
          DbgMsg("Sampling rate doesn't match input!");
          return E_INVALIDARG;
        }
#endif

      }
      break;

    default :
      ASSERT(FALSE);
      return E_UNEXPECTED;
  }

  return NOERROR;

} // end ValidateMediaType


//
// CheckInputType
//
// This is called to make sure the input type requested up stream is
// acceptable. We do not lock access during this call because we are
// just checking information rather than writing.
//
HRESULT CG711Codec::CheckInputType(const CMediaType *pmt)
{
  DbgFunc("CheckInputType");
    
  return(ValidateMediaType(pmt, PINDIR_INPUT));
}


//
// CheckTransform
//
// Before the SetMediaTypes are called for each direction this
// function is given one last veto right.  Since we are a transformation
// the input and output formats are not the same, however, the rate and 
// channels should be identical.
// 

HRESULT CG711Codec::CheckTransform(const CMediaType *mtIn,
                                 const CMediaType *mtOut)
{
  int i,j;

  CAutoLock l(&m_MyCodecLock); // enter critical section auto free
                               // at end of scope

  DbgFunc("CheckTransform");

  LPWAVEFORMATEX lpWfIn = (LPWAVEFORMATEX) mtIn->Format();
  LPWAVEFORMATEX lpWfOut = (LPWAVEFORMATEX) mtOut->Format();

  // get input type index

  if (*mtIn->Subtype()==MEDIASUBTYPE_WAVE
      || *mtIn->Subtype()==MEDIASUBTYPE_NULL)
  {
    for(i=0;i<NUMSUBTYPES;i++)
      if (lpWfIn->wFormatTag == VALIDFORMATTAG[i])
        break;

    if (i == NUMSUBTYPES)
    {
      DbgMsg("Bad input SubType/FormatTag in CheckTransform!");
      return E_UNEXPECTED;
    }
  }
  else
  {
    for(i=0;i<NUMSUBTYPES;i++)
      if (*mtIn->Subtype() == *VALIDSUBTYPE[i])
        break;

    if (i == NUMSUBTYPES)
    {
      DbgMsg("Bad input SubType in CheckTransform!");
      return E_UNEXPECTED;
    }
  }

  // get output type index

  if (*mtOut->Subtype()==MEDIASUBTYPE_WAVE
      || *mtOut->Subtype()==MEDIASUBTYPE_NULL)
  {
    for(j=0;j<NUMSUBTYPES;j++)
      if (lpWfOut->wFormatTag == VALIDFORMATTAG[j])
        break;

    if (j == NUMSUBTYPES)
    {
      DbgMsg("Bad output SubType/FormatTag in CheckTransform!");
      return E_UNEXPECTED;
    }
  }
  else
  {
    for(j=0;j<NUMSUBTYPES;j++)
      if (*mtOut->Subtype() == *VALIDSUBTYPE[j])
        break;

    if (j == NUMSUBTYPES)
    {
      DbgMsg("Bad output SubType in CheckTransform!");
      return E_UNEXPECTED;
    }
  }

  // Check input/output type pair

  if (!VALIDTRANS[i * NUMSUBTYPES + j])
  {
    DbgMsg("Invalid transform pair!");
    return E_UNEXPECTED;
  }

  // Check that number of channels match

  if(lpWfIn->nChannels != lpWfOut->nChannels)
  {
    DbgMsg("Number of channels do not match!");
    return E_UNEXPECTED;
  }

  // Check that sample rates are supported

#if NUMSAMPRATES==0

  // if unrestricted, make sure input & output match

  if (lpWfIn->nSamplesPerSec != lpWfOut->nSamplesPerSec)
  {
    DbgMsg("Input and output sample rates do not match!");
    return E_UNEXPECTED;
  }

#else

  // if sample rate is restricted, make sure it is supported

  if (m_InputSubType == MEDIASUBTYPE_PCM
      || ((m_InputSubType == MEDIASUBTYPE_WAVE
           || m_InputSubType == MEDIASUBTYPE_NULL)
          && m_InputFormatTag == WAVE_FORMAT_PCM))   // compressing?
  {
    for(int i=0;i<NUMSAMPRATES;i++)
      if (lpWfIn->nSamplesPerSec == VALIDSAMPRATE[i])
        break;

    if (i == NUMSAMPRATES)
    {
      DbgMsg("Wrong input SamplesPerSec!");
      return E_UNEXPECTED;
    }

    if (lpWfOut->nSamplesPerSec != NATURALSAMPRATE)
    {
      DbgMsg("Wrong output SamplesPerSec!");
      return E_UNEXPECTED;
    }
  }
  else        // decompressing
  {
    for(int i=0;i<NUMSAMPRATES;i++)
      if (lpWfOut->nSamplesPerSec == VALIDSAMPRATE[i])
        break;

    if (i == NUMSAMPRATES)
    {
      DbgMsg("Wrong output SamplesPerSec!");
      return E_UNEXPECTED;
    }

    if (lpWfIn->nSamplesPerSec != NATURALSAMPRATE)
    {
      DbgMsg("Wrong input SamplesPerSec!");
      return E_UNEXPECTED;
    }
  }
#endif

  return NOERROR;
} // end CheckTransform


//
// DecideBufferSize
//
// Here we need to tell the output pin's allocator what size buffers we
// require. This can only be known when the input is connected and the 
// transform is established.  Are stands is - the output must be >=
// the input after the transform has been applied.
//

HRESULT CG711Codec::DecideBufferSize(IMemAllocator *pAlloc,
                                ALLOCATOR_PROPERTIES *pProperties)
{
    CAutoLock l(&m_MyCodecLock); // enter critical section auto free
                                 // at end of scope

    IMemAllocator *pMemAllocator;
    ALLOCATOR_PROPERTIES Request,Actual;
    int cbBuffer;

    DbgFunc("DecideBufferSize");

    // can only proceed if there's a media type on the input
    if (!m_pInput->IsConnected())
    {
        DbgMsg("Input pin not connected--cannot decide buffer size!");
        return E_UNEXPECTED;
    }

    
    // Get the input pin allocator, and get its size and count.
    // we don't care about his alignment and prefix.

    HRESULT hr = m_pInput->GetAllocator(&pMemAllocator);
    
    if (FAILED(hr))
    {
        DbgMsg("Out of memory in DecideBufferSize!");
        return hr;
    }

    hr = pMemAllocator->GetProperties(&Request);
    
    // we are read only so release
    pMemAllocator->Release();

    if (FAILED(hr))
    {
        return hr;
    }

    m_nInBufferSize  = Request.cbBuffer;

    DbgLog((LOG_MEMORY,1,TEXT("Setting Allocator Requirements")));
    DbgLog((LOG_MEMORY,1,TEXT("Input Buffer Count %d, Size %d"),
           Request.cBuffers, Request.cbBuffer));

    // check buffer requirements against our compression ratio

    if ((m_InputSubType == MEDIASUBTYPE_PCM)      // compressing?
        || (m_InputSubType == MEDIASUBTYPE_WAVE
            && m_InputFormatTag == WAVE_FORMAT_PCM)
          || (m_InputSubType == MEDIASUBTYPE_NULL
              && m_InputFormatTag == WAVE_FORMAT_PCM))
    {
#if NUMSAMPRATES > 1
      cbBuffer = Request.cbBuffer * NATURALSAMPRATE
                 / (COMPRESSION_RATIO[m_nBitRateIndex] * m_nSampleRate);

      if (cbBuffer * (COMPRESSION_RATIO[m_nBitRateIndex] * m_nSampleRate)
          != (Request.cbBuffer * ((UINT)NATURALSAMPRATE)))
      {
        cbBuffer += 1;  // add extra space for non-integer (on avg) part
      }
#else
      cbBuffer = Request.cbBuffer / COMPRESSION_RATIO[m_nBitRateIndex];

      if (cbBuffer * COMPRESSION_RATIO[m_nBitRateIndex] != Request.cbBuffer)
      {
        cbBuffer += 1;  // add extra space for non-integer (on avg) part
      }
#endif
      // force buffer size to be multiple of code frame size

      if (cbBuffer % VALIDCODSIZE[m_nBitRateIndex] != 0)
        cbBuffer = ((1 + cbBuffer / VALIDCODSIZE[m_nBitRateIndex])
                    * VALIDCODSIZE[m_nBitRateIndex]);
    }
    else     // decompressing
    {
      // Since we assume that the decoder can handle changes in bit
      // rate on the fly (or silence frames), we must consider the
      // maximum compression ratio when allocating buffers.

#if NUMSAMPRATES > 1
      cbBuffer = Request.cbBuffer * MAXCOMPRATIO * m_nSampleRate
                 / NATURALSAMPRATE;
#else
      cbBuffer = Request.cbBuffer * MAXCOMPRATIO;
#endif
    }

    // Pass the allocator requirements to our output side
    pProperties->cBuffers = Request.cBuffers; // the # of buffers must match
    pProperties->cbBuffer = cbBuffer;         // compression adjusted buffer
                                              // size

    m_nOutBufferSize = 0;                // clear this in case the set fails

    hr = pAlloc->SetProperties(pProperties, &Actual);

    if (FAILED(hr))
    {
        DbgMsg("Out of memory in DecideBufferSize!");
        return hr;
    }

    DbgLog((LOG_MEMORY,1,TEXT("Obtained Allocator Requirements")));
    DbgLog((LOG_MEMORY,1,
           TEXT("Output Buffer Count %d, Size %d, Alignment %d"),
           Actual.cBuffers, Actual.cbBuffer, Actual.cbAlign));

    // Make sure we obtained at least the minimum required size

    if ((Request.cBuffers > Actual.cBuffers) || (cbBuffer > Actual.cbBuffer))
    {
        DbgMsg("Allocator cannot satisfy request in DecideBufferSize!");
        return E_FAIL;
    }

    m_nOutBufferSize = Actual.cbBuffer;
            
  return NOERROR;

} // end DecideBufferSize


//
// StopStreaming
// 
// This member function resets some buffer variables when the stream
// is stopped.
//
HRESULT CG711Codec::StopStreaming()
{
  m_nPCMLeftover = 0;
  m_nCODLeftover = 0;

#if NUMSAMPRATES > 1
  m_nSRCCount    = 0;
  m_nSRCLeftover = 0;
#endif

  return(NOERROR);
}


//
// GetMediaType
// 
// This member function returns our preffered output media types by
// position.  It is called when an output pin is to be connected.  The
// types that are emumerated are based on the input format already
// connected.  If the input is linear PCM then we enumerate the 
// compressed types at the rate and channels of the input.  If the input
// is compressed, then we enumorate only 16 bit PCM.
//
HRESULT CG711Codec::GetMediaType(int iPosition, CMediaType *pMediaType)
{
    LPWAVEFORMATEX lpWf;
    HRESULT returnValue = NOERROR;  // we're optimistic
    int     ForceiPos = 0;
    int     i;

    CAutoLock l(&m_MyCodecLock);    // freed on end of scope

    DbgFunc("GetMediaType");

    // we must be connected to know our output pin media type
    if(!m_pInput->IsConnected())
    {
      DbgMsg("Input pin not connected in MyCodec::GetMediaType!");
      return E_UNEXPECTED;
    }

    // must be +
    if(iPosition < 0 )
    {
      DbgMsg("Negative index in MyCodec::GetMediaType!");
      return E_INVALIDARG;
    }

    // copy input to output with operator override
    *pMediaType = m_pInput->CurrentMediaType();

    // reflect compression type by overwriting params
    lpWf = (LPWAVEFORMATEX)pMediaType->pbFormat;

    // dlg this is not realy out of memory
    if(lpWf == NULL)
    {
      DbgMsg("Missing WAVEFORMAT in MyCodec::GetMediaType!");
      return E_INVALIDARG;
    }

    // Enumeration doesn't make sense if capabilities have been restricted.
    // In this case, the current pin types are the only types supported.
    //
    if (m_RestrictCaps)
    {
      if (iPosition > 0)
        returnValue = VFW_S_NO_MORE_ITEMS;
      else
      {
        ForceiPos = 0;                 // PCM output case
        for(i=1;i<NUMSUBTYPES;i++)     // compressed cases
          if (m_OutputSubType == *VALIDSUBTYPE[i])
            ForceiPos = i-1;
      }
    }
    else ForceiPos = iPosition;

    // Check to see if there are any more formats left

    if (ForceiPos >= NUMSUBTYPES-1)  // subtract one for PCM
    {
      returnValue = VFW_S_NO_MORE_ITEMS;
    }
    else
    {
      // Based on input format enumerate output formats

      if ((m_InputSubType == MEDIASUBTYPE_PCM)      // compressing?
          || (m_InputSubType == MEDIASUBTYPE_WAVE
              && lpWf->wFormatTag == WAVE_FORMAT_PCM)
          || (m_InputSubType == MEDIASUBTYPE_NULL
              && lpWf->wFormatTag == WAVE_FORMAT_PCM))
      {
        pMediaType->SetSubtype(VALIDSUBTYPE[ForceiPos+1]);
        lpWf->wFormatTag       = VALIDFORMATTAG[ForceiPos+1];
        lpWf->wBitsPerSample   = lpWf->wBitsPerSample
                                 / COMPRESSION_RATIO[m_nBitRateIndex];
        lpWf->nBlockAlign      = lpWf->wBitsPerSample * lpWf->nChannels / 8;
#if NUMSAMPRATES==0
        lpWf->nSamplesPerSec = m_nSampleRate;
#else
        lpWf->nSamplesPerSec = NATURALSAMPRATE;
#endif
        lpWf->nAvgBytesPerSec  = (int) ((DWORD) lpWf->nBlockAlign *
                                               lpWf->nSamplesPerSec);
      }
      else
      {
        pMediaType->SetSubtype(&MEDIASUBTYPE_PCM);
        lpWf->wFormatTag      = WAVE_FORMAT_PCM;
        lpWf->wBitsPerSample  = 16;        // only 16-bit PCM is supported
        lpWf->nBlockAlign     = lpWf->wBitsPerSample * lpWf->nChannels / 8;
        lpWf->nSamplesPerSec  = m_nSampleRate;
        lpWf->nAvgBytesPerSec = (int) ((DWORD) lpWf->nBlockAlign *
                                               lpWf->nSamplesPerSec);
      }
    }
    return returnValue;

} // end GetMediaType


//
// SetMediaType
//
// This function is called when a connection attempt has succeeded.
// It indicates to the filter that a wave type has been settled upon
// for this pin.  Here we snap shot the format tag and channel.  The
// format allows us to easily know which conversion to perform during
// the transform function.  This information could be condensed down
// by establishing a function pointer based on this information.
// (rather than checking these flags in the transform).  Also it MIGHT
// be necessary to locking access to these format values incase they
// change on the fly. Our current assumption is the transform will
// cease prior to these values changing in this function call.
//
//
HRESULT CG711Codec::SetMediaType(PIN_DIRECTION direction,
                                 const CMediaType *pmt){

    CAutoLock l(&m_MyCodecLock); // enter critical section auto free
                                 // at end of scope

    DbgFunc("SetMediaType");

    // Record what we need for doing the actual transform 
    // this could be done by querying the media type also 

    LPWAVEFORMATEX lpWf = (LPWAVEFORMATEX) pmt->Format();

    switch(direction)
    {
      case PINDIR_INPUT:
        m_InputSubType   = *pmt->Subtype();
        m_InputFormatTag = lpWf->wFormatTag;
        m_nChannels      = lpWf->nChannels;
#if NUMSAMPRATES==0
        // sample rate is unrestricted

        m_nSampleRate    = lpWf->nSamplesPerSec;
#else
        // when sample rate is restricted, the sample rate of the
        // compressed data is fixed at NATURALSAMPRATE and the sample
        // rate of the PCM data is one of the supported rates

        if ((m_InputSubType == MEDIASUBTYPE_PCM)
            || ((m_InputSubType == MEDIASUBTYPE_WAVE
                 || m_InputSubType == MEDIASUBTYPE_NULL)
                && m_InputFormatTag == WAVE_FORMAT_PCM))
          m_nSampleRate    = lpWf->nSamplesPerSec;
#endif
        break;
    
      case PINDIR_OUTPUT:
        m_OutputSubType   = *pmt->Subtype();
        m_OutputFormatTag = lpWf->wFormatTag;
        m_nChannels       = lpWf->nChannels;
        break;

      default:
        ASSERT(0);
        return E_UNEXPECTED;
    } // end of direction switch 
     

    // Call the base class to do its thing
    HRESULT hr = CTransformFilter::SetMediaType(direction, pmt);

    if (FAILED(hr)) return hr;

    hr = InitializeState(direction);

    return hr;

} // end SetMediaType


//
// InitializeState
//
HRESULT CG711Codec::InitializeState(PIN_DIRECTION direction)
{
  if (direction == PINDIR_OUTPUT)
  {
    // dynamically allocate encoder or decoder structure

    if ((m_InputSubType == MEDIASUBTYPE_PCM)      // compressing?
        || (m_InputSubType == MEDIASUBTYPE_WAVE
            && m_InputFormatTag == WAVE_FORMAT_PCM)
          || (m_InputSubType == MEDIASUBTYPE_NULL
              && m_InputFormatTag == WAVE_FORMAT_PCM))
    {
      //encoder

      if (m_EncStatePtr == NULL)
      {
        m_EncStatePtr = (ENCODERobj *)CoTaskMemAlloc(sizeof(ENCODERobj));

        if (m_EncStatePtr == NULL)
        {
          return E_OUTOFMEMORY;
        }

        // call the encoder initialization function
        // This macro is empty for this codec.
        // ENC_create(m_EncStatePtr, m_nBitRate, m_nSilDetEnabled, m_UseMMX);

#ifdef USESILDET
        SILDETTHRESH(m_EncStatePtr, m_nSilDetThresh);
#endif
      }
    }
    else
    {
      //decoder

      if (m_DecStatePtr == NULL)
      {
        m_DecStatePtr = (DECODERobj *)CoTaskMemAlloc(sizeof(DECODERobj));

        if (m_DecStatePtr == NULL)
        {
          return E_OUTOFMEMORY;
        }

        //call the decoder initialization function
        // This macro is empty for this codec.
        // DEC_create(m_DecStatePtr, m_nBitRate, m_nSilDetEnabled, m_UseMMX);
      }
    }
  }
  return NOERROR;

} // end of InitializeState


//
//  GetPin - allocates the MyCodec input and output pins
//
//  This function will be called to get the pointer to
//  the input and output pins by the filter graph manager,
//  once after instantiating the object.
//
CBasePin* CG711Codec::GetPin(int n)
{
    HRESULT hr = S_OK;

    if (m_pInput == NULL )        // Instantiate the INPUT pin
    {
        m_pInput = new CMyTransformInputPin(
                NAME("MyTransform input pin"),
                this,      // Owner filter
                &hr,       // Result code
                L"Input"   // Pin name 
                );
    
        // a failed return code should delete the object
        if (FAILED(hr))
        {
            delete m_pInput;
            m_pInput = NULL;
            return NULL;
        }
    }
    
    if (m_pOutput == NULL)      // Instantiate the OUTPUT pin
    {
        m_pOutput = new CMyTransformOutputPin(
                NAME("MyTransform output pin"),
                this,       // Owner filter
                &hr,        // Result code
                L"Output"   // Pin name 
                ); 
        
        // failed return codes cause both objects to be deleted
        if (FAILED(hr))
        {
            delete m_pInput;
            m_pInput = NULL;

            delete m_pOutput;
            m_pOutput = NULL;
            return NULL;
        }
    }

    // Find which pin is required
    switch(n)
    {
    case 0:
        return m_pInput;
    
    case 1:
        return m_pOutput;
    }

    return NULL;
}


///////////////////////////////////////////////////////////////////////
// *
// * Input Pin (supports enumeration of input pin types)
// *

//
// CMyTransformInputPin - Constructor
//
CMyTransformInputPin::CMyTransformInputPin(TCHAR *pObjectName,
                                       CTransformFilter *pTransformFilter,
                                       HRESULT * phr,
                                       LPCWSTR pName)
    : CTransformInputPin(pObjectName, pTransformFilter, phr, pName)
{
    m_nThisInstance = ++m_nInstanceCount;
    DbgFunc("CMyTransformInputPin");
}


// Initialise our instance count for debugging purposes
int CMyTransformInputPin::m_nInstanceCount = 0;

//
// GetMediaType - an override so that we can enumerate input types
//
HRESULT CMyTransformInputPin::GetMediaType(int iPosition, 
                                           CMediaType *pMediaType)
{
    LPWAVEFORMATEX lpWf;
    CG711Codec *pMyCodec;
    int ForceiPos;
    int channels;
    int restricted;
    int samprate;
    int transform;

    CAutoLock l(m_pLock);                       // freed on end of scope

    DbgFunc("CBaseInputPin::GetMediaType");

    pMyCodec = (CG711Codec *) m_pTransformFilter; // access MyCodec interface

    // we must be disconnected to set our input pin media type

	// ZCS bugfix 6-26-97
    //if(!pMyCodec->IsUnPlugged())
    //{
    //  DbgMsg("Must be disconnected to query input pin!");
    //  return E_UNEXPECTED;
    //}

    // must be +
    if(iPosition < 0 )
    {
      DbgMsg("Negative index!");
      return E_INVALIDARG;
    }

    pMyCodec->get_Channels(&channels, -1);
    pMyCodec->RevealCaps(&restricted);
    pMyCodec->get_SampleRate(&samprate, -1);
    pMyCodec->get_Transform(&transform);

    // initialize mediatype

    pMediaType->SetType(&MEDIATYPE_Audio);
    pMediaType->SetFormatType(&FORMAT_WaveFormatEx);
    pMediaType->ReallocFormatBuffer(sizeof(WAVEFORMATEX));
    lpWf = (LPWAVEFORMATEX)pMediaType->pbFormat;
    if(lpWf == NULL)
    {
      DbgMsg("Unable to allocate WAVEFORMATEX structure!");
      return E_OUTOFMEMORY;
    }
    lpWf->nChannels      = (WORD)channels;
    lpWf->nSamplesPerSec = samprate;
    lpWf->cbSize = 0;

    // Enumeration doesn't make sense if capabilities have been restricted.
    // In this case, the current pin types are the only types supported.
    //
    if (restricted)
    {
      if (iPosition > 0)
        return VFW_S_NO_MORE_ITEMS;
      else
        ForceiPos = transform / NUMSUBTYPES;  // input type index
    }
    else ForceiPos = iPosition;

    // Check to see if there are any more formats left

    if (ForceiPos >= NUMSUBTYPES)
    {
      return VFW_S_NO_MORE_ITEMS;
    }
    else
    {
      pMediaType->SetSubtype(VALIDSUBTYPE[ForceiPos]);

      lpWf->wFormatTag      = VALIDFORMATTAG[ForceiPos];
      lpWf->wBitsPerSample  = (WORD)VALIDBITSPERSAMP[ForceiPos];
      lpWf->nChannels       = (WORD)channels;
      lpWf->nBlockAlign     = lpWf->wBitsPerSample * lpWf->nChannels / 8;

      if (VALIDFORMATTAG[ForceiPos] == WAVE_FORMAT_PCM)
        lpWf->nSamplesPerSec = samprate;
      else
        lpWf->nSamplesPerSec = NATURALSAMPRATE;

      lpWf->nAvgBytesPerSec = (int) ((DWORD) lpWf->nBlockAlign *
                                             lpWf->nSamplesPerSec);
      lpWf->cbSize = 0;
      return NOERROR;
    }
} // end CBaseInputPin::GetMediaType

//
//  CheckMediaType - check if mediatype is supported by MyCodec
//
//  Called from the Connect\AgreeMediaType\TryMediaType of the 
//  upstream filter's output pin.
//
HRESULT CMyTransformInputPin::CheckMediaType(const CMediaType *mtIn )
{
  DbgFunc("CMyTransformInputPin::CheckMediaType");

  // Validate the parameter
  CheckPointer(mtIn,E_INVALIDARG);
  ValidateReadWritePtr(mtIn,sizeof(CMediaType));

  return ((CG711Codec *)m_pTransformFilter)->ValidateMediaType(mtIn,
                                                             PINDIR_INPUT);
}


///////////////////////////////////////////////////////////////////////
// *
// * Output Pin (fixes the connection model when enumeration of input
// * pin types is required)
// *

//
// CMyTransformOutputPin - Constructor
//
CMyTransformOutputPin::CMyTransformOutputPin(TCHAR *pObjectName,
                                       CTransformFilter *pTransformFilter,
                                       HRESULT * phr,
                                       LPCWSTR pName)
    : CTransformOutputPin(pObjectName, pTransformFilter, phr, pName)
{
    m_nThisInstance = ++m_nInstanceCount;
    DbgFunc("CMyTransformOutputPin");
}


// Initialise our instance count for debugging purposes
int CMyTransformOutputPin::m_nInstanceCount = 0;

//
//  CheckMediaType - check if mediatype is supported by MyCodec
//
//  Called by MyCodec's output pin.
//
HRESULT CMyTransformOutputPin::CheckMediaType(const CMediaType *mtIn )
{
  DbgFunc("CMyTransformOutputPin::CheckMediaType");

  // Validate the parameter
  CheckPointer(mtIn,E_INVALIDARG);
  ValidateReadWritePtr(mtIn,sizeof(CMediaType));

  return ((CG711Codec *)m_pTransformFilter)->ValidateMediaType(mtIn,
                                                             PINDIR_OUTPUT);
}


///////////////////////////////////////////////////////////////////////
// *
// * Persistent stream (supports saving filter graph to .grf file)
// *

STDMETHODIMP CG711Codec::GetClassID(CLSID *pClsid)
{
  *pClsid = CLSID_G711Codec;

  return NOERROR;
}


// This return value must be >= the persistent data size stored
int CG711Codec::SizeMax()
{
  return (5*sizeof(int) + 4);   // 4 for good luck only
}

//
// WriteToStream
//
// Dump necessary member variables to an unknown stream for later use.
// This information is necessary for the filter to properly transform
// without type negotiation.  you must change SizeMax above if these
// change.
//
HRESULT CG711Codec::WriteToStream(IStream *pStream)
{
    HRESULT hr;
    int     transform;

    get_Transform(&transform);

    hr = WriteInt(pStream, transform);

    if (FAILED(hr)) return hr;
    
    hr = WriteInt(pStream, m_nChannels);
    if (FAILED(hr)) return hr;
    
    hr = WriteInt(pStream, m_nSampleRate);
    if (FAILED(hr)) return hr;
    
    hr = WriteInt(pStream, m_nBitRateIndex);
    if (FAILED(hr)) return hr;
    
    hr = WriteInt(pStream, m_nSilDetEnabled);
    if (FAILED(hr)) return hr;
    
    return NOERROR;
}

//
// ReadFromStream
//
// Read back the above persistent information in the same order? 
// NOTE: any info captured during negotiation that is needed 
//       during run time must be restored at this point. 
//
HRESULT CG711Codec::ReadFromStream(IStream *pStream)
{
    HRESULT hr;
    int i,j,k;

    i = ReadInt(pStream, hr);
    if (FAILED(hr)) return hr;

    j = i / NUMSUBTYPES;
    k = i - j * NUMSUBTYPES;

    if (j < 0 || k < 0 || j >= NUMSUBTYPES || k >= NUMSUBTYPES)
    {
      DbgMsg("Invalid transform type in saved filter graph!");
      return(E_UNEXPECTED);
    }

    m_InputSubType    = *VALIDSUBTYPE[j];
    m_InputFormatTag  = VALIDFORMATTAG[j];
    m_OutputSubType   = *VALIDSUBTYPE[k];
    m_OutputFormatTag = VALIDFORMATTAG[k];

    m_nChannels = ReadInt(pStream, hr);
    if (FAILED(hr)) return hr;

    m_nSampleRate = ReadInt(pStream, hr);
    if (FAILED(hr)) return hr;

    m_nBitRateIndex = ReadInt(pStream, hr);
    if (FAILED(hr)) return hr;
    m_nBitRate = VALIDBITRATE[m_nBitRateIndex];

    m_nSilDetEnabled = ReadInt(pStream, hr);
    if (FAILED(hr)) return hr;

    m_RestrictCaps = TRUE;     // restrict capabilities to those read
                               // from the persistence file

    hr = InitializeState(PINDIR_OUTPUT);

    return hr;
}


//
// GetPages
//
// Returns the clsid's of the property pages we support
STDMETHODIMP CG711Codec::GetPages(CAUUID *pPages)
{
    if (IsBadWritePtr(pPages, sizeof(CAUUID)))
    {
        return E_POINTER;
    }

    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
    if (pPages->pElems == NULL)
    {
        return E_OUTOFMEMORY;
    }

    *(pPages->pElems) = CLSID_G711CodecPropertyPage;

    return NOERROR;
}


//
// ResetState:  Deallocates coder state if necessary
//
STDMETHODIMP  CG711Codec::ResetState()
{
  if (m_EncStatePtr != NULL)
    CoTaskMemFree(m_EncStatePtr);

  if (m_DecStatePtr != NULL)
    CoTaskMemFree(m_DecStatePtr);

  m_EncStatePtr = NULL;
  m_DecStatePtr = NULL;

  return NOERROR;
}


//
// RevealCaps:  Return restrictions
//
STDMETHODIMP  CG711Codec::RevealCaps(int *restricted)
{
  *restricted = m_RestrictCaps;

  return NOERROR;
}


/*
//$Log:   K:\proj\mycodec\quartz\vcs\amacodec.cpv  $
# 
#    Rev 1.3   10 Dec 1996 22:41:18   mdeisher
# ifdef'ed out SRC vars when SRC not used.
# 
#    Rev 1.2   10 Dec 1996 15:19:48   MDEISHER
# removed unnecessary includes.
# moved debugging macros to header.
# added DEFG711GLOBALS so that globals are only defined once.
# ifdef'ed out the licensing checks when license interface not present.
# 
#    Rev 1.1   09 Dec 1996 09:26:58   MDEISHER
# 
# moved sample rate conversion method to separate file.
# 
#    Rev 1.0   09 Dec 1996 09:05:56   MDEISHER
# Initial revision.
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\litesabr\filters\codecs\g711\iamacbr.cpp ===
/*--------------------------------------------------------------

 INTEL Corporation Proprietary Information  

 This listing is supplied under the terms of a license agreement  
 with INTEL Corporation and may not be copied nor disclosed 
 except in accordance with the terms of that agreement.

 Copyright (c) 1996 Intel Corporation.
 All rights reserved.

 $Workfile:   iamacbr.cpp  $
 $Revision:   1.1  $
 $Date:   10 Dec 1996 15:28:38  $ 
 $Author:   MDEISHER  $

--------------------------------------------------------------

iamacbr.cpp

The generic ActiveMovie audio compression filter bit rate
settings methods.

--------------------------------------------------------------*/

#include <streams.h>
#include "resource.h"
#include "amacodec.h"

#if NUMBITRATES > 0
///////////////////////////////////////////////////////////////////////
// *
// * ICodecBitRate interface methods
// *

//
// get_BitRate
//
STDMETHODIMP CG711Codec::get_BitRate(int *bitrate, int index)
{
  HRESULT ReturnVal=NOERROR;

  // Since bit-rate information is passed "in-band" to the decoder
  // only the encoder has a bit-rate setting.

  if ((m_InputSubType == MEDIASUBTYPE_PCM)      // compressing?
      || (m_InputSubType == MEDIASUBTYPE_WAVE
          && m_InputFormatTag == WAVE_FORMAT_PCM)
      || (m_InputSubType == MEDIASUBTYPE_NULL
          && m_InputFormatTag == WAVE_FORMAT_PCM))
  {
    if (index == -1)
    {
      *bitrate = m_nBitRate;
    }
    else if (index != -1 && (index < 0 || index >= NUMBITRATES))
    {
      ReturnVal = E_INVALIDARG;
    }
    else  // enumerate bit rates
    {
      *bitrate = VALIDBITRATE[index];
    }
  }
  else ReturnVal = E_FAIL;

  return ReturnVal;
}


//
// put_BitRate
//
STDMETHODIMP CG711Codec::put_BitRate(int bitrate)
{
  int i;

  // Since bit-rate information is passed "in-band" to the decoder
  // only the encoder has a bit-rate setting.

  if ((m_InputSubType == MEDIASUBTYPE_PCM)      // compressing?
      || (m_InputSubType == MEDIASUBTYPE_WAVE
          && m_InputFormatTag == WAVE_FORMAT_PCM)
      || (m_InputSubType == MEDIASUBTYPE_NULL
          && m_InputFormatTag == WAVE_FORMAT_PCM))
  {
    // if the filter is disconnected, then change bitrate

    if (IsUnPlugged())
    {
      for(i=0;i<NUMBITRATES;i++)
        if (VALIDBITRATE[i] == (UINT)bitrate)
          break;

      if (i == NUMBITRATES)
      {
        DbgMsg("Bad bit-rate in put_BitRate!");
        return(E_INVALIDARG);
      }

      m_nBitRate      = bitrate;
      m_nBitRateIndex = i;
      m_nCODFrameSize = VALIDCODSIZE[m_nBitRateIndex];

      ResetState();  // change in bitrate means need to re-initialize coder

      // restrict capabilities to those set from the properties page

      m_RestrictCaps = TRUE;
  
      return NOERROR;
    }
    else return E_FAIL;
  }
  else return E_FAIL;
}
#endif

/*
//$Log:   K:\proj\mycodec\quartz\vcs\iamacbr.cpv  $
# 
#    Rev 1.1   10 Dec 1996 15:28:38   MDEISHER
# 
# added includes, removed include of algdefs.h.
# 
#    Rev 1.0   09 Dec 1996 08:58:46   MDEISHER
# Initial revision.
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\litesabr\filters\codecs\g711\amacprop.cpp ===
/*--------------------------------------------------------------

 INTEL Corporation Proprietary Information  

 This listing is supplied under the terms of a license agreement  
 with INTEL Corporation and may not be copied nor disclosed 
 except in accordance with the terms of that agreement.

 Copyright (c) 1996 Intel Corporation.
 All rights reserved.

 $Workfile:   amacprop.cpp  $
 $Revision:   1.1  $
 $Date:   10 Dec 1996 15:24:30  $ 
 $Author:   MDEISHER  $

--------------------------------------------------------------

amacprop.cpp

The generic ActiveMovie audio compression filter property page.

--------------------------------------------------------------*/

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <streams.h>
#include "resource.h"
#include "amacodec.h"
#include "amacprop.h"

///////////////////////////////////////////////////////////////////////
// *
// * CG711CodecProperties
// *

//
// CreateInstance
//
// The only allowed way to create Bouncing ball's!
CUnknown *CG711CodecProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
  CUnknown *punk = new CG711CodecProperties(lpunk, phr);
  if (punk == NULL)
  {
    *phr = E_OUTOFMEMORY;
  }

  return punk;
}


//
// CG711CodecProperties::Constructor
//
CG711CodecProperties::CG711CodecProperties(LPUNKNOWN pUnk, HRESULT *phr)
    : CBasePropertyPage(NAME("MyCodec Property Page"),pUnk,
        IDD_G711CodecPROP, IDS_TITLE)
    , m_pCodecSettings(NULL)
#if NUMBITRATES > 0
    , m_pCodecBitRate(NULL)
#endif
#ifdef USESILDET
    , m_pCodecSilDet(NULL)
#endif
    , m_iTransformType(0)
    , m_iBitRate(0)
    , m_iSampleRate(0)
#ifdef USESILDET
    , m_iSilDetEnabled(FALSE)
    , m_iSilDetThresh(DEFSDTHRESH)
#endif
{
}


//
// OnReceiveMessages
//
// Handles the messages for our property window

INT_PTR CG711CodecProperties::OnReceiveMessage( HWND hwnd
                                , UINT uMsg
                                , WPARAM wParam
                                , LPARAM lParam) 
{
  int i,j,k;

  switch (uMsg)
  {
    case WM_PROPERTYPAGE_ENABLE:

      // private message to enable/disable controls.  if lParam, then
      // enable the controls that affect the format; if not lParam,
      // then disable the controls that affect the format.

      for(i=0;i<NUMSUBTYPES;i++)
        EnableWindow(GetDlgItem (hwnd, INBUTTON[i]), (BOOL) lParam);

      for(i=0;i<NUMSUBTYPES;i++)
        EnableWindow(GetDlgItem (hwnd, OUTBUTTON[i]), (BOOL) lParam);

      for(i=0;i<NUMSAMPRATES;i++)
        EnableWindow(GetDlgItem (hwnd, SRBUTTON[i]), (BOOL) lParam);

      if (m_iTransformType / NUMSUBTYPES)  // 0 ==> compressing
      {
        for(i=0;i<NUMENCCTRLS;i++)
          EnableWindow(GetDlgItem (hwnd, ENCBUTTON[i]), (BOOL) FALSE);

        for(i=0;i<NUMDECCTRLS;i++)
          EnableWindow(GetDlgItem (hwnd, DECBUTTON[i]), (BOOL) lParam);

#ifdef USESILDET
        EnableWindow(GetDlgItem (hwnd, IDC_SDTHRESH), (BOOL) FALSE);
#endif
      }
      else
      {
        for(i=0;i<NUMENCCTRLS;i++)
          EnableWindow(GetDlgItem (hwnd, ENCBUTTON[i]), (BOOL) lParam);

        for(i=0;i<NUMDECCTRLS;i++)
          EnableWindow(GetDlgItem (hwnd, DECBUTTON[i]), (BOOL) FALSE);

#ifdef USESILDET
        if (m_iSilDetEnabled)
          EnableWindow(GetDlgItem (hwnd, IDC_SDTHRESH), (BOOL) TRUE);
        else
          EnableWindow(GetDlgItem (hwnd, IDC_SDTHRESH), (BOOL) FALSE);
#endif
      }

      break;

    case WM_HSCROLL:
    case WM_VSCROLL:
#ifdef USESILDET
      if ((HWND) lParam == m_hwndSDThreshSlider)
        OnSliderNotification(LOWORD (wParam), HIWORD (wParam));
#endif
      return TRUE;

    case WM_COMMAND:

      // find input & output types

      i = m_iTransformType / NUMSUBTYPES;     // current input type
      j = m_iTransformType - i * NUMSUBTYPES; // current output type

      // if input button was pushed then set transform

      for(k=0;k<NUMSUBTYPES;k++)
        if (LOWORD(wParam) == INBUTTON[k])
        {
          // if transform is not valid then find one that is

          if (! VALIDTRANS[k*NUMSUBTYPES+j])
            for(j=0;j<NUMSUBTYPES;j++)
              if (VALIDTRANS[k*NUMSUBTYPES+j])
                break;

          m_pCodecSettings->put_Transform(k*NUMSUBTYPES+j);

          break;
        }

      // if output button was pushed then set transform

      for(k=0;k<NUMSUBTYPES;k++)
        if (LOWORD(wParam) == OUTBUTTON[k])
        {
          // if transform is not valid then find one that is

          if (! VALIDTRANS[i*NUMSUBTYPES+k])
            for(i=0;i<NUMSUBTYPES;i++)
              if (VALIDTRANS[i*NUMSUBTYPES+k])
                break;

          m_pCodecSettings->put_Transform(i*NUMSUBTYPES+k);

          break;
        }

      // if sample rate button was pushed then set it

      for(k=0;k<NUMSAMPRATES;k++)
        if (LOWORD(wParam) == SRBUTTON[k])
        {
          m_pCodecSettings->put_SampleRate(VALIDSAMPRATE[k]);

          break;
        }

#if NUMBITRATES > 0
      // if bit rate button was pushed then set it

      for(k=0;k<NUMBITRATES;k++)
        if (LOWORD(wParam) == BRBUTTON[k])
        {
          m_pCodecBitRate->put_BitRate(VALIDBITRATE[k]);

          break;
        }
#endif

#ifdef USESILDET
      if (LOWORD(wParam) == IDC_SILDET)
      {
        if (m_iSilDetEnabled)                     // toggle state
          m_pCodecSilDet->put_SilDetEnabled(FALSE);
        else
          m_pCodecSilDet->put_SilDetEnabled(TRUE);
      }
#endif

      SetButtons(m_hwnd);
      return TRUE;

      case WM_DESTROY:
        return TRUE;

      default:
        return FALSE;

    }
    return TRUE;
}


//
// RefreshSettings
//
// Read the filter settings

void CG711CodecProperties::RefreshSettings()
{
  int i,j;

  m_pCodecSettings->get_Transform(&m_iTransformType);

#if NUMBITRATES > 0
  m_pCodecBitRate->get_BitRate(&j,-1);
  for(i=0;i<NUMBITRATES;i++)
    if (VALIDBITRATE[i] == (UINT)j)
      break;
  m_iBitRate = i;
#endif

  m_pCodecSettings->get_SampleRate(&j,-1);
  for(i=0;i<NUMSAMPRATES;i++)
    if (VALIDSAMPRATE[i] == (UINT)j)
      break;
  m_iSampleRate = i;

#ifdef USESILDET
  m_iSilDetEnabled = m_pCodecSilDet->IsSilDetEnabled();
  m_pCodecSilDet->get_SilDetThresh(&m_iSilDetThresh);
#endif

}


//
// OnConnect
//
// Give us the filter to communicate with

HRESULT CG711CodecProperties::OnConnect(IUnknown *punk)
{
  HRESULT hr;

  //
  // Get ICodecSettings interface
  //

  if (punk == NULL)
  {
    DbgMsg("You can't call OnConnect() with a NULL pointer!!");
    return(E_POINTER);
  }

  ASSERT(m_pCodecSettings == NULL);
  hr = punk->QueryInterface(IID_ICodecSettings, (void **)&m_pCodecSettings);
  if (FAILED(hr))
  {
    DbgMsg("Can't get ICodecSettings interface.");
    return E_NOINTERFACE;
  }
  ASSERT(m_pCodecSettings);

#if NUMBITRATES > 0
  ASSERT(m_pCodecBitRate == NULL);
  hr = punk->QueryInterface(IID_ICodecBitRate, (void **)&m_pCodecBitRate);
  if (FAILED(hr))
  {
    DbgMsg("Can't get ICodecBitRate interface.");
    return E_NOINTERFACE;
  }
  ASSERT(m_pCodecBitRate);
#endif

#ifdef USESILDET
  ASSERT(m_pCodecSilDet == NULL);
  hr = punk->QueryInterface(IID_ICodecSilDetector, (void **)&m_pCodecSilDet);
  if (FAILED(hr))
  {
    DbgMsg("Can't get ICodecSilDetector interface.");
    return E_NOINTERFACE;
  }
  ASSERT(m_pCodecSilDet);
#endif

  // Get current filter state

  RefreshSettings();

  return NOERROR;
}


//
// OnDisconnect
//
// Release the interface

HRESULT CG711CodecProperties::OnDisconnect()
{
  int i,j;

  // Release the interface

  if (m_pCodecSettings == NULL)
    return(E_UNEXPECTED);

#if NUMBITRATES > 0
  if (m_pCodecBitRate == NULL)
    return(E_UNEXPECTED);
#endif

#ifdef USESILDET
  if (m_pCodecSilDet == NULL)
    return(E_UNEXPECTED);
#endif

  // write settings if possible

  if(m_pCodecSettings->put_Transform(m_iTransformType) != NOERROR)
    m_pCodecSettings->get_Transform(&m_iTransformType);

  if(m_pCodecSettings->put_SampleRate(VALIDSAMPRATE[m_iSampleRate]) != NOERROR)
  {
    m_pCodecSettings->get_SampleRate(&j,-1);
    for(i=0;i<NUMSAMPRATES;i++)
      if (VALIDSAMPRATE[i] == (UINT)j)
        break;
    m_iSampleRate = i;
  }

  m_pCodecSettings->Release();
  m_pCodecSettings = NULL;

#if NUMBITRATES > 0
  if(m_pCodecBitRate->put_BitRate(VALIDSAMPRATE[m_iBitRate]) != NOERROR)
  {
    m_pCodecBitRate->get_BitRate(&j,-1);
    for(i=0;i<NUMBITRATES;i++)
      if (VALIDBITRATE[i] == (UINT)j)
        break;
    m_iBitRate = i;
  }

  m_pCodecBitRate->Release();
  m_pCodecBitRate = NULL;
#endif

#ifdef USESILDET
  if(m_pCodecSilDet->put_SilDetEnabled(m_iSilDetEnabled) != NOERROR)
    m_iSilDetEnabled = m_pCodecSilDet->IsSilDetEnabled();

  if(m_pCodecSilDet->put_SilDetThresh(m_iSilDetThresh) != NOERROR)
    m_pCodecSilDet->get_SilDetThresh(&m_iSilDetThresh);

  m_pCodecSilDet->Release();
  m_pCodecSilDet = NULL;
#endif  // USESILDET

  return(NOERROR);
}


//
// OnActivate
//
// Called on dialog creation

HRESULT CG711CodecProperties::OnActivate(void)
{

#ifdef USESILDET
  // get slider handle
  m_hwndSDThreshSlider = GetDlgItem (m_hwnd, IDC_SDTHRESH);

  // set slider range
  SendMessage(m_hwndSDThreshSlider, TBM_SETRANGE, TRUE,
              MAKELONG(MINSDTHRESH, MAXSDTHRESH) );
#endif

  // initialize button settings

  SetButtons(m_hwnd);

  // Disable the buttons if filter is plugged in

  if (m_pCodecSettings->IsUnPlugged())
    PostMessage (m_hwnd, WM_PROPERTYPAGE_ENABLE, 0, TRUE);
  else
    PostMessage (m_hwnd, WM_PROPERTYPAGE_ENABLE, 0, FALSE);

  return NOERROR;
}


//
// OnDeactivate
//
// We are being deactivated
HRESULT CG711CodecProperties::OnDeactivate(void)
{
  ASSERT(m_pCodecSettings);
#if NUMBITRATES > 0
  ASSERT(m_pCodecBitRate);
#endif
#ifdef USESILDET
  ASSERT(m_pCodecSilDet);
#endif

  RefreshSettings();

  return NOERROR;
}


//
// OnApplyChanges
//
// User pressed the Apply button, remember the current settings

HRESULT CG711CodecProperties::OnApplyChanges(void)
{
  ASSERT(m_pCodecSettings);

  m_pCodecSettings->put_Transform(m_iTransformType);
  m_pCodecSettings->put_SampleRate(VALIDSAMPRATE[m_iSampleRate]);

#if NUMBITRATES > 0
  ASSERT(m_pCodecBitRate);
  m_pCodecBitRate->put_BitRate(VALIDBITRATE[m_iBitRate]);
#endif

#ifdef USESILDET
  ASSERT(m_pCodecSilDet);
  m_pCodecSilDet->put_SilDetEnabled(m_iSilDetEnabled);
  m_pCodecSilDet->put_SilDetThresh(m_iSilDetThresh);
#endif  // USESILDET

  return NOERROR;
}


//
// SetButtons
//

void CG711CodecProperties::SetButtons(HWND hwndParent) 
{
  int i,j;

  // read settings from filter

  RefreshSettings();

  // decode input / output types
    
  if (m_iTransformType < 0 || m_iTransformType >= NUMSUBTYPES*NUMSUBTYPES)
  {
    DbgMsg("Transform type is invalid!");
    i = j = 0;
  }
  else
  {
    i = m_iTransformType / NUMSUBTYPES;
    j = m_iTransformType - i * NUMSUBTYPES;
  }

  // set radio buttons

  CheckRadioButton(hwndParent, INBUTTON[0], INBUTTON[NUMSUBTYPES-1],
                   INBUTTON[i]);

  CheckRadioButton(hwndParent, OUTBUTTON[0], OUTBUTTON[NUMSUBTYPES-1],
                   OUTBUTTON[j]);

  if (NUMBITRATES > 0)
    CheckRadioButton(hwndParent,BRBUTTON[0], BRBUTTON[NUMBITRATES-1],
                     BRBUTTON[m_iBitRate]);

  if (NUMSAMPRATES > 0)
    CheckRadioButton(hwndParent, SRBUTTON[0], SRBUTTON[NUMSAMPRATES-1],
                     SRBUTTON[m_iSampleRate]);

  if (m_iTransformType / NUMSUBTYPES)  // 0 ==> compressing
  {
    for(i=0;i<NUMENCCTRLS;i++)
      EnableWindow(GetDlgItem (hwndParent, ENCBUTTON[i]), (BOOL) FALSE);

    for(i=0;i<NUMDECCTRLS;i++)
      EnableWindow(GetDlgItem (hwndParent, DECBUTTON[i]), (BOOL) TRUE);
 
#ifdef USESILDET
   EnableWindow(GetDlgItem (hwndParent, IDC_SDTHRESH), (BOOL) FALSE);
#endif
  }
  else
  {
    for(i=0;i<NUMENCCTRLS;i++)
      EnableWindow(GetDlgItem (hwndParent, ENCBUTTON[i]), (BOOL) TRUE);
  
    for(i=0;i<NUMDECCTRLS;i++)
      EnableWindow(GetDlgItem (hwndParent, DECBUTTON[i]), (BOOL) FALSE);

#ifdef USESILDET
    CheckDlgButton(hwndParent, IDC_SILDET, m_iSilDetEnabled);

    if (m_iSilDetEnabled)  // enabled?
      EnableWindow(GetDlgItem (hwndParent, IDC_SDTHRESH), (BOOL) TRUE);
    else
      EnableWindow(GetDlgItem (hwndParent, IDC_SDTHRESH), (BOOL) FALSE);

    SendMessage(m_hwndSDThreshSlider, TBM_SETPOS, TRUE,
                (LPARAM) m_iSilDetThresh);
#endif
  }
}


#ifdef USESILDET
//
// OnSliderNotification
//
// Handle the notification messages from the slider control

void CG711CodecProperties::OnSliderNotification(WPARAM wParam, WORD wPosition)
{
  switch (wParam)
  {
    case TB_ENDTRACK:
    case TB_THUMBTRACK:
    case TB_LINEDOWN:
    case TB_LINEUP:
      m_iSilDetThresh = (int)
                        SendMessage(m_hwndSDThreshSlider, TBM_GETPOS, 0, 0L);
      m_pCodecSilDet->put_SilDetThresh(m_iSilDetThresh);
      break;
  }
}
#endif

/*
//$Log:   K:\proj\mycodec\quartz\vcs\amacprop.cpv  $
# 
#    Rev 1.1   10 Dec 1996 15:24:30   MDEISHER
# 
# moved property page specific includes into file.
# removed include of algdefs.h
# 
#    Rev 1.0   09 Dec 1996 09:06:16   MDEISHER
# Initial revision.
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\litesabr\filters\codecs\g711\iamacset.cpp ===
/*--------------------------------------------------------------

 INTEL Corporation Proprietary Information  

 This listing is supplied under the terms of a license agreement  
 with INTEL Corporation and may not be copied nor disclosed 
 except in accordance with the terms of that agreement.

 Copyright (c) 1996 Intel Corporation.
 All rights reserved.

 $Workfile:   iamacset.cpp  $
 $Revision:   1.1  $
 $Date:   10 Dec 1996 15:34:50  $ 
 $Author:   MDEISHER  $

--------------------------------------------------------------

iamacset.cpp

The generic ActiveMovie audio compression filter basic
settings methods.

--------------------------------------------------------------*/

#include <streams.h>
#include "resource.h"
#include "amacodec.h"

///////////////////////////////////////////////////////////////////////
// *
// * ICodecSettings interface methods
// *

//
// ReleaseCaps:  Turn off capability restrictions
//
STDMETHODIMP  CG711Codec::ReleaseCaps()
{
  m_RestrictCaps = FALSE;

  return NOERROR;
}


//
// UnPlugged:  Check if filter is unplugged
//
BOOL CG711Codec::IsUnPlugged()
{
  int unplugged = TRUE;

  if (m_pInput != NULL)
  {
    if (m_pInput->IsConnected())  unplugged = FALSE;
  }

  if (m_pOutput != NULL)
  {
    if (m_pOutput->IsConnected()) unplugged = FALSE;
  }

  return(unplugged);
}


//
// get_InputBufferSize
//
STDMETHODIMP CG711Codec::get_InputBufferSize(int *numbytes)
{
  HRESULT ReturnVal = NOERROR;

  // if the filter is disconnected, then can't tell buffer size

  if (!IsUnPlugged())
  {
    *numbytes = m_nInBufferSize;
  }
  else ReturnVal = E_FAIL;

  return(ReturnVal);
}


//
// put_InputBufferSize
//
STDMETHODIMP CG711Codec::put_InputBufferSize(int numbytes)
{
  return(E_NOTIMPL);
}


//
// get_OutputBufferSize
//
STDMETHODIMP CG711Codec::get_OutputBufferSize(int *numbytes)
{
  HRESULT ReturnVal = NOERROR;

  // if the filter is disconnected, then can't tell buffer size

  if (!IsUnPlugged())
  {
    *numbytes = m_nOutBufferSize;
  }
  else ReturnVal = E_FAIL;

  return(ReturnVal);
}


//
// put_OutputBufferSize
//
STDMETHODIMP CG711Codec::put_OutputBufferSize(int numbytes)
{
  return(E_NOTIMPL);
}


//
// get_Channels
//
STDMETHODIMP CG711Codec::get_Channels(int *channels, int index)
{
  HRESULT ReturnVal = NOERROR;

  if (index == -1)
  {
    *channels = m_nChannels;
  }
  else if (index < 0 || index >= NUMCHANNELS)
  {
    ReturnVal = E_INVALIDARG;
  }
  else  // enumerate channels
  {
    *channels = VALIDCHANNELS[index];
  }

  return(ReturnVal);
}


//
// put_Channels
//
STDMETHODIMP CG711Codec::put_Channels(int channels)
{
  int i;

  // if the filter is disconnected, then change nChannels

  if (IsUnPlugged())
  {
    for(i=0;i<NUMCHANNELS;i++)
      if (VALIDCHANNELS[i] == (UINT)channels)
        break;

    if (i == NUMCHANNELS)
    {
      DbgMsg("Bad channels in put_Channels!");
      return(E_INVALIDARG);
    }

#ifdef MONO_ONLY
    if (channels != 1)
    {
      DbgMsg("Bad nChannels in put_Channels!");
      return(E_INVALIDARG);
    }
#endif

    m_nChannels = channels;

    return NOERROR;
  }
  else return E_FAIL;
}

 
//
// get_SampleRate
//
STDMETHODIMP CG711Codec::get_SampleRate(int *samprate, int index)
{
  HRESULT ReturnVal=NOERROR;

  if (index == -1)
  {
    *samprate = m_nSampleRate;
  }
  else if (index != -1 && (index < 0 || index >= NUMSAMPRATES))
  {
    ReturnVal = E_INVALIDARG;
  }
  else  // enumerate sample rates
  {
    *samprate = VALIDSAMPRATE[index];
  }

  return ReturnVal;
}


//
// put_SampleRate
//
STDMETHODIMP CG711Codec::put_SampleRate(int samprate)
{
#if NUMSAMPRATES > 0
  int i;

  // if the filter is disconnected, then change sample rate

  if (IsUnPlugged())
  {
    for(i=0;i<NUMSAMPRATES;i++)
      if (VALIDSAMPRATE[i] == (UINT)samprate)
        break;

    if (i == NUMSAMPRATES)
    {
      DbgMsg("Bad sample rate in put_SampleRate!");
      return(E_INVALIDARG);
    }

    m_nSampleRate = samprate;

    // restrict capabilities to those set from the properties page

    m_RestrictCaps = TRUE;

    return NOERROR;
  }
  else return E_FAIL;

#else

  // no sample rate restrictions

  m_nSampleRate = samprate;

  // restrict capabilities to those set from the properties page

  m_RestrictCaps = TRUE;

  return NOERROR;

#endif
}

//
// get_Transform
//
STDMETHODIMP CG711Codec::get_Transform(int *transform)
{
  HRESULT ReturnVal=NOERROR;
  int i,j;

  // determine input type index

  if (m_InputSubType==MEDIASUBTYPE_WAVE || m_InputSubType==MEDIASUBTYPE_NULL)
  {
    for(i=0;i<NUMSUBTYPES;i++)
      if (m_InputFormatTag == VALIDFORMATTAG[i])
        break;

    if (i == NUMSUBTYPES)
    {
      DbgMsg("Bad m_InputSubType/m_InputFormatTag in get_Transform!");
      i = 0;
      ReturnVal = E_UNEXPECTED;
    }
  }
  else
  {
    for(i=0;i<NUMSUBTYPES;i++)
      if (m_InputSubType == *VALIDSUBTYPE[i])
        break;

    if (i == NUMSUBTYPES)
    {
      DbgMsg("Bad m_InputSubType in get_Transform!");
      i = 0;
      ReturnVal = E_UNEXPECTED;
    }
  }

  // determine output type index

  if (m_OutputSubType==MEDIASUBTYPE_WAVE
      || m_OutputSubType==MEDIASUBTYPE_NULL)
  {
    for(j=0;j<NUMSUBTYPES;j++)
      if (m_OutputFormatTag == VALIDFORMATTAG[j])
        break;

    if (j == NUMSUBTYPES)
    {
      DbgMsg("Bad m_OutputSubType/m_OutputFormatTag in get_Transform!");
      j = 0;
      ReturnVal = E_UNEXPECTED;
    }
  }
  else
  {
    for(j=0;j<NUMSUBTYPES;j++)
      if (m_OutputSubType == *VALIDSUBTYPE[j])
        break;

    if (j == NUMSUBTYPES)
    {
      DbgMsg("Bad m_OutputSubType in get_Transform!");
      j = 0;
      ReturnVal = E_UNEXPECTED;
    }
  }

  *transform = i * NUMSUBTYPES + j;

  return ReturnVal;
}


//
// put_Transform
//
STDMETHODIMP CG711Codec::put_Transform(int transform)
{
  int i,j;

  // if the filter is disconnected, then change transform configuration

  if (IsUnPlugged())
  {
    i = transform / NUMSUBTYPES;
    j = transform - i * NUMSUBTYPES;

    if (i < 0 || j < 0 || i >= NUMSUBTYPES || j >= NUMSUBTYPES)
    {
      DbgMsg("Bad transform type in put_Transform!");
      return(E_INVALIDARG);
    }

    m_InputSubType    = *VALIDSUBTYPE[i];
    m_InputFormatTag  = VALIDFORMATTAG[i];
    m_OutputSubType   = *VALIDSUBTYPE[j];
    m_OutputFormatTag = VALIDFORMATTAG[j];

    // reset state since filter may have changed from encoder to decoder

    ResetState();

    // restrict capabilities to those set from the properties page

    m_RestrictCaps = TRUE;
  
    return NOERROR;
  }
  else return E_FAIL;
}

 
//
// put_InputMediaSubType
//
STDMETHODIMP CG711Codec::put_InputMediaSubType(REFCLSID rclsid)
{
  int i;

  // if the filter is disconnected, then change transform configuration

  if (IsUnPlugged())
  {
    for(i=0;i<NUMSUBTYPES;i++)
      if (rclsid == *VALIDSUBTYPE[i]) break;

    if (i == NUMSUBTYPES)
      return(E_INVALIDARG);

    m_InputSubType    = *VALIDSUBTYPE[i];
    m_InputFormatTag  = VALIDFORMATTAG[i];

    // reset state since filter may have changed from encoder to decoder

    ResetState();

    // restrict capabilities to those set from the properties page

    m_RestrictCaps = TRUE;
  
    return NOERROR;
  }
  else return E_FAIL;
}

 
//
// put_OutputMediaSubType
//
STDMETHODIMP CG711Codec::put_OutputMediaSubType(REFCLSID rclsid)
{
  int j;

  // if the filter is disconnected, then change transform configuration

  if (IsUnPlugged())
  {
    for(j=0;j<NUMSUBTYPES;j++)
      if (rclsid == *VALIDSUBTYPE[j]) break;

    if (j == NUMSUBTYPES)
      return(E_INVALIDARG);

    m_OutputSubType   = *VALIDSUBTYPE[j];
    m_OutputFormatTag = VALIDFORMATTAG[j];

    // reset state since filter may have changed from encoder to decoder

    ResetState();

    // restrict capabilities to those set from the properties page

    m_RestrictCaps = TRUE;
  
    return NOERROR;
  }
  else return E_FAIL;
}

/*
//$Log:   K:\proj\mycodec\quartz\vcs\iamacset.cpv  $
# 
#    Rev 1.1   10 Dec 1996 15:34:50   MDEISHER
# 
# added includes and removed include of algdefs.h
# 
#    Rev 1.0   09 Dec 1996 09:04:06   MDEISHER
# Initial revision.
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\litesabr\filters\codecs\g711\iamacsd.cpp ===
/*--------------------------------------------------------------

 INTEL Corporation Proprietary Information  

 This listing is supplied under the terms of a license agreement  
 with INTEL Corporation and may not be copied nor disclosed 
 except in accordance with the terms of that agreement.

 Copyright (c) 1996 Intel Corporation.
 All rights reserved.

 $Workfile:   iamacsd.cpp  $
 $Revision:   1.1  $
 $Date:   10 Dec 1996 15:32:46  $ 
 $Author:   MDEISHER  $

--------------------------------------------------------------

iamacsd.cpp

The generic ActiveMovie audio compression filter silence
detector settings methods.

--------------------------------------------------------------*/

#include <streams.h>
#include "resource.h"
#include "amacodec.h"

#ifdef USESILDET
///////////////////////////////////////////////////////////////////////
// *
// * ICodecSilDetector interface methods
// *

//
// IsSilDetEnabled
//
BOOL CG711Codec::IsSilDetEnabled()
{
  BOOL ReturnVal;

  if ((m_InputSubType == MEDIASUBTYPE_PCM)      // compressing?
      || (m_InputSubType == MEDIASUBTYPE_WAVE
          && m_InputFormatTag == WAVE_FORMAT_PCM)
      || (m_InputSubType == MEDIASUBTYPE_NULL
          && m_InputFormatTag == WAVE_FORMAT_PCM))
  {
    ReturnVal = m_nSilDetEnabled;
  }
  else
  {
    ReturnVal = FALSE;
  }

  return ReturnVal;
}


//
// put_SilDetEnabled
//
STDMETHODIMP CG711Codec::put_SilDetEnabled(int sdenabled)
{
  HRESULT ReturnVal;

  if ((m_InputSubType == MEDIASUBTYPE_PCM)      // compressing?
      || (m_InputSubType == MEDIASUBTYPE_WAVE
          && m_InputFormatTag == WAVE_FORMAT_PCM)
      || (m_InputSubType == MEDIASUBTYPE_NULL
          && m_InputFormatTag == WAVE_FORMAT_PCM))
  {
    m_nSilDetEnabled = sdenabled;

    SILDETENABLE(m_EncStatePtr, m_nSilDetEnabled);

    ReturnVal = NOERROR;
  }
  else ReturnVal = E_FAIL;

  return(ReturnVal);
}

 
//
// get_SilDetThresh
//
STDMETHODIMP CG711Codec::get_SilDetThresh(int *sdthreshold)
{
  HRESULT ReturnVal;

  if ((m_InputSubType == MEDIASUBTYPE_PCM)      // compressing?
      || (m_InputSubType == MEDIASUBTYPE_WAVE
          && m_InputFormatTag == WAVE_FORMAT_PCM)
      || (m_InputSubType == MEDIASUBTYPE_NULL
          && m_InputFormatTag == WAVE_FORMAT_PCM))
  {
    *sdthreshold = m_nSilDetThresh;
    ReturnVal = NOERROR;
  }
  else ReturnVal = E_FAIL;

  return(ReturnVal);
}


//
// put_SilDetThresh
//
STDMETHODIMP CG711Codec::put_SilDetThresh(int sdthreshold)
{
  HRESULT ReturnVal;

  if ((m_InputSubType == MEDIASUBTYPE_PCM)      // compressing?
      || (m_InputSubType == MEDIASUBTYPE_WAVE
          && m_InputFormatTag == WAVE_FORMAT_PCM)
      || (m_InputSubType == MEDIASUBTYPE_NULL
          && m_InputFormatTag == WAVE_FORMAT_PCM))
  {
    if (sdthreshold >= MINSDTHRESH && sdthreshold <= MAXSDTHRESH)
    {
      m_nSilDetThresh = sdthreshold;

      SILDETTHRESH(m_EncStatePtr, m_nSilDetThresh);

      ReturnVal = NOERROR;
    }
    else  ReturnVal = E_INVALIDARG;
  }
  else ReturnVal = E_FAIL;

  return(ReturnVal);
}
#endif

/*
//$Log:   K:\proj\mycodec\quartz\vcs\iamacsd.cpv  $
# 
#    Rev 1.1   10 Dec 1996 15:32:46   MDEISHER
# 
# added includes, removed include of algdefs.h.
# put ifdef USESILDET around code and removed ifdefs inside code.
# 
#    Rev 1.0   09 Dec 1996 09:03:20   MDEISHER
# Initial revision.
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\litesabr\filters\codecs\g711\mk711tab.h ===
/*------------------------------------------------------------------- 

 INTEL Corporation Proprietary Information  

 This listing is supplied under the terms of a license agreement  
 with INTEL Corporation and may not be copied nor disclosed 
 except in accordance with the terms of that agreement.

 Copyright (c) 1996 Intel Corporation.
 All rights reserved.

 $Workfile:   MK711TAB.H  $
 $Revision:   1.3  $
 $Date:   24 May 1996 15:50:44  $ 
 $Author:   DGRAUMAN  $

-------------------------------------------------------------------

MK711Tab.h

 Tables for performing Alaw and uLaw conversion. Alaw is a subset of
 the uLaw table.

-------------------------------------------------------------------*/

#pragma warning( once : 4305) // there is a lot of truncation going on

const unsigned char ulaw2alaw[256] = {
0x2a, 0x2b, 0x28, 0x29, 0x2e, 0x2f, 0x2c, 0x2d, 
0x22, 0x23, 0x20, 0x21, 0x26, 0x27, 0x24, 0x25, 
0x3a, 0x3b, 0x38, 0x39, 0x3e, 0x3f, 0x3c, 0x3d, 
0x32, 0x33, 0x30, 0x31, 0x36, 0x37, 0x34, 0x35, 
0x0a, 0x0b, 0x08, 0x09, 0x0e, 0x0f, 0x0c, 0x0d, 
0x02, 0x03, 0x00, 0x01, 0x06, 0x07, 0x04, 0x05, 
0x1b, 0x18, 0x19, 0x1e, 0x1f, 0x1c, 0x1d, 0x12, 
0x13, 0x10, 0x11, 0x16, 0x17, 0x14, 0x15, 0x6a, 
0x68, 0x69, 0x6e, 0x6f, 0x6c, 0x6d, 0x62, 0x63, 
0x60, 0x61, 0x66, 0x67, 0x64, 0x65, 0x7a, 0x78, 
0x7e, 0x7f, 0x7c, 0x7d, 0x72, 0x73, 0x70, 0x71, 
0x76, 0x77, 0x74, 0x75, 0x4b, 0x49, 0x4f, 0x4d, 
0x42, 0x43, 0x40, 0x41, 0x46, 0x47, 0x44, 0x45, 
0x5a, 0x5b, 0x58, 0x59, 0x5e, 0x5f, 0x5c, 0x5d, 
0x52, 0x52, 0x53, 0x53, 0x50, 0x50, 0x51, 0x51, 
0x56, 0x56, 0x57, 0x57, 0x54, 0x54, 0x55, 0x55, 
0xaa, 0xab, 0xa8, 0xa9, 0xae, 0xaf, 0xac, 0xad, 
0xa2, 0xa3, 0xa0, 0xa1, 0xa6, 0xa7, 0xa4, 0xa5, 
0xba, 0xbb, 0xb8, 0xb9, 0xbe, 0xbf, 0xbc, 0xbd, 
0xb2, 0xb3, 0xb0, 0xb1, 0xb6, 0xb7, 0xb4, 0xb5, 
0x8a, 0x8b, 0x88, 0x89, 0x8e, 0x8f, 0x8c, 0x8d, 
0x82, 0x83, 0x80, 0x81, 0x86, 0x87, 0x84, 0x85, 
0x9b, 0x98, 0x99, 0x9e, 0x9f, 0x9c, 0x9d, 0x92, 
0x93, 0x90, 0x91, 0x96, 0x97, 0x94, 0x95, 0xea, 
0xe8, 0xe9, 0xee, 0xef, 0xec, 0xed, 0xe2, 0xe3, 
0xe0, 0xe1, 0xe6, 0xe7, 0xe4, 0xe5, 0xfa, 0xf8, 
0xfe, 0xff, 0xfc, 0xfd, 0xf2, 0xf3, 0xf0, 0xf1, 
0xf6, 0xf7, 0xf4, 0xf5, 0xcb, 0xc9, 0xcf, 0xcd, 
0xc2, 0xc3, 0xc0, 0xc1, 0xc6, 0xc7, 0xc4, 0xc5, 
0xda, 0xdb, 0xd8, 0xd9, 0xde, 0xdf, 0xdc, 0xdd, 
0xd2, 0xd2, 0xd3, 0xd3, 0xd0, 0xd0, 0xd1, 0xd1, 
0xd6, 0xd6, 0xd7, 0xd7, 0xd4, 0xd4, 0xd5, 0xd5
};


const unsigned char alaw2ulaw[256] = {
0x2a, 0x2b, 0x28, 0x29, 0x2e, 0x2f, 0x2c, 0x2d, 
0x22, 0x23, 0x20, 0x21, 0x26, 0x27, 0x24, 0x25, 
0x39, 0x3a, 0x37, 0x38, 0x3d, 0x3e, 0x3b, 0x3c, 
0x31, 0x32, 0x30, 0x30, 0x35, 0x36, 0x33, 0x34, 
0x0a, 0x0b, 0x08, 0x09, 0x0e, 0x0f, 0x0c, 0x0d, 
0x02, 0x03, 0x00, 0x01, 0x06, 0x07, 0x04, 0x05, 
0x1a, 0x1b, 0x18, 0x19, 0x1e, 0x1f, 0x1c, 0x1d, 
0x12, 0x13, 0x10, 0x11, 0x16, 0x17, 0x14, 0x15, 
0x62, 0x63, 0x60, 0x61, 0x66, 0x67, 0x64, 0x65, 
0x5d, 0x5d, 0x5c, 0x5c, 0x5f, 0x5f, 0x5e, 0x5e, 
0x74, 0x76, 0x70, 0x72, 0x7c, 0x7e, 0x78, 0x7a, 
0x6a, 0x6b, 0x68, 0x69, 0x6e, 0x6f, 0x6c, 0x6d, 
0x48, 0x49, 0x46, 0x47, 0x4c, 0x4d, 0x4a, 0x4b, 
0x40, 0x41, 0x3f, 0x3f, 0x44, 0x45, 0x42, 0x43, 
0x56, 0x57, 0x54, 0x55, 0x5a, 0x5b, 0x58, 0x59, 
0x4f, 0x4f, 0x4e, 0x4e, 0x52, 0x53, 0x50, 0x51, 
0xaa, 0xab, 0xa8, 0xa9, 0xae, 0xaf, 0xac, 0xad, 
0xa2, 0xa3, 0xa0, 0xa1, 0xa6, 0xa7, 0xa4, 0xa5, 
0xb9, 0xba, 0xb7, 0xb8, 0xbd, 0xbe, 0xbb, 0xbc, 
0xb1, 0xb2, 0xb0, 0xb0, 0xb5, 0xb6, 0xb3, 0xb4, 
0x8a, 0x8b, 0x88, 0x89, 0x8e, 0x8f, 0x8c, 0x8d, 
0x82, 0x83, 0x80, 0x81, 0x86, 0x87, 0x84, 0x85, 
0x9a, 0x9b, 0x98, 0x99, 0x9e, 0x9f, 0x9c, 0x9d, 
0x92, 0x93, 0x90, 0x91, 0x96, 0x97, 0x94, 0x95, 
0xe2, 0xe3, 0xe0, 0xe1, 0xe6, 0xe7, 0xe4, 0xe5, 
0xdd, 0xdd, 0xdc, 0xdc, 0xdf, 0xdf, 0xde, 0xde, 
0xf4, 0xf6, 0xf0, 0xf2, 0xfc, 0xfe, 0xf8, 0xfa, 
0xea, 0xeb, 0xe8, 0xe9, 0xee, 0xef, 0xec, 0xed, 
0xc8, 0xc9, 0xc6, 0xc7, 0xcc, 0xcd, 0xca, 0xcb, 
0xc0, 0xc1, 0xbf, 0xbf, 0xc4, 0xc5, 0xc2, 0xc3, 
0xd6, 0xd7, 0xd4, 0xd5, 0xda, 0xdb, 0xd8, 0xd9, 
0xcf, 0xcf, 0xce, 0xce, 0xd2, 0xd3, 0xd0, 0xd1
};

  
const unsigned short ulaw2short[256] = {
0x8284, 0x8684, 0x8a84, 0x8e84, 0x9284, 0x9684, 0x9a84, 0x9e84, 
0xa284, 0xa684, 0xaa84, 0xae84, 0xb284, 0xb684, 0xba84, 0xbe84, 
0xc184, 0xc384, 0xc584, 0xc784, 0xc984, 0xcb84, 0xcd84, 0xcf84, 
0xd184, 0xd384, 0xd584, 0xd784, 0xd984, 0xdb84, 0xdd84, 0xdf84, 
0xe104, 0xe204, 0xe304, 0xe404, 0xe504, 0xe604, 0xe704, 0xe804, 
0xe904, 0xea04, 0xeb04, 0xec04, 0xed04, 0xee04, 0xef04, 0xf004, 
0xf0c4, 0xf144, 0xf1c4, 0xf244, 0xf2c4, 0xf344, 0xf3c4, 0xf444, 
0xf4c4, 0xf544, 0xf5c4, 0xf644, 0xf6c4, 0xf744, 0xf7c4, 0xf844, 
0xf8a4, 0xf8e4, 0xf924, 0xf964, 0xf9a4, 0xf9e4, 0xfa24, 0xfa64, 
0xfaa4, 0xfae4, 0xfb24, 0xfb64, 0xfba4, 0xfbe4, 0xfc24, 0xfc64, 
0xfc94, 0xfcb4, 0xfcd4, 0xfcf4, 0xfd14, 0xfd34, 0xfd54, 0xfd74, 
0xfd94, 0xfdb4, 0xfdd4, 0xfdf4, 0xfe14, 0xfe34, 0xfe54, 0xfe74, 
0xfe8c, 0xfe9c, 0xfeac, 0xfebc, 0xfecc, 0xfedc, 0xfeec, 0xfefc, 
0xff0c, 0xff1c, 0xff2c, 0xff3c, 0xff4c, 0xff5c, 0xff6c, 0xff7c, 
0xff88, 0xff90, 0xff98, 0xffa0, 0xffa8, 0xffb0, 0xffb8, 0xffc0, 
0xffc8, 0xffd0, 0xffd8, 0xffe0, 0xffe8, 0xfff0, 0xfff8, 0x0000, 
0x7d7c, 0x797c, 0x757c, 0x717c, 0x6d7c, 0x697c, 0x657c, 0x617c, 
0x5d7c, 0x597c, 0x557c, 0x517c, 0x4d7c, 0x497c, 0x457c, 0x417c, 
0x3e7c, 0x3c7c, 0x3a7c, 0x387c, 0x367c, 0x347c, 0x327c, 0x307c, 
0x2e7c, 0x2c7c, 0x2a7c, 0x287c, 0x267c, 0x247c, 0x227c, 0x207c, 
0x1efc, 0x1dfc, 0x1cfc, 0x1bfc, 0x1afc, 0x19fc, 0x18fc, 0x17fc, 
0x16fc, 0x15fc, 0x14fc, 0x13fc, 0x12fc, 0x11fc, 0x10fc, 0x0ffc, 
0x0f3c, 0x0ebc, 0x0e3c, 0x0dbc, 0x0d3c, 0x0cbc, 0x0c3c, 0x0bbc, 
0x0b3c, 0x0abc, 0x0a3c, 0x09bc, 0x093c, 0x08bc, 0x083c, 0x07bc, 
0x075c, 0x071c, 0x06dc, 0x069c, 0x065c, 0x061c, 0x05dc, 0x059c, 
0x055c, 0x051c, 0x04dc, 0x049c, 0x045c, 0x041c, 0x03dc, 0x039c, 
0x036c, 0x034c, 0x032c, 0x030c, 0x02ec, 0x02cc, 0x02ac, 0x028c, 
0x026c, 0x024c, 0x022c, 0x020c, 0x01ec, 0x01cc, 0x01ac, 0x018c, 
0x0174, 0x0164, 0x0154, 0x0144, 0x0134, 0x0124, 0x0114, 0x0104, 
0x00f4, 0x00e4, 0x00d4, 0x00c4, 0x00b4, 0x00a4, 0x0094, 0x0084, 
0x0078, 0x0070, 0x0068, 0x0060, 0x0058, 0x0050, 0x0048, 0x0040, 
0x0038, 0x0030, 0x0028, 0x0020, 0x0018, 0x0010, 0x0008, 0x0000
};


const unsigned char short2ulaw[8192] = {
0xff, 0xfe, 0xfd, 0xfc, 0xfb, 0xfa, 0xf9, 0xf8, 
0xf7, 0xf6, 0xf5, 0xf4, 0xf3, 0xf2, 0xf1, 0xf0, 
0xef, 0xef, 0xee, 0xee, 0xed, 0xed, 0xec, 0xec, 
0xeb, 0xeb, 0xea, 0xea, 0xe9, 0xe9, 0xe8, 0xe8, 
0xe7, 0xe7, 0xe6, 0xe6, 0xe5, 0xe5, 0xe4, 0xe4, 
0xe3, 0xe3, 0xe2, 0xe2, 0xe1, 0xe1, 0xe0, 0xe0, 
0xdf, 0xdf, 0xdf, 0xdf, 0xde, 0xde, 0xde, 0xde, 
0xdd, 0xdd, 0xdd, 0xdd, 0xdc, 0xdc, 0xdc, 0xdc, 
0xdb, 0xdb, 0xdb, 0xdb, 0xda, 0xda, 0xda, 0xda, 
0xd9, 0xd9, 0xd9, 0xd9, 0xd8, 0xd8, 0xd8, 0xd8, 
0xd7, 0xd7, 0xd7, 0xd7, 0xd6, 0xd6, 0xd6, 0xd6, 
0xd5, 0xd5, 0xd5, 0xd5, 0xd4, 0xd4, 0xd4, 0xd4, 
0xd3, 0xd3, 0xd3, 0xd3, 0xd2, 0xd2, 0xd2, 0xd2, 
0xd1, 0xd1, 0xd1, 0xd1, 0xd0, 0xd0, 0xd0, 0xd0, 
0xcf, 0xcf, 0xcf, 0xcf, 0xcf, 0xcf, 0xcf, 0xcf, 
0xce, 0xce, 0xce, 0xce, 0xce, 0xce, 0xce, 0xce, 
0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 
0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 
0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 
0xca, 0xca, 0xca, 0xca, 0xca, 0xca, 0xca, 0xca, 
0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 
0xc8, 0xc8, 0xc8, 0xc8, 0xc8, 0xc8, 0xc8, 0xc8, 
0xc7, 0xc7, 0xc7, 0xc7, 0xc7, 0xc7, 0xc7, 0xc7, 
0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 
0xc5, 0xc5, 0xc5, 0xc5, 0xc5, 0xc5, 0xc5, 0xc5, 
0xc4, 0xc4, 0xc4, 0xc4, 0xc4, 0xc4, 0xc4, 0xc4, 
0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 
0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 
0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 
0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 
0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 
0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 
0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 
0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 
0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 
0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 0xbd, 
0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 
0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 
0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 
0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 
0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 
0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 0xba, 
0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 
0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 
0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 
0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 
0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 
0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 
0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 
0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 
0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 
0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 
0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 
0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 0xb4, 
0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 
0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 
0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 
0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 
0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 
0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 
0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 
0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 
0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 
0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 
0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 
0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 
0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 
0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 
0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 
0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 0xae, 
0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 
0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 
0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 
0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad, 
0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 
0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 
0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 
0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 0xac, 
0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 
0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 
0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 
0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 
0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 
0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 
0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 
0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 
0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 
0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 
0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 
0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 0xa9, 
0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 
0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 
0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 
0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 
0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 
0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 
0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 
0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 0xa7, 
0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 
0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 
0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 
0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 
0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 
0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 
0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 
0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 
0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 
0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 
0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 
0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 
0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 
0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 
0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 
0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 
0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 
0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 
0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 
0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 
0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 
0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 
0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 
0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 
0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 
0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 
0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 
0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 
0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 
0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 
0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 
0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 
0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 
0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 
0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 
0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 
0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 
0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 
0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 
0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 
0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 
0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 
0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 
0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 
0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 
0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 
0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 
0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 
0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 
0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 
0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 
0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 
0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 
0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 
0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 
0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 
0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 
0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 
0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 
0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 0x9c, 
0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 
0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 
0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 
0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 
0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 
0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 
0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 
0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 
0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 
0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 
0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 
0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 
0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 
0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 
0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 
0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 0x9a, 
0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 
0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 
0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 
0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 
0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 
0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 
0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 
0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 
0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 
0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 
0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 
0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 
0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 
0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 
0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 
0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 
0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 
0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 
0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 
0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 
0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 
0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 
0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 
0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97, 
0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 
0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 
0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 
0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 
0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 
0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 
0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 
0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 
0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 
0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 
0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 
0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 
0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 
0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 
0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 
0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 0x95, 
0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 
0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 
0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 
0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 
0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 
0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 
0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 
0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 
0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 
0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 
0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 
0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 
0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 
0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 
0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 
0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 
0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 
0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 
0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 
0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 
0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 
0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 
0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 
0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 
0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 
0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 
0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 
0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 
0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 
0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 
0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 
0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 0x91, 
0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 
0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 
0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 
0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 
0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 
0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 
0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 
0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 0x8a, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 
0x03, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
0x04, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
0x05, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
0x06, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 
0x07, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
0x08, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
0x09, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
0x0a, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
0x0b, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 
0x0c, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 
0x0d, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 
0x0e, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
0x11, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
0x12, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 
0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 
0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 
0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 
0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 
0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 
0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 
0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 
0x13, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 
0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 
0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 
0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 
0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 
0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 
0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 
0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 
0x14, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 
0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 
0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 
0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 
0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 
0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 
0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 
0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 
0x15, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 
0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 
0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 
0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 
0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 
0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 
0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 
0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 
0x16, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 
0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 
0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 
0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 
0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 
0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 
0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 
0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 
0x17, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
0x18, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 
0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 
0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 
0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 
0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 
0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 
0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 
0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 
0x19, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 
0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 
0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 
0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 
0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 
0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 
0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 
0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 
0x1a, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 
0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 
0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 
0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 
0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 
0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 
0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 
0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 
0x1b, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 
0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 
0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 
0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 
0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 
0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 
0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 
0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 
0x1c, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 
0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 
0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 
0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 
0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 
0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 
0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 
0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 
0x1d, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 
0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 
0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 
0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 
0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 
0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 
0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 
0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 
0x1e, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 
0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 
0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 
0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 
0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 
0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 
0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 
0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 
0x1f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
0x20, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 
0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 
0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 
0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 
0x21, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 
0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 
0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 
0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 
0x22, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 
0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 
0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 
0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 
0x23, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 
0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 
0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 
0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 
0x24, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 
0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 
0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 
0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 0x25, 
0x25, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 
0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 
0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 
0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 
0x26, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 
0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 
0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 
0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 
0x27, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 
0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 
0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 
0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 
0x28, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 
0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 
0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 
0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 
0x29, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 
0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 
0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 
0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 
0x2a, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 
0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 
0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 
0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 
0x2b, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 
0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 
0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 
0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 
0x2c, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 
0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 
0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 
0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 
0x2d, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 
0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 
0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 
0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 
0x2e, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 
0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 
0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 
0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 
0x2f, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 
0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 
0x31, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 
0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 
0x32, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 
0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 
0x33, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 
0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 
0x34, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 
0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 
0x35, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
0x36, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 
0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 
0x37, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 
0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 
0x38, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 
0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 
0x39, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 
0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 
0x3a, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 
0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 
0x3b, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 
0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 
0x3c, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 
0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d, 
0x3d, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 
0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 
0x3e, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 
0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 
0x3f, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 
0x40, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 
0x41, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 
0x42, 0x43, 0x43, 0x43, 0x43, 0x43, 0x43, 0x43, 
0x43, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 
0x44, 0x45, 0x45, 0x45, 0x45, 0x45, 0x45, 0x45, 
0x45, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 
0x46, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 
0x47, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 
0x48, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 
0x49, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 
0x4a, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 
0x4b, 0x4c, 0x4c, 0x4c, 0x4c, 0x4c, 0x4c, 0x4c, 
0x4c, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 
0x4d, 0x4e, 0x4e, 0x4e, 0x4e, 0x4e, 0x4e, 0x4e, 
0x4e, 0x4f, 0x4f, 0x4f, 0x4f, 0x4f, 0x4f, 0x4f, 
0x4f, 0x50, 0x50, 0x50, 0x50, 0x51, 0x51, 0x51, 
0x51, 0x52, 0x52, 0x52, 0x52, 0x53, 0x53, 0x53, 
0x53, 0x54, 0x54, 0x54, 0x54, 0x55, 0x55, 0x55, 
0x55, 0x56, 0x56, 0x56, 0x56, 0x57, 0x57, 0x57, 
0x57, 0x58, 0x58, 0x58, 0x58, 0x59, 0x59, 0x59, 
0x59, 0x5a, 0x5a, 0x5a, 0x5a, 0x5b, 0x5b, 0x5b, 
0x5b, 0x5c, 0x5c, 0x5c, 0x5c, 0x5d, 0x5d, 0x5d, 
0x5d, 0x5e, 0x5e, 0x5e, 0x5e, 0x5f, 0x5f, 0x5f, 
0x5f, 0x60, 0x60, 0x61, 0x61, 0x62, 0x62, 0x63, 
0x63, 0x64, 0x64, 0x65, 0x65, 0x66, 0x66, 0x67, 
0x67, 0x68, 0x68, 0x69, 0x69, 0x6a, 0x6a, 0x6b, 
0x6b, 0x6c, 0x6c, 0x6d, 0x6d, 0x6e, 0x6e, 0x6f, 
0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 
0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e
};

/* 

;// $Log:   N:\proj\quartz\g711\src\vcs\mk711tab.h_v  $
;// 
;//    Rev 1.3   24 May 1996 15:50:44   DGRAUMAN
;// fixed comments for PVCS logging
;// 
;//    Rev 1.2   24 May 1996 15:40:56   DGRAUMAN
;// cleaned up code, detabbed, etc...
;// 
;//    Rev 1.1   23 May 1996 11:32:04   DGRAUMAN
;// trying to make logging work

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\litesabr\filters\codecs\g711\mk711.h ===
/*--------------------------------------------------------------

 INTEL Corporation Proprietary Information  

 This listing is supplied under the terms of a license agreement  
 with INTEL Corporation and may not be copied nor disclosed 
 except in accordance with the terms of that agreement.

 Copyright (c) 1996 Intel Corporation.
 All rights reserved.

 $Workfile:   MK711.h  $
 $Revision:   1.4  $
 $Date:   03 Aug 1996 13:35:30  $ 
 $Author:   MDEISHER  $

--------------------------------------------------------------

MK711.h

 prototype and declarations for MK711 routines and tables.
 NOTE: The Silence Detection routines are not currently implemented in 
 the BETA release.

--------------------------------------------------------------*/

#ifdef SILENCE_DETECTION // NOTE: this is not implemented in beta

#include "sdstruct.h"

typedef struct INSTANCE{

  long SDFlags;
  
  //COMFORT_PARMS ComfortParms;

  SD_STATE_VALS SDstate;

} INSTANCE;

extern int  	initializeSD(INSTANCE *SD_inst);
extern int 		silenceDetect(INSTANCE *SD_inst);
extern void 	glblSDinitialize(INSTANCE *SD_inst, int buffersize);
extern int 		classify(float Energy_val,float Alpha1val,float Zc_count,
                    float energymean,float energystdev,float alpha1_mean,
                    float alpha1stdev,float ZC_mean,float ZC_stdev,int s, INSTANCE *SD_inst);
extern void 	update(float *histarray,int histsize,float *mean,float *stdev);
extern int 		zeroCross(float x[], int n);
extern void 	getParams(INSTANCE *SD_inst, float *inbuff, int buffersize);
extern void 	prefilter(INSTANCE *SD_inst, float *sbuf, float *fbuf, int buffersize);
extern void		execSDloop(INSTANCE *SD_inst, int *isFrameSilent, int *isFrameCoded);

extern float 	DotProd(register const float in1[], register const float in2[], register int npts);
#endif

// prototypes for all conversion routines 
void Short2Ulaw(const unsigned short *in, unsigned char *out, long len);
void Ulaw2Short(const unsigned char *in, unsigned short *out, long len);
void Short2Alaw(const unsigned short *in, unsigned char *out, long len);
void Alaw2Short(const unsigned char *in, unsigned short *out, long len);

/* 

$Log:   K:\proj\g711\quartz\src\vcs\mk711.h_v  $
;// 
;//    Rev 1.4   03 Aug 1996 13:35:30   MDEISHER
;// changed function prototypes so that they match functions.
;// (changed int to long).
;// 
;//    Rev 1.3   29 Jul 1996 14:42:40   MDEISHER
;// 
;// added SILENCE_DETECTION constant and moved rest of SID declarations
;// inside the ifdef.
;// 
;//    Rev 1.2   24 May 1996 15:42:08   DGRAUMAN
;// cleaned up code, detabbed, etc...
;// 
;//    Rev 1.1   23 May 1996 11:33:00   DGRAUMAN
;// trying to make logging work

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\litesabr\filters\codecs\g711\resource.h ===
//{{NO_DEPENDENCIES}}
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// Microsoft Visual C++ generated include file.
// Used by G711.rc
//
#define IDD_G711CodecPROP               3500
#define IDC_G711Codec                   3501
#define IDB_DEFAULT                     3502
#define IDC_INPUT                       3503
#define IDC_PCM_IN                      3504
#define IDC_MULAW_IN                    3505
#define IDC_ALAW_IN                     3506
#define IDC_OUTPUT                      3507
#define IDC_PCM_OUT                     3508
#define IDC_MULAW_OUT                   3509
#define IDC_ALAW_OUT                    3510
#define IDS_TITLE                       3511
#define IDS_STATIC                      -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1012
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\litesabr\filters\codecs\g711\template.h ===
/*********************************************************************
 *
 * Copyright (c) 1997 Microsoft Corporation
 *
 * File: codecs\g711\template.h
 *
 * Abstract:
 *     Macros to define CFactoryTemplate templates
 *
 * History:
 *     10/30/97    Created by AndresVG
 *
 **********************************************************************/
#if !defined(_G711_TEMPLATE_H_)
#define      _G711_TEMPLATE_H_

extern AMOVIESETUP_FILTER sudG711Codec;

#define CODECG711NAME  "G.711 Codec"
#define CODECG711LNAME L"G.711 Codec"
#define CODECG711LPROP L"G.711 Codec Property Page"

#define CFT_G711_FILTER \
{ \
	  CODECG711LNAME, \
	  &CLSID_G711Codec, \
	  CG711Codec::CreateInstance, \
	  NULL, \
	  &sudG711Codec \
	  }

#define CFT_G711_FILTER_PROP \
{ \
	  CODECG711LPROP, \
	  &CLSID_G711CodecPropertyPage, \
	  CG711CodecProperties::CreateInstance \
	  }

#define CFT_G711_ALL_FILTERS \
CFT_G711_FILTER, \
CFT_G711_FILTER_PROP

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\litesabr\filters\codecs\g711\mk711.cpp ===
/*---------------------------------------------------------------

 INTEL Corporation Proprietary Information  

 This listing is supplied under the terms of a license agreement  
 with INTEL Corporation and may not be copied nor disclosed 
 except in accordance with the terms of that agreement.

 Copyright (c) 1996 Intel Corporation.
 All rights reserved.

 $Workfile:   MK711.CPP  $
 $Revision:   1.2  $
 $Date:   24 May 1996 15:42:28  $ 
 $Author:   DGRAUMAN  $

---------------------------------------------------------------

MK711.cpp

 These are the Alaw and uLaw conversion functions.  They index into 
 the tables in MK711tab.h for the appropriate conversion value.  This
 is extrememly fast.  There is another way to perform 711 that takes 
 more time but does not use over 8K of memory. left for as an excersize 
 for the student.(me)

---------------------------------------------------------------*/

#include "mk711tab.h"

void Short2Ulaw(const unsigned short *in, unsigned char *out, long len)
{
long i;

    for (i=0; i<len; i++)
        out[i] = short2ulaw[in[i] >> 3];
} // end short2ulaw


void Ulaw2Short(const unsigned char *in, unsigned short *out, long len)
{
long i;

    for (i=0; i<len; i++)
        out[i] = ulaw2short[in[i]];
} // end ulaw2short


void Short2Alaw(const unsigned short *in, unsigned char *out, long len)
{
long i;

    for (i=0; i<len; i++)
        out[i] = ulaw2alaw[short2ulaw[in[i] >> 3]];
} // end short2alaw


void Alaw2Short(const unsigned char *in, unsigned short *out, long len)
{
long i;

    for (i=0; i<len; i++)
        out[i] = ulaw2short[alaw2ulaw[in[i]]];
} // end alaw2 short

/* 

//$Log:   N:\proj\quartz\g711\src\vcs\mk711.cpv  $
// 
//    Rev 1.2   24 May 1996 15:42:28   DGRAUMAN
// cleaned up code, detabbed, etc...
// 
//    Rev 1.1   23 May 1996 11:33:16   DGRAUMAN
// trying to make logging work

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\perfdll\perfctr.h ===
//
//  Offset definition file for extensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the 
//  "First Counter" and "First Help" values for the device they belong to, 
//  in order to determine the absolute location of the counter and 
//  object names and corresponding Explain text in the registry.
//
//  This file is used by the extensible counter DLL code as well as the 
//  counter name and Explain text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//
#define TAPIOBJ                 0
#define LINES                   2
#define PHONES                  4
#define LINESINUSE              6
#define PHONESINUSE             8
#define TOTALOUTGOINGCALLS      10
#define TOTALINCOMINGCALLS      12
#define CLIENTAPPS              14
#define ACTIVEOUTGOINGCALLS     16
#define ACTIVEINCOMINGCALLS     18
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\litesabr\filters\inc\iamacset.h ===
/*--------------------------------------------------------------

 INTEL Corporation Proprietary Information  

 This listing is supplied under the terms of a license agreement  
 with INTEL Corporation and may not be copied nor disclosed 
 except in accordance with the terms of that agreement.

 Copyright (c) 1996 Intel Corporation.
 All rights reserved.

 $Workfile:   iamacset.h  $
 $Revision:   1.1  $
 $Date:   10 Dec 1996 15:35:20  $ 
 $Author:   MDEISHER  $

--------------------------------------------------------------

iamacset.h

The generic ActiveMovie audio compression filter settings
interface header.

--------------------------------------------------------------*/

////////////////////////////////////////////////////////////////////
// ICodecSettings:  Basic codec settings interface
//
// This interface is exported and used by the code in amacodec.cpp.
//

// {AEF332D0-46E6-11d0-9DA0-00AA00AF3494}
DEFINE_GUID(IID_ICodecSettings, 
0xaef332d0, 0x46e6, 0x11d0, 0x9d, 0xa0, 0x0, 0xaa, 0x0, 0xaf, 0x34, 0x94);

DECLARE_INTERFACE_(ICodecSettings, IUnknown)
{
    // Compare these with the functions in class CMyCodec

    STDMETHOD(get_Transform)
        ( THIS_
          int *transform  // [out] transformation type
        ) PURE;

    STDMETHOD(put_Transform)
        ( THIS_
          int transform   // [in] transformation type
        ) PURE;

    STDMETHOD(get_InputBufferSize)
        ( THIS_
          int *numbytes   // [out] input buffer size
        ) PURE;

    STDMETHOD(put_InputBufferSize)
        ( THIS_
          int numbytes   // [out] input buffer size
        ) PURE;

    STDMETHOD(get_OutputBufferSize)
        ( THIS_
          int *numbytes   // [out] output buffer size
        ) PURE;

    STDMETHOD(put_OutputBufferSize)
        ( THIS_
          int numbytes   // [out] output buffer size
        ) PURE;

    STDMETHOD(put_InputMediaSubType)
        ( THIS_
          REFCLSID rclsid // [in] output mediasubtype guid
        ) PURE;

    STDMETHOD(put_OutputMediaSubType)
        ( THIS_
          REFCLSID rclsid // [in] output mediasubtype guid
        ) PURE;

    STDMETHOD(get_Channels)
        ( THIS_
          int *channels, // [out] number of channels
          THIS_
          int index      // [in] enumeration index
        ) PURE;

    STDMETHOD(put_Channels)
        ( THIS_
          int channels  // [in] number of channels
        ) PURE;

    STDMETHOD(get_SampleRate)
        ( THIS_
          int *samprate, // [out] sample rate
          THIS_
          int index      // [in] enumeration index
        ) PURE;

    STDMETHOD(put_SampleRate)
        ( THIS_
          int samprate   // [in] sample rate
        ) PURE;

    STDMETHOD(ReleaseCaps)
        (
        ) PURE;

    virtual BOOL(IsUnPlugged)
        (
        ) PURE;
};

/*
//$Log:   K:\proj\mycodec\quartz\vcs\iamacset.h_v  $
;// 
;//    Rev 1.1   10 Dec 1996 15:35:20   MDEISHER
;// 
;// added ifdef DEFGLOBAL and prototype.
;// 
;//    Rev 1.0   09 Dec 1996 09:05:32   MDEISHER
;// Initial revision.
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\perfdll\tapiperf.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    perfTAPI.c

Abstract:

    This file implements the Extensible Objects for the TAPI object type

Revision History


--*/

//
//  Include Files
//

#include <windows.h>
#include <string.h>
#include <tapi.h>
#include <tspi.h>
#include "client.h"
#include "clntprivate.h"
#include "tapsrv.h"
#include <ntprfctr.h>
#include "perfctr.h"
#include "tapiperf.h"

//
//  References to constants which initialize the Object type definitions
//


HINSTANCE                   ghInst;
HINSTANCE                   ghTapiInst = NULL;
extern TAPI_DATA_DEFINITION TapiDataDefinition;
DWORD                       dwOpenCount = 0;        // count of "Open" threads
BOOL                        bInitOK = FALSE;        // true = DLL initialized OK
HLINEAPP                    hLineApp;
HPHONEAPP                   hPhoneApp;
BOOL                        bTapiSrvRunning = FALSE;
DWORD                       gdwLineDevs, gdwPhoneDevs;

void CheckForTapiSrv();
LONG WINAPI Tapi32Performance(PPERFBLOCK);
//
// Tapi data structures
//

HANDLE hTapiSharedMemory;                // Handle of Tapi Shared Memory
PPERF_COUNTER_BLOCK pCounterBlock;

typedef  LONG (* PERFPROC)(PERFBLOCK *);

#define SZINTERNALPERF          TEXT("internalPerformance")
#define SZTAPI32                TEXT("tapi32.dll")
#define SZTAPISRVKEY            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Telephony")

PERFPROC    glpfnInternalPerformance;

//
//  Function Prototypes
//
//      these are used to insure that the data collection functions
//      accessed by Perflib will have the correct calling format.
//

PM_OPEN_PROC        OpenTapiPerformanceData;
PM_COLLECT_PROC     CollectTapiPerformanceData;
PM_CLOSE_PROC       CloseTapiPerformanceData;


//
//  Constant structure initializations
//      defined in datatapi.h
//

TAPI_DATA_DEFINITION TapiDataDefinition =
{
        {
                sizeof(TAPI_DATA_DEFINITION) + SIZE_OF_TAPI_PERFORMANCE_DATA,
                sizeof(TAPI_DATA_DEFINITION),
                sizeof(PERF_OBJECT_TYPE),
                TAPIOBJ,
                0,
                TAPIOBJ,
                0,
                PERF_DETAIL_NOVICE,
                (sizeof(TAPI_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
                        sizeof(PERF_COUNTER_DEFINITION),
                0,
                -1,
                0
        },

        {
                sizeof(PERF_COUNTER_DEFINITION),
                LINES,
                0,
                LINES,
                0,
                0,
                PERF_DETAIL_NOVICE,
                PERF_COUNTER_RAWCOUNT,
                sizeof(DWORD),
                LINES_OFFSET
        },

        {
                sizeof(PERF_COUNTER_DEFINITION),
                PHONES,
                0,
                PHONES,
                0,
                0,
                PERF_DETAIL_NOVICE,
                PERF_COUNTER_RAWCOUNT,
                sizeof(DWORD),
                PHONES_OFFSET
        },

        {
                sizeof(PERF_COUNTER_DEFINITION),
                LINESINUSE,
                0,
                LINESINUSE,
                0,
                0,
                PERF_DETAIL_NOVICE,
                PERF_COUNTER_RAWCOUNT,
                sizeof(DWORD),
                LINESINUSE_OFFSET
        },

        {
                sizeof(PERF_COUNTER_DEFINITION),
                PHONESINUSE,
                0,
                PHONESINUSE,
                0,
                0,
                PERF_DETAIL_NOVICE,
                PERF_COUNTER_RAWCOUNT,
                sizeof(DWORD),
                PHONESINUSE_OFFSET
        },
        {
                sizeof(PERF_COUNTER_DEFINITION),
                TOTALOUTGOINGCALLS,
                0,
                TOTALOUTGOINGCALLS,
                0,
                0,
                PERF_DETAIL_NOVICE,
                PERF_COUNTER_COUNTER,
                sizeof(DWORD),
                TOTALOUTGOINGCALLS_OFFSET
        },
        {
                sizeof(PERF_COUNTER_DEFINITION),
                TOTALINCOMINGCALLS,
                0,
                TOTALINCOMINGCALLS,
                0,
                0,
                PERF_DETAIL_NOVICE,
                PERF_COUNTER_COUNTER,
                sizeof(DWORD),
                TOTALINCOMINGCALLS_OFFSET
        },

        {
                sizeof(PERF_COUNTER_DEFINITION),
                CLIENTAPPS,
                0,
                CLIENTAPPS,
                0,
                0,
                PERF_DETAIL_NOVICE,
                PERF_COUNTER_RAWCOUNT,
                sizeof(DWORD),
                CLIENTAPPS_OFFSET
        }
 ,
        {
                sizeof(PERF_COUNTER_DEFINITION),
                ACTIVEOUTGOINGCALLS,
                0,
                ACTIVEOUTGOINGCALLS,
                0,
                0,
                PERF_DETAIL_NOVICE,
                PERF_COUNTER_RAWCOUNT,
                sizeof(DWORD),
                ACTIVEOUTGOINGCALLS_OFFSET
        },
        {
                sizeof(PERF_COUNTER_DEFINITION),
                ACTIVEINCOMINGCALLS,
                0,
                ACTIVEINCOMINGCALLS,
                0,
                0,
                PERF_DETAIL_NOVICE,
                PERF_COUNTER_RAWCOUNT,
                sizeof(DWORD),
                ACTIVEINCOMINGCALLS_OFFSET
        }


};


DWORD APIENTRY
OpenTapiPerformanceData(
    LPWSTR lpDeviceNames
    )

/*++

Routine Description:

    This routine will open and map the memory used by the TAPI driver to
    pass performance data in. This routine also initializes the data
    structures used to pass data back to the registry

Arguments:

    Pointer to object ID of each device to be opened (TAPI)


Return Value:

    None.

--*/

{
    LONG status;
    TCHAR szMappedObject[] = TEXT("TAPI_COUNTER_BLOCK");
    HKEY hKeyDriverPerf;
    DWORD size;
    DWORD type;
    DWORD dwFirstCounter;
    DWORD dwFirstHelp;
    HKEY  hTapiKey;
    DWORD   dwType;
    DWORD   dwSize;

    //
    //  Since SCREG is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). the registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem
    //

    if (!dwOpenCount)
    {

        // get counter and help index base values
        //      update static data structures by adding base to
        //          offset value in structure.

        // these values are from <ntprfctr.h>
        dwFirstCounter  = TAPI_FIRST_COUNTER_INDEX;
        dwFirstHelp     = TAPI_FIRST_HELP_INDEX;

        TapiDataDefinition.TapiObjectType.ObjectNameTitleIndex += dwFirstCounter;
        TapiDataDefinition.TapiObjectType.ObjectHelpTitleIndex += dwFirstHelp;

        TapiDataDefinition.Lines.CounterNameTitleIndex += dwFirstCounter;
        TapiDataDefinition.Lines.CounterHelpTitleIndex += dwFirstHelp;

        TapiDataDefinition.Phones.CounterNameTitleIndex += dwFirstCounter;
        TapiDataDefinition.Phones.CounterHelpTitleIndex += dwFirstHelp;

        TapiDataDefinition.LinesInUse.CounterNameTitleIndex += dwFirstCounter;
        TapiDataDefinition.LinesInUse.CounterHelpTitleIndex += dwFirstHelp;

        TapiDataDefinition.PhonesInUse.CounterNameTitleIndex += dwFirstCounter;
        TapiDataDefinition.PhonesInUse.CounterHelpTitleIndex += dwFirstHelp;

        TapiDataDefinition.TotalOutgoingCalls.CounterNameTitleIndex += dwFirstCounter;
        TapiDataDefinition.TotalOutgoingCalls.CounterHelpTitleIndex += dwFirstHelp;

        TapiDataDefinition.TotalIncomingCalls.CounterNameTitleIndex += dwFirstCounter;
        TapiDataDefinition.TotalIncomingCalls.CounterHelpTitleIndex += dwFirstHelp;

        TapiDataDefinition.ClientApps.CounterNameTitleIndex += dwFirstCounter;
        TapiDataDefinition.ClientApps.CounterHelpTitleIndex += dwFirstHelp;

        TapiDataDefinition.CurrentOutgoingCalls.CounterNameTitleIndex += dwFirstCounter;
        TapiDataDefinition.CurrentOutgoingCalls.CounterHelpTitleIndex += dwFirstHelp;

        TapiDataDefinition.CurrentIncomingCalls.CounterNameTitleIndex += dwFirstCounter;
        TapiDataDefinition.CurrentIncomingCalls.CounterHelpTitleIndex += dwFirstHelp;

        bInitOK = TRUE; // ok to use this function
    }

    dwOpenCount++;  // increment OPEN counter

    // get number of devices from tapi


    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      SZTAPISRVKEY,
                                      0,
                                      KEY_READ,
                                      &hTapiKey))
    {
        gdwLineDevs = 0;
        gdwPhoneDevs = 0;
    }
    else
    {
        dwSize = sizeof(DWORD);

        if (ERROR_SUCCESS != RegQueryValueEx(hTapiKey,
                                             TEXT("Perf1"),
                                             NULL,
                                             &dwType,
                                             (LPBYTE)&gdwLineDevs,
                                             &dwSize))
        {
            gdwLineDevs = 0;
        }
        else
        {
            gdwLineDevs -= 'PERF';
        }

        dwSize = sizeof(DWORD);

        if (ERROR_SUCCESS != RegQueryValueEx(hTapiKey,
                                             TEXT("Perf2"),
                                             NULL,
                                             &dwType,
                                             (LPBYTE)&gdwPhoneDevs,
                                             &dwSize))
        {
            gdwPhoneDevs = 0;
        }
        else
        {
            gdwPhoneDevs -= 'PERF';
        }

        RegCloseKey(hTapiKey);
    }


    status = ERROR_SUCCESS; // for successful exit

    return status;

}

DWORD APIENTRY
CollectTapiPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the TAPI counters.

Arguments:

   IN       LPWSTR   lpValueName
         pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is written to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is written to the
            DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
         any error conditions encountered are reported to the event log if
         event logging is enabled.

      ERROR_SUCCESS  if success or any other error. Errors, however are
         also reported to the event log.

--*/
{
    //  Variables for reformatting the data

    ULONG SpaceNeeded;
    PDWORD pdwCounter;
    PERF_COUNTER_BLOCK *pPerfCounterBlock;
    TAPI_DATA_DEFINITION *pTapiDataDefinition;

    //  Variables for collecting data about TAPI Resouces

    LPWSTR                              lpFromString;
    LPWSTR                              lpToString;
    INT                                 iStringLength;

    // variables used for error logging

    DWORD                               dwDataReturn[2];
    DWORD                               dwQueryType;

    PPERFBLOCK                          pPerfBlock;
    static BOOL                         bFirst = TRUE;

    //
    // before doing anything else, see if Open went OK
    //

    if (!bInitOK)
    {
        // unable to continue because open failed.
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS; // yes, this is a successful exit
    }

    // see if this is a foreign (i.e. non-NT) computer data request
    //
    dwQueryType = GetQueryType (lpValueName);

    if (dwQueryType == QUERY_FOREIGN)
    {
        // this routine does not service requests for data from
        // Non-NT computers
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;

        return ERROR_SUCCESS;
    }

    if (dwQueryType == QUERY_ITEMS)
    {
        if ( !(IsNumberInUnicodeList (TapiDataDefinition.TapiObjectType.ObjectNameTitleIndex, lpValueName)))
        {

            // request received for data object not provided by this routine
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_SUCCESS;
        }
    }

    pTapiDataDefinition = (TAPI_DATA_DEFINITION *) *lppData;

    SpaceNeeded = sizeof(TAPI_DATA_DEFINITION) +
                  SIZE_OF_TAPI_PERFORMANCE_DATA;

    if ( *lpcbTotalBytes < SpaceNeeded )
    {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;

        return ERROR_MORE_DATA;
    }

    //
    // Copy the (constant, initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //

    if (!bTapiSrvRunning)
    {
        CheckForTapiSrv();
    }

    pPerfBlock = (PPERFBLOCK)GlobalAlloc(GPTR, sizeof(PERFBLOCK));
	if (NULL == pPerfBlock)
	{
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
		return ERROR_SUCCESS;
	}

    if (!bTapiSrvRunning)
    {
        // don't do anything, but succeed

        FillMemory(pPerfBlock,
                   sizeof(PERFBLOCK),
                   0);

        pPerfBlock->dwLines = gdwLineDevs;
        pPerfBlock->dwPhones = gdwPhoneDevs;
    }
    else
    {
        pPerfBlock->dwSize = sizeof(PERFBLOCK);
        glpfnInternalPerformance (pPerfBlock);

        // don't count me as a client app!
        if (0 != pPerfBlock->dwClientApps)
        {
            pPerfBlock->dwClientApps--;
        }
    }

    memmove(pTapiDataDefinition,
            &TapiDataDefinition,
            sizeof(TAPI_DATA_DEFINITION));

    //
    //  Format and collect TAPI data from shared memory
    //

    pPerfCounterBlock = (PERF_COUNTER_BLOCK *) &pTapiDataDefinition[1];

    pPerfCounterBlock->ByteLength = SIZE_OF_TAPI_PERFORMANCE_DATA;

    pdwCounter = (PDWORD) (&pPerfCounterBlock[1]);

    // make sure we don't have funky values
    if (((LONG)pPerfBlock->dwTotalOutgoingCalls) < 0)
    {
        pPerfBlock->dwTotalOutgoingCalls = 0;
    }

    if (((LONG)pPerfBlock->dwTotalIncomingCalls) < 0)
    {
        pPerfBlock->dwTotalIncomingCalls = 0;
    }

    if (((LONG)pPerfBlock->dwCurrentOutgoingCalls) < 0)
    {
        pPerfBlock->dwCurrentOutgoingCalls = 0;
    }

    if (((LONG)pPerfBlock->dwCurrentIncomingCalls) < 0)
    {
        pPerfBlock->dwCurrentIncomingCalls = 0;
    }

    *pdwCounter =   pPerfBlock->dwLines;
    *++pdwCounter = pPerfBlock->dwPhones;
    *++pdwCounter = pPerfBlock->dwLinesInUse;
    *++pdwCounter = pPerfBlock->dwPhonesInUse;
    *++pdwCounter = pPerfBlock->dwTotalOutgoingCalls;
    *++pdwCounter = pPerfBlock->dwTotalIncomingCalls;
    *++pdwCounter = pPerfBlock->dwClientApps;
    *++pdwCounter = pPerfBlock->dwCurrentOutgoingCalls;
    *++pdwCounter = pPerfBlock->dwCurrentIncomingCalls;

    *lppData = (PVOID) ++pdwCounter;

    // update arguments for return

    *lpNumObjectTypes = 1;

    *lpcbTotalBytes = (DWORD)
        ((PBYTE) pdwCounter - (PBYTE) pTapiDataDefinition);

    GlobalFree(pPerfBlock);

    bFirst = FALSE;

    return ERROR_SUCCESS;
}


DWORD APIENTRY
CloseTapiPerformanceData(
)

/*++

Routine Description:

    This routine closes the open handles to TAPI device performance counters

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{

    return ERROR_SUCCESS;

}

void CALLBACK LineCallbackFunc(DWORD dw1,
                               DWORD dw2,
                               DWORD dw3,
                               DWORD dw4,
                               DWORD dw5,
                               DWORD dw6)
{
}



//////////////////////////////////////////////////////////////////////
//
// PERF UTILITY STUFF BELOW!
//
//////////////////////////////////////////////////////////////////////
#define INITIAL_SIZE     1024L
#define EXTEND_SIZE      1024L

//
// Global data definitions.
//

ULONG                   ulInfoBufferSize = 0;


                              // initialized in Open... routines


DWORD  dwLogUsers = 0;        // count of functions using event log

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

WCHAR NULL_STRING[] = L"\0";    // pointer to null string

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)


DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foreign" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    BOOL    bReturnValue;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not found

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimiter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList

BOOL
WINAPI
DllEntryPoint(
    HANDLE  hDLL,
    DWORD   dwReason,
    LPVOID  lpReserved
    )
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            ghInst = hDLL;

            break;
        }
        case DLL_PROCESS_DETACH:
        {
            break;
        }
        case DLL_THREAD_ATTACH:

            break;

        case DLL_THREAD_DETACH:
        {
            break;
        }

    } // switch

    return TRUE;
}

void CheckForTapiSrv()
{
    SC_HANDLE               sc, scTapiSrv;
    SERVICE_STATUS          ServStat;


    sc = OpenSCManager (NULL, NULL, GENERIC_READ);

    if (NULL == sc)
    {
        return;
    }

    bTapiSrvRunning = FALSE;

    scTapiSrv = OpenService (sc, "TAPISRV", SERVICE_QUERY_STATUS);

    if (!QueryServiceStatus (scTapiSrv, &ServStat))
    {
    }

    if (ServStat.dwCurrentState != SERVICE_RUNNING)
    {
    }
    else
    {
        bTapiSrvRunning = TRUE;
    }

    if (bTapiSrvRunning)
    {
        if (!ghTapiInst)
        {
            ghTapiInst = LoadLibrary (SZTAPI32);

            glpfnInternalPerformance = (PERFPROC)GetProcAddress(
                ghTapiInst,
                SZINTERNALPERF
                );

            if (!glpfnInternalPerformance)
            {
            }
        }
    }

    CloseServiceHandle(scTapiSrv);
    CloseServiceHandle(sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\axctl\ctlres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rtcctl.rc
//
#define IDS_APPNAME                     20
#define IDS_PROJNAME                    100
#define IDS_RTCCLIENT_DESC              101
#define IDS_RTCCTL_DESC                 101
#define IDI_SECURITY                    104
#define IDC_DONOT_PROMPT_IN_THE_FUTURE  107
#define IDS_RTC_SEC_PROMPT              108
#define IDS_PARTICIPANT_NAME_HEADER     109
#define IDS_PARTICIPANT_STATUS_HEADER   110
#define IDC_TOOLBAR                     110
#define IDS_SESSION_STATE_INCOMING      111
#define IDS_PART_STATE_PENDING          111
#define IDS_SESSION_STATE_CONNECTING    112
#define IDS_PART_STATE_CONNECTING       112
#define IDR_RTCCTL                      113
#define IDS_SESSION_STATE_CONNECTED     113
#define IDC_BUTTON_RECV_VIDEO_ENABLED   113
#define IDS_PART_STATE_CONNECTED        113
#define IDD_RTCCTL                      114
#define IDS_SESSION_STATE_DISCONNECTED  114
#define IDC_BUTTON_SEND_VIDEO_ENABLED   114
#define IDS_PART_STATE_DISCONNECTED     114
#define IDS_GENERIC_UNKNOWN             115
#define IDS_PART_STATE_REJECTED         116
#define IDS_PART_REJECTED_BUSY          117
#define IDS_PART_REJECTED_NO_ANSWER     118
#define IDS_PART_REJECTED_PL_FAILED     119
#define IDS_PART_REJECTED_SW_FAILED     120
#define IDS_PART_REJECTED_CANCELLED     121
#define IDS_PART_REJECTED_OTHER         122
#define IDS_PART_STATE_ERROR            123
#define IDS_PART_REJECTED_ALL_BUSY      124
#define IDS_PART_STATE_DISCONNECTING    125
#define IDS_PART_REJECTED_BADNUMBER     126
#define IDR_RTCProvStore                127
#define IDD_RTC_SECURITY_DIALOG         128
#define ID_YES                          129
#define ID_NO                           130
#define ID_YES_DONT_ASK_AGAIN           131
#define IDC_SECURITY_WARNING_ICON       132
#define IDC_SECURITY_WARNING_TEXT       133
#define IDS_TIPS_CALL                   200
#define IDC_BUTTON_CALL                 201
#define IDD_DIALOG_DIAL_BY_PHONE_NUMBER 201
#define IDS_TIPS_HANGUP                 201
#define IDB_RECEIVEWALLPAPER            202
#define IDC_BUTTON_HUP                  202
#define IDD_DIALOG_ADD_CALL_FROM_NUMBER 202
#define IDS_TIPS_KNOB_SPEAKER           202
#define IDC_BUTTON_MUTE_SPEAKER         203
#define IDB_PARTICIPANT_LIST            203
#define IDD_DIALOG_CALL_FROM_NUMBERS    203
#define IDS_TIPS_KNOB_MICRO             203
#define IDC_BUTTON_MUTE_MICRO           204
#define IDS_TIPS_RECV_VIDEO_ENABLED     204
#define IDS_TIPS_SEND_VIDEO_ENABLED     205
#define IDR_ACCELERATOR_DIALPAD         206
#define IDS_TIPS_MUTE_SPEAKER           206
#define IDR_TOOLBAR_MAIN                207
#define IDC_RECEIVELOGO                 207
#define IDD_DIALOG_DIAL_BY_NAME         207
#define IDS_TIPS_MUTE_MICRO             207
#define IDC_PREVIEWLOGO                 208
#define IDB_TOOLBAR_NORMAL              208
#define IDC_COMBO_SPEEDDIAL             209
#define IDC_STATUSBAR                   209
#define IDB_TOOLBAR_DISABLED            209
#define IDC_BUTTON_GO                   210
#define IDB_TOOLBAR_HOT                 210
#define IDC_LIST_CALL_FROM              211
#define IDC_KNOB_SPEAKER                211
#define IDC_LIST_COUNTRIES              212
#define IDC_KNOB_MICRO                  212
#define IDC_EDIT_AREA_CODE              214
#define IDC_LIST_PARTICIPANTS           215
#define IDC_EDIT_LOCAL_NUMBER           215
#define IDC_LIST_SERVICE_PROVIDERS      216
#define IDC_STATIC_COUNTRY              217
#define IDC_STATIC_INSTRUCTIONS         218
#define IDC_STATIC_CALLTO_GROUP         219
#define IDC_STATIC_LABEL                219
#define IDC_STATIC_COMPLETE_NUMBER      220
#define IDC_STATIC_AREA_CODE            221
#define IDC_STATIC_LOCAL_NUMBER         222
#define IDC_STATIC_SERVICE_PROVIDER     223
#define IDC_STATIC_CALL_FROM            224
#define IDC_STATIC_LABEL_GROUP          224
#define IDC_BUTTON_EDIT_CALL_FROM_LIST  225
#define IDC_BUTTON_EDIT_SERVICE_PROVIDER_LIST 226
#define IDC_COMBO_COUNTRY               227
#define IDC_COMBO_SERVICE_PROVIDER      228
#define IDC_EDIT_LABEL                  228
#define IDC_COMBO_CALL_FROM             229
#define IDC_STATIC_PHONE_NUMBER_GROUP   229
#define IDC_BUTTON_DELETE               232
#define IDC_BUTTON_ADD                  233
#define IDC_BUTTON_MODIFY               235
#define IDC_EDIT_COMPLETE               236
#define IDC_RADIO_FROM_COMPUTER         237
#define IDC_RADIO_FROM_PHONE            238
#define IDC_LIST_SERVICE_PROVIDER       241
#define IDR_ACCELERATOR_TOOLBAR         241
#define IDD_DIALOG_DIAL_NEED_CALL_INFO  242
#define IDD_DIALOG_SERVICE_PROVIDERS    243
#define IDC_STATIC_MSG_ICON             243
#define IDD_DIALOG_ERROR_MESSAGE_LITE   244
#define IDC_STATIC_MSG1                 244
#define IDC_EDIT_MSG3                   246
#define IDC_BUTTON_ADD_PART             247
#define IDC_EDIT_MSG2                   247
#define IDB_METAL                       248
#define IDC_BUTTON_REM_PART             248
#define IDC_EDIT_MSG1                   248
#define IDC_VOLHAND                     250
#define IDC_VOLVERT                     251
#define IDC_VOLHORZ                     252
#define IDC_VOLDPOS                     253
#define IDC_VOLDNEG                     254
#define IDB_KNOB                        254
#define IDB_SPKVOL                      254
#define IDB_KNOB_LIGHT                  255
#define IDB_KNOB_LIGHT_DIM              256
#define IDB_KNOB_LIGHT_MASK             257
#define IDB_KNOB_TABSTATE               258
#define IDB_SPKVOL_HOT                  258
#define IDB_KNOB_DISABLED               259
#define IDB_SPKVOL_DISABLED             259
#define IDB_KNOB_LIGHT_DISABLED         260
#define IDB_MICVOL                      262
#define IDB_MICVOL_DISABLED             263
#define IDB_MICVOL_HOT                  264
#define IDB_AV_DISABLED                 265
#define IDB_AV_ACTIVE_HOT               266
#define IDB_AV_ACTIVE_PUSH              267
#define IDB_AV_ACTIVE                   268
#define IDB_AV_INACTIVE_HOT             270
#define IDB_AV_INACTIVE_PUSH            271
#define IDB_AV_INACTIVE                 272
#define IDS_NONE                        273
#define IDS_ADD_PARTICIPANT             274
#define IDB_BUTTON_PRESS                275
#define IDB_BUTTON_HOT                  276
#define IDB_BUTTON_NORM                 277
#define IDB_BUTTON_DIS                  278
#define IDS_TIPS_ADD_PART               280
#define IDS_TIPS_REM_PART               281
#define IDS_SEND                        282
#define IDS_RECEIVE                     283
#define IDC_IM_MENU                     284
#define IDD_DIALOG_MESSAGE_BY_NAME      285
#define IDC_VIDEOTUNE                   286
#define IDS_TEXT_PROVIDER               300
#define IDS_TEXT_REALM                  301
#define IDS_BUTTON_CALL                 400
#define IDS_BUTTON_HANGUP               401
#define IDS_BUTTON_ADD_PART             402
#define IDS_BUTTON_REM_PART             403
#define IDS_TEXT_AUDIO                  450
#define IDS_TEXT_VIDEO                  451
#define IDC_DIAL_0                      500
#define IDC_DIAL_1                      501
#define IDC_DIAL_2                      502
#define IDC_DIAL_3                      503
#define IDC_DIAL_4                      504
#define IDC_DIAL_5                      505
#define IDC_DIAL_6                      506
#define IDC_DIAL_7                      507
#define IDC_DIAL_8                      508
#define IDC_DIAL_9                      509
#define IDC_DIAL_STAR                   510
#define IDC_DIAL_POUND                  511
#define IDS_SB_STATUS_NONE              600
#define IDS_SB_STATUS_ERROR             601
#define IDS_SB_STATUS_IDLE              602
#define IDS_SB_STATUS_UI_BUSY           603
#define IDS_SB_STATUS_DIALING           604
#define IDS_SB_STATUS_CONNECTING        605
#define IDS_SB_STATUS_ANSWERING         606
#define IDS_SB_STATUS_DISCONNECTING     607
#define IDS_SB_STATUS_ALERTING          608
#define IDS_SB_STATUS_CONNECTED         609
#define IDS_SB_STATUS_HOLD              610
#define IDS_SB_STATUS_IDLE_FAILED       620
#define IDS_SB_STATUS_CONNECTING_RINGING 621
#define IDS_SB_STATUS_CONNECTING_QUEUED 622
#define IDS_SB_STATUS_REDIRECTING       623
#define IDS_MB_DETAIL_SIP               650
#define IDS_MB_DETAIL_HR                651
#define IDS_MB_DETAIL_HR_UNKNOWN        652
#define IDS_IM_WINDOW_TITLE             667
#define IDS_IM_SEND                     668
#define IDS_IM_INCOMING_MESSAGE         669
#define IDS_IM_OUTGOING_MESSAGE         670
#define IDS_IM_SAYS                     671
#define IDS_IM_MESSAGE_RECEIVED         672
#define IDS_IM_MESSAGE_SENT             673
#define IDS_IM_AT                       674
#define IDS_IM_ON                       675
#define IDS_IM_DISCONNECTED             676
#define IDS_IM_FILE_FILTER              677
#define IDS_IM_TYPING                   678
#define IDM_IM_CALL_CLOSE               700
#define IDM_IM_TOOLS_SOUNDS             701
#define IDM_IM_TOOLS_LARGEST            702
#define IDM_IM_TOOLS_LARGER             703
#define IDM_IM_TOOLS_MEDIUM             704
#define IDM_IM_TOOLS_SMALLER            705
#define IDM_IM_TOOLS_SMALLEST           706
#define IDM_IM_CALL_SAVEAS              707
#define IDC_TEXT_CALLINFO_REDIRECT      800
#define IDS_TEXT_CALLINFO_REDIRECT      800
#define IDS_MESSAGE_DUPLICATE_PARTICIPANT 900
#define IDS_MESSAGE_CANNOT_ADD_PARTICIPANT 901
#define IDS_ERROR_INIT_GENERIC          1000
#define IDS_ERROR_INIT_CORE             1001
#define IDS_ERROR_INIT_INVPARAM_SCENARIO 1002
#define IDS_ERROR_INIT_INVPARAM_URL     1003
#define IDS_ERROR_INIT_INVPARAM_PROV    1004
#define IDS_ERROR_NO_PROVIDERS          1006
#define IDS_ERROR_INIT_INVPARAM_BOOLEAN 1007
#define IDS_CALLBACK                    1102
#define IDS_CAR                         1103
#define IDS_HOME                        1104
#define IDS_HOME2                       1105
#define IDS_MOBILE                      1106
#define IDS_OTHER                       1107
#define IDS_PAGER                       1108
#define IDS_PRIMARY                     1109
#define IDS_RADIO                       1110
#define IDS_TTYTDD                      1111
#define IDS_IPPHONE                     1112
#define IDS_EMAIL                       1113
#define IDS_WAB                         1200
#define IDS_MAPI                        1201
#define IDS_WAVEIN_MUTED                1301
#define IDS_MICROPHONE_MUTED            1302
#define IDS_MICROPHONE_NOT_SELECTED     1303
#define IDS_MB_HRERROR_NOTFOUND_1       2000
#define IDS_MB_HRERROR_NOTFOUND_2       2001
#define IDS_MB_HRERROR_CLIENT_NOTRUNNING_1 2002
#define IDS_MB_HRERROR_CLIENT_NOTRUNNING_2 2003
#define IDS_MB_HRERROR_SERVER_NOTRUNNING_1 2004
#define IDS_MB_HRERROR_SERVER_NOTRUNNING_2 2005
#define IDS_MB_HRERROR_INVALIDADDRESS_1 2006
#define IDS_MB_HRERROR_INVALIDADDRESS_2 2007
#define IDS_MB_HRERROR_CALLING_PRIMARY_LEG_1 2008
#define IDS_MB_HRERROR_CALLING_PRIMARY_LEG_2 2009
#define IDS_MB_HRERROR_SIP_TIMEOUT_OUT_1 2010
#define IDS_MB_HRERROR_SIP_TIMEOUT_OUT_2 2011
#define IDS_MB_HRERROR_APPS_DONT_MATCH_1 2012
#define IDS_MB_HRERROR_APPS_DONT_MATCH_OUT_2 2013
#define IDS_MB_HRERROR_APPS_DONT_MATCH_IN_2 2014
#define IDS_MB_HRERROR_SIP_TIMEOUT_IN_1 2015
#define IDS_MB_HRERROR_SIP_TIMEOUT_IN_2 2016
#define IDS_MB_HRERROR_GENERIC_OUT_1    2017
#define IDS_MB_HRERROR_GENERIC_OUT_2    2018
#define IDS_MB_HRERROR_GENERIC_IN_1     2019
#define IDS_MB_HRERROR_GENERIC_IN_2     2020
#define IDS_MB_SIPERROR_NOTFOUND_1      2021
#define IDS_MB_SIPERROR_NOTFOUND_2      2022
#define IDS_MB_SIPERROR_AUTH_FAILED_1   2023
#define IDS_MB_SIPERROR_AUTH_FAILED_2   2024
#define IDS_MB_SIPERROR_NOTANSWERING_1  2025
#define IDS_MB_SIPERROR_NOTANSWERING_2  2026
#define IDS_MB_SIPERROR_NOTAVAIL_1      2027
#define IDS_MB_SIPERROR_NOTAVAIL_2      2028
#define IDS_MB_SIPERROR_BUSY_1          2029
#define IDS_MB_SIPERROR_BUSY_2          2030
#define IDS_MB_SIPERROR_SERVER_PROBLEM_1 2031
#define IDS_MB_SIPERROR_SERVER_PROBLEM_2 2032
#define IDS_MB_SIPERROR_DECLINE_1       2033
#define IDS_MB_SIPERROR_DECLINE_2       2034
#define IDS_MB_SIPERROR_PINT_BUSY_1     2035
#define IDS_MB_SIPERROR_PINT_BUSY_2     2036
#define IDS_MB_SIPERROR_PINT_NOANSWER_1 2037
#define IDS_MB_SIPERROR_PINT_NOANSWER_2 2038
#define IDS_MB_SIPERROR_PINT_ALLBUSY_1  2039
#define IDS_MB_SIPERROR_PINT_ALLBUSY_2  2040
#define IDS_MB_SIPERROR_GENERIC_1       2041
#define IDS_MB_SIPERROR_GENERIC_2       2042
#define IDS_MB_HRERROR_LOCAL_MACHINE_1  2043
#define IDS_MB_HRERROR_LOCAL_MACHINE_2  2044
#define IDC_ONDESKTOP                   8000
#define IDC_ONQUICKLAUNCH               8001
#define IDS_STOPBUTTON_TEXT             17075
#define IDS_TESTBUTTON_TEXT             17076
#define ID_BUTTON32768                  32768

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        287
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         253
#define _APS_NEXT_SYMED_VALUE           115
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\axctl\dial.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// Dial.cpp
//

#include "stdafx.h"
#include "dial.h"

#include <tapi.h>
#include <winsock2.h>

#ifdef ASSERT
#undef ASSERT
#endif


#define ASSERT _ASSERTE

//////////////////////////////////////////////////////////////////////////////
//
// Constants
//

#define DEFAULT_PHONE_NUMBER L"+1 (425) 555-1212"


//////////////////////////////////////////////////////////////////////////////
//
// Help arrays
//
DWORD   g_dwHelpArrayDialByName[] =
{
    IDC_EDIT_COMPLETE, IDH_DIALOG_DIAL_BY_NAME_EDIT_ADDRESS,
    0, 0
};

DWORD   g_dwHelpArrayDialByPhoneNumber[] =
{
    IDC_COMBO_COUNTRY,      IDH_DIALOG_DIAL_BY_PHONE_NUMBER_LIST_COUNTRY,
    IDC_EDIT_AREA_CODE,     IDH_DIALOG_DIAL_BY_PHONE_NUMBER_EDIT_CITY,
    IDC_EDIT_LOCAL_NUMBER,  IDH_DIALOG_DIAL_BY_PHONE_NUMBER_EDIT_LOCALNUMBER,
    IDC_EDIT_COMPLETE,      IDH_DIALOG_DIAL_BY_PHONE_NUMBER_EDIT_COMPLETENUMBER, 
    0, 0
};

DWORD   g_dwHelpArrayNeedCallInfo[] =
{
    IDC_EDIT_COMPLETE,                      IDH_DIALOG_NEED_CALL_INFO_EDIT_ADDRESS,    
    IDC_COMBO_SERVICE_PROVIDER,             IDH_DIALOG_NEED_CALL_INFO_LIST_ITSP,        
    IDC_BUTTON_EDIT_SERVICE_PROVIDER_LIST,  IDH_DIALOG_NEED_CALL_INFO_BUTTON_EDITSP,
    IDC_RADIO_FROM_COMPUTER,                IDH_DIALOG_NEED_CALL_INFO_RADIO_COMPUTER,
    IDC_RADIO_FROM_PHONE,                   IDH_DIALOG_NEED_CALL_INFO_RADIO_PHONE,
    IDC_COMBO_CALL_FROM,                    IDH_DIALOG_NEED_CALL_INFO_LIST_PHONES,
    IDC_BUTTON_EDIT_CALL_FROM_LIST,         IDH_DIALOG_NEED_CALL_INFO_BUTTON_EDITPHONE,
    0, 0      
}; 

DWORD   g_dwHelpArrayServiceProviders[] =
{
    IDC_LIST_SERVICE_PROVIDER, IDH_DIALOG_SERVICE_PROVIDERS_BUTTON_DELETE,    
    0, 0      
}; 


DWORD   g_dwHelpArrayCallFromNumbers[] =
{
    IDC_LIST_CALL_FROM,                     IDH_DIALOG_CALL_FROM_NUMBERS_LIST_NUMBERS,
    IDC_BUTTON_ADD,                         IDH_DIALOG_CALL_FROM_NUMBERS_BUTTON_ADD,   
    IDC_BUTTON_MODIFY,                      IDH_DIALOG_CALL_FROM_NUMBERS_BUTTON_MODIFY,
    IDC_BUTTON_DELETE,                      IDH_DIALOG_CALL_FROM_NUMBERS_BUTTON_REMOVE,
    0, 0      
}; 



DWORD   g_dwHelpArrayAddCallFrom[] =
{
    IDC_EDIT_LABEL,         IDH_DIALOG_ADD_CALL_FROM_PHONE_NUMBER_EDIT_LABEL,
    IDC_COMBO_COUNTRY,      IDH_DIALOG_ADD_CALL_FROM_PHONE_NUMBER_LIST_COUNTRY,
    IDC_EDIT_AREA_CODE,     IDH_DIALOG_ADD_CALL_FROM_PHONE_NUMBER_EDIT_CITY,      
    IDC_EDIT_LOCAL_NUMBER,  IDH_DIALOG_ADD_CALL_FROM_PHONE_NUMBER_EDIT_LOCALNUMBER,
    IDC_EDIT_COMPLETE,      IDH_DIALOG_ADD_CALL_FROM_PHONE_NUMBER_EDIT_COMPLETENUMBER,
    0, 0      
}; 




//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


HRESULT PopulatePhoneNumberEditBoxes(
    IN   HWND              hwndDlg,
    IN   IRTCPhoneNumber * pPhoneNumber
    );

//////////////////////////////////////////////////////////////////////////////
//
//

void CheckRadioButton(
    IN   HWND   hwndDlg,
    IN   int    nIDDlgItem,
    IN   BOOL   fCheck
    )
{
    LOG((RTC_TRACE, "CheckRadioButton - enter"));

    //
    // Retrieve a handle to the control.
    //

    HWND hwndControl;

    hwndControl = GetDlgItem(
        hwndDlg,
        nIDDlgItem
        );

    ASSERT( hwndControl != NULL );

    //
    // Send the check/uncheck message to the control.
    //

    SendMessage(
        hwndControl,
        BM_SETCHECK,
        (WPARAM) ( fCheck ? BST_CHECKED : BST_UNCHECKED),
        0
        );


    LOG((RTC_TRACE, "CheckRadioButton - exit S_OK"));    
}


//////////////////////////////////////////////////////////////////////////////
//
//

void EnableControl(
    IN   HWND   hwndDlg,
    IN   int    nIDDlgItem,
    IN   BOOL   fEnable
    )
{
    LOG((RTC_TRACE, "EnableControl - enter"));

    //
    // Retrieve a handle to the control.
    //

    HWND hwndControl;

    hwndControl = GetDlgItem(
        hwndDlg,
        nIDDlgItem
        );

    ASSERT( hwndControl != NULL );

    //
    // Enable or disable the control.
    //

    EnableWindow(
        hwndControl,
        fEnable
        );

    LOG((RTC_TRACE, "EnableControl - exit S_OK"));    
}


//////////////////////////////////////////////////////////////////////////////
//
//

HRESULT UpdateCompleteNumberText(
    IN   HWND              hwndDlg,
    IN   IRTCPhoneNumber * pPhoneNumber
    )
{
    //LOG((RTC_TRACE, "UpdateCompleteNumberText - enter"));

    ASSERT( IsWindow( hwndDlg ) );
    ASSERT( ! IsBadReadPtr( pPhoneNumber, sizeof( IRTCPhoneNumber ) ) );

    //
    // Get the canonical string from the phone number object.
    //

    HRESULT hr;

    BSTR bstrCanonical;

    hr = pPhoneNumber->get_Canonical(
        &bstrCanonical
        );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "UpdateCompleteNumberText - failed to get canonical "
                        "string - exit 0x%08x", hr));

        return hr;
    }

    //
    // Get a handle to the edit box for the
    // complete number.
    //

    SetDlgItemText(
        hwndDlg,
        IDC_EDIT_COMPLETE,
        bstrCanonical
        );

    SysFreeString( bstrCanonical );
    bstrCanonical = NULL;

    //LOG((RTC_TRACE, "UpdateCompleteNumberText - exit S_OK"));

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
//

void HandleCountryChange(
    IN   HWND              hwndDlg,
    IN   HWND              hwndCountryCombo,
    IN   IRTCPhoneNumber * pPhoneNumber
    )
{
    //
    // Get the index of the country selection.
    //

    LRESULT lrIndex;

    lrIndex = SendMessage(
        hwndCountryCombo,
        CB_GETCURSEL,
        0,
        0
        );

    //
    // Use the index to get the item data for the new
    // country selection, which contains the country
    // code.
    //

    DWORD dwCountryCode;

    dwCountryCode = (DWORD) SendMessage(
        hwndCountryCombo,
        CB_GETITEMDATA,
        (WPARAM) lrIndex,
        0
        );

    //
    // Tell the phone number object about the new
    // country code. If it fails, we keep the old
    // country code.
    //

    pPhoneNumber->put_CountryCode(
        dwCountryCode
        );

    //
    // Update the UI with the new canonical number.
    //
        
    UpdateCompleteNumberText(
        hwndDlg,
        pPhoneNumber
        );
}
                        
//////////////////////////////////////////////////////////////////////////////
//
// OUT parameter allocated using RtcAlloc, must be freed using RtcFree
//

HRESULT GetStringFromEditBox(
    IN   HWND     hwndDlg,
    IN   int      nIDDlgItem,
    OUT  WCHAR ** pwszEditBoxString
    )
{
    //LOG((RTC_TRACE, "GetStringFromEditBox - enter"));

    //
    // Retrieve a handle to the control.
    //

    HWND hwndEdit;

    hwndEdit = GetDlgItem(
        hwndDlg,
        nIDDlgItem
        );

    ASSERT( hwndEdit != NULL );


    //
    // Get the length of the string from the edit box.
    //

    DWORD dwLength;

    dwLength = (DWORD) SendMessage(
        hwndEdit,
        WM_GETTEXTLENGTH,
        0,
        0
        );

    //
    // Allocate space to store the string.
    //

    ( *pwszEditBoxString ) =
        (WCHAR *) RtcAlloc( ( dwLength + 1 ) * sizeof( WCHAR ) );

    if ( ( *pwszEditBoxString ) == NULL )
    {
        LOG((RTC_ERROR, "GetStringFromEditBox - failed to allocate string "
                        "- exit E_OUTOFMEMORY"));

        return E_OUTOFMEMORY;
    }

    //
    // Get the string from the edit box.
    //

    SendMessage(
        hwndEdit,
        WM_GETTEXT,
        dwLength + 1,
        (LPARAM) ( *pwszEditBoxString )
        );

    //LOG((RTC_TRACE, "GetStringFromEditBox - exit S_OK"));

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
//

void HandleLabelChange(
    IN   HWND              hwndDlg,
    IN   int               nIDDlgItem,
    IN   IRTCPhoneNumber * pPhoneNumber
    )
{
    HRESULT hr;

    //
    // Get the string from the edit box.
    //

    WCHAR * wszEditBoxString;

    hr = GetStringFromEditBox(
        hwndDlg,
        nIDDlgItem,
        & wszEditBoxString
        );

    if ( FAILED(hr) )
    {
        return;
    }
        
    //
    // Tell the phone number object about the new
    // label.
    //

    hr = pPhoneNumber->put_Label(
        wszEditBoxString
        );

    RtcFree( wszEditBoxString );
}

//////////////////////////////////////////////////////////////////////////////
//
//

void HandleNumberChange(
    IN   HWND              hwndDlg,
    IN   int               nIDDlgItem,
    IN   BOOL              fAreaCode,
    IN   IRTCPhoneNumber * pPhoneNumber
    )
{
    HRESULT hr;

    //
    // Get the string from the edit box.
    //

    WCHAR * wszEditBoxString;

    hr = GetStringFromEditBox(
        hwndDlg,
        nIDDlgItem,
        & wszEditBoxString
        );

    if ( FAILED(hr) )
    {
        return;
    }
        
    //
    // Tell the phone number object about the new
    // area code or local number.
    //

    if ( fAreaCode )
    {
        pPhoneNumber->put_AreaCode(
            wszEditBoxString
            );
    }
    else
    {
        pPhoneNumber->put_Number(
            wszEditBoxString
            );
    }

    RtcFree( wszEditBoxString );

    //
    // Update the UI with the new canonical number.
    //
        
    UpdateCompleteNumberText(
        hwndDlg,
        pPhoneNumber
        );
}


//////////////////////////////////////////////////////////////////////////////
//
//

HRESULT PopulateCountryList(
    IN  HWND        hwndDlg,
    IN  int         nIDDlgItem
    )
{
    LOG((RTC_TRACE, "PopulateCountryList - enter"));

    //
    // Retrieve a handle to the combo box.
    //

    HWND hwndControl;

    hwndControl = GetDlgItem(
        hwndDlg,
        nIDDlgItem
        );

    if ( hwndControl == NULL )
    {
        LOG((RTC_ERROR, "PopulateComboBox - failed to "
                        "get combo box handle - exit E_FAIL"));

        return E_FAIL;
    }

    //
    // Get the LineCountryList structure from TAPI, continually reallocating
    // memory until we give TAPI enough space.
    //

    LONG lResult;

    LPLINECOUNTRYLIST pLineCountryList;

    DWORD dwCurrSize = sizeof(LINECOUNTRYLIST);

    while ( TRUE )
    {
        pLineCountryList = ( LINECOUNTRYLIST * ) RtcAlloc( dwCurrSize );

        if ( pLineCountryList == NULL )
        {
            LOG((RTC_ERROR, "PopulateCountryList - out of memory for country list "
                            "structure - exit E_OUTOFMEMORY"));

            return E_OUTOFMEMORY;
        }

        ZeroMemory(
            pLineCountryList,
            dwCurrSize
            );

        pLineCountryList->dwTotalSize = dwCurrSize;

        lResult = lineGetCountry(
            0,               // we want all countries
            0x00010004,      // highest TAPI version supported by this application
            pLineCountryList // location of structure for output
            );

        //
        // If we don't have enough space, TAPI still sets the return code to
        // zero. Nonzero return code means we have an error we can't recover
        // from.
        //

        if ( lResult != 0 )
        {
            RtcFree( pLineCountryList );
        
            LOG((RTC_ERROR, "PopulateCountryList - lineGetCountry returned %d "
                            "- exit E_FAIL", lResult));

            return E_FAIL;
        }

        //
        // If the structure we allocated was big enough, then stop looping.
        //

        if ( pLineCountryList->dwTotalSize >= pLineCountryList->dwNeededSize )
        {
            break;
        }

        dwCurrSize = pLineCountryList->dwNeededSize;

        RtcFree( pLineCountryList );
    }


    LOG((RTC_TRACE, "PopulateCountryList - country list read successfully"));


    //
    // Loop through the country list and populate the combo box.
    // The string is the country name and the itemdata is the country code.
    //
    // To start off, we set pCurrCountryEntry to point to the first
    // LINECOUNTRYENTRY in pLineCountryList. 
    //

    DWORD dwNumCountries = pLineCountryList->dwNumCountries;

    DWORD dwCurrCountry = 0;

    BYTE * pbFirstCountryEntry =
        ( (BYTE *) pLineCountryList ) + pLineCountryList->dwCountryListOffset;

    LINECOUNTRYENTRY * pCurrCountryEntry =
        (LINECOUNTRYENTRY *) pbFirstCountryEntry;

    for ( dwCurrCountry = 0; dwCurrCountry < dwNumCountries; )
    {
        //
        // Obtain from the current country list entry the offset of the
        // string for the name of the current country. The offset is from
        // the beginning of the country list structure.
        //

        DWORD   dwNameOffset   = pCurrCountryEntry->dwCountryNameOffset;

        //
        // The offset is in bytes. Add the offset to the start of the line
        // country list structure to obtain the location of the string.
        //

        BYTE  * pbCurrCountryString = (BYTE *) pLineCountryList + dwNameOffset;

        //
        // Set the display string to the country name.
        //

        LRESULT lrIndex;

        lrIndex = SendMessage(
            hwndControl,
            CB_ADDSTRING,
            0,
            (LPARAM) pbCurrCountryString
            );

        //
        // Set the itemdata to the country code.
        //

        SendMessage(
            hwndControl,
            CB_SETITEMDATA,
            lrIndex,
            MAKELPARAM(pCurrCountryEntry->dwCountryCode, pCurrCountryEntry->dwCountryID)
            );

        //
        // Advance to the next country. Since pCurrCountryEntry points
        // to a LINECOUNTRYENTRY and LINECOUNTRYENTRY structures are
        // fixed-size, we just increment the pointer.
        //

        dwCurrCountry++;
        pCurrCountryEntry++;
    }

    //
    // Now we have our list of strings, so we don't need the country list
    // any more.
    //

    RtcFree( pLineCountryList );

    LOG((RTC_TRACE, "PopulateCountryList - exit S_OK"));

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
//

INT_PTR CALLBACK AddCallFromDialogProc(
    IN  HWND   hwndDlg,
    IN  UINT   uMsg,
    IN  WPARAM wParam,
    IN  LPARAM lParam
    )
{
    //
    // Static local that stores the core's representation of the phone number
    // we are editing. This dialog creates the phone number object, so this
    // dialog is responsible for releasing it.
    //

    static IRTCPhoneNumber * s_pPhoneNumber = NULL;


    //
    // Handling for various window messages.
    //

    HRESULT hr;
    
    switch ( uMsg )
    {
        case WM_INITDIALOG:
        {
            //
            // Get the core client object pointer.
            //

            s_pPhoneNumber = (IRTCPhoneNumber *) lParam;    

            //
            // Populate country list.
            //

            hr = PopulateCountryList(
                hwndDlg,
                IDC_COMBO_COUNTRY
                );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "AddCallFromDialogProc - PopulateCountryList "
                                "failed - exit 0x%08x", hr));

                EndDialog( hwndDlg, (LPARAM) hr );
            }

            //
            // Populate phone number.
            //

            hr = PopulatePhoneNumberEditBoxes(
                hwndDlg, 
                s_pPhoneNumber
                );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "AddCallFromDialogProc - PopulatePhoneNumberEditBoxes "
                                "failed - exit 0x%08x", hr));

                EndDialog( hwndDlg, (LPARAM) hr );
            }

            //
            // Populate label
            //

            BSTR bstrLabel;

            hr = s_pPhoneNumber->get_Label( &bstrLabel );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "AddCallFromDialogProc - failed to "
                                "retrieve label from phone number object - "
                                "0x%08x - not populating label control", hr));
            }
            else
            {
                SetDlgItemText(
                    hwndDlg,
                    IDC_EDIT_LABEL,
                    bstrLabel
                    );
        
                SysFreeString( bstrLabel );
            }

            return TRUE;
        }

        case WM_COMMAND:

            switch ( LOWORD( wParam ) )
            {
                case IDOK:
                {
                    //
                    // Clean up and end the dialog.
                    //

                    EndDialog( hwndDlg, (LPARAM) S_OK );

                    return TRUE;
                }
                
                case IDCANCEL:
                {
                    //
                    // Clean up and end the dialog.
                    //

                    EndDialog( hwndDlg, (LPARAM) E_ABORT );

                    return TRUE;
                }

                case IDC_COMBO_COUNTRY:
                {

                    switch ( HIWORD( wParam ) )
                    {
                        case CBN_SELCHANGE:
                        {
                            if ( s_pPhoneNumber != NULL )
                            {
                                HandleCountryChange(
                                    hwndDlg,
                                    (HWND) lParam,
                                    s_pPhoneNumber
                                    );
                            }
                        
                            return TRUE;
                        }
                        
                        default:
                            break;
                    }

                    break;
                }

                case IDC_EDIT_AREA_CODE:
                {
                    if ( s_pPhoneNumber != NULL )
                    {
                        HandleNumberChange(
                            hwndDlg,
                            LOWORD( wParam ),
                            TRUE,   // area code
                            s_pPhoneNumber
                            );
                    }
                
                    return TRUE;
                }

                case IDC_EDIT_LOCAL_NUMBER:
                {
                    if ( s_pPhoneNumber != NULL )
                    {
                        HandleNumberChange(
                            hwndDlg,
                            LOWORD( wParam ),
                            FALSE,  // not area code
                            s_pPhoneNumber
                            );
                    }
                
                    return TRUE;
                }

                case IDC_EDIT_LABEL:
                {
                    if ( s_pPhoneNumber != NULL )
                    {
                        HandleLabelChange(
                            hwndDlg,
                            LOWORD( wParam ),
                            s_pPhoneNumber
                            );
                    }

                    return TRUE;
                }

                default:
                    break;
            }    
        
        case WM_CONTEXTMENU:

            ::WinHelp(
                (HWND)wParam,
                g_szDllContextHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)g_dwHelpArrayAddCallFrom);

            return TRUE;

            break;

        case WM_HELP:


            ::WinHelp(
                (HWND)(((HELPINFO *)lParam)->hItemHandle),
                g_szDllContextHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)g_dwHelpArrayAddCallFrom);

            return TRUE;

            break;

        default:
            break;
    }    

    //
    // We fell through, so this procedure did not handle the message.
    //

    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
//
//

HRESULT ShowAddCallFromDialog(
    IN   HWND         hwndParent,
    IN   IRTCPhoneNumber * pPhoneNumber
    )
{
    //
    // Call the dialog box procedure.
    //

    INT_PTR ipReturn;

    ipReturn = DialogBoxParam(
        _Module.GetResourceInstance(),
        (LPCTSTR) IDD_DIALOG_ADD_CALL_FROM_NUMBER,
        hwndParent,
        AddCallFromDialogProc,
        (LPARAM) pPhoneNumber // LPARAM == INT_PTR
        );

    return (HRESULT) ipReturn;
}              

//////////////////////////////////////////////////////////////////////////////
//
//

INT_PTR CALLBACK EditCallFromListDialogProc(
    IN  HWND   hwndDlg,
    IN  UINT   uMsg,
    IN  WPARAM wParam,
    IN  LPARAM lParam
    )
{
    //
    // Handling for various window messages.
    //

    HRESULT hr;
    
    switch ( uMsg )
    {
        case WM_INITDIALOG:
        {

            //
            // Set up the call from list.
            //

            hr = PopulateCallFromList(
                hwndDlg,
                IDC_LIST_CALL_FROM,
                FALSE, // not a combo box
                NULL
                );


            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "EditCallFromListDialogProc - "
                                "PopulateCallFromList failed - exit 0x%08x",
                                hr));

                EndDialog( hwndDlg, (LPARAM) hr );
            }

            //
            // Select the first item if it exists
            //

            HWND hwndControl;
    
            hwndControl = GetDlgItem(
                hwndDlg,
                IDC_LIST_CALL_FROM
                );

            LRESULT lResult;

            lResult = SendMessage(
                        hwndControl,
                        LB_SETCURSEL,
                        0,
                        0
                        );

            EnableControl(
                        hwndDlg,
                        IDC_BUTTON_MODIFY,
                        (lResult !=  LB_ERR)
                        );

            EnableControl(
                        hwndDlg,
                        IDC_BUTTON_DELETE,
                        (lResult !=  LB_ERR)
                        );

            return TRUE;
        }

        case WM_DESTROY:
        {
            CleanupListOrComboBoxInterfaceReferences(
                    hwndDlg,
                    IDC_LIST_CALL_FROM,
                    FALSE // not a combo box
                    );
        }

        case WM_COMMAND:
        {
            switch ( LOWORD( wParam ) )
            {
                case IDOK:
                {                   
                    EndDialog( hwndDlg, (LPARAM) S_OK );

                    return TRUE;
                }
                
                case IDCANCEL:
                {
                    EndDialog( hwndDlg, (LPARAM) E_ABORT );

                    return TRUE;
                }

                case IDC_BUTTON_ADD:
                {
                    IRTCPhoneNumber * pNumber;
                
                    hr = CreatePhoneNumber( & pNumber );

                    if ( FAILED(hr) )
                    {
                        LOG((RTC_ERROR, "EditCallFromListDialogProc - "
                            "CreatePhoneNumber failed 0x%lx", hr));
                    }
                    else                    
                    {
                        pNumber->put_CountryCode( 1 );
                        pNumber->put_AreaCode( L"" );
                        pNumber->put_Number( L"" );

                        hr = ShowAddCallFromDialog(
                            hwndDlg,
                            pNumber
                            );

                        if ( SUCCEEDED(hr) )
                        {
                            hr = StoreLocalPhoneNumber( pNumber, FALSE );

                            if ( FAILED(hr) )
                            {
                                LOG((RTC_ERROR, "EditCallFromListDialogProc - "
                                    "StoreLocalPhoneNumber failed 0x%lx", hr));
                            }
                            else
                            {
                                hr = PopulateCallFromList(
                                    hwndDlg,
                                    IDC_LIST_CALL_FROM,
                                    FALSE, // not a combo box
                                    NULL
                                    );

                                //
                                // We've just clobbered the
                                // last selection, so select the first item if
                                // it exists, otherwise gray out the buttons
                                // that require a selection.
                                //

                                HWND hwndControl;
    
                                hwndControl = GetDlgItem(
                                    hwndDlg,
                                    IDC_LIST_CALL_FROM
                                    );

                                LRESULT lResult;

                                lResult = SendMessage(
                                            hwndControl,
                                            LB_SETCURSEL,
                                            0,
                                            0
                                            );

                                EnableControl(
                                            hwndDlg,
                                            IDC_BUTTON_MODIFY,
                                            (lResult !=  LB_ERR)
                                            );

                                EnableControl(
                                            hwndDlg,
                                            IDC_BUTTON_DELETE,
                                            (lResult !=  LB_ERR)
                                            );
                            }
                        }

                        pNumber->Release();
                    }
                
                    return TRUE;
                }

                case IDC_BUTTON_DELETE:
                {
                    IRTCPhoneNumber * pNumber;
                
                    hr = GetCallFromListSelection(
                        hwndDlg,
                        IDC_LIST_CALL_FROM,
                        FALSE,    // use list box, not combo box
                        & pNumber // does not addref
                        );

                    if ( FAILED(hr) )
                    {
                        LOG((RTC_ERROR, "EditCallFromListDialogProc - "
                            "GetCallFromListSelection failed 0x%lx", hr));
                    }
                    else 
                    {
                        hr = DeleteLocalPhoneNumber( pNumber );
                    
                        if ( FAILED(hr) )
                        {
                            LOG((RTC_ERROR, "EditCallFromListDialogProc - "
                                "DeleteLocalPhoneNumber failed 0x%lx", hr));
                        }
                        else
                        {
                            hr = PopulateCallFromList(
                                hwndDlg,
                                IDC_LIST_CALL_FROM,
                                FALSE, // not a combo box
                                NULL
                                );                           

                            //
                            // We've just clobbered the
                            // last selection, so select the first item if
                            // it exists, otherwise gray out the buttons
                            // that require a selection.
                            //

                            HWND hwndControl;
    
                            hwndControl = GetDlgItem(
                                hwndDlg,
                                IDC_LIST_CALL_FROM
                                );

                            LRESULT lResult;

                            lResult = SendMessage(
                                        hwndControl,
                                        LB_SETCURSEL,
                                        0,
                                        0
                                        );

                            EnableControl(
                                        hwndDlg,
                                        IDC_BUTTON_MODIFY,
                                        (lResult !=  LB_ERR)
                                        );

                            EnableControl(
                                        hwndDlg,
                                        IDC_BUTTON_DELETE,
                                        (lResult !=  LB_ERR)
                                        );

                            SetFocus(hwndDlg);
                        }
                    }
                
                    return TRUE;
                }

                case IDC_BUTTON_MODIFY:
                {
                    IRTCPhoneNumber * pNumber;
                
                    hr = GetCallFromListSelection(
                        hwndDlg,
                        IDC_LIST_CALL_FROM,
                        FALSE,    // use list box, not combo box
                        & pNumber // does not addref
                        );

                    if ( FAILED(hr) )
                    {
                        LOG((RTC_ERROR, "EditCallFromListDialogProc - "
                            "GetCallFromListSelection failed 0x%lx", hr));
                    }
                    else                    
                    {     
                        BSTR bstrOriginalLabel = NULL;

                        hr = pNumber->get_Label( &bstrOriginalLabel );

                        if ( SUCCEEDED(hr) )
                        {
                            hr = ShowAddCallFromDialog(
                                hwndDlg,
                                pNumber
                                );

                            if ( SUCCEEDED(hr) )
                            {
                                BSTR bstrNewLabel = NULL;

                                hr = pNumber->get_Label( &bstrNewLabel );

                                if ( SUCCEEDED(hr) )
                                {
                                    if ( wcscmp(bstrOriginalLabel, bstrNewLabel) != 0 )
                                    {
                                        //
                                        // Entry was renamed, delete the old entry
                                        //

                                        IRTCPhoneNumber * pOriginalNumber = NULL;

                                        hr = CreatePhoneNumber( &pOriginalNumber );

                                        if ( SUCCEEDED(hr) )
                                        {
                                            hr = pOriginalNumber->put_Label( bstrOriginalLabel );

                                            if ( SUCCEEDED(hr) )
                                            {
                                                hr = DeleteLocalPhoneNumber( pOriginalNumber );

                                                if ( FAILED(hr) )
                                                {
                                                    LOG((RTC_ERROR, "EditCallFromListDialogProc - "
                                                        "DeleteLocalPhoneNumber failed 0x%lx", hr));
                                                }
                                            }

                                            pOriginalNumber->Release();
                                        }
                                    }

                                    SysFreeString( bstrNewLabel );
                                    bstrNewLabel = NULL;
                                }

                                hr = StoreLocalPhoneNumber( pNumber, TRUE );

                                if ( FAILED(hr) )
                                {
                                    LOG((RTC_ERROR, "EditCallFromListDialogProc - "
                                        "StoreLocalPhoneNumber failed 0x%lx", hr));
                                }
                                else
                                {
                                    hr = PopulateCallFromList(
                                        hwndDlg,
                                        IDC_LIST_CALL_FROM,
                                        FALSE, // not a combo box
                                        NULL
                                        );

                                    //
                                    // We've just clobbered the
                                    // last selection, so select the first item if
                                    // it exists, otherwise gray out the buttons
                                    // that require a selection.
                                    //

                                    HWND hwndControl;
    
                                    hwndControl = GetDlgItem(
                                        hwndDlg,
                                        IDC_LIST_CALL_FROM
                                        );

                                    LRESULT lResult;

                                    lResult = SendMessage(
                                                hwndControl,
                                                LB_SETCURSEL,
                                                0,
                                                0
                                                );

                                    EnableControl(
                                                hwndDlg,
                                                IDC_BUTTON_MODIFY,
                                                (lResult !=  LB_ERR)
                                                );

                                    EnableControl(
                                                hwndDlg,
                                                IDC_BUTTON_DELETE,
                                                (lResult !=  LB_ERR)
                                                );

                                    SetFocus(hwndDlg);
                                }
                            }

                            SysFreeString( bstrOriginalLabel );
                            bstrOriginalLabel = NULL;
                        }
                    }

                    return TRUE;
                }

                case IDC_LIST_CALL_FROM:
                {
                    switch ( HIWORD( wParam ) )
                    {
                        case CBN_SELCHANGE:
                        {
                            EnableControl(
                                hwndDlg,
                                IDC_BUTTON_MODIFY,
                                TRUE // enable
                                );

                            EnableControl(
                                hwndDlg,
                                IDC_BUTTON_DELETE,
                                TRUE // enable
                                );
                            
                            return TRUE;
                        }
                        
                        default:
                            break;
                    }

                    break;
                }

                default:
                    break;
                    
            } // switch ( LOWORD( wParam ) )    

        } // case WM_COMMAND:
        case WM_CONTEXTMENU:

            ::WinHelp(
                (HWND)wParam,
                g_szDllContextHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)g_dwHelpArrayCallFromNumbers);

            return TRUE;

            break;

        case WM_HELP:


            ::WinHelp(
                (HWND)(((HELPINFO *)lParam)->hItemHandle),
                g_szDllContextHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)g_dwHelpArrayCallFromNumbers);

            return TRUE;

            break;

        default:
            break;

    } // switch ( uMsg )

    //
    // We fell through, so this procedure did not handle the message.
    //

    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
//
//

HRESULT ShowEditCallFromListDialog(
    IN   HWND         hwndParent
    )
{
    //
    // Call the dialog box procedure.
    //

    INT_PTR ipReturn;

    ipReturn = DialogBoxParam(
        _Module.GetResourceInstance(),
        (LPCTSTR) IDD_DIALOG_CALL_FROM_NUMBERS,
        hwndParent,
        EditCallFromListDialogProc,
        NULL
        );

    return (HRESULT) ipReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//

INT_PTR CALLBACK EditServiceProviderListDialogProc(
    IN  HWND   hwndDlg,
    IN  UINT   uMsg,
    IN  WPARAM wParam,
    IN  LPARAM lParam
    )
{
    //
    // Static pointer to core client interface.
    //

    static IRTCClient * s_pClient = NULL;

    //
    // Handling for various window messages.
    //

    HRESULT hr;
    
    switch ( uMsg )
    {
        case WM_INITDIALOG:
        {
            //
            // Save a pointer to the core client interface.
            //

            s_pClient = (IRTCClient *) lParam;

            //
            // Set up the call from list.
            //

            hr = PopulateServiceProviderList(
                hwndDlg,
                s_pClient,
                IDC_LIST_SERVICE_PROVIDER,
                FALSE, // not a combo box
                NULL,
                NULL,
                0xF,
                0
                );


            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "EditProfilesListDialogProc - "
                                "PopulateProfilesList failed - exit 0x%08x",
                                hr));

                EndDialog( hwndDlg, (LPARAM) hr );
            }

            //
            // Select the first item if it exists
            //

            HWND hwndControl;
    
            hwndControl = GetDlgItem(
                hwndDlg,
                IDC_LIST_SERVICE_PROVIDER
                );

            LRESULT lResult;

            lResult = SendMessage(
                        hwndControl,
                        LB_SETCURSEL,
                        0,
                        0
                        );

            EnableControl(
                        hwndDlg,
                        IDC_BUTTON_DELETE,
                        (lResult !=  LB_ERR)
                        );

            return TRUE;
        }

        case WM_DESTROY:
        {
            CleanupListOrComboBoxInterfaceReferences(
                    hwndDlg,
                    IDC_LIST_SERVICE_PROVIDER,
                    FALSE // not a combo box
                    );
        }

        case WM_COMMAND:
        {
            switch ( LOWORD( wParam ) )
            {
                case IDOK:
                {
                    EndDialog( hwndDlg, (LPARAM) S_OK );

                    return TRUE;
                }
                
                case IDCANCEL:
                {
                    EndDialog( hwndDlg, (LPARAM) E_ABORT );

                    return TRUE;
                }

                case IDC_BUTTON_DELETE:
                {
                    IRTCProfile * pProfile;
                
                    hr = GetServiceProviderListSelection(
                        hwndDlg,
                        IDC_LIST_SERVICE_PROVIDER,
                        FALSE,    // use list box, not combo box
                        & pProfile // does not addref
                        );

                    if ( SUCCEEDED(hr) )
                    {
                        //
                        // Delete profile from the prov store
                        //

                        BSTR bstrKey;

                        hr = pProfile->get_Key( &bstrKey );

                        if ( SUCCEEDED(hr) )
                        {
                            IRTCProvStore * pProvStore;

                            hr = CoCreateInstance(
                              CLSID_RTCProvStore,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IRTCProvStore,
                              (LPVOID *)&pProvStore
                             );

                            if ( SUCCEEDED(hr) )
                            {
                                pProvStore->DeleteProvisioningProfile( bstrKey );

                                pProvStore->Release();
                            }

                            SysFreeString( bstrKey );
                        }

                        //
                        // Disable profile
                        //

                        IRTCClientProvisioning * pProv = NULL;

                        hr = s_pClient->QueryInterface(
                                           IID_IRTCClientProvisioning,
                                           (void **)&pProv
                                          );                      

                        if ( SUCCEEDED(hr) )
                        {
                            hr = pProv->DisableProfile( pProfile );

                            pProv->Release();                         

                            if ( SUCCEEDED(hr) )
                            {                              
                                // Delete the listbox entry

                                HWND hwndControl;

                                hwndControl = GetDlgItem(
                                    hwndDlg,
                                    IDC_LIST_SERVICE_PROVIDER
                                    );

                                LRESULT lrIndex;

                                lrIndex = SendMessage(
                                    hwndControl,
                                    LB_GETCURSEL,
                                    0,
                                    0
                                    );

                                if ( lrIndex !=  LB_ERR )
                                {
                                    SendMessage(
                                        hwndControl,
                                        LB_DELETESTRING,
                                        (WPARAM) lrIndex,
                                        0
                                        );
                                }

                                // Release the reference

                                pProfile->Release();

                                //
                                // We've just clobbered the
                                // last selection, so select the first item if
                                // it exists, otherwise gray out the buttons
                                // that require a selection.
                                //

                                LRESULT lResult;

                                lResult = SendMessage(
                                            hwndControl,
                                            LB_SETCURSEL,
                                            0,
                                            0
                                            );

                                EnableControl(
                                            hwndDlg,
                                            IDC_BUTTON_DELETE,
                                            (lResult !=  LB_ERR)
                                            );

                                SetFocus(hwndDlg);
                            }                         
                        }
                    }
                
                    return TRUE;
                }

                case IDC_LIST_SERVICE_PROVIDER:
                {
                    switch ( HIWORD( wParam ) )
                    {
                        case CBN_SELCHANGE:
                        {
                            EnableControl(
                                hwndDlg,
                                IDC_BUTTON_DELETE,
                                TRUE // enable
                                );
                            
                            return TRUE;
                        }
                        
                        default:
                            break;
                    }

                    break;
                }

                default:
                    break;
                    
            } // switch ( LOWORD( wParam ) )    

        } // case WM_COMMAND:
        
        case WM_CONTEXTMENU:

            ::WinHelp(
                (HWND)wParam,
                g_szDllContextHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)g_dwHelpArrayServiceProviders);

            return TRUE;

            break;

        case WM_HELP:


            ::WinHelp(
                (HWND)(((HELPINFO *)lParam)->hItemHandle),
                g_szDllContextHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)g_dwHelpArrayServiceProviders);

            return TRUE;

            break;


        default:
            break;

    } // switch ( uMsg )

    //
    // We fell through, so this procedure did not handle the message.
    //

    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
//
//

HRESULT ShowEditServiceProviderListDialog(
    IN   HWND         hwndParent,
    IN   IRTCClient * pClient
    )
{
    //
    // Call the dialog box procedure.
    //

    INT_PTR ipReturn;

    ipReturn = DialogBoxParam(
        _Module.GetResourceInstance(),
        (LPCTSTR) IDD_DIALOG_SERVICE_PROVIDERS,
        hwndParent,
        EditServiceProviderListDialogProc,
        (LPARAM) pClient // LPARAM == INT_PTR
        );

    return (HRESULT) ipReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
// PopulatePhoneNumberEditBoxes()
// helper function
//

HRESULT PopulatePhoneNumberEditBoxes(
    IN   HWND              hwndDlg,
    IN   IRTCPhoneNumber * pPhoneNumber
    )
{
    LOG((RTC_TRACE, "PopulatePhoneNumberEditBoxes - enter"));

    HRESULT hr;

    //
    // Populate selected country from default destination phone number.
    // Step 1: get country code value from default dest number
    //

    DWORD dwCountryCode;

    hr = pPhoneNumber->get_CountryCode( & dwCountryCode );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "PopulatePhoneNumberEditBoxes - failed to "
                        "retrieve country code from phone number object - "
                        "exit 0x%08x", hr));

        return hr;
    }

    //
    // Step 2: get handle to country list combo box
    //

    HWND hwndCountryList;

    hwndCountryList = GetDlgItem(
        hwndDlg,
        IDC_COMBO_COUNTRY
        );

    if ( hwndCountryList == NULL )
    {
        LOG((RTC_ERROR, "PopulatePhoneNumberEditBoxes - failed to "
                        "get combo box handle - exit E_FAIL"));

        return E_FAIL;
    }

    //
    // Step 3: Determine how many items are in the combo box
    //

    DWORD dwTotalItems;

    dwTotalItems = (DWORD) SendMessage(
        hwndCountryList,
        CB_GETCOUNT,
        0,
        0
        );

    //
    // Step 4: Loop over the combo box items
    // For each item, find out its associated data value
    // If the data matches the country code we're looking for
    // then set that item to be the selected country and stop the loop
    //

    DWORD dwIndex;

    for ( dwIndex = 0; dwIndex < dwTotalItems ; dwIndex++ )
    {
        LRESULT lrThisCode;

        lrThisCode = SendMessage(
            hwndCountryList,
            CB_GETITEMDATA,
            dwIndex,
            0
            );

        if ( HIWORD(dwCountryCode) == 0 )
        {
            //
            // No TAPI country ID, give it our best shot and
            // match on the country code itself.
            //

            if ( LOWORD(lrThisCode) == LOWORD(dwCountryCode) )
            {
                //
                // If country code is "1", choose the United States
                // which is TAPI country ID "1"
                //

                if ( (LOWORD(lrThisCode) == 1) && ( HIWORD(lrThisCode) != 1 ) )
                {
                    continue;
                }
        
                SendMessage(
                    hwndCountryList,
                    CB_SETCURSEL,
                    dwIndex,
                    0
                    );
            
                break;
            }
        }
        else
        {
            //
            // Match the TAPI country ID
            //

            if ( HIWORD(lrThisCode) == HIWORD(dwCountryCode) )
            {
                SendMessage(
                    hwndCountryList,
                    CB_SETCURSEL,
                    dwIndex,
                    0
                    );
            
                break;
            }
        }
    }

    //
    // Populate area code.
    //

    BSTR bstrAreaCode;

    hr = pPhoneNumber->get_AreaCode( &bstrAreaCode );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "PopulatePhoneNumberEditBoxes - failed to "
                        "retrieve area code from phone number object - "
                        "0x%08x - not populating area code control", hr));
    }
    else
    {
        SetDlgItemText(
            hwndDlg,
            IDC_EDIT_AREA_CODE,
            bstrAreaCode
            );
            
        SysFreeString( bstrAreaCode );
    }

    //
    // Populate local number.
    //

    BSTR bstrLocalNumber;

    hr = pPhoneNumber->get_Number( &bstrLocalNumber );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "PopulatePhoneNumberEditBoxes - failed to "
                        "retrieve local number from phone number object - "
                        "exit 0x%08x", hr));

        return hr;
    }
    
    SetDlgItemText(
        hwndDlg,
        IDC_EDIT_LOCAL_NUMBER,
        bstrLocalNumber
        );

    SysFreeString( bstrLocalNumber );

    //
    // Populate canonical phone number from default destination phone number.
    //

    UpdateCompleteNumberText(
        hwndDlg,
        pPhoneNumber
        );

    LOG((RTC_TRACE, "PopulatePhoneNumberEditBoxes - exit S_OK"));

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// PopulateDialByPhoneNumberDialog()
// helper function
//

HRESULT PopulateDialByPhoneNumberDialog(
    IN   HWND              hwndDlg,
    IN   IRTCPhoneNumber * pDestPhoneNumber
    )
{
    LOG((RTC_TRACE, "PopulateDialByPhoneNumberDialog - enter"));

    HRESULT hr;

    //
    // Populate country list.
    //

    hr = PopulateCountryList(
        hwndDlg,
        IDC_COMBO_COUNTRY
        );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "PopulateDialByPhoneNumberDialog - "
                        "PopulateCountryList failed - exit 0x%08x", hr));

        return hr;
    }

    //
    // Populate phone number.
    //

    hr = PopulatePhoneNumberEditBoxes(
        hwndDlg, 
        pDestPhoneNumber
        );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "PopulateDialByPhoneNumberDialog - "
                        "PopulatePhoneNumberEditBoxes failed - exit 0x%08x", hr));

        return hr;
    }

    LOG((RTC_TRACE, "PopulateDialByPhoneNumberDialog - exit S_OK"));

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// PopulateCallInfoDialog()
// helper function
//

HRESULT PopulateCallInfoDialog(
    IN   HWND              hwndDlg,
    IN   IRTCClient      * pClient,
    IN   BSTR              bstrDefaultProfileKey, 
    IN   long              lSessionMask,
    IN   BOOL              fEnumerateProfiles,
    IN   IRTCProfile     * pOneShotProfile,
    IN   BSTR              bstrDefaultCallFrom,
    IN   BOOL              fCallFromEditable
    )
{
    LOG((RTC_TRACE, "PopulateCallInfoDialog - enter"));

    HRESULT hr;

    if ( fEnumerateProfiles == TRUE )
    {
        //
        // Populate service provider list.
        //

        hr = PopulateServiceProviderList(
            hwndDlg,
            pClient,
            IDC_COMBO_SERVICE_PROVIDER,
            TRUE,
            pOneShotProfile,
            bstrDefaultProfileKey,
            fEnumerateProfiles ? lSessionMask : 0,
            fEnumerateProfiles && (lSessionMask & RTCSI_PC_TO_PC)
                               ? IDS_NONE : 0
            );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "PopulateCallInfoDialog - "
                            "PopulateServiceProviderList failed - exit 0x%08x",
                            hr));

            return hr;
        }

        //
        // Determine the number of items that ended up in the list.
        //

        DWORD dwNumItems;

        dwNumItems = (DWORD) SendMessage(
            GetDlgItem(hwndDlg, IDC_COMBO_SERVICE_PROVIDER),
            CB_GETCOUNT,
            0,
            0
            );

        //
        // Return an error if the list ended up empty, because it's
        // impossible to make this call without an ITSP.
        //

        if ( dwNumItems == 0 )
        {
            LOG((RTC_ERROR, "PopulateCallInfoDialog - failed to "
                            "get at least one profile - "
                            "showing message box - exit E_FAIL"));

            DisplayMessage(
                _Module.GetResourceInstance(),
                hwndDlg,
                IDS_ERROR_NO_PROVIDERS,
                IDS_APPNAME
                );

            return E_FAIL;
        }
    }

    if ( fCallFromEditable == TRUE )
    {
        //
        // Populate "call from" list.
        //

        hr = PopulateCallFromList(
            hwndDlg,
            IDC_COMBO_CALL_FROM,
            TRUE, // this is a combo box
            bstrDefaultCallFrom
            );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "PopulateCallInfoDialog - "
                            "PopulateCallFromList failed - exit 0x%08x", hr));

            return hr;
        }

        //
        // Enable/Disable various fields in Call From Group
        //    Select the Computer option first
        //

        if ( (bstrDefaultCallFrom == NULL) ||
             (*bstrDefaultCallFrom == L'\0') )
        {
            SendDlgItemMessage(
                hwndDlg,
                IDC_RADIO_FROM_COMPUTER,
                BM_SETCHECK,
                BST_CHECKED,
                0);
        }
        else
        {
            SendDlgItemMessage(
                hwndDlg,
                IDC_RADIO_FROM_PHONE,
                BM_SETCHECK,
                BST_CHECKED,
                0);
        }

        EnableDisableCallGroupElements(
            hwndDlg,
            pClient,
            lSessionMask,
            IDC_RADIO_FROM_COMPUTER,
            IDC_RADIO_FROM_PHONE,
            IDC_COMBO_CALL_FROM,
            IDC_COMBO_SERVICE_PROVIDER,
            NULL,
            NULL,
            NULL,
            NULL
            );    
    }

    LOG((RTC_TRACE, "PopulateCallInfoDialog - exit S_OK"));

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// Returns S_OK if all the info to be returned is available.
// Returns an error if anything is unavailable.
//
// Each OUT parameter can be NULL, in which case that info is not returned.
//
//

HRESULT GetPhoneNumberDialogResult(
    IN   HWND           hwndDlg,
    OUT  IRTCProfile ** ppProfileChosen,
    OUT  BSTR         * ppDestPhoneNrChosen,
    OUT  BSTR         * ppFromAddressChosen
    )
{
    LOG((RTC_TRACE, "GetPhoneNumberDialogResult - enter"));

    ASSERT( IsWindow( hwndDlg ) );

    HRESULT hr; 

    //
    // Determine which profile was chosen.
    //

    if ( ppProfileChosen != NULL )
    {
        HWND hwndCombo;

        hwndCombo = GetDlgItem(
            hwndDlg,
            IDC_COMBO_SERVICE_PROVIDER
            );
    
        LRESULT lrIndex;

        lrIndex = SendMessage(
            hwndCombo,
            CB_GETCURSEL,
            0,
            0
            );

        if ( lrIndex >= 0 )
        {
            IRTCProfile * pProfile;

            pProfile = (IRTCProfile *) SendMessage(
                hwndCombo,
                CB_GETITEMDATA,
                (WPARAM) lrIndex,
                0
                );

            if (pProfile != NULL)
            {
                pProfile->AddRef();
            }

            (*ppProfileChosen) = pProfile;
        }
        else
        {
            (*ppProfileChosen) = NULL;
        }
    }

    //
    // Determine what destination address was chosen.
    //

    if ( ppDestPhoneNrChosen != NULL )
    {
        WCHAR * wszEditBoxString;

        hr = GetStringFromEditBox(
            hwndDlg,
            IDC_EDIT_COMPLETE,
            & wszEditBoxString
            );

        if ( FAILED(hr) )
        {
            LOG((RTC_INFO, "GetPhoneNumberDialogResult - "
                "cannot get dest addr string - exit 0x%08x", hr));

            if ( ppProfileChosen != NULL )
            {
                (*ppProfileChosen)->Release();
                (*ppProfileChosen) = NULL;
            }

            return hr;
        }

        (*ppDestPhoneNrChosen) = SysAllocString( wszEditBoxString );

        RtcFree( wszEditBoxString );
    }
 

    //
    // Determine what source address was chosen.
    //

    if ( ppFromAddressChosen != NULL )
    {
        HWND    hwndRbPhone = GetDlgItem(hwndDlg, IDC_RADIO_FROM_PHONE);

        if (SendMessage(
                hwndRbPhone,
                BM_GETCHECK,
                0,
                0) == BST_CHECKED)
        {
            //
            // The call from phone radio button was checked
            //

            IRTCPhoneNumber * pNumber;

            hr = GetCallFromListSelection(
                hwndDlg,
                IDC_COMBO_CALL_FROM,
                TRUE, // use combo box, not list box
                & pNumber
                );

            if ( FAILED(hr) )
            {
                LOG((RTC_INFO, "GetPhoneNumberDialogResult - "
                    "cannot get from addr selection - exit 0x%08x", hr));

                if ( ppProfileChosen != NULL )
                {
                    (*ppProfileChosen)->Release();
                    (*ppProfileChosen) = NULL;
                }

                if ( ppDestPhoneNrChosen != NULL )
                {
                    SysFreeString( (*ppDestPhoneNrChosen) );
                    (*ppDestPhoneNrChosen) = NULL;
                }

                return hr;
            }

            hr = pNumber->get_Canonical( ppFromAddressChosen );

            if ( FAILED( hr ) )
            {
                LOG((RTC_INFO, "GetPhoneNumberDialogResult - "
                    "cannot canonical from address - exit 0x%08x", hr));

                if ( ppProfileChosen != NULL )
                {
                    (*ppProfileChosen)->Release();
                    (*ppProfileChosen) = NULL;
                }

                if ( ppDestPhoneNrChosen != NULL )
                {
                    SysFreeString( (*ppDestPhoneNrChosen) );
                    (*ppDestPhoneNrChosen) = NULL;
                }

                return hr;
            }
        }
        else
        {
            //
            // The call from computer radio button was checked
            //

            (*ppFromAddressChosen) = NULL;
        }
    }

    LOG((RTC_TRACE, "GetPhoneNumberDialogResult - exit S_OK"));

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// This structure is used to pass params when calling the Win32
// DialogBoxParam() function to create this dialog box.
//

typedef struct
{
    IN   IRTCClient   * pClient;
    IN   long           lSessionMask;
    IN   BOOL           bEnumerateProfiles;
    IN   BOOL           bProfileEditable;
    IN   IRTCProfile  * pOneShotProfile;
    IN   BSTR	        pDestAddress;
    IN   BSTR           pInstructions;
    OUT  IRTCProfile ** ppProfileChosen;
    OUT  BSTR         * ppFromAddressChosen;

} DialNeedCallInfoDialogProcParams;

//////////////////////////////////////////////////////////////////////////////
//
// DialNeedCallInfoDialogProc()
// helper function
//
// This is the dialog procedure for the phone number dialing dialog box.
//
// Parameters:
//    IN  hwndDlg -- the HWND of this dialog box
//    IN  uMsg    -- identifies the message being sent to this window
//    IN  wParam  -- first parameter
//    IN  lParam  -- second parameter
//

INT_PTR CALLBACK DialNeedCallInfoDialogProc(
    IN  HWND   hwndDlg,
    IN  UINT   uMsg,
    IN  WPARAM wParam,
    IN  LPARAM lParam
    )
{
    //
    // Static locals for saving out parameters passed in on WM_INITDIALOG for
    // use when user presses OK.
    //

    static IRTCProfile ** s_ppProfileChosen     = NULL;
    static BSTR         * s_ppFromAddressChosen = NULL;

    //
    // Static local pointer to core client interface, used to update phone
    // numbers in call from list. This dialog does not addref the client
    // interface pointer, so it must not release it either.
    //

    static IRTCClient * s_pClient = NULL;

    static long         s_lSessionMask = 0;
    static BOOL         s_bEnumerateProfiles = FALSE;

    //
    // Handling for various window messages.
    //

    HRESULT hr;
    
    switch ( uMsg )
    {
        case WM_INITDIALOG:
        {
            //
            // Retrieve the params structure from the message.
            //
            
            DialNeedCallInfoDialogProcParams * pstParams;

            pstParams = (DialNeedCallInfoDialogProcParams *) lParam;

            //
            // Save the IRTCClient pointer for later updates to the
            // call from list.
            //

            s_pClient = pstParams->pClient;

            // the mask is both a vertical (filters the profiles)
            // and an horizontal one (filters the capabilities)

            s_lSessionMask = pstParams->lSessionMask;
            s_bEnumerateProfiles = pstParams->bEnumerateProfiles;

            //
            // Since the user cannot edit the dest address, just fill
            // in the edit box with the number passed in
            //
            SetDlgItemText(hwndDlg, IDC_EDIT_COMPLETE, pstParams->pDestAddress);

            //
            // Enable the button for editing the list and the list
            //

            EnableControl(hwndDlg, IDC_BUTTON_EDIT_SERVICE_PROVIDER_LIST, pstParams->bProfileEditable);                  
            EnableControl(hwndDlg, IDC_COMBO_SERVICE_PROVIDER, pstParams->bProfileEditable);
            
            // set the instructions
            if(pstParams->pInstructions)
            {
                SetDlgItemText(hwndDlg, IDC_STATIC_INSTRUCTIONS, pstParams->pInstructions);
            }
            
            //
            // Save the out params for use when the user presses OK.
            //

            s_ppProfileChosen     = pstParams->ppProfileChosen;
            s_ppFromAddressChosen = pstParams->ppFromAddressChosen;

            // Get the "last" call from used

            BSTR bstrLastCallFrom = NULL;

            get_SettingsString(
                                SS_LAST_CALL_FROM,
                                &bstrLastCallFrom );                

            //
            // Populate the dialog using the IN parameters and the
            // the window handle. Rather than passing in the
            // default destination phone number, we pass in a pointer
            // to the phone number object.
            //

            hr = PopulateCallInfoDialog(
                hwndDlg,
                pstParams->pClient,
                NULL, 
                pstParams->lSessionMask,
                pstParams->bEnumerateProfiles,
                pstParams->pOneShotProfile,
                bstrLastCallFrom,
                TRUE
                );

            if ( bstrLastCallFrom != NULL )
            {
                SysFreeString( bstrLastCallFrom );
                bstrLastCallFrom = NULL;
            }

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "DialNeedCallInfoDialogProc - "
                                "PopulateCallInfoDialog "
                                "returned 0x%08x - ending dialog", hr));

                EndDialog( hwndDlg, (LPARAM) hr );
            }
                   
            return TRUE;
        }

        case WM_DESTROY:
        {
            //
            // Release our references.
            //

            CleanupListOrComboBoxInterfaceReferences(
                hwndDlg,
                IDC_COMBO_SERVICE_PROVIDER,
                TRUE // this is a combo box
                );
        
            CleanupListOrComboBoxInterfaceReferences(
                hwndDlg,
                IDC_COMBO_CALL_FROM,
                TRUE // this is a combo box
                );
        }

        case WM_COMMAND:

            switch ( LOWORD( wParam ) )
            {
                case IDOK:
                {
                    hr = GetPhoneNumberDialogResult(
                        hwndDlg,
                        s_ppProfileChosen,
                        NULL,
                        s_ppFromAddressChosen
                        );

                    //
                    // End the dialog.
                    //

                    EndDialog( hwndDlg, (LPARAM) hr );

                    return TRUE;
                }
                
                case IDCANCEL:
                {
                    //
                    // End the dialog.
                    //

                    EndDialog( hwndDlg, (LPARAM) E_ABORT );

                    return TRUE;
                }

                case IDC_BUTTON_EDIT_CALL_FROM_LIST:
                {
                    hr = ShowEditCallFromListDialog(
                        hwndDlg
                        );

                    if ( SUCCEEDED(hr) )
                    {
                        hr = PopulateCallFromList(
                            hwndDlg,
                            IDC_COMBO_CALL_FROM,
                            TRUE, // this is a combo box
                            NULL
                            );

                        EnableDisableCallGroupElements(
                            hwndDlg,
                            s_pClient,
                            s_lSessionMask,
                            IDC_RADIO_FROM_COMPUTER,
                            IDC_RADIO_FROM_PHONE,
                            IDC_COMBO_CALL_FROM,
                            IDC_COMBO_SERVICE_PROVIDER,
                            NULL,
                            NULL,
                            NULL,
                            NULL
                            ); 
                    }
                    
                    return TRUE;
                }

                case IDC_BUTTON_EDIT_SERVICE_PROVIDER_LIST:
                {
                    hr = ShowEditServiceProviderListDialog(
                        hwndDlg,
                        s_pClient
                        );

                    if ( SUCCEEDED(hr) )
                    {
                        hr = PopulateServiceProviderList(
                            hwndDlg,
                            s_pClient,
                            IDC_COMBO_SERVICE_PROVIDER,
                            TRUE, // this is a combo box
                            NULL,
                            NULL,
                            s_bEnumerateProfiles ? s_lSessionMask : 0,
                            s_bEnumerateProfiles ? (s_lSessionMask & RTCSI_PC_TO_PC): 0 
                               ? IDS_NONE : 0
                            );

                        EnableDisableCallGroupElements(
                            hwndDlg,
                            s_pClient,
                            s_lSessionMask,
                            IDC_RADIO_FROM_COMPUTER,
                            IDC_RADIO_FROM_PHONE,
                            IDC_COMBO_CALL_FROM,
                            IDC_COMBO_SERVICE_PROVIDER,
                            NULL,
                            NULL,
                            NULL,
                            NULL
                            ); 
                    }
                    
                    return TRUE;
                }
                
                case IDC_RADIO_FROM_COMPUTER:
                case IDC_RADIO_FROM_PHONE:
                {
                    switch ( HIWORD( wParam ) )
                    {
                    case BN_CLICKED:
                        {
                            if(LOWORD( wParam )==IDC_RADIO_FROM_PHONE)
                            {
                                // Verify if the Combo has at least one entry in it
                                DWORD dwNumItems = (DWORD) SendDlgItemMessage(
                                    hwndDlg,
                                    IDC_COMBO_CALL_FROM,
                                    CB_GETCOUNT,
                                    0,
                                    0
                                    );

                                if( dwNumItems == 0 )
                                {
                                    // Display the CallFrom options
                                    // simulate a button press
                                    BOOL    bHandled;

                                    SendMessage(
                                        hwndDlg,
                                        WM_COMMAND,
                                        MAKEWPARAM(IDC_BUTTON_EDIT_CALL_FROM_LIST, BN_CLICKED),
                                        0);
                                }
                            }

                            EnableDisableCallGroupElements(
                                hwndDlg,
                                s_pClient,
                                s_lSessionMask,
                                IDC_RADIO_FROM_COMPUTER,
                                IDC_RADIO_FROM_PHONE,
                                IDC_COMBO_CALL_FROM,
                                IDC_COMBO_SERVICE_PROVIDER,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                                );

                            break;
                        }
                    }
                    break;
                }

                case IDC_COMBO_SERVICE_PROVIDER:
                case IDC_COMBO_CALL_FROM:
                {
                    hr = GetPhoneNumberDialogResult(
                        hwndDlg,
                        NULL,
                        NULL,
                        NULL
                        );

                    EnableControl(
                        hwndDlg,
                        IDOK,
                        SUCCEEDED( hr ) // enable if succeeded
                        );

                    EnableDisableCallGroupElements(
                        hwndDlg,
                        s_pClient,
                        s_lSessionMask,
                        IDC_RADIO_FROM_COMPUTER,
                        IDC_RADIO_FROM_PHONE,
                        IDC_COMBO_CALL_FROM,
                        IDC_COMBO_SERVICE_PROVIDER,
                        NULL,
                        NULL,
                        NULL,
                        NULL
                        );                     
                    
                    return TRUE;
                }

                default:
                    break;
            }
        
        case WM_CONTEXTMENU:

            ::WinHelp(
                (HWND)wParam,
                g_szDllContextHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)g_dwHelpArrayNeedCallInfo);

            return TRUE;

            break;

        case WM_HELP:


            ::WinHelp(
                (HWND)(((HELPINFO *)lParam)->hItemHandle),
                g_szDllContextHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)g_dwHelpArrayNeedCallInfo);

            return TRUE;

            break;

        default:
            break;
    }

    //
    // We fell through, so this procedure did not handle the message.
    //

    return FALSE;
}


//////////////////////////////////////////////////////////////////////////////
//
// ShowDialNeedCallInfoDialog()
// externally-visible function
//
// Parameters:
//    IN  hwndParent -- the HWND of the parent window
//

HRESULT ShowDialNeedCallInfoDialog(
    IN   HWND           hwndParent,
    IN   IRTCClient   * pClient,
    IN   long           lSessionMask,
    IN   BOOL           bEnumerateProfiles,
    IN   BOOL           bProfileEditable,
    IN   IRTCProfile  * pOneShotProfile,
    IN   BSTR	        pDestAddress,
    IN   BSTR           pInstructions,
    OUT  IRTCProfile ** ppProfileChosen,
    OUT  BSTR         * ppFromAddressChosen
    )
{
    //
    // Fill out a structure encapsulating the parameters that
    // will be passed to the dialog box procedure.
    //

    DialNeedCallInfoDialogProcParams stParams;

    stParams.pClient              = pClient;
    stParams.lSessionMask         = lSessionMask;
    stParams.bEnumerateProfiles   = bEnumerateProfiles;
    stParams.bProfileEditable     = bProfileEditable;
    stParams.pOneShotProfile      = pOneShotProfile;
    stParams.pDestAddress         = pDestAddress;
    stParams.pInstructions        = pInstructions;
    stParams.ppProfileChosen      = ppProfileChosen;
    stParams.ppFromAddressChosen  = ppFromAddressChosen;

    //
    // Call the dialog box procedure.
    //

    INT_PTR ipReturn;

    ipReturn = DialogBoxParam(
        _Module.GetResourceInstance(),
        (LPCTSTR) IDD_DIALOG_DIAL_NEED_CALL_INFO,
        hwndParent,
        DialNeedCallInfoDialogProc,
        (LPARAM) & stParams // LPARAM == INT_PTR
        );

    //
    // In the success case, the dialog box procedure has written
    // the out parameters to the specified addresses.
    //

    return ipReturn != -1 ? (HRESULT)ipReturn : HRESULT_FROM_WIN32(GetLastError());
}

//////////////////////////////////////////////////////////////////////////////
//
// This structure is used to pass params when calling the Win32
// DialogBoxParam() function to create this dialog box.
//

typedef struct
{
    IN   BOOL           bAddParticipant;
    IN   BSTR	        pDestPhoneNr;
    OUT  BSTR         * ppDestPhoneNrChosen;

} DialByPhoneNumberDialogProcParams;

//////////////////////////////////////////////////////////////////////////////
//
// DialByPhoneNumberDialogProc()
// helper function
//
// This is the dialog procedure for the add participant dialog box.
//
// Parameters:
//    IN  hwndDlg -- the HWND of this dialog box
//    IN  uMsg    -- identifies the message being sent to this window
//    IN  wParam  -- first parameter
//    IN  lParam  -- second parameter
//

INT_PTR CALLBACK DialByPhoneNumberDialogProc(
    IN  HWND   hwndDlg,
    IN  UINT   uMsg,
    IN  WPARAM wParam,
    IN  LPARAM lParam
    )
{
    //
    // Static locals for saving out parameters passed in on WM_INITDIALOG for
    // use when user presses OK.
    //

    static BSTR         * s_ppDestPhoneNrChosen = NULL;

    //
    // Static local that stores the core's representation of the phone number
    // we are editing. This dialog creates the phone number object, so this
    // dialog is responsible for releasing it.
    //

    static IRTCPhoneNumber * s_pPhoneNumber = NULL;

    //
    // Handling for various window messages.
    //

    HRESULT hr;
    
    switch ( uMsg )
    {
        case WM_INITDIALOG:
        {
            //
            // Retrieve the params structure from the message.
            //
            
            DialByPhoneNumberDialogProcParams * pstParams;

            pstParams = (DialByPhoneNumberDialogProcParams *) lParam;

            if ( pstParams->bAddParticipant )
            {
                //
                // Change the window title to add participant
                //

                TCHAR szString[256];

                if (LoadString(_Module.GetResourceInstance(), IDS_ADD_PARTICIPANT, szString, 256))
                {
                    SetWindowText(hwndDlg, szString);
                }
            }

            //
            // Create the phone number object that we will manipulate
            // to do translation to/from canonical form as the user edits
            // the number
            //

            hr = CreatePhoneNumber( & s_pPhoneNumber );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "DialByPhoneNumberDialogProc - "
                                "CreatePhoneNumber returned 0x%08x - "
                                "ending dialog", hr));

                EndDialog( hwndDlg, (LPARAM) hr );
            }

            if ( pstParams->pDestPhoneNr == NULL )
            {
                //
                // Set the phone number object so it contains the "last" 
                // phone number called
                //

                DWORD dwLastCountry;
                BSTR bstrLastAreaCode = NULL;
                BSTR bstrLastNumber = NULL;

                hr = get_SettingsDword( 
                    SD_LAST_COUNTRY_CODE,
                    &dwLastCountry );

                if ( SUCCEEDED(hr) )
                {
                    hr = get_SettingsString( 
                        SS_LAST_AREA_CODE,
                        &bstrLastAreaCode );

                    if ( SUCCEEDED(hr) )
                    {
                        hr = get_SettingsString( 
                            SS_LAST_NUMBER,
                            &bstrLastNumber );

                        if ( SUCCEEDED(hr) )
                        {                        
                            s_pPhoneNumber->put_CountryCode( dwLastCountry );
                            s_pPhoneNumber->put_AreaCode( bstrLastAreaCode );
                            s_pPhoneNumber->put_Number( bstrLastNumber );

                            SysFreeString( bstrLastNumber );
                        }

                        SysFreeString( bstrLastAreaCode );
                    }
                }

                if ( FAILED(hr) )
                {
                    //
                    // There is no "last" phone number called...
                    //
                    // Set the phone number object so it contains a default
                    // phone number
                    //

                    s_pPhoneNumber->put_Canonical( DEFAULT_PHONE_NUMBER );
                }
            }
            else
            {
                //
                // Set the phone number object so it contains the phone
                // number passed into this method
                //

                s_pPhoneNumber->put_Canonical( pstParams->pDestPhoneNr );
            }                   
            
            //
            // Save the out params for use when the user presses OK.
            //

            s_ppDestPhoneNrChosen = pstParams->ppDestPhoneNrChosen;

            //
            // Populate the dialog using the IN parameters and the
            // the window handle. Rather than passing in the
            // default destination phone number, we pass in a pointer
            // to the phone number object.
            //
        
            hr = PopulateDialByPhoneNumberDialog(
                hwndDlg,
                s_pPhoneNumber
                );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "DialByPhoneNumberDialogProc - "
                                "PopulateDialByPhoneNumberDialog "
                                "returned 0x%08x - ending dialog", hr));

                if ( s_pPhoneNumber != NULL )
                {
                    s_pPhoneNumber->Release();
                    s_pPhoneNumber = NULL;
                }

                EndDialog( hwndDlg, (LPARAM) hr );
            }
                   
            return TRUE;
        }

        case WM_DESTROY:
        {
            //
            // Release our references.
            //
        
            if ( s_pPhoneNumber != NULL )
            {
                s_pPhoneNumber->Release();
                s_pPhoneNumber = NULL;
            }
        }

        case WM_COMMAND:

            switch ( LOWORD( wParam ) )
            {
                case IDOK:
                {
                    //
                    // Get the user's selections.
                    //
                    
                    hr = GetPhoneNumberDialogResult(
                        hwndDlg,
                        NULL,
                        s_ppDestPhoneNrChosen,
                        NULL
                        );

                    //
                    // Save this phone number to populate
                    // the dialog next time
                    //

                    if ( s_pPhoneNumber != NULL )
                    {
                        DWORD dwLastCountry;
                        BSTR bstrLastAreaCode = NULL;
                        BSTR bstrLastNumber = NULL;

                        hr = s_pPhoneNumber->get_CountryCode( &dwLastCountry );

                        if ( SUCCEEDED(hr) )
                        {
                            hr = s_pPhoneNumber->get_AreaCode( &bstrLastAreaCode );

                            if ( SUCCEEDED(hr) )
                            {
                                hr = s_pPhoneNumber->get_Number( &bstrLastNumber );

                                if ( SUCCEEDED(hr) )
                                {                        
                                    put_SettingsDword( 
                                        SD_LAST_COUNTRY_CODE,
                                        dwLastCountry );

                                    put_SettingsString( 
                                        SS_LAST_AREA_CODE,
                                        bstrLastAreaCode );

                                    put_SettingsString( 
                                        SS_LAST_NUMBER,
                                        bstrLastNumber );

                                    SysFreeString( bstrLastNumber );
                                }

                                SysFreeString( bstrLastAreaCode );
                            }
                        }
                    }             

                    //
                    // End the dialog.
                    //

                    EndDialog( hwndDlg, (LPARAM) hr );

                    return TRUE;
                }
                
                case IDCANCEL:
                {
                    //
                    // End the dialog.
                    //

                    EndDialog( hwndDlg, (LPARAM) E_ABORT );

                    return TRUE;
                }          

                case IDC_COMBO_COUNTRY:
                {

                    switch ( HIWORD( wParam ) )
                    {
                        case CBN_SELCHANGE:
                        {
                            if ( s_pPhoneNumber != NULL )
                            {
                                HandleCountryChange(
                                    hwndDlg,
                                    (HWND) lParam,
                                    s_pPhoneNumber
                                    );
                            }
                        
                            return TRUE;
                        }
                        
                        default:
                            break;
                    }

                    break;
                }

                case IDC_EDIT_AREA_CODE:
                {
                    HandleNumberChange(
                        hwndDlg,
                        LOWORD( wParam ),
                        TRUE,   // area code
                        s_pPhoneNumber
                        );
                
                    return TRUE;
                }

                case IDC_EDIT_LOCAL_NUMBER:
                {
                    HandleNumberChange(
                        hwndDlg,
                        LOWORD( wParam ),
                        FALSE,  // not area code
                        s_pPhoneNumber
                        );
                
                    return TRUE;
                }

                default:
                    break;
            }
        
        case WM_CONTEXTMENU:

            ::WinHelp(
                (HWND)wParam,
                g_szDllContextHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)g_dwHelpArrayDialByPhoneNumber);

            return TRUE;

            break;

        case WM_HELP:


            ::WinHelp(
                (HWND)(((HELPINFO *)lParam)->hItemHandle),
                g_szDllContextHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)g_dwHelpArrayDialByPhoneNumber);

            return TRUE;

            break;


        default:
            break;
    }

    //
    // We fell through, so this procedure did not handle the message.
    //

    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
//
// dest phone nr is always editable
// otherwise the function is not called
//

HRESULT ShowDialByPhoneNumberDialog(
    IN  HWND         hwndParent,
    IN  BOOL         bAddParticipant,
    IN  BSTR         pDestPhoneNr,
    OUT BSTR       * ppDestPhoneNrChosen
    )
{ 
    ASSERT( ! IsBadWritePtr( ppDestAddressChosen, sizeof(BSTR) ) );

    //
    // Fill out a structure encapsulating the parameters that
    // will be passed to the dialog box procedure.
    //

    DialByPhoneNumberDialogProcParams stParams;

    stParams.bAddParticipant      = bAddParticipant;
    stParams.pDestPhoneNr         = pDestPhoneNr;
    stParams.ppDestPhoneNrChosen  = ppDestPhoneNrChosen;

    //
    // Call the dialog box procedure.
    //

    INT_PTR ipReturn;

    ipReturn = DialogBoxParam(
        _Module.GetResourceInstance(),
        (LPCTSTR) IDD_DIALOG_DIAL_BY_PHONE_NUMBER,
        hwndParent,
        DialByPhoneNumberDialogProc,
        (LPARAM) & stParams // LPARAM == INT_PTR
        );

    //
    // In the success case, the dialog box procedure has written
    // the out parameters to the specified addresses.
    //

    return ipReturn != -1 ? (HRESULT)ipReturn : HRESULT_FROM_WIN32(GetLastError());
}

//////////////////////////////////////////////////////////////////////////////
//
//

typedef struct
{
    IN   BSTR	        pDestAddress;
    OUT  BSTR         * ppDestAddressChosen;

} DialByMachineNameDialogProcParams;

//////////////////////////////////////////////////////////////////////////////
//
//

INT_PTR CALLBACK DialByMachineNameDialogProc(
    IN  HWND   hwndDlg,
    IN  UINT   uMsg,
    IN  WPARAM wParam,
    IN  LPARAM lParam
    )
{
    //
    // Static local used to return result of dialog.
    //

    static BSTR * s_ppAddressToDial = NULL;

    //
    // Handling for various window messages.
    //

    HRESULT hr;
    
    switch ( uMsg )
    {
        case WM_INITDIALOG:
        {
            DialByMachineNameDialogProcParams * pParams;

            //
            // Save return string parameter
            //

            pParams = (DialByMachineNameDialogProcParams *) lParam;

            s_ppAddressToDial = pParams->ppDestAddressChosen;

            if (pParams->pDestAddress == NULL)
            {
                //
                // Get the last called address
                //

                BSTR bstrLastAddress = NULL;

                hr = get_SettingsString( SS_LAST_ADDRESS, &bstrLastAddress );

                if ( SUCCEEDED(hr) )
                {
                    //
                    // Populate the dialog with the last called address
                    //

                    ::SetWindowText( ::GetDlgItem( hwndDlg, IDC_EDIT_COMPLETE ), bstrLastAddress );

                    SysFreeString( bstrLastAddress );
                }
            }
            else
            {
                //
                // Populate the dialog with the address passed in
                //

                ::SetWindowText( ::GetDlgItem( hwndDlg, IDC_EDIT_COMPLETE ), pParams->pDestAddress );
            }

            return TRUE;
        }

        case WM_COMMAND:

            switch ( LOWORD( wParam ) )
            {
                case IDOK:
                {
                    //
                    // Get the string from the edit box.
                    //

                    WCHAR * wszEditBoxString;

                    hr = GetStringFromEditBox(
                        hwndDlg,
                        IDC_EDIT_COMPLETE,
                        & wszEditBoxString
                        );

                    if ( SUCCEEDED(hr) )
                    {
                        //
                        // Save the address for next time
                        //

                        put_SettingsString( SS_LAST_ADDRESS, wszEditBoxString );

                        //
                        // Return the address
                        //

                        (*s_ppAddressToDial) = SysAllocString( wszEditBoxString );                        

                        RtcFree( wszEditBoxString );

                        if ( (*s_ppAddressToDial) == NULL )
                        {
                            hr = E_OUTOFMEMORY;
                        }
                   
                    }

                    EndDialog( hwndDlg, (LPARAM) hr );

                    return TRUE;
                }
                
                case IDCANCEL:
                {
                    EndDialog( hwndDlg, (LPARAM) E_ABORT );

                    return TRUE;
                }

                default:
                    break;
            }    
        
        case WM_CONTEXTMENU:

            ::WinHelp(
                (HWND)wParam,
                g_szDllContextHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)g_dwHelpArrayDialByName);

            return TRUE;

            break;

        case WM_HELP:


            ::WinHelp(
                (HWND)(((HELPINFO *)lParam)->hItemHandle),
                g_szDllContextHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)g_dwHelpArrayDialByName);

            return TRUE;

            break;

        default:
            break;
    }    

    //
    // We fell through, so this procedure did not handle the message.
    //

    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
//
// "Dial by address" = dial by name or IP address
//

HRESULT ShowDialByAddressDialog(
    IN   HWND           hwndParent,
    IN   BSTR	        pDestAddress,
    OUT  BSTR         * ppDestAddressChosen
    )
{
    ASSERT( ! IsBadWritePtr( ppDestAddressChosen, sizeof(BSTR) ) );

    //
    // Call the dialog box procedure.
    //

    DialByMachineNameDialogProcParams params;

    params.pDestAddress        = pDestAddress;
    params.ppDestAddressChosen = ppDestAddressChosen;

    INT_PTR ipReturn;

    ipReturn = DialogBoxParam(
        _Module.GetResourceInstance(),
        (LPCTSTR) IDD_DIALOG_DIAL_BY_NAME,
        hwndParent,
        DialByMachineNameDialogProc,
        (LPARAM) & params // LPARAM == INT_PTR
        );

    return ipReturn != -1 ? (HRESULT)ipReturn : HRESULT_FROM_WIN32(GetLastError());
}

//////////////////////////////////////////////////////////////////////////////
//
// "Message by address" = Send a Message by name or IP address
//

HRESULT ShowMessageByAddressDialog(
    IN   HWND           hwndParent,
    IN   BSTR	        pDestAddress,
    OUT  BSTR         * ppDestAddressChosen
    )
{
    ASSERT( ! IsBadWritePtr( ppDestAddressChosen, sizeof(BSTR) ) );

    //
    // Call the dialog box procedure.
    //

    DialByMachineNameDialogProcParams params;

    params.pDestAddress        = pDestAddress;
    params.ppDestAddressChosen = ppDestAddressChosen;

    INT_PTR ipReturn;

    ipReturn = DialogBoxParam(
        _Module.GetResourceInstance(),
        (LPCTSTR) IDD_DIALOG_MESSAGE_BY_NAME,
        hwndParent,
        DialByMachineNameDialogProc,
        (LPARAM) & params // LPARAM == INT_PTR
        );

    return ipReturn != -1 ? (HRESULT)ipReturn : HRESULT_FROM_WIN32(GetLastError());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\axctl\ctlreshm.h ===
extern WCHAR   g_szDllContextHelpFileName[];

// help ids

#define IDH_DIALOG_SERVICE_PROVIDERS_BUTTON_DELETE                          100

#define IDH_LOGON_EDIT_USERNAME                                             200
#define IDH_LOGON_EDIT_PASSWORD                                             201
#define IDH_LOGON_CHECK_SAVEPASSWORD                                        202

#define IDH_DIALOG_CALL_FROM_NUMBERS_BUTTON_ADD                             301
#define IDH_DIALOG_CALL_FROM_NUMBERS_BUTTON_MODIFY                          302
#define IDH_DIALOG_CALL_FROM_NUMBERS_BUTTON_REMOVE                          303
#define IDH_DIALOG_CALL_FROM_NUMBERS_LIST_NUMBERS                           304

#define IDH_DIALOG_DIAL_BY_PHONE_NUMBER_LIST_COUNTRY                        400
#define IDH_DIALOG_DIAL_BY_PHONE_NUMBER_EDIT_CITY                           401
#define IDH_DIALOG_DIAL_BY_PHONE_NUMBER_EDIT_LOCALNUMBER                    402
#define IDH_DIALOG_DIAL_BY_PHONE_NUMBER_EDIT_COMPLETENUMBER                 403
 
#define IDH_DIALOG_ADD_CALL_FROM_PHONE_NUMBER_EDIT_LABEL                    500
#define IDH_DIALOG_ADD_CALL_FROM_PHONE_NUMBER_LIST_COUNTRY                  501 
#define IDH_DIALOG_ADD_CALL_FROM_PHONE_NUMBER_EDIT_CITY                     502 
#define IDH_DIALOG_ADD_CALL_FROM_PHONE_NUMBER_EDIT_LOCALNUMBER              503
#define IDH_DIALOG_ADD_CALL_FROM_PHONE_NUMBER_EDIT_COMPLETENUMBER           504

#define IDH_DIALOG_DIAL_BY_NAME_EDIT_ADDRESS                                600

#define IDH_DIALOG_NEED_CALL_INFO_EDIT_ADDRESS                              700
#define IDH_DIALOG_NEED_CALL_INFO_LIST_ITSP                                 701
#define IDH_DIALOG_NEED_CALL_INFO_BUTTON_EDITSP                             702
#define IDH_DIALOG_NEED_CALL_INFO_RADIO_COMPUTER                            703
#define IDH_DIALOG_NEED_CALL_INFO_RADIO_PHONE                               704
#define IDH_DIALOG_NEED_CALL_INFO_LIST_PHONES                               705
#define IDH_DIALOG_NEED_CALL_INFO_BUTTON_EDITPHONE                          706
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\axctl\im.cpp ===
//
// im.cpp : Implementation of CIMWindow
//

#include "stdafx.h"
#include <shellapi.h>
#include <Commdlg.h>

/*
const TCHAR * g_szIMWindowClassName = _T("PhoenixIMWnd");
*/

static CHARFORMAT cfDefault =
{
	sizeof(CHARFORMAT),
	CFM_EFFECTS | CFM_PROTECTED | CFM_SIZE | CFM_OFFSET | CFM_COLOR | CFM_CHARSET | CFM_FACE,
	CFE_AUTOCOLOR,		// effects
	200,				// height, 200 twips == 10 points
	0,					// offset
	0,					// color (not used since CFE_AUTOCOLOR is specified)
	DEFAULT_CHARSET,
	FF_SWISS,			// pitch and family
	_T("Microsoft Sans Serif") // face name
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CIMWindowList
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//

CIMWindowList::CIMWindowList( IRTCClient * pClient)
{
    LOG((RTC_TRACE, "CIMWindowList::CIMWindowList"));

    m_pClient = pClient;
    m_pWindowList = NULL;
    m_lNumWindows = 0;   
    m_hRichEditLib = NULL;
}

/////////////////////////////////////////////////////////////////////////////
//
//

CIMWindowList::~CIMWindowList()
{
    LOG((RTC_TRACE, "CIMWindowList::~CIMWindowList"));

    if (m_pWindowList != NULL)
    {
        LONG lIndex;

        for (lIndex = 0; lIndex < m_lNumWindows; lIndex++)
        {
            m_pWindowList[lIndex]->DestroyWindow();

            delete m_pWindowList[lIndex];
            m_pWindowList[lIndex] = NULL;
        }

        RtcFree( m_pWindowList );
        m_pWindowList = NULL;
    }

    m_lNumWindows = 0;
    
    if (m_hRichEditLib != NULL)
    {
        FreeLibrary(m_hRichEditLib);
        m_hRichEditLib = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CIMWindowList::DeliverMessage( IRTCSession * pSession, IRTCParticipant * pParticipant, BSTR bstrMessage )
{
    LOG((RTC_TRACE, "CIMWindowList::DeliverMessage"));

    CIMWindow * pWindow = NULL;

    pWindow = FindWindow( pSession );

    if ( pWindow == NULL )
    {
        //
        // This is a new session
        //

        pWindow = NewWindow( pSession );

        if ( pWindow == NULL )
        {
            LOG((RTC_ERROR, "CIMWindowList::DeliverMessage - out of memory"));

            return E_OUTOFMEMORY;
        }
    }

    //
    // Deliver the message
    //

    pWindow->DeliverMessage( pParticipant, bstrMessage, TRUE );

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CIMWindowList::DeliverUserStatus( IRTCSession * pSession, IRTCParticipant * pParticipant, RTC_MESSAGING_USER_STATUS enStatus )
{
    LOG((RTC_TRACE, "CIMWindowList::DeliverUserStatus"));

    CIMWindow * pWindow = NULL;

    pWindow = FindWindow( pSession );

    if ( pWindow == NULL )
    {
        //
        // This is a new session
        //

        pWindow = NewWindow( pSession );

        if ( pWindow == NULL )
        {
            LOG((RTC_ERROR, "CIMWindowList::DeliverUserStatus - out of memory"));

            return E_OUTOFMEMORY;
        }
    }

    //
    // Deliver the user status
    //

    pWindow->DeliverUserStatus( pParticipant, enStatus );

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CIMWindowList::DeliverState( IRTCSession * pSession, RTC_SESSION_STATE SessionState )
{
    LOG((RTC_TRACE, "CIMWindowList::DeliverState"));

    CIMWindow * pWindow = NULL;

    pWindow = FindWindow( pSession );

    if ( pWindow == NULL )
    {
        //
        // This is a new session
        //

        pWindow = NewWindow( pSession );

        if ( pWindow == NULL )
        {
            LOG((RTC_ERROR, "CIMWindowList::DeliverState - out of memory"));

            return E_OUTOFMEMORY;
        }
    }

    //
    // Deliver the state
    //

    pWindow->DeliverState( SessionState );

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CIMWindowList::AddWindow( CIMWindow * pWindow )
{
    LOG((RTC_TRACE, "CIMWindowList::AddWindow"));

    CIMWindow ** pNewWindowList = NULL;

    //
    // Allocate a new array
    //

    pNewWindowList = (CIMWindow **)RtcAlloc( (m_lNumWindows + 1) * sizeof(CIMWindow *) );

    if ( pNewWindowList == NULL )
    {
        LOG((RTC_ERROR, "CIMWindowList::AddWindow - out of memory"));

        return E_OUTOFMEMORY;
    }

    if (m_pWindowList != NULL)
    {
        //
        // Copy old array contents
        //

        CopyMemory( pNewWindowList, m_pWindowList, m_lNumWindows * sizeof(CIMWindow *) );
    
        RtcFree( m_pWindowList );
    }

    pNewWindowList[m_lNumWindows] = pWindow;

    m_pWindowList = pNewWindowList;
    m_lNumWindows ++;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CIMWindowList::RemoveWindow( CIMWindow * pWindow )
{
    LOG((RTC_TRACE, "CIMWindowList::RemoveWindow"));

    LONG lIndex;

    if (m_pWindowList != NULL)
    {
        for (lIndex = 0; lIndex < m_lNumWindows; lIndex++)
        {
            if (m_pWindowList[lIndex] == pWindow)
            {
                //
                // Found window to remove. No need to reallocate the array,
                // just shift the old contents down.
                //

                if ((lIndex + 1) < m_lNumWindows)
                {
                    CopyMemory( &m_pWindowList[lIndex],
                                &m_pWindowList[lIndex+1],
                                (m_lNumWindows - lIndex - 1) * sizeof(CIMWindow *) );                    
                }

                m_lNumWindows--;
                m_pWindowList[m_lNumWindows] = NULL;

                return S_OK;
            }
        }
    }

    return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
//
//

CIMWindow * CIMWindowList::NewWindow( IRTCSession * pSession )
{
    LOG((RTC_TRACE, "CIMWindowList::NewWindow"));

    if (m_hRichEditLib == NULL)
    {
        //
        // Load the rich edit library if it hasn't been loaded yet
        //

        m_hRichEditLib = LoadLibrary(_T("riched20.dll"));

        if (m_hRichEditLib == NULL)
        {
            LOG((RTC_ERROR, "CIMWindowList::NewWindow - LoadLibrary failed 0x%x", HRESULT_FROM_WIN32(GetLastError())));

            return NULL;
        }
    }

    CIMWindow * pWindow = NULL;
    RECT rc;
    LONG lOffset;

    //
    // Cascade window start positions a bit
    //

    lOffset = (m_lNumWindows % 10) * 20;

    rc.top = 50 + lOffset;
    rc.left = 50 + lOffset;
    rc.right = 50 + lOffset + IM_WIDTH;
    rc.bottom = 50 + lOffset + IM_HEIGHT;

    // Get the monitor that has the largest area of intersecion with the
    // window rectangle. If the window rectangle intersects with no monitors
    // then we will use the nearest monitor.

    HMONITOR hMonitor = NULL;
    RECT rectWorkArea;
    BOOL fResult;
    int diffCord;

    hMonitor = MonitorFromRect( &rc, MONITOR_DEFAULTTONEAREST );

    LOG((RTC_INFO, "CIMWindowList::NewWindow - hMonitor [%p]", hMonitor));

    // Get the visible work area on the monitor

    if ( (hMonitor != NULL) && (hMonitor != INVALID_HANDLE_VALUE) )
    {      
        MONITORINFO monitorInfo;
        monitorInfo.cbSize = sizeof(MONITORINFO);

        fResult = GetMonitorInfo( hMonitor, &monitorInfo );

        rectWorkArea = monitorInfo.rcWork;

        DeleteObject( hMonitor );

        if (!fResult)
        {
            LOG((RTC_ERROR, "CIMWindowList::NewWindow - Failed GetMonitorInfo(%d)", 
                        GetLastError() ));
        }
    }
    else
    {
        // we can always fall back to non-multimon APIs if
        // MonitorFromRect failed.

        fResult = SystemParametersInfo(SPI_GETWORKAREA, 0, &rectWorkArea, 0);

        if (!fResult)
        {
            LOG((RTC_ERROR, "CIMWindowList::NewWindow - Failed SystemParametersInfo(%d)", 
                        GetLastError() ));
        }
    }   
      
    if (fResult)
    {
        LOG((RTC_INFO, "CIMWindowList::NewWindow - monitor work area is "
                    "%d, %d %d %d ",
                    rectWorkArea.left, rectWorkArea.top, 
                    rectWorkArea.right, rectWorkArea.bottom));

        // update x and y coordinates.

        // if top left is not visible, move it to the edge of the visible
        // area

        if (rc.left < rectWorkArea.left) 
        {
            rc.left = rectWorkArea.left;
        }

        if (rc.top < rectWorkArea.top)
        {
            rc.top = rectWorkArea.top;
        }

        // if bottom right corner is outside work area, we move the 
        // top left cornet back so that it becomes visible. Here the 
        // assumption is that the actual size is smaller than the 
        // visible work area.

        diffCord = rc.left + IM_WIDTH - rectWorkArea.right;

        if (diffCord > 0) 
        {
            rc.left -= diffCord;
        }

        diffCord = rc.top + IM_HEIGHT - rectWorkArea.bottom;

        if (diffCord > 0) 
        {
            rc.top -= diffCord;
        }

        rc.right = rc.left + IM_WIDTH;
        rc.bottom = rc.top + IM_HEIGHT;

        LOG((RTC_INFO, "CIMWindowList::NewWindow - new coords are "
                        "%d, %d %d %d ",
                        rc.left, rc.top, 
                        rc.right, rc.bottom));
    } 

    //
    // Create the window
    //

    pWindow = new CIMWindow(this);

    if (pWindow != NULL)
    {
        HRESULT hr;

        hr = AddWindow( pWindow );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CIMWindowList::NewWindow - AddWindow failed 0x%x", hr));

            delete pWindow;

            return NULL;
        }

        TCHAR   szString[0x40];

        szString[0] = _T('\0');

        LoadString(
            _Module.GetModuleInstance(),
            IDS_IM_WINDOW_TITLE,
            szString,
            sizeof(szString)/sizeof(szString[0]));

        pWindow->Create(NULL, rc, szString, WS_VISIBLE | WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN);

        pWindow->m_pSession = pSession;
    }

    return pWindow;
}

/////////////////////////////////////////////////////////////////////////////
//
//

CIMWindow * CIMWindowList::FindWindow( IRTCSession * pSession )
{
    LOG((RTC_TRACE, "CIMWindowList::FindWindow"));

    LONG lIndex;

    if (m_pWindowList != NULL)
    {
        for (lIndex = 0; lIndex < m_lNumWindows; lIndex++)
        {
            if (m_pWindowList[lIndex] != NULL)
            {
                if (m_pWindowList[lIndex]->m_pSession == pSession)
                {
                    return m_pWindowList[lIndex];
                }
            }
        }
    }

    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
//
//

BOOL CIMWindowList::IsDialogMessage( LPMSG lpMsg )
{
    //LOG((RTC_TRACE, "CIMWindowList::IsDialogMessage"));

    LONG lIndex;

    if (m_pWindowList != NULL)
    {
        for (lIndex = 0; lIndex < m_lNumWindows; lIndex++)
        {
            if (m_pWindowList[lIndex]->IsDialogMessage( lpMsg ))
            {
                return TRUE;
            }
        }
    }

    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CIMWindow
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//

CIMWindow::CIMWindow(CIMWindowList * pWindowList)
{
    LOG((RTC_TRACE, "CIMWindow::CIMWindow"));

    m_pIMWindowList = pWindowList;
    m_pSession = NULL;

    m_hIcon = NULL;
    m_hBkBrush = NULL;
    m_hMenu = NULL;

    m_bWindowActive = FALSE;
    m_bPlaySounds = TRUE;
    m_bNewWindow = TRUE;

    m_enStatus = RTCMUS_IDLE;

    m_szStatusText[0] = _T('\0');
}

/////////////////////////////////////////////////////////////////////////////
//
//

CIMWindow::~CIMWindow()
{
    LOG((RTC_TRACE, "CIMWindow::~CIMWindow"));
}


/////////////////////////////////////////////////////////////////////////////
//
//
/*
CWndClassInfo& CIMWindow::GetWndClassInfo() 
{ 
    LOG((RTC_TRACE, "CIMWindow::GetWndClassInfo"));

    static CWndClassInfo wc = 
    { 
        { sizeof(WNDCLASSEX), 0, StartWindowProc, 
          0, 0, NULL, NULL, NULL, NULL, NULL, g_szIMWindowClassName, NULL }, 
        NULL, NULL, IDC_ARROW, TRUE, 0, _T("") 
    }; 
    return wc;
}
*/

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CIMWindow::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT   hr;
    RECT      rcDummy;
    
    LOG((RTC_TRACE, "CIMWindow::OnCreate - enter"));

    ZeroMemory( &rcDummy, sizeof(RECT) );

    //
    // Load and set icons (both small and big)
    //
/*
    m_hIcon = LoadIcon(
        _Module.GetResourceInstance(),
        MAKEINTRESOURCE(IDI_APPICON)
        );

    SetIcon(m_hIcon, FALSE);
    SetIcon(m_hIcon, TRUE);
*/
    //
    // Create brush
    //

    m_hBkBrush = GetSysColorBrush( COLOR_3DFACE );

    //
    // Create the display control
    //

    m_hDisplay.Create(RICHEDIT_CLASS, m_hWnd, rcDummy, NULL,
        WS_CHILD | WS_VISIBLE | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL | ES_READONLY,
        WS_EX_CLIENTEDGE, IDC_IM_DISPLAY);

    m_hDisplay.SendMessage(EM_AUTOURLDETECT, TRUE, 0);
    m_hDisplay.SendMessage(EM_SETEVENTMASK, 0, ENM_LINK);
    m_hDisplay.SendMessage(EM_SETCHARFORMAT, SCF_ALL, (LPARAM)&cfDefault);  

    //
    // Create the edit control
    //

    m_hEdit.Create(RICHEDIT_CLASS, m_hWnd, rcDummy, NULL,
        WS_CHILD | WS_VISIBLE | WS_TABSTOP | ES_MULTILINE | ES_AUTOVSCROLL,
        WS_EX_CLIENTEDGE, IDC_IM_EDIT);  

    m_hEdit.SendMessage(EM_AUTOURLDETECT, TRUE, 0);
    m_hEdit.SendMessage(EM_SETEVENTMASK, 0, ENM_LINK | ENM_CHANGE);
    m_hEdit.SendMessage(EM_SETCHARFORMAT, SCF_ALL, (LPARAM)&cfDefault);

    //
    // Create the send button
    //

    TCHAR   szString[0x40];

    szString[0] = _T('\0');

    LoadString(
        _Module.GetModuleInstance(),
        IDS_IM_SEND,
        szString,
        sizeof(szString)/sizeof(szString[0]));

    m_hSendButton.Create(_T("BUTTON"), m_hWnd, rcDummy, szString,
        WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON | BS_DEFPUSHBUTTON,
        0, IDC_IM_SEND);

    //
    // Create a status control
    //

    HWND hStatusBar = CreateStatusWindow(
            WS_CHILD | WS_VISIBLE,
            NULL,
            m_hWnd,
            IDC_STATUSBAR);

    m_hStatusBar.Attach(hStatusBar);

    //
    // Create the menu
    //

    m_hMenu = LoadMenu( _Module.GetResourceInstance(), MAKEINTRESOURCE(IDC_IM_MENU) );

    if ( m_hMenu )
    {
        SetMenu( m_hMenu );

        CheckMenuRadioItem( m_hMenu,
                            IDM_IM_TOOLS_LARGEST,
                            IDM_IM_TOOLS_SMALLEST,
                            IDM_IM_TOOLS_SMALLER,
                            MF_BYCOMMAND );

        CheckMenuItem( m_hMenu, IDM_IM_TOOLS_SOUNDS, MF_CHECKED );
    }

    //
    // pozition the controls/set the tab order
    //

    PositionWindows();

    LOG((RTC_TRACE, "CIMWindow::OnCreate - exit"));
    
    return 0; 
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CIMWindow::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CIMWindow::OnDestroy - enter"));

    // Destroy windows objects

    if ( m_hIcon != NULL )
    {
        DeleteObject( m_hIcon );
        m_hIcon = NULL;
    }

    if ( m_hBkBrush != NULL )
    {
        DeleteObject( m_hBkBrush );
        m_hBkBrush = NULL;
    }

    if ( m_hMenu != NULL )
    {
        DestroyMenu( m_hMenu );
        m_hMenu = NULL;
    }

    // Terminate the session

    if ( m_pSession != NULL )
    {
        m_pSession->Terminate(RTCTR_NORMAL);
        m_pSession = NULL;
    }

    LOG((RTC_TRACE, "CIMWindow::OnDestroy - exiting"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CIMWindow::OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CIMWindow::OnSize - enter"));

    PositionWindows();

    LOG((RTC_TRACE, "CIMWindow::OnSize - exiting"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CIMWindow::OnSend(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CIMWindow::OnSend - enter"));

    USES_CONVERSION;

    LONG lNumChars;

    //
    // Get the edit box length
    //

    lNumChars = m_hEdit.SendMessage( WM_GETTEXTLENGTH, 0, 0 );  

    if ( lNumChars < 1 )
    {
        LOG((RTC_TRACE, "CIMWindow::OnSend - nothing to send"));
    }
    else
    {
        LPTSTR szEditString = NULL;        

        szEditString = (LPTSTR)RtcAlloc( (lNumChars + 1) * sizeof(TCHAR) );

        if ( szEditString == NULL )
        {
            LOG((RTC_ERROR, "CIMWindow::OnSend - out of memory"));

            return 0;
        }

        //
        // Read the edit box
        //

        m_hEdit.SendMessage( WM_GETTEXT, (WPARAM)(lNumChars + 1), (LPARAM)szEditString );

        //
        // Empty the edit box
        //

        m_hEdit.SendMessage( WM_SETTEXT, 0, 0 );

        //
        // Display the outgoing message
        //

        BSTR bstr = NULL;        

        bstr = T2BSTR( szEditString );

        RtcFree( szEditString );
        szEditString = NULL;

        if ( bstr == NULL )
        {
            LOG((RTC_ERROR, "CIMWindow::OnSend - out of memory"));

            return 0;
        }

        DeliverMessage( NULL, bstr, FALSE );

        //
        // Send the message
        //

        HRESULT hr;        
        LONG lCookie = 0;
    
        hr = m_pSession->SendMessage( NULL, bstr, lCookie );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CIMWindow::OnSend - SendMessage failed 0x%x", hr));
        }
    
        SysFreeString( bstr );
        bstr = NULL;
    }

    //
    // Set focus back to the edit control
    //

    ::SetFocus( m_hEdit );

    LOG((RTC_TRACE, "CIMWindow::OnSend - exiting"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CIMWindow::OnEraseBkgnd(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HDC hdc = (HDC)wParam;
    RECT rc;

    //
    // Fill the background
    //

    GetClientRect( &rc );

    FillRect( hdc, &rc, m_hBkBrush );

    return 1;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CIMWindow::OnActivate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    //
    // If activating the window, set focus to the edit control and stop any flashing
    //

    if (LOWORD(wParam) != WA_INACTIVE)
    {
        ::SetFocus( m_hEdit );

        FLASHWINFO flashinfo;

        flashinfo.cbSize = sizeof( FLASHWINFO );
        flashinfo.hwnd = m_hWnd;
        flashinfo.dwFlags = FLASHW_STOP;
        flashinfo.uCount = 0;
        flashinfo.dwTimeout = 0;

        FlashWindowEx( &flashinfo );
    }

    m_bWindowActive = (LOWORD(wParam) != WA_INACTIVE);

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CIMWindow::OnGetDefID(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{   
    //
    // Return the default pushbutton
    //

    return MAKELRESULT(IDC_IM_SEND, DC_HASDEFID);
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CIMWindow::OnNextDlgCtl(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{   
    //
    // Set focus to the next control
    //

    if ( LOWORD(lParam) )
    {
        ::SetFocus( (HWND)wParam );
    }

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CIMWindow::OnLink(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    //LOG((RTC_TRACE, "CIMWindow::OnLink - enter"));

    ENLINK * enlink;

    enlink = (ENLINK*)pnmh;

    if (enlink->msg == WM_LBUTTONDBLCLK)
    {
        LOG((RTC_TRACE, "CIMWindow::OnLink - WM_LBUTTONDBLCLK"));

        TEXTRANGE textrange;

        textrange.chrg = enlink->chrg;
        textrange.lpstrText = (LPTSTR)RtcAlloc( (enlink->chrg.cpMax - enlink->chrg.cpMin + 1) * sizeof(TCHAR) );

        if (textrange.lpstrText == NULL)
        {
            LOG((RTC_ERROR, "CIMWindow::OnLink - out of memory"));

            return 0;
        }
    
        if ( ::SendMessage( GetDlgItem( idCtrl ), EM_GETTEXTRANGE, 0, (LPARAM)&textrange ) )
        {
            LOG((RTC_INFO, "CIMWindow::OnLink - [%ws]", textrange.lpstrText));
        }   

        ShellExecute( NULL, NULL, textrange.lpstrText, NULL, NULL, SW_SHOWNORMAL);

        RtcFree( (LPVOID)textrange.lpstrText );

        return 1;
    }

    //LOG((RTC_TRACE, "CIMWindow::OnLink - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CIMWindow::OnChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    //LOG((RTC_TRACE, "CIMWindow::OnChange - enter"));

    BOOL bSendStatus = FALSE;

    if ( m_hEdit.SendMessage( WM_GETTEXTLENGTH, 0, 0 ) )
    {
        if ( m_enStatus != RTCMUS_TYPING )
        {
            //
            // Set status to typing
            //

            LOG((RTC_INFO, "CIMWindow::OnChange - RTCMUS_TYPING"));

            m_enStatus = RTCMUS_TYPING;
            bSendStatus = TRUE;
        }
    }
    else
    {
        if ( m_enStatus != RTCMUS_IDLE )
        {
            //
            // Set status to idle
            //

            LOG((RTC_INFO, "CIMWindow::OnChange - RTCMUS_IDLE"));

            m_enStatus = RTCMUS_IDLE;
            bSendStatus = TRUE;
        }
    }

    if ( bSendStatus )
    {
        HRESULT hr;        
        LONG lCookie = 0;
    
        hr = m_pSession->SendMessageStatus( m_enStatus, lCookie );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CIMWindow::OnChange - SendMessageStatus failed 0x%x", hr));
        }
    }

    //LOG((RTC_TRACE, "CIMWindow::OnChange - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

DWORD CALLBACK CIMWindow::EditStreamCallback(
        DWORD_PTR dwCookie,
        LPBYTE    pbBuff,
        LONG      cb,
        LONG    * pcb)
{
    LOG((RTC_TRACE, "CIMWindow::EditStreamCallback - enter"));

    LOG((RTC_INFO, "CIMWindow::EditStreamCallback - dwCookie [%x]", dwCookie));
    LOG((RTC_INFO, "CIMWindow::EditStreamCallback - pbBuff [%x]", pbBuff));
    LOG((RTC_INFO, "CIMWindow::EditStreamCallback - cb [%d]", cb));

    HANDLE hFile = (HANDLE)dwCookie;
    DWORD dwBytesWritten;

    if (!WriteFile( hFile, pbBuff, cb, &dwBytesWritten, NULL ))
    {
        LOG((RTC_ERROR, "CIMWindow::EditStreamCallback - WriteFile failed %d", GetLastError()));

        *pcb = 0;

        return 0;
    }

    *pcb = dwBytesWritten;

    LOG((RTC_TRACE, "CIMWindow::EditStreamCallback - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CIMWindow::OnSaveAs(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CIMWindow::OnSaveAs - enter"));

    TCHAR szFile[MAX_PATH];
    szFile[0] = _T('\0');

    TCHAR szFilter[256];
    ZeroMemory( szFilter, 256*sizeof(TCHAR) );

    if (!LoadString( _Module.GetResourceInstance(), IDS_IM_FILE_FILTER, szFilter, 256 ))
    {
        LOG((RTC_ERROR, "CIMWindow::OnSaveAs - LoadString failed %d", GetLastError()));

        return 0;
    }

    OPENFILENAME ofn;
    ZeroMemory( &ofn, sizeof(OPENFILENAME) );

    ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400;
    ofn.hwndOwner = m_hWnd;
    ofn.lpstrFilter = szFilter;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = MAX_PATH;

    WPARAM flags;

    if (GetSaveFileName( &ofn ))
    {
        LOG((RTC_TRACE, "CIMWindow::OnSaveAs - [%ws]", szFile));

        switch (ofn.nFilterIndex)
        {
        case 1:
            LOG((RTC_TRACE, "CIMWindow::OnSaveAs - Rich Text Format (RTF)"));

            flags = SF_RTF;
            break;

        case 2:
            LOG((RTC_TRACE, "CIMWindow::OnSaveAs - Text Document"));

            flags = SF_TEXT;
            break;

        case 3:
            LOG((RTC_TRACE, "CIMWindow::OnSaveAs - Unicode Text Document"));

            flags = SF_TEXT | SF_UNICODE;
            break;

        default:
            LOG((RTC_ERROR, "CIMWindow::OnSaveAs - unknown document type"));

            return 0;
        }
    }

    HANDLE hFile;
    
    hFile = CreateFile( szFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        LOG((RTC_ERROR, "CIMWindow::OnSaveAs - CreateFile failed %d", GetLastError()));

        return 0;
    }

    EDITSTREAM es;
    ZeroMemory( &es, sizeof(EDITSTREAM) );
    
    es.dwCookie = (DWORD_PTR)hFile;
    es.pfnCallback = CIMWindow::EditStreamCallback;

    m_hDisplay.SendMessage( EM_STREAMOUT, flags, (LPARAM)&es );

    CloseHandle( hFile );

    LOG((RTC_TRACE, "CIMWindow::OnSaveAs - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CIMWindow::OnClose(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CIMWindow::OnClose - enter"));

    DestroyWindow();

    LOG((RTC_TRACE, "CIMWindow::OnClose - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CIMWindow::OnPlaySounds(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CIMWindow::OnPlaySounds - enter"));

    m_bPlaySounds = !m_bPlaySounds;

    CheckMenuItem( m_hMenu, IDM_IM_TOOLS_SOUNDS, m_bPlaySounds ? MF_CHECKED : MF_UNCHECKED );

    LOG((RTC_TRACE, "CIMWindow::OnPlaySounds - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CIMWindow::OnTextSize(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CIMWindow::OnTextSize - enter"));

    CHARFORMAT cf;

    cf.cbSize = sizeof(CHARFORMAT);
    cf.dwMask = CFM_SIZE;    

    switch ( wID )
    {
    case IDM_IM_TOOLS_LARGEST:
        CheckMenuRadioItem( m_hMenu,
                            IDM_IM_TOOLS_LARGEST,
                            IDM_IM_TOOLS_SMALLEST,
                            IDM_IM_TOOLS_LARGEST,
                            MF_BYCOMMAND );

        cf.yHeight = 320;
        break;

    case IDM_IM_TOOLS_LARGER:
        CheckMenuRadioItem( m_hMenu,
                            IDM_IM_TOOLS_LARGEST,
                            IDM_IM_TOOLS_SMALLEST,
                            IDM_IM_TOOLS_LARGER,
                            MF_BYCOMMAND );

        cf.yHeight = 280;
        break;

    case IDM_IM_TOOLS_MEDIUM:
        CheckMenuRadioItem( m_hMenu,
                            IDM_IM_TOOLS_LARGEST,
                            IDM_IM_TOOLS_SMALLEST,
                            IDM_IM_TOOLS_MEDIUM,
                            MF_BYCOMMAND );

        cf.yHeight = 240;
        break;

    case IDM_IM_TOOLS_SMALLER:
        CheckMenuRadioItem( m_hMenu,
                            IDM_IM_TOOLS_LARGEST,
                            IDM_IM_TOOLS_SMALLEST,
                            IDM_IM_TOOLS_SMALLER,
                            MF_BYCOMMAND );

        cf.yHeight = 200;
        break;

    case IDM_IM_TOOLS_SMALLEST:
        CheckMenuRadioItem( m_hMenu,
                            IDM_IM_TOOLS_LARGEST,
                            IDM_IM_TOOLS_SMALLEST,
                            IDM_IM_TOOLS_SMALLEST,
                            MF_BYCOMMAND );

        cf.yHeight = 160;
        break;

    default:
        LOG((RTC_ERROR, "CIMWindow::OnTextSize - invalid text size"));

        return 0;
    }

    m_hDisplay.SendMessage(EM_SETCHARFORMAT, SCF_ALL, (LPARAM)&cf);
    m_hEdit.SendMessage(EM_SETCHARFORMAT, SCF_ALL, (LPARAM)&cf);

    LOG((RTC_TRACE, "CIMWindow::OnTextSize - exit"));

    return 0;
}

///////////////////////////////////////////////////////////////////////////////
// PositionWindows
//      Positions and sizes all the controls to their "initial" position
//  This function also establishes the right tab order

void CIMWindow::PositionWindows()
{
    RECT rcClient;
    RECT rcWnd;

    #define EDGE_SPACING  10
    #define BUTTON_HEIGHT 60
    #define BUTTON_WIDTH  60
    #define STATUS_HEIGHT 20

    GetClientRect( &rcClient );

    rcClient.top += EDGE_SPACING;
    rcClient.bottom -= EDGE_SPACING + STATUS_HEIGHT;
    rcClient.left += EDGE_SPACING;
    rcClient.right -= EDGE_SPACING;

    //
    // Display control
    //

    rcWnd = rcClient;

    rcWnd.bottom -= EDGE_SPACING + BUTTON_HEIGHT;

    m_hDisplay.SetWindowPos( HWND_TOP,
        rcWnd.left, rcWnd.top,
        rcWnd.right - rcWnd.left,
        rcWnd.bottom - rcWnd.top,
        0
        );

    //
    // Edit control
    //

    rcWnd = rcClient;

    rcWnd.top = rcWnd.bottom - BUTTON_HEIGHT;
    rcWnd.right -= BUTTON_WIDTH + EDGE_SPACING;

    m_hEdit.SetWindowPos( m_hDisplay,
        rcWnd.left, rcWnd.top,
        rcWnd.right - rcWnd.left,
        rcWnd.bottom - rcWnd.top,
        0
        );

    //
    // Send button control
    //

    rcWnd = rcClient;

    rcWnd.top = rcWnd.bottom - BUTTON_HEIGHT;
    rcWnd.left = rcWnd.right - BUTTON_WIDTH;

    m_hSendButton.SetWindowPos( m_hEdit,
        rcWnd.left, rcWnd.top,
        rcWnd.right - rcWnd.left,
        rcWnd.bottom - rcWnd.top,
        0
        );

    //
    // Status bar
    //

    m_hStatusBar.SetWindowPos( m_hSendButton,
        0, 0, 0, 0,
        0
        );
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CIMWindow::GetFormattedNameFromParticipant( IRTCParticipant * pParticipant, BSTR * pbstrName )
{
    LOG((RTC_TRACE, "CIMWindow::GetFormattedNameFromParticipant - enter"));

    HRESULT hr = S_OK;

    // get the user name

    hr = pParticipant->get_Name( pbstrName );

    if ( SUCCEEDED(hr) )
    {
        if ( wcscmp( *pbstrName, L"")==0 )
        {
            // the user name is blank

            SysFreeString( *pbstrName );
            *pbstrName = NULL;

            hr = E_FAIL;
        }
    }

    if ( FAILED(hr) )
    {
        // if the user name is no good, get the user URI

        BSTR bstrURI = NULL;

        hr = pParticipant->get_UserURI( &bstrURI );

        if ( SUCCEEDED(hr) )
        {
            if ( wcscmp(bstrURI, L"")==0 )
            {
                // the user URI is blank

                *pbstrName = NULL;

                hr = E_FAIL;
            }
            else
            {
                // good user URI, encapsulate it in <> to make it look better

                *pbstrName = SysAllocStringLen( L"<", wcslen( bstrURI ) + 2 );

                if ( *pbstrName != NULL )
                {
                    wcscat( *pbstrName, bstrURI );
                    wcscat( *pbstrName, L">" );
                }
                else
                {
                    *pbstrName = NULL;

                    hr = E_FAIL;
                }                    
            }

            SysFreeString( bstrURI );
            bstrURI = NULL;
        }
    }
    
    LOG((RTC_TRACE, "CIMWindow::GetFormattedNameFromParticipant - exit"));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CIMWindow::DeliverMessage( IRTCParticipant * pParticipant, BSTR bstrMessage, BOOL bIncoming )
{
    LOG((RTC_TRACE, "CIMWindow::DeliverMessage"));

    USES_CONVERSION;

    //
    // Set selection to end of the display box
    //

    int nLastChar =  (int)m_hDisplay.SendMessage( WM_GETTEXTLENGTH, 0, 0 );

    CHARRANGE charRange = {0};
    charRange.cpMin = charRange.cpMax = nLastChar + 1;

    m_hDisplay.SendMessage( EM_EXSETSEL, 0, (LPARAM)&charRange );

    //
    // Set format for the "from text"
    //

    CHARFORMAT cf;
    PARAFORMAT pf;

    cf.cbSize = sizeof(CHARFORMAT);
    cf.dwMask = CFM_COLOR;
    cf.dwEffects = 0;
    cf.crTextColor = RGB(0,128,128);

    m_hDisplay.SendMessage(EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);

    pf.cbSize = sizeof(PARAFORMAT);
    pf.dwMask = PFM_STARTINDENT;
    pf.dxStartIndent = 50;

    m_hDisplay.SendMessage(EM_SETPARAFORMAT, 0, (LPARAM)&pf);

    //
    // Add the "from text"
    //

    BSTR bstrName = NULL;
    HRESULT hr = E_FAIL;
    TCHAR   szString[0x40];

    if ( pParticipant != NULL )
    {   
        hr = GetFormattedNameFromParticipant( pParticipant, &bstrName );
    }

    if ( FAILED(hr) && (!bIncoming) )
    {
        // get to local user name

        hr = get_SettingsString( SS_USER_DISPLAY_NAME, &bstrName );

        if ( SUCCEEDED(hr) )
        {
            if ( wcscmp(bstrName, L"")==0 )
            {
                // the display name is blank

                SysFreeString( bstrName );
                bstrName = NULL;

                hr = E_FAIL;
            }                                    
        }
    }

    if ( SUCCEEDED(hr) )
    {
        // got a good name       

        m_hDisplay.SendMessage( EM_REPLACESEL, (WPARAM)FALSE, (LPARAM)W2T(bstrName) );            

        SysFreeString( bstrName );
        bstrName = NULL;
    }
    else
    {
        // didn't get a good name, use something generic
        szString[0] = _T('\0');

        LoadString(
                _Module.GetModuleInstance(),
                bIncoming ? IDS_IM_INCOMING_MESSAGE : IDS_IM_OUTGOING_MESSAGE,
                szString,
                sizeof(szString)/sizeof(szString[0]));    
        
        m_hDisplay.SendMessage( EM_REPLACESEL, (WPARAM)FALSE, (LPARAM)szString );
    }       

    szString[0] = _T('\0');

    LoadString(
            _Module.GetModuleInstance(),
            IDS_IM_SAYS,
            szString,
            sizeof(szString)/sizeof(szString[0]));    
    
    m_hDisplay.SendMessage( EM_REPLACESEL, (WPARAM)FALSE, (LPARAM)szString );

    //
    // Set format for the "message text"
    //

    cf.cbSize = sizeof(CHARFORMAT);
    cf.dwMask = CFM_COLOR;
    cf.dwEffects = CFE_AUTOCOLOR;
    cf.crTextColor = 0;

    m_hDisplay.SendMessage(EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);

    pf.cbSize = sizeof(PARAFORMAT);
    pf.dwMask = PFM_STARTINDENT;
    pf.dxStartIndent = 200;

    m_hDisplay.SendMessage(EM_SETPARAFORMAT, 0, (LPARAM)&pf);

    //
    // Add the "message text"
    //

    m_hDisplay.SendMessage( EM_REPLACESEL, (WPARAM)FALSE, (LPARAM)W2T(bstrMessage) );

    //
    // Add line break
    //

    m_hDisplay.SendMessage( EM_REPLACESEL, (WPARAM)FALSE, (LPARAM)_T("\n") );

    //
    // Scroll the display to the bottom
    //

    m_hDisplay.SendMessage( WM_VSCROLL, SB_BOTTOM, 0 );

    //
    // Set status text
    //

    TCHAR szTime[64];
    TCHAR szDate[64];
    TCHAR szAt[64];
    TCHAR szOn[64];
    TCHAR szStatus[64];

    szStatus[0] = _T('\0');

    LoadString(
            _Module.GetModuleInstance(),
            bIncoming ? IDS_IM_MESSAGE_RECEIVED : IDS_IM_MESSAGE_SENT,
            szStatus,
            sizeof(szStatus)/sizeof(szStatus[0])); 

    szAt[0] = _T('\0');

    LoadString(
            _Module.GetModuleInstance(),
            IDS_IM_AT,
            szAt,
            sizeof(szAt)/sizeof(szAt[0])); 

    szOn[0] = _T('\0');

    LoadString(
            _Module.GetModuleInstance(),
            IDS_IM_ON,
            szOn,
            sizeof(szOn)/sizeof(szOn[0])); 
    
    if ( GetTimeFormat(
            LOCALE_USER_DEFAULT, // locale
            TIME_NOSECONDS,     // options
            NULL,               // time
            NULL,               // time format string
            szTime,             // formatted string buffer
            64
            ) )
    {
        if ( GetDateFormat(
                LOCALE_USER_DEFAULT,    // locale
                DATE_SHORTDATE,         // options
                NULL,                   // date
                NULL,                   // date format
                szDate,                 // formatted string buffer
                64
                ) )
        {
            _sntprintf( m_szStatusText, 256, _T("%s %s %s %s %s."),
                    szStatus, szAt, szTime, szOn, szDate );
        }
        else
        {
            _sntprintf( m_szStatusText, 256, _T("%s %s %s."),
                    szStatus, szAt, szTime );
        }
    }
    else
    {
        _sntprintf( m_szStatusText, 256, _T("%s."),
                    szStatus );
    }

    m_hStatusBar.SendMessage(WM_SETTEXT, 0, (LPARAM)m_szStatusText);

    if ( bIncoming )
    {
        //
        // Play a sound
        //

        if ( m_bPlaySounds && (m_bNewWindow || !m_bWindowActive) )
        {
            hr = m_pIMWindowList->m_pClient->PlayRing( RTCRT_MESSAGE, TRUE );
        }

        //
        // If the window isn't active, flash it
        //

        if ( !m_bWindowActive )
        {
            FLASHWINFO flashinfo;

            flashinfo.cbSize = sizeof( FLASHWINFO );
            flashinfo.hwnd = m_hWnd;
            flashinfo.dwFlags = FLASHW_TIMER | FLASHW_ALL;
            flashinfo.uCount = 0;
            flashinfo.dwTimeout = 0;

            FlashWindowEx( &flashinfo );
        }
    }

    m_bNewWindow = FALSE;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CIMWindow::DeliverUserStatus( IRTCParticipant * pParticipant, RTC_MESSAGING_USER_STATUS enStatus )
{
    LOG((RTC_TRACE, "CIMWindow::DeliverUserStatus"));
    
    HRESULT hr;   
    
    switch ( enStatus )
    {
    case RTCMUS_IDLE:
        // restore the old status text
        m_hStatusBar.SendMessage(WM_SETTEXT, 0, (LPARAM)m_szStatusText);

        break;

    case RTCMUS_TYPING:
        {
            BSTR bstrName = NULL;  
            
            hr = GetFormattedNameFromParticipant( pParticipant, &bstrName );

            if ( SUCCEEDED(hr) )
            {
                TCHAR   szString[0x40];

                szString[0] = _T('\0');

                LoadString(
                    _Module.GetModuleInstance(),
                    IDS_IM_TYPING,
                    szString,
                    sizeof(szString)/sizeof(szString[0]));

                LPTSTR szStatusText = NULL;

                szStatusText = (LPTSTR)RtcAlloc( 
                    (_tcslen(szString) + wcslen(bstrName) + 1) * sizeof(TCHAR)
                    );                    

                if ( szStatusText != NULL )
                {
                    _tcscpy( szStatusText, W2T(bstrName) );
                    _tcscat( szStatusText, szString );

                    m_hStatusBar.SendMessage(WM_SETTEXT, 0, (LPARAM)szStatusText);

                    RtcFree( szStatusText );
                } 
                
                SysFreeString( bstrName );
                bstrName = NULL;
            }
        }

        break;

    default:
        LOG((RTC_ERROR, "CIMWindow::DeliverUserStatus - "
            "invalid user status"));
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CIMWindow::DeliverState( RTC_SESSION_STATE SessionState )
{
    LOG((RTC_TRACE, "CIMWindow::DeliverState"));

    //
    // Update participants
    //

    HRESULT hr;
    IRTCEnumParticipants * pEnumPart = NULL;
    IRTCParticipant      * pPart = NULL;

    TCHAR   szString[0x40];

    szString[0] = _T('\0');

    LoadString(
        _Module.GetModuleInstance(),
        IDS_IM_WINDOW_TITLE,
        szString,
        sizeof(szString)/sizeof(szString[0]));

    if ( m_pSession != NULL )
    {
        hr = m_pSession->EnumerateParticipants( &pEnumPart );

        if ( SUCCEEDED(hr) )
        {
            while ( S_OK == pEnumPart->Next( 1, &pPart, NULL ) )
            {
                BSTR bstrName = NULL;

                hr = GetFormattedNameFromParticipant( pPart, &bstrName );

                pPart->Release();
                pPart = NULL; 

                if ( SUCCEEDED(hr) )
                {
                    LPTSTR szWindowTitle = NULL;

                    szWindowTitle = (LPTSTR)RtcAlloc( 
                        (_tcslen(szString) + _tcslen(_T(" - ")) + wcslen(bstrName) + 1) * sizeof(TCHAR)
                        );                    

                    if ( szWindowTitle != NULL )
                    {
                        _tcscpy( szWindowTitle, W2T(bstrName) );
                        _tcscat( szWindowTitle, _T(" - ") );
                        _tcscat( szWindowTitle, szString );

                        SetWindowText( szWindowTitle );

                        RtcFree( szWindowTitle );
                    }

                    SysFreeString( bstrName );
                    bstrName = NULL;

                    break; // just get one for now
                }                                            
            }

            pEnumPart->Release();
            pEnumPart = NULL;
        }
    }

    if ( SessionState == RTCSS_DISCONNECTED )
    {
        //
        // Set status text
        //

        m_szStatusText[0] = _T('\0');

        LoadString(
            _Module.GetModuleInstance(),
            IDS_IM_DISCONNECTED,
            m_szStatusText,
            sizeof(m_szStatusText)/sizeof(m_szStatusText[0]));

        m_hStatusBar.SendMessage(WM_SETTEXT, 0, (LPARAM)m_szStatusText);

        //
        // Disable the edit box and send button
        //

        m_hEdit.EnableWindow(FALSE);
        m_hSendButton.EnableWindow(FALSE);

        //
        // Empty the edit box
        //

        m_hEdit.SendMessage( WM_SETTEXT, 0, 0 );
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\axctl\knob.cpp ===
// knob.cpp : Implementation of CKnobCtl
//  Inspired from CDPlayer code written by dstewart


#include "stdafx.h"
#include "knob.h"

#define LIGHT_OFFSET 13
#define RADIAN_45DEG  0.785398163397448309615
#define RADIAN_90DEG  1.57079632679489661923
#define RADIAN_135DEG 2.356194490192344899999999999925
#define DEGREE_CONVERTER 57.295779513082320876846364344191
#define RADIAN_CONVERTER 0.017453292519943295769222222222222

#define TRACK_TICK 5
#define FAST_TRACK_TICK 1
#define TRACK_DEGREES_PER_TICK 10

#define FLASH_TICK      150
#define KEYBOARD_STEP   3000
    


// Constructor
// 

CKnobCtl::CKnobCtl(
        UINT    nResRest,
        UINT    nResHot,
        UINT    nResDis,
        UINT    nResLightBright,
        UINT    nResLightDim,
        UINT    nResLightDis,
        UINT    nResLightMask)
{
    m_nID = 0;
    m_nLightX = 0;
    m_nLightY = 0;
    m_dwRange = 0xFFFF;
    m_dwPosition = 0;
    m_dwCurPosition = 0;
    m_fDim = TRUE;
    m_fEnabled = TRUE;

    m_nLightWidth = 0;
    m_nLightHeight = 0;
    m_nKnobWidth = 0;
    m_nKnobHeight = 0;

    m_hKnob = NULL;
    m_hKnobTab = NULL;
    m_hKnobDisabled = NULL;
    m_hLight = NULL;
    m_hLightBright = NULL;
    m_hLightDisabled = NULL;
    m_hLightMask = NULL;

    m_hPalette = NULL;
    m_bBackgroundPalette = FALSE;

    m_AudioLevel = 0.0;
    
    // tweak some fields of the WNDCLASSEX structure
    //
    CWndClassInfo&  wci = GetWndClassInfo();

    // if the wc hasn't already been registered, update it
    if(!wci.m_atom)
    {
        // brush (doesn't really matter, I think
        wci.m_wc.hbrBackground = (HBRUSH)(CTLCOLOR_DLG + 1);

        // cursor (treated differently, ATL "feature")
        wci.m_bSystemCursor = FALSE;
        wci.m_lpszCursorID = MAKEINTRESOURCE(IDC_VOLHAND);
    }

    // Load bitmaps
    LoadAllResources(
        nResRest,
        nResHot,
        nResDis,
        nResLightBright,
        nResLightDim,
        nResLightDis,
        nResLightMask);
}


// Destructor
// 

CKnobCtl::~CKnobCtl()
{
    if(m_hLight)
    {
        GlobalFree(m_hLight);
    }
    if(m_hLightBright)
    {
        GlobalFree(m_hLightBright);
    }
    if(m_hLightDisabled)
    {
        GlobalFree(m_hLightDisabled);
    }
    if(m_hKnob)
    {
        GlobalFree(m_hKnob);
    }
    if(m_hKnobTab)
    {
        GlobalFree(m_hKnobTab);
    }
    if(m_hKnobDisabled)
    {
        GlobalFree(m_hKnobDisabled);
    }
    if(m_hLightMask)
    {
        DeleteObject(m_hLightMask);
    }
}


// LoadAllResources
// 

void CKnobCtl::LoadAllResources(        
        UINT    nResRest,
        UINT    nResHot,
        UINT    nResDis,
        UINT    nResLightBright,
        UINT    nResLightDim,
        UINT    nResLightDis,
        UINT    nResLightMask)
{
    HBITMAP hbmpTemp;

    //
    // Load all bitmaps and convert them to DIBs
    //
    hbmpTemp = (HBITMAP)LoadImage(
        _Module.GetResourceInstance(),
        MAKEINTRESOURCE(nResRest),
        IMAGE_BITMAP,
        0,
        0,
        LR_CREATEDIBSECTION);
    
    if(hbmpTemp)
    {
        m_hKnob = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);
        
        BITMAP bm;
        
        GetObject(hbmpTemp,sizeof(bm),&bm);
        
        m_nKnobWidth = bm.bmWidth;
        m_nKnobHeight = bm.bmHeight;

        DeleteObject(hbmpTemp);
    }

    hbmpTemp = (HBITMAP)LoadImage(
        _Module.GetResourceInstance(),
        MAKEINTRESOURCE(nResHot),
        IMAGE_BITMAP,
        0,
        0,
        LR_CREATEDIBSECTION);

    if(hbmpTemp)
    {
        m_hKnobTab = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);

        DeleteObject(hbmpTemp);
    }
    
    hbmpTemp = (HBITMAP)LoadImage(
        _Module.GetResourceInstance(),
        MAKEINTRESOURCE(nResDis),
        IMAGE_BITMAP,
        0,
        0,
        LR_CREATEDIBSECTION);

    if(hbmpTemp)
    {
        m_hKnobDisabled = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);

        DeleteObject(hbmpTemp);
    }

    hbmpTemp = (HBITMAP)LoadImage(
        _Module.GetResourceInstance(),
        MAKEINTRESOURCE(nResLightDim),
        IMAGE_BITMAP,
        0,
        0,
        LR_CREATEDIBSECTION);
    
    if(hbmpTemp)
    {
        m_hLight = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);
        
        BITMAP bm;
        
        GetObject(hbmpTemp,sizeof(bm),&bm);
        
        m_nLightWidth = bm.bmWidth;
        m_nLightHeight = bm.bmHeight;
        
        DeleteObject(hbmpTemp);
    }

    hbmpTemp = (HBITMAP)LoadImage(
        _Module.GetResourceInstance(),
        MAKEINTRESOURCE(nResLightBright),
        IMAGE_BITMAP,
        0,
        0,
        LR_CREATEDIBSECTION);
    
    if(hbmpTemp)
    {
        m_hLightBright = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);

        DeleteObject(hbmpTemp);
    }

    hbmpTemp = (HBITMAP)LoadImage(
        _Module.GetResourceInstance(),
        MAKEINTRESOURCE(nResLightDis),
        IMAGE_BITMAP,
        0,
        0,
        LR_CREATEDIBSECTION);
    
    if(hbmpTemp)
    {
        m_hLightDisabled = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);

        DeleteObject(hbmpTemp);
    }

    CKnobCtl::m_hLightMask = (HBITMAP)LoadImage(
        _Module.GetResourceInstance(),
        MAKEINTRESOURCE(nResLightMask),
        IMAGE_BITMAP,
        0,
        0,
        LR_MONOCHROME);

}


HWND CKnobCtl::Create(
    HWND    hParent,
    int     x,
    int     y,
    UINT    nID
    )
{
    RECT    rectPos;

    rectPos.left = x;
    rectPos.top = y;

    rectPos.right = rectPos.left + m_nKnobWidth;
    rectPos.bottom = rectPos.top + m_nKnobHeight;
    
    return CWindowImpl<CKnobCtl, CWindow, CKnobTraits>::Create(
            hParent,
            rectPos,
            NULL,
            0,
            0,
            nID);
}


// OnCreate
// 

LRESULT CKnobCtl::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // init the ID
    m_nID = GetDlgCtrlID();

//    HRGN    hRegion = CreateEllipticRgn(
//        0, 
//        0, 
//        m_nKnobWidth+1,
//        m_nKnobHeight+1
//        );

//    SetWindowRgn(hRegion, FALSE);

    return 0;
}


// OnSetFocus
// 

LRESULT CKnobCtl::OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    ::SendMessage(GetParent(),DM_SETDEFID,m_nID,0);

    m_fDim = FALSE;
    
    InvalidateRect(NULL,FALSE);
    UpdateWindow();

    SetTimer(TID_FLASH, FLASH_TICK);

    return 0;
}

// OnKillFocus
// 

LRESULT CKnobCtl::OnKillFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    KillTimer(TID_FLASH);
    
    m_fDim = TRUE;
    
    InvalidateRect(NULL,FALSE);
    UpdateWindow();

    return 0;
}

// OnGetDlgCode
// 

LRESULT CKnobCtl::OnGetDlgCode(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // yes, we need arrows
    return (DLGC_WANTARROWS);
}

// OnEraseBackground
// 

LRESULT CKnobCtl::OnEraseBackground(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // do nothing
    return 1;
}

// OnPaint
// 

LRESULT CKnobCtl::OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HDC hdc;
    PAINTSTRUCT ps;

    hdc = BeginPaint( &ps );

    Draw(hdc);

    EndPaint(&ps);
    
    return 0;
}


// OnKeyDown
// 

LRESULT CKnobCtl::OnKeyDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{

    int nVirtKey = (int)wParam;

    DWORD dwCurrent = GetPosition();

    switch (nVirtKey)
    {
    case VK_LEFT :
    case VK_DOWN :
        {
            if (dwCurrent - KEYBOARD_STEP > 65535)
            {
                dwCurrent = KEYBOARD_STEP;
            }
            SetPosition(dwCurrent - KEYBOARD_STEP,TRUE);

            NMHDR nmhdr;
            nmhdr.hwndFrom = m_hWnd;
            nmhdr.idFrom = m_nID;
            nmhdr.code = TRUE;

            ::SendMessage(GetParent(),WM_NOTIFY,(WPARAM)m_nID,(LPARAM)&nmhdr);
        }
        break;
    
    case VK_RIGHT :
    case VK_UP :
        {
            if (dwCurrent + KEYBOARD_STEP > 65535)
            {
                dwCurrent = 65535 - KEYBOARD_STEP;
            }
            SetPosition(dwCurrent + KEYBOARD_STEP,TRUE);

            NMHDR nmhdr;
            nmhdr.hwndFrom = m_hWnd;
            nmhdr.idFrom = m_nID;
            nmhdr.code = TRUE;

            ::SendMessage(GetParent(),WM_NOTIFY,(WPARAM)m_nID,(LPARAM)&nmhdr);
         }
         break;

    default:
        {
            //not a key we want ... tell our parent about it
            ::SendMessage(GetParent(),WM_KEYDOWN,wParam,lParam);
        }
        break;
    } //end switch

    return 0;
}


// OnRightButtonDown
// 

LRESULT CKnobCtl::OnRightButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    m_fFastKnob = TRUE;

    OnButtonDown(LOWORD(lParam),HIWORD(lParam));
    OnMouseMove(0, 0, lParam,bHandled);
    
    return 0;
}


// OnLeftButtonDown
// 

LRESULT CKnobCtl::OnLeftButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    m_fFastKnob = FALSE;

    OnButtonDown(LOWORD(lParam),HIWORD(lParam));
    OnMouseMove(0, 0, lParam,bHandled);
    
    return 0;
}


// OnButtonUp
// 

LRESULT CKnobCtl::OnButtonUp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    KillTimer(TID_FLASH);
    KillTimer(TID_TRACK);

    //we want to be sure the light is dim when we're done
    if (!m_fDim)
    {
        m_fDim = TRUE;
        InvalidateRect(NULL,FALSE);
        UpdateWindow();
    }

    ReleaseCapture();
    
    return 0;
}

// OnButtonDown
// 

void CKnobCtl::OnButtonDown(int x, int y)
{
    SetCapture();

    m_fDim = FALSE;

    InvalidateRect(NULL,FALSE);
    UpdateWindow();

    SetTimer(TID_FLASH,FLASH_TICK);
}



// OnMouseMove
// 

LRESULT CKnobCtl::OnMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    int x = LOWORD(lParam);
    int y = HIWORD(lParam);

    if (GetCapture()==m_hWnd)
    {
        //do the calculations as if 0,0 were the center of the control,
        //then translate to gdi coordinates later (0,0 = top left of control in gdi)
        
        RECT rect;
        GetClientRect(&rect);
            
        int nWidth = rect.right - rect.left;
        int nHeight = rect.bottom - rect.top;

        int maxdist = (nWidth / 2) + 3;
        int radius = (nWidth / 2) - LIGHT_OFFSET;

        //convert to short to force negative numbers for coordinates
        short sx = (short)x;
        short sy = (short)y;

        int deltaX = sx - (nWidth / 2);
        int deltaY = sy - (nHeight / 2);

        ComputeCursor(deltaX, deltaY, maxdist);

        double angle = atan2(deltaY,deltaX);
        double degrees = angle * DEGREE_CONVERTER;

        degrees = degrees + 225;

        if (degrees < 0) 
        {
            degrees = 0;
        }

        if (degrees >= 360)
        {
            degrees = degrees - 360;
        }

        double percentage = degrees / 270;

        m_dwPosition = (DWORD)(m_dwRange * percentage);

        //special-case the "dead zone"
        if ((degrees >= 270) && (degrees <= 315))
        {
            m_dwPosition = m_dwRange;
        }

        if (degrees > 315)
        {
            m_dwPosition = 0;
        }

        if (m_fFastKnob)
        {
            SetTimer(TID_TRACK,FAST_TRACK_TICK);
        }
        else
        {
            SetTimer(TID_TRACK,TRACK_TICK);
        }
    }

    return 0;
}


// OnTimer
// 

LRESULT CKnobCtl::OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    switch(wParam)
    {
    case TID_FLASH:
        
        OnFlashTimer();
    
        break;
    
    case TID_TRACK:

        OnTrackTimer();

        break;
    }

    return 0;
}

// OnEnable
// 

LRESULT CKnobCtl::OnEnable(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    BOOL bNeedUpdate;

    bNeedUpdate = (m_fEnabled && !wParam) 
                ||(!m_fEnabled && wParam);
    
    m_fEnabled = (BOOL)wParam;

    if(bNeedUpdate)
    {
        InvalidateRect(NULL,FALSE);
        UpdateWindow();
    }

    return 0;
}


// OnSetPos
// 

LRESULT CKnobCtl::OnSetPos(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SetPosition((DWORD)lParam, FALSE);

    return 0;
}

// OnGetPos
// 

LRESULT CKnobCtl::OnGetPos(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    return (LRESULT)GetPosition();
}

// OnFlashTimer
// 

void CKnobCtl::OnFlashTimer()
{
    m_fDim = !m_fDim;
        
    InvalidateRect(NULL,FALSE);
    UpdateWindow();
}


// OnTrackTimer
// 

void CKnobCtl::OnTrackTimer()
{
    RECT rect;

    GetClientRect(&rect);
    
    int nWidth = rect.right - rect.left;
    int radius = (nWidth / 2) - LIGHT_OFFSET;

    double degree = ((double)m_dwPosition / m_dwRange) * 270;
    degree = degree + 135;

    if (abs((int)m_trackdegree-(int)degree) < TRACK_DEGREES_PER_TICK)
    {
        m_trackdegree = degree;

        KillTimer(TID_TRACK);
    }
    else
    {
        if (m_trackdegree > degree)
        {
            m_trackdegree -= TRACK_DEGREES_PER_TICK;
        }
        else
        {
            m_trackdegree += TRACK_DEGREES_PER_TICK;
        }
    }

    double angle = m_trackdegree * RADIAN_CONVERTER;

    double fLightX = radius * cos(angle);
    double fLightY = radius * sin(angle);

    //convert to proper gdi coordinates
    m_nLightX = ((int)fLightX) - (m_nLightWidth / 2) + (nWidth / 2);
    m_nLightY = ((int)fLightY) - (m_nLightHeight / 2) + (nWidth / 2);

    InvalidateRect(NULL,FALSE);
    UpdateWindow();

    degree = m_trackdegree - 135;
    
    if (degree < 0) degree = degree + 360;
    
    double percentage = degree / 270;
    
    m_dwCurPosition = (DWORD)(m_dwRange * percentage);

    NMHDR nmhdr;
    nmhdr.hwndFrom = m_hWnd;
    nmhdr.idFrom = m_nID;
    nmhdr.code = TRUE;

    ::SendMessage(GetParent(),WM_NOTIFY,(WPARAM)m_nID,(LPARAM)&nmhdr);
}

// ComputeCursor
//

BOOL CKnobCtl::ComputeCursor(int deltaX, int deltaY, int maxdist)
{
    double  distance = sqrt(double((deltaX * deltaX) + (deltaY * deltaY)));
    double  degrees =  -((atan2(deltaX,deltaY) * DEGREE_CONVERTER) - double(180.0));

    BOOL    fDeadZone = FALSE;

    if (distance < double(4))
    {
        fDeadZone = TRUE;
    }

    if (distance <= maxdist)
    {
        SetCursor(LoadCursor(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDC_VOLHAND)));
    }
    else
    {
        int volcur;

        if ((degrees < double( 22.5) || degrees > double(337.5)) ||
            (degrees > double(157.5) && degrees < double(202.5)))
        {
            volcur = IDC_VOLHORZ;
        }
        else if ((degrees > double( 22.5) && degrees < double( 67.5)) ||
                 (degrees > double(202.5) && degrees < double(247.5)))
        {
            volcur = IDC_VOLDNEG;
        }
        else if ((degrees > double( 67.5) && degrees < double(112.5)) ||
                 (degrees > double(247.5) && degrees < double(292.5)))
        {
            volcur = IDC_VOLVERT;
        }
        else
        {
            volcur = IDC_VOLDPOS;
        }

        SetCursor(LoadCursor(_Module.GetResourceInstance(), MAKEINTRESOURCE(volcur)));
    }

    return fDeadZone;
}

// SetPosition
// 

void CKnobCtl::SetPosition(DWORD dwPosition, BOOL fNotify)
{
    if (GetCapture()==m_hWnd)
    {
        //we're in a feedback loop, return immediately
        return;
    }

    m_dwPosition = dwPosition;
    m_dwCurPosition = dwPosition;

    RECT rect;
    GetClientRect(&rect);

    int nWidth = rect.right - rect.left;
    int radius = (nWidth / 2) - LIGHT_OFFSET;

    double degree = ((double)m_dwPosition / m_dwRange) * 270;
    degree = degree + 135;

    m_trackdegree = degree; //instantly track when position is set programatically

    double angle = degree * RADIAN_CONVERTER;

    double fLightX = radius * cos(angle);
    double fLightY = radius * sin(angle);

    //convert to proper gdi coordinates
    m_nLightX = ((int)fLightX) - (m_nLightWidth / 2) + (nWidth / 2);
    m_nLightY = ((int)fLightY) - (m_nLightHeight / 2) + (nWidth / 2);

    InvalidateRect(NULL,FALSE);
    UpdateWindow();

    if (fNotify)
    {
        NMHDR nmhdr;
        nmhdr.hwndFrom = m_hWnd;
        nmhdr.idFrom = m_nID;
        nmhdr.code = FALSE;

        ::SendMessage(GetParent(),WM_NOTIFY,(WPARAM)m_nID,(LPARAM)&nmhdr);
    }
}

// SetAudioLevel
//
void CKnobCtl::SetAudioLevel(double level)
{
    m_AudioLevel = level;

    // invalidate rectangle so the knob gets redrawn
    InvalidateRect(NULL, FALSE);
    UpdateWindow();
}

// DrawArc
//
void CKnobCtl::DrawArc(HDC hdc, RECT rect, double start, double end)
{
    int nWidth = rect.right - rect.left;
    int nHeight = rect.bottom - rect.top;

    double startRad = RADIAN_CONVERTER * (135 + start*270);
    double endRad = RADIAN_CONVERTER * (135 + end*270);

    Arc( hdc, rect.left, rect.top, rect.right, rect.bottom,
        (int)((nWidth/2)*(1+cos(startRad))), (int)((nHeight/2)*(1+sin(startRad))),
        (int)((nWidth/2)*(1+cos(endRad))), (int)((nHeight/2)*(1+sin(endRad))) );
}

// Draw
//
void CKnobCtl::Draw(HDC hdc)
{
    RECT rect;

    GetClientRect(&rect);

    int nWidth = rect.right - rect.left;
    int nHeight = rect.bottom - rect.top;

    if (m_hPalette)
    {
        SelectPalette(hdc, m_hPalette, m_bBackgroundPalette);
        RealizePalette(hdc);
    }

    HDC memDC = CreateCompatibleDC(hdc);
    if(memDC==NULL)
    {
        // error, exit
        return;
    }

    if (m_hPalette)
    {
        SelectPalette(memDC, m_hPalette, m_bBackgroundPalette);
        RealizePalette(memDC);
    }

    HBITMAP hbmp = CreateCompatibleBitmap(hdc,nWidth,nHeight);
    HBITMAP hbmpOld = (HBITMAP)SelectObject(memDC,hbmp);

    HDC maskmemDC = CreateCompatibleDC(hdc);
    HBITMAP hmaskbmp = CreateCompatibleBitmap(hdc,nWidth,nHeight);
    HBITMAP hmaskbmpOld = (HBITMAP)SelectObject(maskmemDC,hmaskbmp);

    if(hbmp && maskmemDC && hmaskbmp)
    {
        //
        // Build the knob bitmap
        //

        DibBlt(memDC, 0, 0, -1, -1, 
            m_fEnabled ? ( GetFocus()==m_hWnd ? m_hKnobTab : m_hKnob) : m_hKnobDisabled,
            0, 0, SRCCOPY, 0);

        DibBlt(maskmemDC, 0, 0, -1, -1, 
            m_fEnabled ? (m_fDim ? m_hLight : m_hLightBright) : m_hLightDisabled,
               0, 0, SRCCOPY, 0);

        KMaskBlt(memDC,
                m_nLightX,
                m_nLightY,
                m_nLightWidth,
                m_nLightHeight,
                maskmemDC,
                0,
                0,
                (HBITMAP)m_hLightMask,
                0,
                0,
                MAKEROP4(SRCAND,SRCCOPY));
    }

    //
    // Draw the VU Meter
    //

    COLORREF RedColor = RGB(255,0,0);
    COLORREF YellowColor = RGB(255,255,0);
    COLORREF GreenColor = RGB(0,255,0);

    HPEN hRedPen = CreatePen(PS_SOLID, 2, RedColor) ; 
    HPEN hYellowPen = CreatePen(PS_SOLID, 2, YellowColor);
    HPEN hGreenPen = CreatePen(PS_SOLID, 2, GreenColor);

    if(hRedPen && hYellowPen && hGreenPen)
    {
        HPEN hOldPen = (HPEN) SelectObject(memDC, hGreenPen);

        SetArcDirection( memDC, AD_CLOCKWISE );

        for (double d=0.0; d < m_AudioLevel; d += 0.05)
        {
            if ( d >= 0.75 )
            {
                SelectObject(memDC, hRedPen);
            }
            else if ( d >= 0.5 )
            {
                SelectObject(memDC, hYellowPen);
            }

            DrawArc( memDC, rect, d+0.01, d+0.04 );
        }

        SelectObject(memDC, hOldPen);
    }

    if(hRedPen)
        DeleteObject(hRedPen);

    if(hYellowPen)
        DeleteObject(hYellowPen);

    if(hGreenPen)
        DeleteObject(hGreenPen);

    //
    // Copy the bitmap to the screen
    //

    BitBlt(hdc,0,0,nWidth,nHeight,memDC,0,0,SRCCOPY);

    SelectObject(memDC,hbmpOld);

    if(hbmp)
        DeleteObject(hbmp);

    if(memDC)
        DeleteDC(memDC);

    SelectObject(maskmemDC, hmaskbmpOld);

    if(hmaskbmp)
        DeleteObject(hmaskbmp);

    if(maskmemDC)
        DeleteDC(maskmemDC);
}


//kmaskblt -- cuz MaskBlt doesn't work on all platforms.  This is all it does anyway.
//            uses same params as MaskBlt, ignoring the flags part as dwDummy
void CKnobCtl::KMaskBlt(HDC hdcDest, int x, int y, int width, int height, 
                        HDC hdcSource, int xs, int ys, 
                        HBITMAP hMask, int xm, int ym, DWORD dwDummy)
{
    HDC hdcMask = CreateCompatibleDC(hdcDest);

    if(hdcMask)
    {
        HBITMAP holdbmp = (HBITMAP)SelectObject(hdcMask,hMask);

        BitBlt(hdcDest, x, y, width, height, hdcSource, xs, ys, SRCINVERT);
        BitBlt(hdcDest, x, y, width, height, hdcMask, xm, ym, SRCAND);
        BitBlt(hdcDest, x, y, width, height, hdcSource, xs, ys, SRCINVERT);

        SelectObject(hdcMask,holdbmp);
        DeleteDC(hdcMask);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\axctl\im.h ===
// im.h : Declaration of the CIMWindow

#ifndef __IM_H_
#define __IM_H_

#include <richedit.h>

#define IDC_IM_EDIT 3000
#define IDC_IM_SEND 3001
#define IDC_IM_DISPLAY 3002

#define IM_WIDTH 400
#define IM_HEIGHT 400

class CIMWindow;

/////////////////////////////////////////////////////////////////////////////
// CIMWindowList
class CIMWindowList
{
    friend CIMWindow;

public:
    CIMWindowList( IRTCClient * pClient );

    ~CIMWindowList();

    HRESULT DeliverMessage( IRTCSession * pSession, IRTCParticipant * pParticipant, BSTR bstrMessage );

    HRESULT DeliverUserStatus( IRTCSession * pSession, IRTCParticipant * pParticipant, RTC_MESSAGING_USER_STATUS enStatus );

    HRESULT DeliverState( IRTCSession * pSession, RTC_SESSION_STATE SessionState );

    BOOL IsDialogMessage( LPMSG lpMsg );

private:    

    HRESULT AddWindow( CIMWindow * pWindow );

    HRESULT RemoveWindow( CIMWindow * pWindow );

    CIMWindow * NewWindow( IRTCSession * pSession );

    CIMWindow * FindWindow( IRTCSession * pSession );

    // interface to the client
    CComPtr<IRTCClient>     m_pClient;

    CIMWindow ** m_pWindowList;
    LONG         m_lNumWindows;
   
    HMODULE      m_hRichEditLib;
};

/////////////////////////////////////////////////////////////////////////////
// CIMWindow
class CIMWindow :
    public CWindowImpl<CIMWindow>
{
    friend CIMWindowList;

public:
    CIMWindow(CIMWindowList * pWindowList);

    ~CIMWindow();

    //static CWndClassInfo& GetWndClassInfo();

BEGIN_MSG_MAP(CIMWindow)
    MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
    MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
    MESSAGE_HANDLER(WM_ACTIVATE, OnActivate)
    MESSAGE_HANDLER(DM_GETDEFID, OnGetDefID)
    MESSAGE_HANDLER(WM_NEXTDLGCTL, OnNextDlgCtl)
    NOTIFY_CODE_HANDLER(EN_LINK, OnLink)
    COMMAND_CODE_HANDLER(EN_CHANGE, OnChange)
    COMMAND_HANDLER(IDC_IM_SEND, BN_CLICKED, OnSend)
    COMMAND_ID_HANDLER(IDM_IM_CALL_SAVEAS, OnSaveAs)
    COMMAND_ID_HANDLER(IDM_IM_CALL_CLOSE, OnClose)
    COMMAND_ID_HANDLER(IDM_IM_TOOLS_SOUNDS, OnPlaySounds)
    COMMAND_ID_HANDLER(IDM_IM_TOOLS_LARGEST, OnTextSize)
    COMMAND_ID_HANDLER(IDM_IM_TOOLS_LARGER, OnTextSize)
    COMMAND_ID_HANDLER(IDM_IM_TOOLS_MEDIUM, OnTextSize)
    COMMAND_ID_HANDLER(IDM_IM_TOOLS_SMALLER, OnTextSize)
    COMMAND_ID_HANDLER(IDM_IM_TOOLS_SMALLEST, OnTextSize)
END_MSG_MAP()

// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);  

    LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnEraseBkgnd(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);  

    LRESULT OnActivate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);  

    LRESULT OnGetDefID(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);  

    LRESULT OnNextDlgCtl(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled); 

    LRESULT OnLink(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnSend(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnSaveAs(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnClose(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnPlaySounds(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnTextSize(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    HRESULT DeliverMessage( IRTCParticipant * pParticipant, BSTR bstrMessage, BOOL bIncoming );

    HRESULT DeliverUserStatus( IRTCParticipant * pParticipant, RTC_MESSAGING_USER_STATUS enStatus );

    HRESULT DeliverState( RTC_SESSION_STATE SessionState );

private:

    void PositionWindows();

    static DWORD CALLBACK EditStreamCallback(
        DWORD_PTR dwCookie,
        LPBYTE    pbBuff,
        LONG      cb,
        LONG    * pcb);

    HRESULT GetFormattedNameFromParticipant( IRTCParticipant * pParticipant, BSTR * pbstrName );

    CIMWindowList          * m_pIMWindowList;

    // interface to the session
    CComPtr<IRTCSession>     m_pSession;

    // Window controls
    CWindow         m_hDisplay;
    CWindow         m_hEdit;
    CWindow         m_hSendButton;
    CWindow         m_hStatusBar;

    // Icon
    HICON       m_hIcon;

    // Brush
    HBRUSH      m_hBkBrush;

    // Status text
    TCHAR       m_szStatusText[256];

    // Menu
    HMENU       m_hMenu;

    // Active flag
    BOOL        m_bWindowActive;
    BOOL        m_bPlaySounds;
    BOOL        m_bNewWindow;

    // Our status
    RTC_MESSAGING_USER_STATUS m_enStatus;
};

#endif //__IM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\axctl\dial.h ===
//
// Dial.h
//

#ifndef __DIAL_H_
#define __DIAL_H_

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// External functions
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//
//

HRESULT ShowDialNeedCallInfoDialog(
    IN   HWND           hwndParent,
    IN   IRTCClient   * pClient,
    IN   long           lSessionMask,
    IN   BOOL           bEnumerateProfiles,
    IN   BOOL           bProfileEditable,
    IN   IRTCProfile  * pOneShotProfile,
    IN   BSTR	        pDestAddress,
    IN   BSTR           pInstructions,
    OUT  IRTCProfile ** ppProfileChosen,
    OUT  BSTR         * ppFromAddressChosen
    );

//////////////////////////////////////////////////////////////////////////////
//
//

HRESULT ShowDialByPhoneNumberDialog(
    IN  HWND         hwndParent,
    IN  BOOL         bAddParticipant,
    IN  BSTR         pDestPhoneNr,
    OUT BSTR       * ppDestPhoneNrChosen
    );

//////////////////////////////////////////////////////////////////////////////
//
//

HRESULT ShowDialByAddressDialog(
    IN   HWND           hwndParent,
    IN   BSTR	        pDestAddress,
    OUT  BSTR         * ppDestAddressChosen
    );

//////////////////////////////////////////////////////////////////////////////
//
//

HRESULT ShowMessageByAddressDialog(
    IN   HWND           hwndParent,
    IN   BSTR	        pDestAddress,
    OUT  BSTR         * ppDestAddressChosen
    );

//////////////////////////////////////////////////////////////////////////////
//
//

HRESULT ShowEditServiceProviderListDialog(
    IN   HWND         hwndParent,
    IN   IRTCClient * pClient
    );

//////////////////////////////////////////////////////////////////////////////
//
//

HRESULT ShowEditCallFromListDialog(
    IN   HWND         hwndParent
    );

#endif // __DIAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\axctl\misc.h ===
// helper stuff

#pragma once

#include "stdafx.h"

#define BMP_COLOR_MASK RGB(255,0,255) // pink


// Structure with error info
struct RTCAX_ERROR_INFO
{
	LPWSTR		Message1;
	LPWSTR		Message2;
	LPWSTR		Message3;

	HICON		ResIcon;

};



/////////////////////////////////////////////////////////////////////////////
// CErrorMessageLiteDlg

class CErrorMessageLiteDlg : 
    public CAxDialogImpl<CErrorMessageLiteDlg>
{

public:
    CErrorMessageLiteDlg();

    ~CErrorMessageLiteDlg();
    
    enum { IDD = IDD_DIALOG_ERROR_MESSAGE_LITE };

BEGIN_MSG_MAP(CErrorMessageLiteDlg)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
    COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
    COMMAND_ID_HANDLER(IDOK, OnOk)
END_MSG_MAP()


    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\axctl\knob.h ===
// knob.h : Declaration of CKnobCtl
//  Inspired from CDPlayer code written by dstewart

#pragma once

#include "stdafx.h"

#define WC_KNOB     L"RTC_Knob"

typedef CWinTraitsOR<WS_TABSTOP, 0, CControlWinTraits> CKnobTraits;

/////////////////////////////////////////////////////////////////////////////
// CKnobCtl

class CKnobCtl : 
    public CWindowImpl<CKnobCtl, CWindow, CKnobTraits>
{

public:
    CKnobCtl(
        UINT    nResRest,
        UINT    nResHot,
        UINT    nResDis,
        UINT    nResLightBright,
        UINT    nResLightDim,
        UINT    nResLightDis,
        UINT    nResLightMask);

    ~CKnobCtl();

    enum {
        TID_TRACK = 1,
        TID_FLASH
    };

    DECLARE_WND_CLASS(WC_KNOB)

BEGIN_MSG_MAP(CKnobCtl)
    MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
    MESSAGE_HANDLER(WM_GETDLGCODE, OnGetDlgCode)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBackground)
    MESSAGE_HANDLER(WM_KEYDOWN, OnKeyDown)
    MESSAGE_HANDLER(WM_RBUTTONDOWN, OnRightButtonDown)
    MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLeftButtonDown)
    MESSAGE_HANDLER(WM_RBUTTONUP, OnButtonUp)
    MESSAGE_HANDLER(WM_LBUTTONUP, OnButtonUp)
    MESSAGE_HANDLER(WM_MOUSEMOVE, OnMouseMove)
    MESSAGE_HANDLER(WM_TIMER, OnTimer)
    MESSAGE_HANDLER(WM_ENABLE, OnEnable)
    MESSAGE_HANDLER(TBM_SETPOS, OnSetPos);
    MESSAGE_HANDLER(TBM_GETPOS, OnGetPos);
END_MSG_MAP()

    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnKillFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnGetDlgCode(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnEraseBackground(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnKeyDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnRightButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnLeftButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnButtonUp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnEnable(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnSetPos(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnGetPos(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

public:

    void  LoadAllResources(        
        UINT    nResRest,
        UINT    nResHot,
        UINT    nResDis,
        UINT    nResLightBright,
        UINT    nResLightDim,
        UINT    nResLightDis,
        UINT    nResLightMask);

    HWND  Create(
        HWND    hParent,
        int     x,
        int     y,
        UINT    nID
        );

    void SetRange(DWORD dwRange) {m_dwRange = dwRange;}
    void SetPosition(DWORD dwPosition, BOOL fNotify);
    
    DWORD GetRange() {return m_dwRange;}
    DWORD GetPosition() {return m_dwCurPosition;}

    void SetPalette(HPALETTE hPalette) {m_hPalette = hPalette;}
    void SetBackgroundPalette(BOOL bBackgroundPalette) {m_bBackgroundPalette = bBackgroundPalette;}

    void  OnButtonDown(int x, int y);

    void  OnTrackTimer();
    void  OnFlashTimer();

    BOOL  ComputeCursor(int deltaX, int deltaY, int maxdist);

    void  DrawArc(HDC hdc, RECT rect, double start, double end);
    void  SetAudioLevel(double level);

    void  Draw(HDC hdc);
    void  KMaskBlt(HDC hdcDest, int x, int y, int width, int height, 
                   HDC hdcSource, int xs, int ys, 
                   HBITMAP hMask, int xm, int ym, DWORD dwDummy);

private:

    int         m_nID;
    
    int         m_nLightX;
    int         m_nLightY;
    
    DWORD       m_dwRange;
    DWORD       m_dwPosition;
    DWORD       m_dwCurPosition;
    
    double      m_trackdegree;

    double      m_AudioLevel;
    
    BOOL        m_fDim;
    BOOL        m_fFastKnob;

    BOOL        m_fEnabled;

    int         m_nLightWidth;
    int         m_nLightHeight;
    int         m_nKnobWidth;
    int         m_nKnobHeight;

    HANDLE      m_hKnob;
    HANDLE      m_hKnobTab;
    HANDLE      m_hKnobDisabled;
    HANDLE      m_hLight;
    HANDLE      m_hLightDisabled;
    HANDLE      m_hLightBright;
    HANDLE      m_hLightMask;

    HPALETTE    m_hPalette;
    BOOL        m_bBackgroundPalette;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\axctl\misc.cpp ===
// helper stuff
// header needed

#include "stdafx.h"
#include "misc.h"


/////////////////////////////////////////////////////////////////////////////
// CParticipant
//
struct CParticipantEntry
{
    LIST_ENTRY      ListEntry;

    IRTCParticipant *pParticipant;
    RTC_PARTICIPANT_STATE
                    nState;

    BOOL            bAutoDelete;
};


/////////////////////////////////////////////////////////////////////////////
// CParticipantList
//
//

// Constructor
//

CParticipantList::CParticipantList()
{
    InitializeListHead(&ListHead);
}

// Initialize
// Creates the columns

HRESULT  CParticipantList::Initialize(void)
{
    TCHAR       szBuffer[MAX_STRING_LEN];
    LVCOLUMN    lvColumn;
    RECT        Rect;
    HIMAGELIST  hImageList;
    HBITMAP     hBitmap;
    
    // Add columns
    GetWindowRect(&Rect);

    // Name column
    szBuffer[0] = _T('\0');
    LoadString( _Module.GetResourceInstance(), 
                IDS_PARTICIPANT_NAME_HEADER,
                szBuffer, 
                sizeof(szBuffer)/sizeof(TCHAR));
    
    ZeroMemory(&lvColumn, sizeof(lvColumn));

    lvColumn.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;
    lvColumn.cx = (Rect.right - Rect.left) / 2;
    lvColumn.pszText = szBuffer;
    
    ListView_InsertColumn(m_hWnd, 0, &lvColumn);

    // Status column
    szBuffer[0] = _T('\0');
    LoadString( _Module.GetResourceInstance(), 
                IDS_PARTICIPANT_STATUS_HEADER,
                szBuffer, 
                sizeof(szBuffer)/sizeof(TCHAR));
    
    ZeroMemory(&lvColumn, sizeof(lvColumn));

    lvColumn.mask = LVCF_TEXT | LVCF_WIDTH;
    lvColumn.cx = (Rect.right - Rect.left) / 2 - 5;
    lvColumn.pszText = szBuffer;
    
    ListView_InsertColumn(m_hWnd, 1, &lvColumn);

    // Create an imagelist for small icons and set it on the listview
    hImageList = ImageList_Create(16, 16, ILC_COLOR | ILC_MASK , 5, 5);
    if(hImageList)
    {
        // Open a bitmap
        hBitmap = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_PARTICIPANT_LIST));
        if(hBitmap)
        {
            // Add the bitmap to the image list
            ImageList_AddMasked(hImageList, hBitmap, BMP_COLOR_MASK);
            // set the image list
            ListView_SetImageList(m_hWnd, hImageList, LVSIL_SMALL);

            DeleteObject(hBitmap);
        }
    }
    
    return S_OK;
}

// Change

//
//  Adds an entry to the list if there is no other with the same IRTCParticipant and
//  also Addrefs the interface
//
//  For the DISCONNECTED state   the interface is released and:
//    - if the previous state was DISCONNECTING, delete the entry
//    - else put (IRTCParticipant *)1 instead
//


HRESULT CParticipantList::Change(IRTCParticipant *pParticipant, RTC_PARTICIPANT_STATE nState, long StatusCode)
{
    // Search for the item first
    TCHAR       szBuffer[MAX_STRING_LEN];
    LVFINDINFO  lvf;
    int         iItem;
    int         iImage;
    CComBSTR    bstrName;
    HRESULT     hr;
    LVITEM      lv = {0};
    CParticipantEntry
               *pEntry;

    // search the participant in the list of participant entries
    pEntry = GetParticipantEntry(pParticipant);

    if(pEntry==NULL)
    {
        // not found, entry must be added
        // But don't bother for DISCONNECTED state
        if(nState == RTCPS_DISCONNECTED)
        {
            return S_OK;
        }
        
        // name
        hr = pParticipant->get_UserURI(&bstrName);
        if(FAILED(hr))
        {
            return hr;
        }

        // create entry
        pEntry = (CParticipantEntry *)RtcAlloc(sizeof(CParticipantEntry));
        if(!pEntry)
        {
            return E_OUTOFMEMORY;
        }

        InitializeListHead(&pEntry->ListEntry);
        pEntry->nState = nState;
        pEntry->pParticipant = pParticipant;
        pEntry->bAutoDelete = FALSE;

        pEntry->pParticipant->AddRef();
        
        // Add them to list box.
        lv.mask = LVIF_PARAM | LVIF_TEXT | LVIF_IMAGE;
        lv.iItem = 0x7FFFFFFF;
        lv.iSubItem = 0;
        lv.iImage = GetImage(nState);
        lv.lParam = reinterpret_cast<LPARAM>(pEntry);
        lv.pszText = bstrName ? bstrName : _T("");

        iItem = ListView_InsertItem(m_hWnd, &lv);

        // insert the entry in the list of participants
        InsertTailList(&ListHead, &pEntry->ListEntry);
    }
    else
    {
        // found in the list, try to find it in the list view
        lvf.flags = LVFI_PARAM;
        lvf.lParam = reinterpret_cast<LPARAM>(pEntry);

        iItem = ListView_FindItem(m_hWnd, -1, &lvf);
        if(iItem>=0)
        {
            // set the image
            lv.mask = LVIF_IMAGE;
            lv.iItem = iItem;
            lv.iSubItem = 0;
            lv.iImage = GetImage(nState);
        
            ListView_SetItem(m_hWnd, &lv);
        }
    }

   
    if(nState == RTCPS_DISCONNECTED && pEntry->bAutoDelete && StatusCode == 0)
    {
        // delete everything
        RemoveEntryList(&pEntry->ListEntry);

        if(pEntry->pParticipant)
        {
            pEntry->pParticipant->Release();
        }
        
        RtcFree(pEntry);

        if(iItem>=0)
        {
            ListView_DeleteItem(m_hWnd, iItem);
        }
    }
    else
    {
        // change the status

        pEntry->nState = nState;

        if(nState == RTCPS_DISCONNECTED)
        {
            if(pEntry->pParticipant)
            {
                pEntry->pParticipant->Release();
                pEntry->pParticipant = NULL;
            }
        }

        if(iItem>=0)
        {
            // Set the state
            GetStatusString(nState, HRESULT_CODE(StatusCode) , szBuffer, sizeof(szBuffer)/sizeof(TCHAR));
            lv.mask = LVIF_TEXT;
            lv.iItem = iItem;
            lv.iSubItem = 1;
            lv.pszText = szBuffer;
       
            ListView_SetItem(m_hWnd, &lv);
        }
    }
    
    return S_OK;
}


void CParticipantList::RemoveAll(void)
{
    int         iItem;
    LVITEM      lv;
    LIST_ENTRY  *pListEntry;
    CParticipantEntry
                *pEntry;

    ListView_DeleteAllItems(m_hWnd);

    while(!IsListEmpty(&ListHead))
    {
        pListEntry = ListHead.Flink;

        RemoveEntryList(pListEntry);

        pEntry = CONTAINING_RECORD(pListEntry, CParticipantEntry, ListEntry);

        if(pEntry->pParticipant)
        {
            pEntry->pParticipant->Release();
        }

        RtcFree(pEntry);
    }
}

HRESULT CParticipantList::Remove(IRTCParticipant **ppParticipant)
{
    // find the current selection
    int         iItem;
    LVITEM      lv;
    CParticipantEntry
               *pEntry;

    iItem = ListView_GetNextItem(m_hWnd, -1, LVNI_SELECTED);
    if(iItem<0)
    {
        return E_FAIL;
    }

    lv.mask = LVIF_PARAM;
    lv.iItem = iItem;
    lv.iSubItem = 0;
    lv.lParam = NULL;
        
    ListView_GetItem(m_hWnd, &lv);
    
    pEntry = reinterpret_cast<CParticipantEntry *>(lv.lParam);

    if(!pEntry)
    {
        return E_UNEXPECTED;
    }

    if(!pEntry->pParticipant)
    {
        // delete it right now
        ListView_DeleteItem(m_hWnd, iItem);

        *ppParticipant = NULL;

        return S_OK;
    }

    // else deffer
    pEntry ->bAutoDelete = TRUE;

    *ppParticipant = pEntry->pParticipant;
    (*ppParticipant)->AddRef();

    return S_OK;
}

BOOL  CParticipantList::CanDeleteSelected(void)
{
    HRESULT         hr;
    CParticipantEntry   *pEntry;
    
    // find the current selection
    int         iItem;
    LVITEM      lv;

    iItem = ListView_GetNextItem(m_hWnd, -1, LVNI_SELECTED);
    if(iItem<0)
    {
        return FALSE;
    }

    lv.mask = LVIF_PARAM;
    lv.iItem = iItem;
    lv.iSubItem = 0;
    lv.lParam = NULL;
        
    ListView_GetItem(m_hWnd, &lv);
    
    pEntry = reinterpret_cast<CParticipantEntry *>(lv.lParam);
    VARIANT_BOOL    bRemovable = VARIANT_FALSE;
    
    if(!pEntry->pParticipant)
    {
        // this is already disconnected. Can be removed
        return TRUE;
    }

    hr = pEntry->pParticipant -> get_Removable(&bRemovable);

    if(FAILED(hr))
    {
        return FALSE;
    }
    
    return bRemovable ? TRUE : FALSE;
}


void  CParticipantList::GetStatusString(RTC_PARTICIPANT_STATE State, long lError, TCHAR *pszBuffer, int nSize)
{
    int nResId;

    switch(State)
    {
    case RTCPS_PENDING:
        nResId = IDS_PART_STATE_PENDING;
        break;

    case RTCPS_INPROGRESS:
        nResId = IDS_PART_STATE_CONNECTING;
        break;

    case RTCPS_CONNECTED:
        nResId = IDS_PART_STATE_CONNECTED;
        break;
    
    case RTCPS_DISCONNECTING:
        nResId = IDS_PART_STATE_DISCONNECTING;
        break;

    case RTCPS_DISCONNECTED:
        if(lError == 0)
        {
            nResId = IDS_PART_STATE_DISCONNECTED;
        }
        else 
        {
            switch(lError)
            {
            case 5:
                nResId = IDS_PART_REJECTED_BUSY;
                break;
        
            case 6:
                nResId = IDS_PART_REJECTED_NO_ANSWER;
                break;

            case 7:
                nResId = IDS_PART_REJECTED_ALL_BUSY;
                break;

            case 8:
                nResId = IDS_PART_REJECTED_PL_FAILED;
                break;

            case 9:
                nResId = IDS_PART_REJECTED_SW_FAILED;
                break;

            case 10:
                nResId = IDS_PART_REJECTED_CANCELLED;
                break;
        
            case 11:
            case 307:
                nResId = IDS_PART_REJECTED_BADNUMBER;
                break;

            default:
                nResId = IDS_PART_STATE_REJECTED;
                break;
            }
        }
        break;

    default:
        nResId = IDS_GENERIC_UNKNOWN;
        break;
    }

    *pszBuffer = _T('\0');
    LoadString(_Module.GetResourceInstance(), nResId, pszBuffer, nSize);
}


int  CParticipantList::GetImage(RTC_PARTICIPANT_STATE State)
{
    switch(State)
    {
    case RTCPS_PENDING:
        return ILI_PART_PENDING;
        break;
    
    case RTCPS_INPROGRESS:
        return ILI_PART_INPROGRESS;
        break;

    case RTCPS_CONNECTED:
        return ILI_PART_CONNECTED;
        break;
    }
    return ILI_PART_DISCONNECTED;
}


CParticipantEntry *CParticipantList::GetParticipantEntry(IRTCParticipant *pRTCParticipant)
{
    LIST_ENTRY  *pListEntry;

    CParticipantEntry *pEntry;
    
    // linear search
    for(pListEntry = ListHead.Flink; pListEntry!= &ListHead; pListEntry = pListEntry->Flink)
    {
        pEntry = CONTAINING_RECORD(pListEntry, CParticipantEntry, ListEntry);

        // compare the pointers
        if(pEntry->pParticipant == pRTCParticipant)
        {
            return pEntry;
        }
    }

    return NULL;
}



/////////////////////////////////////////////////////////////////////////////
// CErrorMessageLiteDlg


////////////////////////////////////////
//

CErrorMessageLiteDlg::CErrorMessageLiteDlg()
{
    LOG((RTC_TRACE, "CErrorMessageLiteDlg::CErrorMessageLiteDlg"));
}


////////////////////////////////////////
//

CErrorMessageLiteDlg::~CErrorMessageLiteDlg()
{
    LOG((RTC_TRACE, "CErrorMessageLiteDlg::~CErrorMessageLiteDlg"));
}


////////////////////////////////////////
//

LRESULT CErrorMessageLiteDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CErrorMessageLiteDlg::OnInitDialog - enter"));

    // LPARAM contains a pointer to an RTCAX_ERROR_INFO stricture
    RTCAX_ERROR_INFO    *pInfo = (RTCAX_ERROR_INFO *)lParam;

    ATLASSERT(pInfo);

    SetDlgItemText(IDC_EDIT_MSG1, pInfo->Message1 ? pInfo->Message1 : _T(""));
    SetDlgItemText(IDC_EDIT_MSG2, pInfo->Message2 ? pInfo->Message2 : _T(""));
    SetDlgItemText(IDC_EDIT_MSG3, pInfo->Message3 ? pInfo->Message3 : _T(""));

    SendDlgItemMessage(IDC_STATIC_MSG_ICON,
                       STM_SETIMAGE,
                       IMAGE_ICON,
                       (LPARAM)pInfo->ResIcon);

    // Title
    TCHAR   szTitle[0x80];

    szTitle[0] = _T('\0');
    LoadString(
        _Module.GetResourceInstance(),
        IDS_APPNAME,
        szTitle,
        sizeof(szTitle)/sizeof(szTitle[0]));

    SetWindowText(szTitle);

    LOG((RTC_TRACE, "CErrorMessageLiteDlg::OnInitDialog - exit"));
    
    return 1;
}
    

////////////////////////////////////////
//

LRESULT CErrorMessageLiteDlg::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CErrorMessageLiteDlg::OnDestroy - enter"));

    LOG((RTC_TRACE, "CErrorMessageLiteDlg::OnDestroy - exit"));
    
    return 0;
}
    

////////////////////////////////////////
//

LRESULT CErrorMessageLiteDlg::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CErrorMessageLiteDlg::OnCancel - enter"));
    
    LOG((RTC_TRACE, "CErrorMessageLiteDlg::OnCancel - exiting"));
   
    EndDialog(wID);
    return 0;
}

////////////////////////////////////////
//

LRESULT CErrorMessageLiteDlg::OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CErrorMessageLiteDlg::OnOk - enter"));
    
    LOG((RTC_TRACE, "CErrorMessageLiteDlg::OnOk - exiting"));
    
    EndDialog(wID);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\axctl\promptedobjectsafety.h ===
#ifndef _PROMPTED_OBJECT_SAFETY_H_
#define _PROMPTED_OBJECT_SAFETY_H_

/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    PromptedObjectSafety.h

Abstract:

  abstract base class for secure object safety mechanism

  calls the derived class's Ask() method to determine 
  whether safe for scripting request should be rejected

--*/


#include "ObjectSafeImpl.h"


class __declspec(novtable) CPromptedObjectSafety : public CObjectSafeImpl
{

public:
   
    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, 
                                         DWORD dwOptionSetMask, 
                                         DWORD dwEnabledOptions)
    {
        if ( SUCCEEDED(InterfaceSupported(riid)) && Ask() )
        {
            return CObjectSafeImpl::SetInterfaceSafetyOptions(riid, 
                                                        dwOptionSetMask,
                                                        dwEnabledOptions);
        }
        else
        {
            return E_FAIL;
        }
    }


    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, 
                                         DWORD *pdwSupportedOptions,
                                         DWORD *pdwEnabledOptions)
    {
        if (SUCCEEDED(InterfaceSupported(riid)) && Ask())
        {
            return CObjectSafeImpl::GetInterfaceSafetyOptions(riid, 
                                                          pdwSupportedOptions,
                                                          pdwEnabledOptions);
        }
        else
        {
            return E_FAIL;
        }
    }

    //
    // implement Ask() in the derived class. Should contain the logic to make 
    // the decision on whether the control should be allowed to run
    //
    // return FALSE if you want to mark your control as not safe for scripting
    // return TRUE otherwise
    //

    virtual BOOL Ask() = 0;

};

#endif // _PROMPTED_OBJECT_SAFETY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\axctl\objectsafeimpl.h ===
#ifndef _OBJECT_SAFE_IMPL_H_
#define _OBJECT_SAFE_IMPL_H_

#include <atlcom.h>
#include <atlwin.h>
#include <atlctl.h>


/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ObjectSafeImpl.h

Abstract:

  base class for object safety. basic implementation for IObjectSafety

  derive your control from this class if the control is safe for scripting 
  on all the interfaces it exposes

  if you want to delegate IObjectSafety requests to the IObjectSafety
  interface of the aggrefate that supports the interface requested, 
  have your derived class implement QIOnAggregate() 

--*/


class __declspec(novtable) CObjectSafeImpl : public IObjectSafety
{

public:
    
    CObjectSafeImpl()
        :m_dwSafety(0)
    {}


    //
    // we support INTERFACESAFE_FOR_UNTRUSTED_CALLER and INTERFACESAFE_FOR_UNTRUSTED_DATA
    //

    enum { SUPPORTED_SAFETY_OPTIONS = 
        INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA };


    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
    {

       
        IUnknown *pNonDelegatingUnknown = NULL;

        //
        // any options requested that we do not support?
        //
        
        if ( (~SUPPORTED_SAFETY_OPTIONS & dwOptionSetMask) != 0 )
        {
            return E_FAIL;
        }

        
        //
        //  Is the interface exposed by one of the aggregated objects?
        //
                
        HRESULT hr = QIOnAggregates(riid, &pNonDelegatingUnknown);

        if (SUCCEEDED(hr))
        {

            //
            // get IObjectSafety on non delegating unknown of the aggregated object
            //

            IObjectSafety *pAggrObjectSafety = NULL;

            hr = pNonDelegatingUnknown->QueryInterface(IID_IObjectSafety, (void**)&pAggrObjectSafety);

            pNonDelegatingUnknown->Release();
            pNonDelegatingUnknown = NULL;
            
            if (SUCCEEDED(hr))
            {

                // 
                // the aggregate exposes IObjectSafety. use it to set the new 
                // safety options
                //

                hr = pAggrObjectSafety->SetInterfaceSafetyOptions(riid,
                                                                  dwOptionSetMask,
                                                                  dwEnabledOptions);

                pAggrObjectSafety->Release();
                pAggrObjectSafety = NULL;

            }

        }
        else 
        {
            //
            // the interface requested is not requested by the object's 
            // aggregates. see if the interface is supported at all
            //

            hr = InterfaceSupported(riid);

            if (SUCCEEDED(hr))
            {

                //
                // the object supports the interface. Set safety options.
                // 

                s_CritSection.Lock();

                //
                // set the bits specified by the mask to the values specified by the values
                //

                m_dwSafety = (dwEnabledOptions & dwOptionSetMask) |
                             (m_dwSafety & ~dwOptionSetMask);

                s_CritSection.Unlock();

            }

        }

        return hr;
    }





    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
    {
        
        //
        // check caller's pointers
        //

        if ( IsBadWritePtr(pdwSupportedOptions, sizeof(DWORD)) ||
             IsBadWritePtr(pdwEnabledOptions, sizeof(DWORD)) )
        {
             return E_POINTER;
        }

        //
        //  if we fail, at least return something meaningful.
        //

        *pdwSupportedOptions = 0;
        *pdwEnabledOptions = 0;


        IUnknown *pNonDelegatingUnknown = NULL;
       
        //
        //  Is the interface exposed by one of the aggregated objects?
        //
        
        HRESULT hr = QIOnAggregates(riid, &pNonDelegatingUnknown);

        if (SUCCEEDED(hr))
        {

            //
            // get IObjectSafety on non delegating unknown of the aggregated object
            //

            IObjectSafety *pAggrObjectSafety = NULL;

            hr = pNonDelegatingUnknown->QueryInterface(IID_IObjectSafety, (void**)&pAggrObjectSafety);

            pNonDelegatingUnknown->Release();
            pNonDelegatingUnknown = NULL;
            
            if (SUCCEEDED(hr))
            {

                // 
                // the aggregate exposes IObjectSafety. use it to get the new 
                // safety options
                //

                hr = pAggrObjectSafety->GetInterfaceSafetyOptions(riid,
                                                                  pdwSupportedOptions,
                                                                  pdwEnabledOptions);

                pAggrObjectSafety->Release();
                pAggrObjectSafety = NULL;

            }

        }
        else 
        {
            //
            // the interface requested is not requested by the object's 
            // aggregates. see if the interface is supported at all
            //

            hr = InterfaceSupported(riid);

            if (SUCCEEDED(hr))
            {

                //
                // the object supports the interface. get options
                // 

                *pdwSupportedOptions = SUPPORTED_SAFETY_OPTIONS;

                s_CritSection.Lock();

                *pdwEnabledOptions = m_dwSafety;

                s_CritSection.Unlock();

            }

        }

        return hr;
    }


private:

    DWORD m_dwSafety;

    // 
    // thread safety
    //
    // this interface is not likely to be a performance bottleneck, 
    // at the same time, having one critical section per object
    // is wasteful. so have a static critical section
    //

    static CComAutoCriticalSection s_CritSection;


protected:

    //
    // return S_OK if the interface requested is exposed 
    // by the object
    //
    
    HRESULT InterfaceSupported(REFIID riid)
    {

        void *pVoid = NULL;

    
        HRESULT hr = E_FAIL;
     
        // 
        // does the object support requested interface
        //

        hr = QueryInterface(riid, &pVoid);


        if (SUCCEEDED(hr))
        {

            //
            // don't need the interface itself, just wanted to see if
            // it is supported
            //

            ((IUnknown*)pVoid)->Release();

        }
        

        return hr;
    }


    //
    // Implement in the derived class if you have any aggregates
    //
    // returns the non delegating IUnknown of the first (in the order of COMMAP)
    // aggregate that supports the iid requested
    //
    
    virtual HRESULT QIOnAggregates(REFIID riid, IUnknown **ppNonDelegatingUnknown)
    {
        return E_NOINTERFACE;
    }

};

#endif // _OBJECT_SAFE_IMPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\axctl\provstore.h ===
/**********************************************************************************
*
*   Copyright (c) 2000  Microsoft Corporation
*
*   Module Name:
*
*    provstore.h
*
*   Abstract:
*
*    Definition of the CProvStore class that implements all the internal support
*    functions. 
*
*    This is the include file for all the data structures and constants required for 
*    the provisioning module. The basic class CProvStore implements all the 
*    support functions which will be required to implement the APIs.
*
************************************************************************************/
#ifndef _PROVSTORE_H
#define _PROVSTORE_H

#include <objectsafeimpl.h>
#include "RTCObjectSafety.h"
#include "Rpcdce.h"
#include <Mshtmcid.h>
#include <Mshtml.h>
#include <string.h>


HRESULT EnableProfiles( IRTCClient * pClient );

HRESULT GetKeyFromProfile( BSTR bstrProfileXML, BSTR * pbstrKey );

HRESULT MyOpenProvisioningKey( HKEY * phProvisioningKey, BOOL fReadOnly);
HRESULT MyGetProfileFromKey(
                            HKEY hProvisioningKey, 
                            WCHAR *szSubKeyName, 
                            WCHAR **pszProfileXML
                            );


/////////////////////////////////////////////////////////////////////////////
// CRTCProvStore
class ATL_NO_VTABLE CRTCProvStore : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public ISupportErrorInfo,
    public CComCoClass<CRTCProvStore, &CLSID_RTCProvStore>,
    public IDispatchImpl<IRTCProvStore, &IID_IRTCProvStore, &LIBID_RTCCtlLib>,
    public CRTCObjectSafety
{
public:
    CRTCProvStore()
    {
    }

DECLARE_PROTECT_FINAL_CONSTRUCT()
DECLARE_REGISTRY_RESOURCEID(IDR_RTCProvStore)

BEGIN_COM_MAP(CRTCProvStore)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IRTCProvStore)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)  
    COM_INTERFACE_ENTRY(IObjectWithSite)
    COM_INTERFACE_ENTRY(IObjectSafety)
END_COM_MAP()

    HRESULT FinalConstruct();

    void FinalRelease();

// IRTCProvStore
public: 
    STDMETHOD(get_ProvisioningProfile)(BSTR bstrKey, BSTR * pbstrProfileXML);
    STDMETHOD(DeleteProvisioningProfile)(BSTR bstrKey);
    STDMETHOD(SetProvisioningProfile)(BSTR bstrProfileXML);
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
};

#endif //_PROVSTORE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\axctl\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\axctl\provstore.cpp ===
/*********************************************************************************
*
*   Copyright (c) 2001  Microsoft Corporation
*
*   Module Name:
*
*    provstore.cpp
*
*   Abstract:
*
*    Implementation of all of the methods in CProfileStore class.
*
*
**********************************************************************************/

#include "stdafx.h"
#include "provstore.h"

CComAutoCriticalSection CObjectSafeImpl::s_CritSection;
CComAutoCriticalSection CObjectWithSite::s_ObjectWithSiteCritSection;
CObjectWithSite::EnValidation CObjectWithSite::s_enValidation = CObjectWithSite::UNVALIDATED;

HKEY g_hRegistryHive = HKEY_CURRENT_USER;
const WCHAR * g_szProvisioningKeyName = L"Software\\Microsoft\\Phoenix\\ProvisioningInfo";
const WCHAR * g_szProvisioningSchemaKeyName = L"schema";
const WCHAR *    g_szProfileInfo =L"provision";
const WCHAR *    g_szKey = L"key";

//////////////////////////////////////////////////////////////////////////////////
//EnableProfiles
// query for IRTCClientProvisioning
//
// for each profile stored in the registry:
//  1) CreateProfile(BSTR XML, IRTCProfile ** ppProfile)
//  2) EnableProfile(IRTCProfile * pProfile, VARIANT_TRUE)

HRESULT EnableProfiles( IRTCClient * pClient )
{
    long dwResult = 0;
    long dwProfileCount = 0, i; 
    WCHAR *szSubKeyName;
    WCHAR *szProfileXML;
    unsigned long dwSubKeySize = 0, dwLargestSubKeySize = 0;
    HRESULT hr = 0;
    HKEY hProvisioningKey;
    CComPtr<IRTCClientProvisioning> spClientProv;
    
    LOG((RTC_TRACE, "EnableProfiles: enter :%x.",pClient));
    if( IsBadWritePtr(pClient, sizeof(IRTCClient) ) )
    {
        LOG((RTC_ERROR, "EnableProfiles: invalid arg:%x.",pClient));
        return E_POINTER;
    }
    
    hr = pClient->QueryInterface(IID_IRTCClientProvisioning,(void**)&(spClientProv.p));
    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "EnableProfiles: QI failed:%x.",pClient));
        return E_FAIL;
    }
    
    // Get a handle to the provisioninginfo key, we need read/write access
    hr = MyOpenProvisioningKey(&hProvisioningKey, FALSE);
    if ( FAILED (hr) )
    {
        LOG((RTC_ERROR, "EnableProfiles: Failed to open provisioning key."));
        return hr;
    }
    
    // Get the size of the largest subkey string for the provisioningInfo key.
    dwResult = RegQueryInfoKey(
        hProvisioningKey,    // handle to key
        NULL,                // class buffer
        NULL,                // size of class buffer
        NULL,                // reserved
        (unsigned long *)(&dwProfileCount),    // number of subkeys
        &dwSubKeySize,    // longest subkey name
        NULL,                // longest class string
        NULL,                // number of value entries
        NULL,                // longest value name
        NULL,                // longest value data
        NULL,                // descriptor length
        NULL				   // last write time
        );
    
    if (dwResult != ERROR_SUCCESS)
    {
        RegCloseKey(hProvisioningKey);
        return HRESULT_FROM_WIN32(dwResult);
    }
    
    
    // We allocate a string to receive the name of the subkey when we enumerate. 
    // Since we have the size of the longest subkey, we can allocate. We add one since
    // the size doesn't include null on Win 2K.
    
    dwSubKeySize ++;
    dwLargestSubKeySize = dwSubKeySize;
    
    LOG((RTC_INFO, "EnableProfiles: Size of largest key (after increasing by 1): %d", dwSubKeySize));
    
    szSubKeyName = (PWCHAR)RtcAlloc( sizeof( WCHAR ) * dwSubKeySize);
    
    if (szSubKeyName == 0)
    {
        // Not enough memory
        RegCloseKey(hProvisioningKey);
        return E_OUTOFMEMORY;
    }
    
    
    // Iternate through the cached profiles 
    for (i = 0; i < dwProfileCount; i ++)
    {
        //reset the size of subkey name buffer
        dwSubKeySize = dwLargestSubKeySize;
        
        dwResult = RegEnumKey(
            hProvisioningKey,     // handle to key to query
            i, // index of subkey to query
            szSubKeyName, // buffer for subkey name
            dwSubKeySize   // size of subkey name buffer
            );
        
        if (dwResult != ERROR_SUCCESS)
        {
            // Clean up
            
            LOG((RTC_ERROR, "EnableProfiles: Enum failed! (result = %d)", dwResult));
            LOG((RTC_ERROR, "EnableProfiles: key=%s,Size of key: %d, of the largest key:%d", 
                szSubKeyName, dwSubKeySize,dwLargestSubKeySize));
            
            RtcFree((LPVOID)szSubKeyName );
            RegCloseKey(hProvisioningKey);
            return HRESULT_FROM_WIN32(dwResult);
        }
        
        // We have to read the registry, create a profile for it, and enable it
        
        hr = MyGetProfileFromKey(hProvisioningKey, szSubKeyName, &szProfileXML);
        
        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "EnableProfiles: Failed in getting from Registry(status = 0x%x)!", hr));
                        
            RtcFree((LPVOID)szSubKeyName );
            RegCloseKey(hProvisioningKey);
            
            return hr;
        }
        
        LOG((RTC_INFO, "EnableProfiles: Getting the profile %d, key={%s}",i,szSubKeyName));
        
        IRTCProfile *pProfile;
        hr = spClientProv->CreateProfile( CComBSTR( szProfileXML ), &pProfile);

        RtcFree((LPVOID)szProfileXML );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "EnableProfiles: Failed in CreateProfile, hr=0x%x", hr));           
        }
        else
        {        
            hr = spClientProv->EnableProfile( pProfile, RTCRF_REGISTER_ALL );       
        
            //We don't need pProfile no matter it success or not
            pProfile->Release();
        
            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "EnableProfiles: Failed in EnableProfile(status = 0x%x)!", hr));
            }
        }
    }//for i

    RtcFree((LPVOID)szSubKeyName );
    RegCloseKey(hProvisioningKey);
    
    LOG((RTC_TRACE, "EnableProfiles: exit ok :%x.",pClient));
    return S_OK;
}
//
///////////////////////////////////////////////////////////////////////////////
//    Helper function for opening the provisioning key in the registry and get 
//    the correct handle. The function creates the ProvisioningInfo key if it 
//    doesn't exist. If it exists, it will also open it and return the handle. 
///////////////////////////////////////////////////////////////////////////////
//
HRESULT MyOpenProvisioningKey( HKEY * phProvisioningKey, BOOL fReadOnly)
{
    
    long result;
    DWORD dwDisposition = 0;
    HKEY hProvisioningKey;
    REGSAM samDesired;
    
    
    LOG((RTC_TRACE, "CProfileStore::OpenProvisioningKey: Entered"));
    
    _ASSERTE(phProvisioningKey != NULL);
    
    if (fReadOnly)
    {
        samDesired = KEY_READ;
    }
    else
    {
        samDesired = KEY_ALL_ACCESS;
    }
    
    result = RegCreateKeyEx(
        g_hRegistryHive,        // handle to open key
        g_szProvisioningKeyName,                // subkey name
        0,                                // reserved
        NULL,                            // class string
        0,                                // special options
        samDesired,                    // desired security access
        NULL,                            // inheritance
        &hProvisioningKey,                    // key handle 
        &dwDisposition
        );
    
    
    if (result != ERROR_SUCCESS)
    {
        LOG((RTC_ERROR, "MyOpenProvisioningKey: Unable to open the Provisioning Key"));
        return HRESULT_FROM_WIN32(result);
    }
    
    
    *phProvisioningKey = hProvisioningKey;
    
    
    LOG((RTC_TRACE, "MyOpenProvisioningKey: Exited"));
    
    return S_OK;
}


HRESULT CRTCProvStore::FinalConstruct()
{
  
    LOG((RTC_TRACE, "CRTCProvStore::FinalConstruct - enter"));

    LOG((RTC_TRACE, "CRTCProvStore::FinalConstruct - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProvStore::FinalRelease
//
// This gets called when the object is destroyed.
//
/////////////////////////////////////////////////////////////////////////////

void CRTCProvStore::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCProvStore::FinalRelease - enter"));

    LOG((RTC_TRACE, "CRTCProvStore::FinalRelease - exit S_OK"));

}


//
///////////////////////////////////////////////////////////////////////////////////
// Sets the provisioning Profile.
///////////////////////////////////////////////////////////////////////////////////
//
STDMETHODIMP CRTCProvStore::SetProvisioningProfile(BSTR bstrProfileXML)
{
    HRESULT hr = 0;
    BSTR bstrKey;
    HKEY hProvisioningKey, hProfileKey;
    long result;
    DWORD dwDisposition;
    DWORD dwProfileSize;

    if (IsBadStringPtr(bstrProfileXML, -1))
    {
        Error(L"Bad XML profile string", IID_IRTCProvStore);
        LOG((RTC_ERROR, "CRTCClientProvisioning::SetProvisioningProfile, invalid arg"));
        return E_POINTER;
    }

    hr= GetKeyFromProfile(  bstrProfileXML,  &bstrKey );
    if(FAILED(hr))
	{
        Error(L"No valid URL in XML profile string", IID_IRTCProvStore);
		LOG((RTC_ERROR,"CRTCProvStore::SetProvisioningProfile -"
			" Cannot get uri from profile %s, hr=%x. ", bstrProfileXML,hr));
		return E_FAIL;
	}

    
    // Get a handle to the provisioninginfo key, we need read/write access
    
    hr = MyOpenProvisioningKey(&hProvisioningKey, FALSE);
    if ( FAILED (hr) )
    {
        Error(L"Unable to open ProvisioningKey", IID_IRTCProvStore);
        LOG((RTC_ERROR, "CRTCProvStore::SetProvisioningProfile -"
			" Failed to open provisioning key,hr=%x",hr));
        SysFreeString( bstrKey );
        return hr;
    }
    
    //  Open/Create the registry key for this profile
    result = RegCreateKeyEx(
        hProvisioningKey,                // handle to open key
        bstrKey,                        // subkey name
        0,                                // reserved
        NULL,                            // class string
        0,                                // special options
        KEY_ALL_ACCESS,                    // desired security access
        NULL,                            // inheritance
        &hProfileKey,                    // key handle 
        &dwDisposition
        );
    
    // Close the provisioning key
    RegCloseKey(hProvisioningKey);

    //we don't need bstrKey
    SysFreeString( bstrKey );
    bstrKey = NULL;

    if (result != ERROR_SUCCESS)
    {
        Error(L"Unable to create Profile Key", IID_IRTCProvStore);
        LOG((RTC_ERROR, "CRTCProvStore::SetProvisioningProfile -"
			"Unable to create/open the Profile Key"));        
        return HRESULT_FROM_WIN32(result);
    }
    
    // Now that the key is created, we add the schema value and data 
    
    // size of value data, since it is a widechar, 
    // 1 is for the null that we want to store too. 
	    
    dwProfileSize = sizeof(WCHAR) * (wcslen(bstrProfileXML) + 1);
    
    result = RegSetValueEx(
        hProfileKey,        // handle to key
        g_szProvisioningSchemaKeyName,        // value name
        0,                    // reserved
        REG_BINARY,            // value type
        (const unsigned char *)bstrProfileXML,            // value data
        dwProfileSize        //size of the profile
        );
    
    RegCloseKey(hProfileKey);
    
    if (result != ERROR_SUCCESS)
    {
        Error(L"Unable to set ProvisioningKey", IID_IRTCProvStore);
        LOG((RTC_ERROR, "CRTCProvStore::SetProvisioningProfile -"
			"Failed to add the schema XML!"));
        
        return HRESULT_FROM_WIN32(result);
    }
    
    
    LOG((RTC_TRACE, "CRTCProvStore::SetProvisioningProfile - Exited"));
    
    return S_OK;
}

//
///////////////////////////////////////////////////////////////////////////////////
// Implementation of ISupportErrorInfo::InterfaceSupportsErrorInfo method
///////////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CRTCProvStore::InterfaceSupportsErrorInfo(REFIID riid)
{
    DWORD i = 0;
    DWORD dwLength = 0;
    static const IID * iidArray[] = 
    {
        &IID_IRTCProvStore
    };


    dwLength = (sizeof(iidArray))/(sizeof(iidArray[0]));

    for (i = 0; i < dwLength; i ++)
    {
        if (InlineIsEqualGUID(*iidArray[i], riid))
            return S_OK;
    }
    return S_FALSE;
}

//
///////////////////////////////////////////////////////////////////////////////////
// GetKeyFromProfile
//
///////////////////////////////////////////////////////////////////////////////////
//
HRESULT GetKeyFromProfile( BSTR bstrProfileXML, BSTR * pbstrKey )
{
    IXMLDOMDocument * pXMLDoc = NULL;
    HRESULT hr;
    
    hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER,
        IID_IXMLDOMDocument, (void**)&pXMLDoc );
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "GetKeyFromProfile - "
            "CoCreateInstance failed 0x%lx", hr));
        
        return hr;
    }
    
    
    VARIANT_BOOL bSuccess;
    
    hr = pXMLDoc->loadXML( bstrProfileXML, &bSuccess );
    
    if ( S_OK != hr )
    {
        LOG((RTC_ERROR, "GetKeyFromProfile - "
            "loadXML failed 0x%lx", hr));
        
        if ( S_FALSE == hr )
        {
            hr = E_FAIL;
        }
        
        pXMLDoc->Release();
        return hr;
    }
    
    IXMLDOMNode * pDocument = NULL;
    
    hr = pXMLDoc->QueryInterface( IID_IXMLDOMNode, (void**)&pDocument);
    pXMLDoc->Release();
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "GetKeyFromProfile - "
            "QueryInterface failed 0x%lx", hr));
        return hr;
    }
    
    IXMLDOMNode * pNode = NULL;
    hr = pDocument->selectSingleNode( CComBSTR(g_szProfileInfo), &pNode );
    pDocument->Release();
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "GetKeyFromProfile - "
            "selectSingleNode failed 0x%lx", hr));
        return hr;
    }

    if ( hr != S_OK )
    {
        LOG((RTC_ERROR, "GetKeyFromProfile - "
            "no matching node"));
        return E_FAIL;
    }
    
    IXMLDOMElement * pElement = NULL;
    hr = pNode->QueryInterface( IID_IXMLDOMElement, (void**)&pElement );
    pNode->Release();
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "GetKeyFromProfile - "
            "QueryInterface failed 0x%lx", hr));
        return hr;
    }
    CComVariant var;
    hr = pElement->getAttribute( CComBSTR(g_szKey), &var );
    if ( hr != S_OK )
    {
        LOG((RTC_ERROR, "GetKeyFromProfile - "
            "getAttribute failed 0x%lx", hr));
        return hr;
    }
    pElement->Release();
    if ( var.vt != VT_BSTR )
    {
        LOG((RTC_ERROR, "GetKeyFromProfile - "
            "not a string"));
        return E_FAIL;
    }
    *pbstrKey = SysAllocString( var.bstrVal );
    if ( *pbstrKey == NULL )
    {
        LOG((RTC_ERROR, "GetKeyFromProfile - "
            "out of memory"));
        return E_OUTOFMEMORY;
    }
    return S_OK;
}


//
//////////////////////////////////////////////////////////////////////////////////////////////
// Gets the profile given the key and subkey from registry. 
//
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT MyGetProfileFromKey(
                                         HKEY hProvisioningKey, 
                                         WCHAR *szSubKeyName, 
                                         WCHAR **pszProfileXML
                                         )
{
    long result;
    HKEY hProfileKey;
    WCHAR *szProfileXML;
    DWORD dwMemoryReqd;
    DWORD type;


    LOG((RTC_TRACE, "MyGetProfileFromKey: Entered"));
 
    *pszProfileXML = 0;

    result = RegOpenKeyEx(
                hProvisioningKey,        // handle to open key
                szSubKeyName,            // subkey name
                0,                        // reserved
                KEY_READ,                // security access mask
                &hProfileKey            // handle to open key
                );


    if (result != ERROR_SUCCESS)
    {
        LOG((RTC_ERROR,"MyGetProfileFromKey: RegOpenKeyEx fail, subkey=%s.",szSubKeyName));
        return HRESULT_FROM_WIN32(result);
    }

    // Find out how much space is required for the profile

    result = RegQueryValueEx(
                hProfileKey,            // handle to key
                g_szProvisioningSchemaKeyName,            // value name
                NULL,                    // reserved
                &type,                    // type buffer
                NULL,                    // data buffer
                &dwMemoryReqd            // size of data buffer
                );

    if (result != ERROR_SUCCESS)
    {
        RegCloseKey(hProfileKey);
        LOG((RTC_ERROR,"MyGetProfileFromKey: RegQueryValueEx fail, subkey=%s.",szSubKeyName));
        return HRESULT_FROM_WIN32(result);
    }

    // We have got the size, let us do the memory allocation now

    szProfileXML = (PWCHAR)RtcAlloc( sizeof( WCHAR ) * dwMemoryReqd); 

    if (szProfileXML == 0)
    {
        return E_OUTOFMEMORY;
    }

    // We have the memory too, go ahead and read in the profile

    result = RegQueryValueEx(
                hProfileKey,            // handle to key
                g_szProvisioningSchemaKeyName,            // value name
                NULL,                    // reserved
                &type,                    // type buffer
                                        // data buffer
                (unsigned char *)(szProfileXML),
                &dwMemoryReqd            // size of data buffer
                );

    // We have to close this key irrespective of the result, so we do it here.
    RegCloseKey(hProfileKey);
    
    if (result != ERROR_SUCCESS)
    {
        RtcFree( szProfileXML );
        return HRESULT_FROM_WIN32(result);
    }

    *pszProfileXML = szProfileXML;

    LOG((RTC_TRACE, "MyGetProfileFromKey: Exited"));
 
    return S_OK;
}


STDMETHODIMP CRTCProvStore::get_ProvisioningProfile(BSTR bstrKey, BSTR * pbstrProfileXML)
{
    HRESULT hr;
    HKEY hProvisioningKey;
    WCHAR * szProfile;

    LOG((RTC_TRACE, "CRTCProvStore::get_ProvisioningProfile: Entered"));


    if (IsBadStringPtr(bstrKey, -1))
    {
        Error(L"Bad Key Argument", IID_IRTCProvStore);
        LOG((RTC_ERROR, "CRTCProvStore::get_ProvisioningProfile:", 
            "invalid key string"));
        return E_POINTER;
    }

    if (IsBadWritePtr(pbstrProfileXML, sizeof(BSTR)))
    {
        Error(L"Bad argument for profile string", IID_IRTCProvStore);
        LOG((RTC_ERROR, "CRTCProvStore::get_ProvisioningProfile:", 
            "invalid profilestr pointer"));
        return E_POINTER;
    }


   // We only need a read access here, so we pass true (READONLY).

    hr = MyOpenProvisioningKey(&hProvisioningKey, TRUE);
    if ( FAILED (hr) )
    {
        Error(L"Unable to open ProvisioningKey", IID_IRTCProvStore);
        LOG((RTC_ERROR, "CRTCProvStore::get_ProvisioningProfile -"
                " Failed to open provisioning key,hr=%x",hr));
        return hr;
    }

    hr = MyGetProfileFromKey(hProvisioningKey, bstrKey, &szProfile);

    // Close the provisioning key
    RegCloseKey(hProvisioningKey);

    if ( FAILED( hr ))
    {
        Error(L"Unable to read ProvisioningKey", IID_IRTCProvStore);
        LOG((RTC_ERROR, "CRTCProvStore::get_ProvisioningProfile: GetProfileFromKey Failed."));
        return hr;
    }
        
    // So everything is file. Ready to return success.

    *pbstrProfileXML = SysAllocString(szProfile);
    RtcFree(szProfile);

    if( !*pbstrProfileXML )
    {
        LOG((RTC_ERROR, "CRTCProvStore::get_ProvisioningProfile -"
            "out of memory, or szProfile is null"));
        return E_FAIL;
    }

    LOG((RTC_TRACE, "CRTCProvStore::get_ProvisioningProfile: Exited"));

    return S_OK;
}


//
///////////////////////////////////////////////////////////////////////////////////
// Deletes the provisioning Profile by Key
///////////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CRTCProvStore::DeleteProvisioningProfile(BSTR bstrKey)
{

    HRESULT hr = 0;
    HKEY hProvisioningKey;
    long result;

    LOG((RTC_TRACE, "CRTCProvStore::DeleteProvisioningProfile: Entered"));

    // Get a handle to the provisioninginfo key, we need write access.
    hr = MyOpenProvisioningKey(&hProvisioningKey, FALSE);
    if ( FAILED (hr) )
    {
        Error(L"Unable to open ProvisioningKey", IID_IRTCProvStore);
        LOG((RTC_ERROR, "CRTCProvStore::DeleteProvisioningProfile -"
            "Failed to open provisioning key."));
        return hr;
    }

    // Go ahead and delete this schema from the registry. 
    result = RegDeleteKey(hProvisioningKey,bstrKey);
    RegCloseKey(hProvisioningKey);

    if (result != ERROR_SUCCESS)
    {
            TCHAR szBuffer[]=L"Failed to delete the key";
            Error(szBuffer, IID_IRTCProvStore);
            LOG((RTC_ERROR, "CRTCProvStore::DeleteProvisioningProfile -"
                "Failed to delete the profile. key=%s", bstrKey));
            return HRESULT_FROM_WIN32(result);
    }

    LOG((RTC_TRACE, "CRTCProvStore::DeleteProvisioningProfile: Exited"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\axctl\objectwithsite.h ===
#ifndef _OBJECT_WITH_SITE_H_
#define _OBJECT_WITH_SITE_H_


/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ObjectWithSite.h

Abstract:

    The implementation of IObjectWithSite interface that allows 
    for per-page persistent data to be stored in registry or as
    a cookie.

--*/


#include <Mshtml.h>
#include <Wininet.h>


//
// this url is used to construct the URL for cookies -- a security measure 
// so a script applet cannot drop a cookie with the same name and data
// and fool us into thinking it is our cookie
//

#define RTC_HARDCODED_URL _T("http://www.microsoft.com/")

//
// the expiration date is needed to make the cookie persistent
//

#define RTC_COOKIE_DATA _T("6; expires = Sat, 12-Sep-2099 00:00:00 GMT")



//
// dummy suffix to be appended to the url string
//

#define RTC_URL_SUFFIX  _T("/url")

class __declspec(novtable) CObjectWithSite : public  IObjectWithSite
{

public:

    //
    // current validation level. used to determine whether the page is safe, 
    // unsafe, or whether information from the user is needed
    //
    
    enum EnValidation { VALIDATED_SAFE, VALIDATED_SAFE_PERMANENT, VALIDATED_UNSAFE, UNVALIDATED };


public:

    
    //
    // store type
    // 

    enum EnMechanism { COOKIES, REGISTRY };


    CObjectWithSite(TCHAR const *pszStorageName)
        :m_pszURL(NULL),
        m_dwSecurityZone(URLZONE_UNTRUSTED),
        m_pUnkSite(NULL),
        m_pszStorageName(NULL)
    {
        SetStorageName(pszStorageName);
    }


    ~CObjectWithSite()
    {
    
        if (m_pszURL)
        {
            delete m_pszURL;
        
            m_pszURL = NULL;
        }

        
        if (m_pUnkSite)
        {
            m_pUnkSite->Release();

            m_pUnkSite = NULL;
        }


        if (m_pszStorageName)
        {

            delete m_pszStorageName;

            m_pszStorageName = NULL;

        }
    }

    ////////////////////////////
    //
   	// IObjectWithSite methods


    STDMETHOD(SetSite)(IUnknown *pUnkSite)
    {


        if ((NULL != pUnkSite) && IsBadCodePtr((FARPROC)pUnkSite))
        {
            return E_POINTER;
        }


        s_ObjectWithSiteCritSection.Lock();

        //
        // we are moving away from a page. this is the new page, as far as
        // validation logic is concerned, so invalidate the current page
        //

        if (NULL == pUnkSite)
        {
            Validate(UNVALIDATED);
        }

        // 
        // Get URL and zone information for this site
        //

        //
        // Note: we could delay this until we are actually asked for
        // zone or URL, but this should not be a performance bottlneck 
        // in our case, so do this now to keep the code simple.

        StoreURLAndZone(pUnkSite);


        //
        // replace the current site pointer with the new one
        //

        if (m_pUnkSite)
        {
            m_pUnkSite->Release();
        }


        m_pUnkSite = pUnkSite;

        if (m_pUnkSite)
        {
            m_pUnkSite->AddRef();
        }

        s_ObjectWithSiteCritSection.Unlock();

        return S_OK;
    }


    STDMETHOD(GetSite)(REFIID riid, void **ppSite)
    {

        HRESULT hr = E_POINTER;

        if (!IsBadWritePtr(ppSite, sizeof(void*)))
        {
    
            s_ObjectWithSiteCritSection.Lock();

            *ppSite = NULL;

            if (m_pUnkSite)
            {
                hr = m_pUnkSite->QueryInterface(riid, ppSite);
            }
            else
            {
                hr = E_FAIL;
            }

            s_ObjectWithSiteCritSection.Unlock();

        }

        return hr;
    }


    //
    // has this page been validated?
    //

    EnValidation GetValidation() 
    {

        //
        // if the page has not been validated, see if it is marked as safe
        //

        s_ObjectWithSiteCritSection.Lock();


        if (UNVALIDATED == s_enValidation)
        {
            if (IsPageSafe())
            {
                s_enValidation = VALIDATED_SAFE;
            }
        }

        EnValidation enValidation = s_enValidation;

        s_ObjectWithSiteCritSection.Unlock();

        return enValidation;
    }


    //
    // validate page as safe, unsafe, or reset validation
    //
    
    EnValidation Validate(EnValidation enNewValidation)
    {

        s_ObjectWithSiteCritSection.Lock();


        //
        // keep the validation before the change
        //
        
        EnValidation enOldValidation = s_enValidation;


        //
        // safe permanent is a special case:
        //

        if (VALIDATED_SAFE_PERMANENT == enNewValidation)
        {

            //
            // set persistent safety flag and 
            // validate page as safe
            //

            MarkPageAsSafe();
            enNewValidation = VALIDATED_SAFE;
        }


        //
        // change our validation level for this page
        //

        s_enValidation = enNewValidation;

        s_ObjectWithSiteCritSection.Unlock();

        return enOldValidation;
    }



    BOOL IsIntranet()
    {
        
        //
        //  if anything other that intranet assume internet -- a less secure zone
        //

        s_ObjectWithSiteCritSection.Lock();

        BOOL bIntranet = ( m_dwSecurityZone == URLZONE_INTRANET );

        s_ObjectWithSiteCritSection.Unlock();

        return bIntranet;

    }


    ////////////////////
    //
    // HaveSite()
    //
    // return true if we have a site pointer
    //

    BOOL HaveSite()
    {

        s_ObjectWithSiteCritSection.Lock();


        BOOL bHaveSite = FALSE;

        if (NULL != m_pUnkSite)
        {
            bHaveSite = TRUE;
        }


        s_ObjectWithSiteCritSection.Unlock();

        return bHaveSite;
    }



private:

    ////////////////////////////
    //
    //  store the current url in the "safe" list
    //
    //
    // not thread safe, called from inside a lock
    //

    HRESULT MarkPageAsSafe(EnMechanism enMechanism = COOKIES)
    {

        //
        // if storage is invalid, the object has not been properly initialized
        //

        if (IsBadStringPtr(m_pszStorageName, -1))
        {
            return E_UNEXPECTED;
        }


        //
        // is we don't have the url, can't do what we are asked
        //

        if (NULL == m_pszURL)
        {
            return S_FALSE;
        }


        //
        // if url is garbage, we have a problem
        //

        if ( IsBadStringPtr(m_pszURL, -1) )
        {
            return E_FAIL;
        }


        HRESULT hr = E_FAIL;

        switch (enMechanism)
        {

            case REGISTRY:

                hr = MarkPageSafeInRegistry(m_pszStorageName);
                break;

            case COOKIES:

                hr = MarkPageSafeCookie(m_pszStorageName);
                break;

            default:

                break;

        }

        return hr;
    }


    //
    //  Returns TRUE if the current page is in the safe list
    //

    //
    // not thread safe, called from inside a lock
    //

    BOOL IsPageSafe( EnMechanism enMechanism = COOKIES )
    {

        //
        // if we cannot get safety marking for whatever reason,
        // return false
        //
        
        _ASSERTE(NULL != m_pszStorageName);

        if ( IsBadStringPtr(m_pszURL, -1) || 
             IsBadStringPtr(m_pszStorageName, -1))
        {
            return FALSE;
        }

        BOOL bSafe = FALSE;

        switch (enMechanism)
        {

        case REGISTRY:
 
            bSafe = IsPageSafeRegistry(m_pszStorageName);
            break;

        case COOKIES:
 
            bSafe = IsPageSafeCookie(m_pszStorageName);
            break;

        default:
 
            break;
        }

        return bSafe;
    }



private:

    //
    // this method is only called from the constructor. not thread safe.
    //

    HRESULT SetStorageName(TCHAR const *pszStorageName)
    {
        //
        // calling this method invalidates the old storage name
        // so deallocate it before doing anything else
        //

        if (NULL != m_pszStorageName) 
        {
            delete m_pszStorageName;
            m_pszStorageName = NULL;
        }

        //
        // argument must be valid
        //

        if (IsBadStringPtr(pszStorageName, -1))
        {
            return E_POINTER;
        }

        // 
        // allocate buffer for the new storage name
        // 

        size_t nSize = _tcsclen(pszStorageName) + 1;

        m_pszStorageName = new TCHAR[nSize];

        if (NULL == m_pszStorageName)
        {
            return E_OUTOFMEMORY;
        }

        _tcscpy(m_pszStorageName, pszStorageName);

        return S_OK;
    }



    //
    // cache the url string and security zone id
    // not thread safe must be called from inside a lock
    //
    
    HRESULT StoreURLAndZone(IUnknown *pUnkSite)
    {

        //
        // reset zone and deallocate URL, if it exists
        //

        m_dwSecurityZone = URLZONE_UNTRUSTED;

        if (m_pszURL)
        {
            delete m_pszURL;
            m_pszURL = NULL;
        }
		    
        if (pUnkSite == NULL)
        {
            return S_OK;
        }

        // 
        // use pUnkSite to get to IHTMLDocument2, which will give us the URL
        // 

        //
        // these interfaces need to be released on exit.
        // smart pointers will do exactly what we need
        //

        HRESULT hr = E_FAIL;
                
        CComPtr<IOleClientSite> pSite;

	    if (FAILED(hr = pUnkSite->QueryInterface(IID_IOleClientSite, (LPVOID *) &pSite)))
        {
		    return hr;
        }

        
        CComPtr<IOleContainer>  pOleCtr;

	    if (FAILED(hr = pSite->GetContainer(&pOleCtr)))
        {
		    return hr;
        }


        CComPtr<IHTMLDocument2> pDoc;

        if (FAILED(hr = pOleCtr->QueryInterface(IID_IHTMLDocument2, (LPVOID *) &pDoc)))
        {
		    return hr;
        }

    
        // 
        //  get and keep the url
        //

        BSTR bstrURL;
        
        if (FAILED(hr = pDoc->get_URL(&bstrURL)))
        {
		    return hr;
        }

        UINT nURLLength = SysStringLen(bstrURL) + 1;

        _ASSERTE(NULL == m_pszURL);

        m_pszURL = new TCHAR[nURLLength];

        if (NULL == m_pszURL)
        {
            SysFreeString(bstrURL);
            return E_OUTOFMEMORY;
        }



#ifdef _UNICODE

        _tcscpy(m_pszURL, bstrURL);

#else
        int r = WideCharToMultiByte(
                                  CP_ACP,
                                  0,
                                  bstrURL,
                                  nURLLength,
                                  m_pszURL,
                                  nURLLength,
                                  NULL,
                                  NULL );

        if (0 == r)
        {
            SysFreeString(bstrURL);

            delete m_pszURL;
            m_pszURL = NULL;
            
            return E_FAIL;
        }


#endif

        //
        // whatever follows '#' and '?' is "extra info" and is not considered 
        // to be a part of the actual URL by Internet(Set/Get)Coookie. Extra 
        // Info has no value for us -- so throw it out
        //
        
        TCHAR *psDelimiter = _tcsstr(m_pszURL, _T("#"));
        
        if (NULL != psDelimiter)
        {
            *psDelimiter = _T('\0');
        }


        psDelimiter = _tcsstr(m_pszURL, _T("?"));

        if (NULL != psDelimiter)
        {
            *psDelimiter = _T('\0');
        }


        //
        // at this point we cached the URL
        // now attempt to get the security zone. if we fail getting zone
        // information still keep the url.
        //

        //
        //  Get security zone
        //
        
        CComPtr<IInternetSecurityManager> pSecMgr;
	           

        hr = CoCreateInstance(CLSID_InternetSecurityManager,
		                 NULL,
		                 CLSCTX_INPROC_SERVER,
		                 IID_IInternetSecurityManager,
		                 (LPVOID *) &pSecMgr);

	    if (pSecMgr == NULL)
        {
            SysFreeString(bstrURL);
		    return hr;
        }

	    hr = pSecMgr->MapUrlToZone(bstrURL, &m_dwSecurityZone, 0);
        
        
        //
        // if failed, reset url to untrusted, just in case
        //

        if ( FAILED(hr) )
        {
            m_dwSecurityZone = URLZONE_UNTRUSTED;
        }


        SysFreeString(bstrURL);

        //
        // we should have at least the URL at this point
        //

        return S_OK;
    }

    
    // 
    //  drop a cookie for this page as an indicator that this page is safe
    //

    HRESULT MarkPageSafeCookie(TCHAR const *pszCookieName)
    {

        TCHAR *pszURL = NULL;

        //
        // generate the url for the cookie
        // remember to delete the returned string
        //

        GenerateURLString(&pszURL);

        if (NULL == pszURL)
            return E_OUTOFMEMORY;

        BOOL bReturn = InternetSetCookie(pszURL, pszCookieName, RTC_COOKIE_DATA);

        delete pszURL;

        return (bReturn)?S_OK:E_FAIL;
    }



    //
    //  presence of a cookie for this page is an indicator that it's safe
    //  returns TRUE if the cookie exists. FALSE otherwise
    // 
    
    BOOL IsPageSafeCookie(TCHAR const *pszCookieName)
    {
        
        //
        // m_pszURL was checked by the calling function and the object
        // is protected. m_pszURL should never be null here.
        //
        
        _ASSERTE(m_pszURL);

        // 
        // same goes for pszCookieName
        //

        _ASSERTE(pszCookieName);


        BOOL bReturn = FALSE;

        BOOL bFinalReturn = FALSE;


        TCHAR *pszURL = NULL;

        // remember to delete the returned string

        GenerateURLString(&pszURL);

        if (NULL == pszURL)
        {
            return FALSE;
        }
        
        //
        // see how much data the cookie contains
        //
        
        DWORD dwCookieDataSize = 0;
        
        // 
        // assuming the return code is TRUE if the method succeeds in getting
        // get the buffer size. the current documentation is not 100% clear
        //

        bReturn = InternetGetCookie(pszURL, pszCookieName, NULL, &dwCookieDataSize);


        //
        // dwCookieDataSize has the length of cookie data
        //
        
        if ( bReturn && dwCookieDataSize )
        {

            // 
            //  allocate the buffer for cookie data
            //

            TCHAR *pCookieDataBuffer = new TCHAR[dwCookieDataSize];

            if (NULL != pCookieDataBuffer)
            {
                //
                // all cookies for this page are returned in cookie data,
                // the name argument is ignored
                //
            
                bReturn = InternetGetCookie(pszURL,
                                            pszCookieName,
                                            pCookieDataBuffer,
                                            &dwCookieDataSize);
            

                // 
                // is succeeded, parse cookie data buffer to see if the 
                // cookie we are looking for is there
                //
                                
                if ( bReturn && ( NULL != _tcsstr(pCookieDataBuffer, pszCookieName) ) )
                {

                    bFinalReturn = TRUE;
                }


                delete pCookieDataBuffer;
                pCookieDataBuffer = NULL;
            }
        }


        delete pszURL;
        pszURL = NULL;

        return bFinalReturn;
    }

    

    //
    // add a registry entry for this page as an indicator that the page is safe
    // returns TRUE if the registry entry exists
    //

    HRESULT MarkPageSafeInRegistry(TCHAR const *szRegistryKeyName)
    {
       
        _ASSERTE(m_pszURL);

        //
        // open the registry key. create if not there
        //

        DWORD dwDisposition = 0;
        HKEY hKey = 0;

        LONG rc = RegCreateKeyEx(HKEY_CURRENT_USER,
                            szRegistryKeyName,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            &dwDisposition);

        if ( rc == ERROR_SUCCESS )
        {
            DWORD dwData = 0;

            //
            //  add the current URL to the registry
            //

            rc = RegSetValueEx(hKey,
                               m_pszURL,
                               0,
                               REG_DWORD,
                               (BYTE*)&dwData, 
                               sizeof(DWORD));
 
        }

        if (hKey)
        {
            RegCloseKey(hKey);
        }

        hKey = NULL;

        if (rc == ERROR_SUCCESS )
        {
            return S_OK;
        }
        else 
        {
            return E_FAIL;
        }
    }


    // 
    // presence of a registry entry for this page indicates that the 
    // page is safe
    //
    
    BOOL IsPageSafeRegistry(TCHAR const *szRegistryKeyName)
    {
        
        DWORD dwDisposition = 0;
        HKEY hKey = 0;

        //
        // the default is not safe
        //

        if (NULL == m_pszURL)
        {
            return FALSE;
        }

        //
        // open the registry key where the page information is kept.
        // create if not there
        //

        LONG rc = RegCreateKeyEx(HKEY_CURRENT_USER,
                            szRegistryKeyName, 
                            0, 
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_CREATE_SUB_KEY | KEY_READ,
                            NULL,
                            &hKey,
                            &dwDisposition);

        if ( rc == ERROR_SUCCESS )
        {


            DWORD dwDataType = 0;
            DWORD dwDataSize = 0;
            
            // 
            // read the setting for the current page.
            // Note: we don't need the actual data, we just
            // want to see if the value exists
            // 

            rc = RegQueryValueEx(hKey,
                            m_pszURL,
                            0,
                            &dwDataType,
                            NULL,
                            &dwDataSize
                           );
        }
        
        if (hKey)
        {
            RegCloseKey(hKey);
        }

        hKey = NULL;

        return (rc == ERROR_SUCCESS);
    }


    // 
    // build the URL string based on the hardcoded URL and 
    // the actual URL for this page.
    // we are hoping that the striing will be unique (per page) and no
    // mischevious scripting app can drop a cookie corresponding to 
    // this URL
    // 
    // Note: if the implementation of of Internet(Set/Get)Cookie changes
    // to have stricter validation for the URL string, this technique will
    // not work
    // 

    void GenerateURLString(TCHAR **ppszURL)
    {
        
        //
        // the precondition is that m_pszURL exists
        //

        _ASSERT(NULL != m_pszURL);

        *ppszURL = NULL;

        //
        // alias the char pointer pointer to by *pszURL.
        // so it is easier to refer to.
        //

        TCHAR* &pszURL = *ppszURL;
        
        //
        // allocate memory for concatenated string
        //

        pszURL = new TCHAR[_tcslen(RTC_HARDCODED_URL) + 
                           _tcslen(m_pszURL) + 
                           _tcslen(RTC_URL_SUFFIX) + 1];

        // concatenate 

        if (pszURL)
        {
            *pszURL = _T('\0');
        
            _tcscat(pszURL, RTC_HARDCODED_URL);
            _tcscat(pszURL, m_pszURL);
            _tcscat(pszURL, RTC_URL_SUFFIX);
        }

    }



private:
    
    //
    // cached URL string
    //

    TCHAR *m_pszURL;


    //
    // cached security zone
    //
    
    DWORD m_dwSecurityZone;


    //
    // site for IObjectWithSite
    //

    IUnknown *m_pUnkSite;

    // 
    // thread safety
    //

    static CComAutoCriticalSection s_ObjectWithSiteCritSection;

    //
    // the status of the current page
    //

    static EnValidation s_enValidation;

    //
    // name of the persistent cookie or registry key
    //
    
    TCHAR *m_pszStorageName;

};

#endif // _OBJECT_WITH_SITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\axctl\rtcaxctl.cpp ===
// RTCCtl.cpp : Implementation of CRTCCtl

#include "stdafx.h"
#include "misc.h"
#include "dial.h"
#include "knob.h"
#include "provstore.h"

#define OATRUE -1
#define OAFALSE 0

LONG    g_lObjects = 0;

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CRTCCtl
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

// static members - layouts
// all the values are in pixels

// Zone group sizes
#define ZONE_GROUP_TOOLBAR_HEIGHT       41
#define ZONE_GROUP_MAIN_HEIGHT          186
#define ZONE_GROUP_SECONDARY_HEIGHT     61
#define ZONE_GROUP_PARTLIST_HEIGHT      88
#define ZONE_GROUP_STATUS_HEIGHT        31
#define ZONE_STANDALONE_OFFSET          0

#define ZONE_PARTLIST_STANDALONE        10

// 
#define CTLSIZE_Y                      240

#define QCIF_CX_SIZE                   176
#define QCIF_CY_SIZE                   144

#define QQCIF_CX_SIZE   (QCIF_CX_SIZE/2)
#define QQCIF_CY_SIZE   (QCIF_CY_SIZE/2)

// Initial coordinates for controls
// All values are in pixels

// this takes into account the window has 2pixel thin borders
// the window adjustes itself in order to accomodate the QCIF size,
// but it doesn't center itself..

#define     CTLPOS_X_RECEIVEWIN     29
#define     CTLPOS_Y_RECEIVEWIN     0

#define     CTLPOS_X_DIALPAD        56
#define     CTLPOS_Y_DIALPAD        3

#define     CTLPOS_DX_DIALPAD       5
#define     CTLPOS_DY_DIALPAD       3

#define     CTLPOS_X_MICVOL         120
#define     CTLPOS_Y_MICVOL         -5

#define     CTLPOS_X_SPKVOL         50
#define     CTLPOS_Y_SPKVOL         -5

#define     CTLPOS_X_SEND_AUDIO_MUTE    189
#define     CTLPOS_Y_SEND_AUDIO_MUTE    5

#define     CTLPOS_X_SEND_AUDIO_MUTE_TEXT    194
#define     CTLPOS_Y_SEND_AUDIO_MUTE_TEXT    21

#define     CTLPOS_X_RECV_AUDIO_MUTE    11
#define     CTLPOS_Y_RECV_AUDIO_MUTE    5

#define     CTLPOS_X_RECV_AUDIO_MUTE_TEXT    16
#define     CTLPOS_Y_RECV_AUDIO_MUTE_TEXT    21

#define     CTLPOS_X_SEND_VIDEO         189
#define     CTLPOS_Y_SEND_VIDEO         157

#define     CTLPOS_X_SEND_VIDEO_TEXT    194
#define     CTLPOS_Y_SEND_VIDEO_TEXT    173

#define     CTLPOS_X_RECV_VIDEO         11
#define     CTLPOS_Y_RECV_VIDEO         157

#define     CTLPOS_X_RECV_VIDEO_TEXT    15
#define     CTLPOS_Y_RECV_VIDEO_TEXT    173

#define     CTLPOS_X_RECV_TEXT          0
#define     CTLPOS_Y_RECV_TEXT          45

#define     CTLPOS_X_SEND_TEXT          185
#define     CTLPOS_Y_SEND_TEXT          45

#define     CTLPOS_X_PARTLIST       5
#define     CTLPOS_Y_PARTLIST       0

#define     CTLPOS_X_ADDPART        5
#define     CTLPOS_Y_ADDPART        160

#define     CTLPOS_X_REMPART        123
#define     CTLPOS_Y_REMPART        160

// size of some controls, in pixels
#define     CX_CHECKBOX_BUTTON      37
#define     CY_CHECKBOX_BUTTON      15

#define     CX_DIALPAD_BUTTON       40
#define     CY_DIALPAD_BUTTON       32

#define     CX_PARTLIST             230
#define     CY_PARTLIST_WEBCRM       74
#define     CY_PARTLIST_STANDALONE  150

#define     CX_PARTICIPANT_BUTTON   112
#define     CY_PARTICIPANT_BUTTON   23

#define     CX_GENERIC_TEXT         40
#define     CY_GENERIC_TEXT         16

#define     CX_SENDRECV_TEXT        54
#define     CY_SENDRECV_TEXT        16

// initial placement of rectangles
CZoneStateArray  CRTCCtl::s_InitialZoneStateArray = {
    0,                              TRUE,
    0,                              TRUE,
    0,                              TRUE,
    0,                              TRUE,
    0,                              TRUE,
    0,                              TRUE 
};

// nothing displayed
CZoneStateArray  CRTCCtl::s_EmptyZoneLayout = {
    0,                              FALSE,
    0,                              FALSE,
    0,                              FALSE,
    0,                              FALSE,
    0,                              FALSE,
    0,                              TRUE   // status with error
};

// WebCrm pc to pc
CZoneStateArray  CRTCCtl::s_WebCrmPCToPCZoneLayout = {
    0,                              TRUE,   // toolbar
    ZONE_GROUP_TOOLBAR_HEIGHT,      TRUE,   // logo/video
    ZONE_GROUP_TOOLBAR_HEIGHT,      FALSE,  // no dialpad
    ZONE_GROUP_TOOLBAR_HEIGHT +
    ZONE_GROUP_MAIN_HEIGHT,         TRUE,   // audio controls
    ZONE_GROUP_TOOLBAR_HEIGHT +
    ZONE_GROUP_MAIN_HEIGHT,         FALSE,  // no participants
    ZONE_GROUP_TOOLBAR_HEIGHT +
    ZONE_GROUP_MAIN_HEIGHT +
    ZONE_GROUP_SECONDARY_HEIGHT,    TRUE    // status
};

// WebCrm pc to phone, with dialpad
CZoneStateArray  CRTCCtl::s_WebCrmPCToPhoneWithDialpadZoneLayout = {
    0,                              TRUE,   // toolbar
    ZONE_GROUP_TOOLBAR_HEIGHT,      FALSE,  // no logo/video
    ZONE_GROUP_TOOLBAR_HEIGHT,      TRUE,   // dialpad
    ZONE_GROUP_TOOLBAR_HEIGHT +
    ZONE_GROUP_MAIN_HEIGHT,         TRUE,   // audio controls
    ZONE_GROUP_TOOLBAR_HEIGHT +
    ZONE_GROUP_MAIN_HEIGHT,         FALSE,  // no participants
    ZONE_GROUP_TOOLBAR_HEIGHT +
    ZONE_GROUP_MAIN_HEIGHT +
    ZONE_GROUP_SECONDARY_HEIGHT,    TRUE    // status
};

// WebCrm pc to phone, no dialpad
CZoneStateArray  CRTCCtl::s_WebCrmPCToPhoneZoneLayout = {
    0,                              TRUE,   // toolbar
    ZONE_GROUP_TOOLBAR_HEIGHT,      FALSE,  // no logo/video
    ZONE_GROUP_TOOLBAR_HEIGHT,      FALSE,  // no dialpad
    ZONE_GROUP_TOOLBAR_HEIGHT,      TRUE,   // audio controls
    ZONE_GROUP_TOOLBAR_HEIGHT,      FALSE,  // no participants
    ZONE_GROUP_TOOLBAR_HEIGHT +
    ZONE_GROUP_SECONDARY_HEIGHT,    TRUE    // status
};

// WebCrm phone to phone
CZoneStateArray  CRTCCtl::s_WebCrmPhoneToPhoneZoneLayout = {
    0,                              TRUE,   // toolbar
    ZONE_GROUP_TOOLBAR_HEIGHT,      FALSE,  // no logo/video
    ZONE_GROUP_TOOLBAR_HEIGHT,      FALSE,  // no dialpad
    ZONE_GROUP_TOOLBAR_HEIGHT,      FALSE,  // no audio controls
    ZONE_GROUP_TOOLBAR_HEIGHT,      TRUE,   // participants
    ZONE_GROUP_TOOLBAR_HEIGHT +
    ZONE_GROUP_PARTLIST_HEIGHT,     TRUE    // status
};

// PC to PC, idle or incoming calls
CZoneStateArray  CRTCCtl::s_DefaultZoneLayout = {
    0,                              FALSE,  // no toolbar
    
    ZONE_STANDALONE_OFFSET,         TRUE,   // logo/video
    
    ZONE_STANDALONE_OFFSET,         FALSE,  // no dialpad
    
    ZONE_STANDALONE_OFFSET + 
    ZONE_GROUP_MAIN_HEIGHT,         TRUE,   // audio controls
    
    ZONE_STANDALONE_OFFSET +
    ZONE_GROUP_MAIN_HEIGHT,         FALSE,  // no participants
    
    ZONE_STANDALONE_OFFSET +
    ZONE_GROUP_MAIN_HEIGHT +
    ZONE_GROUP_SECONDARY_HEIGHT,    FALSE   // no status
};

// PC to Phone (same as PC to PC for now)
CZoneStateArray  CRTCCtl::s_PCToPhoneZoneLayout = {
    0,                              FALSE,  // no toolbar

    ZONE_STANDALONE_OFFSET,         TRUE,   // logo/video (should disable video ?)

    ZONE_STANDALONE_OFFSET,         FALSE,  // no dialpad (using the frame one)

    ZONE_STANDALONE_OFFSET +
    ZONE_GROUP_MAIN_HEIGHT,         TRUE,   // audio controls
    
    ZONE_STANDALONE_OFFSET +
    ZONE_GROUP_MAIN_HEIGHT,         FALSE,  // no participants
    
    ZONE_STANDALONE_OFFSET +
    ZONE_GROUP_MAIN_HEIGHT +
    ZONE_GROUP_SECONDARY_HEIGHT,    FALSE   // no status
};

// Phone to Phone
CZoneStateArray  CRTCCtl::s_PhoneToPhoneZoneLayout = {
    0,                              FALSE,  // no toolbar
    
    ZONE_STANDALONE_OFFSET,         FALSE,   // logo/video

    ZONE_STANDALONE_OFFSET,         FALSE,  // no dialpad

    ZONE_STANDALONE_OFFSET +
    ZONE_GROUP_MAIN_HEIGHT,         FALSE,  // no audio controls

    ZONE_STANDALONE_OFFSET +
    ZONE_PARTLIST_STANDALONE,       TRUE,   // participants

    ZONE_STANDALONE_OFFSET +
    ZONE_PARTLIST_STANDALONE  +
    ZONE_GROUP_SECONDARY_HEIGHT,    FALSE   // no status
};


// Constructor
//
CRTCCtl::CRTCCtl()
{
    // This one won't make it into steelhead tracing, it is not initialized yet
    LOG((RTC_TRACE, "[%p] CRTCCtl::CRTCCtl", this));
        
    InitCommonControls();

    m_bWindowOnly = TRUE;

    m_nControlState = RTCAX_STATE_NONE;
    m_bRedirecting = FALSE;
    m_bOutgoingCall = FALSE;
    m_enListen = RTCLM_NONE;
    m_nCtlMode = CTL_MODE_UNKNOWN;

    m_bAddPartDlgIsActive = FALSE;

    m_lMediaCapabilities = 0;
    m_lMediaPreferences = 0;

    m_hAcceleratorDialpad = NULL;
    m_hAcceleratorToolbar = NULL;
    m_hNormalImageList = NULL;
    m_hHotImageList = NULL;
    m_hDisabledImageList = NULL;

    m_hBckBrush = NULL;
    m_hVideoBrush = NULL;

    m_hbmBackground = NULL;

    m_bReadOnlyProp = FALSE;
    m_bBoolPropError = FALSE;

    m_nPropCallScenario = RTC_CALL_SCENARIO_PCTOPC;
    m_bPropAutoPlaceCall = FALSE;
    m_bPropShowDialpad = FALSE;
    m_bPropDisableVideoReception = FALSE;
    m_bPropDisableVideoTransmission = FALSE;
    m_bPropDisableVideoPreview = FALSE;

    m_bReceiveWindowActive = FALSE;
    m_bPreviewWindowActive = FALSE;
    m_bPreviewWindowIsPreferred = TRUE;

    m_nCachedCallScenario = RTC_CALL_SCENARIO_PCTOPC;

    CopyMemory(m_ZoneStateArray, s_InitialZoneStateArray, sizeof(m_ZoneStateArray));
    
    m_pWebCrmLayout = NULL;

    m_hPalette = NULL;
    m_bBackgroundPalette = FALSE;

    m_pSpeakerKnob = NULL;
    m_pMicroKnob = NULL;

    m_pIMWindows = NULL;

    m_pCP = NULL;
    m_ulAdvise = 0;

    CalcExtent(m_sizeExtent);
}

// Destructor
//
CRTCCtl::~CRTCCtl()
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::~CRTCCtl", this));
    
    if (m_pSpeakerKnob)
    {
        delete m_pSpeakerKnob;
        m_pSpeakerKnob = NULL;
    }

    if (m_pMicroKnob)
    {
        delete m_pMicroKnob;
        m_pMicroKnob = NULL;
    }
}

// FinalConstruct (initialize)
//
HRESULT CRTCCtl::FinalConstruct(void)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::FinalConstruct - enter", this));
    
    if ( InterlockedIncrement(&g_lObjects) == 1 )
    {
        //
        // This is the first object
        //

        //
        // Register for steelhead tracing
        //

        LOGREGISTERTRACING(_T("RTCCTL"));
    }

    // Initialize the common controls library
    INITCOMMONCONTROLSEX  InitStruct;

    InitStruct.dwSize = sizeof(InitStruct);
    InitStruct.dwICC = ICC_BAR_CLASSES | ICC_LISTVIEW_CLASSES ;

    InitCommonControlsEx(&InitStruct);

    LOG((RTC_TRACE, "[%p] CRTCCtl::FinalConstruct - exit", this));

    return S_OK;
}

// FinalRelease (uninitialize)
//
void  CRTCCtl::FinalRelease(void)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::FinalRelease - enter", this));
    
    if ( InterlockedDecrement(&g_lObjects) == 0)
    {
        //
        // This was the last object
        //             
      
        //
        // Deregister for steelhead tracing
        //
        
        LOGDEREGISTERTRACING();   
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::FinalRelease - exit", this));
}

// 
// IRTCCtl methods.
//      Methods called when the object is initialized
//      m_bReadOnlyProp == TRUE freezes all the properties
//  

STDMETHODIMP CRTCCtl::get_DestinationUrl(BSTR *pVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_DestinationUrl - enter", this));

    *pVal = m_bstrPropDestinationUrl.Copy();
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_DestinationUrl - exit", this));
    
    return S_OK;
}

STDMETHODIMP CRTCCtl::put_DestinationUrl(BSTR newVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::put_DestinationUrl <%S> - enter", this, newVal ? newVal : L"null"));
   
    if(!m_bReadOnlyProp)
    {
        // just save the value. Don't do anything else
        m_bstrPropDestinationUrl = newVal;
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::put_DestinationUrl - exit", this));
    return S_OK;
}

STDMETHODIMP CRTCCtl::get_DestinationName(BSTR *pVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_DestinationName - enter", this));

    *pVal = m_bstrPropDestinationName.Copy();
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_DestinationName - exit", this));
    
    return S_OK;
}

STDMETHODIMP CRTCCtl::put_DestinationName(BSTR newVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::put_DestinationName <%S> - enter", this, newVal ? newVal : L"null"));
    
    if(!m_bReadOnlyProp)
    {
        // just save the value. Don't do anything else
        m_bstrPropDestinationName = newVal;
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::put_DestinationName - exit", this));
    return S_OK;
}


STDMETHODIMP CRTCCtl::get_AutoPlaceCall(BOOL *pVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_AutoPlaceCall - enter", this));

    *pVal = m_bPropAutoPlaceCall;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_AutoPlaceCall - exit", this));

    return S_OK;
}

STDMETHODIMP CRTCCtl::put_AutoPlaceCall(BOOL newVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::put_AutoPlaceCall <%d> - enter", this, newVal));
    
    // is it a valid boolean value
    if(newVal!=0 && newVal!=1)
    {
        LOG((RTC_TRACE, "[%p] CRTCCtl::put_AutoPlaceCall: invalid boolean value - exit", this));

        m_bBoolPropError = TRUE;

        return E_INVALIDARG;
    }
    
    if(!m_bReadOnlyProp)
    {
        // just save the value. Don't do anything else
        m_bPropAutoPlaceCall = newVal;
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::put_AutoPlaceCall - exit", this));

    return S_OK;
}

STDMETHODIMP CRTCCtl::get_ProvisioningProfile(BSTR *pVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_ProvisioningProfile - enter", this));

    *pVal = m_bstrPropProvisioningProfile.Copy();
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_ProvisioningProfile - exit", this));

    return S_OK;
}

STDMETHODIMP CRTCCtl::put_ProvisioningProfile(BSTR newVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::put_ProvisioningProfile <hmm, do you want to see it here ?> - enter", this));

    if(!m_bReadOnlyProp)
    {
        // just save the value. Don't do anything else
        m_bstrPropProvisioningProfile = newVal;
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::put_ProvisioningProfile - exit", this));

    return S_OK;
}

STDMETHODIMP CRTCCtl::get_ShowDialpad(BOOL *pVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_ShowDialpad - enter", this));

    *pVal = m_bPropShowDialpad;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_ShowDialpad - exit", this));

    return S_OK;
}

STDMETHODIMP CRTCCtl::put_ShowDialpad(BOOL newVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::put_ShowDialpad <%d> - enter", this, newVal));
    
    // is it a valid boolean value
    if(newVal!=0 && newVal!=1)
    {
        LOG((RTC_TRACE, "[%p] CRTCCtl::put_ShowDialpad: invalid boolean value - exit", this));

        m_bBoolPropError = TRUE;

        return E_INVALIDARG;
    }
 
    if(!m_bReadOnlyProp)
    {
        m_bPropShowDialpad = newVal;
    }
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::put_ShowDialpad - exit", this));

    return S_OK;
}

STDMETHODIMP CRTCCtl::get_CallScenario(RTC_CALL_SCENARIO *pVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_CallScenario - enter", this));

    *pVal = m_nPropCallScenario;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_CallScenario - exit", this));

    return S_OK;
}

STDMETHODIMP CRTCCtl::put_CallScenario(RTC_CALL_SCENARIO newVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::put_CallScenario <%d> - enter", this, newVal));

    if(!m_bReadOnlyProp)
    {
        m_nPropCallScenario = newVal;
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::put_CallScenario - exit", this));

    return S_OK;
}

STDMETHODIMP CRTCCtl::get_DisableVideoReception(BOOL *pVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_DisableVideoReception - enter"));

    *pVal = m_bPropDisableVideoReception;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_DisableVideoReception - exit"));

    return S_OK;
}

STDMETHODIMP CRTCCtl::put_DisableVideoReception(BOOL newVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::put_DisableVideoReception <%d> - enter", newVal));
    
    // is it a valid boolean value
    if(newVal!=0 && newVal!=1)
    {
        LOG((RTC_TRACE, "[%p] CRTCCtl::put_DisableVideoReception: invalid boolean value - exit", this));

        m_bBoolPropError = TRUE;

        return E_INVALIDARG;
    }

    if(!m_bReadOnlyProp)
    {
        m_bPropDisableVideoReception = newVal;

    }
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::put_DisableVideoReception - exit"));

    return S_OK;
}

STDMETHODIMP CRTCCtl::get_DisableVideoTransmission(BOOL *pVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_DisableVideoTransmission - enter"));

    *pVal = m_bPropDisableVideoTransmission;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_DisableVideoTransmission - exit"));

    return S_OK;
}

STDMETHODIMP CRTCCtl::put_DisableVideoTransmission(BOOL newVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::put_DisableVideoTransmission <%d> - enter", newVal));
    
    // is it a valid boolean value
    if(newVal!=0 && newVal!=1)
    {
        LOG((RTC_TRACE, "[%p] CRTCCtl::put_DisableVideoTransmission: invalid boolean value - exit", this));

        m_bBoolPropError = TRUE;

        return E_INVALIDARG;
    }

    if(!m_bReadOnlyProp)
    {
        m_bPropDisableVideoTransmission = newVal;
       
    }
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::put_DisableVideoTransmission - exit"));

    return S_OK;
}

STDMETHODIMP CRTCCtl::get_DisableVideoPreview(BOOL *pVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_DisableVideoPreview - enter"));

    *pVal = m_bPropDisableVideoPreview;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_DisableVideoPreview - exit"));

    return S_OK;
}

STDMETHODIMP CRTCCtl::put_DisableVideoPreview(BOOL newVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::put_DisableVideoPreview <%d> - enter", newVal));
    
    // is it a valid boolean value
    if(newVal!=0 && newVal!=1)
    {
        LOG((RTC_TRACE, "[%p] CRTCCtl::put_DisableVideoPreview: invalid boolean value - exit", this));

        m_bBoolPropError = TRUE;

        return E_INVALIDARG;
    }


    if(!m_bReadOnlyProp)
    {
        m_bPropDisableVideoPreview = newVal;
    }
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::put_DisableVideoPreview - exit"));

    return S_OK;
}

// 
// Fire events to the outside world (IRTCCtlNotify)
//  

// Fire_OnControlStateChange
// 
HRESULT    CRTCCtl::Fire_OnControlStateChange(
    /*[in]*/ RTCAX_STATE State,
    /*[in]*/ UINT StatusBarResID)
{
    HRESULT     hr = S_OK;
    // Maximum one connection
    CComPtr<IUnknown> p = IConnectionPointImpl<CRTCCtl, &IID_IRTCCtlNotify, CComUnkOneEntryArray>::m_vec.GetUnknown(1);
    if(p)
    {
        IRTCCtlNotify *pn = reinterpret_cast<IRTCCtlNotify *>(p.p);

        hr = pn->OnControlStateChange(State, StatusBarResID);
    }

    return hr;
};

// 
// IOleControl methods.
//      
//  

// OnAmbientPropertyChange
// removed

// 
// ISupportsErrorInfo methods.
//      
//  

// InterfaceSupportsErrorInfo
// 
STDMETHODIMP CRTCCtl::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_IRTCCtl,
    };
    for (int i=0; i<sizeof(arr)/sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i], riid))
        {
            return S_OK;
        }
    }
    return S_FALSE;
}

// IPersistStream(Init)

STDMETHODIMP CRTCCtl::Load(LPSTREAM pStm)
{
    HRESULT     hr;
    
    LOG((RTC_INFO, "[%p] CRTCCtl::Load (IPersistStream) - enter", this));
    
    //
    // Calls the original method
    //

    hr = IPersistStreamInitImpl<CRTCCtl>::Load(pStm);

    //
    // If successful, compute the new size of 
    // the control and notify the container
    //

    if(SUCCEEDED(hr))
    {
        CalcSizeAndNotifyContainer();
    }
    
    //
    // This in a webcrm scenario
    //
    m_nCtlMode = CTL_MODE_HOSTED;
    
    LOG((RTC_INFO, "[%p] CRTCCtl::Load (IPersistStream) - exit", this));

    return hr;
}

// IPersistPropertyBag
STDMETHODIMP CRTCCtl::Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
{
    HRESULT     hr;
    
    LOG((RTC_INFO, "[%p] CRTCCtl::Load (IPersistPropertyBag) - enter", this));
    
    //
    // Calls the original method
    //

    hr = IPersistPropertyBagImpl<CRTCCtl>::Load(pPropBag, pErrorLog);

    //
    // If successful, compute the new size of 
    // the control and notify the container
    //

    if(SUCCEEDED(hr))
    {
        CalcSizeAndNotifyContainer();
    }
  
    //
    // This in a webcrm scenario
    //
    m_nCtlMode = CTL_MODE_HOSTED;

    LOG((RTC_INFO, "[%p] CRTCCtl::Load (IPersistPropertyBag) - exit", this));

    return hr;
}



// 
// IRTCEventNotification methods.
//      
//  

// Event
//  Dispatches the event to the appropriate specialized method 
//
STDMETHODIMP CRTCCtl::Event(RTC_EVENT enEvent,IDispatch * pEvent)
{
    HRESULT     hr = S_OK;
    
    CComQIPtr<IRTCSessionStateChangeEvent, &IID_IRTCSessionStateChangeEvent>
            pRTCSessionStateChangeEvent;
    CComQIPtr<IRTCParticipantStateChangeEvent, &IID_IRTCParticipantStateChangeEvent>
            pRTCParticipantStateChangeEvent;
    CComQIPtr<IRTCClientEvent, &IID_IRTCClientEvent>
            pRTCRTCClientEvent;
    CComQIPtr<IRTCMediaEvent, &IID_IRTCMediaEvent>
            pRTCRTCMediaEvent;
    CComQIPtr<IRTCIntensityEvent, &IID_IRTCIntensityEvent>
            pRTCRTCIntensityEvent;
    CComQIPtr<IRTCMessagingEvent, &IID_IRTCMessagingEvent>
            pRTCRTCMessagingEvent;

    //LOG((RTC_INFO, "[%p] CRTCCtl::Event %d - enter", this, enEvent));

    switch(enEvent)
    {
    case RTCE_SESSION_STATE_CHANGE:
        pRTCSessionStateChangeEvent = pEvent;
        hr = OnSessionStateChangeEvent(pRTCSessionStateChangeEvent);
        break;

    case RTCE_PARTICIPANT_STATE_CHANGE:
        pRTCParticipantStateChangeEvent = pEvent;
        hr = OnParticipantStateChangeEvent(pRTCParticipantStateChangeEvent);
        break;

    case RTCE_CLIENT:
        pRTCRTCClientEvent = pEvent;
        hr = OnClientEvent(pRTCRTCClientEvent);
        break;

    case RTCE_MEDIA:
        pRTCRTCMediaEvent = pEvent;
        hr = OnMediaEvent(pRTCRTCMediaEvent);
        break;

    case RTCE_INTENSITY:
        pRTCRTCIntensityEvent = pEvent;
        hr = OnIntensityEvent(pRTCRTCIntensityEvent);
        break;

    case RTCE_MESSAGING:
        pRTCRTCMessagingEvent = pEvent;
        hr = OnMessageEvent(pRTCRTCMessagingEvent);
        break;
    }

    //LOG((RTC_INFO, "[%p] CRTCCtl::Event %d - exit", this, enEvent));

    return hr;
}

// 
// IRTCCtlFrameSupport methods.
//  Private interface called by the standalone Phoenix frame     
//  
// 

// GetClient
//  Gets an IRTCClient interface pointer
STDMETHODIMP CRTCCtl::GetClient(/*[out]*/ IRTCClient **ppClient)
{
    HRESULT hr;
    
    LOG((RTC_INFO, "[%p] CRTCCtl::GetClient - enter", this));
    
    if(m_pRTCClient == NULL)
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::GetClient cannot return a non-NULL interface pointer, exit", this));
        return E_FAIL;
    }

    hr = m_pRTCClient.CopyTo(ppClient);

    LOG((RTC_INFO, "[%p] CRTCCtl::GetClient - exit", this));

    return hr;
}

// GetActiveSession
//  Gets the active IRTCSession interface pointer
STDMETHODIMP CRTCCtl::GetActiveSession(/*[out]*/ IRTCSession **ppSession)
{
    HRESULT hr;
    
    LOG((RTC_INFO, "[%p] CRTCCtl::GetActiveSession - enter", this));
    
    hr = m_pRTCActiveSession.CopyTo(ppSession);

    LOG((RTC_INFO, "[%p] CRTCCtl::GetActiveSession - exit", this));

    return hr;
}

// Message
//   Invokes the right appropriate dialog box (if necessary) and
//   then starts an instant message session
// 
STDMETHODIMP CRTCCtl::Message(
                    /*[in]*/ BSTR          pDestName,
                    /*[in]*/ BSTR          pDestAddress,
                    /*[in]*/ BOOL          bDestAddressEditable,
                    /*[out]*/ BSTR       * ppDestAddressChosen
                    )
{
    HRESULT     hr = S_OK;
    CComBSTR    bstrDestAddressChosen;
    CComPtr<IRTCProfile> pProfileChosen = NULL;

    LOG((RTC_INFO, "[%p] CRTCCtl::Message - enter", this));

    // Query for the destination address if required
    //
    
    if(bDestAddressEditable)
    {
        //
        // We need to get the destination address.
        //

        LOG((RTC_TRACE, "[%p] CRTCCtl::Message: bring up ShowDialByAddressDialog", this));

        hr = ShowMessageByAddressDialog(m_hWnd,
                                        pDestAddress,
                                        &bstrDestAddressChosen);
        
        if ( SUCCEEDED(hr) )
        {
            ;  // nothing
        }
        else if (hr==E_ABORT)
        {
            LOG((RTC_TRACE, "[%p] CRTCCtl::Message: ShowMessageByAddressDialog dismissed, do nothing", this));
        }
        else
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::Message: error (%x) returned ShowMessageByAddressDialog", this, hr));
        }
    }
    else
    {
        bstrDestAddressChosen = SysAllocString( pDestAddress );
    }

    BOOL    bIsPhoneAddress = FALSE;
    BOOL    bIsSIPAddress = FALSE;
    BOOL    bIsTELAddress = FALSE;
    BOOL    bHasMaddrOrTsp = FALSE;
    BOOL    bIsEmailLike = FALSE;
  
    if(SUCCEEDED(hr))
    {

        //
        // Determine the type of the address
        //


        hr = GetAddressType(
            bstrDestAddressChosen,
            &bIsPhoneAddress,
            &bIsSIPAddress,
            &bIsTELAddress,
            &bIsEmailLike,
            &bHasMaddrOrTsp);

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::Message: "
                "GetAddressType failed 0x%lx", this, hr));
        
        }
    }

    if(SUCCEEDED(hr))
    {
        // Reject it if it is a phone address
        if (bIsPhoneAddress)
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::Message: "
                "phone address not supported for messenging", this));

            return E_INVALIDARG;
        }
    
        // select a profile if appropriate
        if (!bHasMaddrOrTsp && bIsEmailLike)
        {
            // choose an appropriate profile
            IRTCEnumProfiles * pEnumProfiles = NULL;   
            IRTCProfile      * pProfile = NULL;
            IRTCClientProvisioning * pProv = NULL;

            hr = m_pRTCClient->QueryInterface(
                               IID_IRTCClientProvisioning,
                               (void **)&pProv
                              );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "[%p] CRTCCtl::Message - "
                                    "QI failed 0x%lx", this, hr));
        
                return hr;
            }

            hr = pProv->EnumerateProfiles( &pEnumProfiles );

            pProv->Release();

            if ( SUCCEEDED(hr) )
            {
                while ( S_OK == pEnumProfiles->Next( 1, &pProfile, NULL ) )
                {
                    //
                    // Get the supported session types of the provider
                    //
        
                    long lSupportedSessions;

                    hr = pProfile->get_SessionCapabilities( &lSupportedSessions );

                    if ( FAILED( hr ) )
                    {
                        LOG((RTC_ERROR, "CRTCCtl::Message - failed to "
                                        "get session info - 0x%08x - skipping", hr));

                        pProfile->Release();
                        pProfile = NULL;

                        continue;
                    }

                    if ( lSupportedSessions & RTCSI_PC_TO_PC )
                    {
                        pProfileChosen = pProfile;
                    }
                    
                    pProfile->Release();
                    pProfile = NULL;

                    if ( pProfileChosen != NULL )
                    {
                        break;
                    }
                }

                pEnumProfiles->Release();
                pEnumProfiles = NULL;
            }
        }
 
        // Do the work
        
        IRTCSession * pSession;

        hr = m_pRTCClient->CreateSession(
                    RTCST_IM,
                    NULL,
                    pProfileChosen,
                    RTCCS_FORCE_PROFILE,
                    &pSession
                    );

        if (SUCCEEDED(hr))
        {
            hr = pSession->AddParticipant(
                            bstrDestAddressChosen,
                            pDestName ? pDestName : L"",                            
                            NULL
                            );

            pSession->Release();

            if (FAILED(hr))
            {
                LOG((RTC_ERROR, "[%p] CRTCCtl::Message: error (%x) returned by AddParticipant(...)", this, hr));
            }
        }
        else
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::Message: error (%x) returned by CreateSession(...)", this, hr));
        }
    }

    if ( ppDestAddressChosen != NULL )
    {
        *ppDestAddressChosen = SysAllocString(bstrDestAddressChosen);
    }

    LOG((RTC_INFO, "[%p] CRTCCtl::Message - exit", this));

    return hr;
}

// Call
//   Invokes the right appropriate dialog box (if necessary) and
//   then places the call using the internal method DoCall
// 
STDMETHODIMP CRTCCtl::Call(
                    /*[in]*/ BOOL          bCallPhone,
                    /*[in]*/ BSTR          pDestName,
                    /*[in]*/ BSTR          pDestAddress,
                    /*[in]*/ BOOL          bDestAddressEditable,
                    /*[in]*/ BSTR          pLocalPhoneAddress,
                    /*[in]*/ BOOL          bProfileSelected,
                    /*[in]*/ IRTCProfile * pProfile,
                    /*[out]*/ BSTR       * ppDestAddressChosen
                    )
{
    HRESULT     hr;
    CComBSTR    bstrDestAddressChosen;
    CComBSTR    bstrFromAddressChosen;
    CComPtr<IRTCProfile> pProfileChosen;
    RTC_CALL_SCENARIO   nCallScenario;

    LOG((RTC_INFO, "[%p] CRTCCtl::Call - enter", this));
    
    ATLASSERT(m_nControState == RTCAX_STATE_IDLE);

    // From the user's point of view, the "phone" is busy when dialing
    // (it cannot answer calls)
    SetControlState(RTCAX_STATE_DIALING);

    hr = S_OK;

    // When a call is first started, set the T120 data stream based on any
    // currently running T120 applets 
    VARIANT_BOOL fWhiteboard = VARIANT_FALSE;
    VARIANT_BOOL fAppSharing = VARIANT_FALSE;

    m_pRTCClient->get_IsT120AppletRunning(RTCTA_WHITEBOARD, &fWhiteboard);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::Call: get_IsT120AppletRunning error (%x)", this, hr));
    }

    m_pRTCClient->get_IsT120AppletRunning(RTCTA_APPSHARING, &fAppSharing);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::Call: get_IsT120AppletRunning error (%x)", this, hr));
    }

    if ( fWhiteboard || fAppSharing  )
    {
        m_lMediaPreferences |= RTCMT_T120_SENDRECV;
    }
    else
    {
        m_lMediaPreferences &= (~RTCMT_T120_SENDRECV);
    }

    // Set volatile preferences
    hr = m_pRTCClient->SetPreferredMediaTypes( m_lMediaPreferences, FALSE );
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::Call; cannot set preferred media types, error %x", this, hr));
    }
    
    // Query for the destination address if required
    //
    
    if(bDestAddressEditable)
    {
        //
        // We need to get the destination address.
        //

        if(bCallPhone)
        {
            LOG((RTC_TRACE, "[%p] CRTCCtl::Call: bring up ShowDialByPhoneNumberDialog", this));

            hr = ShowDialByPhoneNumberDialog(m_hWnd,
                                            FALSE,
                                            pDestAddress,
                                            &bstrDestAddressChosen);

        }
        else
        {
            LOG((RTC_TRACE, "[%p] CRTCCtl::Call: bring up ShowDialByAddressDialog", this));

            hr = ShowDialByAddressDialog(   m_hWnd,
                                            pDestAddress,
                                            &bstrDestAddressChosen);
        }

        
        if ( SUCCEEDED(hr) )
        {
            ;  // nothing
        }
        else if (hr==E_ABORT)
        {
            LOG((RTC_TRACE, "[%p] CRTCCtl::Call: ShowDialByXXXDialog dismissed, do nothing", this));
        }
        else
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::Call: error (%x) returned ShowDialByXXXDialog", this, hr));
        }
    }
    else
    {
        bstrDestAddressChosen = pDestAddress;
    }
    
    
    BOOL    bIsPhoneAddress = FALSE;
    BOOL    bIsSIPAddress = FALSE;
    BOOL    bIsTELAddress = FALSE;
    BOOL    bHasMaddrOrTsp = FALSE;
    BOOL    bIsEmailLike = FALSE;
  
    if(SUCCEEDED(hr))
    {

        //
        // Determine the type of the address
        //


        hr = GetAddressType(
            bstrDestAddressChosen,
            &bIsPhoneAddress,
            &bIsSIPAddress,
            &bIsTELAddress,
            &bIsEmailLike,
            &bHasMaddrOrTsp);

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::Call: "
                "GetAddressType failed 0x%lx", this, hr));
        
        }
    }
    
    BOOL bNeedDialog = FALSE;
    BOOL bAllowEditProfile = TRUE;
    BOOL bEnumerateLocalProfiles = TRUE;
    LONG lSessionMask = 0;

    if(SUCCEEDED(hr))
    {
        //
        //  We may need the dialog box for choosing provider and from
        //


        //
        // Special cases
        //      The Address is a TEL URL that has a TSP parameter
        //  or           it is a SIP URL of type PC with a MADDR parameter
        //  or           it is a SIP URL of type Phone   
        //
        //          The profile is ignored, and the user is forced to 
        //      switch to PCTOPHONE if the selected From device is a local phone
        //
        //
        //      The address is a SIP URL of type PC, not looking like an email address
        //
        //          The profile is ignored, the user is forced to switch to PCTOPC
        //      if the selected From Device is a local phone

        if(bHasMaddrOrTsp || (bIsPhoneAddress && bIsSIPAddress) )
        {
            pProfile = NULL;

            bAllowEditProfile = FALSE;
            bEnumerateLocalProfiles = FALSE;

            if(pLocalPhoneAddress && *pLocalPhoneAddress)
            {
				//
				// The user chose "call from phone". This will not work
				// for this address type. We must enfore "call from pc".
				//
#ifdef MULTI_PROVIDER
                bNeedDialog = TRUE;
                lSessionMask = RTCSI_PC_TO_PHONE;   
#else
				pLocalPhoneAddress = NULL;
#endif MULTI_PROVIDER
            }

        }
        else if (!bIsPhoneAddress && !bIsEmailLike)
        {
            pProfile = NULL;

            bAllowEditProfile = FALSE;
            bEnumerateLocalProfiles = FALSE;

            if(pLocalPhoneAddress && *pLocalPhoneAddress)
            {
				//
				// The user chose "call from phone". This will not work
				// for this address type. We must enfore "call from pc".
				//
#ifdef MULTI_PROVIDER
                bNeedDialog = TRUE;
                lSessionMask = RTCSI_PC_TO_PC; 
#else
				pLocalPhoneAddress = NULL;
#endif MULTI_PROVIDER
            }
        }
        else
        {
            long lSupportedSessions = RTCSI_PC_TO_PC;

            if ( pProfile != NULL )
            {
                //
                // We were given a profile
                //

                hr = pProfile->get_SessionCapabilities( &lSupportedSessions );
            
                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "[%p] CRTCCtl::Call: "
                        "get_SessionCapabilities failed 0x%lx", this, hr));
                }
            }
            else if(!bProfileSelected)
            {
                // force the UI to show up (when called from command line)
                lSupportedSessions = 0;
            }
#ifndef MULTI_PROVIDER
            else
            {
                // find supported sessions for all profiles
                IRTCEnumProfiles * pEnumProfiles = NULL;  
                IRTCClientProvisioning * pProv = NULL;

                hr = m_pRTCClient->QueryInterface(
                                   IID_IRTCClientProvisioning,
                                   (void **)&pProv
                                  );

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "[%p] CRTCCtl::Call - "
                                        "QI failed 0x%lx", this, hr));
        
                    return hr;
                }

                hr = pProv->EnumerateProfiles( &pEnumProfiles );

                pProv->Release();

                if ( SUCCEEDED(hr) )
                {
                    while ( S_OK == pEnumProfiles->Next( 1, &pProfile, NULL ) )
                    {
                        //
                        // Get the supported session types of the provider
                        //
        
                        long lSupportedSessionsForThisProfile;

                        hr = pProfile->get_SessionCapabilities( &lSupportedSessionsForThisProfile );

                        if ( FAILED( hr ) )
                        {
                            LOG((RTC_ERROR, "CRTCCtl::Call - failed to "
                                            "get session info - 0x%08x - skipping", hr));

                            pProfile->Release();
                            pProfile = NULL;

                            continue;
                        }

                        lSupportedSessions |= lSupportedSessionsForThisProfile;  
                        
                        pProfile->Release();
                        pProfile = NULL;
                    }

                    pEnumProfiles->Release();
                    pEnumProfiles = NULL;
                }
            }
#endif MULTI_PROVIDER

            if(SUCCEEDED(hr))
            {
                //
                // Check the validity of our call from, profile, and dest address combination
                //

                if ( bIsPhoneAddress )
                {
                    if ( pLocalPhoneAddress == NULL )
                    {
                        bNeedDialog = !(lSupportedSessions & RTCSI_PC_TO_PHONE);
                    }
                    else
                    {
                        bNeedDialog = !(lSupportedSessions & RTCSI_PHONE_TO_PHONE);
                    }

                    lSessionMask = RTCSI_PC_TO_PHONE | RTCSI_PHONE_TO_PHONE;
                }
                else
                {
                    bNeedDialog = !(lSupportedSessions & RTCSI_PC_TO_PC);
                    
                    lSessionMask = RTCSI_PC_TO_PC;
                }
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        if ( bNeedDialog )
        {
            //
            // We need a dialog to get correct call from and profile info
            //

            hr = ShowDialNeedCallInfoDialog(
                                        m_hWnd,
                                        m_pRTCClient,
                                        lSessionMask,
#ifdef MULTI_PROVIDER
                                        bEnumerateLocalProfiles,
                                        bAllowEditProfile,
#else
                                        FALSE,
                                        FALSE,
#endif MULTI_PROVIDER
                                        NULL,
                                        bstrDestAddressChosen,
                                        NULL,   // no special instructions here
                                        &pProfileChosen,
                                        &bstrFromAddressChosen
                                        );
        }
        else
        {
            //
            // Use the call from and profile passed in
            //

            pProfileChosen = pProfile;
            bstrFromAddressChosen = pLocalPhoneAddress;

            hr = S_OK;

        }
    }

    if(SUCCEEDED(hr))
    {        
        // convert from phone/pc & from address to call scenario
        if(bIsPhoneAddress & !bIsSIPAddress)
        {
            nCallScenario = (BSTR)bstrFromAddressChosen==NULL ?
                RTC_CALL_SCENARIO_PCTOPHONE : RTC_CALL_SCENARIO_PHONETOPHONE;
        }
        else
        {
            nCallScenario = RTC_CALL_SCENARIO_PCTOPC;
        }

#ifndef MULTI_PROVIDER
        if ( bAllowEditProfile )
        {
            // choose an appropriate profile
            IRTCEnumProfiles * pEnumProfiles = NULL; 
            IRTCClientProvisioning * pProv = NULL;

            hr = m_pRTCClient->QueryInterface(
                               IID_IRTCClientProvisioning,
                               (void **)&pProv
                              );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "[%p] CRTCCtl::Call - "
                                    "QI failed 0x%lx", this, hr));
    
                return hr;
            }

            hr = pProv->EnumerateProfiles( &pEnumProfiles );

            pProv->Release();

            if ( SUCCEEDED(hr) )
            {
                while ( S_OK == pEnumProfiles->Next( 1, &pProfile, NULL ) )
                {
                    //
                    // Get the supported session types of the provider
                    //
        
                    long lSupportedSessions;

                    hr = pProfile->get_SessionCapabilities( &lSupportedSessions );

                    if ( FAILED( hr ) )
                    {
                        LOG((RTC_ERROR, "CRTCCtl::Call - failed to "
                                        "get session info - 0x%08x - skipping", hr));

                        pProfile->Release();
                        pProfile = NULL;

                        continue;
                    }

                    switch ( nCallScenario )
                    {
                    case RTC_CALL_SCENARIO_PCTOPC:
                        if ( lSupportedSessions & RTCSI_PC_TO_PC )
                        {
                            pProfileChosen = pProfile;
                        }
                        break;

                    case RTC_CALL_SCENARIO_PCTOPHONE:
                        if ( lSupportedSessions & RTCSI_PC_TO_PHONE )
                        {
                            pProfileChosen = pProfile;
                        }
                        break;

                    case RTC_CALL_SCENARIO_PHONETOPHONE:
                        if ( lSupportedSessions & RTCSI_PHONE_TO_PHONE )
                        {
                            pProfileChosen = pProfile;
                        }
                        break;
                    }
                    
                    pProfile->Release();
                    pProfile = NULL;

                    if ( pProfileChosen != NULL )
                    {
                        break;
                    }
                }

                pEnumProfiles->Release();
                pEnumProfiles = NULL;
            }
        }
#endif MULTI_PROVIDER

        // Do the work
        hr = DoCall(pProfileChosen,
                    nCallScenario,
                    ( nCallScenario == RTC_CALL_SCENARIO_PHONETOPHONE) ? bstrFromAddressChosen : NULL,
                    pDestName,
                    bstrDestAddressChosen);

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::Call: error (%x) returned by DoCall(...)", this, hr));
        }
    }

    // common point of processing errors
    if(FAILED(hr))
    {
        if (hr==E_ABORT)
        {
            LOG((RTC_TRACE, "[%p] CRTCCtl::Call: ShowXXXDialog dismissed, do nothing", this));

            SetControlState(RTCAX_STATE_IDLE);

        }
        else
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::Call: error (%x)", this, hr));

            SetControlState(RTCAX_STATE_IDLE, hr);
        }
    }

    if ( ppDestAddressChosen != NULL )
    {
        *ppDestAddressChosen = SysAllocString(bstrDestAddressChosen);
    }
    
    LOG((RTC_INFO, "[%p] CRTCCtl::Call - exit", this));

    return hr;
}

// HangUp
//  Terminates and releases the current session (if any)
// 
STDMETHODIMP CRTCCtl::HangUp(void)
{
    HRESULT hr = S_OK;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::HangUp - enter", this));
    
    ATLASSERT(m_nControState == RTCAX_STATE_CONNECTED);

    if(m_pRTCActiveSession)
    {
        // enter in DISCONNECTING state
        SetControlState(RTCAX_STATE_DISCONNECTING);
        
        // Terminates the session
        hr = m_pRTCActiveSession->Terminate(RTCTR_NORMAL);

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::HangUp: Terminate returned error <%x> - exit", this, hr));

            LOG((RTC_INFO, "[%p] CRTCCtl::HangUp: releasing active session", this));

            m_pRTCActiveSession = NULL;

            SetControlState(RTCAX_STATE_IDLE);

            return hr;
        }

        // the DISCONNECTED event will push the control state to IDLE
    }
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::HangUp - exit", this));

    return hr;
}

// ReleaseSession
//  Releases the current session (if any)
// 
STDMETHODIMP CRTCCtl::ReleaseSession(void)
{
    HRESULT hr = S_OK;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::ReleaseSession - enter", this));
    
    ATLASSERT(m_nControState == RTCAX_STATE_CONNECTED);

    if (m_pRTCActiveSession)
    {      
        LOG((RTC_INFO, "[%p] CRTCCtl::ReleaseSession: releasing active session", this));

        m_pRTCActiveSession = NULL;

        SetControlState(RTCAX_STATE_IDLE);
    }
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::ReleaseSession - exit", this));

    return hr;
}

// AddParticipant
//  Adds a new participant in a PhoneToPhone scenario
//
STDMETHODIMP CRTCCtl::AddParticipant(
    /*[in]*/ LPOLESTR pDestName,
    /*[in]*/ LPOLESTR pDestAddress,
    /*[in]*/ BOOL     bAddressEditable)
{
    HRESULT     hr;
    CComBSTR    bstrDestAddressChosen;

    LOG((RTC_INFO, "[%p] CRTCCtl::AddParticipant - enter", this));
    
    ATLASSERT(m_nControState == RTCAX_STATE_CONNECTED);

    // if there's no number specified, display the dialog box
    // 
    if(pDestAddress == NULL || *pDestAddress == L'\0')
    {
        m_bAddPartDlgIsActive = TRUE;
          
        hr = ShowDialByPhoneNumberDialog(m_hWnd,
                                        TRUE, // bAddParticipant
                                        pDestAddress,
                                        &bstrDestAddressChosen);

        m_bAddPartDlgIsActive = FALSE;
    }
    else
    {
        bstrDestAddressChosen = pDestAddress;

        hr = S_OK;
    }

    if(SUCCEEDED(hr))
    {
        // verify we are still in a CONNECTED state...
        if(m_nControlState == RTCAX_STATE_CONNECTED)
        {
            // Create the participant (callee)
            // This will fire events
            hr = m_pRTCActiveSession->AddParticipant(
                bstrDestAddressChosen,
                pDestName ? pDestName : L"",
                NULL);

            if(hr == HRESULT_FROM_WIN32(ERROR_USER_EXISTS))
            {
                DisplayMessage(
                        _Module.GetResourceInstance(),
                        m_hWnd,
                        IDS_MESSAGE_DUPLICATE_PARTICIPANT,
                        IDS_APPNAME,
                        MB_OK | MB_ICONEXCLAMATION);
            }
            else if (FAILED(hr))
            {
                DisplayMessage(
                        _Module.GetResourceInstance(),
                        m_hWnd,
                        IDS_MESSAGE_CANNOT_ADD_PARTICIPANT,
                        IDS_APPNAME,
                        MB_OK | MB_ICONSTOP);
            }
        }
        else
        {
            // switch back to IDLE if it is busy 
            // 
            if(m_nControlState == RTCAX_STATE_UI_BUSY)
            {
                SetControlState(RTCAX_STATE_IDLE);
            }

            hr = S_OK;
        }


        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::AddParticipant - error <%x> when calling AddParticipant", this, hr));

        }
    }
    else if (hr==E_ABORT)
    {
        LOG((RTC_TRACE, "[%p] CRTCCtl::AddParticipant: ShowXXXDialog dismissed, do nothing", this));

    }
    else
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::AddParticipant: error (%x) returned ShowXXXDialog", this, hr));

        SetControlState(RTCAX_STATE_IDLE);
    }

    LOG((RTC_INFO, "[%p] CRTCCtl::AddParticipant - exit", this));

    return hr;
}

// get_CanAddParticipant
//  
//
STDMETHODIMP CRTCCtl::get_CanAddParticipant(BOOL *pfCan)
{
    *pfCan = ConfButtonsActive();

    return S_OK;
}

// get_CurrentCallScenario
//
//
STDMETHODIMP CRTCCtl::get_CurrentCallScenario(RTC_CALL_SCENARIO *pVal)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_CurrentCallScenario - enter", this));

    *pVal = m_nCachedCallScenario;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_CurrentCallScenario - exit", this));

    return S_OK;
}

// PreProcessMessage
//  Gives the control a chance to process accelerators.
//
STDMETHODIMP CRTCCtl::PreProcessMessage(/*[in]*/ LPMSG lpMsg)
{
    if (m_pIMWindows)
    {
        if (m_pIMWindows->IsDialogMessage(lpMsg))
        {
            return S_OK;
        }
    }

    // directly call TranslateAccelerator of IOleInPlaceActiveObjectImpl for now
    return TranslateAccelerator(lpMsg);
}

// LoadStringResource
//  Load a string resource
//
STDMETHODIMP CRTCCtl::LoadStringResource(
				/*[in]*/ UINT nID,
				/*[in]*/ int nBufferMax,
				/*[out]*/ LPWSTR pszText)
{
    int nChars;

    nChars = LoadString(
        _Module.GetResourceInstance(),
        nID,
        pszText,
        nBufferMax);

    return nChars ? S_OK : HRESULT_FROM_WIN32(GetLastError());
}

// get_ControlState
//  Gets the control state
//
STDMETHODIMP CRTCCtl::get_ControlState( RTCAX_STATE *pVal)
{
    *pVal = m_nControlState;

    return S_OK;
}


// put_ControlState
//  Sets the control state
//
STDMETHODIMP CRTCCtl::put_ControlState( RTCAX_STATE pVal)
{
    SetControlState(pVal);

    return S_OK;
}


// put_Standalone
//  Sets the standalone mode
//
STDMETHODIMP CRTCCtl::put_Standalone(/*[in]*/ BOOL pVal)
{
    m_nCtlMode = pVal ? CTL_MODE_STANDALONE : CTL_MODE_HOSTED;

    if(pVal)
    {
        // this is the first moment the control becomes aware of its 
        // running within frame status 
        // Set the default visual layout for this case
        SetZoneLayout(&s_DefaultZoneLayout, TRUE);
     
    }
    return S_OK;
}

// put_Palette
//  Sets the palette
//
STDMETHODIMP CRTCCtl::put_Palette(/*[in]*/ HPALETTE hPalette)
{
    m_hPalette = hPalette;

    if (m_pSpeakerKnob != NULL)
    {
        m_pSpeakerKnob->SetPalette(m_hPalette);
    }

    if (m_pMicroKnob != NULL)
    {
        m_pMicroKnob->SetPalette(m_hPalette);
    }

    return S_OK;
}

// put_BackgroundPalette
//  Sets the background palette flag
//
STDMETHODIMP CRTCCtl::put_BackgroundPalette(/*[in]*/ BOOL bBackgroundPalette)
{
    m_bBackgroundPalette = bBackgroundPalette;

    if (m_pSpeakerKnob != NULL)
    {
        m_pSpeakerKnob->SetBackgroundPalette(m_bBackgroundPalette);
    }

    if (m_pMicroKnob != NULL)
    {
        m_pMicroKnob->SetBackgroundPalette(m_bBackgroundPalette);
    }

    return S_OK;
}

// put_ListenForIncomingSessions
//  Wrapper for the similar core function
//
STDMETHODIMP CRTCCtl::put_ListenForIncomingSessions(
    /*[in]*/ RTC_LISTEN_MODE enListen)
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::put_ListenForIncomingSessions(%x) - enter", this, enListen));

    // forward to the core
    ATLASSERT(m_pRTCClient != NULL);

    m_enListen = enListen;

    hr = m_pRTCClient->put_ListenForIncomingSessions(enListen);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::put_ListenForIncomingSessions: error (%x) when calling core, exit", this, hr));
        return hr;
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::put_ListenForIncomingSessions(%x) - exit", this, enListen));

    return S_OK;
}

// get_ListenForIncomingSessions
//  Wrapper for the similar core function
//
STDMETHODIMP CRTCCtl::get_ListenForIncomingSessions(
    /*[out, retval]*/ RTC_LISTEN_MODE * penListen)
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::get_ListenForIncomingSessions - enter", this));

    // forward to the core
    ATLASSERT(m_pRTCClient != NULL);

    *penListen = m_enListen;

    LOG((RTC_TRACE, "[%p] CRTCCtl::get_ListenForIncomingSessions - enter", this));

    return S_OK;

}


// get_MediaCapabilities
//
STDMETHODIMP CRTCCtl::get_MediaCapabilities(/*[out, retval]*/ long *pVal)
{
    *pVal = m_lMediaCapabilities;

    return S_OK;
}

// get_MediaPreferences
//
STDMETHODIMP CRTCCtl::get_MediaPreferences(/*[out, retval]*/ long *pVal)
{
    // read the cached value
    *pVal = m_lMediaPreferences;

    return S_OK;
}

// put_MediaPreferences
//
STDMETHODIMP CRTCCtl::put_MediaPreferences(/*[in]*/ long pVal)
{
    HRESULT     hr;

    BOOL    bVideoSendEnabled;
    BOOL    bVideoSendDisabled;
    BOOL    bVideoRecvEnabled;
    BOOL    bVideoRecvDisabled;
    BOOL    bAudioSendEnabled;
    BOOL    bAudioSendDisabled;
    BOOL    bAudioRecvEnabled;
    BOOL    bAudioRecvDisabled;
    BOOL    bT120Enabled;
    BOOL    bT120Disabled;
   
    LOG((RTC_TRACE, "[%p] CRTCCtl::put_MediaPreferences(%x) - enter", this, pVal));

    // Call the core
    ATLASSERT(m_pRTCClient != NULL);

    hr = m_pRTCClient->SetPreferredMediaTypes(pVal, m_nCtlMode == CTL_MODE_STANDALONE);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::put_MediaPreferences: error (%x) when calling core, exit", this, hr));
        return hr;
    }

    // Need this because Start/StopStream allows calling with
    // one media at a time
    bVideoSendEnabled = 
        !(m_lMediaPreferences & RTCMT_VIDEO_SEND) && (pVal & RTCMT_VIDEO_SEND);
    bVideoSendDisabled = 
        (m_lMediaPreferences & RTCMT_VIDEO_SEND) && !(pVal & RTCMT_VIDEO_SEND);
    bVideoRecvEnabled = 
        !(m_lMediaPreferences & RTCMT_VIDEO_RECEIVE) && (pVal & RTCMT_VIDEO_RECEIVE);
    bVideoRecvDisabled = 
        (m_lMediaPreferences & RTCMT_VIDEO_RECEIVE) && !(pVal & RTCMT_VIDEO_RECEIVE);
    bAudioSendEnabled = 
        !(m_lMediaPreferences & RTCMT_AUDIO_SEND) && (pVal & RTCMT_AUDIO_SEND);
    bAudioSendDisabled = 
        (m_lMediaPreferences & RTCMT_AUDIO_SEND) && !(pVal & RTCMT_AUDIO_SEND);
    bAudioRecvEnabled = 
        !(m_lMediaPreferences & RTCMT_AUDIO_RECEIVE) && (pVal & RTCMT_AUDIO_RECEIVE);
    bAudioRecvDisabled = 
        (m_lMediaPreferences & RTCMT_AUDIO_RECEIVE) && !(pVal & RTCMT_AUDIO_RECEIVE);
    bT120Enabled = 
        !(m_lMediaPreferences & RTCMT_T120_SENDRECV) && (pVal & RTCMT_T120_SENDRECV);
    bT120Disabled = 
        (m_lMediaPreferences & RTCMT_T120_SENDRECV) && !(pVal & RTCMT_T120_SENDRECV);

    // Set the internal member
    m_lMediaPreferences = pVal;

    // Refresh the buttons
    long lState;
        
    lState = (long)m_hReceivePreferredButton.SendMessage(BM_GETCHECK, 0, 0);
    if(lState == BST_CHECKED)
    {
        if(!(m_lMediaPreferences & RTCMT_VIDEO_RECEIVE))
        {
            m_hReceivePreferredButton.SendMessage(BM_SETCHECK, BST_UNCHECKED, 0);
        }
    }
    else
    {
        if(m_lMediaPreferences & RTCMT_VIDEO_RECEIVE)
        {
            m_hReceivePreferredButton.SendMessage(BM_SETCHECK, BST_CHECKED, 0);
        }
    }
    
    lState = (long)m_hSendPreferredButton.SendMessage(BM_GETCHECK, 0, 0);
    if(lState == BST_CHECKED)
    {
        if(!(m_lMediaPreferences & RTCMT_VIDEO_SEND))
        {
            m_hSendPreferredButton.SendMessage(BM_SETCHECK, BST_UNCHECKED, 0);
        }
    }
    else
    {
        if(m_lMediaPreferences & RTCMT_VIDEO_SEND)
        {
            m_hSendPreferredButton.SendMessage(BM_SETCHECK, BST_CHECKED, 0);
        }
    }

    // try to synchronize any current session
    // I check the state at each call, I don't what could happen
    // underneath the Core API
    // XXX strange things can happen during ANSWERING or CONNECTING states..
    //

    long lCookie = 0;

#define     SYNC_STREAM(b,op,m,c)                       \
    if(m_pRTCActiveSession &&                           \
        (m_nControlState == RTCAX_STATE_CONNECTED ||    \
         m_nControlState == RTCAX_STATE_CONNECTING ||   \
         m_nControlState == RTCAX_STATE_ANSWERING))     \
    {                                                   \
        if(b)                                           \
        {                                               \
            m_pRTCActiveSession -> op(m, c);            \
        }                                               \
    }

    SYNC_STREAM(bVideoSendDisabled, RemoveStream, RTCMT_VIDEO_SEND, lCookie)
    SYNC_STREAM(bVideoRecvDisabled, RemoveStream, RTCMT_VIDEO_RECEIVE, lCookie)
    SYNC_STREAM(bAudioSendDisabled, RemoveStream, RTCMT_AUDIO_SEND, lCookie)
    SYNC_STREAM(bAudioRecvDisabled, RemoveStream, RTCMT_AUDIO_RECEIVE, lCookie)
    SYNC_STREAM(bT120Disabled, RemoveStream, RTCMT_T120_SENDRECV, lCookie)
    
    SYNC_STREAM(bVideoSendEnabled, AddStream, RTCMT_VIDEO_SEND, lCookie)
    SYNC_STREAM(bVideoRecvEnabled, AddStream, RTCMT_VIDEO_RECEIVE, lCookie)
    SYNC_STREAM(bAudioSendEnabled, AddStream, RTCMT_AUDIO_SEND, lCookie)
    SYNC_STREAM(bAudioRecvEnabled, AddStream, RTCMT_AUDIO_RECEIVE, lCookie)
    SYNC_STREAM(bT120Enabled, AddStream, RTCMT_T120_SENDRECV, lCookie)

#undef      SYNC_STREAM    


    LOG((RTC_TRACE, "[%p] CRTCCtl::put_MediaPreferences - exit", this));

    return S_OK;
}

// get_AudioMuted
//
STDMETHODIMP CRTCCtl::get_AudioMuted(
    /*[in]*/ RTC_AUDIO_DEVICE enDevice,
    /*[out, retval]*/ BOOL *fpMuted)
{
    HRESULT     hr;

    LOG((RTC_TRACE, "[%p] CRTCCtl::get_AudioMuted(%x) - enter", this, enDevice));

    // Call the core
    ATLASSERT(m_pRTCClient != NULL);

    VARIANT_BOOL fMuted;

    hr = m_pRTCClient->get_AudioMuted(enDevice, &fMuted);

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::get_AudioMuted: error (%x) when calling core, exit", this, hr));
        return hr;
    }

    *fpMuted = fMuted ? TRUE : FALSE;

    LOG((RTC_TRACE, "[%p] CRTCCtl::get_AudioMuted - exit", this));

    return S_OK;
}


// put_AudioMuted
//
STDMETHODIMP CRTCCtl::put_AudioMuted(
    /*[in]*/ RTC_AUDIO_DEVICE enDevice,
    /*[in]*/ BOOL pVal)
{
    HRESULT     hr;

    LOG((RTC_TRACE, "[%p] CRTCCtl::put_AudioMuted(%x,%x) - enter", this, enDevice, pVal));

    // Call the core
    ATLASSERT(m_pRTCClient != NULL);

    hr = m_pRTCClient->put_AudioMuted(enDevice, pVal ? VARIANT_TRUE : VARIANT_FALSE);

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::put_AudioMuted: error (%x) when calling core, exit", this, hr));
        return hr;
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::put_AudioMuted - exit", this));

    return S_OK;
}

// put_VideoPreview
//
STDMETHODIMP CRTCCtl::put_VideoPreview(
    /*[in]*/ BOOL pVal)
{
    HRESULT     hr;

    LOG((RTC_TRACE, "[%p] CRTCCtl::put_VideoPreview(%s) - enter", this, pVal ? "true" : "false"));

    m_bPreviewWindowIsPreferred = pVal;
    
    // Apply changes to the existing video window, if necessary
    //
    ShowHidePreviewWindow(
        m_ZoneStateArray[AXCTL_ZONE_LOGOVIDEO].bShown
     && m_bPreviewWindowActive 
     && m_bPreviewWindowIsPreferred);

    // XXX Update the m_hPreviewPreferredButton button here
    //

    // save the setting

    hr = put_SettingsDword(SD_VIDEO_PREVIEW, m_bPreviewWindowIsPreferred);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::put_VideoPreview: error (%x) when calling core", this, hr));

        // not a big deal (at least for this setting)
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::put_VideoPreview(%s) - enter", this, pVal ? "true" : "false"));

    return hr;
}

// get_VideoPreview
//
STDMETHODIMP CRTCCtl::get_VideoPreview(/*[out, retval]*/ BOOL *pVal)
{
    *pVal = m_bPreviewWindowIsPreferred;

    return S_OK;
}



// ShowCallFromOptions
//
STDMETHODIMP CRTCCtl::ShowCallFromOptions()
{
    HRESULT     hr;

    LOG((RTC_TRACE, "[%p] CRTCCtl::ShowCallFromOptions - enter", this));

    ATLASSERT(m_pRTCClient != NULL);

    hr = ShowEditCallFromListDialog( m_hWnd );

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::ShowCallFromOptions: error (%x) returned by ShowEditCallFromListDialog, exit", this, hr));
        return hr;
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::ShowCallFromOptions - exit", this));

    return S_OK;
}

// ShowServiceProviderOptions
//
STDMETHODIMP CRTCCtl::ShowServiceProviderOptions()
{
    HRESULT     hr;

    LOG((RTC_TRACE, "[%p] CRTCCtl::ShowServiceProviderOptions - enter", this));

    ATLASSERT(m_pRTCClient != NULL);

    hr = ShowEditServiceProviderListDialog( m_hWnd, m_pRTCClient );

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::ShowServiceProviderOptions: error (%x) returned by ShowEditCallFromListDialog, exit", this, hr));
        return hr;
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::ShowServiceProviderOptions - exit", this));

    return S_OK;
}

STDMETHODIMP CRTCCtl::StartT120Applet (RTC_T120_APPLET enApplet)
{
    HRESULT     hr;

    LOG((RTC_TRACE, "[%p] CRTCCtl::StartT120Applet(%d) - enter", this, enApplet));

    // Call the core
    ATLASSERT(m_pRTCClient != NULL);

    hr = m_pRTCClient->StartT120Applet(enApplet);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::StartT120Applet: error (%x) when calling core, exit", this, hr));
        return hr;
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::StartT120Applet - exit", this));

    return S_OK;
}

// SetZoneLayout
//
STDMETHODIMP CRTCCtl::SetZoneLayout(
    /* [in] */ CZoneStateArray *pArray,
    /* [in] */ BOOL bRefreshControls)
{
    int i;
    
    // Place each rectangle
    for(i=AXCTL_ZONE_TOOLBAR; i<AXCTL_ZONE_NR; i++)
    {
        PlaceAndEnableDisableZone(i, (*pArray) + i);
    }

    if(bRefreshControls)
    {
        // force the enable/disable of the windows controls
        // based on the new layout
        SetControlState(m_nControlState);
    }

    return S_OK;
}

//
// Message/command handlers
//


// OnInitDialog
//  Processes WM_INITDIALOG
//      CoCreates a CLSID_RTCClient object
//      Registers for notifications
//      Sets the UI items
//      
// 

LRESULT CRTCCtl::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT hr;
    BOOL    bInitError;
    UINT    nID = 0;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnInitDialog - enter", this));

    bInitError = FALSE;

    // Initialize the core
    hr = CoreInitialize();

    if(SUCCEEDED(hr))
    {
        ;   // nothing here
    }
    else
    {
        // a disabled UI will be displayed..
        bInitError = TRUE;
        nID = IDS_ERROR_INIT_CORE;
    }

    // Instant Messaging Window List
    //

    m_pIMWindows = new CIMWindowList( m_pRTCClient );

    if(m_pIMWindows == NULL)
    {
        LOG((RTC_ERROR, "CRTCCtl::OnInitDialog - failed to create IMWindowList"));

        bInitError = TRUE;
        nID = nID ? nID : IDS_ERROR_INIT_GENERIC;
    }

    // Tooltip window
    //
    CreateTooltips();

    //
    // Adjust initial vertical size as specified in sizeExtent
    //  
    // 

    RECT    rectAdjSize;
    SIZE    sizePixel;

    // get current size
    GetClientRect(&rectAdjSize);

    // Get size as known by the container
    AtlHiMetricToPixel(&m_sizeExtent, &sizePixel);

    // adjust the height
    rectAdjSize.bottom = rectAdjSize.top + sizePixel.cy;

    // resize the window
    MoveWindow(
        rectAdjSize.left,
        rectAdjSize.top,
        rectAdjSize.right - rectAdjSize.left,
        rectAdjSize.bottom - rectAdjSize.top,
        FALSE
        );
    
    //
    // Initialize and Attach all controls to their window wrappers
    //

    // hosts for video windows

    m_hReceiveWindow.Attach(GetDlgItem(IDC_RECEIVELOGO));
    m_hPreviewWindow.Attach(GetDlgItem(IDC_PREVIEWLOGO));
    
    // dtmf buttons

    CWindow *pDtmfCrt = m_hDtmfButtons;
    CWindow *pDtmfEnd = m_hDtmfButtons + NR_DTMF_BUTTONS;

    for (int id = IDC_DIAL_0; pDtmfCrt<pDtmfEnd; pDtmfCrt++, id++)
    {
        pDtmfCrt->Attach(GetDlgItem(id));
    }

    // Create the toolbar control
    hr = CreateToolbarControl(&m_hCtlToolbar);
    if(FAILED(hr))
    {
        bInitError = TRUE;
        nID = nID ? nID : IDS_ERROR_INIT_GENERIC;
    }

    // create a status control
    HWND hStatusBar = CreateStatusWindow(
            WS_CHILD | WS_VISIBLE,
            NULL,
            m_hWnd,
            IDC_STATUSBAR);

    if(hStatusBar==NULL)
    {
        LOG((RTC_ERROR, "CRTCCtl::OnInitDialog - failed to create status bar - 0x%08x",
                        GetLastError()));
        bInitError = TRUE;
        nID = nID ? nID : IDS_ERROR_INIT_GENERIC;
    }
    
    m_hStatusBar.Attach(hStatusBar);

    // Divides the status bar in parts
    RECT  rectStatus;
    INT  aWidths[SBP_NR_PARTS];

    rectStatus.left = 0;
    rectStatus.right = 0;

    m_hStatusBar.GetClientRect(&rectStatus);
        
    // divide fairly
    aWidths[SBP_STATUS] = rectStatus.right *4 / 5;
    aWidths[SBP_ICON] = -1;

    // set parts
    m_hStatusBar.SendMessage(SB_SETPARTS, (WPARAM)SBP_NR_PARTS, (LPARAM)aWidths);
    
    // Create buttons
    //

#define CREATE_BUTTON(m,id,ttid)                                    \
    {                                                               \
        RECT    rcButton;                                           \
                                                                    \
        rcButton.left = 0;                                          \
        rcButton.right = 0;                                         \
        rcButton.top = 0;                                           \
        rcButton.bottom = 0;                                        \
                                                                    \
        m.Create(                                                   \
            m_hWnd,                                                 \
            rcButton,                                               \
            _T(""),                                                 \
            WS_TABSTOP,                                             \
            MAKEINTRESOURCE(IDB_AV_INACTIVE),                       \
            MAKEINTRESOURCE(IDB_AV_INACTIVE_PUSH),                  \
            MAKEINTRESOURCE(IDB_AV_DISABLED),                       \
            MAKEINTRESOURCE(IDB_AV_INACTIVE_HOT),                   \
            MAKEINTRESOURCE(IDB_AV_ACTIVE),                         \
            MAKEINTRESOURCE(IDB_AV_ACTIVE_PUSH),                    \
            MAKEINTRESOURCE(IDB_AV_DISABLED),                       \
            MAKEINTRESOURCE(IDB_AV_ACTIVE_HOT),                     \
            NULL,                                                   \
            id);                                                    \
                                                                    \
        TOOLINFO    ti;                                             \
                                                                    \
        ti.cbSize = TTTOOLINFO_V1_SIZE;                             \
        ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;                    \
        ti.hwnd = m_hWnd;                                           \
        ti.uId = (UINT_PTR)(HWND)m;                                 \
        ti.hinst = _Module.GetResourceInstance();                   \
        ti.lpszText = MAKEINTRESOURCE(ttid);                        \
                                                                    \
        m_hTooltip.SendMessage(TTM_ADDTOOL, 0,                      \
                (LPARAM)(LPTOOLINFO)&ti);                           \
    }

    CREATE_BUTTON(m_hReceivePreferredButton, IDC_BUTTON_RECV_VIDEO_ENABLED, IDS_TIPS_RECV_VIDEO_ENABLED);
    
    CREATE_BUTTON(m_hSendPreferredButton, IDC_BUTTON_SEND_VIDEO_ENABLED, IDS_TIPS_SEND_VIDEO_ENABLED);

    CREATE_BUTTON(m_hSpeakerMuteButton, IDC_BUTTON_MUTE_SPEAKER, IDS_TIPS_MUTE_SPEAKER);

    CREATE_BUTTON(m_hMicroMuteButton, IDC_BUTTON_MUTE_MICRO, IDS_TIPS_MUTE_MICRO);

#undef CREATE_BUTTON

#define CREATE_BUTTON(m,id,sid,ttid)                                \
    {                                                               \
        RECT    rcButton;                                           \
        TCHAR   szText[0x100];                                      \
                                                                    \
        rcButton.left = 0;                                          \
        rcButton.right = 0;                                         \
        rcButton.top = 0;                                           \
        rcButton.bottom = 0;                                        \
                                                                    \
        szText[0] = _T('\0');                                       \
        ::LoadString(_Module.GetResourceInstance(),sid,             \
                szText, sizeof(szText)/sizeof(szText[0]));          \
                                                                    \
        m.Create(                                                   \
            m_hWnd,                                                 \
            rcButton,                                               \
            szText,                                                 \
            WS_TABSTOP,                                             \
            MAKEINTRESOURCE(IDB_BUTTON_NORM),                       \
            MAKEINTRESOURCE(IDB_BUTTON_PRESS),                      \
            MAKEINTRESOURCE(IDB_BUTTON_DIS),                        \
            MAKEINTRESOURCE(IDB_BUTTON_HOT),                        \
            NULL,                                                   \
            id);                                                    \
                                                                    \
        TOOLINFO    ti;                                             \
                                                                    \
        ti.cbSize = TTTOOLINFO_V1_SIZE;                             \
        ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;                    \
        ti.hwnd = m_hWnd;                                           \
        ti.uId = (UINT_PTR)(HWND)m;                                 \
        ti.hinst = _Module.GetResourceInstance();                   \
        ti.lpszText = MAKEINTRESOURCE(ttid);                        \
                                                                    \
        m_hTooltip.SendMessage(TTM_ADDTOOL, 0,                      \
                (LPARAM)(LPTOOLINFO)&ti);                           \
    }

    CREATE_BUTTON(m_hAddParticipant, IDC_BUTTON_ADD_PART, IDS_BUTTON_ADD_PART, IDS_TIPS_ADD_PART);
    
    CREATE_BUTTON(m_hRemParticipant, IDC_BUTTON_REM_PART, IDS_BUTTON_REM_PART, IDS_TIPS_REM_PART);

#undef CREATE_BUTTON
    //
    // setup knob controls
    //
    //
    
    // create speaker knob
    m_pSpeakerKnob = new CKnobCtl(
                                    IDB_SPKVOL,
                                    IDB_SPKVOL_HOT,
                                    IDB_SPKVOL_DISABLED,
                                    IDB_KNOB_LIGHT,
                                    IDB_KNOB_LIGHT_DIM,
                                    IDB_KNOB_LIGHT_DISABLED,
                                    IDB_KNOB_LIGHT_MASK);

    HWND        hWndSpeaker = NULL;

    if(m_pSpeakerKnob)
    {
        // Create the window
        hWndSpeaker = m_pSpeakerKnob->Create(
            m_hWnd,
            0,
            0,
            IDC_KNOB_SPEAKER);

        m_hSpeakerKnob.Attach(hWndSpeaker);
        m_hSpeakerKnob.SendMessage(TBM_SETPOS, (WPARAM)TRUE, 0);

        // add the tool to the tooltip window
        //
        TOOLINFO    ti;

        ti.cbSize = TTTOOLINFO_V1_SIZE; 
        ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;
        ti.hwnd = m_hWnd;
        ti.uId = (UINT_PTR)hWndSpeaker;
        ti.hinst = _Module.GetResourceInstance();
        ti.lpszText = MAKEINTRESOURCE(IDS_TIPS_KNOB_SPEAKER);

        m_hTooltip.SendMessage(TTM_ADDTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);
    }
     
    // create microphone knob
    
    m_pMicroKnob = new CKnobCtl(
                                    IDB_MICVOL,
                                    IDB_MICVOL_HOT,
                                    IDB_MICVOL_DISABLED,
                                    IDB_KNOB_LIGHT,
                                    IDB_KNOB_LIGHT_DIM,
                                    IDB_KNOB_LIGHT_DISABLED,
                                    IDB_KNOB_LIGHT_MASK);

    HWND        hWndMicro = NULL;

    if(m_pMicroKnob)
    {
        // Create the window
        hWndMicro = m_pMicroKnob->Create(
            m_hWnd,
            0,
            0,
            IDC_KNOB_MICRO);

        m_hMicroKnob.Attach(hWndMicro);
        m_hMicroKnob.SendMessage(TBM_SETPOS, (WPARAM)TRUE, 0);

        // add the tool to the tooltip window
        //
        TOOLINFO    ti;

        ti.cbSize = TTTOOLINFO_V1_SIZE;
        ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;
        ti.hwnd = m_hWnd;
        ti.uId = (UINT_PTR)hWndMicro;
        ti.hinst = _Module.GetResourceInstance();
        ti.lpszText = MAKEINTRESOURCE(IDS_TIPS_KNOB_MICRO);

        m_hTooltip.SendMessage(TTM_ADDTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);
    }
    

    // Participant list
    //
    m_hParticipantList.Attach(GetDlgItem(IDC_LIST_PARTICIPANTS));
    
    hr = m_hParticipantList.Initialize();
    if(FAILED(hr))
    {
        bInitError = TRUE;
        nID = nID ? nID : IDS_ERROR_INIT_GENERIC;
    }
    
    // some static text controls
    RECT    rectDummy;
    TCHAR   szText[0x100];

    rectDummy.bottom =0;
    rectDummy.left = 0;
    rectDummy.right = 0;
    rectDummy.top = 0;

    szText[0] = _T('\0');

    LoadString(_Module.GetResourceInstance(), IDS_TEXT_VIDEO, 
        szText, sizeof(szText)/sizeof(szText[0]));

    m_hReceivePreferredText.Create(m_hWnd, rectDummy, szText, WS_CHILD | WS_VISIBLE, WS_EX_TRANSPARENT);
    m_hSendPreferredText.Create(m_hWnd, rectDummy, szText, WS_CHILD | WS_VISIBLE, WS_EX_TRANSPARENT);
    
    szText[0] = _T('\0');

    LoadString(_Module.GetResourceInstance(), IDS_TEXT_AUDIO, 
        szText, sizeof(szText)/sizeof(szText[0]));

    m_hSpeakerMuteText.Create(m_hWnd, rectDummy, szText, WS_CHILD | WS_VISIBLE, WS_EX_TRANSPARENT);
    m_hMicroMuteText.Create(m_hWnd, rectDummy, szText, WS_CHILD | WS_VISIBLE, WS_EX_TRANSPARENT);

    szText[0] = _T('\0');

    LoadString(_Module.GetResourceInstance(), IDS_SEND, 
        szText, sizeof(szText)/sizeof(szText[0]));

    m_hSendText.Create(m_hWnd, rectDummy, szText, WS_CHILD | WS_VISIBLE, WS_EX_TRANSPARENT);
    m_hSendText.put_CenterHorizontal(TRUE);

    szText[0] = _T('\0');

    LoadString(_Module.GetResourceInstance(), IDS_RECEIVE, 
        szText, sizeof(szText)/sizeof(szText[0]));

    m_hReceiveText.Create(m_hWnd, rectDummy, szText, WS_CHILD | WS_VISIBLE, WS_EX_TRANSPARENT);
    m_hReceiveText.put_CenterHorizontal(TRUE);

    // place all controls at their initial position and set the tab order
    PlaceWindowsAtTheirInitialPosition();

    // make sure the sizes for the logo windows are corect
    // Their client area must exactly match QCIF and QCIF/4
    // This function must be called AFTER the video windows have
    // been placed at their initial position

    AdjustVideoFrames();

    // Load the accelerator for dialpad
    m_hAcceleratorDialpad = LoadAccelerators(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDR_ACCELERATOR_DIALPAD));
    if(!m_hAcceleratorDialpad)
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnInitDialog - couldn't load the accelerator table for dialpad", this));
    }
    
    // Load the accelerator for toolbar
    m_hAcceleratorToolbar = LoadAccelerators(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDR_ACCELERATOR_TOOLBAR));
    if(!m_hAcceleratorToolbar)
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnInitDialog - couldn't load the accelerator table for toolbar", this));
    }

    // Set the initial visual aspect
    // for Web hosted, use the properties in order to choose a predefined layout
    // for Frame based, the control is driven through IRTCCtlFrameSupport
    
    CZoneStateArray *pLayout;
        
    pLayout = &s_EmptyZoneLayout;

    // if standalone mode, m_nCtlMode is still set to unknown (it will be set
    // later by the main app through the IRTCCtlFrameSupport interf

    if(m_nCtlMode != CTL_MODE_HOSTED
        || (BSTR)m_bstrPropDestinationUrl == NULL
        || m_bstrPropDestinationUrl.Length()==0 ) 
    {
        // 
        nID =  nID ? nID : IDS_ERROR_INIT_INVPARAM_URL;
    }
    else
    {
        if(!bInitError)
        {
            // Create a one shot profile, this also validates the XML provisioning profile
            if(m_bstrPropProvisioningProfile!=NULL && *m_bstrPropProvisioningProfile!=L'\0')
            { 
                IRTCClientProvisioning * pProv = NULL;

                hr = m_pRTCClient->QueryInterface(
                            IID_IRTCClientProvisioning,
                            (void **) &pProv
                           );

                if (FAILED(hr))
                {
                    LOG((RTC_ERROR, "[%p] CRTCCtl::OnInitDialog; cannot QI for one shot provisioning, error %x", this, hr));

                    bInitError = TRUE;
                    nID =  nID ? nID : IDS_ERROR_INIT_INVPARAM_PROV;
                }
                else
                {
                    hr = pProv->CreateProfile(m_bstrPropProvisioningProfile, &m_pRTCOneShotProfile);

                    pProv->Release();
                    pProv = NULL;

                    if (FAILED(hr))
                    {
                        LOG((RTC_ERROR, "[%p] CRTCCtl::OnInitDialog; cannot create one shot profile, error %x", this, hr));

                        bInitError = TRUE;
                        nID =  nID ? nID : IDS_ERROR_INIT_INVPARAM_PROV;
                    }
                }
            }
            else
            {
                // it's not fatal for PC to PC
                if(m_nPropCallScenario != RTC_CALL_SCENARIO_PCTOPC)
                {
                    LOG((RTC_ERROR, "[%p] CRTCCtl::OnInitDialog; provisioning profile not present", this));
                    bInitError = TRUE;
                    nID =  nID ? nID : IDS_ERROR_INIT_INVPARAM_PROV;
                }
            }
        }
        if(!bInitError)
        {
            if(m_bBoolPropError)
            {
                bInitError = TRUE;
                nID =  nID ? nID : IDS_ERROR_INIT_INVPARAM_BOOLEAN;
            }
        }
        if(!bInitError)
        {
            if(m_pWebCrmLayout)
            {
                pLayout = m_pWebCrmLayout;
            }
            else
            {
                bInitError = TRUE;
                nID =  nID ? nID : IDS_ERROR_INIT_INVPARAM_SCENARIO;
            }
        }
    }
    
    // Load the background bitmap
    //
    m_hbmBackground = (HBITMAP)LoadImage(
        _Module.GetResourceInstance(),
        MAKEINTRESOURCE(IDB_METAL),
        IMAGE_BITMAP,
        0,
        0,
        LR_CREATEDIBSECTION);

    // Set the control visual layout
    //

    SetZoneLayout(pLayout, FALSE);

    //
    // Brush for background
    //  using a cached one

    //m_hBckBrush = (HBRUSH)GetStockObject(HOLLOW_BRUSH);
    m_hBckBrush = (HBRUSH)GetSysColorBrush(COLOR_3DFACE);
    m_hVideoBrush = (HBRUSH)GetStockObject(BLACK_BRUSH);

    // Refresh the audio controls
    RefreshAudioControls();

    // Refresh the video controls
    RefreshVideoControls();

    // activates the controls
    SetControlState((bInitError ? RTCAX_STATE_ERROR : RTCAX_STATE_IDLE), S_OK, nID);
     
    // freeze the properties
    m_bReadOnlyProp = TRUE;

    // post PlaceCall if AutoPlaceCall is TRUE && state is IDLE
    //  Currently all the initialization is done synchronously, so
    //  the ctl state must be IDLE if there has been no error.
    
    if(m_nControlState == RTCAX_STATE_IDLE
        && m_bPropAutoPlaceCall)
    {
        // post

        PostMessage(
            WM_COMMAND,
            MAKEWPARAM(IDC_BUTTON_CALL, 1), // Accelerator like
            NULL);
    }

    //
    // register for terminal services notifications
    //

    m_hWtsLib = LoadLibrary( _T("wtsapi32.dll") );

    if (m_hWtsLib)
    {
        WTSREGISTERSESSIONNOTIFICATION   fnWtsRegisterSessionNotification;
        
        fnWtsRegisterSessionNotification = 
            (WTSREGISTERSESSIONNOTIFICATION)GetProcAddress( m_hWtsLib, "WTSRegisterSessionNotification" );

        if (fnWtsRegisterSessionNotification)
        {
            fnWtsRegisterSessionNotification( m_hWnd, NOTIFY_FOR_THIS_SESSION );
        }
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::OnInitDialog - exit", this));

    bHandled = FALSE;

    // os sets focus
    return 1;
}

// OnDestroy
// Processes WM_DESTROY
//      Aborts any call
//      Unregister the event sink
//      Releases all references to the core
//      
// 

LRESULT CRTCCtl::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnDestroy - enter", this));

    //
    // unregister for terminal services notifications
    //

    if (m_hWtsLib)
    {
        WTSUNREGISTERSESSIONNOTIFICATION fnWtsUnRegisterSessionNotification;

        fnWtsUnRegisterSessionNotification = 
            (WTSUNREGISTERSESSIONNOTIFICATION)GetProcAddress( m_hWtsLib, "WTSUnRegisterSessionNotification" );

        if (fnWtsUnRegisterSessionNotification)
        {
            fnWtsUnRegisterSessionNotification( m_hWnd );
        }

        FreeLibrary( m_hWtsLib );
        m_hWtsLib = NULL;
    }

    // destroy the IM windows
    if (m_pIMWindows)
    {
        delete m_pIMWindows;
        m_pIMWindows = NULL;
    }

    // uninitialize the core
    CoreUninitialize();

    // Destroy the toolbar control
    DestroyToolbarControl(&m_hCtlToolbar);

    // Destroy GDI resources
    if(m_hbmBackground)
    {
        DeleteObject(m_hbmBackground);
        m_hbmBackground = NULL;
    }

    PostQuitMessage(0);

    bHandled = FALSE;   
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnDestroy - exit", this));
    return 0;
}

// OnWtsSessionChange
//
LRESULT CRTCCtl::OnWtsSessionChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnWtsSessionChange - enter", this));
    HRESULT hr;


    switch( wParam )
    {
    case WTS_CONSOLE_CONNECT:
        LOG((RTC_INFO, "[%p] CRTCCtl::OnWtsSessionChange - WTS_CONSOLE_CONNECT (%d)",
            this, lParam));

        if ( m_enListen != RTCLM_NONE)
        {
            LOG((RTC_INFO, "[%p] CRTCCtl::OnWtsSessionChange - enabling listen", this));

            ATLASSERT(m_pRTCClient != NULL);

            hr = m_pRTCClient->put_ListenForIncomingSessions( m_enListen );

            if(FAILED(hr))
            {
                LOG((RTC_ERROR, "[%p] CRTCCtl::OnWtsSessionChange - "
                        "error <%x> when calling put_ListenForIncomingSessions", this, hr));
            }
        }
        break;

    case WTS_CONSOLE_DISCONNECT:
        LOG((RTC_INFO, "[%p] CRTCCtl::OnWtsSessionChange - WTS_CONSOLE_DISCONNECT (%d)",
            this, lParam));

        // if a call is active
        if(m_nControlState == RTCAX_STATE_CONNECTING ||
           m_nControlState == RTCAX_STATE_CONNECTED ||
           m_nControlState == RTCAX_STATE_ANSWERING)
        {
            LOG((RTC_INFO, "[%p] CRTCCtl::OnWtsSessionChange - dropping active call", this));

            if (m_nCachedCallScenario == RTC_CALL_SCENARIO_PHONETOPHONE)
            {
                ReleaseSession();
            }
            else
            {
                HangUp();
            }
        }

        if ( m_enListen != RTCLM_NONE )
        {
            LOG((RTC_INFO, "[%p] CRTCCtl::OnWtsSessionChange - disabling listen", this));

            ATLASSERT(m_pRTCClient != NULL);

            hr = m_pRTCClient->put_ListenForIncomingSessions( RTCLM_NONE );

            if(FAILED(hr))
            {
                LOG((RTC_ERROR, "[%p] CRTCCtl::OnWtsSessionChange - "
                        "error <%x> when calling put_ListenForIncomingSessions", this, hr));
            }
        }

        break;
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::OnWtsSessionChange - exit", this));
    return 0;
}

// OnKnobNotify
// Processes WM_NOTIFY from Volume knobs
LRESULT CRTCCtl::OnKnobNotify(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnKnobNotify - enter", this));

    HRESULT hr;

    CWindow *pKnob = idCtrl == IDC_KNOB_SPEAKER ?
        &m_hSpeakerKnob : &m_hMicroKnob;
    
    long lPos = (long)pKnob->SendMessage(TBM_GETPOS, 0, 0);

    hr = m_pRTCClient->put_Volume( 
        idCtrl == IDC_KNOB_SPEAKER ? RTCAD_SPEAKER : RTCAD_MICROPHONE, 
        lPos );
       
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnKnobNotify - error <%x> when calling put_Volume", this, hr));
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::OnKnobNotify - exit", this));

    return 0;
}

// OnKnobNotify
// Processes WM_NOTIFY from Volume knobs
LRESULT CRTCCtl::OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnItemChanged - exit", this));

    NMLISTVIEW  *pnmlv = (NMLISTVIEW *)pnmh;

    if((pnmlv->uChanged & LVIF_STATE) && (pnmlv->uNewState & LVIS_SELECTED))
    {
        // update the delete button
        UpdateRemovePartButton();
    }

    return 0;
}

// OnButtonCall
// Processes BN_CLICK

LRESULT CRTCCtl::OnButtonCall(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnButtonCall - enter", this));

    // Must be in RTCAX_STATE_IDLE state
    if(m_nControlState != RTCAX_STATE_IDLE)
    {
        //ATLASSERT(
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnButtonCall - invalid control state (%d), exit", this, m_nControlState));
        
        return 0;
    }
    
    //
    // Proceed with the call.
    //

    CallOneShot();

    LOG((RTC_TRACE, "[%p] CRTCCtl::OnButtonCall - exit", this));

    return 0;
}

// OnButtonHangUp
// Processes BN_CLICK

LRESULT CRTCCtl::OnButtonHangUp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnButtonHangUp - enter", this));

    // Must be in RTCAX_STATE_CONNECTING or ..CONNECTED state
    if(m_nControlState != RTCAX_STATE_CONNECTING &&
       m_nControlState != RTCAX_STATE_CONNECTED &&
       m_nControlState != RTCAX_STATE_ANSWERING)
    {
        //ATLASSERT(
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnButtonHangUp - invalid control state (%d), exit", this, m_nControlState));
        
        return 0;
    }
    
    //
    // Proceed with hang up
    //
    HangUp();

    
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnButtonHangUp - exit", this));

    return 0;
}


// OnToolbarAccel
// Processes toolbar accelerators

LRESULT CRTCCtl::OnToolbarAccel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnToolbarAccel - enter", this));
    
    // 
    //  Is the button enabled ?
    // 
    LRESULT lState;

    lState = m_hCtlToolbar.SendMessage(TB_GETSTATE, (WPARAM)wID);

    if(lState != -1 && (lState & TBSTATE_ENABLED) 
        && (wID == IDC_BUTTON_CALL || wID == IDC_BUTTON_HUP))
    {
        //
        //  Visual feedback - press the button
        //
        
        m_hCtlToolbar.SendMessage(TB_SETSTATE, (WPARAM)wID, (LPARAM)(lState | TBSTATE_PRESSED));

        // 
        // Set a timer for depressing the key
        //  Using the button ID as a timer id.  
        //

        if (0 == SetTimer(wID, 150))
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::OnToolbarAccel - failed to create a timer", this));

            // revert the button if SetTimer has failed
            m_hCtlToolbar.SendMessage(TB_SETSTATE, (WPARAM)wID, (LPARAM)lState);
            
            //
            // Call recursively, don't have visual effect
            //
    
            SendMessage(
                WM_COMMAND,
                MAKEWPARAM(wID, BN_CLICKED),
                (LPARAM)hWndCtl);
        }

        //
        // If a timer has been fired, the call of the relevant method
        //  will happen during WM_TIMER
        //
            
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::OnToolbarAccel - exit", this));

    return 0;
}

// OnButtonAddPart
// Processes BN_CLICK

LRESULT CRTCCtl::OnButtonAddPart(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    return AddParticipant(NULL, NULL, TRUE);
}

// OnButtonRemPart
// Processes BN_CLICK

LRESULT CRTCCtl::OnButtonRemPart(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    IRTCParticipant *pParticipant = NULL;
    HRESULT hr;

    // prepare the deletion from the list view
    hr = m_hParticipantList.Remove(&pParticipant);
    if(SUCCEEDED(hr) && pParticipant)
    {
        if(m_pRTCActiveSession)
        {
            hr = m_pRTCActiveSession->RemoveParticipant(pParticipant);
        }
        else
        {
            hr = E_UNEXPECTED;
        }

        pParticipant -> Release();
    }
    
    // refresh the Remove Participant button
    UpdateRemovePartButton();

    return hr;
 
}


// OnButtonMuteSpeaker
// Processes BN_CLICK

LRESULT CRTCCtl::OnButtonMuteSpeaker(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{  
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnButtonMuteSpeaker - enter", this));

    HRESULT hr;

    long lState = (long)m_hSpeakerMuteButton.SendMessage(BM_GETCHECK, 0, 0);

    // the button is actually the opposite of "mute"
    // so set the opposite of the opposite
    hr = m_pRTCClient->put_AudioMuted( RTCAD_SPEAKER, (!(lState == BST_UNCHECKED)) ? VARIANT_TRUE : VARIANT_FALSE );
       
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnButtonMuteSpeaker - error <%x> when calling put_AudioMuted", this, hr));
    }
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnButtonMuteSpeaker - exit", this));

    return 0;
}

// OnButtonMuteMicro
// Processes BN_CLICK

LRESULT CRTCCtl::OnButtonMuteMicro(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{  
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnButtonMuteMicro - enter", this));

    HRESULT hr;

    long lState = (long)m_hMicroMuteButton.SendMessage(BM_GETCHECK, 0, 0);

    // the button is actually the opposite of "mute"
    // so set the opposite of the opposite
    hr = m_pRTCClient->put_AudioMuted( RTCAD_MICROPHONE, (!(lState == BST_UNCHECKED)) ? VARIANT_TRUE : VARIANT_FALSE );
       
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnButtonMuteMicro - error <%x> when calling put_AudioMuted", this, hr));
    }
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnButtonMuteMicro - exit", this));

    return 0;
}

// OnButtonRecvVideo
// Processes BN_CLICK

LRESULT CRTCCtl::OnButtonRecvVideo(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{  
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnButtonRecvVideo - enter", this));

    HRESULT hr;

    long lState = (long)m_hReceivePreferredButton.SendMessage(BM_GETCHECK, 0, 0);

    // calculate the new preference
    long    lNewMediaPreferences = m_lMediaPreferences;    

    lNewMediaPreferences &= ~RTCMT_VIDEO_RECEIVE;
    // the opposite
    lNewMediaPreferences |= (lState == BST_UNCHECKED ? RTCMT_VIDEO_RECEIVE : 0);

    // call the internal function, which also updates the button
    // the change is persistent or volatle depending on 
    // the model (standalone or webcrm)
    hr = put_MediaPreferences( lNewMediaPreferences );
       
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnButtonRecvVideo - error <%x> when calling put_MediaPreference", this, hr));
    }
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnButtonRecvVideo - exit", this));

    return 0;
}

// OnButtonSendVideo
// Processes BN_CLICK

LRESULT CRTCCtl::OnButtonSendVideo(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{  
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnButtonSendVideo - enter", this));

    HRESULT hr;

    long lState = (long)m_hSendPreferredButton.SendMessage(BM_GETCHECK, 0, 0);

    // calculate the new preference
    long    lNewMediaPreferences = m_lMediaPreferences;    

    lNewMediaPreferences &= ~RTCMT_VIDEO_SEND;
    // the opposite
    lNewMediaPreferences |= (lState == BST_UNCHECKED ? RTCMT_VIDEO_SEND : 0);

    // call the internal function, which also updates the button
    // the change is persistent or volatle depending on 
    // the model (standalone or webcrm)
    hr = put_MediaPreferences( lNewMediaPreferences );
       
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnButtonSendVideo - error <%x> when calling put_MediaPreference", this, hr));
    }
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnButtonSendVideo - exit", this));

    return 0;
}




// OnDialButton
//  Processes dialpad buttons
//

LRESULT CRTCCtl::OnDialButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnDialButton - enter", this));

    // What a hack... When using accelerators, TranslateAccelerator puts 1
    // in the hiword of wParam, which is the notify code. Just like that.
    // Wonder what would happen if BN_PAINT (==1) was sent
    if(wNotifyCode==BN_CLICKED || wNotifyCode == 1)
    {
        ATLASSERT(m_pRRTCClient.p);

        WORD wButton = wID - IDC_DIAL_0;

        if(wButton < NR_DTMF_BUTTONS)
        {

            if(wNotifyCode == 1)
            {
                // Do visual feedback
                m_hDtmfButtons[wButton].SendMessage(BM_SETSTATE, (WPARAM)TRUE);
                
                // Set a timer for depressing the key
                // 
                if (0 == SetTimer(wButton + 1, 150))
                {
                    LOG((RTC_ERROR, "[%p] CRTCCtl::OnDialButton - failed to create a timer", this));

                    // revert the button if SetTimer has failed
                    m_hDtmfButtons[wButton].SendMessage(BM_SETSTATE, (WPARAM)FALSE);
                }
            }
            
            // Call in the core
            //
            hr = m_pRTCClient->SendDTMF((RTC_DTMF)wButton);
            if(FAILED(hr))
            {
                LOG((RTC_ERROR, "[%p] CRTCCtl::OnDialButton - error <%x> when calling SendDTMF", this, hr));
            }
        }
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::OnDialButton - exit", this));

    return 0;
}

// OnDialogColor
//  Returns the brush to be used for background

LRESULT CRTCCtl::OnDialogColor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HDC         dc = (HDC) wParam;
    LOGBRUSH    lb;

    HBRUSH  hBrush;

    // the video windows have a different brush
    if((HWND)lParam == (HWND)m_hReceiveWindow ||
       (HWND)lParam == (HWND)m_hPreviewWindow)
    {
        hBrush = m_hVideoBrush;
    }
    else
    {
        hBrush = m_hBckBrush;
    }


    ::GetObject(hBrush, sizeof(lb), (void*)&lb);
    ::SetBkColor(dc, lb.lbColor);
    //::SetBkMode(dc, TRANSPARENT);
    
    return (LRESULT)hBrush;
}

// OnDrawItem
//  

LRESULT CRTCCtl::OnDrawItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT)lParam;

    if (wParam != 0)
    {
        //
        // This was sent by a control
        // 

        if (lpdis->CtlType == ODT_BUTTON)
        {
            CButton::OnDrawItem(lpdis, m_hPalette, m_bBackgroundPalette);
        }
    }

    return 0;
}

// OnEraseBackground
//  Paints the background

LRESULT CRTCCtl::OnEraseBackground(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HDC         dc = (HDC) wParam;

    HBITMAP     hbmOldBitmap = NULL;
    HDC         hdcCompatible = NULL;

    if (!m_hbmBackground)
    {
        // hmm, no bitmap... Fallback

        bHandled = FALSE;

        return 0;
    }

    if (m_hPalette)
    {
        SelectPalette(dc, m_hPalette, m_bBackgroundPalette);
        RealizePalette(dc);
    }

    // create a compatible DC
    //
    hdcCompatible = CreateCompatibleDC(dc);
    if (!hdcCompatible)
    {
        // hmm, cannot create DC... Fallback

        bHandled = FALSE;

        return 0;
    }

    // select the bitmap in the context
    //
    hbmOldBitmap = (HBITMAP)SelectObject(
        hdcCompatible,
        m_hbmBackground);


    // copy the bits..
    //
    RECT    destRect;

    GetClientRect(&destRect);

    BitBlt(
        dc,
        destRect.left,
        destRect.top,
        destRect.right,
        destRect.bottom,
        hdcCompatible,
        0,
        0,
        SRCCOPY);

    // Cleanup
    //
    if (hbmOldBitmap)
    {
        SelectObject(hdcCompatible, hbmOldBitmap);
    }

    DeleteDC(hdcCompatible);

    return 1;
}


// OnTimer
//  Depresses a dialpad or toolbar button

LRESULT CRTCCtl::OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if(wParam > 0  && wParam <= NR_DTMF_BUTTONS)
    {
        // depress the button
        m_hDtmfButtons[wParam-1].SendMessage(BM_SETSTATE, (WPARAM)FALSE);
        
    }
    else if (wParam == IDC_BUTTON_CALL ||  wParam == IDC_BUTTON_HUP)
    {
        LRESULT     lState;

        //
        // Get current state of the tool button
        //  The button id is equal to the timer id

        lState = m_hCtlToolbar.SendMessage(TB_GETSTATE, wParam);

        if(lState != -1)
        {
            // Mask the "pressed" attribute
            // I hope I don't interfere with any action the user might take

            m_hCtlToolbar.SendMessage(TB_SETSTATE, wParam, (LPARAM)(lState & ~TBSTATE_PRESSED));

            if(lState & TBSTATE_ENABLED)
            {
                //
                // Call recursively
                //
    
                SendMessage(
                    WM_COMMAND,
                    MAKEWPARAM(wParam, BN_CLICKED),
                    NULL);
            }
            
        }
    }
    
    // kill the timer...
    KillTimer((UINT)wParam);

    return 0;
}

// OnGetDispInfo
//  Retrieves text for tooltips
//
LRESULT CRTCCtl::OnGetDispInfo(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    LPTOOLTIPTEXT   lpttt; 
    UINT            idButton;
 
    lpttt = (LPTOOLTIPTEXT) pnmh; 
    
    // module instance for resources
    lpttt->hinst = _Module.GetResourceInstance(); 
 
    if( lpttt->uFlags & TTF_IDISHWND )
    {
        // idFrom is actually the HWND of the tool
        idButton = ::GetDlgCtrlID((HWND)lpttt->hdr.idFrom);
    }
    else
    {
        // idFrom is the id of the button
        idButton = (UINT)(lpttt->hdr.idFrom); 
    }

    // string resource for the given button
    switch (idButton) 
    { 
    case IDC_BUTTON_CALL: 
        lpttt->lpszText = MAKEINTRESOURCE(IDS_TIPS_CALL); 
        break; 
    
    case IDC_BUTTON_HUP: 
        lpttt->lpszText = MAKEINTRESOURCE(IDS_TIPS_HANGUP); 
        break;
   }
    
    // we don't want to be asked again..
    lpttt->uFlags |= TTF_DI_SETITEM;

    return 0;
}


//
// Internal functions
//

// PreTranslateAccelerator
//      Translates the accelerators
//      This overrides the implementation from CComCompositeControl in order to
//  enable dialpad acces through the numeric keys
//
BOOL CRTCCtl::PreTranslateAccelerator(LPMSG pMsg, HRESULT& hRet)
{
    // is the dialpad visible and enabled ?
    if(m_ZoneStateArray[AXCTL_ZONE_DIALPAD].bShown && 
       m_nControlState == RTCAX_STATE_CONNECTED &&
       m_hAcceleratorDialpad)
    {
        if(::TranslateAccelerator(m_hWnd, m_hAcceleratorDialpad, pMsg))
        {
            // translated, return
            hRet = S_OK;
            return TRUE;
        }
    }

    // is the toolbar is enabled..
    if(m_ZoneStateArray[AXCTL_ZONE_TOOLBAR].bShown && 
       m_hAcceleratorToolbar)
    {
        if(::TranslateAccelerator(m_hWnd, m_hAcceleratorToolbar, pMsg))
        {
            // translated, return
            hRet = S_OK;
            return TRUE;
        }
    }


    // Pass it down in the chain
    return CComCompositeControl<CRTCCtl>::PreTranslateAccelerator(pMsg, hRet);
}


// CreateToolbarControl
//      Creates the toolbar control
// 

#define     RTCCTL_BITMAP_CX    19
#define     RTCCTL_BITMAP_CY    19

HRESULT CRTCCtl::CreateToolbarControl(CWindow *phToolbar)
{
    HRESULT     hr;
    HWND        hToolbar;
    HBITMAP     hBitmap = NULL;
    TBBUTTON    tbb[2];
    int         iCall, iHup;
    TCHAR       szBuf[MAX_STRING_LEN];


    // Create the "normal" image list
    m_hNormalImageList = ImageList_Create(RTCCTL_BITMAP_CX, RTCCTL_BITMAP_CY, ILC_COLOR | ILC_MASK , 5, 5);
    if(m_hNormalImageList)
    {
        // Open a bitmap
        hBitmap = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_TOOLBAR_NORMAL));
        if(hBitmap)
        {
            // Add the bitmap to the image list
            ImageList_AddMasked(m_hNormalImageList, hBitmap, BMP_COLOR_MASK);

            DeleteObject(hBitmap);
            hBitmap = NULL;
        }
    }
    
    // Create the "disabled" image list
    m_hDisabledImageList = ImageList_Create(RTCCTL_BITMAP_CX, RTCCTL_BITMAP_CY, ILC_COLOR | ILC_MASK , 5, 5);
    if(m_hDisabledImageList)
    {
        // Open a bitmap
        hBitmap = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_TOOLBAR_DISABLED));
        if(hBitmap)
        {
            // Add the bitmap to the image list
            ImageList_AddMasked(m_hDisabledImageList, hBitmap, BMP_COLOR_MASK);

            DeleteObject(hBitmap);
            hBitmap = NULL;
        }
    }
    
    // Create the "hot" image list
    m_hHotImageList = ImageList_Create(RTCCTL_BITMAP_CX, RTCCTL_BITMAP_CY, ILC_COLOR | ILC_MASK , 5, 5);
    if(m_hHotImageList)
    {
        // Open a bitmap
        hBitmap = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_TOOLBAR_HOT));
        if(hBitmap)
        {
            // Add the bitmap to the image list
            ImageList_AddMasked(m_hHotImageList, hBitmap, BMP_COLOR_MASK);

            DeleteObject(hBitmap);
            hBitmap = NULL;
        }
    }

    // Create the toolbar
    hToolbar = CreateWindowEx(
        0, 
        TOOLBARCLASSNAME, 
        (LPTSTR) NULL,
        WS_CHILD | WS_VISIBLE | TBSTYLE_LIST | TBSTYLE_FLAT | TBSTYLE_TOOLTIPS, 
        3, 
        0, 
        0, 
        0, 
        m_hWnd, 
        (HMENU) IDC_TOOLBAR, 
        _Module.GetResourceInstance(), 
        NULL); 

    if(hToolbar!=NULL)
    {
        // backward compatibility
        SendMessage(hToolbar, TB_BUTTONSTRUCTSIZE, (WPARAM) sizeof(TBBUTTON), 0);
        
        // Set the image lists
        SendMessage(hToolbar, TB_SETIMAGELIST, 0, (LPARAM)m_hNormalImageList); 
        SendMessage(hToolbar, TB_SETHOTIMAGELIST, 0, (LPARAM)m_hHotImageList); 
        SendMessage(hToolbar, TB_SETDISABLEDIMAGELIST, 0, (LPARAM)m_hDisabledImageList); 

        // Load text strings for buttons
        // Call button
        szBuf[0] = _T('\0');
        LoadString(_Module.GetResourceInstance(), IDS_BUTTON_CALL, szBuf, MAX_STRING_LEN-1); 
        // Save room for second null terminator.
        szBuf[ocslen(szBuf) + 1] = 0;  //Double-null terminate. 
        // add the string to the toolbar
        iCall = (UINT)SendMessage(hToolbar, TB_ADDSTRING, 0, (LPARAM) szBuf);
        
        // HangUp button
        szBuf[0] = _T('\0');
        LoadString(_Module.GetResourceInstance(), IDS_BUTTON_HANGUP, szBuf, MAX_STRING_LEN-1); 
        // Save room for second null terminator.
        szBuf[ocslen(szBuf) + 1] = 0;  //Double-null terminate. 
        // add the string to the toolbar
        iHup = (UINT)SendMessage(hToolbar, TB_ADDSTRING, 0, (LPARAM) szBuf);

        // Prepare the button structs
        tbb[0].iBitmap = m_nPropCallScenario == RTC_CALL_SCENARIO_PCTOPC ?
            ILI_TB_CALLPC :  ILI_TB_CALLPHONE;
        tbb[0].iString = iCall;
        tbb[0].dwData = 0;
        tbb[0].fsStyle = BTNS_BUTTON;
        tbb[0].fsState = 0;
        tbb[0].idCommand = IDC_BUTTON_CALL;

        tbb[1].iBitmap = ILI_TB_HANGUP;
        tbb[1].iString = iHup;
        tbb[1].dwData = 0;
        tbb[1].fsStyle = BTNS_BUTTON;
        tbb[1].fsState = 0;
        tbb[1].idCommand = IDC_BUTTON_HUP;

        // Add the buttons to the toolbar
        SendMessage(hToolbar, TB_ADDBUTTONS, sizeof(tbb)/sizeof(tbb[0]), 
            (LPARAM) (LPTBBUTTON) &tbb); 
 
        // Autosize the generated toolbar
        SendMessage(hToolbar, TB_AUTOSIZE, 0, 0); 

        // Attach to the wrapper
        phToolbar->Attach(hToolbar);

        hr = S_OK;
    }
    else
    {
        LOG((RTC_ERROR, "CRTCCtl::CreateToolbarControl - error (%x) when trying to create the toolbar", GetLastError()));

        if(m_hNormalImageList)
        {
            ImageList_Destroy(m_hNormalImageList);
            m_hNormalImageList = NULL;
        }
        if(m_hHotImageList)
        {
            ImageList_Destroy(m_hHotImageList);
            m_hHotImageList = NULL;
        }
        if(m_hDisabledImageList)
        {
            ImageList_Destroy(m_hDisabledImageList);
            m_hDisabledImageList = NULL;
        }

        hr = E_FAIL;
    }

    return hr;
}

// DestroyToolbarControl
//      Destroys the toolbar control and the associated image lists.
// 

void CRTCCtl::DestroyToolbarControl(CWindow *phToolbar)
{
    
    HWND    hToolbar = phToolbar->Detach();

    if(hToolbar)
    {
        ::DestroyWindow(hToolbar);
    }
    
    if(m_hNormalImageList)
    {
        ImageList_Destroy(m_hNormalImageList);
        m_hNormalImageList = NULL;
    }
    
    if(m_hHotImageList)
    {
        ImageList_Destroy(m_hHotImageList);
        m_hHotImageList = NULL;
    }

    if(m_hDisabledImageList)
    {
        ImageList_Destroy(m_hDisabledImageList);
        m_hDisabledImageList = NULL;
    }
}

// CreateTooltips
//      Creates the tooltip window
// 


BOOL CRTCCtl::CreateTooltips()
{
    HWND hwndTT = CreateWindowEx(0, TOOLTIPS_CLASS, (LPTSTR) NULL,
        0, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
        CW_USEDEFAULT, m_hWnd, (HMENU) NULL, _Module.GetModuleInstance(), NULL);

    if (hwndTT == NULL)
        return FALSE;

    m_hTooltip.Attach(hwndTT);

    return TRUE;
}


// PlaceWindowsAtTheirInitialPosition
//      Positions and sizes all the controls to their "initial" position
//   It's needed because all further moving is done relatively. 
//  This function also establishes the right tab order

void CRTCCtl::PlaceWindowsAtTheirInitialPosition()
{
    HWND   hPrevious = NULL;

#define POSITION_WINDOW(m,x,y,cx,cy,f)                  \
    m.SetWindowPos(                                     \
        hPrevious,                                      \
        x,                                              \
        y,                                              \
        cx,                                             \
        cy,                                             \
        SWP_NOACTIVATE | f );                           \
    hPrevious = (HWND)m;       

    // toolbar control (no size/move)
    POSITION_WINDOW(m_hCtlToolbar, 
        CTLPOS_X_RECEIVEWIN, CTLPOS_Y_RECEIVEWIN, 
        0, 0,
        SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER);


    // this window resizes itself in AdjustVideoWindows
    POSITION_WINDOW(m_hReceiveWindow, 
        CTLPOS_X_RECEIVEWIN, CTLPOS_Y_RECEIVEWIN, 
        0, 0,
        SWP_NOSIZE);

    // This window is moved and resized in AdjustVideoWindows
    POSITION_WINDOW(m_hPreviewWindow, 
        0, 0, 
        0, 0,
        SWP_NOSIZE | SWP_NOMOVE);

    // dtmf buttons
    CWindow *pDtmfCrt = m_hDtmfButtons;
    CWindow *pDtmfEnd = m_hDtmfButtons + NR_DTMF_BUTTONS;

    for (int id = IDC_DIAL_0; pDtmfCrt<pDtmfEnd; pDtmfCrt++, id++)
    {
        POSITION_WINDOW((*pDtmfCrt), 
            CTLPOS_X_DIALPAD + ((id - IDC_DIAL_0) % 3) * (CX_DIALPAD_BUTTON + CTLPOS_DX_DIALPAD),
            CTLPOS_Y_DIALPAD + ((id - IDC_DIAL_0) / 3) * (CY_DIALPAD_BUTTON + CTLPOS_DY_DIALPAD), 
            CX_DIALPAD_BUTTON, CY_DIALPAD_BUTTON,
            0);
    }


    POSITION_WINDOW(m_hReceivePreferredButton, 
        CTLPOS_X_RECV_VIDEO, CTLPOS_Y_RECV_VIDEO, 
        CX_CHECKBOX_BUTTON, CY_CHECKBOX_BUTTON,
        0);
    
    POSITION_WINDOW(m_hSendPreferredButton, 
        CTLPOS_X_SEND_VIDEO, CTLPOS_Y_SEND_VIDEO, 
        CX_CHECKBOX_BUTTON, CY_CHECKBOX_BUTTON,
        0);

    POSITION_WINDOW(m_hSpeakerMuteButton, 
        CTLPOS_X_RECV_AUDIO_MUTE, CTLPOS_Y_RECV_AUDIO_MUTE, 
        CX_CHECKBOX_BUTTON, CY_CHECKBOX_BUTTON,
        0);
    
    POSITION_WINDOW(m_hMicroMuteButton, 
        CTLPOS_X_SEND_AUDIO_MUTE, CTLPOS_Y_SEND_AUDIO_MUTE, 
        CX_CHECKBOX_BUTTON, CY_CHECKBOX_BUTTON,
        0);
    
    // all the static texts (doesn't really matter)

    POSITION_WINDOW(m_hReceivePreferredText, 
        CTLPOS_X_RECV_VIDEO_TEXT, CTLPOS_Y_RECV_VIDEO_TEXT, 
        CX_GENERIC_TEXT, CY_GENERIC_TEXT,
        0);
    
    POSITION_WINDOW(m_hSendPreferredText, 
        CTLPOS_X_SEND_VIDEO_TEXT, CTLPOS_Y_SEND_VIDEO_TEXT, 
        CX_GENERIC_TEXT, CY_GENERIC_TEXT,
        0);
    
    POSITION_WINDOW(m_hSpeakerMuteText, 
        CTLPOS_X_RECV_AUDIO_MUTE_TEXT, CTLPOS_Y_RECV_AUDIO_MUTE_TEXT, 
        CX_GENERIC_TEXT, CY_GENERIC_TEXT,
        0);
    
    POSITION_WINDOW(m_hMicroMuteText, 
        CTLPOS_X_SEND_AUDIO_MUTE_TEXT, CTLPOS_Y_SEND_AUDIO_MUTE_TEXT, 
        CX_GENERIC_TEXT, CY_GENERIC_TEXT,
        0);

    POSITION_WINDOW(m_hReceiveText, 
        CTLPOS_X_RECV_TEXT, CTLPOS_Y_RECV_TEXT, 
        CX_SENDRECV_TEXT, CY_SENDRECV_TEXT,
        0);

    POSITION_WINDOW(m_hSendText, 
        CTLPOS_X_SEND_TEXT, CTLPOS_Y_SEND_TEXT, 
        CX_SENDRECV_TEXT, CY_SENDRECV_TEXT,
        0);

    // The volume knobs resize themselves
    //
    POSITION_WINDOW(m_hSpeakerKnob, 
        CTLPOS_X_SPKVOL, CTLPOS_Y_SPKVOL, 
        0, 0,
        SWP_NOSIZE);

    POSITION_WINDOW(m_hMicroKnob, 
        CTLPOS_X_MICVOL, CTLPOS_Y_MICVOL, 
        0, 0,
        SWP_NOSIZE);
    
    // Participant list
    POSITION_WINDOW(m_hParticipantList, 
        CTLPOS_X_PARTLIST, CTLPOS_Y_PARTLIST, 
        CX_PARTLIST, 
        m_nCtlMode == CTL_MODE_HOSTED ? CY_PARTLIST_WEBCRM : CY_PARTLIST_STANDALONE,
        0);
    
    // Add/remove participant buttons
    POSITION_WINDOW(m_hAddParticipant, 
        CTLPOS_X_ADDPART, CTLPOS_Y_ADDPART, 
        CX_PARTICIPANT_BUTTON, CY_PARTICIPANT_BUTTON,
        0);
    
    POSITION_WINDOW(m_hRemParticipant, 
        CTLPOS_X_REMPART, CTLPOS_Y_REMPART, 
        CX_PARTICIPANT_BUTTON, CY_PARTICIPANT_BUTTON,
        0);

    // status bar, no size/move
    POSITION_WINDOW(m_hStatusBar, 
        CTLPOS_X_MICVOL, CTLPOS_Y_MICVOL, 
        0, 0,
        SWP_NOSIZE | SWP_NOMOVE);

#undef POSITION_WINDOW

}


// MoveWindowVertically
//      moves one control
// 
void CRTCCtl::MoveWindowVertically(CWindow *pWindow, LONG Offset)
{
    RECT     Rect;

    pWindow->GetWindowRect(&Rect);

    ::MapWindowPoints( NULL, m_hWnd, (LPPOINT)&Rect, 2 );

    pWindow->MoveWindow(Rect.left, Rect.top + Offset, Rect.right - Rect.left, Rect.bottom - Rect.top,  TRUE);
}

// PlaceAndEnableDisableZone
//      moves and enables/disables a zone according to the layout
//  specified in *pNewState 
//
void CRTCCtl::PlaceAndEnableDisableZone(int iZone, CZoneState *pNewState)
{
    LONG    lOffset;
    BOOL    bVisibilityChanged;
    BOOL    bShown;
    
    CWindow *pDtmfCrt;
    CWindow *pDtmfEnd;
    int     id;
    
    // try to minimize the flickering by
    // updating only the controls that change state

    bShown = pNewState->bShown;



    lOffset = (LONG)(pNewState->iBase - m_ZoneStateArray[iZone].iBase);

    bVisibilityChanged = (m_ZoneStateArray[iZone].bShown && !bShown) ||
                         (!m_ZoneStateArray[iZone].bShown && bShown);

    if(lOffset!=0)
    {
        switch(iZone)
        {
        case AXCTL_ZONE_TOOLBAR:
            MoveWindowVertically(&m_hCtlToolbar, lOffset);
            break; 

        case AXCTL_ZONE_LOGOVIDEO:
            MoveWindowVertically(&m_hReceiveWindow, lOffset);
            MoveWindowVertically(&m_hPreviewWindow, lOffset);
            MoveWindowVertically(&m_hReceivePreferredButton, lOffset);
            MoveWindowVertically(&m_hSendPreferredButton, lOffset);
            //MoveWindowVertically(&m_hPreviewPreferredButton, lOffset);
            MoveWindowVertically(&m_hReceivePreferredText, lOffset);
            MoveWindowVertically(&m_hSendPreferredText, lOffset);
            //MoveWindowVertically(&m_hPreviewPreferredText, lOffset);        
            break;

        case AXCTL_ZONE_DIALPAD:
            pDtmfCrt = m_hDtmfButtons;
            pDtmfEnd = m_hDtmfButtons + NR_DTMF_BUTTONS;

            for (id = IDC_DIAL_0; pDtmfCrt<pDtmfEnd; pDtmfCrt++, id++)
                MoveWindowVertically(pDtmfCrt, lOffset);

            break;

        case AXCTL_ZONE_AUDIO:
            MoveWindowVertically(&m_hSpeakerKnob, lOffset);
            MoveWindowVertically(&m_hSpeakerMuteButton, lOffset);
            MoveWindowVertically(&m_hSpeakerMuteText, lOffset);
    
            MoveWindowVertically(&m_hMicroKnob, lOffset);
            MoveWindowVertically(&m_hMicroMuteButton, lOffset);
            MoveWindowVertically(&m_hMicroMuteText, lOffset);

            MoveWindowVertically(&m_hReceiveText, lOffset);
            MoveWindowVertically(&m_hSendText, lOffset);
            break;

        case AXCTL_ZONE_PARTICIPANTS:
            MoveWindowVertically(&m_hParticipantList, lOffset);
            MoveWindowVertically(&m_hAddParticipant, lOffset);
            MoveWindowVertically(&m_hRemParticipant, lOffset);
            break;

        case AXCTL_ZONE_STATUS:
            // The status bar moves automatically
            break;
        }
    }
    if(bVisibilityChanged)
    {
        int iShow = bShown ? SW_SHOW : SW_HIDE;

        switch(iZone)
        {
        case AXCTL_ZONE_TOOLBAR:
            m_hCtlToolbar.ShowWindow(iShow);
            break; 

        case AXCTL_ZONE_LOGOVIDEO:
            m_hReceiveWindow.ShowWindow(iShow);
            
            // preview window is processed by ShowHidePreviewWindow
            
            // so the window is displayed when
            //      the logovideo zone is displayed
            //  and the video sending is active
            //  and the preview preference is set
 
            ShowHidePreviewWindow(
                bShown 
             && m_bPreviewWindowActive 
             && m_bPreviewWindowIsPreferred);

            m_hReceivePreferredButton.ShowWindow(iShow);
            m_hSendPreferredButton.ShowWindow(iShow);
            //m_hPreviewPreferredButton.ShowWindow(iShow);

            m_hReceivePreferredText.ShowWindow(iShow);
            m_hSendPreferredText.ShowWindow(iShow);
            //m_hPreviewPreferredText.ShowWindow(iShow);

            break;

        case AXCTL_ZONE_DIALPAD:
            pDtmfCrt = m_hDtmfButtons;
            pDtmfEnd = m_hDtmfButtons + NR_DTMF_BUTTONS;

            for (id = IDC_DIAL_0; pDtmfCrt<pDtmfEnd; pDtmfCrt++, id++)
                pDtmfCrt->ShowWindow(iShow);

            break;

        case AXCTL_ZONE_AUDIO:
            m_hSpeakerKnob.ShowWindow(iShow);
            m_hSpeakerMuteButton.ShowWindow(iShow);
            m_hSpeakerMuteText.ShowWindow(iShow);

            m_hMicroKnob.ShowWindow(iShow);
            m_hMicroMuteButton.ShowWindow(iShow);
            m_hMicroMuteText.ShowWindow(iShow);

            m_hReceiveText.ShowWindow(iShow);
            m_hSendText.ShowWindow(iShow);

            break;

        case AXCTL_ZONE_PARTICIPANTS:
            m_hParticipantList.ShowWindow(iShow);
            m_hParticipantList.EnableWindow(bShown);

            // don't enable/disable these here
            m_hAddParticipant.ShowWindow(iShow);
            m_hRemParticipant.ShowWindow(iShow);

            break;

        case AXCTL_ZONE_STATUS:
            m_hStatusBar.ShowWindow(iShow);
            break;
        }
    }
    
    // Save the new state
    m_ZoneStateArray[iZone] = *pNewState;
}

// AdjustVideoFrames
//  For the receive window, keep the top left position fixed, adjust the size
//  of the client area to match a QCIF video size
//  Similar for the preview window, with the difference that the size is
//  QQCIF and the window is aligned with the receive window
//

void  CRTCCtl::AdjustVideoFrames()
{
    // adjust the client rect size of the receive window
    AdjustVideoFrame(&m_hReceiveWindow, QCIF_CX_SIZE, QCIF_CY_SIZE);

    // adjust the client rect size of the preview window
    AdjustVideoFrame(&m_hPreviewWindow, QQCIF_CX_SIZE, QQCIF_CY_SIZE);

    // Align the preview window
    // The entire preview window (client and non client) must be in the client 
    // area of the receive window
    //
    RECT    rectRecvClnt;
    RECT    rectPrev;
    
    // Client area of the receive window
    m_hReceiveWindow.GetClientRect(&rectRecvClnt);

    // get the current position of the preview window
    m_hPreviewWindow.GetWindowRect(&rectPrev);
    ::MapWindowPoints( NULL, m_hWnd, (LPPOINT)&rectPrev, 2 );
    
    // Map the window in the client area of the receive window
    // XXX Mirroring ?
    POINT   pt;

    pt.x = rectRecvClnt.right - (rectPrev.right - rectPrev.left);
    pt.y = rectRecvClnt.bottom - (rectPrev.bottom - rectPrev.top);

    // convert to dlg client the top left corner
    m_hReceiveWindow.MapWindowPoints(m_hWnd, &pt, 1);
    
    // size is unchanged
    rectPrev.right = rectPrev.right - rectPrev.left;
    rectPrev.bottom = rectPrev.bottom - rectPrev.top;

    // top left corner is moved
    rectPrev.left = pt.x;
    rectPrev.top = pt.y;


    // move the window
    m_hPreviewWindow.MoveWindow(
        rectPrev.left,
        rectPrev.top,
        rectPrev.right,
        rectPrev.bottom,
        TRUE);
}

// AdjustVideoFrame
//
void  CRTCCtl::AdjustVideoFrame(CWindow *pWindow, int iCx, int iCy)
{
    WINDOWINFO  wi;
    
    // 
    wi.cbSize = sizeof(WINDOWINFO);

    // get window info
    GetWindowInfo(*pWindow, &wi);

    // don't use the cxyborders members
    // use diff between client area and window area

    int iDiffX;
    int iDiffY;
    
    iDiffX = iCx - (wi.rcClient.right - wi.rcClient.left);
    iDiffY = iCy - (wi.rcClient.bottom - wi.rcClient.top);

    // the window rect is in screen coords, convert in client
    ::MapWindowPoints( NULL, m_hWnd, (LPPOINT)&wi.rcWindow, 2 );

    // compute the bottom/right
    wi.rcWindow.bottom += iDiffY;
    wi.rcWindow.right += iDiffX;

    // adjust the size
    pWindow->MoveWindow(&wi.rcWindow, TRUE);
}


     
// SetControlState
//  Sets a new UI state
//  
//      NewState    -   control UI state
//      Status code -   SIP status code, may be taken into account 
//      Result      -   API error code, may be taken into account
//      nID         -   Resource ID for a string, overrides the previous params
//


void CRTCCtl::SetControlState(
    RTCAX_STATE NewState, 
    HRESULT StatusCode,
    UINT nID)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::SetControlState <%d> - enter", this, NewState));
    
    /////////////////////
    //
    //  Processing redirects
    //  If m_bRedirecting is TRUE, set the state recursively to DIALING and places the next call
    //
    ///////////////////
    
    if(m_bRedirecting)
    {
        HRESULT hr, hrCall;

        LOG((RTC_INFO, "[%p] CRTCCtl::SetControlState: redirecting...", this));

        switch(NewState)
        {
        case RTCAX_STATE_IDLE:
            // set recursively the state to Dialing
            SetControlState(RTCAX_STATE_DIALING);

            // try to place a new call
            hrCall = S_OK;

            hr = RedirectedCall(&hrCall);

            if (hr == S_OK)
            {
                // call placed successfully, return
                LOG((RTC_TRACE, "[%p] CRTCCtl::SetControlState <%d> - shortcut exit", this, NewState));

                return;
            }
            else if (hr == S_FALSE)
            {
                // this is end of the list
                // if hrCall != success, use it for the error message box 
                // that will be displayed
                // else, use the params
                if ( FAILED(hrCall) )
                {
                    StatusCode = hrCall;
                }
            }
            else if (hr == E_ABORT)
            {
                // clear any params, the user aborted the call
                hr = S_OK;
                StatusCode = 0;
            }
            else
            {
                // other unrecoverable error
                StatusCode = hr;
            }

            m_bRedirecting = FALSE;
            
            break;
        
        case RTCAX_STATE_DIALING:   // do nothing, it's our recursive call
        case RTCAX_STATE_CONNECTING:    // do nothing, these are provisional responses

            break;

        case RTCAX_STATE_DISCONNECTING:  // the user hung up , so we have to stop..
        case RTCAX_STATE_CONNECTED:     // or the call succeeded

            m_bRedirecting = FALSE;

            break;
        
        default:        // errors
            
            LOG((RTC_ERROR, "[%p] CRTCCtl::SetControlState - "
                "invalid state (%d) during redirection", this, NewState));

            m_bRedirecting = FALSE;

            break;
        }

    }

    
    //////////////////////
    //  
    //  Adjust the state to UI_BUSY if a dialog box must be displayed
    //  Calls itself recursively 
    //
    //////////////////////

    if(NewState == RTCAX_STATE_IDLE
        && FAILED(StatusCode) )
    {

        // prepare the error strings
        HRESULT     hr;
        RTCAX_ERROR_INFO    ErrorInfo;

        ZeroMemory(&ErrorInfo, sizeof(ErrorInfo));

        hr = PrepareErrorStrings(
            m_bOutgoingCall,
            StatusCode,
            (LPWSTR)m_bstrOutAddress,
            &ErrorInfo);
       
        if(SUCCEEDED(hr))
        {

            //
            // Create the dialog box
            //
            CErrorMessageLiteDlg *pErrorDlgLite =
                new CErrorMessageLiteDlg;

            if(pErrorDlgLite)
            {

                // Set the state to UI_BUSY using a recursive call
                //

                SetControlState(
                    RTCAX_STATE_UI_BUSY,
                    StatusCode,
                    nID);

                //
                //  Call the modal dialog box
                //
                
                pErrorDlgLite->DoModal(m_hWnd, (LPARAM)&ErrorInfo);

                delete pErrorDlgLite;
            }
            else
            {
                LOG((RTC_ERROR, "[%p] CRTCCtl::SetControlState; OOM", this));
            }
        }
        
        FreeErrorStrings(&ErrorInfo);

        // Continue 
    }

    /////
    // We cannot set the state to idle when AddParticipant dialog box is active
    //
    if(NewState == RTCAX_STATE_IDLE && m_bAddPartDlgIsActive)
    {
        // set to busy. The state will be set back to idle when
        // the AddPart dialog box is dismissed
        NewState = RTCAX_STATE_UI_BUSY;
    }

    //////////////////////
    //  
    //  Set the new state
    //
    //////////////////////
    
    BOOL    bStateChanged = (m_nControlState != NewState);

    // This is the new current state
    m_nControlState = NewState;

    // This is needed when displaying error messages
    if(m_nControlState == RTCAX_STATE_DIALING)
    {
        m_bOutgoingCall = TRUE;
    }
    else if (m_nControlState == RTCAX_STATE_IDLE)
    {
        m_bOutgoingCall = FALSE;
    }

    //////////////////////
    //  
    //  Change layout
    //
    //
    //////////////////////

    if(bStateChanged)
    {
        // Change the visuals (in standalone mode)
        if(m_nCtlMode == CTL_MODE_STANDALONE)
        {
            if(m_nControlState == RTCAX_STATE_CONNECTING)
            {
                // display the right layout
                switch(m_nCachedCallScenario)
                {
                case RTC_CALL_SCENARIO_PCTOPC:
                    SetZoneLayout(&s_DefaultZoneLayout, FALSE);
                    break;

                case RTC_CALL_SCENARIO_PCTOPHONE:
                    SetZoneLayout(&s_PCToPhoneZoneLayout, FALSE);
                    break;

                case RTC_CALL_SCENARIO_PHONETOPHONE:
                    SetZoneLayout(&s_PhoneToPhoneZoneLayout, FALSE);
                    break;
                }
            }
            else if(m_nControlState == RTCAX_STATE_IDLE)
            {
                SetZoneLayout(&s_DefaultZoneLayout, FALSE);
            }
        }
    }

    //////////////////////
    //  
    //  Determine the text in the status bar
    //
    //
    //////////////////////
    
    //  nID overrides everything
    //
    if(nID == 0)
    {
        // for IDLE or UI_BUSY state, any Result != S_OK
        // or StatusCode != 0 must set the status bar to error
        // 
        // 

        if(m_nControlState == RTCAX_STATE_IDLE ||
           m_nControlState == RTCAX_STATE_UI_BUSY )
        {
            if( FAILED(StatusCode) )
            {
                nID = IDS_SB_STATUS_IDLE_FAILED;
            }
        }
        
        // for CONNECTING process some of the provisional responses
        //

        else if ( (m_nControlState == RTCAX_STATE_CONNECTING) &&
                  (HRESULT_FACILITY(StatusCode) == FACILITY_SIP_STATUS_CODE) )
        {
            switch( HRESULT_CODE(StatusCode) )
            {
            case 180:
                nID = IDS_SB_STATUS_CONNECTING_RINGING;
                break;

            case 182:
                nID = IDS_SB_STATUS_CONNECTING_QUEUED;
                break;
            }
        }

        // if the status is CONNECTING or DIALING, we are in
        //  redirecting mode and no ID has been assigned, use a special text
        if(nID==0 &&
           m_bRedirecting && 
           (m_nControlState == RTCAX_STATE_CONNECTING 
           || m_nControlState == RTCAX_STATE_DIALING))
        {
            nID = IDS_SB_STATUS_REDIRECTING;
        }

        // nothing special, so use the defaults
        //

        if(nID == 0)
        {
            ATLASSERT(m_nControlState <= RTCAX_STATE_CONNECTING);
    
            nID = m_nControlState + IDS_SB_STATUS_NONE;
        }
    }

    // 
    // Set the status bar text (if active)
    
    if(m_ZoneStateArray[AXCTL_ZONE_STATUS].bShown)
    {
        TCHAR   szText[0x80];

        szText[0] = _T('\0');
        LoadString(
            _Module.GetResourceInstance(), 
            nID, 
            szText, 
            sizeof(szText)/sizeof(TCHAR));

        m_hStatusBar.SendMessage(SB_SETTEXT, SBP_STATUS, (LPARAM)szText);
    }

    //////////////////////
    //  
    //  Enable/disable the controls
    //
    //
    //////////////////////

    BOOL    bToolbarActive = m_ZoneStateArray[AXCTL_ZONE_TOOLBAR].bShown;

    if (m_nControlState == RTCAX_STATE_IDLE)
    {
        CWindow *pDtmfCrt = m_hDtmfButtons;
        CWindow *pDtmfEnd = m_hDtmfButtons + NR_DTMF_BUTTONS;

        for (int id = IDC_DIAL_0; pDtmfCrt<pDtmfEnd; pDtmfCrt++, id++)
             pDtmfCrt->EnableWindow(FALSE);
    }

    // enable/disable the toolbar buttons
    //
    BOOL bCallEnabled = bToolbarActive && m_nControlState == RTCAX_STATE_IDLE;
    BOOL bHupEnabled = bToolbarActive && 
                             (m_nControlState == RTCAX_STATE_CONNECTED ||
                              m_nControlState == RTCAX_STATE_CONNECTING ||
                              m_nControlState == RTCAX_STATE_ANSWERING);
    
    m_hCtlToolbar.SendMessage(TB_SETSTATE, IDC_BUTTON_CALL, 
            MAKELONG(bCallEnabled ? TBSTATE_ENABLED : TBSTATE_INDETERMINATE, 0L));
    m_hCtlToolbar.SendMessage(TB_SETSTATE, IDC_BUTTON_HUP, 
            MAKELONG(bHupEnabled ? TBSTATE_ENABLED : TBSTATE_INDETERMINATE, 0L));

    // Participant list buttons
    //
    // Add/Rem Participant are active in CONNECTED mode, standalone 
    // model, when PL is visible

    m_hAddParticipant.EnableWindow(ConfButtonsActive());
    UpdateRemovePartButton();
    
    // Disable everything if error
    if(m_nControlState == RTCAX_STATE_ERROR)
    {
        EnableWindow(FALSE);
    }

    //////////////////////
    //  
    //  Advertise to the frame 
    //
    //
    //////////////////////

    Fire_OnControlStateChange(m_nControlState, nID);

    LOG((RTC_TRACE, "[%p] CRTCCtl::SetControlState <%d> - exit", this, NewState));
}

// ConfButtonsActive
//  

BOOL CRTCCtl::ConfButtonsActive(void)
{
    return
        m_nControlState == RTCAX_STATE_CONNECTED &&
        m_nCtlMode == CTL_MODE_STANDALONE &&
        m_ZoneStateArray[AXCTL_ZONE_PARTICIPANTS].bShown;
}

// UpdateRemovePartButton
//  

void CRTCCtl::UpdateRemovePartButton(void)
{
    // refresh the Delete button state
    m_hRemParticipant.EnableWindow(ConfButtonsActive() && m_hParticipantList.CanDeleteSelected());
}

// RefreshAudioControls
//  Read current volume/mute settings and sets the window controls
//
HRESULT CRTCCtl::RefreshAudioControls(void)
{
    HRESULT         hr;
    VARIANT_BOOL    bMuted;
    long            lVolume;

    if(m_pRTCClient!=NULL)
    {
    
        // Speaker mute
        hr = m_pRTCClient -> get_AudioMuted(RTCAD_SPEAKER, &bMuted);

        if(SUCCEEDED(hr))
        {
            // the button is actually the opposite of "mute"
            m_hSpeakerMuteButton.SendMessage(BM_SETCHECK, bMuted ? BST_UNCHECKED : BST_CHECKED, 0);
        
            m_hSpeakerMuteButton.EnableWindow( TRUE );
        }
        else
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::RefreshAudioControls - error <%x> when calling get_AudioMuted", this, hr));

            m_hSpeakerMuteButton.EnableWindow( FALSE );
        }

        // Speaker volume
        hr = m_pRTCClient -> get_Volume(RTCAD_SPEAKER, &lVolume);
        if(SUCCEEDED(hr))
        {
            m_hSpeakerKnob.SendMessage(TBM_SETPOS, (WPARAM)TRUE, (LPARAM)lVolume);

            m_hSpeakerKnob.EnableWindow( TRUE );
        }
        else
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::RefreshAudioControls - error <%x> when calling get_Volume", this, hr));

            m_hSpeakerKnob.EnableWindow( FALSE );
        }


        // Microphone mute
        hr = m_pRTCClient -> get_AudioMuted(RTCAD_MICROPHONE, &bMuted);
        if(SUCCEEDED(hr))
        {
            // the button is actually the opposite of "mute"
            m_hMicroMuteButton.SendMessage(BM_SETCHECK, bMuted ? BST_UNCHECKED : BST_CHECKED, 0);
        
            m_hMicroMuteButton.EnableWindow( TRUE );
        }
        else
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::RefreshAudioControls - error <%x> when calling get_AudioMuted", this, hr));

            m_hMicroMuteButton.EnableWindow( FALSE );
        }

        // Microphone volume
        hr = m_pRTCClient -> get_Volume(RTCAD_MICROPHONE, &lVolume);
        if(SUCCEEDED(hr))
        {
            m_hMicroKnob.SendMessage(TBM_SETPOS, (WPARAM)TRUE, (LPARAM)lVolume);

            m_hMicroKnob.EnableWindow( TRUE );
        }
        else
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::RefreshAudioControls - error <%x> when calling get_Volume", this, hr));

            m_hMicroKnob.EnableWindow( FALSE );
        }
    }
    else
    {
        // disable everything
        m_hSpeakerKnob.EnableWindow( FALSE );
        m_hSpeakerMuteButton.EnableWindow( FALSE );

        m_hMicroKnob.EnableWindow( FALSE );
        m_hMicroMuteButton.EnableWindow( FALSE );
    }

    return S_OK;
}

// RefreshVideoControls
//  Read current video enable/disable controls
//
HRESULT CRTCCtl::RefreshVideoControls(void)
{
    HRESULT         hr;
    long            lVolume;

    if(m_pRTCClient!=NULL)
    {
    
        // read capabilities from core
        //
        hr = m_pRTCClient -> get_MediaCapabilities(&m_lMediaCapabilities);

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::RefreshVideoControls - "
                "error (%x) returned by get_MediaCapabilities, exit",this,  hr));
        
            m_hReceivePreferredButton.EnableWindow(FALSE);
            m_hSendPreferredButton.EnableWindow(FALSE);
        
            return 0;
        }
        
        // Get media preferences
        hr = m_pRTCClient->get_PreferredMediaTypes( &m_lMediaPreferences);
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::RefreshVideoControls - "
                "error (%x) returned by get_PreferredMediaTypes, exit",this,  hr));

            m_hReceivePreferredButton.EnableWindow(FALSE);
            m_hSendPreferredButton.EnableWindow(FALSE);
            return 0;
        }

        m_hReceivePreferredButton.EnableWindow(
            m_lMediaCapabilities & RTCMT_VIDEO_RECEIVE);
        m_hSendPreferredButton.EnableWindow(
            m_lMediaCapabilities & RTCMT_VIDEO_SEND);

        m_hReceivePreferredButton.SendMessage(
            BM_SETCHECK, 
            (m_lMediaPreferences & RTCMT_VIDEO_RECEIVE) ? BST_CHECKED : BST_UNCHECKED,
            0);
        
        m_hSendPreferredButton.SendMessage(
            BM_SETCHECK, 
            (m_lMediaPreferences & RTCMT_VIDEO_SEND) ? BST_CHECKED : BST_UNCHECKED,
            0);

        // Get the video preview preference
        DWORD   dwValue = (DWORD)TRUE;

        hr = get_SettingsDword(SD_VIDEO_PREVIEW, &dwValue);
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::RefreshVideoControls - "
                "error (%x) returned by get_SettingsDword(SD_VIDEO_PREVIEW)",this,  hr));
        }

        m_bPreviewWindowIsPreferred = !!dwValue;

        // XXX add here the initialization of m_hPreviewPreferredButton
    }

    return S_OK;
}




// CalcSizeAndNotifyContainer
//      Calculates the vertical size based on properties
//    and notifies the container.  
//
//  WARNING !!!! Must be called prior to creating
//  the window for the control 
// 
//

void CRTCCtl::CalcSizeAndNotifyContainer(void)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::CalcSizeAndNotifyContainer - enter", this));

    // find the appropriate layout
    // also keep it for later (OnInitDialog)

    switch(m_nPropCallScenario)
    {
    case RTC_CALL_SCENARIO_PCTOPC:
        // logo/video
        m_pWebCrmLayout = m_bPropShowDialpad ? 
            NULL : &s_WebCrmPCToPCZoneLayout;
        break;

    case RTC_CALL_SCENARIO_PCTOPHONE:
       // dialpad or nothing
        m_pWebCrmLayout = m_bPropShowDialpad ? 
            &s_WebCrmPCToPhoneWithDialpadZoneLayout : &s_WebCrmPCToPhoneZoneLayout;
        break;
    
    case RTC_CALL_SCENARIO_PHONETOPHONE:
        // the caller may want a dialpad. So what ? We are not a computer game.
        m_pWebCrmLayout =  m_bPropShowDialpad ? 
            NULL : &s_WebCrmPhoneToPhoneZoneLayout;
        break;

    default:
        // uhh, this is not a correct parameter.
        LOG((RTC_WARN, "[%p] CRTCCtl::CalcSizeAndNotifyContainer - incorrect CallScenario property (%d)", this, m_nPropCallScenario));
        break;
    }

    if(m_pWebCrmLayout)
    {
        LONG    lSize = 0;
        
        //
        // Computes the size in pixels
        //
        //  !!! Hardcoded, it's based on knowledge regarding 
        //  group placements
        //
        if((*m_pWebCrmLayout)[AXCTL_ZONE_TOOLBAR].bShown)
        {
            lSize += ZONE_GROUP_TOOLBAR_HEIGHT;
        }
        
        if((*m_pWebCrmLayout)[AXCTL_ZONE_LOGOVIDEO].bShown
         ||(*m_pWebCrmLayout)[AXCTL_ZONE_DIALPAD].bShown)
        {
            lSize += ZONE_GROUP_MAIN_HEIGHT;
        }

        if((*m_pWebCrmLayout)[AXCTL_ZONE_AUDIO].bShown)
        {
            lSize += ZONE_GROUP_SECONDARY_HEIGHT;
        }

        if((*m_pWebCrmLayout)[AXCTL_ZONE_PARTICIPANTS].bShown)
        {
            lSize += ZONE_GROUP_PARTLIST_HEIGHT;
        }
        
        if((*m_pWebCrmLayout)[AXCTL_ZONE_STATUS].bShown)
        {
            lSize += ZONE_GROUP_STATUS_HEIGHT;
        }

        //
        // Convert to HiMetric
        //

        SIZE size;
        size.cx = CTLSIZE_Y; // fixed size !! (whatever the aspect ratio is)
        size.cy = lSize;

        AtlPixelToHiMetric(&size, &size);

        //
        // Set the new size
        //
        m_sizeExtent.cy = size.cy;
        m_sizeExtent.cx = size.cx;
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::CalcSizeAndNotifyContainer - exit", this));
}


// OnVideoMediaEvent
//      Processes the events related to video streaming

/*
    There are four parameters that drive the aspect of the video zone

    - AXCTL Layout - logovideo zone     (VZONE)
    - Send video streaming status       (SVID) 
    - Receive video streaming status    (RVID)
    - Preview window preference         (PREV)

    The receive window can display a black brush or a DX video window. It also
    can be clipped in order to accommodate a preview window

    VZONE   RVID   SVID    PREV         Big Window                      Small Window
    
    Hidden   X      X       X           Black brush, not clipped       hidden
    Active   No     No      No          Black brush, not clipped       hidden 
    Active   No     No      Yes         Black brush, not clipped       hidden 
    Active   No     Yes     No          Black brush, not clipped       hidden
    Active   No     Yes     Yes         Black brush, clipped           preview video
    Active   Yes    No      No          Rec Video, not clipped         hidden 
    Active   Yes    No      Yes         Rec Video, not clipped         hidden 
    Active   Yes    Yes     No          Rec Video, not clipped         hidden
    Active   Yes    Yes     Yes         Rec Video, clipped             preview video
   
*/


HRESULT CRTCCtl::OnVideoMediaEvent(
        BOOL    bReceiveWindow,
        BOOL    bActivated)
{
    BOOL        *pWindowActive;
    HRESULT     hr = S_OK;

    LOG((RTC_TRACE, "[%p] CRTCCtl::OnVideoMediaEvent - enter", this));

    pWindowActive = bReceiveWindow ? &m_bReceiveWindowActive : &m_bPreviewWindowActive;

    //
    // Is the event redundant ?
    //

    if((bActivated && *pWindowActive) ||
       (!bActivated && !*pWindowActive))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnVideoMediaEvent - redundant event, exit", this));

        return E_UNEXPECTED;
    }
    
    //
    // Get the IVideoWindow interface
    //
    IVideoWindow    *pVideoWindow = NULL;

    ATLASSERT(m_pRTCClient.p);

    hr = m_pRTCClient -> get_IVideoWindow(
        bReceiveWindow ? RTCVD_RECEIVE : RTCVD_PREVIEW,
        &pVideoWindow);

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnVideoMediaEvent - cannot get the IVideoWindow interface, exit", this));

        return hr;
    }

    //
    // Do the work
    //
    RTC_VIDEO_DEVICE nVideoDevice;
    CWindow         *pFrameWindow;

    nVideoDevice = bReceiveWindow ? RTCVD_RECEIVE : RTCVD_PREVIEW;
    pFrameWindow = bReceiveWindow ? &m_hReceiveWindow : &m_hPreviewWindow;

    ATLASSERT(pVideoWindow);

    if(bActivated)
    {
        // set the window style
        //

        hr = pVideoWindow -> put_WindowStyle(WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS);
        
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::OnVideoMediaEvent - "
                        "error (%x) returned by put_WindowStyle, exit", this, hr));

            return hr;
        }
        
        // set the window owner
        //
        hr = pVideoWindow -> put_Owner((OAHWND)HWND(*pFrameWindow));
        
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::OnVideoMediaEvent - "
                        "error (%x) returned by put_Owner, exit", this, hr));

            return hr;
        }

        // The geometry.. The entire client area of the bitmap control is used by the
        //  video window
        //
        RECT    rectPos;

        pFrameWindow ->GetClientRect(&rectPos);

        hr = pVideoWindow -> SetWindowPosition(
            rectPos.left,
            rectPos.top,
            rectPos.right,
            rectPos.bottom
            );
        
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::OnVideoMediaEvent - "
                        "error (%x) returned by SetWindowPosition, exit", this, hr));

            return hr;
        }
        
        // Show the window
        //
         
        hr = pVideoWindow -> put_Visible(OATRUE);
        
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::OnVideoMediaEvent - "
                        "error (%x) returned by put_Visible(OATRUE), exit", this, hr));
        
            return hr;
        }

        // 
        // Mark the window as shown
        //

        *pWindowActive = TRUE;

        //
        // Adjust some clipping regions, if necessary
        //

        if(!bReceiveWindow)
        {
            ShowHidePreviewWindow(
                m_ZoneStateArray[AXCTL_ZONE_LOGOVIDEO].bShown &&
                *pWindowActive &&
                m_bPreviewWindowIsPreferred);
        }
    }
    else
    {
        // 
        // Mark the window as hidden, whatever the result of the method will be
        //

        *pWindowActive = FALSE;
        
        
        //
        // Adjust some clipping regions, if necessary
        //

        if(!bReceiveWindow)
        {
            ShowHidePreviewWindow(
                m_ZoneStateArray[AXCTL_ZONE_LOGOVIDEO].bShown &&
                *pWindowActive &&
                m_bPreviewWindowIsPreferred);
        }
        
        // hide the window
        
        hr = pVideoWindow -> put_Visible(OAFALSE);
        
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::OnVideoMediaEvent - "
                        "error (%x) returned by put_Visible(OAFALSE), exit", this, hr));
            
            return hr;
        }

        // set the window owner to NULL
        //
        hr = pVideoWindow -> put_Owner(NULL);
        
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::OnVideoMediaEvent - "
                        "error (%x) returned by put_Owner, exit", this, hr));

            return hr;
        }

    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::OnVideoMediaEvent - exit", this));

    return hr;
}


// ShowHidePreviewWindow
//      Hides or displays the preview window.
//      It also adjust the receive window region

void CRTCCtl::ShowHidePreviewWindow(BOOL bShow)
{
    RECT rectRecv;
    long lEdgeX, lEdgeY;

    // Get the window region for the receive window
    m_hReceiveWindow.GetWindowRect(&rectRecv);   
    
    // map to the window coordinates of the receive window
    //  this is ugly, we don't have a way to directly do this..
    //
    ::MapWindowPoints(NULL, m_hReceiveWindow, (LPPOINT)&rectRecv, 2);

    // adjust for the window edge
    lEdgeX = rectRecv.left;
    lEdgeY = rectRecv.top;
  
    rectRecv.right -= lEdgeX;
    rectRecv.bottom -= lEdgeY; 
    rectRecv.left = 0;
    rectRecv.top = 0;
    
    // create a region
    HRGN    hRegion1 = CreateRectRgn(
        rectRecv.left,
        rectRecv.top,
        rectRecv.right,
        rectRecv.bottom
        );
 
    if(bShow)
    {
        RECT    rectPrev;

        m_hPreviewWindow.GetWindowRect(&rectPrev);      

        ::MapWindowPoints(NULL, m_hReceiveWindow, (LPPOINT)&rectPrev, 2);
 
        // adjust for the window edge
        rectPrev.right -= lEdgeX;
        rectPrev.bottom -= lEdgeY; 
        rectPrev.left -= lEdgeX;
        rectPrev.top -= lEdgeY;  

        HRGN    hRegion2 = CreateRectRgn(
            rectPrev.left,  
            rectPrev.top,  
            rectPrev.right,
            rectPrev.bottom
            );

        CombineRgn(hRegion1, hRegion1, hRegion2, RGN_DIFF);

        DeleteObject(hRegion2);
    }
    
    // show/hide the preview window
    m_hPreviewWindow.ShowWindow(bShow ? SW_SHOW : SW_HIDE);
    
    // set the new region
    m_hReceiveWindow.SetWindowRgn(hRegion1, TRUE);
}


// PrepareErrorStrings
//      Prepare error strings for an error message box

HRESULT CRTCCtl::PrepareErrorStrings(
        BOOL    bOutgoingCall,
        HRESULT StatusCode,
        LPWSTR  pAddress,
        RTCAX_ERROR_INFO
               *pErrorInfo)
{

    UINT    nID1 = 0;
    UINT    nID2 = 0;
    BOOL    bInsertAddress = FALSE;
    WORD    wIcon;
    PWSTR   pString = NULL;
    PWSTR   pFormat = NULL;
    DWORD   dwLength;


    LOG((RTC_TRACE, "[%p] CRTCCtl::PrepareErrorStrings; "
        "outgoing: %s, StatusCode=%x, Address %S - enter", 
        this,
        bOutgoingCall ? "true" : "false",
        StatusCode,
        pAddress ? pAddress : L"(null)"));

    // Error by default
    //
    wIcon = OIC_HAND;

    if ( FAILED(StatusCode) )
    {
        if ( (HRESULT_FACILITY(StatusCode) == FACILITY_SIP_STATUS_CODE) ||
             (HRESULT_FACILITY(StatusCode) == FACILITY_PINT_STATUS_CODE) )
        {
            // by default we use a generic message
            // we blame the network
            //
            nID1 = IDS_MB_SIPERROR_GENERIC_1;
            nID2 = IDS_MB_SIPERROR_GENERIC_2;

            // the default is a warning for this class
            wIcon = OIC_WARNING;

            switch( HRESULT_CODE(StatusCode) )
            {
            case 405:   // method not allowed
            case 406:   // not acceptable
            case 488:   // not acceptable here
            case 606:   // not acceptable

                // reusing the "apps don't match" error
                // 
			    nID1 = IDS_MB_HRERROR_APPS_DONT_MATCH_1;
			    nID2 = IDS_MB_HRERROR_APPS_DONT_MATCH_OUT_2;
            
                break;

            case 404:   // not found
            case 410:   // gone
            case 604:   // does not exist anywhere
            case 700:   // ours, no client is running on the callee
            
                // not found
                // 
                nID1 = IDS_MB_SIPERROR_NOTFOUND_1;
                nID2 = IDS_MB_SIPERROR_NOTFOUND_2;
                // bInsertAddress = TRUE;
            
                // information
                wIcon = OIC_INFORMATION;

                break;

            case 401:
            case 407:

                // auth failed
                // 
                nID1 = IDS_MB_SIPERROR_AUTH_FAILED_1;
                nID2 = IDS_MB_SIPERROR_AUTH_FAILED_2;
            
                break;

            case 408:   // timeout
            
                // timeout. this also cover the case when
                //  the callee is lazy and doesn't answer the call
                //
                // if we are in the connecting state, we may assume
                // that the other end is not answering the phone.
                // It's not perfect, but I don't have any choice

                if (m_nControlState == RTCAX_STATE_CONNECTING)
                {
                    nID1 = IDS_MB_SIPERROR_NOTANSWERING_1;
                    nID2 = IDS_MB_SIPERROR_NOTANSWERING_2;

                    // information
                    wIcon = OIC_INFORMATION;
                }

                break;            

            case 480:   // not available
            
                // callee has not made him/herself available..
                // 
                nID1 = IDS_MB_SIPERROR_NOTAVAIL_1;
                nID2 = IDS_MB_SIPERROR_NOTAVAIL_2;
            
                // information
                wIcon = OIC_INFORMATION;
            
                break;
        
            case 486:   // busy here
            case 600:   // busy everywhere
            
                // callee has not made him/herself available..
                // 
                nID1 = IDS_MB_SIPERROR_BUSY_1;
                nID2 = IDS_MB_SIPERROR_BUSY_2;
            
                // information
                wIcon = OIC_INFORMATION;
            
                break;

            case 500:   // server internal error
            case 503:   // service unavailable
            case 504:   // server timeout
            
                //  blame the server
                //
                nID1 = IDS_MB_SIPERROR_SERVER_PROBLEM_1;
                nID2 = IDS_MB_SIPERROR_SERVER_PROBLEM_2;
            
                break;

            case 603:   // decline

                nID1 = IDS_MB_SIPERROR_DECLINE_1;
                nID2 = IDS_MB_SIPERROR_DECLINE_2;
            
                // information
                wIcon = OIC_INFORMATION;

                break;
            }
        
            //
            // some Pint errors, they are actually for the primary leg
            //

            if(m_nCachedCallScenario == RTC_CALL_SCENARIO_PHONETOPHONE)
            {
                // keep the "warning" icon, because there's a problem with the primary leg

                switch( HRESULT_CODE(StatusCode) )
                {
                case 5:

                    nID1 = IDS_MB_SIPERROR_PINT_BUSY_1;
                    nID2 = IDS_MB_SIPERROR_PINT_BUSY_2;
                    break;

                case 6:

                    nID1 = IDS_MB_SIPERROR_PINT_NOANSWER_1;
                    nID2 = IDS_MB_SIPERROR_PINT_NOANSWER_2;
                    break;

                case 7:

                    nID1 = IDS_MB_SIPERROR_PINT_ALLBUSY_1;
                    nID2 = IDS_MB_SIPERROR_PINT_ALLBUSY_2;
                    break;
              
                }
            }


            //
            //  The third string displays the SIP code
            //

            PWSTR pFormat = RtcAllocString(
                _Module.GetResourceInstance(),
                IDS_MB_DETAIL_SIP);

            if(pFormat)
            {
                // find the length
                dwLength = 
                    ocslen(pFormat) // format length
                 -  2               // length of %d
                 +  0x10;           // enough for a number...

                pString = (PWSTR)RtcAlloc((dwLength + 1)*sizeof(WCHAR));
            
                if(pString)
                {
                    _snwprintf(pString, dwLength + 1, pFormat, HRESULT_CODE(StatusCode) );
                }

                RtcFree(pFormat);
                pFormat = NULL;
            
                pErrorInfo->Message3 = pString;
                pString = NULL;
            }
        }
        else
        {
            // Two cases - incoming and outgoing calls
            if(bOutgoingCall)
            {
                if(StatusCode == HRESULT_FROM_WIN32(WSAHOST_NOT_FOUND) )
                {
                    // Use the generic message in this case
                    //
                    nID1 = IDS_MB_HRERROR_NOTFOUND_1;
                    nID2 = IDS_MB_HRERROR_NOTFOUND_2;
            
                    // it's not malfunction
                    wIcon = OIC_INFORMATION;

                }
                else if (StatusCode == HRESULT_FROM_WIN32(WSAECONNRESET))
                {
                    // Even thoough it can be caused by any hard reset of the 
                    // remote end, in most of the cases it is caused when the 
                    // other end doesn't have SIP client running.

                    // different messages based on whether it uses a profile or not.
                    // XXXX
                    // It assumes the profile is not changed by the core
                    // This is currently true, but if we move the redirection stuff into
                    // the core, it won't be true any more.
                
                    if (m_pCachedProfile)
                    {
                        nID1 = IDS_MB_HRERROR_SERVER_NOTRUNNING_1;
                        nID2 = IDS_MB_HRERROR_SERVER_NOTRUNNING_2;
                    }
                    else
                    {
                        nID1 = IDS_MB_HRERROR_CLIENT_NOTRUNNING_1;
                        nID2 = IDS_MB_HRERROR_CLIENT_NOTRUNNING_2;
                    }
    
                    wIcon = OIC_INFORMATION;
            
                }
			    else if (StatusCode == RTC_E_INVALID_SIP_URL ||
                         StatusCode == RTC_E_DESTINATION_ADDRESS_MULTICAST)
			    {
				    nID1 = IDS_MB_HRERROR_INVALIDADDRESS_1;
				    nID2 = IDS_MB_HRERROR_INVALIDADDRESS_2;
                
                    wIcon = OIC_HAND;
			    }
			    else if (StatusCode == RTC_E_DESTINATION_ADDRESS_LOCAL)
			    {
				    nID1 = IDS_MB_HRERROR_LOCAL_MACHINE_1;
				    nID2 = IDS_MB_HRERROR_LOCAL_MACHINE_2;
                
                    wIcon = OIC_HAND;
			    }
                else if (StatusCode == HRESULT_FROM_WIN32(ERROR_USER_EXISTS) &&
                    m_nCachedCallScenario == RTC_CALL_SCENARIO_PHONETOPHONE)
                {
                    nID1 = IDS_MB_HRERROR_CALLING_PRIMARY_LEG_1;
                    nID2 = IDS_MB_HRERROR_CALLING_PRIMARY_LEG_2;

                    wIcon = OIC_INFORMATION;
                }
			    else if (StatusCode == RTC_E_SIP_TIMEOUT)
			    {
				    nID1 = IDS_MB_HRERROR_SIP_TIMEOUT_OUT_1;
				    nID2 = IDS_MB_HRERROR_SIP_TIMEOUT_OUT_2;
                
                    wIcon = OIC_HAND;
			    }
			    else if (StatusCode == RTC_E_SIP_CODECS_DO_NOT_MATCH || 
                         StatusCode == RTC_E_SIP_PARSE_FAILED)
			    {
				    nID1 = IDS_MB_HRERROR_APPS_DONT_MATCH_1;
				    nID2 = IDS_MB_HRERROR_APPS_DONT_MATCH_OUT_2;
                
                    wIcon = OIC_INFORMATION;
			    }
                else
                {
                    nID1 = IDS_MB_HRERROR_GENERIC_OUT_1;
                    nID2 = IDS_MB_HRERROR_GENERIC_OUT_2;
                
                    wIcon = OIC_HAND;
                }
            }
            else
            {
                // incoming call
			    if (StatusCode == RTC_E_SIP_TIMEOUT)
			    {
				    nID1 = IDS_MB_HRERROR_SIP_TIMEOUT_IN_1;
				    nID2 = IDS_MB_HRERROR_SIP_TIMEOUT_IN_2;
                
                    wIcon = OIC_HAND;
			    }
			    else if (StatusCode == RTC_E_SIP_CODECS_DO_NOT_MATCH || 
                         StatusCode == RTC_E_SIP_PARSE_FAILED)
			    {
				    nID1 = IDS_MB_HRERROR_APPS_DONT_MATCH_1;
				    nID2 = IDS_MB_HRERROR_APPS_DONT_MATCH_IN_2;
                
                    wIcon = OIC_INFORMATION;
			    }
                else
                {
                    nID1 = IDS_MB_HRERROR_GENERIC_IN_1;
                    nID2 = IDS_MB_HRERROR_GENERIC_IN_2;

                    wIcon = OIC_HAND;
                }
            }
        
            //
            //  The third string displays the error code and text
            //

        
            PWSTR   pErrorText = NULL;

            dwLength = 0;
        
            // retrieve the error text
            if ( HRESULT_FACILITY(StatusCode) == FACILITY_RTC_INTERFACE )
            {
                // I hope it's the core 
                HANDLE  hRTCModule = GetModuleHandle(_T("RTCDLL.DLL"));
                dwLength = ::FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_HMODULE |
                    FORMAT_MESSAGE_IGNORE_INSERTS,
                    hRTCModule,
                    StatusCode,
                    0,
                    (LPTSTR)&pErrorText, // that's ugly
                    0,
                    NULL);
            }

        
            if (dwLength == 0)
            {
                // is it a QUARTZ error ?

                HANDLE  hQtzModule = GetModuleHandle(_T("QUARTZ.DLL"));
                dwLength = ::FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_HMODULE |
                    FORMAT_MESSAGE_IGNORE_INSERTS,
                    hQtzModule,
                    StatusCode,
                    0,
                    (LPTSTR)&pErrorText, // that's ugly
                    0,
                    NULL);
            }

            if(dwLength == 0)
            {
                // normal system errors
                dwLength = ::FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    StatusCode,
                    0,
                    (LPTSTR)&pErrorText, // that's ugly
                    0,
                    NULL);
            }

            // load the format
            // load a simpler one if the associated
            // text for Result could not be found
        
            pFormat = RtcAllocString(
                _Module.GetResourceInstance(),
                dwLength > 0 ? 
                IDS_MB_DETAIL_HR : IDS_MB_DETAIL_HR_UNKNOWN);
       
            if(pFormat)
            {
                LPCTSTR szInserts[] = {
                    (LPCTSTR)UlongToPtr(StatusCode), // ugly
                    pErrorText
                };

                PWSTR   pErrorTextCombined = NULL;
                
                // format the error message
                dwLength = ::FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_STRING |
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    pFormat,
                    0,
                    0,
                    (LPTSTR)&pErrorTextCombined,
                    0,
                    (va_list *)szInserts);

                if(dwLength > 0)
                {
                    // set the error info
                    // this additional operation is needed
                    //  because we need RtcAlloc allocated memory

                    pErrorInfo->Message3 = RtcAllocString(pErrorTextCombined);
                }

                if(pErrorTextCombined)
                {
                    LocalFree(pErrorTextCombined);
                }

                RtcFree(pFormat);
                pFormat = NULL;
            
            }
    
            if(pErrorText)
            {
                LocalFree(pErrorText);
            }
        }
    }

    //
    // Prepare the first string.
    //

    pString = RtcAllocString(
                        _Module.GetResourceInstance(),
                        nID1);

    if(pString)
    {
        // do we have to insert the address ?
        if(bInsertAddress)
        {
            pFormat = pString;

            pString = NULL;

            // find the length
            dwLength = 
                ocslen(pFormat) // format length
             -  2               // length of %s
             +  (pAddress ? ocslen(pAddress) : 0);   // address

            pString = (PWSTR)RtcAlloc((dwLength + 1)*sizeof(WCHAR));
            
            if(pString)
            {
                _snwprintf(pString, dwLength + 1, pFormat, pAddress ? pAddress : L"");
            }

            RtcFree(pFormat);
            pFormat = NULL;
        }
    }

    pErrorInfo->Message1 = pString;

    pErrorInfo->Message2 = RtcAllocString(
                        _Module.GetResourceInstance(),
                        nID2);

    pErrorInfo->ResIcon = (HICON)LoadImage(
        0,
        MAKEINTRESOURCE(wIcon),
        IMAGE_ICON,
        0,
        0,
        LR_SHARED);
        
    LOG((RTC_TRACE, "[%p] CRTCCtl::PrepareErrorStrings - exit", this));

    return S_OK;
}


// FreeErrorStrings
//      Free error strings

void CRTCCtl::FreeErrorStrings(
        RTCAX_ERROR_INFO
               *pErrorInfo)
{
    if(pErrorInfo->Message1)
    {
        RtcFree(pErrorInfo->Message1);
        pErrorInfo->Message1 = NULL;
    }
    if(pErrorInfo->Message2)
    {
        RtcFree(pErrorInfo->Message2);
        pErrorInfo->Message2 = NULL;
    }
    if(pErrorInfo->Message3)
    {
        RtcFree(pErrorInfo->Message3);
        pErrorInfo->Message3 = NULL;
    }
}


// CoreInitialize
//      CoCreates and Initialize a CLSID_RTCClient object
//      Registers for notifications
//      
// 

HRESULT CRTCCtl::CoreInitialize()
{
    HRESULT hr;
    
    // This one won't make it into steelhead tracing, it is not initialized yet
    LOG((RTC_TRACE, "[%p] CRTCCtl::CoreInitialize - enter", this));

    // Create the main instance of the Core
    hr = m_pRTCClient.CoCreateInstance(CLSID_RTCClient);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::CoreInitialize; cannot cocreate RTCClient, error %x", this, hr));
        return hr;
    }

    // Initialize the client
    hr = m_pRTCClient->Initialize();
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::CoreInitialize; cannot Initialize RTCClient, error %x", this, hr));
        // releases explicitly the interface
        m_pRTCClient.Release();
        return hr;
    }

    if(m_nCtlMode == CTL_MODE_HOSTED)
    {
        // prepare a "one time" media preference
        
        m_lMediaPreferences = RTCMT_AUDIO_SEND | RTCMT_AUDIO_RECEIVE;

        if(!m_bPropDisableVideoReception && m_nPropCallScenario == RTC_CALL_SCENARIO_PCTOPC)
        {
            m_lMediaPreferences |= RTCMT_VIDEO_RECEIVE;
        }
        
        if(!m_bPropDisableVideoTransmission && m_nPropCallScenario == RTC_CALL_SCENARIO_PCTOPC)
        {
            m_lMediaPreferences |= RTCMT_VIDEO_SEND;
        }

        // Set volatile preferences
        hr = m_pRTCClient->SetPreferredMediaTypes( m_lMediaPreferences, FALSE );
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::CoreInitialize; cannot set preferred media types, error %x", this, hr));

            m_pRTCClient->Shutdown();
            // releases explicitly the interface
            m_pRTCClient.Release();
            return hr;
        }

        // video preview preference as specified in the param
        m_bPreviewWindowIsPreferred = m_bPropDisableVideoPreview;
    }

    // Set the event filter

    hr = m_pRTCClient->put_EventFilter( RTCEF_CLIENT |
                                        RTCEF_SESSION_STATE_CHANGE |
                                        RTCEF_PARTICIPANT_STATE_CHANGE |
                                        RTCEF_MEDIA |
                                        RTCEF_INTENSITY	|
                                        RTCEF_MESSAGING );

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::CoreInitialize; cannot set event filter, error %x", this, hr));

        m_pRTCClient->Shutdown();
        // releases explicitly the interface
        m_pRTCClient.Release();
        return hr;
    }

    // Find the connection point

    IConnectionPointContainer     * pCPC;
    IUnknown         * pUnk;

    hr = m_pRTCClient->QueryInterface(
                           IID_IConnectionPointContainer,
                           (void **) &pCPC
                          );

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::CoreInitialize; cannot QI for connection point container, error %x", this, hr));

        m_pRTCClient->Shutdown();
        // releases explicitly the interface
        m_pRTCClient.Release();
        return hr;
    }

    hr = pCPC->FindConnectionPoint(
                              IID_IRTCEventNotification,
                              &m_pCP
                             );

    pCPC->Release();

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::CoreInitialize; cannot find connection point, error %x", this, hr));

        m_pRTCClient->Shutdown();
        // releases explicitly the interface
        m_pRTCClient.Release();
        return hr;
    }    

    // Get IUnknown for ourselves

    hr = QueryInterface(
                   IID_IUnknown,
                   (void **)&pUnk
                  );

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::CoreInitialize; cannot QI for IUnknown, error %x", this, hr));

        m_pCP->Release();
        m_pCP = NULL;

        m_pRTCClient->Shutdown();
        // releases explicitly the interface
        m_pRTCClient.Release();
        return hr;
    }

    // Register for notifications

    hr = m_pCP->Advise(
                 pUnk,
                 (ULONG *)&m_ulAdvise
                );

    pUnk->Release();

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::CoreInitialize; cannot advise connection point, error %x", this, hr));
        
        m_pCP->Release();
        m_pCP = NULL;

        m_pRTCClient->Shutdown();
        // releases explicitly the interface
        m_pRTCClient.Release();
        return hr;
    }

    m_hCoreShutdownEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

    if ( m_hCoreShutdownEvent == NULL )
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::CoreInitialize; cannot create shutdown event", this));

        m_pCP->Unadvise(m_ulAdvise);
        m_pCP->Release();
        m_pCP = NULL;

        m_pRTCClient->Shutdown();
        // releases explicitly the interface
        m_pRTCClient.Release();
        return E_OUTOFMEMORY;
    }

    // Set local user name and uri

    BSTR bstrDisplayName = NULL;
    BSTR bstrUserURI = NULL;

    hr = get_SettingsString( SS_USER_DISPLAY_NAME, &bstrDisplayName );

    if ( SUCCEEDED(hr) )
    {
        hr = m_pRTCClient->put_LocalUserName( bstrDisplayName );

        SysFreeString( bstrDisplayName );
        bstrDisplayName = NULL;

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::CoreInitialize; cannot set local user name, error %x", this, hr));
        }
    }

    hr = get_SettingsString( SS_USER_URI, &bstrUserURI );

    if ( SUCCEEDED(hr) )
    {
        hr = m_pRTCClient->put_LocalUserURI( bstrUserURI );

        SysFreeString( bstrUserURI );
        bstrUserURI = NULL;

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::CoreInitialize; cannot set local user URI, error %x", this, hr));
        }
    }

    hr = EnableProfiles( m_pRTCClient );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::CoreInitialize; EnableProfiles failed, error %x", this, hr));
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::CoreInitialize - exit S_OK", this));
    return S_OK;
}

// CoreUninitialize
//      Unregisters the event sink
//      Shuts down and releases the RTCClient
// 

void CRTCCtl::CoreUninitialize()
{
    HRESULT hr;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::CoreUninitialize - enter", this));

    // Shuts down the client
    if(m_pRTCClient!=NULL)
    {
        m_pRTCClient->put_EventFilter( RTCEF_CLIENT );

        // Forcibly terminates any call
        // Don't rely on any notification to change the state (we've just filtered)
        // so remove manually all the references
        if(m_pRTCActiveSession != NULL)
        {
            LOG((RTC_TRACE, "[%p] CRTCCtl::CoreUninitialize; Terminating the pending call...", this));

            m_pRTCActiveSession->Terminate(RTCTR_SHUTDOWN);

            LOG((RTC_INFO, "[%p] CRTCCtl::CoreUninitialize: releasing active session", this));

            m_pRTCActiveSession = NULL;
            
        }
        
        // Frees the participants from the list
        m_hParticipantList.RemoveAll();

        // Release any one shot profile we may have
        m_pRTCOneShotProfile.Release();

        // Release any cached profile
        m_pCachedProfile.Release();
        m_pRedirectProfile.Release();

        // Prepare for shutdown
        hr = m_pRTCClient->PrepareForShutdown();
        if(FAILED(hr))
        {
            // Hmm
            LOG((RTC_ERROR, "[%p] CRTCCtl::CoreUninitialize; cannot PrepareForShutdown RTCClient, error %x", this, hr));
        }
        else
        {
            MSG msg;

            while (MsgWaitForMultipleObjects (
                1,                  // nCount
                &m_hCoreShutdownEvent, // pHandles
                FALSE,              // fWaitAll
                INFINITE,           // dwMilliseconds
                QS_ALLINPUT         // dwWakeMask
                ) != WAIT_OBJECT_0)
            {
                while (PeekMessage (
                    &msg,           // lpMsg
                    NULL,           // hWnd
                    0,              // wMsgFilterMin
                    0,              // wMsgFilterMax
                    PM_REMOVE       // wRemoveMsg
                    ))
                {
                    TranslateMessage (&msg);
                    DispatchMessage (&msg);
                }
            }
        }

        CloseHandle( m_hCoreShutdownEvent );
        m_hCoreShutdownEvent = NULL;

        // unregister our event sink
        hr = m_pCP->Unadvise( m_ulAdvise );

        m_pCP->Release();
        m_pCP = NULL;

        if(FAILED(hr))
        {
            // Hmm
            LOG((RTC_ERROR, "[%p] CRTCCtl::CoreUninitialize; cannot unregister event sink(???), error %x", this, hr));
        }        

        hr = m_pRTCClient->Shutdown();
        if(FAILED(hr))
        {
            // Hmm
            LOG((RTC_ERROR, "[%p] CRTCCtl::CoreUninitialize; cannot Shutdown RTCClient, error %x", this, hr));
        }
        
        // releases explicitly the interface
        m_pRTCClient.Release();
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::CoreUninitialize - exit", this));
}

// CallOneShot
// 
//      Creates an IRTCProfile based on the provisioning profile 
//   set as a parameter , asks for the user to enter "from" address 
//   and calls DoCall(intf, props).
// 
  
HRESULT CRTCCtl::CallOneShot(void)
{
    HRESULT hr;

    CComBSTR                bstrFromAddressChosen;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::CallOneShot - enter", this));
    
    ATLASSERT(m_nControState == RTCAX_STATE_IDLE);
        
    SetControlState(RTCAX_STATE_DIALING);

    // Invoke a dialog box if necessary
    // For PCTOPC and PCtoPhone we have all the info (there's no From address involved)
    if(m_nPropCallScenario == RTC_CALL_SCENARIO_PHONETOPHONE)
    {

        ATLASSERT(m_pRTCOneShotProfile.p);

        LOG((RTC_TRACE, "[%p] CRTCCtl::CallOneShot: bring up ShowDialByPhoneNumberDialog", this));

        hr = ShowDialNeedCallInfoDialog(
                                        m_hWnd,
                                        m_pRTCClient,
                                        RTCSI_PHONE_TO_PHONE,
                                        FALSE,
                                        FALSE,
                                        m_pRTCOneShotProfile,
                                        m_bstrPropDestinationUrl,
                                        NULL,
                                        NULL, // we don't care about profile chosen
                                        &bstrFromAddressChosen
                                        );
    }
    else
    {
        hr = S_OK;
    }
    
    if(SUCCEEDED(hr))
    {
        // Do the work
        hr = DoCall(m_pRTCOneShotProfile,
                    m_nPropCallScenario,
                    bstrFromAddressChosen,
                    m_bstrPropDestinationName,
                    m_bstrPropDestinationUrl);

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "[%p] CRTCCtl::CallOneShot: error (%x) returned by DoCall(...)", this, hr));
            
            SetControlState(RTCAX_STATE_IDLE, 0, hr);
        }
    }
    else if (hr==E_ABORT)
    {
        LOG((RTC_TRACE, "[%p] CRTCCtl::CallOneShot: ShowXXXDialog dismissed, do nothing", this));

        SetControlState(RTCAX_STATE_IDLE);
    }
    else
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::CallOneShot: error (%x) returned ShowXXXDialog", this, hr));
        
        SetControlState(RTCAX_STATE_IDLE);
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::CallOneShot - exit", this));

    return hr;
}




// RedirectedCall
// Places a call to the next contact in the redirection context
//  Returns S_OK when a call has been placed successfully
//          S_FALSE when there are no more addresses
//          E_ABORT if the user chose not to continue in a callinfo dlgbox
//          E_other for any unrecoverable error
//  The outcome of the last call that failed in DoCall is returned as an Out parameter.

HRESULT CRTCCtl::RedirectedCall(HRESULT *phCallResult)
{
    LOG((RTC_TRACE, "[%p] CRTCCtl::RedirectedCall - enter", this));

    HRESULT     hr;

    *phCallResult = S_OK;

    do
    {
        // advance in the list of contacts
        // if it returns false, we are at the end of the list
        hr = m_pRTCActiveSession->NextRedirectedUser();

        if(hr == S_FALSE)
        {
            // end of addresses
            LOG((RTC_TRACE, "[%p] CRTCCtl::RedirectedCall - end of list has been reached, exit", this));

            return S_FALSE;
        }
        else if (hr != S_OK)
        {
            // cannot continue
            LOG((RTC_ERROR, "[%p] CRTCCtl::RedirectedCall - error (%x) returned by Advance, exit", this, hr));

            return hr;
        }

        // Get the names
        //
        CComBSTR    bstrName;
        CComBSTR    bstrAddress;

        hr = m_pRTCActiveSession->get_RedirectedUserURI(
            &bstrAddress);

        if(FAILED(hr))
        {
            // cannot continue
            LOG((RTC_ERROR, "[%p] CRTCCtl::RedirectedCall - error (%x) returned by get_UserURI, exit", this, hr));

            return hr;
        }
        
        hr = m_pRTCActiveSession->get_RedirectedUserName(
            &bstrName);

        if(FAILED(hr))
        {
            // cannot continue
            LOG((RTC_ERROR, "[%p] CRTCCtl::RedirectedCall - error (%x) returned by get_UserName, exit", this, hr));

            return hr;
        }

        // decide on whether to display the UI or not
        BOOL    bIsPhone;
        BOOL    bIsSIP;
        BOOL    bIsTEL;
        BOOL    bHasMaddrOrTsp;
        BOOL    bIsEmailLike;

        hr = GetAddressType(
            bstrAddress,
            &bIsPhone,
            &bIsSIP,
            &bIsTEL,
            &bIsEmailLike,
            &bHasMaddrOrTsp);

        if(FAILED(hr))
        {
            *phCallResult = HRESULT_FROM_WIN32(ERROR_UNSUPPORTED_TYPE);

            continue;
        }

        // The UI is only shown in standalone mode
        //

        // UI for choosing provider/from is displayed for
        //      phone numbers
        //      tel urls with no tsp
    
        // UI is not displayed for (and a NULL profile is passed to core):
        //      pc addresses
        //      tel urls with tsp
        //      sip urls of type phone
        //      sip urls of type pc

        if(m_nCtlMode == CTL_MODE_STANDALONE &&
            ((bIsPhone && !bIsSIP && !bIsTEL)   //plain phone numbers
            || (bIsTEL && !bHasMaddrOrTsp) ) )   //tel urls with no tsp  
        {
            CComPtr<IRTCProfile> pProfileChosen;
            CComBSTR            bstrFromAddressChosen;
            CComBSTR            bstrInstructions;


            bstrInstructions.LoadString(IDS_TEXT_CALLINFO_REDIRECT);

            hr = ShowDialNeedCallInfoDialog(
                                            m_hWnd,
                                            m_pRTCClient,
                                            bIsPhone ? (RTCSI_PC_TO_PHONE | RTCSI_PHONE_TO_PHONE)
                                            : RTCSI_PC_TO_PC,
                                            TRUE,
                                            TRUE,
                                            NULL,
                                            bstrAddress,
                                            bstrInstructions,
                                            &pProfileChosen,
                                            &bstrFromAddressChosen
                                        );
            if(FAILED(hr))
            {
                // cannot continue with the redirection
                LOG((RTC_WARN, "[%p] CRTCCtl::RedirectedCall - error (%x) returned by "
                    "ShowDialNeedCallInfoDialog, exit", this, hr));

                return hr; // this includes E_ABORT
            }

            *phCallResult = DoRedirect(
                pProfileChosen,
                bstrFromAddressChosen && *bstrFromAddressChosen!=L'\0' 
                ? RTC_CALL_SCENARIO_PHONETOPHONE : RTC_CALL_SCENARIO_PCTOPHONE,
                bstrFromAddressChosen,
                bstrName,
                bstrAddress
                );
        }
        else
        {
            RTC_CALL_SCENARIO   nCallScenario;

            // For phone addresses, we set the scenario based on the original one
            //  
            //  m_nCachedCallScenario -> nCallScenario
            //
            //  PC_TO_PC                PC_TO_PHONE
            //  PC_TO_PHONE             PC_TO_PHONE
            //  PHONE_TO_PHONE          PHONE_TO_PHONE
            // 
            // For PC addresses
            // nCallScenario is PC_TO_PC whatever the original call scenario was
            //
            if(bIsPhone)
            {
                nCallScenario = m_nCachedCallScenario == RTC_CALL_SCENARIO_PCTOPC ?
                    RTC_CALL_SCENARIO_PCTOPHONE : m_nCachedCallScenario;
            }
            else
            {
                nCallScenario = RTC_CALL_SCENARIO_PCTOPC;
            }

            *phCallResult = DoRedirect(
                NULL, // use no profile !!!
                nCallScenario,
                m_bstrCachedLocalPhoneURI,
                bstrName,
                bstrAddress
                );
        }

    // exit if a DoCall returns S_OK, because an event will be posted eventually
    } while (FAILED(*phCallResult));


    LOG((RTC_TRACE, "[%p] CRTCCtl::RedirectedCall - exit", this));

    return S_OK;
}

// DoRedirect
//   Places the redirected call
//
HRESULT CRTCCtl::DoRedirect(/*[in]*/ IRTCProfile *pProfile,
                   /*[in]*/ RTC_CALL_SCENARIO CallScenario,
                   /*[in]*/ BSTR     pLocalPhoneAddress,
                   /*[in]*/ BSTR     pDestName,
                   /*[in]*/ BSTR     pDestAddress)

{
    HRESULT hr;

    LOG((RTC_TRACE, "[%p] CRTCCtl::DoRedirect - enter", this));
    
    ATLASSERT(m_nControState == RTCAX_STATE_DIALING);

    // cache some parameters, needed for redirects, for changing the visual layout, etc.
    m_nCachedCallScenario = CallScenario;
    m_pCachedProfile = pProfile;
    m_bstrCachedLocalPhoneURI = pLocalPhoneAddress;
    
    // Create session
    hr = m_pRTCActiveSession->Redirect(
        (RTC_SESSION_TYPE)CallScenario,
        pLocalPhoneAddress,
        pProfile,
        RTCCS_FORCE_PROFILE | RTCCS_FAIL_ON_REDIRECT
        );

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::DoRedirect - error <%x> when calling Redirect, exit", this, hr));

        // delete participants
        m_hParticipantList.RemoveAll();

        return hr;
    }

    //  Save the address for error messages
    //
    m_bstrOutAddress = pDestAddress;

    // Create the participant (callee)
    // This will fire events
    hr = m_pRTCActiveSession->AddParticipant(
        pDestAddress,
        pDestName ? pDestName : _T(""),
        NULL);

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::DoRedirect - error <%x> when calling AddParticipant, exit", this, hr));
        
        m_pRTCActiveSession->Terminate(RTCTR_NORMAL);

        // delete participants
        m_hParticipantList.RemoveAll();

        return hr;
    }
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::DoRedirect - exit S_OK", this));

    return S_OK;
}

// DoCall
//   Places the call to the core
//
HRESULT CRTCCtl::DoCall(/*[in]*/ IRTCProfile *pProfile,
                   /*[in]*/ RTC_CALL_SCENARIO CallScenario,
                   /*[in]*/ BSTR     pLocalPhoneAddress,
                   /*[in]*/ BSTR     pDestName,
                   /*[in]*/ BSTR     pDestAddress)

{
    CComPtr<IRTCSession> pSession;

    HRESULT hr;

    LOG((RTC_TRACE, "[%p] CRTCCtl::DoCall - enter", this));
    
    ATLASSERT(m_nControState == RTCAX_STATE_DIALING);

    // cache some parameters, needed for redirects, for changing the visual layout, etc.
    m_nCachedCallScenario = CallScenario;
    m_pCachedProfile = pProfile;
    m_bstrCachedLocalPhoneURI = pLocalPhoneAddress;
    
    // Create session
    hr = m_pRTCClient->CreateSession(
        (RTC_SESSION_TYPE)CallScenario,
        pLocalPhoneAddress,
        pProfile,
        RTCCS_FORCE_PROFILE | RTCCS_FAIL_ON_REDIRECT,
        &pSession);

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::DoCall - error <%x> when calling CreateSession, exit", this, hr));

        // delete participants
        m_hParticipantList.RemoveAll();

        return hr;
    }

    //  Save the address for error messages
    //
    m_bstrOutAddress = pDestAddress;

    // Create the participant (callee)
    // This will fire events
    hr = pSession->AddParticipant(
        pDestAddress,
        pDestName ? pDestName : _T(""),
        NULL);

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::DoCall - error <%x> when calling AddParticipant, exit", this, hr));
        
        pSession->Terminate(RTCTR_NORMAL);

        // delete participants
        m_hParticipantList.RemoveAll();

        return hr;
    }
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::DoCall - exit S_OK", this));

    return S_OK;
}


// Accept
//      Accept the currently alerting session

HRESULT CRTCCtl::Accept(void)
{
    HRESULT     hr;

    LOG((RTC_TRACE, "[%p] CRTCCtl::Accept - enter", this));

    if(m_pRTCActiveSession == NULL)
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::Accept called, but there's no active session, exit", this));

        return E_FAIL;
    }
    
    ATLASSERT(m_nControState == RTCAX_STATE_ALERTING);

    // Set the Answering mode
    SetControlState(RTCAX_STATE_ANSWERING);
                
    // answer the call   
    hr = m_pRTCActiveSession -> Answer();
    
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::Accept, Answer returned error <%x>", this, hr));
                    
        // try a terminate..
        if(m_pRTCActiveSession != NULL)
        {
            HRESULT hr1;

            hr1 = m_pRTCActiveSession->Terminate(RTCTR_NORMAL);

            if(FAILED(hr1))
            {
                // release it, if it's still there

                LOG((RTC_INFO, "[%p] CRTCCtl::Accept: releasing active session", this));

                m_pRTCActiveSession = NULL;
            }
        }
        
        // set the idle state
        SetControlState(RTCAX_STATE_IDLE, hr);

        return hr;
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::Accept - exit", this));

    return S_OK;
}

// Reject
//      Reject the currently alerting session

HRESULT CRTCCtl::Reject(RTC_TERMINATE_REASON Reason)
{
    HRESULT     hr;

    LOG((RTC_TRACE, "[%p] CRTCCtl::Reject - enter", this));

    if(m_pRTCActiveSession == NULL)
    {
        // may happen
        // harmless

        LOG((RTC_TRACE, "[%p] CRTCCtl::Reject called, but there's no active session, exit", this));

        return S_FALSE;
    }
    
    ATLASSERT(m_nControState == RTCAX_STATE_ALERTING);

    // Set the Disconnecting mode
    SetControlState(RTCAX_STATE_DISCONNECTING);
                
    // reject the call   
    hr = m_pRTCActiveSession -> Terminate(Reason);
    
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::Reject, Terminate returned error <%x>", this, hr));
                    
        // release it, if it's still there
        LOG((RTC_INFO, "[%p] CRTCCtl::Reject: releasing active session", this));

        m_pRTCActiveSession = NULL;
        
        // set the idle state
        SetControlState(RTCAX_STATE_IDLE);
        
        return hr;
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::Reject - exit", this));

    return S_OK;
}


// OnSessionStateChangeEvent
//      Processes session events

HRESULT CRTCCtl::OnSessionStateChangeEvent(IRTCSessionStateChangeEvent *pEvent)
{
    CComPtr<IRTCSession> pSession = NULL;
    RTC_SESSION_STATE   SessionState;
    RTC_SESSION_TYPE    SessionType;
    long                StatusCode;
    HRESULT     hr;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnSessionStateChangeEvent - enter", this));

    // Grab the relevant data from the event
    //
    if(!pEvent)
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnSessionStateChangeEvent, no interface ! - exit", this));
        return E_UNEXPECTED;
    }
    
    hr = pEvent->get_Session(&pSession);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnSessionStateChangeEvent, error <%x> in get_Session - exit", this, hr));
        return hr;
    }
    
    if(pSession==NULL)
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnSessionStateChangeEvent, no session interface ! - exit", this));
        return E_UNEXPECTED;
    }

    hr = pEvent->get_State(&SessionState);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnSessionStateChangeEvent, error <%x> in get_State - exit", this, hr));
        return hr;
    }
    
    hr = pEvent->get_StatusCode(&StatusCode);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnSessionStateChangeEvent, error <%x> in get_StatusCode - exit", this, hr));
        return hr;
    }

    hr = pSession->get_Type(&SessionType);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnSessionStateChangeEvent, error <%x> in get_Type - exit", this, hr));
        return hr;
    }

    hr = S_OK; // optimistic

    if (SessionType == RTCST_IM)
    {
        //
        // Instant message session
        //

        if (m_pIMWindows != NULL)
        {
            hr = m_pIMWindows->DeliverState( pSession, SessionState );
        }
    }
    else
    {
        BOOL    bExpected = FALSE;

        //
        //  The only acceptable event in IDLE state is an incoming call
        //

        if(m_nControlState == RTCAX_STATE_IDLE)
        {
            // In this state there must be no current session
            ATLASSERT(m_pRTCActiveSession == NULL);
        
            switch(SessionState)
            {
            case RTCSS_INCOMING:
            
                // this is a new session that has to be cached as the current session
                //
                m_pRTCActiveSession = pSession;

                // Alert the user, ring the bell
                LOG((RTC_INFO, "[%p] CRTCCtl::OnSessionStateChangeEvent, Alerting...", this));
                
                SetControlState(RTCAX_STATE_ALERTING);

                bExpected = TRUE;

                break;
            }
        }
        else if (m_nControlState == RTCAX_STATE_CONNECTING ||
                 m_nControlState == RTCAX_STATE_ANSWERING ||
                 m_nControlState == RTCAX_STATE_DISCONNECTING ||
                 m_nControlState == RTCAX_STATE_CONNECTED ||
                 m_nControlState == RTCAX_STATE_ALERTING ||
                 m_nControlState == RTCAX_STATE_DIALING ||
                 m_nControlState == RTCAX_STATE_UI_BUSY)
        {
            // First verify the event is for the current session
            // 
            if(m_pRTCActiveSession == pSession)
            {
                // the session is the current session
                //
                switch(SessionState)
                {
                case RTCSS_CONNECTED:
                    if(m_nControlState == RTCAX_STATE_CONNECTING ||
                       m_nControlState == RTCAX_STATE_ANSWERING )
                    {
                        // Connected, life is good
                        //
                        LOG((RTC_INFO, "[%p] CRTCCtl::OnSessionStateChangeEvent, Connected !", this));

                        // Change the control status
                        SetControlState(RTCAX_STATE_CONNECTED);
                    
                        bExpected = TRUE;
                    }
                    break;

                case RTCSS_DISCONNECTED:
                    // rejected or whatever
                    //
                    LOG((RTC_INFO, "[%p] CRTCCtl::OnSessionStateChangeEvent, Disconnected", this));                                   
                
                    hr = S_OK;

                    // process the special case of redirects (Status code between 300 and 399)
                    if( (m_nControlState == RTCAX_STATE_CONNECTING) &&
                        (HRESULT_FACILITY(StatusCode) == FACILITY_SIP_STATUS_CODE) &&
                        (HRESULT_CODE(StatusCode) >= 300) &&
                        (HRESULT_CODE(StatusCode) <= 399) &&
                        (HRESULT_CODE(StatusCode) != 380) )                        
                    {
                        // yes, this is a redirect
                        LOG((RTC_INFO, "[%p] CRTCCtl::OnSessionStateChangeEvent, Redirecting...", this));
                    
                        // mark the redirect mode (it's a substatus of CONNECTING...)
                        m_bRedirecting = TRUE;

                        // store the redirect profile
                        m_pRedirectProfile = m_pCachedProfile;
                    
                        // fall thru
                        // SetControlState will take care of posting a new call
                    }
                    else if ( !m_bRedirecting )
                    {
                        // release the current session
                        LOG((RTC_INFO, "[%p] CRTCCtl::OnSessionStateChangeEvent: releasing active session", this));

                        m_pRTCActiveSession = NULL;
                    }
                
                    // delete participants
                    m_hParticipantList.RemoveAll();

                    // back to idle
                    SetControlState(RTCAX_STATE_IDLE, StatusCode);
                                
                    bExpected = TRUE;
                    break;

                case RTCSS_INPROGRESS:
                
                    // corresponds to provisional responses
                    //
                    LOG((RTC_INFO, "[%p] CRTCCtl::OnSessionStateChangeEvent, new inprogress status", this));
                
                    // 
                    SetControlState(RTCAX_STATE_CONNECTING, StatusCode);
 
                    // change status for myself
                    // ChangeParticipantStateInList(NULL, ); 
                
                    bExpected = TRUE;
                    break;

                case RTCSS_ANSWERING:

                    if(m_nControlState == RTCAX_STATE_ANSWERING)
                    {
                        //
                        // Nothing to do here, the UI is already in the ANSWERING state
                        //

                        LOG((RTC_INFO, "[%p] CRTCCtl::OnSessionStateChangeEvent, answering event, do nothing", this));

                        bExpected = TRUE;
                    }

                    break;
                }
            }
            else
            {
                // This is a session other than the current session
                //
                if(SessionState == RTCSS_INPROGRESS)
                {
                    if(m_nControlState == RTCAX_STATE_DIALING)
                    {
                        // this is the call we're placing

                        ATLASSERT(m_pRTCActiveSession == NULL);

                        // cache the session
                        // we assume the session is not bogus

                        LOG((RTC_INFO, "[%p] CRTCCtl::OnSessionStateChangeEvent: setting active session [%p]", this, pSession));

                        m_pRTCActiveSession = pSession;
                
                        // Set the state to Connecting
                        SetControlState(RTCAX_STATE_CONNECTING, StatusCode);
            
                        bExpected = TRUE;
                    }
                }
                else if(SessionState == RTCSS_INCOMING)
                {
            
                    // This is an incoming call
                    // reject any incoming calls, we are busy !
                    //
                    LOG((RTC_INFO, "[%p] CRTCCtl::OnSessionStateChangeEvent, we're busy, calling Terminate", this));

                    hr = pSession -> Terminate(RTCTR_BUSY);

                    if(FAILED(hr))
                    {
                        LOG((RTC_ERROR, "[%p] CRTCCtl::OnSessionStateChangeEvent, Terminate returned error <%x>", this, hr));
                    }

                    bExpected = TRUE;
                }
            }
        }

        if(!bExpected && SessionState == RTCSS_DISCONNECTED)
        {
            bExpected = TRUE;
        }

        if(!bExpected)
        {
            // not expected
            LOG((RTC_ERROR, "[%p] CRTCCtl::OnSessionStateChangeEvent, unexpected state <Session:%x, UI:%x>", 
                    this, SessionState, m_nControlState));
            hr = E_UNEXPECTED;
        }
    }
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnSessionStateChangeEvent - exit", this));

    return hr;
}

// OnParticipantStateChangeEvent
//      Processes participant events
//
HRESULT CRTCCtl::OnParticipantStateChangeEvent(IRTCParticipantStateChangeEvent *pEvent)
{
    CComPtr<IRTCParticipant> pParticipant = NULL;
    RTC_PARTICIPANT_STATE   ParticipantState;
    long                StatusCode;
    HRESULT     hr;
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnParticipantStateChangeEvent - enter", this));

    if(!pEvent)
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnParticipantStateChangeEvent, no interface ! - exit", this));
        return E_UNEXPECTED;
    }
    
    hr = pEvent->get_Participant(&pParticipant);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnParticipantStateChangeEvent, error <%x> in get_Participant - exit", this, hr));
        return hr;
    }
    
    if(pParticipant==NULL)
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnParticipantStateChangeEvent, no participant interface ! - exit", this));
        return E_UNEXPECTED;
    }

    hr = pEvent->get_State(&ParticipantState);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnParticipantStateChangeEvent, error <%x> in get_State - exit", this, hr));
        return hr;
    }
    
    hr = pEvent->get_StatusCode(&StatusCode);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnParticipantStateChangeEvent, error <%x> in get_StatusCode - exit", this, hr));
        return hr;
    }
    
    hr = m_hParticipantList.Change(pParticipant, ParticipantState, StatusCode);
    
    if(ParticipantState == RTCPS_DISCONNECTED)
    {
        // refresh the Remove Participant button
        UpdateRemovePartButton();
    }
    
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnParticipantStateChangeEvent, error <%x> "
            "in m_hParticipantList.Change - exit", this, hr));
        
        return hr;
    }
  
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnParticipantStateChangeEvent - exit", this));

    return hr;
}

// OnClientEvent
//      Processes streaming events
//
HRESULT CRTCCtl::OnClientEvent(IRTCClientEvent *pEvent)
{
    HRESULT     hr;
    RTC_CLIENT_EVENT_TYPE nEventType;          

    LOG((RTC_TRACE, "[%p] CRTCCtl::OnClientEvent - enter", this));

    if(!pEvent)
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnClientEvent, no interface ! - exit", this));
        return E_UNEXPECTED;
    }
 
    // grab the event components
    //
    hr = pEvent->get_EventType(&nEventType);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnClientEvent, error <%x> in get_EventType - exit", this, hr));
        return hr;
    }

    if (nEventType == RTCCET_VOLUME_CHANGE)
    {
        //
        // Refresh the audio controls
        //

        RefreshAudioControls();
    }
    else if (nEventType == RTCCET_DEVICE_CHANGE)
    {
        if(m_pRTCClient!=NULL)
        {
            LONG lOldMediaCapabilities = m_lMediaCapabilities;

            //
            // Read capabilities from core
            //
            hr = m_pRTCClient->get_MediaCapabilities( &m_lMediaCapabilities );

            if(FAILED(hr))
            {
                LOG((RTC_ERROR, "[%p] CRTCCtl::OnClientEvent - "
                    "error (%x) returned by get_MediaCapabilities, exit",this,  hr));
            }
        
            //
            // Get media preferences
            //
            hr = m_pRTCClient->get_PreferredMediaTypes( &m_lMediaPreferences);
            if(FAILED(hr))
            {
                LOG((RTC_ERROR, "[%p] CRTCCtl::OnClientEvent - "
                    "error (%x) returned by get_PreferredMediaTypes, exit",this,  hr));
            }

            LONG lChangedMediaCapabilities = lOldMediaCapabilities ^ m_lMediaCapabilities;
            LONG lAddedMediaCapabilities = m_lMediaCapabilities & lChangedMediaCapabilities;
            LONG lRemovedMediaCapabilities = lChangedMediaCapabilities ^ lAddedMediaCapabilities;

            //
            // Add/Remove media types
            //

            put_MediaPreferences( m_lMediaPreferences | lAddedMediaCapabilities & ~lRemovedMediaCapabilities );
        }

        //
        // Refersh video and audio controls
        //

        RefreshVideoControls();
        RefreshAudioControls();
    }
    else if (nEventType == RTCCET_ASYNC_CLEANUP_DONE)
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnClientEvent, RTCCET_ASYNC_CLEANUP_DONE", this));

        SetEvent( m_hCoreShutdownEvent );
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::OnClientEvent - exit", this));

    return hr;
}

// OnMediaEvent
//      Processes streaming events
//
HRESULT CRTCCtl::OnMediaEvent(IRTCMediaEvent *pEvent)
{
    HRESULT     hr;
    RTC_MEDIA_EVENT_TYPE nEventType;
    RTC_MEDIA_EVENT_REASON nEventReason;
    LONG        lMediaType;           

    LOG((RTC_TRACE, "[%p] CRTCCtl::OnMediaEvent - enter", this));

    if(!pEvent)
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnMediaEvent, no interface ! - exit", this));
        return E_UNEXPECTED;
    }
 
    // grab the event components
    //
    hr = pEvent->get_EventType(&nEventType);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnMediaEvent, error <%x> in get_EventType - exit", this, hr));
        return hr;
    }

    hr = pEvent->get_EventReason(&nEventReason);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnMediaEvent, error <%x> in get_EventReason - exit", this, hr));
        return hr;
    }

    hr = pEvent->get_MediaType(&lMediaType);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnMediaEvent, error <%x> in get_MediaType - exit", this, hr));
        return hr;
    }
    
    LOG((RTC_TRACE, "[%p] CRTCCtl::OnMediaEvent - type %x, state %x", this, lMediaType, nEventType));

    hr = S_OK;

    if ((nEventType == RTCMET_STOPPED) &&
        (nEventReason == RTCMER_HOLD) )
    {
        SetControlState(m_nControlState, S_OK, IDS_SB_STATUS_HOLD);        
    }
    else
    {
        SetControlState(m_nControlState, S_OK);
    }

    //
    // Video event ?
    //
    if(lMediaType & (RTCMT_VIDEO_SEND | RTCMT_VIDEO_RECEIVE))
    {
        hr = S_OK;

        if(lMediaType & RTCMT_VIDEO_RECEIVE)
        {
            hr = OnVideoMediaEvent(TRUE, nEventType == RTCMET_STARTED);
        }

        if((lMediaType & RTCMT_VIDEO_SEND))
        {
            HRESULT hr1;

            hr1 = OnVideoMediaEvent(FALSE, nEventType == RTCMET_STARTED);

            if(FAILED(hr1) && SUCCEEDED(hr))
            {
                hr = hr1;
            }
        }
    }
    
    //
    // Audio event ?
    //

    if(lMediaType & (RTCMT_AUDIO_SEND | RTCMT_AUDIO_RECEIVE))
    {
        //
        // Muting might be automatically disabled, so keep the controls in sync
        //
        RefreshAudioControls();
    }

    //
    // Send Audio event (dialpad)
    //
    
    if(lMediaType & RTCMT_AUDIO_SEND)
    {
        hr = S_OK;                       

        if (nEventType == RTCMET_STARTED)
        {
            //
            // Enable the dialpad
            //

            CWindow *pDtmfCrt = m_hDtmfButtons;
            CWindow *pDtmfEnd = m_hDtmfButtons + NR_DTMF_BUTTONS;

            for (int id = IDC_DIAL_0; pDtmfCrt<pDtmfEnd; pDtmfCrt++, id++)
                 pDtmfCrt->EnableWindow(TRUE);

        }
        else if (nEventType == RTCMET_STOPPED)
        {
            //
            // Disable the dialpad
            //

            CWindow *pDtmfCrt = m_hDtmfButtons;
            CWindow *pDtmfEnd = m_hDtmfButtons + NR_DTMF_BUTTONS;

            for (int id = IDC_DIAL_0; pDtmfCrt<pDtmfEnd; pDtmfCrt++, id++)
                 pDtmfCrt->EnableWindow(FALSE);
        }
    }

    //
    // Are we streaming video?
    //

    if (m_pRTCClient != NULL)
    {
        long lMediaTypes = 0;

        hr = m_pRTCClient->get_ActiveMedia( &lMediaTypes );

        if ( SUCCEEDED(hr) )
        {
            m_bBackgroundPalette = 
                ( lMediaTypes & (RTCMT_VIDEO_SEND | RTCMT_VIDEO_RECEIVE) ) ? TRUE : FALSE;

            if (m_pSpeakerKnob != NULL)
            {
                m_pSpeakerKnob->SetBackgroundPalette(m_bBackgroundPalette);
            }

            if (m_pMicroKnob != NULL)
            {
                m_pMicroKnob->SetBackgroundPalette(m_bBackgroundPalette);
            }
        }
    }

    LOG((RTC_TRACE, "[%p] CRTCCtl::OnMediaEvent - exit", this));

    return hr;
}

// OnIntensityEvent
//      Processes Intensity monitor events
//
HRESULT CRTCCtl::OnIntensityEvent(IRTCIntensityEvent *pEvent)
{
    HRESULT     hr;

    LONG lMin, lMax, lLevel;
    RTC_AUDIO_DEVICE adDirection;

//    LOG((RTC_TRACE, "[%p] CRTCCtl::OnIntensityEvent - enter", this));

    if(!pEvent)
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnIntensityEvent, no interface ! - exit", this));
        return E_UNEXPECTED;
    }
 
    //
    // Get the min, max, value and direction of the stream.
    //


    hr = pEvent->get_Direction(&adDirection);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnIntensityEvent, error <%x> in get_Direction - exit", this, hr));
        return hr;
    }
    
    hr = pEvent->get_Min(&lMin);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnIntensityEvent, error <%x> in get_Min - exit", this, hr));
        return hr;
    }

    hr = pEvent->get_Max(&lMax);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnIntensityEvent, error <%x> in get_Max - exit", this, hr));
        return hr;
    }


    hr = pEvent->get_Level(&lLevel);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnIntensityEvent, error <%x> in get_Level - exit", this, hr));
        return hr;
    }

    // Log the value.
    //LOG((RTC_INFO, "[%p] CRTCCtl::OnIntensityEvent - [%d] %d - %d, %d", this, adDirection, lMin, lMax, lLevel));

    // Display the level on the knob.

    if (adDirection == RTCAD_MICROPHONE)
    {
        DWORD dwIncrement = lMax - lMin;

        if (dwIncrement == 0)
        {
            // This will clear the display
            m_pMicroKnob->SetAudioLevel(0);
        }
        else
        {
            m_pMicroKnob->SetAudioLevel((double)lLevel/(double)dwIncrement);
        }
    }
    if (adDirection == RTCAD_SPEAKER)
    {
        DWORD dwIncrement = lMax - lMin;

        if (dwIncrement == 0)
        {
            // This will clear the display
            m_pSpeakerKnob->SetAudioLevel(0);
        }
        else
        {
            m_pSpeakerKnob->SetAudioLevel((double)lLevel/(double)dwIncrement);
        }
    }

//    LOG((RTC_TRACE, "[%p] CRTCCtl::OnIntensityEvent - exit", this));

    return hr;
}

// OnMessageEvent
//      Processes instant message events
//
HRESULT CRTCCtl::OnMessageEvent(IRTCMessagingEvent *pEvent)
{
    HRESULT     hr;

    CComPtr<IRTCSession>      pSession = NULL;
    CComPtr<IRTCParticipant>  pParticipant = NULL;
    RTC_MESSAGING_EVENT_TYPE  enType;    

//    LOG((RTC_TRACE, "[%p] CRTCCtl::OnMessageEvent - enter", this));

    if(!pEvent)
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnMessageEvent, no interface ! - exit", this));
        return E_UNEXPECTED;
    }
 
    hr = pEvent->get_Session(&pSession);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnMessageEvent, error <%x> in get_Session - exit", this, hr));
        return hr;
    }
    
    if(pSession == NULL)
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnMessageEvent, no session interface ! - exit", this));
        return E_UNEXPECTED;
    }

    hr = pEvent->get_Participant(&pParticipant);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnMessageEvent, error <%x> in get_Participant - exit", this, hr));
        return hr;
    }
    
    if(pParticipant == NULL)
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnMessageEvent, no participant interface ! - exit", this));
        return E_UNEXPECTED;
    }

    hr = pEvent->get_EventType(&enType);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnMessageEvent, error <%x> in get_EventType - exit", this, hr));
        return hr;
    }

    switch ( enType )
    {
    case RTCMSET_MESSAGE:
        {
            BSTR                      bstrMessage = NULL;

            hr = pEvent->get_Message(&bstrMessage);
            if(FAILED(hr))
            {
                LOG((RTC_ERROR, "[%p] CRTCCtl::OnMessageEvent, error <%x> in get_Message - exit", this, hr));
                return hr;
            }

            if (bstrMessage == NULL)
            {
                LOG((RTC_ERROR, "[%p] CRTCCtl::OnMessageEvent, no message ! - exit", this));
                return E_UNEXPECTED;
            }

            if (m_pIMWindows != NULL)
            {
                hr = m_pIMWindows->DeliverMessage( pSession, pParticipant, bstrMessage );
            }

            SysFreeString( bstrMessage );
        }
        break;

    case RTCMSET_STATUS:
        {
            RTC_MESSAGING_USER_STATUS enStatus;

            hr = pEvent->get_UserStatus(&enStatus);
            if(FAILED(hr))
            {
                LOG((RTC_ERROR, "[%p] CRTCCtl::OnMessageEvent, error <%x> in get_Message - exit", this, hr));
                return hr;
            }

            if (m_pIMWindows != NULL)
            {
                hr = m_pIMWindows->DeliverUserStatus( pSession, pParticipant, enStatus );
            }
        }
        break;

    default:
        LOG((RTC_ERROR, "[%p] CRTCCtl::OnMessageEvent,invalid event type - exit", this));
        return E_FAIL;
    }

//    LOG((RTC_TRACE, "[%p] CRTCCtl::OnMessageEvent - exit", this));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\axctl\rtcobjectsafety.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCObjectSafety.h

Abstract:

    Implements IObjectSafety and IObjectWithSite

  Manages decision logic of whether RTC functionality should be allowed on 
  the current page. Checks persistent settings for this page and prompts with
  a dialog if necessary.

  Objects that need this protection (CRTCClient) derive from this
  class.

--*/

#ifndef __RTCOBJECTSAFETY__
#define __RTCOBJECTSAFETY__

#include "PromptedObjectSafety.h"
#include "ScrpScrtDlg.h"
#include "ObjectWithSite.h"

#define RTC_COOKIE_NAME _T("RTC")


class __declspec(novtable) CRTCObjectSafety : public CPromptedObjectSafety, public CObjectWithSite
{


public:
    
    //
    // call CObjectWithSite's constructor and pass in the cookie name
    //

    CRTCObjectSafety()
        :CObjectWithSite(RTC_COOKIE_NAME)
    {
    }


    //
    // implementing CPromptedObjectSafety's pure virtual method
    // if the page is not in the safe list, and this is the first 
    // time we are asking, prompt the user. act accordingly.
    // if the user chooses, mark the page safe for scripting (persistently)
    //
    
    virtual BOOL Ask()
    {

        //
        // if the object does not have a site pointer. we should not consider 
        // it to be safe. Do not prompt the user
        //

        if ( !HaveSite() )
        {

            return FALSE;
        }


        EnValidation enCurrentValidation = GetValidation();
        
        //
        // if the page has not been validated, try to validate it.
        //

        if (UNVALIDATED == enCurrentValidation)
        {

           CScriptSecurityDialog *pDialog = new CScriptSecurityDialog;
       
           //
           // if succeeded displaying the dialog
           // validate the page based on user's input
           //
           
           if ( NULL != pDialog )
           {

               switch (pDialog->DoModalWithText(IDS_RTC_SEC_PROMPT))
               {

                case ID_YES:

                    Validate(VALIDATED_SAFE);
                    break;

                case ID_NO:

                    Validate(VALIDATED_UNSAFE);
                    break;

                case ID_YES_DONT_ASK_AGAIN:

                    Validate(VALIDATED_SAFE_PERMANENT);
                    break;

                default:

                    break;

               }

               delete pDialog;

                // 
                // get the new validation.
                //

                enCurrentValidation = GetValidation();

           } // if (NULL != pDialog) 

        }

        //
        // by now we either got the validation data or validation did not change
        //
        // return true if the page is validated as safe
        //

        return (VALIDATED_SAFE == enCurrentValidation);
    }

};

#endif // __RTCOBJECTSAFETY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\axctl\scrpscrtdlg.h ===
// DlgAddr.h : Declaration of the CScriptSecurityDialog

#ifndef __SCRIPTSECURITYDIALOG_H_
#define __SCRIPTSECURITYDIALOG_H_

#include "ctlres.h"

/////////////////////////////////////////////////////////////////////////////
// CScriptSecurityDialog


//
// this class is not thread safe
//

class CScriptSecurityDialog : 
	public CDialogImpl<CScriptSecurityDialog>
{

public:

    CScriptSecurityDialog() : m_psMessageText(NULL)
    {}

    INT_PTR DoModalWithText(UINT uResourceID, HWND hWndParent = ::GetActiveWindow())
    {		
        //
        // this assertion could fail is if the class is used from 
        // a multithreaded app, and domodalX is called on two different threads
        // the class is not thread safe and this should be caught during 
        // testing.
        // another way this assert could fire is if the class itself is
        // broken. this, too, is a test-time error. 
        //
                
        _ASSERTE(NULL == m_psMessageText);

        //
        // load string from resource module
        //

        m_psMessageText = SafeLoadString(uResourceID);


        // 
        // if failed, bail out now
        //

        if (NULL == m_psMessageText)
        {
            return -1;
        }

        
        //
        // attempt to display the dialog box
        // the string is used in OnInitDialog to set the dialog's text
        //
        
        INT_PTR rc = _DoModal(hWndParent);

        //
        // deallocate string
        //

        delete m_psMessageText;
        m_psMessageText = NULL;

        return rc;
    }



    INT_PTR DoModalWithText(LPTSTR psMessageText, HWND hWndParent = ::GetActiveWindow())
    {    	
        //
        // this assertion could fail is if the class is used from 
        // a multithreaded app, and domodalX is called on two different threads
        // the class is not thread safe and this should be caught during 
        // testing.
        // another way this assert could fire is if the class itself is
        // broken. this, too, is a test-time error. 
        //

        _ASSERTE(NULL == m_psMessageText);

        //
        // the dialog is modal, so the lifetime of psMessageText is guaranteed 
        // to exceed the lifetime of the dialog.
        //

        m_psMessageText = psMessageText;

        
        //
        // attempt to display the dialog. the string will be used to set 
        // the message text in OnInitDialog
        // 

        INT_PTR rc = _DoModal(hWndParent);

        //
        // no longer need the string + the string cannot be assumed 
        // valid after we return
        //
        
        m_psMessageText = NULL;
		
        return rc;
    }

	enum { IDD = IDD_RTC_SECURITY_DIALOG };


public:

BEGIN_MSG_MAP(CScriptSecurityDialog)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_ID_HANDLER(ID_YES, OnYes)
	COMMAND_ID_HANDLER(ID_NO, OnNo)
END_MSG_MAP()



//
// Attributes
//

private:

    //
    // the prompt text
    //

    LPTSTR m_psMessageText;
    

protected:

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {   
        //
        // m_psMessageText must be set before _DoModal is called
        // if m_psMessageText is null here, the error is in the class itself
        // and this should be detected during testing
        //

        _ASSERTE(NULL != m_psMessageText);


        //
        // display the text that was passed into DoModalWithText as a string 
        // or a resources
        //

        SetDlgItemText(IDC_SECURITY_WARNING_TEXT, m_psMessageText);

	    return TRUE;
    }

	LRESULT OnYes(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        //
        // see if do not ask in the future is set
        // 
        
        if (IsDlgButtonChecked(IDC_DONOT_PROMPT_IN_THE_FUTURE))
            wID = ID_YES_DONT_ASK_AGAIN;

        EndDialog(wID);
       
        return FALSE;
    }


    LRESULT OnNo(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        
        EndDialog(wID);
        
        return FALSE;
    }

	
private:

    INT_PTR _DoModal(HWND hWndParent)
    {
        
        //
        // otherwise, attempt to display the dialog box
        //

        _ASSERTE(m_hWnd == NULL);
        _Module.AddCreateWndData(&m_thunk.cd, (CDialogImplBase*)this);
        INT_PTR nRet = ::DialogBoxParam(_Module.GetResourceInstance(),
                        MAKEINTRESOURCE(CScriptSecurityDialog::IDD),
                        hWndParent,
                        CScriptSecurityDialog::StartDialogProc,
                        NULL);

 
        m_hWnd = NULL;
        return nRet;
    }


private:

    //
    // Load string for this resource. Safe with respect to string size
    //
    
    TCHAR *SafeLoadString( UINT uResourceID )
    {

        TCHAR *pszTempString = NULL;

        int nCurrentSizeInChars = 128;
        
        int nCharsCopied = 0;
        
        do
        {

            if ( NULL != pszTempString )
            {
                delete  pszTempString;
                pszTempString = NULL;
            }

            nCurrentSizeInChars *= 2;

            pszTempString = new TCHAR[ nCurrentSizeInChars ];

            if (NULL == pszTempString)
            {
                return NULL;
            }

            nCharsCopied = ::LoadString( _Module.GetResourceInstance(),
                                         uResourceID,
                                         pszTempString,
                                         nCurrentSizeInChars
                                        );

            if ( 0 == nCharsCopied )
            {
                delete pszTempString;
                return NULL;
            }

            //
            // nCharsCopied does not include the null terminator
            // so compare it to the size of the buffer - 1
            // if the buffer was filled completely, retry with a bigger buffer
            //

        } while ( (nCharsCopied >= (nCurrentSizeInChars - 1) ) );

        return pszTempString;
    }


    //
    // private, not to be called. the dialog must be created with DoModalWithText
    //

    HWND Create(HWND hWndParent, LPCTSTR psMessageText = NULL)
    {
        // this dialog must be created as modal

        _ASSERTE(FALSE);

        return NULL;
    }

    //
    // private, not to be called. the dialog must be created with DoModalWithText
    //

    INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow())
    {
        _ASSERTE(FALSE);

        return -1;
    }


};

#endif //__SCRIPTSECURITYDIALOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\axctl\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A29A9105_0AC9_4F8B_AF30_ACFE3CB5E7FF__INCLUDED_)
#define AFX_STDAFX_H__A29A9105_0AC9_4F8B_AF30_ACFE3CB5E7FF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#define ATL_TRACE_LEVEL     2 

#define OEMRESOURCE     // setting this gets OIC_ constants in windows.h

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <atlbase.h>

#include <commctrl.h>
#include <math.h>
#include <wtsapi32.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlhost.h>
#include <atlctl.h>

#include <rtclog.h>
#include <rtcmem.h>
#include <rtcdib.h>

#include <rtcctl.h>
#include <rtcaxctl.h>
#include <rtcerr.h>
#include <rtcutil.h>
#include <ui.h>
#include <rtcuri.h>
#include <im.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A29A9105_0AC9_4F8B_AF30_ACFE3CB5E7FF__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\axctl\rtcctl.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCCTL.cpp

Abstract:

    Implementation of DLL exports.

--*/

#include "stdafx.h"
#include "ctlres.h"
#include <initguid.h>

#include "RTCCtl_i.c"

//
// For the ntbuild environment we need to include this file to get the base
//  class implementations.

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>
#include "provstore.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_RTCCtl, CRTCCtl)
OBJECT_ENTRY(CLSID_RTCProvStore, CRTCProvStore)
END_OBJECT_MAP()

WCHAR   g_szDllContextHelpFileName[] = L"RTCCTL.HLP";


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        LOGREGISTERDEBUGGER(_T("RTCCTL"));

        LOG((RTC_TRACE, "DllMain - DLL_PROCESS_ATTACH"));

        //
        // Create a heap for memory allocation
        //

        if ( RtcHeapCreate() == FALSE )
        {
            return FALSE;
        }
               
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);       
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        LOG((RTC_TRACE, "DllMain - DLL_PROCESS_DETACH"));
        
#if DBG
        //
        // Make sure we didn't leak anything
        //
             
        RtcDumpMemoryList();
#endif

        //
        // Destroy the heap
        //
        
        RtcHeapDestroy();        

        //
        // Unregister for debug tracing
        //
        
        LOGDEREGISTERDEBUGGER() ;

        _Module.Term();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // There are two typelibraries...
    HRESULT hr;

    hr = _Module.RegisterServer(TRUE);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer(TRUE);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\rtcbuddy.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCBuddy.cpp

Abstract:

    Definition of the CRTCBuddy class

--*/
#include "stdafx.h"


/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::FinalConstruct
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCBuddy::FinalConstruct()
{
    LOG((RTC_TRACE, "CRTCBuddy::FinalConstruct [%p] - enter", this));

#if DBG
    m_pDebug = (PWSTR) RtcAlloc( sizeof(void *) );
    *((void **)m_pDebug) = this;
#endif

    LOG((RTC_TRACE, "CRTCBuddy::FinalConstruct [%p] - exit S_OK", this));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCBuddy::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCBuddy::FinalRelease [%p] - enter", this));

    RemoveSIPBuddy(FALSE);

    if ( m_pCClient != NULL )
    {
        m_pCClient->Release();
        m_pCClient = NULL;
    }

    if ( m_pSIPBuddyManager != NULL )
    {
        m_pSIPBuddyManager->Release();
        m_pSIPBuddyManager = NULL;
    }

    if ( m_pProfile != NULL )
    {
        m_pProfile->Release();
        m_pProfile = NULL;
    }

    if ( m_szName != NULL )
    {
        RtcFree(m_szName);
        m_szName = NULL;
    }
    
    if ( m_szData != NULL )
    {
        RtcFree(m_szData);
        m_szData = NULL;
    }

    if ( m_szPresentityURI != NULL )
    {
        RtcFree(m_szPresentityURI);
        m_szPresentityURI = NULL;
    }

    if ( m_szNotes != NULL )
    {
        RtcFree(m_szNotes);
        m_szNotes = NULL;
    }

    if ( m_pSipRedirectContext != NULL )
    {
        m_pSipRedirectContext->Release();
        m_pSipRedirectContext = NULL;
    }

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    LOG((RTC_TRACE, "CRTCBuddy::FinalRelease [%p] - exit", this));
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::InternalAddRef
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CRTCBuddy::InternalAddRef()
{
    DWORD dwR;

    dwR = InterlockedIncrement(&m_dwRef);

    LOG((RTC_INFO, "CRTCBuddy::InternalAddRef [%p] - dwR %d", this, dwR));

    return dwR;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::InternalRelease
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CRTCBuddy::InternalRelease()
{
    DWORD               dwR;
    
    dwR = InterlockedDecrement(&m_dwRef);

    LOG((RTC_INFO, "CRTCBuddy::InternalRelease [%p] - dwR %d", this, dwR));

    return dwR;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::Initialize
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCBuddy::Initialize(
                        CRTCClient       * pCClient,      
                        ISIPBuddyManager * pSIPBuddyManager,
                        PCWSTR             szPresentityURI,
                        PCWSTR             szName,
                        PCWSTR             szData,
                        BOOL               bPersistent,
                        IRTCProfile      * pProfile,
                        long               lFlags
                        )
{
    LOG((RTC_TRACE, "CRTCBuddy::Initialize - enter"));

    HRESULT hr;

    if ( IsBadReadPtr( pCClient, sizeof(CRTCClient) ) )
    {
        LOG((RTC_ERROR, "CRTCBuddy::Initialize - "
                            "bad CRTCClient pointer"));

        return E_POINTER;
    }

    if ( IsBadReadPtr( pSIPBuddyManager, sizeof(ISIPBuddyManager) ) )
    {
        LOG((RTC_ERROR, "CRTCBuddy::Initialize - "
                            "bad ISIPBuddyManager pointer"));

        return E_POINTER;
    }

    m_szPresentityURI = RtcAllocString(szPresentityURI);
    m_szName = RtcAllocString(szName);
    m_szData = RtcAllocString(szData);

    m_bPersistent = bPersistent;

    m_pCClient = pCClient;
    if ( m_pCClient )
    {
        m_pCClient->AddRef();
    }

    m_pSIPBuddyManager = pSIPBuddyManager;
    if ( m_pSIPBuddyManager )
    {
        m_pSIPBuddyManager->AddRef();
    }

    m_pProfile = pProfile;
    if ( m_pProfile )
    {
        m_pProfile->AddRef();
    }

    m_lFlags = lFlags;

    hr = CreateSIPBuddy();

    if ( FAILED(hr) )
    {
        LOG((RTC_WARN, "CRTCBuddy::Initialize - "
                        "CreateSIPBuddy failed 0x%lx", hr));
    }        

    LOG((RTC_TRACE, "CRTCBuddy::Initialize - exit S_OK"));

    return S_OK;
} 


/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::CreateSIPBuddy
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCBuddy::CreateSIPBuddy()
{
    LOG((RTC_TRACE, "CRTCBuddy::CreateSIPBuddy - enter"));

    HRESULT     hr;

    // reset the cached error
    m_hrStatusCode = S_OK;
    
    hr = CreateSIPBuddyHelper();

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCBuddy::CreateSIPBuddy - "
                            "CreateSIPBuddyHelper failed 0x%lx", hr));
        // we have an "event"...
        m_hrStatusCode = hr;

        CRTCBuddyEvent::FireEvent( m_pCClient, this );
    }
    
    LOG((RTC_TRACE, "CRTCBuddy::CreateSIPBuddy - exit"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::CreateSIPBuddyHelper
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCBuddy::CreateSIPBuddyHelper()
{
    LOG((RTC_TRACE, "CRTCBuddy::CreateSIPBuddyHelper - enter"));

    HRESULT hr;
    
    BSTR bstrLocalUserName = NULL;
    BSTR bstrLocalUserURI = NULL;   

    //
    // Choose the best profile if needed
    //

    if ( !(m_lFlags & RTCCS_FORCE_PROFILE) )
    {
        IRTCProfile * pProfile = NULL;
        RTC_SESSION_TYPE enType = RTCST_PC_TO_PC;

        hr = m_pCClient->GetBestProfile(
                &enType,
                m_szPresentityURI,
                (m_pSipRedirectContext != NULL),
                &pProfile
                );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::CreateSIPBuddyHelper - "
                                "GetBestProfile failed 0x%lx", hr));

            return hr;
        }

        if ( m_pProfile != NULL )
        {
            m_pProfile->Release();
            m_pProfile = NULL;
        }

        m_pProfile = pProfile;
    }

    LOG((RTC_INFO, "CRTCSession::CreateSIPBuddyHelper - "
                                "profile [%p]", m_pProfile));

    //
    // Get profile info
    //

    SIP_PROVIDER_ID ProviderID = GUID_NULL;
    SIP_SERVER_INFO Proxy;            
    CRTCProfile * pCProfile = NULL;

    if ( m_pProfile != NULL )
    {
        //
        // Get pointer to profile object
        //

        pCProfile = static_cast<CRTCProfile *>(m_pProfile);  

        //
        // Get the SIP provider ID from the profile. If the profile is NULL
        // then this call has no provider. In that case we just use GUID_NULL.
        //

        pCProfile->GetGuid( &ProviderID );
        
        //
        // Determine supported session types for this profile
        //

        long lSupportedSessions;

        hr = m_pProfile->get_SessionCapabilities( &lSupportedSessions );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCBuddy::CreateSIPBuddyHelper - "
                                "get_SessionCapabilities failed 0x%lx", hr));           

            return hr;
        }

        //
        // Validate session type
        //

        if ( !(RTCSI_PC_TO_PC & lSupportedSessions) )
        {
            LOG((RTC_ERROR, "CRTCBuddy::CreateSIPBuddyHelper - "
                                "session type is not supported by this profile"));

            return E_FAIL;
        }              
    }

    //
    // Get local user name
    // 
    
    if ( m_pProfile != NULL )
    { 
        hr = m_pProfile->get_UserName( &bstrLocalUserName );

        if ( FAILED(hr) )
        {
            LOG((RTC_WARN, "CRTCBuddy::CreateSIPBuddyHelper - "
                                "get_UserName failed 0x%lx", hr));
        }
    }

    if ( (m_pProfile == NULL) || FAILED(hr) ) 
    {
        hr = m_pCClient->get_LocalUserName( &bstrLocalUserName );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCBuddy::CreateSIPBuddyHelper - "
                                "get_LocalUserName failed 0x%lx", hr));

            return hr;
        }
    }

    //
    // Get local user URI
    //

    if ( m_pProfile != NULL )
    { 
        hr = m_pProfile->get_UserURI( &bstrLocalUserURI );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCBuddy::CreateSIPBuddyHelper - "
                                "get_UserURI failed 0x%lx", hr));
            
            SysFreeString( bstrLocalUserName );
            bstrLocalUserName = NULL;

            return hr;
        }
    }
    else
    {
        hr = m_pCClient->get_LocalUserURI( &bstrLocalUserURI );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCBuddy::CreateSIPBuddyHelper - "
                                "get_LocalUserURI failed 0x%lx", hr));
           
            SysFreeString( bstrLocalUserName );
            bstrLocalUserName = NULL;

            return hr;
        }
    }

    //
    // Get SIP proxy info
    //

    if ( pCProfile != NULL )
    {        
        hr = pCProfile->GetSipProxyServerInfo( RTCSI_PC_TO_PC, &Proxy );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::CreateSipSession - "
                                "GetSipProxyServerInfo failed 0x%lx", hr));

            SysFreeString( bstrLocalUserName );
            bstrLocalUserName = NULL;

            SysFreeString( bstrLocalUserURI );
            bstrLocalUserURI = NULL;

            return hr;
        } 
    }

    //
    // Is this a redirect?
    //

    BSTR bstrRedirectURI = NULL;
    BSTR bstrRedirectName = NULL;

    if ( m_pSipRedirectContext != NULL )
    {
        LOG((RTC_INFO, "CRTCSession::CreateSipSession - "
                                "redirecting buddy"));

        hr = m_pSipRedirectContext->Advance();

        if ( hr != S_OK )
        {
            if ( hr == S_FALSE )
            {
                LOG((RTC_ERROR, "CRTCSession::CreateSipSession - "
                                    "redirect list empty"));
            }
            else
            {
                LOG((RTC_ERROR, "CRTCSession::CreateSipSession - "
                                    "Advance failed 0x%lx", hr));
            }

            SysFreeString( bstrLocalUserName );
            bstrLocalUserName = NULL;

            SysFreeString( bstrLocalUserURI );
            bstrLocalUserURI = NULL;

            return hr;
        } 

        hr = m_pSipRedirectContext->GetSipUrlAndDisplayName( &bstrRedirectURI, &bstrRedirectName );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::CreateSipSession - "
                                "GetSipUrlAndDisplayName failed 0x%lx", hr));

            SysFreeString( bstrLocalUserName );
            bstrLocalUserName = NULL;

            SysFreeString( bstrLocalUserURI );
            bstrLocalUserURI = NULL;

            return hr;
        }
    }

    //
    // Create a SIP buddy
    //

    ISIPBuddy * pSIPBuddy = NULL;

    hr = m_pSIPBuddyManager->AddBuddy(
            bstrLocalUserName,
            bstrRedirectURI ? bstrRedirectURI : m_szPresentityURI,
            bstrLocalUserURI,
            &ProviderID,
            (pCProfile != NULL) ? &Proxy : NULL,
            m_pSipRedirectContext,
            &pSIPBuddy );

    SysFreeString( bstrRedirectURI );
    bstrRedirectURI = NULL;

    SysFreeString( bstrRedirectName );
    bstrRedirectName = NULL;

    SysFreeString( bstrLocalUserName );
    bstrLocalUserName = NULL;

    SysFreeString( bstrLocalUserURI );
    bstrLocalUserURI = NULL;

    if (pCProfile != NULL)
    {
        pCProfile->FreeSipServerInfo( &Proxy );
    }

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCBuddy::CreateSIPBuddyHelper - AddBuddy failed 0x%lx", hr));

        return hr;
    }

    //
    // Set the notify interface
    //

    hr = pSIPBuddy->SetNotifyInterface(this);

    if ( FAILED(hr) )
    {        
        LOG((RTC_ERROR, "CRTCBuddy::CreateSIPBuddyHelper - "
                        "SetNotifyInterface failed 0x%lx", hr));

        pSIPBuddy->Release();

        return hr;
    }    

    //
    // Free the old buddy if it exists
    //

    if ( m_pSIPBuddy != NULL )
    {
        RemoveSIPBuddy(FALSE);
    }

    //
    // Store the new buddy
    //

    m_pSIPBuddy = pSIPBuddy;
    m_enStatus = RTCXS_PRESENCE_OFFLINE;

    if ( m_szNotes != NULL )
    {
        RtcFree( m_szNotes );
        m_szNotes = NULL;
    }

    LOG((RTC_TRACE, "CRTCBuddy::CreateSIPBuddyHelper - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::RemoveSIPBuddy
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCBuddy::RemoveSIPBuddy(BOOL bShutdown)
{
    LOG((RTC_TRACE, "CRTCBuddy::RemoveSIPBuddy - enter"));

    HRESULT hr; 

    if ( m_pSIPBuddy != NULL )
    {       
        hr = m_pSIPBuddyManager->RemoveBuddy(
                m_pSIPBuddy,
                bShutdown ? APPLICATION_SHUTDOWN : BUDDY_REMOVED_BYUSER);

        if ( FAILED(hr) )
        {        
            LOG((RTC_ERROR, "CRTCBuddy::RemoveSIPBuddy - "
                            "RemoveBuddy failed 0x%lx", hr));
        }
        
        //
        // If this is not for shutdown, release the SIP buddy now
        //

        if (!bShutdown)
        {
            hr = m_pSIPBuddy->SetNotifyInterface(NULL);

            if ( FAILED(hr) )
            {        
                LOG((RTC_ERROR, "CRTCBuddy::RemoveSIPBuddy - "
                                "SetNotifyInterface failed 0x%lx", hr));
            }

            m_pSIPBuddy->Release();
            m_pSIPBuddy = NULL;
        }
    }

    m_bShutdown = bShutdown;

    LOG((RTC_TRACE, "CRTCBuddy::RemoveSIPBuddy - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::CreateXMLDOMNode
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCBuddy::CreateXMLDOMNode( IXMLDOMDocument * pXMLDoc, IXMLDOMNode ** ppXDN )
{
    IXMLDOMNode    * pBuddyInfo = NULL;
    IXMLDOMElement * pElement = NULL;
    HRESULT hr;

    LOG((RTC_TRACE, "CRTCBuddy::CreateXMLDOMNode - enter"));

    hr = pXMLDoc->createNode( CComVariant(NODE_ELEMENT), CComBSTR(_T("BuddyInfo")), NULL, &pBuddyInfo );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCBuddy::CreateXMLDOMNode - "
                        "createNode failed 0x%lx", hr));

        return hr;
    }
    
    hr = pBuddyInfo->QueryInterface( IID_IXMLDOMElement, (void**)&pElement );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCBuddy::CreateXMLDOMNode - "
                        "QueryInterface failed 0x%lx", hr));

        pBuddyInfo->Release();

        return hr;
    }

    if (m_szPresentityURI != NULL)
    {
        hr = pElement->setAttribute( CComBSTR(_T("Presentity")), CComVariant( m_szPresentityURI ) );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCBuddy::CreateXMLDOMNode - "
                        "setAttribute(Presentity) failed 0x%lx", hr));

            pElement->Release();
            pBuddyInfo->Release();

            return hr;
        }
    }

    if (m_szName != NULL)
    {
        hr = pElement->setAttribute( CComBSTR(_T("Name")), CComVariant( m_szName ) );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCBuddy::CreateXMLDOMNode - "
                        "setAttribute(Name) failed 0x%lx", hr));

            pElement->Release();
            pBuddyInfo->Release();

            return hr;
        }
    }

    if (m_szData != NULL)
    {
        hr = pElement->setAttribute( CComBSTR(_T("Data")), CComVariant( m_szData ) );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCBuddy::CreateXMLDOMNode - "
                        "setAttribute(Data) failed 0x%lx", hr));

            pElement->Release();
            pBuddyInfo->Release();

            return hr;
        }
    }

    pElement->Release();

    *ppXDN = pBuddyInfo;

    LOG((RTC_TRACE, "CRTCBuddy::CreateXMLDOMNode - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::GetClient
//
/////////////////////////////////////////////////////////////////////////////

CRTCClient * 
CRTCBuddy::GetClient()
{
    LOG((RTC_TRACE, "CRTCBuddy::GetClient"));

    return m_pCClient;
} 


/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::get_PresentityURI
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCBuddy::get_PresentityURI(
        BSTR * pbstrPresentityURI
        )
{
    LOG((RTC_TRACE, "CRTCBuddy::get_PresentityURI - enter"));

    if ( IsBadWritePtr( pbstrPresentityURI, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCBuddy::get_PresentityURI - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szPresentityURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCBuddy::get_PresentityURI - "
                            "buddy has no address"));

        return E_FAIL;
    }

    //
    // Allocate the BSTR to be returned
    //
    
    *pbstrPresentityURI = SysAllocString(m_szPresentityURI);

    if ( *pbstrPresentityURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCBuddy::get_PresentityURI - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }    
    
    LOG((RTC_TRACE, "CRTCBuddy::get_PresentityURI - exit S_OK"));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::put_PresentityURI
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCBuddy::put_PresentityURI(
        BSTR bstrPresentityURI
        )
{
    LOG((RTC_TRACE, "CRTCBuddy::put_PresentityURI - enter"));

    HRESULT hr;

    if ( IsBadStringPtrW( bstrPresentityURI, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCBuddy::put_PresentityURI - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    //
    // Clean the presentity URI
    //

    PWSTR szCleanPresentityURI = NULL;

    AllocCleanSipString( bstrPresentityURI, &szCleanPresentityURI );

    if ( szCleanPresentityURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCBuddy::put_PresentityURI - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    //
    // Is this different than the existing presentity URI?
    //

    if ( !IsEqualURI( m_szPresentityURI, szCleanPresentityURI ) )
    {
        //
        // Don't allow duplicates
        //

        IRTCBuddy *pBuddy = NULL;

        hr = m_pCClient->FindBuddyByURI(
            szCleanPresentityURI,
            &pBuddy);

        if (hr == S_OK)
        {
            RtcFree( szCleanPresentityURI );
            szCleanPresentityURI = NULL;

            pBuddy->Release();
            pBuddy = NULL;
        
            LOG((RTC_ERROR, "CRTCBuddy::put_PresentityURI - "
                                "duplicate buddy"));

            return E_FAIL;
        }

        //
        // Recreate the SIP buddy
        //

        PWSTR szOldPresentityURI = m_szPresentityURI;
      
        m_szPresentityURI = szCleanPresentityURI;    
        szCleanPresentityURI = NULL;
        
        hr = CreateSIPBuddy();

        if ( FAILED(hr) )
        {
            LOG((RTC_WARN, "CRTCBuddy::put_PresentityURI - CreateSIPBuddy failed 0x%lx", hr));
        }

        if ( szOldPresentityURI != NULL )
        {
            RtcFree( szOldPresentityURI );
            szOldPresentityURI = NULL;
        }

        //
        // Update storage
        //

        if ( m_bPersistent )
        {
            m_pCClient->UpdatePresenceStorage();
        }
    }
    else
    {
        RtcFree( szCleanPresentityURI );
        szCleanPresentityURI = NULL;
    }
    
    LOG((RTC_TRACE, "CRTCBuddy::put_PresentityURI - exit S_OK"));

    return S_OK;
}              

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::get_Name
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCBuddy::get_Name(
        BSTR * pbstrName
        )
{
    LOG((RTC_TRACE, "CRTCBuddy::get_Name - enter"));

    if ( IsBadWritePtr( pbstrName, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCBuddy::get_Name - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szName == NULL )
    {
        LOG((RTC_ERROR, "CRTCBuddy::get_Name - "
                            "buddy has no name"));

        return E_FAIL;
    }

    //
    // Allocate the BSTR to be returned
    //
    
    *pbstrName = SysAllocString(m_szName);

    if ( *pbstrName == NULL )
    {
        LOG((RTC_ERROR, "CRTCBuddy::get_Name - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }    
    
    LOG((RTC_TRACE, "CRTCBuddy::get_Name - exit S_OK"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::put_Name
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCBuddy::put_Name(
        BSTR bstrName
        )
{
    LOG((RTC_TRACE, "CRTCBuddy::put_Name - enter"));

    if ( IsBadStringPtrW( bstrName, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCBuddy::put_Name - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szName != NULL )
    {
        RtcFree( m_szName );
        m_szName = NULL;
    }

    m_szName = RtcAllocString( bstrName );    

    if ( m_szName == NULL )
    {
        LOG((RTC_ERROR, "CRTCBuddy::put_Name - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    } 
    
    //
    // Update storage
    //

    if ( m_bPersistent )
    {
        m_pCClient->UpdatePresenceStorage();
    }
    
    LOG((RTC_TRACE, "CRTCBuddy::put_Name - exit S_OK"));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::get_Data
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCBuddy::get_Data(
        BSTR * pbstrData
        )
{
    LOG((RTC_TRACE, "CRTCBuddy::get_Data - enter"));

    if ( IsBadWritePtr( pbstrData, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCBuddy::get_Data - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szData == NULL )
    {
        LOG((RTC_ERROR, "CRTCBuddy::get_Data - "
                            "buddy has no guid string"));

        return E_FAIL;
    }

    //
    // Allocate the BSTR to be returned
    //
    
    *pbstrData = SysAllocString(m_szData);

    if ( *pbstrData == NULL )
    {
        LOG((RTC_ERROR, "CRTCBuddy::get_Data - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }    
    
    LOG((RTC_TRACE, "CRTCBuddy::get_Data - exit S_OK"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::put_Data
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCBuddy::put_Data(
        BSTR bstrData
        )
{
    LOG((RTC_TRACE, "CRTCBuddy::put_Data - enter"));

    if ( IsBadStringPtrW( bstrData, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCBuddy::put_Data - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szData != NULL )
    {
        RtcFree( m_szData );
        m_szData = NULL;
    }

    m_szData = RtcAllocString( bstrData );    

    if ( m_szData == NULL )
    {
        LOG((RTC_ERROR, "CRTCBuddy::put_Data - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }  
    
    //
    // Update storage
    //

    if ( m_bPersistent )
    {
        m_pCClient->UpdatePresenceStorage();
    }
    
    LOG((RTC_TRACE, "CRTCBuddy::put_Data - exit S_OK"));

    return S_OK;
}      

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::get_Persistent
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCBuddy::get_Persistent(
            VARIANT_BOOL * pfPersistent
            )
{
    LOG((RTC_TRACE, "CRTCBuddy::get_Persistent - enter"));

    if ( IsBadWritePtr( pfPersistent, sizeof(VARIANT_BOOL) ) )
    {
        LOG((RTC_ERROR, "CRTCBuddy::pfPersistent - "
                            "bad pointer"));

        return E_POINTER;
    }

    *pfPersistent = m_bPersistent ? VARIANT_TRUE : VARIANT_FALSE;

    LOG((RTC_TRACE, "CRTCBuddy::get_Persistent - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::put_Persistent
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCBuddy::put_Persistent(
            VARIANT_BOOL fPersistent
            )
{
    LOG((RTC_TRACE, "CRTCBuddy::put_Persistent - enter"));

    m_bPersistent = fPersistent ? TRUE : FALSE;

    //
    // Update storage
    //

    m_pCClient->UpdatePresenceStorage();

    LOG((RTC_TRACE, "CRTCBuddy::put_Persistent - exit"));

    return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::get_Status
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCBuddy::get_Status(
            RTC_PRESENCE_STATUS * penStatus
            )
{
    LOG((RTC_TRACE, "CRTCBuddy::get_Status - enter"));

    if ( IsBadWritePtr( penStatus, sizeof(RTC_PRESENCE_STATUS) ) )
    {
        LOG((RTC_ERROR, "CRTCBuddy::get_Status - "
                            "bad pointer"));

        return E_POINTER;
    }

    // return error if presence info couldn't be found
    if(FAILED(m_hrStatusCode))
    {
        LOG((RTC_TRACE, "CRTCBuddy::get_Status - returning cached error code"));
        
        return m_hrStatusCode;
    }

    *penStatus = m_enStatus;

    LOG((RTC_TRACE, "CRTCBuddy::get_Status - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::get_Notes
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCBuddy::get_Notes(
        BSTR * pbstrNotes
        )
{
    LOG((RTC_TRACE, "CRTCBuddy::get_Notes - enter"));

    if ( IsBadWritePtr( pbstrNotes, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCBuddy::get_Notes - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    // return error if presence info couldn't be found
    if(FAILED(m_hrStatusCode))
    {
        LOG((RTC_TRACE, "CRTCBuddy::get_Notes - returning cached error code"));
        
        return m_hrStatusCode;
    }

    if ( m_szNotes == NULL )
    {
        LOG((RTC_ERROR, "CRTCBuddy::get_Notes - "
                            "buddy has no notes"));

        return E_FAIL;
    }

    //
    // Allocate the BSTR to be returned
    //
    
    *pbstrNotes = SysAllocString(m_szNotes);

    if ( *pbstrNotes == NULL )
    {
        LOG((RTC_ERROR, "CRTCBuddy::get_Notes - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }    
    
    LOG((RTC_TRACE, "CRTCBuddy::get_Notes - exit S_OK"));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::NotifyRedirect
//
/////////////////////////////////////////////////////////////////////////////  
STDMETHODIMP
CRTCBuddy::NotifyRedirect(
        IN  ISipRedirectContext    *pRedirectContext,
        IN  SIP_CALL_STATUS        *pCallStatus
        )
{
    LOG((RTC_TRACE, "CRTCBuddy::NotifyRedirect - enter"));

    HRESULT hr;

    //
    // Save the redirect context
    //

    if ( m_pSipRedirectContext != NULL )
    {
        m_pSipRedirectContext->Release();
        m_pSipRedirectContext = NULL;
    }

    m_pSipRedirectContext = pRedirectContext;
    m_pSipRedirectContext->AddRef();

    //
    // Free the old buddy if it exists
    //

    if ( m_pSIPBuddy != NULL )
    {
        RemoveSIPBuddy(FALSE);
    }

    //
    // Recreate the SIP buddy
    //

    hr = CreateSIPBuddy();

    m_pSipRedirectContext->Release();
    m_pSipRedirectContext = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCBuddy::NotifyRedirect - CreateSIPBuddy failed 0x%lx", hr));

        return hr;
    }
    
    LOG((RTC_TRACE, "CRTCBuddy::NotifyRedirect - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::BuddyUnsubscribed
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCBuddy::BuddyUnsubscribed(void)
{
    LOG((RTC_TRACE, "CRTCBuddy::BuddyUnsubscribed - enter"));

    HRESULT hr;

    m_enStatus = RTCXS_PRESENCE_OFFLINE;

    if ( m_szNotes != NULL )
    {
        RtcFree( m_szNotes );
        m_szNotes = NULL;
    }

    if ( m_bShutdown )
    {
        //
        // This is a SIP buddy the was recently removed for shutdown. We have
        // just been notified that the UNSUB was completed. Release the
        // SIP buddy now.
        //

        hr = m_pSIPBuddy->SetNotifyInterface(NULL);

        if ( FAILED(hr) )
        {        
            LOG((RTC_ERROR, "CRTCBuddy::BuddyUnsubscribed - "
                            "SetNotifyInterface failed 0x%lx", hr));
        }

        m_pSIPBuddy->Release();
        m_pSIPBuddy = NULL;
    }

    //
    // Notify the core
    //

    AddRef();

    PostMessage( m_pCClient->GetWindow(), WM_BUDDY_UNSUB, (WPARAM)this, (LPARAM)m_bShutdown );

    LOG((RTC_TRACE, "CRTCBuddy::BuddyUnsubscribed - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::BuddyResub
//
/////////////////////////////////////////////////////////////////////////////
HRESULT
CRTCBuddy::BuddyResub()
{
    LOG((RTC_TRACE, "CRTCBuddy::BuddyResub - enter"));

    //
    // The SIP watcher on the other side has sent us an UNSUB. We must
    // recreate our SIP buddy to send another SUB request.
    //

    m_enStatus = RTCXS_PRESENCE_OFFLINE;
    m_hrStatusCode = S_OK;

    CRTCBuddyEvent::FireEvent( m_pCClient, this );

    //
    // Free the old buddy if it exists
    //

    if ( m_pSIPBuddy != NULL )
    {
        RemoveSIPBuddy(FALSE);
    }

    //
    // Recreate the SIP buddy
    //

    HRESULT hr;

    hr = CreateSIPBuddy();

    if ( FAILED(hr) )
    {
        LOG((RTC_WARN, "CRTCBuddy::BuddyResub - CreateSIPBuddy failed 0x%lx", hr));

        return hr;
    }

    LOG((RTC_TRACE, "CRTCBuddy::BuddyResub - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::BuddyRejected
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCBuddy::BuddyRejected(
    HRESULT   StatusCode
    )
{
    LOG((RTC_TRACE, "CRTCBuddy::BuddyRejected - enter"));

    m_enStatus = RTCXS_PRESENCE_OFFLINE;
    m_hrStatusCode = StatusCode;

    if ( m_szNotes != NULL )
    {
        RtcFree( m_szNotes );
        m_szNotes = NULL;
    }

    CRTCBuddyEvent::FireEvent( m_pCClient, this );

    LOG((RTC_TRACE, "CRTCBuddy::BuddyRejected - exit S_OK"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddy::BuddyInfoChange
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCBuddy::BuddyInfoChange(void)
{
    LOG((RTC_TRACE, "CRTCBuddy::BuddyInfoChange - enter"));

    if ( m_pSIPBuddy != NULL )
    {
        SIP_PRESENCE_INFO PresenceInfo;

        m_pSIPBuddy->GetPresenceInformation( &PresenceInfo );

        //
        // Get the status
        //

        if ( PresenceInfo.presenceStatus == BUDDY_ONLINE )
        {
            // try the MSN substatus frst
            if(PresenceInfo.activeMsnSubstatus != MSN_SUBSTATUS_UNKNOWN)
            {
                switch ( PresenceInfo.activeMsnSubstatus )
                {
                case MSN_SUBSTATUS_ONLINE:
                    m_enStatus = RTCXS_PRESENCE_ONLINE;
                    break;

                case MSN_SUBSTATUS_AWAY:
                    m_enStatus = RTCXS_PRESENCE_AWAY;
                    break;

                case MSN_SUBSTATUS_IDLE:
                    m_enStatus = RTCXS_PRESENCE_IDLE;
                    break;

                case MSN_SUBSTATUS_BUSY:
                    m_enStatus = RTCXS_PRESENCE_BUSY;
                    break;

                case MSN_SUBSTATUS_BE_RIGHT_BACK:
                    m_enStatus = RTCXS_PRESENCE_BE_RIGHT_BACK;
                    break;

                case MSN_SUBSTATUS_ON_THE_PHONE:
                    m_enStatus = RTCXS_PRESENCE_ON_THE_PHONE;
                    break;

                case MSN_SUBSTATUS_OUT_TO_LUNCH:
                    m_enStatus = RTCXS_PRESENCE_OUT_TO_LUNCH;
                    break;

                default:
                    m_enStatus = RTCXS_PRESENCE_ONLINE;
                    break;
                }
            }
            else
            {
                switch ( PresenceInfo.activeStatus )
                {
                case ACTIVE_STATUS_UNKNOWN:
                    m_enStatus = RTCXS_PRESENCE_ONLINE;
                    break;

                case DEVICE_ACTIVE:
                    m_enStatus = RTCXS_PRESENCE_ONLINE;
                    break;

                case DEVICE_INACTIVE:
                    m_enStatus = RTCXS_PRESENCE_AWAY;
                    break;

                case DEVICE_INUSE:
                    m_enStatus = RTCXS_PRESENCE_BUSY;
                    break;
                }
            }
        }
        else
        {
            m_enStatus = RTCXS_PRESENCE_OFFLINE;
        }

        //
        // Get the notes
        //

        if ( m_szNotes != NULL )
        {
            RtcFree( m_szNotes );
            m_szNotes = NULL;
        }

        if ( PresenceInfo.pstrSpecialNote[0] != 0 )
        {
            int iSize = MultiByteToWideChar(
                            CP_UTF8, 0, PresenceInfo.pstrSpecialNote, -1,
                            NULL, 0);

            if ( iSize > 0 )
            {
                m_szNotes = (LPWSTR)RtcAlloc(iSize * sizeof(WCHAR));

                if ( m_szNotes != NULL )
                {
                    iSize = MultiByteToWideChar(
                                CP_UTF8, 0, PresenceInfo.pstrSpecialNote, -1,
                                m_szNotes, iSize);

                    if ( iSize == 0 )
                    {
                        RtcFree( m_szNotes );
                        m_szNotes = NULL;
                    }
                }
            }
        }
    }
    
    m_hrStatusCode = S_OK;

    CRTCBuddyEvent::FireEvent( m_pCClient, this );

    LOG((RTC_TRACE, "CRTCBuddy::BuddyInfoChange - exit"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\rtcevents.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCEvents.cpp

Abstract:

    Implementation of the event classes

--*/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////
//
// RTCE_CLIENT
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClientEvent::FireEvent
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClientEvent::FireEvent(
                        CRTCClient * pCClient,                            
                        RTC_CLIENT_EVENT_TYPE enEventType
                       )
{
    HRESULT                                   hr = S_OK;
    
    IDispatch                               * pDispatch;

    LOG((RTC_TRACE, "CRTCClientEvent::FireEvent - enter" ));

    //
    // create event
    //

    CComObject<CRTCClientEvent> * p;
    hr = CComObject<CRTCClientEvent>::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCClientEvent::FireEvent - CreateInstance failed 0x%lx", hr));
        
        return hr;
    }

    //
    // get idispatch interface
    //
    
    hr = p->QueryInterface(
                           IID_IDispatch,
                           (void **)&pDispatch
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClientEvent::FireEvent - QI failed 0x%lx", hr));
        
        delete p;
        
        return hr;
    }

    //
    // initialize
    //
    
    p->m_enEventType = enEventType;

    p->m_pClient = static_cast<IRTCClient *>(pCClient);
    p->m_pClient->AddRef();
        
#if DBG
    p->m_pDebug = (PWSTR) RtcAlloc( sizeof(void *) );
    *((void **)(p->m_pDebug)) = p;
#endif

    //
    // fire event
    //
    
    pCClient->FireEvent(
                    RTCE_CLIENT,
                    pDispatch
                   );

    //
    // release stuff
    //
    
    pDispatch->Release();

    LOG((RTC_TRACE, "CRTCClientEvent::FireEvent - exit S_OK" ));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClientEvent::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void
CRTCClientEvent::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCClientEvent::FinalRelease - enter"));

    if (m_pClient != NULL)
    {
        m_pClient->Release();
        m_pClient = NULL;
    }

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    LOG((RTC_TRACE, "CRTCClientEvent::FinalRelease - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClientEvent::get_EventType
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClientEvent::get_EventType(
        RTC_CLIENT_EVENT_TYPE * penEventType
        )
{
    if ( IsBadWritePtr(penEventType , sizeof(RTC_CLIENT_EVENT_TYPE) ) )
    {
        LOG((RTC_ERROR, "CRTCClientEvent::get_EventType - bad pointer"));

        return E_POINTER;
    }

    *penEventType = m_enEventType;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClientEvent::get_Client
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClientEvent::get_Client(
        IRTCClient ** ppClient
        )
{
    if ( IsBadWritePtr(ppClient , sizeof(IRTCClient *) ) )
    {
        LOG((RTC_ERROR, "CRTCClientEvent::get_Client - bad pointer"));

        return E_POINTER;
    }

    *ppClient = m_pClient;
    (*ppClient)->AddRef();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// RTCE_REGISTRATION_STATE_CHANGE
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// CRTCRegistrationStateChangeEvent::FireEvent
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCRegistrationStateChangeEvent::FireEvent(
                        CRTCClient * pCClient,
                        CRTCProfile * pCProfile,
                        RTC_REGISTRATION_STATE enState,
                        long lStatusCode,
                        PCWSTR szStatusText
                       )
{
    HRESULT                                   hr = S_OK;
    
    IDispatch                               * pDispatch;

    LOG((RTC_TRACE, "CRTCRegistrationStateChangeEvent::FireEvent - enter" ));

    //
    // create event
    //

    CComObject<CRTCRegistrationStateChangeEvent> * p;
    hr = CComObject<CRTCRegistrationStateChangeEvent>::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCRegistrationStateChangeEvent::FireEvent - CreateInstance failed 0x%lx", hr));
        
        return hr;
    }

    //
    // get idispatch interface
    //
    
    hr = p->QueryInterface(
                           IID_IDispatch,
                           (void **)&pDispatch
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCRegistrationStateChangeEvent::FireEvent - QI failed 0x%lx", hr));
        
        delete p;
        
        return hr;
    }

    //
    // initialize
    //

    p->m_pProfile = static_cast<IRTCProfile *>(pCProfile);
    p->m_pProfile->AddRef();
    
    p->m_enState = enState;
    p->m_lStatusCode = lStatusCode;
    p->m_szStatusText = RtcAllocString( szStatusText );
        
#if DBG
    p->m_pDebug = (PWSTR) RtcAlloc( sizeof(void *) );
    *((void **)(p->m_pDebug)) = p;
#endif

    //
    // fire event
    //
    
    pCClient->FireEvent(
                    RTCE_REGISTRATION_STATE_CHANGE,
                    pDispatch
                   );

    //
    // release stuff
    //
    
    pDispatch->Release();

    LOG((RTC_TRACE, "CRTCRegistrationStateChangeEvent::FireEvent - exit S_OK" ));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCRegistrationStateChangeEvent::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void
CRTCRegistrationStateChangeEvent::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCRegistrationStateChangeEvent::FinalRelease - enter"));

    if (m_pProfile != NULL)
    {
        m_pProfile->Release();
        m_pProfile = NULL;
    }

    if (m_szStatusText != NULL)
    {
        RtcFree(m_szStatusText);
        m_szStatusText = NULL;
    }

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    LOG((RTC_TRACE, "CRTCRegistrationStateChangeEvent::FinalRelease - exit"));
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCRegistrationStateChangeEvent::get_Profile
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCRegistrationStateChangeEvent::get_Profile(
        IRTCProfile ** ppProfile
        )
{
    if ( IsBadWritePtr(ppProfile , sizeof(IRTCProfile *) ) )
    {
        LOG((RTC_ERROR, "CRTCRegistrationStateChangeEvent::get_Profile - bad pointer"));

        return E_POINTER;
    }

    *ppProfile = m_pProfile;
    (*ppProfile)->AddRef();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCRegistrationStateChangeEvent::get_State
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCRegistrationStateChangeEvent::get_State(
        RTC_REGISTRATION_STATE * penState
        )
{
    if ( IsBadWritePtr(penState , sizeof(RTC_REGISTRATION_STATE) ) )
    {
        LOG((RTC_ERROR, "CRTCRegistrationStateChangeEvent::get_State - bad pointer"));

        return E_POINTER;
    }

    *penState = m_enState;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCRegistrationStateChangeEvent::get_StatusCode
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCRegistrationStateChangeEvent::get_StatusCode(
        long * plStatusCode
        )
{
    if ( IsBadWritePtr(plStatusCode , sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCRegistrationStateChangeEvent::get_StatusCode - bad pointer"));

        return E_POINTER;
    }

    *plStatusCode = m_lStatusCode;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCRegistrationStateChangeEvent::get_StatusText
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCRegistrationStateChangeEvent::get_StatusText(
        BSTR * pbstrStatusText
        )
{
    if ( IsBadWritePtr(pbstrStatusText , sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCRegistrationStateChangeEvent::get_StatusText - bad pointer"));

        return E_POINTER;
    }

    *pbstrStatusText = NULL;

    if ( m_szStatusText == NULL )
    {
        LOG((RTC_ERROR, "CRTCRegistrationStateChangeEvent::get_StatusText - no value"));

        return E_FAIL;
    }

    *pbstrStatusText = SysAllocString(m_szStatusText);

    if ( *pbstrStatusText == NULL )
    {
        LOG((RTC_ERROR, "CRTCRegistrationStateChangeEvent::get_StatusText - out of memory"));

        return E_OUTOFMEMORY;
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// RTCE_SESSION_STATE_CHANGE
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSessionStateChangeEvent::FireEvent
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCSessionStateChangeEvent::FireEvent(
                       CRTCSession * pCSession,
                       RTC_SESSION_STATE enState,
                       long lStatusCode,
                       PCWSTR szStatusText
                      )
{
    HRESULT                                   hr = S_OK;
    
    IDispatch                               * pDispatch;
    CRTCClient                              * pCClient;

    LOG((RTC_TRACE, "CRTCSessionStateChangeEvent::FireEvent - enter" ));

    pCClient = pCSession->GetClient();

    if (pCClient == NULL)
    {
        LOG((RTC_ERROR, "CRTCSessionStateChangeEvent::FireEvent - GetClient failed"));
        
        return E_FAIL;
    }
    
    //
    // create event
    //

    CComObject<CRTCSessionStateChangeEvent> * p;
    hr = CComObject<CRTCSessionStateChangeEvent>::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCSessionStateChangeEvent::FireEvent - CreateInstance failed 0x%lx", hr));
        
        return hr;
    }

    //
    // get idispatch interface
    //
    
    hr = p->QueryInterface(
                           IID_IDispatch,
                           (void **)&pDispatch
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSessionStateChangeEvent::FireEvent - QI failed 0x%lx", hr));
        
        delete p;
        
        return hr;
    }

    //
    // initialize
    //

    p->m_pSession = static_cast<IRTCSession *>(pCSession);
    p->m_pSession->AddRef();
    
    p->m_enState = enState;
    p->m_lStatusCode = lStatusCode;
    p->m_szStatusText = RtcAllocString( szStatusText );
        
#if DBG
    p->m_pDebug = (PWSTR) RtcAlloc( sizeof(void *) );
    *((void **)(p->m_pDebug)) = p;
#endif

    //
    // fire event
    //
    
    pCClient->FireEvent(
                    RTCE_SESSION_STATE_CHANGE,
                    pDispatch
                   );

    //
    // release stuff
    //
    
    pDispatch->Release();

    LOG((RTC_TRACE, "CRTCSessionStateChangeEvent::FireEvent - exit S_OK" ));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSessionStateChangeEvent::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void
CRTCSessionStateChangeEvent::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCSessionStateChangeEvent::FinalRelease - enter"));

    if (m_pSession != NULL)
    {
        m_pSession->Release();
        m_pSession = NULL;
    }

    if (m_szStatusText != NULL)
    {
        RtcFree(m_szStatusText);
        m_szStatusText = NULL;
    }

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    LOG((RTC_TRACE, "CRTCSessionStateChangeEvent::FinalRelease - exit"));
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCSessionStateChangeEvent::get_Session
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSessionStateChangeEvent::get_Session(
        IRTCSession ** ppSession
        )
{
    if ( IsBadWritePtr(ppSession , sizeof(IRTCSession *) ) )
    {
        LOG((RTC_ERROR, "CRTCSessionStateChangeEvent::get_Session - bad pointer"));

        return E_POINTER;
    }

    *ppSession = m_pSession;
    (*ppSession)->AddRef();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSessionStateChangeEvent::get_State
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSessionStateChangeEvent::get_State(
        RTC_SESSION_STATE * penState
        )
{
    if ( IsBadWritePtr(penState , sizeof(RTC_SESSION_STATE) ) )
    {
        LOG((RTC_ERROR, "CRTCSessionStateChangeEvent::get_State - bad pointer"));

        return E_POINTER;
    }

    *penState = m_enState;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSessionStateChangeEvent::get_StatusCode
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSessionStateChangeEvent::get_StatusCode(
        long * plStatusCode
        )
{
    if ( IsBadWritePtr(plStatusCode , sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCSessionStateChangeEvent::get_StatusCode - bad pointer"));

        return E_POINTER;
    }

    *plStatusCode = m_lStatusCode;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSessionStateChangeEvent::get_StatusText
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSessionStateChangeEvent::get_StatusText(
        BSTR * pbstrStatusText
        )
{
    if ( IsBadWritePtr(pbstrStatusText , sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCSessionStateChangeEvent::get_StatusText - bad pointer"));

        return E_POINTER;
    }

    *pbstrStatusText = NULL;

    if ( m_szStatusText == NULL )
    {
        LOG((RTC_ERROR, "CRTCSessionStateChangeEvent::get_StatusText - no value"));

        return E_FAIL;
    }

    *pbstrStatusText = SysAllocString(m_szStatusText);

    if ( *pbstrStatusText == NULL )
    {
        LOG((RTC_ERROR, "CRTCSessionStateChangeEvent::get_StatusText - out of memory"));

        return E_OUTOFMEMORY;
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// RTCE_SESSION_OPERATION_COMPLETE
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSessionOperationCompleteEvent::FireEvent
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCSessionOperationCompleteEvent::FireEvent(
                       CRTCSession * pCSession,
                       long lCookie,
                       long lStatusCode,
                       PCWSTR szStatusText
                      )
{
    HRESULT                                   hr = S_OK;
    
    IDispatch                               * pDispatch;
    CRTCClient                              * pCClient;

    LOG((RTC_TRACE, "CRTCSessionOperationCompleteEvent::FireEvent - enter" ));

    pCClient = pCSession->GetClient();

    if (pCClient == NULL)
    {
        LOG((RTC_ERROR, "CRTCSessionOperationCompleteEvent::FireEvent - GetClient failed"));
        
        return E_FAIL;
    }
    
    //
    // create event
    //

    CComObject<CRTCSessionOperationCompleteEvent> * p;
    hr = CComObject<CRTCSessionOperationCompleteEvent>::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCSessionOperationCompleteEvent::FireEvent - CreateInstance failed 0x%lx", hr));
        
        return hr;
    }

    //
    // get idispatch interface
    //
    
    hr = p->QueryInterface(
                           IID_IDispatch,
                           (void **)&pDispatch
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSessionOperationCompleteEvent::FireEvent - QI failed 0x%lx", hr));
        
        delete p;
        
        return hr;
    }

    //
    // initialize
    //

    p->m_pSession = static_cast<IRTCSession *>(pCSession);
    p->m_pSession->AddRef();
    
    p->m_lCookie = lCookie;
    p->m_lStatusCode = lStatusCode;
    p->m_szStatusText = RtcAllocString( szStatusText );
        
#if DBG
    p->m_pDebug = (PWSTR) RtcAlloc( sizeof(void *) );
    *((void **)(p->m_pDebug)) = p;
#endif

    //
    // fire event
    //
    
    pCClient->FireEvent(
                    RTCE_SESSION_OPERATION_COMPLETE,
                    pDispatch
                   );

    //
    // release stuff
    //
    
    pDispatch->Release();

    LOG((RTC_TRACE, "CRTCSessionOperationCompleteEvent::FireEvent - exit S_OK" ));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSessionOperationCompleteEvent::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void
CRTCSessionOperationCompleteEvent::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCSessionOperationCompleteEvent::FinalRelease - enter"));

    if (m_pSession != NULL)
    {
        m_pSession->Release();
        m_pSession = NULL;
    }

    if (m_szStatusText != NULL)
    {
        RtcFree(m_szStatusText);
        m_szStatusText = NULL;
    }

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    LOG((RTC_TRACE, "CRTCSessionOperationCompleteEvent::FinalRelease - exit"));
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCSessionOperationCompleteEvent::get_Session
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSessionOperationCompleteEvent::get_Session(
        IRTCSession ** ppSession
        )
{
    if ( IsBadWritePtr(ppSession , sizeof(IRTCSession *) ) )
    {
        LOG((RTC_ERROR, "CRTCSessionOperationCompleteEvent::get_Session - bad pointer"));

        return E_POINTER;
    }

    *ppSession = m_pSession;
    (*ppSession)->AddRef();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSessionOperationCompleteEvent::get_Cookie
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSessionOperationCompleteEvent::get_Cookie(
        long * plCookie
        )
{
    if ( IsBadWritePtr(plCookie , sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCSessionOperationCompleteEvent::get_State - bad pointer"));

        return E_POINTER;
    }

    *plCookie = m_lCookie;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSessionOperationCompleteEvent::get_StatusCode
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSessionOperationCompleteEvent::get_StatusCode(
        long * plStatusCode
        )
{
    if ( IsBadWritePtr(plStatusCode , sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCSessionOperationCompleteEvent::get_StatusCode - bad pointer"));

        return E_POINTER;
    }

    *plStatusCode = m_lStatusCode;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSessionOperationCompleteEvent::get_StatusText
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSessionOperationCompleteEvent::get_StatusText(
        BSTR * pbstrStatusText
        )
{
    if ( IsBadWritePtr(pbstrStatusText , sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCSessionOperationCompleteEvent::get_StatusText - bad pointer"));

        return E_POINTER;
    }

    *pbstrStatusText = NULL;

    if ( m_szStatusText == NULL )
    {
        LOG((RTC_ERROR, "CRTCSessionOperationCompleteEvent::get_StatusText - no value"));

        return E_FAIL;
    }

    *pbstrStatusText = SysAllocString(m_szStatusText);

    if ( *pbstrStatusText == NULL )
    {
        LOG((RTC_ERROR, "CRTCSessionOperationCompleteEvent::get_StatusText - out of memory"));

        return E_OUTOFMEMORY;
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// RTCE_PARTICIPANT_STATE_CHANGE
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipantStateChangeEvent::FireEvent
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCParticipantStateChangeEvent::FireEvent(
                       CRTCParticipant * pCParticipant,
                       RTC_PARTICIPANT_STATE enState,
                       long lStatusCode
                      )
{
    HRESULT                                   hr = S_OK;
    
    IDispatch                               * pDispatch;
    CRTCClient                              * pCClient;

    LOG((RTC_TRACE, "CRTCParticipantStateChangeEvent::FireEvent - enter" ));

    pCClient = pCParticipant->GetClient();

    if (pCClient == NULL)
    {
        LOG((RTC_ERROR, "CRTCParticipantStateChangeEvent::FireEvent - GetClient failed"));
        
        return E_FAIL;
    }
    
    //
    // create event
    //

    CComObject<CRTCParticipantStateChangeEvent> * p;
    hr = CComObject<CRTCParticipantStateChangeEvent>::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCParticipantStateChangeEvent::FireEvent - CreateInstance failed 0x%lx", hr));
        
        return hr;
    }

    //
    // get idispatch interface
    //
    
    hr = p->QueryInterface(
                           IID_IDispatch,
                           (void **)&pDispatch
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCParticipantStateChangeEvent::FireEvent - QI failed 0x%lx", hr));
        
        delete p;
        
        return hr;
    }

    //
    // initialize
    //

    p->m_pParticipant = static_cast<IRTCParticipant *>(pCParticipant);
    p->m_pParticipant->AddRef();
    
    p->m_enState = enState;
    p->m_lStatusCode = lStatusCode;
        
#if DBG
    p->m_pDebug = (PWSTR) RtcAlloc( sizeof(void *) );
    *((void **)(p->m_pDebug)) = p;
#endif

    //
    // fire event
    //
    
    pCClient->FireEvent(
                    RTCE_PARTICIPANT_STATE_CHANGE,
                    pDispatch
                   );

    //
    // release stuff
    //
    
    pDispatch->Release();

    LOG((RTC_TRACE, "CRTCParticipantStateChangeEvent::FireEvent - exit S_OK" ));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipantStateChangeEvent::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void
CRTCParticipantStateChangeEvent::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCParticipantStateChangeEvent::FinalRelease - enter"));

    if (m_pParticipant != NULL)
    {
        m_pParticipant->Release();
        m_pParticipant = NULL;
    }

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    LOG((RTC_TRACE, "CRTCParticipantStateChangeEvent::FinalRelease - exit"));
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipantStateChangeEvent::get_Participant
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCParticipantStateChangeEvent::get_Participant(
        IRTCParticipant ** ppParticipant
        )
{
    if ( IsBadWritePtr(ppParticipant , sizeof(IRTCParticipant *) ) )
    {
        LOG((RTC_ERROR, "CRTCParticipantStateChangeEvent::get_Participant - bad pointer"));

        return E_POINTER;
    }

    *ppParticipant = m_pParticipant;
    (*ppParticipant)->AddRef();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipantStateChangeEvent::get_State
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCParticipantStateChangeEvent::get_State(
        RTC_PARTICIPANT_STATE * penState
        )
{
    if ( IsBadWritePtr(penState , sizeof(RTC_PARTICIPANT_STATE) ) )
    {
        LOG((RTC_ERROR, "CRTCParticipantStateChangeEvent::get_State - bad pointer"));

        return E_POINTER;
    }

    *penState = m_enState;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipantStateChangeEvent::get_StatusCode
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCParticipantStateChangeEvent::get_StatusCode(
        long * plStatusCode
        )
{
    if ( IsBadWritePtr(plStatusCode , sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCParticipantStateChangeEvent::get_StatusCode - bad pointer"));

        return E_POINTER;
    }

    *plStatusCode = m_lStatusCode;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// RTCE_MEDIA
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// CRTCMediaEvent::FireEvent
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCMediaEvent::FireEvent(
                       CRTCClient * pCClient,
                       RTC_MEDIA_EVENT_TYPE enEventType,
                       RTC_MEDIA_EVENT_REASON enEventReason,
                       long lMediaType
                      )
{
    HRESULT                                   hr = S_OK;
    
    IDispatch                               * pDispatch;

    LOG((RTC_TRACE, "CRTCMediaEvent::FireEvent - enter" ));
    
    //
    // create event
    //

    CComObject<CRTCMediaEvent> * p;
    hr = CComObject<CRTCMediaEvent>::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCMediaEvent::FireEvent - CreateInstance failed 0x%lx", hr));
        
        return hr;
    }

    //
    // get idispatch interface
    //
    
    hr = p->QueryInterface(
                           IID_IDispatch,
                           (void **)&pDispatch
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCMediaEvent::FireEvent - QI failed 0x%lx", hr));
        
        delete p;
        
        return hr;
    }

    //
    // initialize
    //
    
    p->m_enEventType = enEventType;
    p->m_enEventReason = enEventReason;
    p->m_lMediaType = lMediaType;
        
#if DBG
    p->m_pDebug = (PWSTR) RtcAlloc( sizeof(void *) );
    *((void **)(p->m_pDebug)) = p;
#endif

    //
    // fire event
    //
    
    pCClient->FireEvent(
                    RTCE_MEDIA,
                    pDispatch
                   );

    //
    // release stuff
    //
    
    pDispatch->Release();

    LOG((RTC_TRACE, "CRTCMediaEvent::FireEvent - exit S_OK" ));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCMediaEvent::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void
CRTCMediaEvent::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCMediaEvent::FinalRelease - enter"));

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    LOG((RTC_TRACE, "CRTCMediaEvent::FinalRelease - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCMediaEvent::get_EventType
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCMediaEvent::get_EventType(
        RTC_MEDIA_EVENT_TYPE * penEventType
        )
{
    if ( IsBadWritePtr(penEventType , sizeof(RTC_MEDIA_EVENT_TYPE) ) )
    {
        LOG((RTC_ERROR, "CRTCMediaEvent::get_EventType - bad pointer"));

        return E_POINTER;
    }

    *penEventType = m_enEventType;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCMediaEvent::get_EventReason
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCMediaEvent::get_EventReason(
        RTC_MEDIA_EVENT_REASON * penEventReason
        )
{
    if ( IsBadWritePtr(penEventReason , sizeof(RTC_MEDIA_EVENT_REASON) ) )
    {
        LOG((RTC_ERROR, "CRTCMediaEvent::get_EventReason - bad pointer"));

        return E_POINTER;
    }

    *penEventReason = m_enEventReason;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCMediaEvent::get_MediaType
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCMediaEvent::get_MediaType(
        long * plMediaType
        )
{
    if ( IsBadWritePtr(plMediaType , sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCMediaEvent::get_MediaType - bad pointer"));

        return E_POINTER;
    }

    *plMediaType = m_lMediaType;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// RTCE_INTENSITY
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// CRTCIntensityEvent::FireEvent
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCIntensityEvent::FireEvent(
                             CRTCClient * pCClient,
                             long lValue,
                             RTC_AUDIO_DEVICE direction,
                             long lMin,
                             long lMax
                      )
{
    HRESULT                                   hr = S_OK;
    
    IDispatch                               * pDispatch;

    //LOG((RTC_TRACE, "CRTCIntensityEvent::FireEvent - enter" ));
    
    //
    // create event
    //

    CComObject<CRTCIntensityEvent> * p;
    hr = CComObject<CRTCIntensityEvent>::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCIntensityEvent::FireEvent - CreateInstance failed 0x%lx", hr));
        
        return hr;
    }

    //
    // get idispatch interface
    //
    
    hr = p->QueryInterface(
                           IID_IDispatch,
                           (void **)&pDispatch
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCIntensityEvent::FireEvent - QI failed 0x%lx", hr));
        
        delete p;
        
        return hr;
    }

    //
    // initialize
    //
    
    p->m_lLevel = lValue;
    p->m_lMin = lMin;
    p->m_lMax = lMax;
    p->m_Direction = direction;
        

    //
    // fire event
    //
    
    pCClient->FireEvent(
                    RTCE_INTENSITY,
                    pDispatch
                   );

    //
    // release stuff
    //
    
    pDispatch->Release();

    //LOG((RTC_TRACE, "CRTCIntensityEvent::FireEvent - exit S_OK" ));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCIntensityEvent::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void
CRTCIntensityEvent::FinalRelease()
{
    //LOG((RTC_TRACE, "CRTCIntensityEvent::FinalRelease - enter"));

    //LOG((RTC_TRACE, "CRTCIntensityEvent::FinalRelease - exit"));
}



/////////////////////////////////////////////////////////////////////////////
//
// CRTCIntensityEvent::get_Level
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCIntensityEvent::get_Level(long * plLevel)
{
    //LOG((RTC_TRACE, "CRTCIntensityEvent::get_Level - enter"));

    if ( IsBadWritePtr(plLevel , sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCIntensityEvent::get_Level - bad pointer"));

        return E_POINTER;
    }

    *plLevel = m_lLevel;

    //LOG((RTC_TRACE, "CRTCIntensityEvent::get_Level - exit"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCIntensityEvent::get_Min
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCIntensityEvent::get_Min(long * plMin)
{
    //LOG((RTC_TRACE, "CRTCIntensityEvent::get_Min - enter"));

    if ( IsBadWritePtr(plMin , sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCIntensityEvent::get_Min - bad pointer"));

        return E_POINTER;
    }

    *plMin = m_lMin;

    //LOG((RTC_TRACE, "CRTCIntensityEvent::get_Min - exit"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCIntensityEvent::get_Max
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCIntensityEvent::get_Max(long * plMax)
{
    //LOG((RTC_TRACE, "CRTCIntensityEvent::get_Max - enter"));

    if ( IsBadWritePtr(plMax , sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCIntensityEvent::get_Max - bad pointer"));

        return E_POINTER;
    }

    *plMax = m_lMax;

    //LOG((RTC_TRACE, "CRTCIntensityEvent::get_Max - exit"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCIntensityEvent::get_Direction
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCIntensityEvent::get_Direction(RTC_AUDIO_DEVICE * plDirection)
{
    //LOG((RTC_TRACE, "CRTCIntensityEvent::get_Direction - enter"));

    if ( IsBadWritePtr(plDirection , sizeof(RTC_AUDIO_DEVICE) ) )
    {
        LOG((RTC_ERROR, "CRTCIntensityEvent::get_Direction - bad pointer"));

        return E_POINTER;
    }

    *plDirection = m_Direction;

    //LOG((RTC_TRACE, "CRTCIntensityEvent::get_Direction - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// RTCE_MESSAGE
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// CRTCMessagingEvent::FireEvent
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCMessagingEvent::FireEvent(
                       CRTCSession * pCSession,
                       IRTCParticipant * pParticipant,
                       PCWSTR szMessage,
                       PCWSTR szMessageHeader,
                       RTC_MESSAGING_EVENT_TYPE enEventType,
                       RTC_MESSAGING_USER_STATUS enUserStatus
                      )
{
    HRESULT                                   hr = S_OK;
    
    IDispatch                               * pDispatch;
    CRTCClient                              * pCClient;

    LOG((RTC_TRACE, "CRTCMessagingEvent::FireEvent - enter" ));

    pCClient = pCSession->GetClient();

    if (pCClient == NULL)
    {
        LOG((RTC_ERROR, "CRTCMessagingEvent::FireEvent - GetClient failed"));
        
        return E_FAIL;
    }
    
    //
    // create event
    //

    CComObject<CRTCMessagingEvent> * p;
    hr = CComObject<CRTCMessagingEvent>::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCMessagingEvent::FireEvent - CreateInstance failed 0x%lx", hr));
        
        return hr;
    }

    //
    // get idispatch interface
    //
    
    hr = p->QueryInterface(
                           IID_IDispatch,
                           (void **)&pDispatch
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCMessagingEvent::FireEvent - QI failed 0x%lx", hr));
        
        delete p;
        
        return hr;
    }

    //
    // initialize
    //

    p->m_pSession = static_cast<IRTCSession *>(pCSession);
    p->m_pSession->AddRef();

    p->m_pParticipant = pParticipant;
    p->m_pParticipant->AddRef();

    p->m_szMessage = RtcAllocString( szMessage );
    p->m_szMessageHeader = RtcAllocString( szMessageHeader );

    p->m_enEventType = enEventType;
    p->m_enUserStatus = enUserStatus;
        
#if DBG
    p->m_pDebug = (PWSTR) RtcAlloc( sizeof(void *) );
    *((void **)(p->m_pDebug)) = p;
#endif

    //
    // fire event
    //
    
    pCClient->FireEvent(
                    RTCE_MESSAGING,
                    pDispatch
                   );

    //
    // release stuff
    //
    
    pDispatch->Release();

    LOG((RTC_TRACE, "CRTCMessagingEvent::FireEvent - exit S_OK" ));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCMessagingEvent::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void
CRTCMessagingEvent::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCMessagingEvent::FinalRelease - enter"));

    if (m_pSession != NULL)
    {
        m_pSession->Release();
        m_pSession = NULL;
    }

    if (m_pParticipant != NULL)
    {
        m_pParticipant->Release();
        m_pParticipant = NULL;
    }

    if (m_szMessage != NULL)
    {
        RtcFree(m_szMessage);
        m_szMessage = NULL;
    }

    if (m_szMessageHeader != NULL)
    {
        RtcFree(m_szMessageHeader);
        m_szMessageHeader = NULL;
    }

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    LOG((RTC_TRACE, "CRTCMessagingEvent::FinalRelease - exit"));
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCMessagingEvent::get_Session
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCMessagingEvent::get_Session(
        IRTCSession ** ppSession
        )
{
    if ( IsBadWritePtr(ppSession , sizeof(IRTCSession *) ) )
    {
        LOG((RTC_ERROR, "CRTCMessagingEvent::get_Session - bad pointer"));

        return E_POINTER;
    }

    *ppSession = m_pSession;
    (*ppSession)->AddRef();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCMessagingEvent::get_Participant
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCMessagingEvent::get_Participant(
        IRTCParticipant ** ppParticipant
        )
{
    if ( IsBadWritePtr(ppParticipant , sizeof(IRTCParticipant *) ) )
    {
        LOG((RTC_ERROR, "CRTCMessagingEvent::get_Participant - bad pointer"));

        return E_POINTER;
    }

    *ppParticipant = m_pParticipant;
    (*ppParticipant)->AddRef();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCMessagingEvent::get_Message
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCMessagingEvent::get_Message(
        BSTR * pbstrMessage
        )
{
    if ( IsBadWritePtr(pbstrMessage , sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCMessagingEvent::get_Message - bad pointer"));

        return E_POINTER;
    }

    *pbstrMessage = NULL;

    if ( m_szMessage == NULL )
    {
        LOG((RTC_ERROR, "CRTCMessagingEvent::get_Message - no value"));

        return E_FAIL;
    }

    *pbstrMessage = SysAllocString(m_szMessage);

    if ( *pbstrMessage == NULL )
    {
        LOG((RTC_ERROR, "CRTCMessagingEvent::get_Message - out of memory"));

        return E_OUTOFMEMORY;
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCMessagingEvent::get_MessageHeader
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCMessagingEvent::get_MessageHeader(
        BSTR * pbstrMessageHeader
        )
{
    if ( IsBadWritePtr(pbstrMessageHeader , sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCMessagingEvent::get_MessageHeader - bad pointer"));

        return E_POINTER;
    }

    *pbstrMessageHeader = NULL;

    if ( m_szMessageHeader == NULL )
    {
        LOG((RTC_ERROR, "CRTCMessagingEvent::get_MessageHeader - no value"));

        return E_FAIL;
    }

    *pbstrMessageHeader = SysAllocString(m_szMessageHeader);

    if ( *pbstrMessageHeader == NULL )
    {
        LOG((RTC_ERROR, "CRTCMessagingEvent::get_MessageHeader - out of memory"));

        return E_OUTOFMEMORY;
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCMessagingEvent::get_EventType
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCMessagingEvent::get_EventType(
        RTC_MESSAGING_EVENT_TYPE * penEventType
        )
{
    if ( IsBadWritePtr(penEventType , sizeof(RTC_MESSAGING_EVENT_TYPE) ) )
    {
        LOG((RTC_ERROR, "CRTCMessagingEvent::get_EventType - bad pointer"));

        return E_POINTER;
    }

    *penEventType = m_enEventType;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCMessagingEvent::get_UserStatus
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCMessagingEvent::get_UserStatus(
        RTC_MESSAGING_USER_STATUS * penUserStatus
        )
{
    if ( IsBadWritePtr(penUserStatus , sizeof(RTC_MESSAGING_USER_STATUS) ) )
    {
        LOG((RTC_ERROR, "CRTCMessagingEvent::get_UserStatus - bad pointer"));

        return E_POINTER;
    }

    *penUserStatus = m_enUserStatus;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// RTCE_BUDDY
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddyEvent::FireEvent
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCBuddyEvent::FireEvent(
                       CRTCClient * pCClient,
                       IRTCBuddy * pBuddy
                      )
{
    HRESULT                                   hr = S_OK;
    
    IDispatch                               * pDispatch;

    //
    // create event
    //

    CComObject<CRTCBuddyEvent> * p;
    hr = CComObject<CRTCBuddyEvent>::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCBuddyEvent::FireEvent - CreateInstance failed 0x%lx", hr));
        
        return hr;
    }

    //
    // get idispatch interface
    //
    
    hr = p->QueryInterface(
                           IID_IDispatch,
                           (void **)&pDispatch
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCBuddyEvent::FireEvent - QI failed 0x%lx", hr));
        
        delete p;
        
        return hr;
    }

    //
    // initialize
    //

    p->m_pBuddy = pBuddy;
    p->m_pBuddy->AddRef();

#if DBG
    p->m_pDebug = (PWSTR) RtcAlloc( sizeof(void *) );
    *((void **)(p->m_pDebug)) = p;
#endif

    //
    // fire event
    //
    
    pCClient->FireEvent(
                    RTCE_BUDDY,
                    pDispatch
                   );

    //
    // release stuff
    //
    
    pDispatch->Release();

    LOG((RTC_TRACE, "CRTCBuddyEvent::FireEvent - exit S_OK" ));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddyEvent::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void
CRTCBuddyEvent::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCBuddyEvent::FinalRelease - enter"));

    if (m_pBuddy != NULL)
    {
        m_pBuddy->Release();
        m_pBuddy = NULL;
    }

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    LOG((RTC_TRACE, "CRTCBuddyEvent::FinalRelease - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddyEvent::get_Buddy
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCBuddyEvent::get_Buddy(
        IRTCBuddy **ppBuddy
        )
{
    if ( IsBadWritePtr(ppBuddy , sizeof( IRTCBuddy * ) ) )
    {
        LOG((RTC_ERROR, "CRTCBuddyEvent::get_Buddy - bad pointer"));

        return E_POINTER;
    }

    *ppBuddy = m_pBuddy;

    if (*ppBuddy != NULL)
    {
        (*ppBuddy)->AddRef();
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// RTCE_WATCHER
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcherEvent::FireEvent
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCWatcherEvent::FireEvent(
                       CRTCClient * pCClient,
                       IRTCWatcher * pWatcher
                      )
{
    HRESULT                                   hr = S_OK;
    
    IDispatch                               * pDispatch;

    //
    // create event
    //

    CComObject<CRTCWatcherEvent> * p;
    hr = CComObject<CRTCWatcherEvent>::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCWatcherEvent::FireEvent - CreateInstance failed 0x%lx", hr));
        
        return hr;
    }

    //
    // get iunknown interface
    //
    
    hr = p->QueryInterface(
                           IID_IDispatch,
                           (void **)&pDispatch
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWatcherEvent::FireEvent - QI failed 0x%lx", hr));
        
        delete p;
        
        return hr;
    }

    //
    // initialize
    //

    p->m_pWatcher = pWatcher;
    p->m_pWatcher->AddRef();

#if DBG
    p->m_pDebug = (PWSTR) RtcAlloc( sizeof(void *) );
    *((void **)(p->m_pDebug)) = p;
#endif

    //
    // fire event
    //
    
    pCClient->FireEvent(
                    RTCE_WATCHER,
                    pDispatch
                   );

    //
    // release stuff
    //
    
    pDispatch->Release();

    LOG((RTC_TRACE, "CRTCWatcherEvent::FireEvent - exit S_OK" ));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcherEvent::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void
CRTCWatcherEvent::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCWatcherEvent::FinalRelease - enter"));

    if (m_pWatcher != NULL)
    {
        m_pWatcher->Release();
        m_pWatcher = NULL;
    }

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    LOG((RTC_TRACE, "CRTCWatcherEvent::FinalRelease - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcherEvent::get_Watcher
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCWatcherEvent::get_Watcher(
        IRTCWatcher **ppWatcher
        )
{
    if ( IsBadWritePtr(ppWatcher , sizeof( IRTCWatcher * ) ) )
    {
        LOG((RTC_ERROR, "CRTCWatcherEvent::get_Unknown - bad pointer"));

        return E_POINTER;
    }

    *ppWatcher = m_pWatcher;

    if (*ppWatcher != NULL)
    {
        (*ppWatcher)->AddRef();
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\rtcevents.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCEvents.h

Abstract:

    Definition of the event classes

--*/

#ifndef __RTCEVENTS__
#define __RTCEVENTS__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "dllres.h"

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClientEvent
//
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CRTCClientEvent : 
    public CComObjectRoot,
	public IDispatchImpl<IRTCClientEvent, &IID_IRTCClientEvent, &LIBID_RTCCORELib>
{
public:
    CRTCClientEvent() {}
BEGIN_COM_MAP(CRTCClientEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IRTCClientEvent)
END_COM_MAP()

    static HRESULT FireEvent(
                             CRTCClient * pCClient,                            
                             RTC_CLIENT_EVENT_TYPE enEventType
                            );

    void FinalRelease();

protected:

    RTC_CLIENT_EVENT_TYPE m_enEventType; 
    IRTCClient          * m_pClient;

#if DBG
    PWSTR               m_pDebug;
#endif

// IRTCClientEvent
public:

    STDMETHOD(get_EventType)(
                           RTC_CLIENT_EVENT_TYPE * penEventType
                          );

    STDMETHOD(get_Client)(
                           IRTCClient ** ppClient
                          );
};

/////////////////////////////////////////////////////////////////////////////
//
// CRTCRegistrationStateChangeEvent
//
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CRTCRegistrationStateChangeEvent : 
    public CComObjectRoot,
	public IDispatchImpl<IRTCRegistrationStateChangeEvent, &IID_IRTCRegistrationStateChangeEvent, &LIBID_RTCCORELib>
{
public:
    CRTCRegistrationStateChangeEvent() {}
BEGIN_COM_MAP(CRTCRegistrationStateChangeEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IRTCRegistrationStateChangeEvent)
END_COM_MAP()

    static HRESULT FireEvent(
                             CRTCClient * pCClient,
                             CRTCProfile * pCProfile,
                             RTC_REGISTRATION_STATE enState,
                             long lStatusCode,
                             PCWSTR szStatusText
                            );

    void FinalRelease();

protected:

    IRTCProfile       * m_pProfile;
    RTC_REGISTRATION_STATE m_enState; 
    long                m_lStatusCode;
    PWSTR               m_szStatusText;

#if DBG
    PWSTR               m_pDebug;
#endif

// IRTCRegistrationStateChangeEvent
public:

    STDMETHOD(get_Profile)(
                           IRTCProfile ** ppProfile
                          );
        
    STDMETHOD(get_State)(
                         RTC_REGISTRATION_STATE * penState
                        );

    STDMETHOD(get_StatusCode)(
                              long * plStatusCode
                             );   
    
    STDMETHOD(get_StatusText)(
                              BSTR * pbstrStatusText
                             );  
};

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSessionStateChangeEvent
//
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CRTCSessionStateChangeEvent : 
    public CComObjectRoot,
	public IDispatchImpl<IRTCSessionStateChangeEvent, &IID_IRTCSessionStateChangeEvent, &LIBID_RTCCORELib>
{
public:
    CRTCSessionStateChangeEvent() {}
BEGIN_COM_MAP(CRTCSessionStateChangeEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IRTCSessionStateChangeEvent)
END_COM_MAP()

    static HRESULT FireEvent(
                             CRTCSession * pCSession,
                             RTC_SESSION_STATE enState,
                             long lStatusCode,
                             PCWSTR szStatusText
                            );

    void FinalRelease();

protected:

    IRTCSession       * m_pSession;
    RTC_SESSION_STATE   m_enState; 
    long                m_lStatusCode;
    PWSTR               m_szStatusText;

#if DBG
    PWSTR               m_pDebug;
#endif

// IRTCSessionStateChangeEvent
public:

    STDMETHOD(get_Session)(
                           IRTCSession ** ppSession
                          );
        
    STDMETHOD(get_State)(
                         RTC_SESSION_STATE * penState
                        );

    STDMETHOD(get_StatusCode)(
                              long * plStatusCode
                             );   
    
    STDMETHOD(get_StatusText)(
                              BSTR * pbstrStatusText
                             );  
};

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSessionOperationCompleteEvent
//
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CRTCSessionOperationCompleteEvent : 
    public CComObjectRoot,
	public IDispatchImpl<IRTCSessionOperationCompleteEvent, &IID_IRTCSessionOperationCompleteEvent, &LIBID_RTCCORELib>
{
public:
    CRTCSessionOperationCompleteEvent() {}
BEGIN_COM_MAP(CRTCSessionOperationCompleteEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IRTCSessionOperationCompleteEvent)
END_COM_MAP()

    static HRESULT FireEvent(
                             CRTCSession * pCSession,
                             long lCookie,
                             long lStatusCode,
                             PCWSTR szStatusText
                            );

    void FinalRelease();

protected:

    IRTCSession       * m_pSession;
    long                m_lCookie; 
    long                m_lStatusCode;
    PWSTR               m_szStatusText;

#if DBG
    PWSTR               m_pDebug;
#endif

// IRTCSessionOperationCompleteEvent
public:

    STDMETHOD(get_Session)(
                           IRTCSession ** ppSession
                          );
        
    STDMETHOD(get_Cookie)(
                         long * plCookie
                        );

    STDMETHOD(get_StatusCode)(
                              long * plStatusCode
                             );   
    
    STDMETHOD(get_StatusText)(
                              BSTR * pbstrStatusText
                             );  
};

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipantStateChangeEvent
//
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CRTCParticipantStateChangeEvent : 
    public CComObjectRoot,
	public IDispatchImpl<IRTCParticipantStateChangeEvent, &IID_IRTCParticipantStateChangeEvent, &LIBID_RTCCORELib>
{
public:
    CRTCParticipantStateChangeEvent() {}
BEGIN_COM_MAP(CRTCParticipantStateChangeEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IRTCParticipantStateChangeEvent)
END_COM_MAP()

    static HRESULT FireEvent(
                             CRTCParticipant * pCParticipant,
                             RTC_PARTICIPANT_STATE enState,
                             long lStatusCode
                            );

    void FinalRelease();

protected:

    IRTCParticipant   * m_pParticipant;
    RTC_PARTICIPANT_STATE   m_enState; 
    long                m_lStatusCode;

#if DBG
    PWSTR               m_pDebug;
#endif

// IRTCParticipantStateChangeEvent
public:

    STDMETHOD(get_Participant)(
                               IRTCParticipant ** ppParticipant
                              );
        
    STDMETHOD(get_State)(
                         RTC_PARTICIPANT_STATE * penState
                        );

    STDMETHOD(get_StatusCode)(
                         long * plStatusCode
                        );                           
};

/////////////////////////////////////////////////////////////////////////////
//
// CRTCMediaEvent
//
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CRTCMediaEvent : 
    public CComObjectRoot,
	public IDispatchImpl<IRTCMediaEvent, &IID_IRTCMediaEvent, &LIBID_RTCCORELib>
{
public:
    CRTCMediaEvent() {}
BEGIN_COM_MAP(CRTCMediaEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IRTCMediaEvent)
END_COM_MAP()

    static HRESULT FireEvent(
                             CRTCClient * pCClient,
                             RTC_MEDIA_EVENT_TYPE enEventType,
                             RTC_MEDIA_EVENT_REASON enEventReason,
                             long lMediaType
                            );

    void FinalRelease();

protected:

    RTC_MEDIA_EVENT_TYPE	m_enEventType; 
    RTC_MEDIA_EVENT_REASON  m_enEventReason;
    long                    m_lMediaType;

#if DBG
    PWSTR               m_pDebug;
#endif

// IRTCMediaEvent
public:

    STDMETHOD(get_MediaType)(
                             long * plMediaType
                            );
  
    STDMETHOD(get_EventType)(
                             RTC_MEDIA_EVENT_TYPE * penEventType
                            );

    STDMETHOD(get_EventReason)(
                               RTC_MEDIA_EVENT_REASON * penEventReason
                              );
};


/////////////////////////////////////////////////////////////////////////////
//
// CRTCIntensityEvent
//
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CRTCIntensityEvent : 
    public CComObjectRoot,
	public IDispatchImpl<IRTCIntensityEvent, &IID_IRTCIntensityEvent, &LIBID_RTCCORELib>
{
public:
    CRTCIntensityEvent() {}
BEGIN_COM_MAP(CRTCIntensityEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IRTCIntensityEvent)
END_COM_MAP()

    static HRESULT FireEvent(
                             CRTCClient * pCClient,
                             long lValue,
                             RTC_AUDIO_DEVICE direction,
                             long lMin,
                             long lMax
                            );

    void FinalRelease();

protected:
     long                   m_lLevel;
     RTC_AUDIO_DEVICE       m_Direction;
     long                   m_lMin;
     long                   m_lMax;



// IRTCIntensityEvent
public:
    STDMETHOD(get_Level)(
                             long * plLevel
                            );
  
    STDMETHOD(get_Min)(
                             long * plMin
                            );

    STDMETHOD(get_Max)(
                             long * plMax
                            );
    
    STDMETHOD(get_Direction)(
                             RTC_AUDIO_DEVICE * plDirection
                            );

};

/////////////////////////////////////////////////////////////////////////////
//
// CRTCMessagingEvent
//
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CRTCMessagingEvent : 
    public CComObjectRoot,
	public IDispatchImpl<IRTCMessagingEvent, &IID_IRTCMessagingEvent, &LIBID_RTCCORELib>
{
public:
    CRTCMessagingEvent() {}
BEGIN_COM_MAP(CRTCMessagingEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IRTCMessagingEvent)
END_COM_MAP()

    static HRESULT FireEvent(
                             CRTCSession * pCSession,
                             IRTCParticipant * pParticipant,                             
                             PCWSTR szMessage,
                             PCWSTR szMessageHeader,
                             RTC_MESSAGING_EVENT_TYPE enEventType,
                             RTC_MESSAGING_USER_STATUS enUserStatus
                            );

    void FinalRelease();

protected:

    IRTCSession       * m_pSession;
    IRTCParticipant   * m_pParticipant;
    PWSTR               m_szMessage;
    PWSTR               m_szMessageHeader;
    RTC_MESSAGING_EVENT_TYPE  m_enEventType;
    RTC_MESSAGING_USER_STATUS m_enUserStatus;

#if DBG
    PWSTR               m_pDebug;
#endif

// CRTCMessagingEvent
public:

    STDMETHOD(get_Session)(
                           IRTCSession ** ppSession
                          );

    STDMETHOD(get_Participant)(
                               IRTCParticipant ** ppParticipant
                              );
        
    STDMETHOD(get_EventType)(
                        RTC_MESSAGING_EVENT_TYPE * penEventType
                       );

    STDMETHOD(get_Message)(
                           BSTR * pbstrMessage
                          );

    STDMETHOD(get_MessageHeader)(
                           BSTR * pbstrMessageHeader
                          );

    STDMETHOD(get_UserStatus)(
                              RTC_MESSAGING_USER_STATUS * penUserStatus
                             );
};

    
/////////////////////////////////////////////////////////////////////////////
//
// CRTCBuddyEvent
//
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CRTCBuddyEvent : 
    public CComObjectRoot,
	public IDispatchImpl<IRTCBuddyEvent, &IID_IRTCBuddyEvent, &LIBID_RTCCORELib>
{
public:
    CRTCBuddyEvent() {}
BEGIN_COM_MAP(CRTCBuddyEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IRTCBuddyEvent)
END_COM_MAP()

    static HRESULT FireEvent(
                             CRTCClient * pCClient,
                             IRTCBuddy * pBuddy
                            );

    void FinalRelease();

protected:

    IRTCBuddy         * m_pBuddy;

#if DBG
    PWSTR               m_pDebug;
#endif

// CRTCBuddyEvent
public:

    STDMETHOD(get_Buddy)(
                         IRTCBuddy ** ppBuddy
                        );
};

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcherEvent
//
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CRTCWatcherEvent : 
    public CComObjectRoot,
	public IDispatchImpl<IRTCWatcherEvent, &IID_IRTCWatcherEvent, &LIBID_RTCCORELib>
{
public:
    CRTCWatcherEvent() {}
BEGIN_COM_MAP(CRTCWatcherEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IRTCWatcherEvent)
END_COM_MAP()

    static HRESULT FireEvent(
                             CRTCClient * pCClient,
                             IRTCWatcher * pWatcher
                            );

    void FinalRelease();

protected:

    IRTCWatcher       * m_pWatcher;

#if DBG
    PWSTR               m_pDebug;
#endif

// CRTCWatcherEvent
public:

    STDMETHOD(get_Watcher)(
                           IRTCWatcher ** ppWatcher
                          );
};


#endif //__RTCEVENTS__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\rtcparticipant.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCParticipant.cpp

Abstract:

    Implementation of the CRTCParticipant class

--*/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipant::FinalConstruct
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCParticipant::FinalConstruct()
{
    LOG((RTC_TRACE, "CRTCParticipant::FinalConstruct [%p] - enter", this));

#if DBG
    m_pDebug = (PWSTR) RtcAlloc( sizeof(void *) );
    *((void **)m_pDebug) = this;
#endif

    LOG((RTC_TRACE, "CRTCParticipant::FinalConstruct [%p] - exit S_OK", this));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipant::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCParticipant::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCParticipant::FinalRelease [%p] - enter", this));

    if ( m_pCClient != NULL )
    {
        m_pCClient->Release();
        m_pCClient = NULL;
    }

    if ( m_szName != NULL )
    {
        RtcFree(m_szName);
        m_szName = NULL;
    }

    if ( m_szUserURI != NULL )
    {
        RtcFree(m_szUserURI);
        m_szUserURI = NULL;
    }

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    LOG((RTC_TRACE, "CRTCParticipant::FinalRelease [%p] - exit", this));
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipant::InternalAddRef
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CRTCParticipant::InternalAddRef()
{
    DWORD dwR;

    dwR = InterlockedIncrement(&m_dwRef);

    LOG((RTC_INFO, "CRTCParticipant::InternalAddRef [%p] - dwR %d", this, dwR));

    if ( (dwR > 0) && m_pSession )
    {
        m_pSession->AddRef();
    }

    return dwR;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipant::InternalRelease
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CRTCParticipant::InternalRelease()
{
    DWORD               dwR;
    
    dwR = InterlockedDecrement(&m_dwRef);

    LOG((RTC_INFO, "CRTCParticipant::InternalRelease [%p] - dwR %d", this, dwR));

    if ( (dwR > 0) && m_pSession )
    {
        m_pSession->Release();
    }

    return dwR;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipant::Initialize
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCParticipant::Initialize(
                            CRTCClient  * pCClient,   
                            IRTCSession * pSession,
                            PCWSTR        szUserURI,
                            PCWSTR        szName,
                            BOOL          bRemovable
                           )
{
    LOG((RTC_TRACE, "CRTCParticipant::Initialize - enter"));

    m_szUserURI = RtcAllocString(szUserURI);
    m_szName = RtcAllocString(szName);
    m_bRemovable = bRemovable;

    m_pCClient = pCClient;
    if (m_pCClient != NULL)
    {
        m_pCClient->AddRef();
    }

    m_pSession = pSession; // don't addref

    LOG((RTC_TRACE, "CRTCParticipant::Initialize - exit S_OK"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipant::GetClient
//
/////////////////////////////////////////////////////////////////////////////

CRTCClient * 
CRTCParticipant::GetClient()
{
    LOG((RTC_TRACE, "CRTCParticipant::GetClient"));

    return m_pCClient;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipant::SetState
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCParticipant::SetState(
                          RTC_PARTICIPANT_STATE enState,
                          long lStatusCode
                         )
{
    LOG((RTC_TRACE, "CRTCParticipant::SetState - enter"));

    //
    // We only need to do something if this is a new state
    //
    
    if (m_enState != enState)
    {
        LOG((RTC_INFO, "CRTCParticipant::SetState - new state"));
        
        m_enState = enState;
    }

    LOG((RTC_INFO, "CRTCParticipant::SetState - "
            "state [%d] status [%d]", enState, lStatusCode));

    //
    // Fire a state change event
    //
    
    CRTCParticipantStateChangeEvent::FireEvent(this, m_enState, lStatusCode);

    LOG((RTC_TRACE, "CRTCParticipant::SetState - exit S_OK"));

    return S_OK;
}    

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipant::get_UserURI
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCParticipant::get_UserURI(
        BSTR * pbstrUserURI
        )
{
    LOG((RTC_TRACE, "CRTCParticipant::get_UserURI - enter"));

    if ( IsBadWritePtr( pbstrUserURI, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCParticipant::get_UserURI - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szUserURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCParticipant::get_UserURI - "
                            "pariticpant has no address"));

        return E_FAIL;
    }

    //
    // Allocate the BSTR to be returned
    //
    
    *pbstrUserURI = SysAllocString(m_szUserURI);

    if ( *pbstrUserURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCParticipant::get_UserURI - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }    
    
    LOG((RTC_TRACE, "CRTCParticipant::get_UserURI - exit S_OK"));

    return S_OK;
}              

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipant::get_Name
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCParticipant::get_Name(
        BSTR * pbstrName
        )
{
    LOG((RTC_TRACE, "CRTCParticipant::get_Name - enter"));

    if ( IsBadWritePtr( pbstrName, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCParticipant::get_Name - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szName == NULL )
    {
        LOG((RTC_ERROR, "CRTCParticipant::get_Name - "
                            "pariticpant has no name"));

        return E_FAIL;
    }

    //
    // Allocate the BSTR to be returned
    //
    
    *pbstrName = SysAllocString(m_szName);

    if ( *pbstrName == NULL )
    {
        LOG((RTC_ERROR, "CRTCParticipant::get_Name - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }    
    
    LOG((RTC_TRACE, "CRTCParticipant::get_Name - exit S_OK"));

    return S_OK;
}        

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipant::get_Removable
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCParticipant::get_Removable(
        VARIANT_BOOL * pfRemovable
        )
{
    LOG((RTC_TRACE, "CRTCParticipant::get_Removable - enter"));

    if ( IsBadWritePtr(pfRemovable , sizeof(VARIANT_BOOL) ) )
    {
        LOG((RTC_ERROR, "CRTCParticipant::get_Removable - bad pointer"));

        return E_POINTER;
    }

    //
    // Cannot be removed if in Disconnecting mode.
    //

    *pfRemovable = (m_bRemovable && 
        m_enState != RTCPS_DISCONNECTING) ? VARIANT_TRUE : VARIANT_FALSE;

    LOG((RTC_TRACE, "CRTCParticipant::get_Removable - exit S_OK"));

    return S_OK;
}        

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipant::get_State
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCParticipant::get_State(
        RTC_PARTICIPANT_STATE * penState
        )
{
    LOG((RTC_TRACE, "CRTCParticipant::get_State - enter"));

    if ( IsBadWritePtr(penState , sizeof(RTC_PARTICIPANT_STATE) ) )
    {
        LOG((RTC_ERROR, "CRTCParticipant::get_State - bad pointer"));

        return E_POINTER;
    }

    *penState = m_enState;
   
    LOG((RTC_TRACE, "CRTCParticipant::get_State - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCParticipant::get_Session
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCParticipant::get_Session(
            IRTCSession ** ppSession
            )
{
    LOG((RTC_TRACE, "CRTCParticipant::get_Session - enter"));

    if ( IsBadWritePtr(ppSession , sizeof(IRTCSession *) ) )
    {
        LOG((RTC_ERROR, "CRTCParticipant::get_Session - bad pointer"));

        return E_POINTER;
    }

    *ppSession = m_pSession;
    if (m_pSession) m_pSession->AddRef();
   
    LOG((RTC_TRACE, "CRTCParticipant::get_Session - exit S_OK"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\rtccoll.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCColl.h

Abstract:

    Template classes for collections

--*/

#ifndef __RTCCOLL__
#define __RTCCOLL__
////////////////////////////////////////////////////////////////////////
// CRtcCollection
//      Collection template
////////////////////////////////////////////////////////////////////////
template <class T> class ATL_NO_VTABLE CRTCCollection :
    public CComDualImpl<IRTCCollection, &IID_IRTCCollection, &LIBID_RTCCORELib>,
    public CComObjectRoot
{
public:
    typedef CRTCCollection<T> _CRTCCollectionBase;

BEGIN_COM_MAP(_CRTCCollectionBase)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IRTCCollection)
END_COM_MAP()

private:

    int                 m_nSize;
    CComVariant *       m_Var;
    
public:

    CRTCCollection() : m_nSize(0),
                       m_Var(NULL)
                       {}


    // initialize
    HRESULT STDMETHODCALLTYPE Initialize(
                                         CRTCObjectArray<T *> array
                                        )
    {
        int                     i;
        HRESULT                 hr;

        LOG((RTC_TRACE, "Initialize - enter"));

        // create variant array
        m_nSize = array.GetSize();

        m_Var = new CComVariant[m_nSize];

        if (m_Var == NULL)
        {
            LOG((RTC_ERROR, "Initialize - out of memory"));
            return E_OUTOFMEMORY;
        }

        for (i = 0; i < array.GetSize(); i++)
        {
            // get IDispatch pointer
            IDispatch * pDisp = NULL;
            IUnknown *  pUnk = NULL;

            // try to get an IDispatch first
            hr = array[i]->QueryInterface(IID_IDispatch, (void**)&pDisp);

            if (S_OK != hr)
            {
                // Try an IUnknown
                hr = array[i]->QueryInterface(IID_IUnknown, (void**)&pUnk);
                
                if (S_OK != hr)
                {
                    // this would be interesting...          
                    return hr;
                }
            }

            // create a variant and add it to the collection
            CComVariant& var = m_Var[i];

            VariantInit(&var);
            
            if(pDisp)
            {
                var.vt = VT_DISPATCH;
                var.pdispVal = pDisp;
            }
            else
            {
                var.vt = VT_UNKNOWN;
                var.punkVal = pUnk;
            }
        }

        this->AddRef();

        LOG((RTC_TRACE, "Initialize - exit"));
        
        return S_OK;
    }

    // initialize
    HRESULT STDMETHODCALLTYPE Initialize(
                                         CRTCArray<T *> array
                                        )
    {
        int                     i;
        HRESULT                 hr;

        LOG((RTC_TRACE, "Initialize - enter"));

        // create variant array
        m_nSize = array.GetSize();

        m_Var = new CComVariant[m_nSize];

        if (m_Var == NULL)
        {
            LOG((RTC_ERROR, "Initialize - out of memory"));
            return E_OUTOFMEMORY;
        }

        for (i = 0; i < array.GetSize(); i++)
        {
            // get IDispatch pointer
            IDispatch * pDisp = NULL;

            hr = array[i]->QueryInterface(IID_IDispatch, (void**)&pDisp);

            if (S_OK != hr)
            {
                return hr;
            }

            // create a variant and add it to the collection
            CComVariant& var = m_Var[i];

            VariantInit(&var);
            
            var.vt = VT_DISPATCH;
            var.pdispVal = pDisp;
        }

        this->AddRef();

        LOG((RTC_TRACE, "Initialize - exit"));
        
        return S_OK;
    }

    void FinalRelease()
    {
        //
        // We "new"ed an array of objects -- delete the array and call
        // each object's destructor. Each destructor calls VariantClear,
        // which calls Release on each pointer.
        //

        if(m_Var != NULL)
        {
            delete [] m_Var;
        }
    }
    
    STDMETHOD(get_Count)(
                         long* retval
                        )
    {
        LOG((RTC_TRACE, "get_Count - enter"));

        if ( IsBadWritePtr( retval, sizeof(long) ) )
        {
            return E_POINTER;
        }
        
        *retval = m_nSize;

        LOG((RTC_TRACE, "get_Count - exit"));

        return S_OK;
    }

    STDMETHOD(get_Item)(
                        long Index, 
                        VARIANT* retval
                       )
    {
        LOG((RTC_TRACE, "get_Item - enter"));

        if ( IsBadWritePtr (retval, sizeof(VARIANT) ) )
        {
            return E_POINTER;
        }
        
        VariantInit(retval);

        retval->vt = VT_UNKNOWN;
        retval->punkVal = NULL;

        // use 1-based index, VB like
        if ((Index < 1) || (Index > m_nSize))
        {
            return E_INVALIDARG;
        }

        VariantCopy(retval, &m_Var[Index-1]);

        LOG((RTC_TRACE, "get_Item - exit"));
        
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE get__NewEnum(
                                           IUnknown** retval
                                          )
    
    {
        HRESULT         hr;

        LOG((RTC_TRACE, "new__Enum - enter"));
        
        if ( IsBadWritePtr( retval, sizeof( IUnknown * ) ) )
        {
            return E_POINTER;
        }

        *retval = NULL;

        typedef CComObject<CComEnum<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _Copy<VARIANT> > > enumvar;

        enumvar* p; // = new enumvar;
        enumvar::CreateInstance( &p );

        _ASSERTE(p);
        
        if (p == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {

            hr = p->Init(&m_Var[0], &m_Var[m_nSize], NULL, AtlFlagCopy);

            if (SUCCEEDED(hr))
            {
                hr = p->QueryInterface(IID_IEnumVARIANT, (void**)retval);
            }

            if (FAILED(hr))
            {
                delete p;
            }
        }

        LOG((RTC_TRACE, "new__Enum - exit"));
        
        return hr;

    }
};

#endif //__RTCCOLL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\rtcparticipant.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCParticipant.h

Abstract:

    Definition of the CRTCParticipant class

--*/

#ifndef __RTCPARTICIPANT__
#define __RTCPARTICIPANT__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CRTCParticipant

class ATL_NO_VTABLE CRTCParticipant :
#ifdef TEST_IDISPATCH
    public IDispatchImpl<IRTCParticipant, &IID_IRTCParticipant, &LIBID_RTCCORELib>, 
#else
    public IRTCParticipant,
#endif
	public CComObjectRoot
{
public:
    CRTCParticipant() : m_pCClient(NULL), 
                        m_pSession(NULL),
                        m_enState(RTCPS_IDLE),
                        m_szUserURI(NULL),
                        m_szName(NULL),
                        m_bRemovable(FALSE)
                        
    {}
BEGIN_COM_MAP(CRTCParticipant)
#ifdef TEST_IDISPATCH
    COM_INTERFACE_ENTRY(IDispatch)
#endif
    COM_INTERFACE_ENTRY(IRTCParticipant)
END_COM_MAP()

    HRESULT FinalConstruct();

    void FinalRelease();

    STDMETHOD_(ULONG, InternalAddRef)();

    STDMETHOD_(ULONG, InternalRelease)(); 

    CRTCClient * GetClient();

    HRESULT Initialize(
                      CRTCClient * pCClient, 
                      IRTCSession * pSession,
                      PCWSTR szUserURI,
                      PCWSTR szName,
                      BOOL   bRemovable = FALSE
                      );

    HRESULT SetState(
                     RTC_PARTICIPANT_STATE enState,
                     long lStatusCode
                    );
            
private:

    CRTCClient            * m_pCClient;
    IRTCSession           * m_pSession;
    RTC_PARTICIPANT_STATE   m_enState;
    PWSTR                   m_szUserURI;
    PWSTR                   m_szName;
    BOOL                    m_bRemovable;
 
#if DBG
    PWSTR                   m_pDebug;
#endif

// IRTCParticipant
public:

    STDMETHOD(get_UserURI)(
            BSTR * pbstrUserURI
            );   

    STDMETHOD(get_Name)(
            BSTR * pbstrName
            );  

    STDMETHOD(get_Removable)(
            VARIANT_BOOL * pfRemovable
            );   

    STDMETHOD(get_State)(
            RTC_PARTICIPANT_STATE * penState
            );

    STDMETHOD(get_Session)(
            IRTCSession ** ppSession
            );
};

#endif //__RTCPARTICIPANT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\rtcbuddy.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCBuddy.h

Abstract:

    Definition of the CRTCBuddy class

--*/

#pragma once


/////////////////////////////////////////////////////////////////////////////
// CRTCBuddy

class ATL_NO_VTABLE CRTCBuddy :
#ifdef TEST_IDISPATCH
    public IDispatchImpl<IRTCBuddy, &IID_IRTCBuddy, &LIBID_RTCCORELib>, 
#else
    public IRTCBuddy,
#endif
    public ISipBuddyNotify,
	public CComObjectRoot
{

friend CRTCClient;

public:
    CRTCBuddy() : m_pCClient(NULL),
                  m_pSIPBuddyManager(NULL),
                  m_szPresentityURI(NULL),
                  m_szName(NULL),
                  m_szData(NULL),
                  m_bPersistent(FALSE),
                  m_pSIPBuddy(NULL),
                  m_enStatus(RTCXS_PRESENCE_OFFLINE),
                  m_hrStatusCode(S_OK),
                  m_szNotes(NULL),
                  m_bShutdown(FALSE),
                  m_pSipRedirectContext(NULL),
                  m_pProfile(NULL),
                  m_lFlags(0)
    {}

BEGIN_COM_MAP(CRTCBuddy)
#ifdef TEST_IDISPATCH
    COM_INTERFACE_ENTRY(IDispatch)
#endif
    COM_INTERFACE_ENTRY(IRTCBuddy)
    COM_INTERFACE_ENTRY(IRTCPresenceContact)
    COM_INTERFACE_ENTRY(ISipBuddyNotify)
END_COM_MAP()

    HRESULT FinalConstruct();

    void FinalRelease();

    STDMETHOD_(ULONG, InternalAddRef)();

    STDMETHOD_(ULONG, InternalRelease)(); 

    CRTCClient * GetClient();

    HRESULT Initialize(
                      CRTCClient        * pCClient,
                      ISIPBuddyManager  * pSIPBuddyManager,
                      PCWSTR              szPresentityURI,
                      PCWSTR              szName,
                      PCWSTR              szData,
                      BOOL                bPersistent,
                      IRTCProfile       * pProfile,
                      long                lFlags
                      );

    HRESULT CreateSIPBuddy();

    HRESULT RemoveSIPBuddy(BOOL bShutdown);

    HRESULT CreateXMLDOMNode( IXMLDOMDocument * pXMLDoc, IXMLDOMNode ** ppXDN );
    
    HRESULT CreateSIPBuddyHelper();

    HRESULT BuddyResub();
          
private:

    CRTCClient            * m_pCClient;
    ISIPBuddyManager      * m_pSIPBuddyManager;
    PWSTR                   m_szPresentityURI;
    PWSTR                   m_szName;
    ISIPBuddy             * m_pSIPBuddy;
    RTC_PRESENCE_STATUS     m_enStatus;
    HRESULT                 m_hrStatusCode;
    PWSTR                   m_szNotes;
    PWSTR                   m_szData;
    BOOL                    m_bPersistent;
    BOOL                    m_bShutdown;
    ISipRedirectContext   * m_pSipRedirectContext;
    IRTCProfile           * m_pProfile;
    long                    m_lFlags;
 
#if DBG
    PWSTR                   m_pDebug;
#endif

// IRTCBuddy
public:

    STDMETHOD(get_PresentityURI)(
            BSTR * pbstrPresentityURI
            );   

    STDMETHOD(put_PresentityURI)(
            BSTR bstrPresentityURI
            );  

    STDMETHOD(get_Name)(
            BSTR * pbstrName
            );

    STDMETHOD(put_Name)(
            BSTR bstrName
            );

    STDMETHOD(get_Data)(
            BSTR * pbstrData
            );

    STDMETHOD(put_Data)(
            BSTR bstrData
            );
	
    STDMETHOD(get_Persistent)(
            VARIANT_BOOL *pfPersistent
            );                 
	
    STDMETHOD(put_Persistent)(
            VARIANT_BOOL fPersistent
            );                 

    STDMETHOD(get_Status)(
            RTC_PRESENCE_STATUS * penStatus
            );

    STDMETHOD(get_Notes)(
            BSTR * pbstrNotes
            );                
    
    
// ISipBuddyNotify

    STDMETHOD(NotifyRedirect)(
        IN  ISipRedirectContext    *pRedirectContext,
        IN  SIP_CALL_STATUS        *pCallStatus
        );

    STDMETHOD(BuddyUnsubscribed)(void);
    
    STDMETHOD(BuddyInfoChange)(void);

    STDMETHOD(BuddyRejected)(
            HRESULT   StatusCode
            );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\rtcclient.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCClient.cpp

Abstract:

    Implementation of the CRTCClient class

--*/

#include "stdafx.h"
#include <dbt.h>
#include <uuids.h>
#include "rtcmedia.h"
#include "sdkinternal.h" // for NM constants

#define OATRUE -1
#define OAFALSE 0

LONG    g_lObjects = 0;

const DWORD INTENSITY_POLL_INTERVAL = 100;
const DWORD VOLUME_CHANGE_DELAY = 100;
const DWORD PRESENCE_STORAGE_DELAY = 5000;
const SHUTDOWN_TIMEOUT_DELAY = 5000;

extern HKEY g_hRegistryHive;
extern const WCHAR * g_szProvisioningKeyName;

HRESULT 
RTCTuningWizard(
                IRTCClient * pRTCClient,
                HINSTANCE hInst, 
                HWND hwndParent,
                IRTCTerminalManage * pRTCTerminalManager,
                BOOL * pfAudioCapture,
                BOOL * pfAudioRender,
                BOOL * pfVideo
                );

#ifdef TEST_IDISPATCH

/////////////////////////////////////////////////////////////////////////////
// IDispatch implementation
//

typedef IDispatchImpl<IRTCClientVtbl<CRTCClient>,
                      &IID_IRTCClient,
                      &LIBID_RTCCORELib>
        ClientType;

typedef IDispatchImpl<IRTCClientPresenceVtbl<CRTCClient>, 
                      &IID_IRTCClientPresence,
                      &LIBID_RTCCORELib>
        ClientPresenceType;

typedef IDispatchImpl<IRTCClientProvisioningVtbl<CRTCClient>, 
                      &IID_IRTCClientProvisioning,
                      &LIBID_RTCCORELib>
        ClientProvisioningType;

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::GetIDsOfNames
//
// Overidden IDispatch method
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCClient::GetIDsOfNames(REFIID riid, 
                          LPOLESTR* rgszNames, 
                          UINT cNames, 
                          LCID lcid, 
                          DISPID* rgdispid
                         ) 
{ 
    HRESULT hr = DISP_E_UNKNOWNNAME;

    // See if the requsted method belongs to the default interface
    hr = ClientType::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((RTC_INFO, "CRTCClient::GetIDsOfNames - found %S on IRTCClient", *rgszNames));

        rgdispid[0] |= IDISPCLIENT;
        return hr;
    }

    // If not, then try the IRTCClientPresence interface
    hr = ClientPresenceType::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((RTC_INFO, "CRTCClient::GetIDsOfNames - found %S on IRTCClientPresence", *rgszNames));
        rgdispid[0] |= IDISPCLIENTPRESENCE;
        return hr;
    }

    // If not, then try the IRTCClientProvisioning interface
    hr = ClientProvisioningType::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((RTC_INFO, "CRTCClient::GetIDsOfNames - found %S on IRTCClientProvisioning", *rgszNames));
        rgdispid[0] |= IDISPCLIENTPROVISIONING;
        return hr;
    }

    LOG((RTC_INFO, "CRTCClient::GetIDsOfNames - Didn't find %S on our iterfaces", *rgszNames));

    return hr; 
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::Invoke
//
// Overidden IDispatch method
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCClient::Invoke(DISPID dispidMember, 
                   REFIID riid, 
                   LCID lcid, 
                   WORD wFlags, 
                   DISPPARAMS* pdispparams, 
                   VARIANT* pvarResult, 
                   EXCEPINFO* pexcepinfo, 
                   UINT* puArgErr
                  )
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    DWORD   dwInterface = (dispidMember & INTERFACEMASK);
    
    LOG((RTC_INFO, "CRTCClient::Invoke - dispidMember %X", dispidMember));

    // Call invoke for the required interface
    switch (dwInterface)
    {
        case IDISPCLIENT:
        {
            hr = ClientType::Invoke(dispidMember, 
                                        riid, 
                                        lcid, 
                                        wFlags, 
                                        pdispparams,
                                        pvarResult, 
                                        pexcepinfo, 
                                        puArgErr
                                       );
            break;
        }
        case IDISPCLIENTPRESENCE:
        {
            hr = ClientPresenceType::Invoke(dispidMember, 
                                        riid, 
                                        lcid, 
                                        wFlags, 
                                        pdispparams,
                                        pvarResult, 
                                        pexcepinfo, 
                                        puArgErr
                                       );
            break;
        }
        case IDISPCLIENTPROVISIONING:
        {
            hr = ClientProvisioningType::Invoke(dispidMember, 
                                        riid, 
                                        lcid, 
                                        wFlags, 
                                        pdispparams,
                                        pvarResult, 
                                        pexcepinfo, 
                                        puArgErr
                                       );
            break;
        }

    } // end switch (dwInterface)

    LOG((RTC_INFO, "CRTCClient::Invoke - exit"));

    return hr;
}

#endif // TEST_IDISPATCH

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::InternalAddRef
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CRTCClient::InternalAddRef()
{
    DWORD dwR;

    dwR = InterlockedIncrement(&m_dwRef);

    LOG((RTC_INFO, "CRTCClient::InternalAddRef [%p] - dwR %d", this, dwR));

    return dwR;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::InternalRelease
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CRTCClient::InternalRelease()
{
    DWORD               dwR;
    
    dwR = InterlockedDecrement(&m_dwRef);

    LOG((RTC_INFO, "CRTCClient::InternalRelease [%p] - dwR %d", this, dwR));

    return dwR;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::FinalConstruct
//
// This gets called when the object is CoCreated. Returning an error
// code from this function will cause the object creation to fail.
//
// We enforce that this object must be a singleton by failing to create
// additional objects.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::FinalConstruct()
{
    HRESULT hr;
    
    LOG((RTC_TRACE, "CRTCClient::FinalConstruct [%p] - enter", this));

#if DBG
    m_pDebug = (PWSTR) RtcAlloc( sizeof(void *) );
    *((void **)m_pDebug) = this;
#endif    

    if ( InterlockedIncrement(&g_lObjects) == 1 )
    {
        //
        // This is the first object
        //

        //
        // Register for steelhead tracing
        //

        LOGREGISTERTRACING(_T("RTCDLL"));
    }
    
    LOG((RTC_TRACE, "CRTCClient::FinalConstruct [%p] - exit S_OK", this));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::FinalRelease
//
// This gets called when the object is destroyed.
//
/////////////////////////////////////////////////////////////////////////////

void
CRTCClient::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCClient::FinalRelease [%p] - enter", this));   

    //
    // Are we already shutdown?
    //

    if ( (m_enRtcState != RTC_STATE_NULL) &&
         (m_enRtcState != RTC_STATE_SHUTDOWN) )
    {
        LOG((RTC_ERROR, "CRTCClient::FinalRelease [%p] - shutdown was not called", this));   

        Shutdown();
    }

    //
    // Shutdown the media manager
    //

    if ( m_pMediaManage != NULL )
    {
        m_pMediaManage->Shutdown();

        m_pMediaManage->Release();
        m_pMediaManage = NULL;
    }

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    if ( InterlockedDecrement(&g_lObjects) == 0)
    {
        //
        // This was the last object
        //             
      
        //
        // Deregister for steelhead tracing
        //
        
        LOGDEREGISTERTRACING();   
    }
     
    LOG((RTC_TRACE, "CRTCClient::FinalRelease [%p] - exit", this));    
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::GetMediaManager
//
/////////////////////////////////////////////////////////////////////////////

HRESULT CRTCClient::GetMediaManager(
        IRTCMediaManage ** ppMediaManager
        )
{
    if (m_pMediaManage == NULL)
    {
        return E_FAIL;
    }

    *ppMediaManager = m_pMediaManage;
    (*ppMediaManager)->AddRef();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::WndProc
//
// This is the client's window procedure
//
/////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK
CRTCClient::WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{ 
    if (uMsg == WM_CREATE)
    {
        SetLastError(0);
        if ( !SetWindowLongPtr(hwnd,
                               GWLP_USERDATA,
                               (LONG_PTR)(((LPCREATESTRUCT)lParam)->lpCreateParams)
                              ) )
        {
            if (GetLastError())  // It isn't really an error unless get last error says so
            {
                LOG((RTC_ERROR, "CRTCClient::WndProc - "
                        "SetWindowLongPtr failed %ld", GetLastError()));

                return -1;
            }
        }
    }
    else
    {
        CRTCClient *me = (CRTCClient *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

        switch (uMsg) 
        { 
            case WM_STREAMING:
                LOG((RTC_INFO, "CRTCClient::WndProc - "
                            "WM_STREAMING"));  
                
                me->OnStreamingEvent( (RTCMediaEventItem *)lParam );

                break;

            case MM_MIXM_LINE_CHANGE:
                LOG((RTC_INFO, "CRTCClient::WndProc - "
                            "MM_MIXM_LINE_CHANGE"));  

                me->OnMixerChange();

                break;

            case MM_MIXM_CONTROL_CHANGE:
                LOG((RTC_INFO, "CRTCClient::WndProc - "
                            "MM_MIXM_CONTROL_CHANGE"));  

                me->OnMixerChange();

                break;

            case WM_DEVICECHANGE: 
                switch(wParam)
                {
                case DBT_DEVICEARRIVAL:
                    LOG((RTC_INFO, "CRTCClient::WndProc - "
                            "DBT_DEVICEARRIVAL"));

                    me->OnDeviceChange();

                    break;

                case DBT_DEVICEREMOVECOMPLETE:
                    LOG((RTC_INFO, "CRTCClient::WndProc - "
                            "DBT_DEVICEREMOVECOMPLETE"));

                    me->OnDeviceChange();

                    break;
                }
                break;

            case WM_TIMER:                
                switch(wParam)
                {
                case TID_INTENSITY:                
                    me->OnIntensityTimer();

                    break;

                case TID_PRESENCE_STORAGE:
                    me->OnPresenceStorageTimer();

                    break;

                case TID_SHUTDOWN_TIMEOUT:
                    me->OnShutdownTimeout();

                    break;

                case TID_VOLUME_CHANGE:
                    me->OnVolumeChangeTimer();

                    break;

                case TID_DTMF_TIMER:
                    me->OnDTMFTimer();

                    break;
                }
                break;

            case WM_BUDDY_UNSUB:
                LOG((RTC_INFO, "CRTCClient::WndProc - "
                            "WM_BUDDY_UNSUB"));

                me->OnBuddyUnsub((IRTCBuddy *)wParam, (BOOL)lParam);

                break;

            case WM_PROFILE_UNREG:
                LOG((RTC_INFO, "CRTCClient::WndProc - "
                            "WM_PROFILE_UNREG"));

                me->OnProfileUnreg((IRTCProfile *)wParam);

                break;

            case WM_ASYNC_CLEANUP_DONE:
                LOG((RTC_INFO, "CRTCClient::WndProc - "
                            "WM_ASYNC_CLEANUP_DONE"));

                me->OnAsyncCleanupDone();

                break;
 
            case WM_DESTROY: 
                LOG((RTC_INFO, "CRTCClient::WndProc - "
                            "WM_DESTROY"));
                return 0; 
 
            default: 
                return DefWindowProc(hwnd, uMsg, wParam, lParam); 
        } 
    }
    return 0; 
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::OnMixerChange
//
/////////////////////////////////////////////////////////////////////////////
void
CRTCClient::OnMixerChange()
{
    //LOG((RTC_TRACE, "CRTCClient::OnMixerChange - enter"));

    //
    // Start the volume change timer
    //

    if ( !m_fVolumeChangeInProgress )
    {
        DWORD dwID = (DWORD)SetTimer(m_hWnd, TID_VOLUME_CHANGE, VOLUME_CHANGE_DELAY, NULL);
        if (dwID==0)
        {
            LOG((RTC_ERROR, "CRTCClient::OnMixerChange - "
                           "SetTimer failed %d", GetLastError()));

            return;
        }

        m_fVolumeChangeInProgress = TRUE;
    }

    //LOG((RTC_TRACE, "CRTCClient::OnMixerChange - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::OnVolumeChangeTimer
//
/////////////////////////////////////////////////////////////////////////////
void
CRTCClient::OnVolumeChangeTimer()
{
    //LOG((RTC_TRACE, "CRTCClient::OnVolumeChangeTimer - enter"));

    //
    // Kill the volume change timer
    //

    KillTimer(m_hWnd, TID_VOLUME_CHANGE);

    m_fVolumeChangeInProgress = FALSE;

    //
    // Fire the event
    //

    CRTCClientEvent::FireEvent(this, RTCCET_VOLUME_CHANGE);

    //LOG((RTC_TRACE, "CRTCClient::OnVolumeChangeTimer - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::OnBuddyUnsub
//
// This helper function handles buddy unsubscribes on shutdown
//
/////////////////////////////////////////////////////////////////////////////
void 
CRTCClient::OnBuddyUnsub(IRTCBuddy * pBuddy, BOOL bShutdown)
{
    LOG((RTC_TRACE, "CRTCClient::OnBuddyUnsub - enter"));

    if ( bShutdown )
    {
        //
        // Remove the buddy from our array
        //

        if ( pBuddy != NULL )
        {
            m_BuddyArray.Remove(pBuddy);
        }

        //
        // Check if all the buddies are unsubscribed
        //

        if ( m_enRtcState == RTC_STATE_PREPARING_SHUTDOWN )
        {
            if ( m_BuddyArray.GetSize() == 0 )
            {
                LOG((RTC_INFO, "CRTCClient::OnBuddyUnsub - all buddies are unsubscribed"));
        
                InternalPrepareForShutdown2(TRUE);
            }
            else
            {
                LOG((RTC_INFO, "CRTCClient::OnBuddyUnsub - %d remaining buddies", m_BuddyArray.GetSize()));
            }
        }
    }
    else
    {
        //
        // The SIP watcher on the other side has sent us an UNSUB. We must
        // recreate our SIP buddy to send another SUB request.
        //

        CRTCBuddy * pCBuddy;
        HRESULT hr;

        pCBuddy = static_cast<CRTCBuddy *>(pBuddy);

        hr = pCBuddy->BuddyResub();

        if ( FAILED(hr) )
        {        
            LOG((RTC_ERROR, "CRTCClient::OnBuddyUnsub - "
                            "BuddyResub failed 0x%lx", hr));
        }
    }

    if ( pBuddy != NULL )
    {
        pBuddy->Release();
    }

    LOG((RTC_TRACE, "CRTCClient::OnBuddyUnsub - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::OnProfileUnreg
//
// This helper function handles profile unregisters on shutdown
//
/////////////////////////////////////////////////////////////////////////////
void 
CRTCClient::OnProfileUnreg(IRTCProfile * pProfile)
{
    LOG((RTC_TRACE, "CRTCClient::OnProfileUnreg - enter"));

    //
    // Remove the profile from our array
    //

    if ( pProfile != NULL )
    {
        m_HiddenProfileArray.Remove(pProfile);
    }

    //
    // Check if all the profiles are unsubscribed
    //

    if ( m_enRtcState == RTC_STATE_PREPARING_SHUTDOWN2 )
    {
        if ( m_HiddenProfileArray.GetSize() == 0 )
        {
            LOG((RTC_INFO, "CRTCClient::OnProfileUnreg - all proflies are unregistered"));
        
            InternalPrepareForShutdown3(TRUE);
        }
        else
        {
            LOG((RTC_INFO, "CRTCClient::OnProfileUnreg - %d remaining profiles", m_HiddenProfileArray.GetSize()));
        }
    }

    LOG((RTC_TRACE, "CRTCClient::OnProfileUnreg - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::OnAsyncCleanupDone
//
// This helper function fires the RTCCET_ASYNC_CLEANUP_DONE event
//
/////////////////////////////////////////////////////////////////////////////
void 
CRTCClient::OnAsyncCleanupDone()
{
    LOG((RTC_TRACE, "CRTCClient::OnAsyncCleanupDone - enter"));

    CRTCClientEvent::FireEvent( this, RTCCET_ASYNC_CLEANUP_DONE );

    LOG((RTC_TRACE, "CRTCClient::OnAsyncCleanupDone - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::OnShutdownTimeout
//
/////////////////////////////////////////////////////////////////////////////

void CRTCClient::OnShutdownTimeout()
{
    LOG((RTC_TRACE, "CRTCClient::OnShutdownTimeout - enter"));

    // Kill the timer
    KillTimer(m_hWnd, TID_SHUTDOWN_TIMEOUT);

    LOG((RTC_INFO, "CRTCClient::OnShutdownTimeout - shutdown timed out"));
    
    if ( m_enRtcState == RTC_STATE_PREPARING_SHUTDOWN )
    {
        //
        // We must cleanup any remaining buddies that could not
        // be unsubscribed.
        //
        m_BuddyArray.Shutdown();

        //
        // Continue shutdown
        //
        InternalPrepareForShutdown2(TRUE);
    }
    else if ( m_enRtcState == RTC_STATE_PREPARING_SHUTDOWN2 )
    {
        //
        // We must cleanup any remaining profiles that could not
        // be unregistered
        //
        m_HiddenProfileArray.Shutdown();

        //
        // Continue shutdown
        //
        InternalPrepareForShutdown3(TRUE);
    }
    else if ( m_enRtcState == RTC_STATE_PREPARING_SHUTDOWN3 )
    {
        //
        // Continue shutdown
        //
        InternalReadyForShutdown();
    }

    LOG((RTC_TRACE, "CRTCClient::OnShutdownTimeout - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::OnStreamingEvent
//
// This helper function handles streaming events
//
/////////////////////////////////////////////////////////////////////////////
void
CRTCClient::OnStreamingEvent(
        RTCMediaEventItem * pEvent
        )
{
    LOG((RTC_TRACE, "CRTCClient::OnStreamingEvent - enter"));

    switch( pEvent->Event )
    {
    case RTC_ME_STREAM_CREATED:   // new stream created by media
        {            
            LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                    "RTC_ME_STREAM_CREATED"));

            if ( pEvent->MediaType == RTC_MT_AUDIO )
            {
                if ( pEvent->Direction == RTC_MD_CAPTURE )
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "audio send created"));                    
                }
                else
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "audio receive created"));
                }
            }
            else if ( pEvent->MediaType == RTC_MT_VIDEO )
            {
                if ( pEvent->Direction == RTC_MD_CAPTURE )
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "video send created"));
                }
                else
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "audio receive created"));
                }
            }
            else if ( pEvent->MediaType == RTC_MT_DATA )
            {
                LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "T120 stream created"));
            }
        }
        break;

    case RTC_ME_STREAM_REMOVED:   // stream removed by media
        {            
            LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                    "RTC_ME_STREAM_REMOVED"));

            if ( pEvent->MediaType == RTC_MT_AUDIO )
            {
                if ( pEvent->Direction == RTC_MD_CAPTURE )
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "audio send removed"));                    
                }
                else
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "audio receive removed"));
                }
            }
            else if ( pEvent->MediaType == RTC_MT_VIDEO )
            {
                if ( pEvent->Direction == RTC_MD_CAPTURE )
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "video send removed"));;
                }
                else
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "video receive removed"));
                }
            }
            else if ( pEvent->MediaType == RTC_MT_DATA )
            {
                LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "T120 stream removed"));
            }
        }
        break;

    case RTC_ME_STREAM_ACTIVE:    // stream active
        {
            LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                    "RTC_ME_STREAM_ACTIVE"));

            LONG lMediaType;

            if ( pEvent->MediaType == RTC_MT_AUDIO )
            {
                if ( pEvent->Direction == RTC_MD_CAPTURE )
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "audio send started"));

                    lMediaType = RTCMT_AUDIO_SEND;

                    m_lActiveMedia |= RTCMT_AUDIO_SEND;

                    m_bCaptureDeviceMuted = FALSE;
                }
                else
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "audio receive started"));

                    lMediaType = RTCMT_AUDIO_RECEIVE;

                    m_lActiveMedia |= RTCMT_AUDIO_RECEIVE;
                }
            }
            else if ( pEvent->MediaType == RTC_MT_VIDEO )
            {               
                if ( pEvent->Direction == RTC_MD_CAPTURE )
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "video send started"));

                    lMediaType = RTCMT_VIDEO_SEND;     
                    
                    m_lActiveMedia |= RTCMT_VIDEO_SEND;
                }
                else
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "video receive started"));

                    lMediaType = RTCMT_VIDEO_RECEIVE;

                    m_lActiveMedia |= RTCMT_VIDEO_RECEIVE;
                }
            }
            else if ( pEvent->MediaType == RTC_MT_DATA )
            {
                LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "T120 stream started"));

                lMediaType = RTCMT_T120_SENDRECV;

                m_lActiveMedia |= RTCMT_T120_SENDRECV;
            }

            LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                    "cause %d", pEvent->Cause));
            
            switch( pEvent->Cause )
            {
            case RTC_ME_CAUSE_REMOTE_HOLD:
                CRTCMediaEvent::FireEvent(this, RTCMET_STARTED, RTCMER_HOLD, lMediaType);
                break;

            case RTC_ME_CAUSE_TIMEOUT:
                CRTCMediaEvent::FireEvent(this, RTCMET_STARTED, RTCMER_TIMEOUT, lMediaType);
                break;

            default:
                CRTCMediaEvent::FireEvent(this, RTCMET_STARTED, RTCMER_NORMAL, lMediaType);
            } 

            // Also, we start the intensity monitor here.. 
            StartIntensityMonitor(lMediaType);

        }
        break;

    case RTC_ME_STREAM_INACTIVE:  // stream inactive
        {
            LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                    "RTC_ME_STREAM_INACTIVE"));

            LONG lMediaType;

            if ( pEvent->MediaType == RTC_MT_AUDIO )
            {
                if ( pEvent->Direction == RTC_MD_CAPTURE )
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "audio send stopped"));

                    lMediaType = RTCMT_AUDIO_SEND;

                    m_lActiveMedia &= ~RTCMT_AUDIO_SEND;
                }
                else
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "audio receive stopped"));

                    lMediaType = RTCMT_AUDIO_RECEIVE;

                    m_lActiveMedia &= ~RTCMT_AUDIO_RECEIVE;
                }
            }
            else if ( pEvent->MediaType == RTC_MT_VIDEO )
            {
                if ( pEvent->Direction == RTC_MD_CAPTURE )
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "video send stopped"));

                    lMediaType = RTCMT_VIDEO_SEND;

                    m_lActiveMedia &= ~RTCMT_VIDEO_SEND;
                }
                else
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "video receive stopped"));

                    lMediaType = RTCMT_VIDEO_RECEIVE;

                    m_lActiveMedia &= ~RTCMT_VIDEO_RECEIVE;
                }
            }
            else if ( pEvent->MediaType == RTC_MT_DATA )
            {
                LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "T120 stream stopped"));

                lMediaType = RTCMT_T120_SENDRECV;

                m_lActiveMedia &= ~RTCMT_T120_SENDRECV;
            }

            LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                    "cause %d", pEvent->Cause));

            switch( pEvent->Cause )
            {
            case RTC_ME_CAUSE_REMOTE_HOLD:
                CRTCMediaEvent::FireEvent(this, RTCMET_STOPPED, RTCMER_HOLD, lMediaType);
                break;

            case RTC_ME_CAUSE_TIMEOUT:
                CRTCMediaEvent::FireEvent(this, RTCMET_STOPPED, RTCMER_TIMEOUT, lMediaType);
                break;

            default:
                CRTCMediaEvent::FireEvent(this, RTCMET_STOPPED, RTCMER_NORMAL, lMediaType);
            }          

            // Also, we stop the intensity monitor here.. 
            StopIntensityMonitor(lMediaType);

        }
        break;

    case RTC_ME_STREAM_FAIL:      // stream failed due to some error
        {
            LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                    "RTC_ME_STREAM_FAIL"));

            LONG lMediaType;

            if ( pEvent->MediaType == RTC_MT_AUDIO )
            {
                if ( pEvent->Direction == RTC_MD_CAPTURE )
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "audio send failed"));

                    lMediaType = RTCMT_AUDIO_SEND;
                }
                else
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "audio receive failed"));

                    lMediaType = RTCMT_AUDIO_RECEIVE;
                }
            }
            else if ( pEvent->MediaType == RTC_MT_VIDEO )
            {
                if ( pEvent->Direction == RTC_MD_CAPTURE )
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "video send failed"));

                    lMediaType = RTCMT_VIDEO_SEND;
                }
                else
                {
                    LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "video receive failed"));

                    lMediaType = RTCMT_VIDEO_RECEIVE;
                }
            }
            else if ( pEvent->MediaType == RTC_MT_DATA )
            {
                LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                            "T120 stream failed"));

                lMediaType = RTCMT_T120_SENDRECV;
            }

            switch( pEvent->Cause )
            {
            case RTC_ME_CAUSE_UNKNOWN:
                LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                        "cause RTC_ME_CAUSE_UNKNOWN"));

                CRTCMediaEvent::FireEvent(this, RTCMET_FAILED, RTCMER_NORMAL, lMediaType);
                break;

            case RTC_ME_CAUSE_BAD_DEVICE:
                LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                        "cause RTC_ME_CAUSE_BAD_DEVICE"));

                CRTCMediaEvent::FireEvent(this, RTCMET_FAILED, RTCMER_BAD_DEVICE, lMediaType);
                break;

            case RTC_ME_CAUSE_CRYPTO:
                LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                        "cause RTC_ME_CAUSE_CRYPTO"));

                CRTCMediaEvent::FireEvent(this, RTCMET_FAILED, RTCMER_NORMAL, lMediaType);
                break;

            default:
                LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                        "cause %d", pEvent->Cause ));                
            }
        }
        break;

    case RTC_ME_T120_FAIL:      // T120 failed due to some error
        {
            LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                    "RTC_ME_T120_FAIL"));

            switch( pEvent->Cause )
            {
            case RTC_ME_CAUSE_T120_INITIALIZE:
                LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                        "cause RTC_ME_CAUSE_T120_INITIALIZE"));
                break;
            case RTC_ME_CAUSE_T120_OUTGOING_CALL:
                LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                        "cause RTC_ME_CAUSE_T120_OUTGOING_CALL"));
                break;
            case RTC_ME_CAUSE_T120_INCOMING_CALL:
                LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                        "cause RTC_ME_CAUSE_T120_INCOMING_CALL"));
                break;
            case RTC_ME_CAUSE_T120_START_APPLET:
                LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                        "cause RTC_ME_CAUSE_T120_START_APPLET"));
                break;
            }
        }
        break;

    case RTC_ME_TERMINAL_REMOVED: // usb device removed
        {
            LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                    "RTC_ME_TERMINAL_REMOVED"));            
        }
        break;

    case RTC_ME_VOLUME_CHANGE:    // volume change
        {
            LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                    "RTC_ME_VOLUME_CHANGE"));
        }
        break;

    case RTC_ME_REQUEST_RELEASE_WAVEBUF: // we need to close the wave device
        {
            LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                    "RTC_ME_REQUEST_RELEASE_WAVEBUF"));

            if (m_pWavePlayerSystemDefault != NULL)
            {
                m_pWavePlayerSystemDefault->CloseWaveDevice();
            }

            if (m_pWavePlayerRenderTerminal != NULL)
            {
                m_pWavePlayerRenderTerminal->CloseWaveDevice();
            }
        }
        break;

    case RTC_ME_LOSSRATE: // forward the lossrate to media controller
        {
            LOG((RTC_INFO, "CRTCClient::OnStreamingEvent - "
                    "RTC_ME_LOSSRATE"));

            if (m_pMediaManage != NULL)
            {
                m_pMediaManage->OnLossrate(
                                    pEvent->MediaType,
                                    pEvent->Direction,
                                    (DWORD)pEvent->hrError
                                    );
            }
        }
        break;

    case RTC_ME_BANDWIDTH:
        {
            if (m_pMediaManage != NULL)
            {
                m_pMediaManage->OnBandwidth(
                                    pEvent->MediaType,
                                    pEvent->Direction,
                                    (DWORD)pEvent->hrError
                                    );
            }
        }
        break;

    case RTC_ME_NETWORK_QUALITY:
        {

            //
            // Fire an RTC_CLIENT_EVENT (RTCCET_NETWORK_QUALITY_CHANGE)
            //
            // I don't care wether it's audio or video
            // the notification is only for SEND, unfortunately

            CRTCClientEvent::FireEvent(
                this,
                RTCCET_NETWORK_QUALITY_CHANGE);
        }
        break;

    default:
        LOG((RTC_ERROR, "CRTCClient::OnStreamingEvent - "
                "unknown event [0x%lx]", pEvent->Event));
    }

    //
    // Free the event structure
    //

    if (m_pMediaManage != NULL)
    {
        m_pMediaManage->FreeMediaEvent( pEvent );
    }

    LOG((RTC_TRACE, "CRTCClient::OnStreamingEvent - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::OnDeviceChange
//
// This helper function handles device change events
//
/////////////////////////////////////////////////////////////////////////////
void 
CRTCClient::OnDeviceChange()
{
    LOG((RTC_TRACE, "CRTCClient::OnDeviceChange - enter"));

    HRESULT hr;
    IRTCTerminalManage * pTerminalManage = NULL;

    //
    // Mark our cached media capabilities as invalid
    //

    m_fMediaCapsCached = FALSE;

    //
    // Get the IRTCTerminalManage interface
    //

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTerminalManage,
                           (void **)&pTerminalManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::OnDeviceChange - "
                            "QI failed 0x%lx", hr));
        
        return;
    }

    //
    // Get the old terminal list
    //

    IRTCTerminal ** ppOldTerminals = NULL;
    DWORD dwOldCount = 0;

    hr = GetTerminalList( pTerminalManage, &ppOldTerminals, &dwOldCount );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::OnDeviceChange - "
                            "GetTerminalList failed 0x%lx", hr));

        pTerminalManage->Release();
        pTerminalManage = NULL;

        return;
    }

    //
    // Get the old selected terminals
    //

    IRTCTerminal * pAudioCapture = NULL;
    IRTCTerminal * pAudioRender = NULL;
    IRTCTerminal * pVideoCapture = NULL;

    hr = pTerminalManage->GetDefaultTerminal( RTC_MT_AUDIO, RTC_MD_CAPTURE, &pAudioCapture );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::OnDeviceChange - "
                            "GetDefaultTerminal(AudioCapture) failed 0x%lx", hr));
    }

    hr = pTerminalManage->GetDefaultTerminal( RTC_MT_AUDIO, RTC_MD_RENDER, &pAudioRender );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::OnDeviceChange - "
                            "GetDefaultTerminal(AudioRender) failed 0x%lx", hr));
    }

    hr = pTerminalManage->GetDefaultTerminal( RTC_MT_VIDEO, RTC_MD_CAPTURE, &pVideoCapture );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::OnDeviceChange - "
                            "GetDefaultTerminal(VideoCapture) failed 0x%lx", hr));
    }

    //
    // Get the terminal manager to renumerate the static terminals
    //
    
    hr = pTerminalManage->UpdateStaticTerminals();
   
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::OnDeviceChange - "
                            "UpdateStaticTerminals failed 0x%lx", hr));
    
        if ( pAudioCapture != NULL )
        {
            pAudioCapture->Release();
            pAudioCapture = NULL;
        }

        if ( pAudioRender != NULL )
        {
            pAudioRender->Release();
            pAudioRender = NULL;
        }

        if ( pVideoCapture != NULL )
        {
            pVideoCapture->Release();
            pVideoCapture = NULL;
        }

        pTerminalManage->Release();
        pTerminalManage = NULL;

        FreeTerminalList( ppOldTerminals, dwOldCount );
        ppOldTerminals = NULL;

        return;
    }

    //
    // Get the new terminal list
    //

    IRTCTerminal ** ppNewTerminals = NULL;
    DWORD dwNewCount = 0;

    hr = GetTerminalList( pTerminalManage, &ppNewTerminals, &dwNewCount );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::OnDeviceChange - "
                            "GetTerminalList failed 0x%lx", hr));

        if ( pAudioCapture != NULL )
        {
            pAudioCapture->Release();
            pAudioCapture = NULL;
        }

        if ( pAudioRender != NULL )
        {
            pAudioRender->Release();
            pAudioRender = NULL;
        }

        if ( pVideoCapture != NULL )
        {
            pVideoCapture->Release();
            pVideoCapture = NULL;
        }

        pTerminalManage->Release();
        pTerminalManage = NULL;

        FreeTerminalList( ppOldTerminals, dwOldCount );
        ppOldTerminals = NULL;

        return;
    }

    //
    // Compare terminal lists
    //

    DWORD dwOld, dwNew;

    for ( dwNew = 0; dwNew < dwNewCount; dwNew++ )
    {
        BOOL bIsAdded = TRUE;

        for ( dwOld = 0; dwOld < dwOldCount; dwOld++ )
        {
            if ( ppNewTerminals[dwNew] == ppOldTerminals[dwOld] )
            {
                bIsAdded = FALSE;
            }
        }

        if ( bIsAdded )
        {
            //
            // Added terminal found
            //

            RTC_MEDIA_TYPE mt;
            RTC_MEDIA_DIRECTION md;
            WCHAR * szDescription;
           
            //
            // Get terminal media type, direction, and description
            //

            ppNewTerminals[dwNew]->GetMediaType( &mt );
            ppNewTerminals[dwNew]->GetDirection( &md );

            hr = ppNewTerminals[dwNew]->GetDescription( &szDescription );       

            if ( SUCCEEDED(hr) )
            {
                LOG((RTC_INFO, "CRTCClient::OnDeviceChange - "
                            "added terminal: '%ws' mt: %d md: %d",
                            szDescription, mt, md));
            }

            ppNewTerminals[dwNew]->FreeDescription( szDescription ); 
            
            //
            // Is a terminal of this type currently selected?
            //

            BOOL bIsSelected = TRUE;

            if ( mt == RTC_MT_AUDIO )
            {
                if ( md == RTC_MD_CAPTURE )
                {
                    if ( pAudioCapture == NULL )
                    {
                        bIsSelected = FALSE;
                    }
                }
                else
                {
                    if ( pAudioRender == NULL )
                    {
                        bIsSelected = FALSE;
                    }
                }
            }
            else
            {
                if ( md == RTC_MD_CAPTURE )
                {
                    if ( pVideoCapture == NULL )
                    {
                        bIsSelected = FALSE;
                    }
                }
            }

            if ( !bIsSelected )
            {
                //
                // No, select the terminal
                //

                LOG((RTC_INFO, "CRTCClient::OnDeviceChange - "
                                "selecting a default terminal"));

                hr = pTerminalManage->SetDefaultStaticTerminal( mt, md, ppNewTerminals[dwNew] );

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCClient::OnDeviceChange - "
                                        "SetDefaultStaticTerminal failed 0x%lx", hr));
                }
            }
        }
    }

    for ( dwOld = 0; dwOld < dwOldCount; dwOld++ )
    {
        BOOL bIsRemoved = TRUE;

        for ( dwNew = 0; dwNew < dwNewCount; dwNew++ )
        {
            if ( ppNewTerminals[dwNew] == ppOldTerminals[dwOld] )
            {
                bIsRemoved = FALSE;
            }
        }

        if ( bIsRemoved )
        {
            //
            // Removed terminal found
            //

            RTC_MEDIA_TYPE mt;
            RTC_MEDIA_DIRECTION md;
            WCHAR * szDescription;
           
            //
            // Get terminal media type, direction, and description
            //

            ppOldTerminals[dwOld]->GetMediaType( &mt );
            ppOldTerminals[dwOld]->GetDirection( &md );

            hr = ppOldTerminals[dwOld]->GetDescription( &szDescription );       

            if ( SUCCEEDED(hr) )
            {
                LOG((RTC_INFO, "CRTCClient::OnDeviceChange - "
                            "removed terminal: '%ws' mt: %d md: %d",
                            szDescription, mt, md));
            }

            ppOldTerminals[dwOld]->FreeDescription( szDescription );  

            //
            // Is this the currently selected terminal?
            //

            BOOL bIsSelected = FALSE;

            if ( mt == RTC_MT_AUDIO )
            {
                if ( md == RTC_MD_CAPTURE )
                {
                    if ( pAudioCapture == ppOldTerminals[dwOld] )
                    {
                        bIsSelected = TRUE;
                    }
                }
                else
                {
                    if ( pAudioRender == ppOldTerminals[dwOld] )
                    {
                        bIsSelected = TRUE;
                    }
                }
            }
            else
            {
                if ( md == RTC_MD_CAPTURE )
                {
                    if ( pVideoCapture == ppOldTerminals[dwOld] )
                    {
                        bIsSelected = TRUE;
                    }
                }
            }

            if ( bIsSelected )
            {
                //
                // Yes, this terminal is selected
                //

                LOG((RTC_INFO, "CRTCClient::OnDeviceChange - "
                            "selected terminal removed"));

                //
                // Is there a terminal available to replace this one?
                //

                for ( dwNew = 0; dwNew < dwNewCount; dwNew++ )
                {
                    RTC_MEDIA_TYPE mtNew;
                    RTC_MEDIA_DIRECTION mdNew;

                    ppNewTerminals[dwNew]->GetMediaType( &mtNew );
                    ppNewTerminals[dwNew]->GetDirection( &mdNew );

                    if ( (mtNew == mt) && (mdNew == md) )
                    {
                        //
                        // Yes, we found an appropriate terminal
                        //

                        LOG((RTC_INFO, "CRTCClient::OnDeviceChange - "
                                "selecting a default terminal"));

                        hr = pTerminalManage->SetDefaultStaticTerminal( mt, md, ppNewTerminals[dwNew] );

                        if ( FAILED(hr) )
                        {
                            LOG((RTC_ERROR, "CRTCClient::OnDeviceChange - "
                                                "SetDefaultStaticTerminal failed 0x%lx", hr));
                        }

                        break;
                    }
                }
            }              
        }
    }

    if ( pAudioCapture != NULL )
    {
        pAudioCapture->Release();
        pAudioCapture = NULL;
    }

    if ( pAudioRender != NULL )
    {
        pAudioRender->Release();
        pAudioRender = NULL;
    }

    if ( pVideoCapture != NULL )
    {
        pVideoCapture->Release();
        pVideoCapture = NULL;
    }

    pTerminalManage->Release();
    pTerminalManage = NULL;

    FreeTerminalList( ppNewTerminals, dwNewCount );
    ppNewTerminals = NULL;

    FreeTerminalList( ppOldTerminals, dwOldCount );
    ppOldTerminals = NULL;

    //
    // Save the settings
    //

    hr = StoreDefaultTerminals();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::OnDeviceChange - "
                    "StoreDefaultTerminals failed 0x%lx", hr));
    }

    //
    // Send an event
    //

    CRTCClientEvent::FireEvent(this, RTCCET_DEVICE_CHANGE);

    LOG((RTC_TRACE, "CRTCClient::OnDeviceChange - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::Initialize
//
// This is an IRTCClient method that will initialize the object. It should
// be called before any other methods.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::Initialize()
{
    LOG((RTC_TRACE, "CRTCClient::Initialize - enter"));

    HRESULT hr;

    if ( m_enRtcState == RTC_STATE_SHUTDOWN )
    {
        LOG((RTC_WARN, "CRTCClient::Initialize - already shutdown"));

        return RTC_E_CLIENT_ALREADY_SHUT_DOWN;
    }
    else if ( m_enRtcState != RTC_STATE_NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                    "already initialized" ));

        return RTC_E_CLIENT_ALREADY_INITIALIZED;
    }

    //
    // Register a window class
    //

    WNDCLASS wc;
    ATOM atom;

    ZeroMemory(&wc, sizeof(wc));
    wc.lpfnWndProc = WndProc;
    wc.hInstance = _Module.GetModuleInstance();
    wc.lpszClassName = _T("CRTCClient");

    atom = RegisterClass(&wc);

    if ( !atom )
    {
        DWORD  dwError = GetLastError();

        if(dwError == ERROR_CLASS_ALREADY_EXISTS)
        {
            LOG((RTC_TRACE, "CRTCClient::Initialize - "
                    "RegisterClass failed; class already exists." ));

            // continue

        }
        else
        {
            LOG((RTC_ERROR, "CRTCClient::Initialize - "
                    "RegisterClass failed %d", dwError ));
        
            m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

            return HRESULT_FROM_WIN32(dwError);
        }
    }

    //
    // Create a window
    //

    m_hWnd = CreateWindow( _T("CRTCClient"), _T("CRTCClient"), 0,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
            NULL, NULL, NULL, this);

    if ( m_hWnd == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                "CreateWindow failed %d", GetLastError() ));
        
        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Register to receive PNP device notifications
    //

    DEV_BROADCAST_DEVICEINTERFACE NotificationFilter;

    ZeroMemory( &NotificationFilter, sizeof(NotificationFilter) );
    NotificationFilter.dbcc_size = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
    NotificationFilter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
    NotificationFilter.dbcc_classguid = AM_KSCATEGORY_VIDEO;

    m_hDevNotifyVideo = RegisterDeviceNotification( m_hWnd, 
        &NotificationFilter,
        DEVICE_NOTIFY_WINDOW_HANDLE
        );

    if ( m_hDevNotifyVideo == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                "RegisterDeviceNotification(Video) failed %d", GetLastError() ));
        
        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return HRESULT_FROM_WIN32(GetLastError());
    }

    NotificationFilter.dbcc_classguid = AM_KSCATEGORY_AUDIO;

    m_hDevNotifyAudio = RegisterDeviceNotification( m_hWnd, 
        &NotificationFilter,
        DEVICE_NOTIFY_WINDOW_HANDLE
        );

    if ( m_hDevNotifyAudio == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                "RegisterDeviceNotification(Audio) failed %d", GetLastError() ));
        
        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Initialize the wave player
    //

    m_pWavePlayerSystemDefault = new CWavePlayer;

    if ( m_pWavePlayerSystemDefault == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                        "wave player for ring not created"));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return E_OUTOFMEMORY;                        
    }

    m_pWavePlayerRenderTerminal = new CWavePlayer;

    if ( m_pWavePlayerRenderTerminal == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                        "wave player for dtmf not created"));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return E_OUTOFMEMORY;                        
    }

    hr = CWavePlayer::Initialize();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                        "wave player failed to initialize 0x%lx", hr ));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;                        
    }

    //
    // Create the media manager
    //

    hr = CreateMediaController( &m_pMediaManage );
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                        "CreateMediaController failed 0x%lx", hr ));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;  
    }

    //
    // Initialize the media manager
    //

    hr = m_pMediaManage->Initialize( m_hWnd, WM_STREAMING );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                        "MediaManage Initialize failed 0x%lx", hr ));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;  
    }

    //
    // Create the SIP stack
    //

    hr = SipCreateStack( m_pMediaManage, &m_pSipStack );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                        "SipCreateStack failed 0x%lx", hr ));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;  
    }

    //
    // Get our SIP notification interface
    //

    ISipStackNotify * pNotify = NULL;

    hr = _InternalQueryInterface( IID_ISipStackNotify, (void **) &pNotify );
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                        "failed to get SIP stack notify interface 0x%lx", hr ));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;  
    }

    //
    // Register for SIP stack notifications
    //

    hr = m_pSipStack->SetNotifyInterface( pNotify );

    pNotify->Release();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                        "SetNotifyInterface failed 0x%lx", hr ));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;  
    }

    //
    // Create the video windows
    //

    IRTCTerminalManage * pTerminalManage = NULL;
    IRTCTerminal       * pTerminal = NULL;
    IRTCVideoConfigure * pVideoCfg = NULL;

    //
    // Get the IRTCTerminalManage interface
    //

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTerminalManage,
                           (void **)&pTerminalManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                            "QI(TerminalManage) failed 0x%lx", hr));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;
    }

    //
    // Get the video preview terminal
    //

    hr = pTerminalManage->GetVideoPreviewTerminal(                                         
                            &pTerminal
                            );    

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                            "GetVideoPreviewTerminal failed 0x%lx", hr));        

        pTerminalManage->Release();
        pTerminalManage = NULL;

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;
    }

    if ( pTerminal == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                        "NULL terminal"));

        pTerminalManage->Release();
        pTerminalManage = NULL;

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return E_FAIL;
    }

    //
    // Get the IRTCVideoConfigure interface on the video preview terminal
    //

    hr = pTerminal->QueryInterface(
                   IID_IRTCVideoConfigure,
                   (void **)&pVideoCfg
                  );

    pTerminal->Release();
    pTerminal = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                            "QI(VideoConfigure) failed 0x%lx", hr));

        pTerminalManage->Release();
        pTerminalManage = NULL;
        
        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;
    }

    //
    // Get the IVideoWindow from the video preview terminal
    //

    hr = pVideoCfg->GetIVideoWindow( (LONG_PTR **)&m_pVideoWindow[RTCVD_PREVIEW] );

    pVideoCfg->Release();
    pVideoCfg = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                            "GetIVideoWindow failed 0x%lx", hr));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;
    }

    LOG((RTC_INFO, "CRTCClient::Initialize - "
                     "m_pVideoWindow[RTCVD_PREVIEW] = 0x%lx",
                     m_pVideoWindow[RTCVD_PREVIEW]));

    //
    // Get the video render terminal
    //

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_VIDEO,
                            RTC_MD_RENDER,                                            
                            &pTerminal
                            );        

    pTerminalManage->Release();
    pTerminalManage = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                            "GetDefaultTerminal failed 0x%lx", hr));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;
    }

    if ( pTerminal == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                        "NULL terminal"));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return E_FAIL;
    }

    //
    // Get the IRTCVideoConfigure interface on the video render terminal
    //

    hr = pTerminal->QueryInterface(
                   IID_IRTCVideoConfigure,
                   (void **)&pVideoCfg
                  );

    pTerminal->Release();
    pTerminal = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                            "QI(VideoConfigure) failed 0x%lx", hr));

        pTerminalManage->Release();
        pTerminalManage = NULL;
        
        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;
    }

    //
    // Get the IVideoWindow from the video render terminal
    //

    hr = pVideoCfg->GetIVideoWindow( (LONG_PTR **)&m_pVideoWindow[RTCVD_RECEIVE] );

    pVideoCfg->Release();
    pVideoCfg = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                            "GetIVideoWindow failed 0x%lx", hr));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;
    }

    LOG((RTC_INFO, "CRTCClient::Initialize - "
                     "m_pVideoWindow[RTCVD_RECEIVE] = 0x%lx",
                     m_pVideoWindow[RTCVD_RECEIVE]));

    //
    // Load default terminal settings from registry and
    // select the terminals
    //

    hr = LoadAndSelectDefaultTerminals();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                            "LoadAndSelectDefaultTerminals failed 0x%lx", hr));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;
    }

    //
    // Auto select default terminals
    //

    hr = AutoSelectDefaultTerminals();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                            "AutoSelectDefaultTerminals failed 0x%lx", hr));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;
    }

    //
    // Set preferred media types
    //

    DWORD dwMediaTypes;

    hr = get_RegistryDword( RTCRD_PREFERRED_MEDIA_TYPES, &dwMediaTypes );

    if ( SUCCEEDED(hr) )
    {
        //
        // We got media types from the registry
        //

        hr = m_pMediaManage->SetPreference( dwMediaTypes );
    }
    else
    {
        //
        // Default to all media types
        //

        put_RegistryDword( RTCRD_PREFERRED_MEDIA_TYPES, RTCMT_AUDIO_SEND | RTCMT_AUDIO_RECEIVE |
                                                        RTCMT_VIDEO_SEND | RTCMT_VIDEO_RECEIVE );

        hr = m_pMediaManage->SetPreference( RTCMT_AUDIO_SEND | RTCMT_AUDIO_RECEIVE |
                                            RTCMT_VIDEO_SEND | RTCMT_VIDEO_RECEIVE );

    }

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                            "SetPreference failed 0x%lx", hr));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;
    }
    
    //
    // Get default local user info
    //
       
    m_szUserName = RtcGetUserName();

    if ( m_szUserName == NULL )
    {   
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                        "RtcGetUserName failed"));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return E_OUTOFMEMORY;
    }

    PWSTR szComputerName = NULL;

    szComputerName = RtcGetComputerName();

    if ( szComputerName == NULL )
    {   
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                        "RtcGetComputerName failed"));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return E_OUTOFMEMORY;
    }

    hr = AllocCleanSipString( szComputerName, &m_szUserURI );

    RtcFree( szComputerName );
    szComputerName = NULL;

    if ( FAILED(hr) )
    {   
        LOG((RTC_ERROR, "CRTCClient::Initialize - "
                        "AllocCleanSipString failed 0x%lx", hr));

        m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

        return hr;
    }

    //
    // Have we been tuned yet?
    //

    DWORD dwTuned;

    hr = get_RegistryDword( RTCRD_TUNED, &dwTuned );

    if ( FAILED(hr) || ( dwTuned == 0 ) )
    {
        m_fTuned = FALSE;
    }
    else
    {
        m_fTuned = TRUE;
    }

    m_enRtcState = RTC_STATE_INITIALIZED;

    LOG((RTC_TRACE, "CRTCClient::Initialize - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::AutoSelectDefaultTerminals
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::AutoSelectDefaultTerminals()
{
    LOG((RTC_TRACE, "CRTCClient::AutoSelectDefaultTerminals - enter"));

    HRESULT hr;    

    //
    // Get the IRTCTerminalManage interface
    //

    IRTCTerminalManage * pTerminalManage = NULL;

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTerminalManage,
                           (void **)&pTerminalManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::AutoSelectDefaultTerminals - "
                            "QI(TerminalManage) failed 0x%lx", hr));

        return hr;
    }

    //
    // Get the terminal list
    //

    IRTCTerminal ** ppTerminals = NULL;
    DWORD dwCount = 0;

    hr = GetTerminalList( pTerminalManage, &ppTerminals, &dwCount );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::AutoSelectDefaultTerminals - "
                            "GetTerminalList failed 0x%lx", hr));

        pTerminalManage->Release();
        pTerminalManage = NULL;

        return hr;
    }

    RTC_MEDIA_TYPE mt;
    RTC_MEDIA_DIRECTION md;
    IRTCTerminal * pOldTerminal = NULL;

    for ( DWORD dw=0; dw < dwCount; dw++ )
    {
        //
        // Get terminal media type and direction
        //

        ppTerminals[dw]->GetMediaType( &mt );
        ppTerminals[dw]->GetDirection( &md );

        BOOL bIsDisabled = FALSE;

        if ( mt == RTC_MT_AUDIO )
        {
            if ( md == RTC_MD_CAPTURE )
            {
                bIsDisabled = m_fAudioCaptureDisabled;
            }
            else
            {
                bIsDisabled = m_fAudioRenderDisabled;
            }
        }
        else
        {
            if ( md == RTC_MD_CAPTURE )
            {
                bIsDisabled = m_fVideoCaptureDisabled;
            }
        }

        if ( !bIsDisabled )
        {
            //
            // Is there a terminal of this type already selected?
            //

            pTerminalManage->GetDefaultTerminal( mt, md, &pOldTerminal );

            if ( pOldTerminal != NULL )
            {
                //
                // Yes, do nothing
                //

                pOldTerminal->Release();
                pOldTerminal = NULL;
            }
            else
            {
                //
                // No, select the terminal
                //

                LOG((RTC_INFO, "CRTCClient::AutoSelectDefaultTerminals - "
                                "selecting a default terminal"));

                hr = pTerminalManage->SetDefaultStaticTerminal( mt, md, ppTerminals[dw] );

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCClient::AutoSelectDefaultTerminals - "
                                        "SetDefaultStaticTerminal failed 0x%lx", hr));
                }
            }
        }
    }

    FreeTerminalList( ppTerminals, dwCount );
    ppTerminals = NULL;

    pTerminalManage->Release();
    pTerminalManage = NULL;

    LOG((RTC_TRACE, "CRTCClient::AutoSelectDefaultTerminals - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::LoadAndSelectDefaultTerminals
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::LoadAndSelectDefaultTerminals()
{
    LOG((RTC_TRACE, "CRTCClient::LoadAndSelectDefaultTerminals - enter"));

    HRESULT hr;    

    //
    // Get the IRTCTerminalManage interface
    //

    IRTCTerminalManage * pTerminalManage = NULL;

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTerminalManage,
                           (void **)&pTerminalManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::LoadAndSelectDefaultTerminals - "
                            "QI(TerminalManage) failed 0x%lx", hr));

        return hr;
    }

    //
    // Get the terminal list
    //

    IRTCTerminal ** ppTerminals = NULL;
    DWORD dwCount = 0;

    hr = GetTerminalList( pTerminalManage, &ppTerminals, &dwCount );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::LoadAndSelectDefaultTerminals - "
                            "GetTerminalList failed 0x%lx", hr));

        pTerminalManage->Release();
        pTerminalManage = NULL;

        return hr;
    }

    BSTR szAudioCapture = NULL;
    BSTR szAudioRender = NULL;
    BSTR szVideoCapture = NULL;

    get_RegistryString( RTCRS_TERM_AUDIO_CAPTURE, &szAudioCapture );
    get_RegistryString( RTCRS_TERM_AUDIO_RENDER, &szAudioRender );
    get_RegistryString( RTCRS_TERM_VIDEO_CAPTURE, &szVideoCapture );

    if ( ( szAudioCapture != NULL) &&
         wcscmp( szAudioCapture, L"NULL" ) == 0 )
    {
        m_fAudioCaptureDisabled = TRUE;
    }

    if ( ( szAudioRender != NULL) &&
         wcscmp( szAudioRender, L"NULL" ) == 0 )
    {
        m_fAudioRenderDisabled = TRUE;
    }

    if ( ( szVideoCapture != NULL) &&
         wcscmp( szVideoCapture, L"NULL" ) == 0 )
    {
        m_fVideoCaptureDisabled = TRUE;
    }

    RTC_MEDIA_TYPE mt;
    RTC_MEDIA_DIRECTION md;
    WCHAR * szDescription;

    for ( DWORD dw=0; dw < dwCount; dw++ )
    {
        //
        // Get terminal media type, direction, and description
        //

        ppTerminals[dw]->GetMediaType( &mt );
        ppTerminals[dw]->GetDirection( &md );
        
        hr = ppTerminals[dw]->GetDescription( &szDescription );       

        if ( SUCCEEDED(hr) )
        {
            //
            // Is this terminal one which was stored in the registry?
            //

            BOOL fSelect = FALSE;

            if ( mt == RTC_MT_AUDIO )
            {
                if ( md == RTC_MD_CAPTURE )
                {
                    if ( ( szAudioCapture != NULL) &&
                         ( wcscmp( szAudioCapture, szDescription ) == 0 ) )
                    {
                        fSelect = TRUE;
                    }
                }
                else
                {
                    if ( ( szAudioRender != NULL) &&
                         ( wcscmp( szAudioRender, szDescription ) == 0 ) )
                    {
                        fSelect = TRUE;
                    }
                }
            }
            else
            {
                if ( md == RTC_MD_CAPTURE )
                {
                    if ( ( szVideoCapture != NULL) &&
                         ( wcscmp( szVideoCapture, szDescription ) == 0 ) )
                    {
                        fSelect = TRUE;
                    }
                }
            }

            //
            // Free the description
            //

            ppTerminals[dw]->FreeDescription( szDescription );    

            if ( fSelect == TRUE )
            {
                //
                // Select the terminal
                //

                LOG((RTC_INFO, "CRTCClient::LoadAndSelectDefaultTerminals - "
                                "selecting a default terminal"));

                hr = pTerminalManage->SetDefaultStaticTerminal( mt, md, ppTerminals[dw] );

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCClient::LoadAndSelectDefaultTerminals - "
                                        "SetDefaultStaticTerminal failed 0x%lx", hr));
                }
            }
        }
    }

    SysFreeString( szAudioCapture );
    SysFreeString( szAudioRender );
    SysFreeString( szVideoCapture );

    FreeTerminalList( ppTerminals, dwCount );
    ppTerminals = NULL;

    pTerminalManage->Release();
    pTerminalManage = NULL;       

    LOG((RTC_TRACE, "CRTCClient::LoadAndSelectDefaultTerminals - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::StoreDefaultTerminals
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::StoreDefaultTerminals()
{
    LOG((RTC_TRACE, "CRTCClient::StoreDefaultTerminals - enter"));

    HRESULT hr;

    IRTCTerminalManage * pTerminalManage = NULL;
    IRTCTerminal       * pTerminal = NULL;
    WCHAR              * szDescription = NULL;

    //
    // Get the IRTCTerminalManage interface
    //

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTerminalManage,
                           (void **)&pTerminalManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::StoreDefaultTerminals - "
                            "QI(TerminalManage) failed 0x%lx", hr));

        return hr;
    }

    //
    // Store audio capture
    //

    if ( m_fAudioCaptureDisabled )
    {
        hr = put_RegistryString( RTCRS_TERM_AUDIO_CAPTURE, L"NULL" );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::StoreDefaultTerminals - "
                        "put_RegistryString failed 0x%lx", hr));
        }
    }
    else
    {
        hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            RTC_MD_CAPTURE,                                            
                            &pTerminal
                            );        

        if ( SUCCEEDED(hr) )
        {
            LOG((RTC_INFO, "CRTCClient::StoreDefaultTerminals - "
                                "audio capture"));

            if (pTerminal == NULL)
            {
                hr = DeleteRegistryString( RTCRS_TERM_AUDIO_CAPTURE );

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCClient::StoreDefaultTerminals - "
                                "DeleteRegistryString failed 0x%lx", hr));
                }
            }
            else
            {
                hr = pTerminal->GetDescription( &szDescription );

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCClient::StoreDefaultTerminals - "
                                    "GetDescription failed 0x%lx", hr));
                }
                else
                {
                    hr = put_RegistryString( RTCRS_TERM_AUDIO_CAPTURE, szDescription );

                    if ( FAILED(hr) )
                    {
                        LOG((RTC_ERROR, "CRTCClient::StoreDefaultTerminals - "
                                    "put_RegistryString failed 0x%lx", hr));
                    }

                    pTerminal->FreeDescription( szDescription );
                    szDescription = NULL;
                }

                pTerminal->Release();
                pTerminal = NULL;
            }
        }
    }

    //
    // Store audio render
    //

    if ( m_fAudioRenderDisabled )
    {
        hr = put_RegistryString( RTCRS_TERM_AUDIO_RENDER, L"NULL" );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::StoreDefaultTerminals - "
                        "put_RegistryString failed 0x%lx", hr));
        }
    }
    else
    {
        hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            RTC_MD_RENDER,                                            
                            &pTerminal
                            );        

        if ( SUCCEEDED(hr) )
        {
            LOG((RTC_INFO, "CRTCClient::StoreDefaultTerminals - "
                                "audio render"));

            if (pTerminal == NULL)
            {
                hr = DeleteRegistryString( RTCRS_TERM_AUDIO_RENDER );

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCClient::StoreDefaultTerminals - "
                                "DeleteRegistryString failed 0x%lx", hr));
                }
            }
            else
            {
                hr = pTerminal->GetDescription( &szDescription );

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCClient::StoreDefaultTerminals - "
                                    "GetDescription failed 0x%lx", hr));
                }
                else
                {
                    hr = put_RegistryString( RTCRS_TERM_AUDIO_RENDER, szDescription );

                    if ( FAILED(hr) )
                    {
                        LOG((RTC_ERROR, "CRTCClient::StoreDefaultTerminals - "
                                    "put_RegistryString failed 0x%lx", hr));
                    }

                    pTerminal->FreeDescription( szDescription );
                    szDescription = NULL;
                }

                pTerminal->Release();
                pTerminal = NULL;
            }
        }
    }

    //
    // Store video capture
    //

    if ( m_fVideoCaptureDisabled )
    {
        hr = put_RegistryString( RTCRS_TERM_VIDEO_CAPTURE, L"NULL" );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::StoreDefaultTerminals - "
                        "put_RegistryString failed 0x%lx", hr));
        }
    }
    else
    {
        hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_VIDEO,
                            RTC_MD_CAPTURE,                                            
                            &pTerminal
                            );        

        if ( SUCCEEDED(hr) )
        {
            LOG((RTC_INFO, "CRTCClient::StoreDefaultTerminals - "
                                "video capture"));

            if (pTerminal == NULL)
            {
                hr = DeleteRegistryString( RTCRS_TERM_VIDEO_CAPTURE );

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCClient::StoreDefaultTerminals - "
                                "DeleteRegistryString failed 0x%lx", hr));
                }
            }
            else
            {
                hr = pTerminal->GetDescription( &szDescription );

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCClient::StoreDefaultTerminals - "
                                    "GetDescription failed 0x%lx", hr));
                }
                else
                {
                    hr = put_RegistryString( RTCRS_TERM_VIDEO_CAPTURE, szDescription );

                    if ( FAILED(hr) )
                    {
                        LOG((RTC_ERROR, "CRTCClient::StoreDefaultTerminals - "
                                    "put_RegistryString failed 0x%lx", hr));
                    }

                    pTerminal->FreeDescription( szDescription );
                    szDescription = NULL;
                }

                pTerminal->Release();
                pTerminal = NULL;
            }
        }
    }

    pTerminalManage->Release();
    pTerminalManage = NULL;

    LOG((RTC_TRACE, "CRTCClient::StoreDefaultTerminals - exit S_OK"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::SetEncryptionKey
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCClient::SetEncryptionKey(
    long lMediaType,
    BSTR bstrEncryptionKey
    )
{
    HRESULT     hr;

    LOG((RTC_TRACE, "CRTCClient::SetEncryptionKey - enter"));

    if(lMediaType & RTCMT_AUDIO_SEND)
    {
        hr = m_pMediaManage -> SetEncryptionKey(
            RTC_MT_AUDIO, RTC_MD_CAPTURE, bstrEncryptionKey);

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCClient::SetEncryptionKey - "
                                "MM->SetEncryptionKey failed 0x%lx", hr));

            return hr;
        }
    }
    if(lMediaType & RTCMT_AUDIO_RECEIVE)
    {
        hr = m_pMediaManage -> SetEncryptionKey(
            RTC_MT_AUDIO, RTC_MD_RENDER, bstrEncryptionKey);

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCClient::SetEncryptionKey - "
                                "MM->SetEncryptionKey failed 0x%lx", hr));

            return hr;
        }
    }
    if(lMediaType & RTCMT_VIDEO_SEND)
    {
        hr = m_pMediaManage -> SetEncryptionKey(
            RTC_MT_VIDEO, RTC_MD_CAPTURE, bstrEncryptionKey);

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCClient::SetEncryptionKey - "
                                "MM->SetEncryptionKey failed 0x%lx", hr));

            return hr;
        }
    }
    if(lMediaType & RTCMT_VIDEO_RECEIVE)
    {
        hr = m_pMediaManage -> SetEncryptionKey(
            RTC_MT_VIDEO, RTC_MD_RENDER, bstrEncryptionKey);

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCClient::SetEncryptionKey - "
                                "MM->SetEncryptionKey failed 0x%lx", hr));

            return hr;
        }
    }

    LOG((RTC_TRACE, "CRTCClient::SetEncryptionKey - exit"));
    
    return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::Shutdown
//
// This is an IRTCClient method that will shutdown the object. It should
// be called before releasing the object.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::Shutdown()
{
    LOG((RTC_TRACE, "CRTCClient::Shutdown - enter"));

    DWORD dwResult;
    HRESULT hr;

    if ( m_enRtcState == RTC_STATE_NULL )
    {
        LOG((RTC_WARN, "CRTCClient::Shutdown - not initialized"));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }
    else if ( m_enRtcState == RTC_STATE_INITIALIZED )
    {
        LOG((RTC_WARN, "CRTCClient::Shutdown - not prepared for shutdown"));

        //
        // We are not prepared for shutdown. Do the necessary preparation and
        // continue with shutdown right away.
        //

        InternalPrepareForShutdown(FALSE);
        InternalPrepareForShutdown2(FALSE);
        InternalPrepareForShutdown3(FALSE);
    }
    else if ( m_enRtcState == RTC_STATE_PREPARING_SHUTDOWN )
    {
        LOG((RTC_WARN, "CRTCClient::Shutdown - "
                    "not finished preparing for shutdown (1)" ));

        //
        // We are not finished preparing for shutdown. Go ahead and
        // continue with shutdown right away.
        //

        InternalPrepareForShutdown2(FALSE);
        InternalPrepareForShutdown3(FALSE);
    }
    else if ( m_enRtcState == RTC_STATE_PREPARING_SHUTDOWN2 )
    {
        LOG((RTC_WARN, "CRTCClient::Shutdown - "
                    "not finished preparing for shutdown (2)" ));

        //
        // We are not finished preparing for shutdown. Go ahead and
        // continue with shutdown right away.
        //

        InternalPrepareForShutdown3(FALSE);
    }
    else if ( m_enRtcState == RTC_STATE_PREPARING_SHUTDOWN3 )
    {
        LOG((RTC_WARN, "CRTCClient::Shutdown - "
                    "not finished preparing for shutdown (3)" ));

        //
        // We are not finished preparing for shutdown. Go ahead and
        // continue with shutdown right away.
        //
    }
    else if ( m_enRtcState == RTC_STATE_SHUTDOWN )
    {
        LOG((RTC_WARN, "CRTCClient::Shutdown - already shutdown"));

        return RTC_E_CLIENT_ALREADY_SHUT_DOWN;
    }

    m_enRtcState = RTC_STATE_SHUTDOWN;

    //
    // Free local user info
    //

    if ( m_szUserURI != NULL )
    {
        RtcFree( m_szUserURI );
        m_szUserURI = NULL;
    }

    if ( m_szUserName != NULL )
    {
        RtcFree( m_szUserName );
        m_szUserName = NULL;
    }

    //
    // Release the video windows
    //

    if ( m_pVideoWindow[RTCVD_PREVIEW] != NULL )
    {
        m_pVideoWindow[RTCVD_PREVIEW]->Release();
        m_pVideoWindow[RTCVD_PREVIEW] = NULL;
    }

    if ( m_pVideoWindow[RTCVD_RECEIVE] != NULL )
    {
        m_pVideoWindow[RTCVD_RECEIVE]->Release();
        m_pVideoWindow[RTCVD_RECEIVE] = NULL;
    }

    //
    // Close the audio device
    //

    if ( m_pWavePlayerSystemDefault != NULL )
    {
        m_pWavePlayerSystemDefault->CloseWaveDevice();

        delete m_pWavePlayerSystemDefault;
        m_pWavePlayerSystemDefault = NULL;
    }

    if ( m_pWavePlayerRenderTerminal != NULL )
    {
        m_pWavePlayerRenderTerminal->CloseWaveDevice();

        delete m_pWavePlayerRenderTerminal;
        m_pWavePlayerRenderTerminal = NULL;
    }

    //
    // Release the profile arrays
    //

    m_ProfileArray.Shutdown();
    m_HiddenProfileArray.Shutdown();

    //
    // Disable presence
    //

    m_fPresenceEnabled = FALSE;

    //
    // Release the buddy manager
    //

    if ( m_pSipBuddyManager != NULL )
    { 
        m_pSipBuddyManager->Release();
        m_pSipBuddyManager = NULL;
    }

    //
    // Release the buddy array
    //

    m_BuddyArray.Shutdown();

    //
    // Release the watcher manager 
    //

    if ( m_pSipWatcherManager != NULL )
    { 
        m_pSipWatcherManager->Release();
        m_pSipWatcherManager = NULL;
    }

    //
    // Release the watcher arrays
    //

    m_WatcherArray.Shutdown();   
    m_HiddenWatcherArray.Shutdown();   

#ifdef DUMP_PRESENCE
    DumpWatchers("SHUTDOWN");
#endif

    //
    // Release the SIP stack
    //

    if ( m_pSipStack != NULL )
    {
        //
        // Unregister notifications
        //

        m_pSipStack->SetNotifyInterface( NULL );

        m_pSipStack->Shutdown();
        m_pSipStack->Release();
        m_pSipStack = NULL;
    }

    //
    // Unregister for PNP events
    //

    if ( NULL != m_hDevNotifyVideo )
    {
        UnregisterDeviceNotification(m_hDevNotifyVideo);
        m_hDevNotifyVideo = NULL;
    }

    if ( NULL != m_hDevNotifyAudio )
    {
        UnregisterDeviceNotification(m_hDevNotifyAudio);
        m_hDevNotifyAudio = NULL;
    }
    
    //
    // Destroy window
    //

    if ( NULL != m_hWnd )
    {
        DestroyWindow(m_hWnd);
        m_hWnd = NULL;
    }

    //
    // Unregister window class
    //

    // this fails if there's still a window open. It can happen when multiple instances
    // are running
    UnregisterClass( _T("CRTCClient"), _Module.GetModuleInstance() );

    LOG((RTC_TRACE, "CRTCClient::Shutdown - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::PrepareForShutdown
//
// This is an IRTCClient method that will prepare the object for shutdown.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::PrepareForShutdown()
{
    LOG((RTC_TRACE, "CRTCClient::PrepareForShutdown - enter"));

    HRESULT hr;

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::PrepareForShutdown - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    hr = InternalPrepareForShutdown(TRUE);

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::PrepareForShutdown - "
                           "InternalPrepareForShutdown failed 0x%lx", hr));

        return hr;
    }

    LOG((RTC_TRACE, "CRTCClient::PrepareForShutdown - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::InternalPrepareForShutdown
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::InternalPrepareForShutdown(BOOL fAsync)
{
    LOG((RTC_TRACE, "CRTCClient::InternalPrepareForShutdown - enter"));

    HRESULT hr;

    m_enRtcState = RTC_STATE_PREPARING_SHUTDOWN;

    //
    // Store presence information
    //

    if ( m_fPresenceUseStorage )
    {
        //
        // Get watcher shutdown blob information
        //

        CRTCWatcher * pCWatcher = NULL;

        for (int n = 0; n < m_WatcherArray.GetSize(); n++)
        {
            pCWatcher = reinterpret_cast<CRTCWatcher *>(m_WatcherArray[n]);

            if ( pCWatcher )
            {
                pCWatcher->GetSIPWatcherShutdownBlob();
            }
        }

        //
        // Now, save the presence info
        //

        InternalExport( m_varPresenceStorage );

        m_fPresenceUseStorage = FALSE;
    }

    //
    // Unsubscribe the SIP buddies
    //

    if ( m_pSipBuddyManager != NULL )
    { 
        CRTCBuddy * pCBuddy = NULL;

        for (int n = 0; n < m_BuddyArray.GetSize(); n++)
        {
            pCBuddy = reinterpret_cast<CRTCBuddy *>(m_BuddyArray[n]);

            if ( pCBuddy )
            {
                if ( pCBuddy->m_pSIPBuddy == NULL )
                {
                    m_BuddyArray[n]->AddRef();

                    PostMessage( m_hWnd, WM_BUDDY_UNSUB, (WPARAM)m_BuddyArray[n], (LPARAM)TRUE );
                }
                else
                {
                    pCBuddy->RemoveSIPBuddy(TRUE);                   
                }
            }
        }
    }

    if ( fAsync )
    {
        PostMessage( m_hWnd, WM_BUDDY_UNSUB, 0, (LPARAM)TRUE );

        //
        // Start the timeout timer
        //

        DWORD dwID = (DWORD)SetTimer(m_hWnd, TID_SHUTDOWN_TIMEOUT, SHUTDOWN_TIMEOUT_DELAY, NULL);
        if (dwID==0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            LOG((RTC_ERROR, "CRTCClient::InternalPrepareForShutdown - "
                           "SetTimer failed 0x%lx", hr));

            return hr;
        }
    }

    LOG((RTC_TRACE, "CRTCClient::InternalPrepareForShutdown - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::InternalPrepareForShutdown2
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::InternalPrepareForShutdown2(BOOL fAsync)
{
    LOG((RTC_TRACE, "CRTCClient::InternalPrepareForShutdown2 - enter"));

    HRESULT hr;

    m_enRtcState = RTC_STATE_PREPARING_SHUTDOWN2;

    //
    // Disable all provider profiles
    //

    for ( int n = 0; n < m_ProfileArray.GetSize(); n++ )
    {
        m_HiddenProfileArray.Add( m_ProfileArray[n] );
        
        CRTCProfile * pCProfile = NULL;

        pCProfile = static_cast<CRTCProfile *>(m_ProfileArray[n]);

        pCProfile->Disable();
    }

    m_ProfileArray.Shutdown();

    if ( fAsync )
    {
        PostMessage( m_hWnd, WM_PROFILE_UNREG, 0, 0 );

        //
        // Start the timeout timer
        //

        DWORD dwID = (DWORD)SetTimer(m_hWnd, TID_SHUTDOWN_TIMEOUT, SHUTDOWN_TIMEOUT_DELAY, NULL);
        if (dwID==0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            LOG((RTC_ERROR, "CRTCClient::InternalPrepareForShutdown2 - "
                           "SetTimer failed 0x%lx", hr));

            return hr;
        }    
    }

    LOG((RTC_TRACE, "CRTCClient::InternalPrepareForShutdown2 - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::InternalPrepareForShutdown3
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::InternalPrepareForShutdown3(BOOL fAsync)
{
    LOG((RTC_TRACE, "CRTCClient::InternalPrepareForShutdown3 - enter"));

    HRESULT hr;

    m_enRtcState = RTC_STATE_PREPARING_SHUTDOWN3;

    //
    // Unsubscribe the SIP watchers
    //

    if ( m_pSipWatcherManager != NULL )
    { 
        CRTCWatcher * pCWatcher = NULL;

        for (int n = 0; n < m_WatcherArray.GetSize(); n++)
        {
            pCWatcher = reinterpret_cast<CRTCWatcher *>(m_WatcherArray[n]);

            if ( pCWatcher )
            {
                pCWatcher->RemoveSIPWatchers(TRUE);                   
            }
        }
        
        for (int n = 0; n < m_HiddenWatcherArray.GetSize(); n++)
        {
            pCWatcher = reinterpret_cast<CRTCWatcher *>(m_HiddenWatcherArray[n]);

            if ( pCWatcher )
            {
                pCWatcher->RemoveSIPWatchers(TRUE);                   
            }
        }
    }

    //
    // Prepare SIP stack for shutdown
    //

    hr = m_pSipStack->PrepareForShutdown();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::InternalPrepareForShutdown3 - "
                           "PrepareForShutdown failed 0x%lx", hr));
    }
    else if ( hr == S_OK )
    {
        LOG((RTC_INFO, "CRTCClient::InternalPrepareForShutdown3 - "
                           "sip stack ready for shutdown"));

        InternalReadyForShutdown();
    }
    else if ( fAsync )
    {       
        //
        // Start the timeout timer
        //

        DWORD dwID = (DWORD)SetTimer(m_hWnd, TID_SHUTDOWN_TIMEOUT, SHUTDOWN_TIMEOUT_DELAY, NULL);
        if (dwID==0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            LOG((RTC_ERROR, "CRTCClient::InternalPrepareForShutdown3 - "
                           "SetTimer failed 0x%lx", hr));

            return hr;
        }    
    }

    LOG((RTC_TRACE, "CRTCClient::InternalPrepareForShutdown3 - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::InternalReadyForShutdown()
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::InternalReadyForShutdown()
{
    LOG((RTC_TRACE, "CRTCClient::InternalReadyForShutdown - enter"));

    m_enRtcState = RTC_STATE_READY_FOR_SHUTDOWN;

    PostMessage(m_hWnd, WM_ASYNC_CLEANUP_DONE, 0, 0);    

    LOG((RTC_TRACE, "CRTCClient::InternalReadyForShutdown - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::put_EventFilter
//
// This is an IRTCClient method that will set the event filter.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::put_EventFilter(
        long lFilter
        )
{
    LOG((RTC_TRACE, "CRTCClient::put_EventFilter - enter"));

    if ( lFilter & ~RTCEF_ALL )
    {
        LOG((RTC_ERROR, "CRTCClient::put_EventFilter - "
                            "invalid filter mask"));

        return E_INVALIDARG;
    }

    m_lEventFilter = lFilter;

    LOG((RTC_TRACE, "CRTCClient::put_EventFilter - exit S_OK"));

    return S_OK;
}
 
/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_EventFilter
//
// This is an IRTCClient method that will return the event filter.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_EventFilter(
        long * plFilter
        )
{
    LOG((RTC_TRACE, "CRTCClient::get_EventFilter - enter"));

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( plFilter, sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_EventFilter - "
                            "bad long pointer"));

        return E_POINTER;
    }
    
    *plFilter = m_lEventFilter;

    LOG((RTC_TRACE, "CRTCClient::get_EventFilter - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::SetPreferredMediaTypes
//
// This is an IRTCClient method that will set the preferred media types.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::SetPreferredMediaTypes(
        long lMediaTypes,
        VARIANT_BOOL fPersistent
        )
{
    LOG((RTC_TRACE, "CRTCClient::SetPreferredMediaTypes - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::SetPreferredMediaTypes - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( lMediaTypes & ~(RTCMT_AUDIO_SEND |
                         RTCMT_AUDIO_RECEIVE |
                         RTCMT_VIDEO_SEND |
                         RTCMT_VIDEO_RECEIVE |
                         RTCMT_T120_SENDRECV) )
    {
        LOG((RTC_ERROR, "CRTCClient::SetPreferredMediaTypes - "
                            "invalid meida types"));

        return E_INVALIDARG;
    }

    HRESULT hr;

    hr = m_pMediaManage->SetPreference( lMediaTypes );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::SetPreferredMediaTypes - "
                            "SetPreference failed 0x%lx", hr));

        return hr;
    }
    
    if ( fPersistent == VARIANT_TRUE )
    {
        lMediaTypes &= (~RTCMT_T120_SENDRECV); // Never persist settings about T120 stream

        hr = put_RegistryDword( RTCRD_PREFERRED_MEDIA_TYPES, (DWORD)lMediaTypes );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::SetPreferredMediaTypes - "
                                "put_RegistryDword failed 0x%lx", hr));

            return hr;
        }
    }

    LOG((RTC_TRACE, "CRTCClient::SetPreferredMediaTypes - exit S_OK"));

    return S_OK;
}
 
/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_PreferredMediaTypes
//
// This is an IRTCClient method that will return the preferred media types.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_PreferredMediaTypes(
        long * plMediaTypes
        )
{
    LOG((RTC_TRACE, "CRTCClient::get_PreferredMediaTypes - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredMediaTypes - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( plMediaTypes, sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredMediaTypes - "
                            "bad long pointer"));

        return E_POINTER;
    }

    HRESULT hr;

    DWORD dwMediaTypes;

    hr = m_pMediaManage->GetPreference( &dwMediaTypes );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredMediaTypes - "
                            "GetPreference failed 0x%lx", hr));

        return hr;
    } 

    *plMediaTypes = dwMediaTypes;

    LOG((RTC_TRACE, "CRTCClient::get_PreferredMediaTypes - exit S_OK"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_MediaCapabilities
//
// This is an IRTCClient method that will return the media types for which
// terminals exist.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_MediaCapabilities(
        long * plMediaTypes
        )
{
    LOG((RTC_TRACE, "CRTCClient::get_MediaCapabilities - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_MediaCapabilities - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( plMediaTypes, sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_MediaCapabilities - "
                            "bad long pointer"));

        return E_POINTER;
    }

    //
    // Do we have media capabilities cached?
    //

    if ( m_fMediaCapsCached == FALSE )
    {
        HRESULT hr;

        IRTCTerminalManage * pTerminalManage = NULL;
        IRTCTerminal       * pTerminal = NULL;

        //
        // Get the IRTCTerminalManage interface
        //

        hr = m_pMediaManage->QueryInterface(
                               IID_IRTCTerminalManage,
                               (void **)&pTerminalManage
                              );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::get_MediaCapabilities - "
                                "QI(TerminalManage) failed 0x%lx", hr));

            return hr;
        }

        //
        // We always have video receive
        //

        m_lMediaCaps = RTCMT_VIDEO_RECEIVE | RTCMT_T120_SENDRECV;

        LOG((RTC_INFO, "CRTCClient::get_MediaCapabilities - "
                                "RTCMT_VIDEO_RECEIVE | RTCMT_T120_SENDRECV"));

        //
        // Check video send
        //

        hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_VIDEO,
                            RTC_MD_CAPTURE,                                            
                            &pTerminal
                            );        

        if ( SUCCEEDED(hr) && (pTerminal != NULL) )
        {
            m_lMediaCaps |= RTCMT_VIDEO_SEND;

            LOG((RTC_INFO, "CRTCClient::get_MediaCapabilities - "
                                "RTCMT_VIDEO_SEND"));

            pTerminal->Release();
            pTerminal = NULL;
        }

        //
        // Check audio receive
        //

        hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            RTC_MD_RENDER,                                            
                            &pTerminal
                            );        

        if ( SUCCEEDED(hr) && (pTerminal != NULL) )
        {
            m_lMediaCaps |= RTCMT_AUDIO_RECEIVE;

            LOG((RTC_INFO, "CRTCClient::get_MediaCapabilities - "
                                "RTCMT_AUDIO_RECEIVE"));

            pTerminal->Release();
            pTerminal = NULL;
        }

        //
        // Check audio send
        //

        hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            RTC_MD_CAPTURE,                                            
                            &pTerminal
                            );        

        if ( SUCCEEDED(hr) && (pTerminal != NULL) )
        {
            m_lMediaCaps |= RTCMT_AUDIO_SEND;

            LOG((RTC_INFO, "CRTCClient::get_MediaCapabilities - "
                                "RTCMT_AUDIO_SEND"));

            pTerminal->Release();
            pTerminal = NULL;
        }

        pTerminalManage->Release();
        pTerminalManage = NULL;

        m_fMediaCapsCached = TRUE;        
    }

    *plMediaTypes = m_lMediaCaps;

    LOG((RTC_TRACE, "CRTCClient::get_MediaCapabilities - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::InternalCreateSession
//
// This is a private helper method to do the work of creating a new
// session object. It is meant to be called by the public API method
// CreateSession and when SIP notifies us of an incoming session.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCClient::InternalCreateSession(
        IRTCSession ** ppSession
        )
{
    HRESULT hr;
    
    LOG((RTC_TRACE, "CRTCClient::InternalCreateSession - enter"));
    
    //
    // Create the session
    //

    CComObject<CRTCSession> * pCSession;
    hr = CComObject<CRTCSession>::CreateInstance( &pCSession );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCClient::InternalCreateSession - "
                            "CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
            
        return hr;
    }

    //
    // Get the IRTCSession interface
    //

    IRTCSession * pSession = NULL;

    hr = pCSession->QueryInterface(
                           IID_IRTCSession,
                           (void **)&pSession
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::InternalCreateSession - "
                            "QI failed 0x%lx", hr));
        
        delete pCSession;
        
        return hr;
    }   

    *ppSession = pSession;

    LOG((RTC_TRACE, "CRTCClient::InternalCreateSession - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::CreateSession
//
// This is an IRTCClient method that creates a new outgoing session using
// the service provider specified by IRTCProfile. If the profile is NULL, the 
// default service provider is used.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCClient::CreateSession(
        RTC_SESSION_TYPE enType,
        BSTR bstrLocalPhoneURI,
        IRTCProfile * pProfile,
        long lFlags,
        IRTCSession ** ppSession
        )
{
    HRESULT hr = S_OK;
    
    LOG((RTC_TRACE, "CRTCClient::CreateSession - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateSession - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( ppSession, sizeof(IRTCSession *) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateSession - "
                            "bad IRTCSession pointer"));

        return E_POINTER;
    }

    //
    // NULL is okay for profile, it means no provider
    //
    
    if ( (pProfile != NULL) && 
         IsBadReadPtr( pProfile, sizeof(IRTCProfile) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateSession - "
                            "bad IRTCProfile pointer"));

        return E_POINTER;
    }

    //
    // NULL is okay for local phone uri
    //

    if ( (bstrLocalPhoneURI != NULL) &&
         IsBadStringPtrW( bstrLocalPhoneURI, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateSession - "
                            "bad phone uri string pointer"));

        return E_POINTER;
    }     
    
    LOG((RTC_INFO, "CRTCClient::CreateSession - enType [%d]",
        enType));
    LOG((RTC_INFO, "CRTCClient::CreateSession - bstrLocalPhoneURI [%ws]",
        bstrLocalPhoneURI));
    LOG((RTC_INFO, "CRTCClient::CreateSession - pProfile [0x%p]",
        pProfile));
    LOG((RTC_INFO, "CRTCClient::CreateSession - lFlags [0x%lx]",
        lFlags));       

    //
    // Verify session type
    //

    switch (enType)
    {
        case RTCST_PC_TO_PC:
        {
            LOG((RTC_INFO, "CRTCClient::CreateSession - "
                    "RTCST_PC_TO_PC"));
            
            if ( (bstrLocalPhoneURI != NULL) &&
                 (*bstrLocalPhoneURI != L'\0') )
            {
                LOG((RTC_ERROR, "CRTCClient::CreateSession - "
                    "RTCST_PC_TO_PC sessions shouldn't have a local phone URI"));
            
                return E_INVALIDARG;
            }

            if ( m_fTuning )
            {
                LOG((RTC_ERROR, "CRTCClient::CreateSession - "
                        "tuning is active" ));

                return E_FAIL;
            }

            break;
        }

        case RTCST_PC_TO_PHONE:
        {
            LOG((RTC_INFO, "CRTCClient::CreateSession - "
                    "RTCST_PC_TO_PHONE"));

            if ( (bstrLocalPhoneURI != NULL) &&
                 (*bstrLocalPhoneURI != L'\0') )
            {
                LOG((RTC_ERROR, "CRTCClient::CreateSession - "
                    "RTCST_PC_TO_PHONE sessions shouldn't have a local phone URI"));
            
                return E_INVALIDARG;
            }

            if ( m_fTuning )
            {
                LOG((RTC_ERROR, "CRTCClient::CreateSession - "
                        "tuning is active" ));

                return E_FAIL;
            }

            break;
        }

        case RTCST_PHONE_TO_PHONE:
        {
            LOG((RTC_INFO, "CRTCClient::CreateSession - "
                    "RTCST_PHONE_TO_PHONE"));

            if ( (bstrLocalPhoneURI == NULL) ||
                 (*bstrLocalPhoneURI == L'\0') )
            {
                LOG((RTC_ERROR, "CRTCClient::CreateSession - "
                    "PHONE_TO_PHONE sessions need a local phone URI"));
            
                return RTC_E_LOCAL_PHONE_NEEDED;
            }

            break;
        }

        case RTCST_IM:
        {
            LOG((RTC_INFO, "CRTCClient::CreateSession - "
                    "RTCST_IM"));
            
            if ( (bstrLocalPhoneURI != NULL) &&
                 (*bstrLocalPhoneURI != L'\0') )
            {
                LOG((RTC_ERROR, "CRTCClient::CreateSession - "
                    "RTCST_IM sessions shouldn't have a local phone URI"));
            
                return E_INVALIDARG;
            }

            break;
        }

        default:
        {
            LOG((RTC_ERROR, "CRTCClient::CreateSession - "
                            "invalid session type"));
        
            return E_INVALIDARG;
        }
    }   

    //
    // Create the session
    //

    IRTCSession * pSession = NULL;
    
    hr = InternalCreateSession( 
                               &pSession
                              );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateSession - "
                            "InternalCreateSession failed 0x%lx", hr));
   
        return hr;
    }   
    
    //
    // Initialize the session
    //

    CRTCSession * pCSession = NULL;

    pCSession = static_cast<CRTCSession *>(pSession);
    
    hr = pCSession->InitializeOutgoing(
                               this, 
                               pProfile,
                               m_pSipStack,
                               enType,
                               m_szUserName,
                               m_szUserURI,
                               bstrLocalPhoneURI,
                               lFlags
                              );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::InternalCreateSession - "
                            "Initialize failed 0x%lx", hr));
        
        pSession->Release();        
        
        return hr;
    }     

    *ppSession = pSession;

    LOG((RTC_TRACE, "CRTCClient::CreateSession - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_NetworkAddresse
//
// This is an IRTCClient method that will return the network
// addresses and ports being used by the client.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCClient::get_NetworkAddresses(
        VARIANT_BOOL fTCP,
        VARIANT_BOOL fExternal,
        VARIANT * pvAddress
        )
{
    HRESULT hr;
    
    LOG((RTC_TRACE, "CRTCClient::get_NetworkAddresses - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_NetworkAddresses - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( pvAddress, sizeof(VARIANT) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_NetworkAddresses - "
                            "bad VARIANT pointer"));

        return E_POINTER;
    }

    //
    // Get network addresses from SIP
    //

    LPOLESTR * NetworkAddressArray;
    ULONG      ulNetworkAddressCount;

    hr = m_pSipStack->GetNetworkAddresses(
                            fTCP ? TRUE : FALSE,
                            fExternal ? TRUE : FALSE,
                            &NetworkAddressArray,
                            &ulNetworkAddressCount
                            );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_NetworkAddresses - "
                            "GetNetworkAddresses failed 0x%lx"));

        return hr;
    }

    //
    // Create the SAFEARRAY
    //

    SAFEARRAY * pSafeArray;
    SAFEARRAYBOUND SafeArrayBound[1];

    SafeArrayBound[0].lLbound = 0;
    SafeArrayBound[0].cElements = ulNetworkAddressCount;

    pSafeArray = SafeArrayCreate(VT_BSTR, 1, SafeArrayBound);

    if ( pSafeArray == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::get_NetworkAddresses - "
                            "SafeArrayCreate out of memory"));

        m_pSipStack->FreeNetworkAddresses(
                            NetworkAddressArray,
                            ulNetworkAddressCount
                            );

        return E_OUTOFMEMORY;
    }

    //
    // Pack the SAFEARRAY
    //

    if ( ulNetworkAddressCount > 0 )
    {
        BSTR HUGEP *pbstr;

        hr = SafeArrayAccessData( pSafeArray, (void HUGEP**) &pbstr );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::SafeArrayAccessData - "
                            "SafeArrayCreate failed"));

            SafeArrayDestroy( pSafeArray );

            m_pSipStack->FreeNetworkAddresses(
                                NetworkAddressArray,
                                ulNetworkAddressCount
                                );

            return hr;
        }

        for (ULONG i=0; i < ulNetworkAddressCount; i++)
        {
            pbstr[i] = SysAllocString( NetworkAddressArray[i] );

            if ( pbstr[i] == NULL )
            {
                LOG((RTC_ERROR, "CRTCClient::SafeArrayAccessData - "
                            "SysAllocString out of memory"));

                SafeArrayUnaccessData( pSafeArray );

                SafeArrayDestroy( pSafeArray );

                m_pSipStack->FreeNetworkAddresses(
                                    NetworkAddressArray,
                                    ulNetworkAddressCount
                                    );

                return E_OUTOFMEMORY;
            }
        }

        SafeArrayUnaccessData( pSafeArray );
    }

    m_pSipStack->FreeNetworkAddresses(
                            NetworkAddressArray,
                            ulNetworkAddressCount
                            );

    //
    // Initialize the VARIANT
    //

    VariantInit(pvAddress);

    pvAddress->vt = VT_ARRAY | VT_BSTR;
    pvAddress->parray = pSafeArray;

    LOG((RTC_TRACE, "CRTCClient::get_NetworkAddresses - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::InternalCreateProfile
//
// This is a private helper method to do the work of creating a new
// profile object. 
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCClient::InternalCreateProfile(
        IRTCProfile ** ppProfile
        )
{
    HRESULT hr;
    
    LOG((RTC_TRACE, "CRTCClient::InternalCreateProfile - enter"));
    
    //
    // Create the session
    //

    CComObject<CRTCProfile> * pCProfile;
    hr = CComObject<CRTCProfile>::CreateInstance( &pCProfile );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCClient::InternalCreateProfile - "
                            "CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
            
        return hr;
    }

    //
    // Get the IRTCProfile interface
    //

    IRTCProfile * pProfile = NULL;

    hr = pCProfile->QueryInterface(
                           IID_IRTCProfile,
                           (void **)&pProfile
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::InternalCreateProfile - "
                            "QI failed 0x%lx", hr));
        
        delete pCProfile;
        
        return hr;
    }
   
    *ppProfile = pProfile;

    LOG((RTC_TRACE, "CRTCClient::InternalCreateProfile - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::CreateProfile
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCClient::CreateProfile(
        BSTR bstrProfileXML,
        IRTCProfile ** ppProfile
        )
{
    HRESULT hr;
    
    LOG((RTC_TRACE, "CRTCClient::CreateProfile - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateProfile - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( ppProfile, sizeof(IRTCProfile *) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateProfile - "
                            "bad IRTCProfile pointer"));

        return E_POINTER;
    }

    if ( IsBadStringPtrW( bstrProfileXML, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateProfile - "
                            "bad XML string pointer"));

        return E_POINTER;
    }
    
    //
    // Create the profile
    //

    IRTCProfile * pProfile = NULL;
    
    hr = InternalCreateProfile( 
                               &pProfile
                              );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateProfile - "
                            "InternalCreateProfile failed 0x%lx", hr));
        
        return hr;
    }

    //
    // Initialize the profile
    //

    CRTCProfile * pCProfile = NULL;

    pCProfile = static_cast<CRTCProfile *>(pProfile);
    
    hr = pCProfile->InitializeFromString( bstrProfileXML,
                                          this,
                                          m_pSipStack);

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateProfile - "
                            "InitializeFromString failed 0x%lx", hr));

        pProfile->Release();
        
        return hr;
    } 

    *ppProfile = pProfile;

    LOG((RTC_TRACE, "CRTCClient::CreateProfile - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::EnableProfile
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCClient::EnableProfile(
            IRTCProfile * pProfile,
            long lRegisterFlags
            )
{
    LOG((RTC_TRACE, "CRTCClient::EnableProfile - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::EnableProfile - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadReadPtr( pProfile, sizeof( IRTCProfile * ) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::EnableProfile - "
                            "bad IRTCProfile pointer"));

        return E_POINTER;
    }

    if ( lRegisterFlags & ~RTCRF_REGISTER_ALL )
    {
        LOG((RTC_ERROR, "CRTCClient::EnableProfile - "
                            "invalid register flags"));

        return E_INVALIDARG;
    }

    HRESULT hr;

    //
    // Get the profile realm
    //

    BSTR bstrRealm = NULL;
    CRTCProfile * pCProfile = NULL;
    IRTCProfile * pProfileWithDuplicateRealm = NULL;

    pCProfile = static_cast<CRTCProfile *>(pProfile);

    hr = pCProfile->GetRealm( &bstrRealm );

    if ( SUCCEEDED(hr) )
    {
        //
        // Search the profile array and make sure we are not
        // trying to add a duplicate realm
        //

        for (int n = 0; n < m_ProfileArray.GetSize(); n++)
        {
            BSTR bstrSearchRealm = NULL;

            pCProfile = static_cast<CRTCProfile *>(m_ProfileArray[n]);

            hr = pCProfile->GetRealm( &bstrSearchRealm );

            if ( SUCCEEDED(hr) )
            {
                if ( _wcsicmp( bstrRealm, bstrSearchRealm ) == 0 )
                {
                    pProfileWithDuplicateRealm = m_ProfileArray[n];

                    SysFreeString( bstrSearchRealm );

                    break;
                }

                SysFreeString( bstrSearchRealm );
            }
        }

        SysFreeString( bstrRealm );
    }

    //
    // Get profile key
    //

    BSTR bstrKey = NULL;    

    hr = pProfile->get_Key( &bstrKey );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::EnableProfile - "
                            "get_Key failed 0x%lx", hr));

        return hr;
    }

    //
    // Search the profile array and make sure we are not
    // trying to add a duplicate key
    //

    BOOL fNeedToAdd = TRUE;

    for (int n = 0; n < m_ProfileArray.GetSize(); n++)
    {        
        if ( pProfile == m_ProfileArray[n] )
        {           
            //
            // This is the same profile as we already have
            // in the array.
            //
            // Enable the profile again.
            //

            fNeedToAdd = FALSE;
            
            // 
            // Since we don't add it, we don't have a duplicate realm
            //
            
            pProfileWithDuplicateRealm = NULL;

            break;
        }

        BSTR bstrSearchKey = NULL;

        hr = m_ProfileArray[n]->get_Key( &bstrSearchKey );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::EnableProfile - "
                                "get_Key failed 0x%lx", hr));

            SysFreeString( bstrKey );

            return hr;
        }

        if ( wcscmp( bstrKey, bstrSearchKey ) == 0 )
        {           
            //
            // This is a new version of a profile we already have
            // in the array.
            //
            // We must disable the old profile and enable the new
            // one.
            //

            if ( pProfileWithDuplicateRealm != NULL )
            {
                if ( pProfileWithDuplicateRealm == m_ProfileArray[n] )
                {
                    //
                    // The duplicate realm will be removed, so it is not
                    // a problem.
                    //

                    pProfileWithDuplicateRealm = NULL;
                }
                else
                {
                    //
                    // The duplicate realm is in another profile in the
                    // array besides the one being removed.
                    //

                    LOG((RTC_ERROR, "CRTCClient::EnableProfile - "
                                "duplicate realm"));

                    SysFreeString( bstrKey );
                    SysFreeString( bstrSearchKey );

                    return RTC_E_DUPLICATE_REALM;
                }
            }

            DisableProfile( m_ProfileArray[n] );

            SysFreeString( bstrSearchKey );

            break;
        }

        SysFreeString( bstrSearchKey );
    }

    SysFreeString( bstrKey );

    if ( pProfileWithDuplicateRealm != NULL )
    {
        //
        // There is another profile in the array with a duplicate
        // realm.
        //

        LOG((RTC_ERROR, "CRTCClient::EnableProfile - "
                    "duplicate realm"));

        return RTC_E_DUPLICATE_REALM;
    }

    //
    // Enable the profile
    //

    if ( fNeedToAdd )
    {
        BOOL fResult;

        fResult = m_ProfileArray.Add( pProfile );

        if ( !fResult )
        {
            LOG((RTC_ERROR, "CRTCClient::EnableProfile - "
                            "out of memory"));
       
            return E_OUTOFMEMORY;
        }
    }

    pCProfile = static_cast<CRTCProfile *>(pProfile);

    hr = pCProfile->Enable( lRegisterFlags );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::EnableProfile - "
                            "Enable failed 0x%lx", hr));
       
        return hr;
    }

    LOG((RTC_TRACE, "CRTCClient::EnableProfile - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::DisableProfile
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCClient::DisableProfile(
            IRTCProfile * pProfile           
            )
{
    LOG((RTC_TRACE, "CRTCClient::DisableProfile - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::DisableProfile - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadReadPtr( pProfile, sizeof( IRTCProfile * ) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::DisableProfile - "
                            "bad IRTCProfile pointer"));

        return E_POINTER;
    }

    //
    // Make sure the profile is in the list
    //

    int n = m_ProfileArray.Find( pProfile );

    if ( n == -1 )
    {
        LOG((RTC_ERROR, "CRTCClient::DisableProfile - "
                            "profile not enabled"));

        return E_FAIL;
    }

    //
    // Disable the profile
    //

    BOOL fResult;
    HRESULT hr;

    fResult = m_HiddenProfileArray.Add( pProfile );

    if ( !fResult )
    {
        LOG((RTC_ERROR, "CRTCClient::DisableProfile - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    CRTCProfile * pCProfile = NULL;

    pCProfile = static_cast<CRTCProfile *>(pProfile);

    m_ProfileArray.RemoveAt(n);                        

    hr = pCProfile->Disable();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::DisableProfile - "
                            "Disable failed 0x%lx", hr));

        return hr;
    }

    LOG((RTC_TRACE, "CRTCClient::DisableProfile - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::EnumerateProfiles
//
// This is an IRTCClient method that enumerates profiles on the client.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::EnumerateProfiles(
        IRTCEnumProfiles ** ppEnum
        )
{
    HRESULT                 hr;

    LOG((RTC_TRACE, "CRTCClient::EnumerateProfiles enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::EnumerateProfiles - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( ppEnum, sizeof( IRTCEnumProfiles * ) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::EnumerateProfiles - "
                            "bad IRTCEnumProfiles pointer"));

        return E_POINTER;
    }
    
    //
    // Create the enumeration
    //
 
    CComObject< CRTCEnum< IRTCEnumProfiles,
                          IRTCProfile,
                          &IID_IRTCEnumProfiles > > * p;
                          
    hr = CComObject< CRTCEnum< IRTCEnumProfiles,
                               IRTCProfile,
                               &IID_IRTCEnumProfiles > >::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCClient::InternalEnumerateProfiles - "
                            "CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
        
        return hr;
    }

    //
    // Initialize the enumeration (adds a reference)
    //
    
    hr = p->Initialize( m_ProfileArray );

    if ( S_OK != hr )
    {
        LOG((RTC_ERROR, "CRTCClient::InternalEnumerateProfiles - "
                            "could not initialize enumeration" ));
    
        delete p;
        return hr;
    }

    *ppEnum = p;

    LOG((RTC_TRACE, "CRTCClient::EnumerateProfiles - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_Profiles
//
// This is an IRTCClient method that enumerates profiles on the client.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCClient::get_Profiles(
        IRTCCollection ** ppCollection
        )
{
    HRESULT hr;
    
    LOG((RTC_TRACE, "CRTCClient::get_Profiles - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Profiles - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( ppCollection, sizeof(IRTCCollection *) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Profiles - "
                            "bad IRTCCollection pointer"));

        return E_POINTER;
    }

    //
    // Create the collection
    //
 
    CComObject< CRTCCollection< IRTCProfile > > * p;
                          
    hr = CComObject< CRTCCollection< IRTCProfile > >::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCClient::get_Profiles - "
                            "CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
        
        return hr;
    }

    //
    // Initialize the collection (adds a reference)
    //
    
    hr = p->Initialize( m_ProfileArray );

    if ( S_OK != hr )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Profiles - "
                            "could not initialize enumeration" ));
    
        delete p;
        return hr;
    }

    // Set the collection to be returned to the caller. 

    *ppCollection = p;

    LOG((RTC_TRACE, "CRTCClient::get_Profiles - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::GetProfile
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCClient::GetProfile(
            BSTR bstrUserAccount,
            BSTR bstrUserPassword,
            BSTR bstrUserURI,
            BSTR bstrServer,
            long lTransport,
            long lCookie
            )
{
    LOG((RTC_TRACE, "CRTCClient::GetProfile - enter"));

    LOG((RTC_TRACE, "CRTCClient::GetProfile - exit E_NOTIMPL"));

    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_SessionCapabilities
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCClient::get_SessionCapabilities(
            long * plSupportedSessions
            )
{
    LOG((RTC_TRACE, "CRTCClient::get_SessionCapabilities - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_SessionCapabilities - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( plSupportedSessions, sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_SessionCapabilities - "
                            "bad long pointer"));

        return E_POINTER;
    }

    HRESULT hr;

    *plSupportedSessions = RTCSI_PC_TO_PC | RTCSI_IM;

    for ( int n=0; n < m_ProfileArray.GetSize() ; n++ )
    {
        //
        // Get the supported session types of the provider
        //

        long lSupportedSessions;

        hr = m_ProfileArray[n]->get_SessionCapabilities( &lSupportedSessions );

        if ( FAILED( hr ) )
        {
            LOG((RTC_ERROR, "CRTCClient::get_SessionCapabilities - "
                            "get_SessionCapabilities failed 0x%lx - skipping", hr));

            continue;
        }

        *plSupportedSessions |= lSupportedSessions;
    }

    LOG((RTC_TRACE, "CRTCClient::get_SessionCapabilities - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::GetBestProfile
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCClient::GetBestProfile(
        RTC_SESSION_TYPE * penType,
        PCWSTR szDestUserURI,
        BOOL fIsRedirect,
        IRTCProfile ** ppProfile
        )
{
    HRESULT hr;
    
    LOG((RTC_TRACE, "CRTCClient::GetBestProfile - enter"));

    //
    // Check the arguments
    //

    if ( IsBadReadPtr( penType, sizeof(RTC_SESSION_TYPE) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::GetBestProfile - "
                            "bad RTC_SESSION_TYPE pointer"));

        return E_POINTER;
    }
    
    if ( (szDestUserURI != NULL) &&
         IsBadStringPtrW( szDestUserURI, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::GetBestProfile - "
                            "bad string pointer"));

        return E_POINTER;
    }

    if ( IsBadWritePtr( ppProfile, sizeof(IRTCProfile *) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::GetBestProfile - "
                            "bad IRTCProfile pointer"));

        return E_POINTER;
    }

    //
    // Determine the type of the address
    //

    BOOL    bUseProfile = TRUE;
  
    if( szDestUserURI != NULL )
    {
        BOOL    bIsPhoneAddress = FALSE;
        BOOL    bIsSIPAddress = FALSE;
        BOOL    bIsTELAddress = FALSE;
        BOOL    bHasMaddrOrTsp = FALSE;
        BOOL    bIsEmailLike = FALSE;

        hr = GetAddressType(
            szDestUserURI,
            &bIsPhoneAddress,
            &bIsSIPAddress,
            &bIsTELAddress,
            &bIsEmailLike,
            &bHasMaddrOrTsp);

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::GetBestProfile - "
                "GetAddressType failed 0x%lx", hr)); 
            
            return hr;
        }

        if ( bHasMaddrOrTsp ||
             (bIsPhoneAddress && bIsSIPAddress) ||
             (!bIsPhoneAddress && !bIsEmailLike) )
        {
            //
            // This address has all the information we need. No need to
            // use a profile.
            //

            bUseProfile = FALSE;

            if (*penType == RTCST_PHONE_TO_PHONE)
            {
                //
                // This cannot be used for PINT calls
                //

                LOG((RTC_ERROR, "CRTCClient::GetBestProfile - "
                    "address will not work for RTCST_PHONE_TO_PHONE")); 

                return RTC_E_INVALID_SESSION_TYPE;
            }           
            else if (*penType == RTCST_PC_TO_PHONE)
            {
                *penType = RTCST_PC_TO_PC;
            }
        }
        else
        {
            if ( bIsPhoneAddress && (*penType == RTCST_PC_TO_PC) )
            {
                *penType = RTCST_PC_TO_PHONE;
            }
            else if ( !bIsPhoneAddress && (*penType == RTCST_PC_TO_PHONE) )
            {
                *penType = RTCST_PC_TO_PC;
            }
        }
    }

    if ( fIsRedirect &&
         ((*penType == RTCST_PC_TO_PC) || (*penType == RTCST_IM)) )
    {
        //
        // Always redirect PC_TO_PC calls with no profile
        //

        LOG((RTC_INFO, "CRTCClient::GetBestProfile - "
                    "choosing no profile for redirect")); 

        bUseProfile = FALSE;
    }

    if ( bUseProfile )
    {
        //
        // Choose an appropriate profile
        //

        IRTCProfile      * pProfile = NULL;
        BOOL               bFound = FALSE;

        for ( int n=0; n < m_ProfileArray.GetSize() ; n++ )
        {
            //
            // Get the supported session types of the provider
            //

            long lSupportedSessions;

            hr = m_ProfileArray[n]->get_SessionCapabilities( &lSupportedSessions );

            if ( FAILED( hr ) )
            {
                LOG((RTC_ERROR, "CRTCClient::GetBestProfile - "
                                "get_SessionCapabilities failed 0x%lx - skipping", hr));

                continue;
            }

            switch ( *penType )
            {
            case RTCST_PC_TO_PC:
                if ( lSupportedSessions & RTCSI_PC_TO_PC )
                {
                    bFound = TRUE;
                }
                break;

            case RTCST_PC_TO_PHONE:
                if ( lSupportedSessions & RTCSI_PC_TO_PHONE )
                {
                    bFound = TRUE;
                }
                break;

            case RTCST_PHONE_TO_PHONE:
                if ( lSupportedSessions & RTCSI_PHONE_TO_PHONE )
                {
                    bFound = TRUE;
                }
                break;
            
            case RTCST_IM:
                if ( lSupportedSessions & RTCSI_IM )
                {                   
                    bFound = TRUE;
                }
                break;
            }

            if ( bFound == TRUE )
            {
                *ppProfile = m_ProfileArray[n];
                (*ppProfile)->AddRef();

                break;
            }
        }

        if ( bFound == FALSE )
        {
            LOG((RTC_ERROR, "CRTCClient::GetBestProfile - "
                            "no profile found"));

            if ( (*penType == RTCST_PC_TO_PC) ||
                 (*penType == RTCST_IM) )
            {
                *ppProfile = NULL;
            }
            else
            {
                return RTC_E_NO_PROFILE;
            }
        }
    }
    else
    {
        *ppProfile = NULL;
    }

    LOG((RTC_INFO, "CRTCClient::GetBestProfile - profile [%p]", *ppProfile ));
       
    LOG((RTC_TRACE, "CRTCClient::GetBestProfile - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::put_ListenForIncomingSessions
//
// This is an IRTCClient method that sets the client to listen for 
// incoming sessions.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::put_ListenForIncomingSessions(
        RTC_LISTEN_MODE enListen
        )
{
    LOG((RTC_TRACE, "CRTCClient::put_ListenForIncomingSessions - enter"));   

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::put_ListenForIncomingSessions - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    HRESULT hr;

    BOOL fEnableIncomingCalls;
    BOOL fEnableStaticPort;

    switch ( enListen )
    {
    case RTCLM_NONE:
        fEnableStaticPort = FALSE;
        fEnableIncomingCalls = FALSE;
        break;      

    case RTCLM_DYNAMIC:
        fEnableStaticPort = FALSE;
        fEnableIncomingCalls = TRUE;
        break;

    case RTCLM_BOTH:
        fEnableStaticPort = TRUE;
        fEnableIncomingCalls = TRUE;
        break;

    default:
        LOG((RTC_ERROR, "CRTCClient::put_ListenForIncomingSessions - "
                                     "invalid argument"));

        return E_INVALIDARG;
    }

    if ( fEnableStaticPort && !m_fEnableStaticPort )
    {
        hr = m_pSipStack->EnableStaticPort();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::put_ListenForIncomingSessions - "
                                     "EnableStaticPort failed 0x%lx"));

            return hr;
        }
    }
    else if ( !fEnableStaticPort && m_fEnableStaticPort )
    {        
        hr = m_pSipStack->DisableStaticPort();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::put_ListenForIncomingSessions - "
                                     "DisableStaticPort failed 0x%lx"));

            return hr;
        }
    }

    if ( fEnableIncomingCalls && !m_fEnableIncomingCalls )
    {
        hr = m_pSipStack->EnableIncomingCalls();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::put_ListenForIncomingSessions - "
                                     "EnableIncomingCalls failed 0x%lx"));

            return hr;
        }
    }
    else if ( !fEnableIncomingCalls && m_fEnableIncomingCalls )
    {
        hr = m_pSipStack->DisableIncomingCalls();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::put_ListenForIncomingSessions - "
                                     "DisableIncomingCalls failed 0x%lx"));

            return hr;
        }

        hr = m_pSipStack->DisableStaticPort();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::put_ListenForIncomingSessions - "
                                     "DisableStaticPort failed 0x%lx"));

            return hr;
        }
    }

    m_fEnableIncomingCalls = fEnableIncomingCalls;
    m_fEnableStaticPort = fEnableStaticPort;
    
    LOG((RTC_TRACE, "CRTCClient::put_ListenForIncomingSessions - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_ListenForIncomingSessions
//
// This is an IRTCClient method that determines if the client is 
// currently listening for incoming sessions.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_ListenForIncomingSessions(
        RTC_LISTEN_MODE * penListen
        )
{
    LOG((RTC_TRACE, "CRTCClient::get_ListenForIncomingSessions - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_ListenForIncomingSessions - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadWritePtr(penListen, sizeof( RTC_LISTEN_MODE ) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_ListenForIncomingSessions - "
                                 "bad pointer"));

        return E_POINTER;
    }

    if ( m_fEnableIncomingCalls )
    {
        if ( m_fEnableStaticPort )
        {
            *penListen = RTCLM_BOTH;
        }
        else
        {
            *penListen = RTCLM_DYNAMIC;
        }
    }
    else
    {
        *penListen = RTCLM_NONE;
    }

    LOG((RTC_TRACE, "CRTCClient::get_ListenForIncomingSessions - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::InvokeTuningWizard
//
// This is an IRTCClient method that will invoke the tuning wizard UI
// for selection and tuning of audio and video devices.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::InvokeTuningWizard(
        OAHWND hwndParent
        )
{
    HRESULT hr;

    LOG((RTC_TRACE, "CRTCClient::InvokeTuningWizard - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::InvokeTuningWizard - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Don't let the tuning wizard start if we already have
    // one running
    //

    if ( m_fTuning )
    {
        LOG((RTC_ERROR, "CRTCClient::InvokeTuningWizard - "
                    "tuning is active" ));

        return RTC_E_MEDIA_CONTROLLER_STATE;
    }

    //
    // Don't let the tuning wizard start if there is active media
    //

    if ( m_lActiveMedia )
    {
        LOG((RTC_ERROR, "CRTCClient::InvokeTuningWizard - "
                    "media is active" ));

        return RTC_E_MEDIA_CONTROLLER_STATE;
    }

    IRTCTerminalManage * pTerminalManage = NULL;   
    LONG lSoundCaps = 0;
    BOOL fAudioCapture = FALSE;
    BOOL fAudioRender = FALSE;
    BOOL fVideo = FALSE;

    //
    // Get the TerminalManage interface from MediaManage
    //

    hr = m_pMediaManage->QueryInterface(IID_IRTCTerminalManage, (void **)&pTerminalManage );

    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CRTCClient::InvokeTuningWizard - "
                "QI(IRTCTerminalManage) failed 0x%lx", hr));

        return hr;
    }

    //
    // Mark our cached media capabilities as invalid
    //

    m_fMediaCapsCached = FALSE;

    //
    // Add a reference to ourselves in case somebody tries to
    // release the client object while we are tuning.
    //

    AddRef();
        
    //
    // Call the tuning wizard function
    //

    m_fTuning = TRUE;

    hr = RTCTuningWizard(
                    this, 
                    _Module.GetResourceInstance(), 
                    (HWND)hwndParent, 
                    pTerminalManage,  
                    &fAudioCapture,
                    &fAudioRender,
                    &fVideo
                    );

    m_fTuning = FALSE;

    if ( hr != S_OK )
    {
        LOG((RTC_ERROR, "CRTCClient::InvokeTuningWizard - "
                "RTCTuningWizard failed 0x%lx", hr));

        pTerminalManage->Release();
        pTerminalManage = NULL;

        Release();

        return hr;
    }

    //
    // Check the terminals
    //

    IRTCTerminal * pTerminal = NULL;

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            RTC_MD_CAPTURE,                                            
                            &pTerminal
                            );        

    if ( SUCCEEDED(hr) )
    {
        m_fAudioCaptureDisabled = fAudioCapture && ( pTerminal == NULL);  
        
        if ( pTerminal != NULL )
        {
            pTerminal->Release();
            pTerminal = NULL;
        }
    }

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            RTC_MD_RENDER,                                            
                            &pTerminal
                            );        

    if ( SUCCEEDED(hr) )
    {
        m_fAudioRenderDisabled = fAudioRender && ( pTerminal == NULL);     
        
        if ( pTerminal != NULL )
        {
            pTerminal->Release();
            pTerminal = NULL;
        }
    }

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_VIDEO,
                            RTC_MD_CAPTURE,                                            
                            &pTerminal
                            );        

    if ( SUCCEEDED(hr) )
    {
        m_fVideoCaptureDisabled = fVideo && ( pTerminal == NULL);   
        
        if ( pTerminal != NULL )
        {
            pTerminal->Release();
            pTerminal = NULL;
        }
    }
    
    pTerminalManage->Release();
    pTerminalManage = NULL;

    //
    // Store new terminal settings
    //

    hr = StoreDefaultTerminals();

    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CRTCClient::InvokeTuningWizard - "
                "StoreDefaultTerminals failed 0x%lx", hr));

        Release();

        return hr;
    }

    m_fTuned = TRUE;

    put_RegistryDword( RTCRD_TUNED, 1 );

    //
    // Send an event
    //

    CRTCClientEvent::FireEvent(this, RTCCET_DEVICE_CHANGE);

    Release();

    LOG((RTC_TRACE, "CRTCClient::InvokeTuningWizard - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_IsTuned
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_IsTuned(
    VARIANT_BOOL * pfTuned
    )
{
    LOG((RTC_TRACE, "CRTCClient::get_IsTuned - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_IsTuned - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadWritePtr( pfTuned, sizeof(VARIANT_BOOL) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_IsTuned - "
                            "bad VARIANT_BOOL pointer"));

        return E_POINTER;
    }

    *pfTuned = m_fTuned ? VARIANT_TRUE : VARIANT_FALSE;

    LOG((RTC_TRACE, "CRTCClient::get_IsTuned - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_NetworkQuality
//
// Returns a measure of the network quality (a combination of packet loss, jitter, 
// and others)
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_NetworkQuality(
    long * plNetworkQuality
    )
{
    HRESULT   hr;
    
    LOG((RTC_TRACE, "CRTCClient::get_NetworkQuality - enter"));
    
    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_NetworkQuality - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadWritePtr( plNetworkQuality, sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_NetworkQuality - "
                            "bad long pointer"));

        return E_POINTER;
    }

    DWORD   dwValue;

    hr = m_pMediaManage->GetNetworkQuality(&dwValue);
    
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCClient::get_NetworkQuality - "
            "GetNetworkQuality with error 0x%x", hr));

        return hr;
    }

    *plNetworkQuality = (long)dwValue;
    
    LOG((RTC_TRACE, "CRTCClient::get_NetworkQuality - exit"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::GetAudioCfg
//
// This is a helper method to retreive IRTCAudioConfigure
//
/////////////////////////////////////////////////////////////////////////////
HRESULT
CRTCClient::GetAudioCfg(
        RTC_AUDIO_DEVICE enDevice,
        IRTCAudioConfigure ** ppAudioCfg
        )
{
    //LOG((RTC_TRACE, "CRTCClient::GetAudioCfg - enter"));

    IRTCTerminalManage * pTerminalManage = NULL;
    IRTCTerminal       * pTerminal = NULL;
    HRESULT              hr;

    //
    // Check the arguments
    //

    if( (enDevice != RTCAD_SPEAKER) && 
        (enDevice != RTCAD_MICROPHONE) )
    {
        LOG((RTC_ERROR, "CRTCClient::GetAudioCfg - "
                            "invalid audio device"));

        return E_INVALIDARG;
    }

    //
    // Get the IRTCTerminalManage interface
    //

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTerminalManage,
                           (void **)&pTerminalManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::GetAudioCfg - "
                            "QI(TerminalManage) failed 0x%lx", hr));

        return hr;
    }

    //
    // Get the terminal
    //

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            (enDevice == RTCAD_SPEAKER) ? 
                                RTC_MD_RENDER : RTC_MD_CAPTURE,                                            
                            &pTerminal
                            );

    pTerminalManage->Release();
    pTerminalManage = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::GetAudioCfg - "
                            "GetDefaultTerminal failed 0x%lx", hr));

        return hr;
    }

    if ( pTerminal == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::GetAudioCfg - "
                        "NULL terminal"));

        return E_FAIL;
    }

    //
    // Get the IRTCAudioConfigure interface
    //

    hr = pTerminal->QueryInterface(
                   IID_IRTCAudioConfigure,
                   (void **)ppAudioCfg
                  );

    pTerminal->Release();
    pTerminal = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::GetAudioCfg - "
                            "QI(AudioConfigure) failed 0x%lx", hr));     

        return hr;
    }

    //LOG((RTC_TRACE, "CRTCClient::GetAudioCfg - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::put_Volume
//
// This is an IRTCClient method that will set the volume level of the
// speaker or microphone.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::put_Volume(
        RTC_AUDIO_DEVICE enDevice,
        long lVolume
        )
{
    LOG((RTC_TRACE, "CRTCClient::put_Volume - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::put_Volume - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    IRTCAudioConfigure * pAudioCfg = NULL;
    HRESULT              hr;

    //
    // Get the IRTCAudioConfigure interface
    //

    hr = GetAudioCfg(
                     enDevice,
                     &pAudioCfg
                    );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_Volume - "
                            "GetAudioCfg failed 0x%lx", hr));     

        return hr;
    }

    //
    // Set the volume
    //

    hr = pAudioCfg->SetVolume( lVolume );

    pAudioCfg->Release();
    pAudioCfg = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_Volume - "
                            "SetVolume failed 0x%lx", hr));

    }

    LOG((RTC_TRACE, "CRTCClient::put_Volume - exit S_OK"));

    return S_OK;
}
 
/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_Volume
//
// This is an IRTCClient method that will return the volume level of the
// speaker or microphone.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_Volume(
        RTC_AUDIO_DEVICE enDevice,
        long * plVolume
        )
{
    LOG((RTC_TRACE, "CRTCClient::get_Volume - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Volume - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadWritePtr( plVolume, sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Volume - "
                            "bad long pointer"));

        return E_POINTER;
    }

    IRTCAudioConfigure * pAudioCfg = NULL;
    HRESULT              hr;

    //
    // Get the IRTCAudioConfigure interface
    //

    hr = GetAudioCfg(
                     enDevice,
                     &pAudioCfg
                    );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Volume - "
                            "GetAudioCfg failed 0x%lx", hr));     

        return hr;
    }

    //
    // Get the volume
    //

    UINT uiVolume;

    hr = pAudioCfg->GetVolume( &uiVolume );

    pAudioCfg->Release();
    pAudioCfg = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Volume - "
                            "GetVolume failed 0x%lx", hr));

        return hr;
    }

    *plVolume = uiVolume;

    LOG((RTC_TRACE, "CRTCClient::get_Volume - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::put_AudioMuted
//
// This is an IRTCClient method that will set the mute of the
// speaker or microphone.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::put_AudioMuted(
        RTC_AUDIO_DEVICE enDevice,
        VARIANT_BOOL fMuted
        )
{
    LOG((RTC_TRACE, "CRTCClient::put_AudioMuted - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::put_AudioMuted - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    IRTCAudioConfigure * pAudioCfg = NULL;
    HRESULT              hr;

    //
    // Get the IRTCAudioConfigure interface
    //

    hr = GetAudioCfg(
                     enDevice,
                     &pAudioCfg
                    );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_AudioMuted - "
                            "GetAudioCfg failed 0x%lx", hr));     

        return hr;
    }

    //
    // Set the mute
    //

    hr = pAudioCfg->SetMute( fMuted ? TRUE : FALSE);

    pAudioCfg->Release();
    pAudioCfg = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_AudioMuted - "
                            "SetMute failed 0x%lx", hr));

        return hr;
    }
    
    //
    // Cache the mute state for microphone
    //
    if(enDevice == RTCAD_MICROPHONE)
    {
        m_bCaptureDeviceMuted = fMuted ? TRUE : FALSE;
    }

    //
    // Fire a volume change event
    //

    CRTCClientEvent::FireEvent(this, RTCCET_VOLUME_CHANGE);

    LOG((RTC_TRACE, "CRTCClient::put_AudioMuted - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_AudioMuted
//
// This is an IRTCClient method that will return the mute of the
// speaker or microphone.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_AudioMuted(
        RTC_AUDIO_DEVICE enDevice,
        VARIANT_BOOL * pfMuted
        )
{
    LOG((RTC_TRACE, "CRTCClient::get_AudioMuted - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_AudioMuted - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadWritePtr( pfMuted, sizeof(VARIANT_BOOL) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_AudioMuted - "
                            "bad VARIANT_BOOL pointer"));

        return E_POINTER;
    }

    IRTCAudioConfigure * pAudioCfg = NULL;
    HRESULT              hr;
    BOOL                 fMuted;

    //
    // Get the IRTCAudioConfigure interface
    //

    hr = GetAudioCfg(
                     enDevice,
                     &pAudioCfg
                    );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_AudioMuted - "
                            "GetAudioCfg failed 0x%lx", hr));     

        return hr;
    }

    //
    // Get the mute
    //

    hr = pAudioCfg->GetMute( &fMuted );

    pAudioCfg->Release();
    pAudioCfg = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_AudioMuted - "
                            "GetMute failed 0x%lx", hr));

        return hr;
    }

    //
    // Cache the mute state for microphone
    //
    if(enDevice == RTCAD_MICROPHONE)
    {
        m_bCaptureDeviceMuted = fMuted;
    }

    *pfMuted = fMuted ? VARIANT_TRUE : VARIANT_FALSE;

    LOG((RTC_TRACE, "CRTCClient::get_AudioMuted - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_IVideoWindow
//
// This is an IRTCClient method that will return the IVideoWindow interface
// for the receive or preview video window.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_IVideoWindow(
        RTC_VIDEO_DEVICE enDevice,
        IVideoWindow ** ppIVideoWindow
        )
{
    LOG((RTC_TRACE, "CRTCClient::get_IVideoWindow - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_IVideoWindow - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    HRESULT hr;

    if ( IsBadWritePtr( ppIVideoWindow, sizeof(IVideoWindow *) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_IVideoWindow - "
                            "bad IVideoWindow pointer"));

        return E_POINTER;
    }

    if ( (enDevice != RTCVD_PREVIEW) && (enDevice != RTCVD_RECEIVE) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_IVideoWindow - "
                            "invalid device argument"));

        return E_INVALIDARG;
    }

    LOG((RTC_INFO, "CRTCClient::get_IVideoWindow - [%s]",
                        (enDevice == RTCVD_PREVIEW) ? "PREVIEW" : "RECEIVE"));

    if ( m_pVideoWindow[enDevice] == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::get_IVideoWindow - "
                            "video window does not exist"));

        return E_FAIL;
    }

    //
    // Get the IVideoWIndow
    //

    *ppIVideoWindow = m_pVideoWindow[enDevice];
    m_pVideoWindow[enDevice]->AddRef();

    LOG((RTC_TRACE, "CRTCClient::get_IVideoWindow - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::GetTerminalList
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::GetTerminalList(
        IRTCTerminalManage * pTerminalManage,
        IRTCTerminal *** pppTerminals,
        DWORD * pdwCount
        )
{
    LOG((RTC_TRACE, "CRTCClient::GetTerminalList - enter"));

    HRESULT hr;

    //
    // Count the terminals
    //

    DWORD dwCount = 0;

    hr = pTerminalManage->GetStaticTerminals( &dwCount, NULL );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::GetTerminalList - "
                            "GetStaticTerminals failed 0x%lx", hr));
        return hr;
    }

    LOG((RTC_INFO, "CRTCClient::GetTerminalList - "
                            "%d static terminals", dwCount));

    IRTCTerminal ** ppTerminals = NULL;

    ppTerminals = (IRTCTerminal **)RtcAlloc( dwCount * sizeof(IRTCTerminal*) );

    if ( ppTerminals == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::GetTerminalList - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }
    
    //
    // Get the static terminals
    //

    hr = pTerminalManage->GetStaticTerminals( &dwCount, ppTerminals );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::GetTerminalList - "
                            "GetStaticTerminals failed 0x%lx", hr));

        RtcFree( ppTerminals );

        return hr;
    }

    *pppTerminals = ppTerminals;
    *pdwCount = dwCount;

    LOG((RTC_TRACE, "CRTCClient::GetTerminalList - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::FreeTerminalList
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::FreeTerminalList(
        IRTCTerminal ** ppTerminals,
        DWORD dwCount
        )
{
    LOG((RTC_TRACE, "CRTCClient::FreeTerminalList - enter"));

    for ( DWORD dw = 0; dw < dwCount; dw++ )
    {
        ppTerminals[dw]->Release();
        ppTerminals[dw] = NULL;
    }

    RtcFree( ppTerminals );

    LOG((RTC_TRACE, "CRTCClient::FreeTerminalList - exit S_OK"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::put_PreferredAudioDevice
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::put_PreferredAudioDevice(
        RTC_AUDIO_DEVICE enDevice,
        BSTR  bstrDeviceName
        )
{
    LOG((RTC_TRACE, "CRTCClient::put_PreferredAudioDevice - enter"));

    HRESULT hr;    

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredAudioDevice - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if( (enDevice != RTCAD_SPEAKER) && 
        (enDevice != RTCAD_MICROPHONE) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredAudioDevice - "
                            "invalid audio device"));

        return E_INVALIDARG;
    }

    if ( IsBadStringPtrW( bstrDeviceName, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredAudioDevice - "
                            "bad string pointer"));

        return E_POINTER;
    }

    //
    // Get the IRTCTerminalManage interface
    //

    IRTCTerminalManage * pTerminalManage = NULL;

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTerminalManage,
                           (void **)&pTerminalManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredAudioDevice - "
                            "QI(TerminalManage) failed 0x%lx", hr));

        return hr;
    }

    //
    // Get the old terminal
    //

    IRTCTerminal * pOldTerminal = NULL;

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            (enDevice == RTCAD_SPEAKER) ? 
                                RTC_MD_RENDER : RTC_MD_CAPTURE,                                            
                            &pOldTerminal
                            );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredAudioDevice - "
                            "GetDefaultTerminal failed 0x%lx", hr));

        pTerminalManage->Release();
        pTerminalManage = NULL;

        return hr;
    }

    //
    // Get the terminal list
    //

    IRTCTerminal ** ppTerminals = NULL;
    DWORD dwCount = 0;

    hr = GetTerminalList( pTerminalManage, &ppTerminals, &dwCount );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredAudioDevice - "
                            "GetTerminalList failed 0x%lx", hr));

        if (pOldTerminal != NULL)
        {
            pOldTerminal->Release();
            pOldTerminal = NULL;
        }

        pTerminalManage->Release();
        pTerminalManage = NULL;

        return hr;
    }

    RTC_MEDIA_TYPE mt;
    RTC_MEDIA_DIRECTION md;
    WCHAR * szDescription;
    BOOL bFound = FALSE;

    for ( DWORD dw=0; (dw < dwCount) && !bFound; dw++ )
    {
        //
        // Get terminal media type, direction, and description
        //

        ppTerminals[dw]->GetMediaType( &mt );
        ppTerminals[dw]->GetDirection( &md );
        
        hr = ppTerminals[dw]->GetDescription( &szDescription );       

        if ( SUCCEEDED(hr) )
        {
            //
            // Is this terminal one which we want to select?
            //

            BOOL fSelect = FALSE;

            if ( mt == RTC_MT_AUDIO )
            {
                if ( ((md == RTC_MD_CAPTURE) && (enDevice == RTCAD_MICROPHONE)) ||
                     ((md == RTC_MD_RENDER) && (enDevice == RTCAD_SPEAKER)) )
                {
                    if ( wcscmp( bstrDeviceName, szDescription ) == 0 )
                    {
                        if ( ppTerminals[dw] == pOldTerminal )
                        {
                            LOG((RTC_INFO, "CRTCClient::put_PreferredAudioDevice - "
                                    "terminal already selected"));
                        }
                        else
                        {
                            LOG((RTC_INFO, "CRTCClient::put_PreferredAudioDevice - "
                                    "selecting a terminal"));

                            hr = pTerminalManage->SetDefaultStaticTerminal( mt, md, ppTerminals[dw] );

                            if ( FAILED(hr) )
                            {
                                LOG((RTC_ERROR, "CRTCClient::put_PreferredAudioDevice - "
                                                    "SetDefaultStaticTerminal failed 0x%lx", hr));
                            }
                            else
                            {
                                //
                                // Mark our cached media capabilities as invalid
                                //

                                m_fMediaCapsCached = FALSE;

                                if (enDevice == RTCAD_MICROPHONE)
                                {
                                    m_fAudioCaptureDisabled = FALSE;
                                }
                                else
                                {
                                    m_fAudioRenderDisabled = FALSE;
                                }

                                //
                                // Save the settings
                                //

                                hr = StoreDefaultTerminals();

                                if ( FAILED(hr) )
                                {
                                    LOG((RTC_ERROR, "CRTCClient::put_PreferredAudioDevice - "
                                                "StoreDefaultTerminals failed 0x%lx", hr));
                                }

                                //
                                // Send an event
                                //

                                CRTCClientEvent::FireEvent(this, RTCCET_DEVICE_CHANGE);
                            }
                        }

                        bFound = TRUE;
                    }
                }
            }

            //
            // Free the description
            //

            ppTerminals[dw]->FreeDescription( szDescription );    
        }
    }

    FreeTerminalList( ppTerminals, dwCount );
    ppTerminals = NULL;

    if (pOldTerminal != NULL)
    {
        pOldTerminal->Release();
        pOldTerminal = NULL;
    }

    pTerminalManage->Release();
    pTerminalManage = NULL;

    if ( !bFound )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredAudioDevice - "
                "terminal was not found"));

        return E_INVALIDARG;
    }

    LOG((RTC_TRACE, "CRTCClient::put_PreferredAudioDevice - exit 0x%lx"));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_PreferredAudioDevice
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_PreferredAudioDevice(
        RTC_AUDIO_DEVICE enDevice,
        BSTR * pbstrDeviceName
        )
{
    LOG((RTC_TRACE, "CRTCClient::get_PreferredAudioDevice - enter"));

    IRTCTerminalManage * pTerminalManage = NULL;
    IRTCTerminal       * pTerminal = NULL;
    HRESULT              hr;

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAudioDevice - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( pbstrDeviceName, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAudioDevice - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if( (enDevice != RTCAD_SPEAKER) && 
        (enDevice != RTCAD_MICROPHONE) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAudioDevice - "
                            "invalid audio device"));

        return E_INVALIDARG;
    }

    //
    // Get the IRTCTerminalManage interface
    //

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTerminalManage,
                           (void **)&pTerminalManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAudioDevice - "
                            "QI(TerminalManage) failed 0x%lx", hr));

        return hr;
    }

    //
    // Get the terminal
    //

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            (enDevice == RTCAD_SPEAKER) ? 
                                RTC_MD_RENDER : RTC_MD_CAPTURE,                                            
                            &pTerminal
                            );

    pTerminalManage->Release();
    pTerminalManage = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAudioDevice - "
                            "GetDefaultTerminal failed 0x%lx", hr));

        return hr;
    }

    if ( pTerminal == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAudioDevice - "
                        "NULL terminal"));

        return RTC_E_NO_DEVICE;
    }

    //
    // Get the description
    //

    WCHAR * szDescription = NULL;

    hr = pTerminal->GetDescription(
                       &szDescription
                      );
   
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAudioDevice - "
                            "GetDescription failed 0x%lx", hr));     

        pTerminal->Release();
        pTerminal = NULL;

        return hr;
    }

    *pbstrDeviceName = SysAllocString( szDescription );

    pTerminal->FreeDescription( szDescription );
    szDescription = NULL;

    pTerminal->Release();
    pTerminal = NULL;

    if ( *pbstrDeviceName == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAudioDevice - "
                            "out of memory")); 
        
        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCClient::get_PreferredAudioDevice - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::put_PreferredVolume
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::put_PreferredVolume(
        RTC_AUDIO_DEVICE enDevice,
        long  lVolume
        )
{
    LOG((RTC_TRACE, "CRTCClient::put_PreferredVolume - enter"));

    HRESULT hr;

    IRTCTerminalManage * pTerminalManage = NULL;
    IRTCTuningManage   * pTuningManage = NULL;
    IRTCTerminal       * pCapture = NULL;
    IRTCTerminal       * pRender = NULL;

    //
    // Check the arguments
    //

    if( (enDevice != RTCAD_SPEAKER) && 
        (enDevice != RTCAD_MICROPHONE) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredVolume - "
                            "invalid audio device"));

        return E_INVALIDARG;
    }

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredVolume - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Get the IRTCTerminalManage interface
    //

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTerminalManage,
                           (void **)&pTerminalManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredVolume - "
                            "QI(TerminalManage) failed 0x%lx", hr));

        return hr;
    }

    //
    // Get the terminals
    //

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            RTC_MD_RENDER,                                            
                            &pRender
                            );    

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredVolume - "
                            "GetDefaultTerminal(Render) failed 0x%lx", hr));

        pTerminalManage->Release();
        pTerminalManage = NULL;

        return hr;
    }

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            RTC_MD_CAPTURE,                                            
                            &pCapture
                            );
    
    pTerminalManage->Release();
    pTerminalManage = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredVolume - "
                            "GetDefaultTerminal(Capture) failed 0x%lx", hr));

        if (pRender != NULL)
        {
            pRender->Release();
            pRender = NULL;
        }

        return hr;
    }

    //
    // Get the IRTCTuningManage interface
    //

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTuningManage,
                           (void **)&pTuningManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredVolume - "
                            "QI(TuningManage) failed 0x%lx", hr));

        if (pRender != NULL)
        {
            pRender->Release();
            pRender = NULL;
        }

        if (pCapture != NULL)
        {
            pCapture->Release();
            pCapture = NULL;
        }

        return hr;
    }

    //
    // Initialize Tuning
    //

    hr = pTuningManage->InitializeTuning(
                                pCapture,
                                pRender,
                                FALSE);

    if (pRender != NULL)
    {
        pRender->Release();
        pRender = NULL;
    }

    if (pCapture != NULL)
    {
        pCapture->Release();
        pCapture = NULL;
    }

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredVolume - "
                            "InitializeTuning failed 0x%lx", hr));

        pTuningManage->Release();
        pTuningManage = NULL;

        return hr;
    }

    //
    // Get the volume
    //

    hr = pTuningManage->SetVolume(
                            (enDevice == RTCAD_SPEAKER) ? 
                                RTC_MD_RENDER : RTC_MD_CAPTURE, 
                            (UINT)lVolume
                            );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredVolume - "
                            "SetVolume failed 0x%lx", hr));
    }

    //
    // Shutdown Tuning
    //

    pTuningManage->ShutdownTuning();

    pTuningManage->Release();
    pTuningManage = NULL;

    LOG((RTC_TRACE, "CRTCClient::put_PreferredVolume - exit 0x%lx"));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_PreferredVolume
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_PreferredVolume(
        RTC_AUDIO_DEVICE enDevice,
        long * plVolume
        )
{
    LOG((RTC_TRACE, "CRTCClient::get_PreferredVolume - enter"));

    HRESULT hr;

    IRTCTerminalManage * pTerminalManage = NULL;
    IRTCTuningManage   * pTuningManage = NULL;
    IRTCTerminal       * pCapture = NULL;
    IRTCTerminal       * pRender = NULL;
    UINT                 uiVolume = 0;

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredVolume - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( plVolume, sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAudioDevice - "
                            "bad long pointer"));

        return E_POINTER;
    }

    if( (enDevice != RTCAD_SPEAKER) && 
        (enDevice != RTCAD_MICROPHONE) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredVolume - "
                            "invalid audio device"));

        return E_INVALIDARG;
    }
    //
    // Get the IRTCTerminalManage interface
    //

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTerminalManage,
                           (void **)&pTerminalManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredVolume - "
                            "QI(TerminalManage) failed 0x%lx", hr));

        return hr;
    }

    //
    // Get the terminals
    //

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            RTC_MD_RENDER,                                            
                            &pRender
                            );    

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredVolume - "
                            "GetDefaultTerminal(Render) failed 0x%lx", hr));

        pTerminalManage->Release();
        pTerminalManage = NULL;

        return hr;
    }

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            RTC_MD_CAPTURE,                                            
                            &pCapture
                            );
    
    pTerminalManage->Release();
    pTerminalManage = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredVolume - "
                            "GetDefaultTerminal(Capture) failed 0x%lx", hr));

        if (pRender != NULL)
        {
            pRender->Release();
            pRender = NULL;
        }

        return hr;
    }

    //
    // Get the IRTCTuningManage interface
    //

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTuningManage,
                           (void **)&pTuningManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredVolume - "
                            "QI(TuningManage) failed 0x%lx", hr));

        if (pRender != NULL)
        {
            pRender->Release();
            pRender = NULL;
        }

        if (pCapture != NULL)
        {
            pCapture->Release();
            pCapture = NULL;
        }

        return hr;
    }

    //
    // Initialize Tuning
    //

    hr = pTuningManage->InitializeTuning(
                                pCapture,
                                pRender,
                                FALSE);

    if (pRender != NULL)
    {
        pRender->Release();
        pRender = NULL;
    }

    if (pCapture != NULL)
    {
        pCapture->Release();
        pCapture = NULL;
    }

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredVolume - "
                            "InitializeTuning failed 0x%lx", hr));

        pTuningManage->Release();
        pTuningManage = NULL;

        return hr;
    }

    //
    // Get the volume
    //

    hr = pTuningManage->GetVolume(
                            (enDevice == RTCAD_SPEAKER) ? 
                                RTC_MD_RENDER : RTC_MD_CAPTURE, 
                            &uiVolume
                            );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredVolume - "
                            "GetVolume failed 0x%lx", hr));
    }
    else
    {
        *plVolume = (long)uiVolume;
    }

    //
    // Shutdown Tuning
    //

    pTuningManage->ShutdownTuning();

    pTuningManage->Release();
    pTuningManage = NULL;

    LOG((RTC_TRACE, "CRTCClient::get_PreferredVolume - exit 0x%lx"));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::put_PreferredAEC
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::put_PreferredAEC(
        VARIANT_BOOL  bEnable
        )
{
    LOG((RTC_TRACE, "CRTCClient::put_PreferredAEC - enter"));

    HRESULT hr;

    IRTCTerminalManage * pTerminalManage = NULL;
    IRTCTuningManage   * pTuningManage = NULL;
    IRTCTerminal       * pCapture = NULL;
    IRTCTerminal       * pRender = NULL;

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredAEC - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Get the IRTCTerminalManage interface
    //

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTerminalManage,
                           (void **)&pTerminalManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredAEC - "
                            "QI(TerminalManage) failed 0x%lx", hr));

        return hr;
    }

    //
    // Get the terminals
    //

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            RTC_MD_RENDER,                                            
                            &pRender
                            );    

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredAEC - "
                            "GetDefaultTerminal(Render) failed 0x%lx", hr));

        pTerminalManage->Release();
        pTerminalManage = NULL;

        return hr;
    }

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            RTC_MD_CAPTURE,                                            
                            &pCapture
                            );
    
    pTerminalManage->Release();
    pTerminalManage = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredAEC - "
                            "GetDefaultTerminal(Capture) failed 0x%lx", hr));

        if (pRender != NULL)
        {
            pRender->Release();
            pRender = NULL;
        }

        return hr;
    }

    //
    // Get the IRTCTuningManage interface
    //

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTuningManage,
                           (void **)&pTuningManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredAEC - "
                            "QI(TuningManage) failed 0x%lx", hr));

        if (pRender != NULL)
        {
            pRender->Release();
            pRender = NULL;
        }

        if (pCapture != NULL)
        {
            pCapture->Release();
            pCapture = NULL;
        }

        return hr;
    }

    //
    // Initialize Tuning
    //

    hr = pTuningManage->InitializeTuning(
                                pCapture,
                                pRender,
                                bEnable ? TRUE : FALSE);

    if (pRender != NULL)
    {
        pRender->Release();
        pRender = NULL;
    }

    if (pCapture != NULL)
    {
        pCapture->Release();
        pCapture = NULL;
    }

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredAEC - "
                            "InitializeTuning failed 0x%lx", hr));

        pTuningManage->Release();
        pTuningManage = NULL;

        return hr;
    }

    //
    // Save AEC setting
    //

    hr = pTuningManage->SaveAECSetting();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredAEC - "
                            "SaveAECSetting failed 0x%lx", hr));

        pTuningManage->ShutdownTuning();

        pTuningManage->Release();
        pTuningManage = NULL;

        return hr;
    }

    //
    // Shutdown Tuning
    //

    pTuningManage->ShutdownTuning();

    pTuningManage->Release();
    pTuningManage = NULL;

    LOG((RTC_TRACE, "CRTCClient::put_PreferredAEC - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_PreferredAEC
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_PreferredAEC(
        VARIANT_BOOL * pbEnabled
        )
{
    LOG((RTC_TRACE, "CRTCClient::get_PreferredAEC - enter"));

    HRESULT hr;

    IRTCTerminalManage * pTerminalManage = NULL;
    IRTCTuningManage   * pTuningManage = NULL;
    IRTCTerminal       * pCapture = NULL;
    IRTCTerminal       * pRender = NULL;
    BOOL                 fCaptureAEC = FALSE;
    BOOL                 fRenderAEC = FALSE;

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAEC - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( pbEnabled, sizeof(VARIANT_BOOL) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAEC - "
                            "bad VARIANT_BOOL pointer"));

        return E_POINTER;
    }

    //
    // Get the IRTCTerminalManage interface
    //

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTerminalManage,
                           (void **)&pTerminalManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAEC - "
                            "QI(TerminalManage) failed 0x%lx", hr));

        return hr;
    }

    //
    // Get the terminals
    //

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            RTC_MD_RENDER,                                            
                            &pRender
                            );    

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAEC - "
                            "GetDefaultTerminal(Render) failed 0x%lx", hr));

        pTerminalManage->Release();
        pTerminalManage = NULL;

        return hr;
    }

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_AUDIO,
                            RTC_MD_CAPTURE,                                            
                            &pCapture
                            );
    
    pTerminalManage->Release();
    pTerminalManage = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAEC - "
                            "GetDefaultTerminal(Capture) failed 0x%lx", hr));

        if (pRender != NULL)
        {
            pRender->Release();
            pRender = NULL;
        }

        return hr;
    }

    //
    // Get the IRTCTuningManage interface
    //

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTuningManage,
                           (void **)&pTuningManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAEC - "
                            "QI(TuningManage) failed 0x%lx", hr));

        if (pRender != NULL)
        {
            pRender->Release();
            pRender = NULL;
        }

        if (pCapture != NULL)
        {
            pCapture->Release();
            pCapture = NULL;
        }

        return hr;
    }

    //
    // Is AEC enabled?
    //

    if (pCapture != NULL && pRender != NULL)
    {
        hr = pTuningManage->IsAECEnabled(pCapture, pRender, &fCaptureAEC);

        fRenderAEC = fCaptureAEC;
    }

    //
    // release interface ptr
    //

    if (pCapture != NULL)
    {
        pCapture->Release();
        pCapture = NULL;
    }

    if (pRender != NULL)
    {
        pRender->Release();
        pRender = NULL;
    }

    pTuningManage->Release();
    pTuningManage = NULL;

    //
    // check result
    //

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredAEC - "
                            "IsAECEnabled failed 0x%lx", hr));

        return hr;
    }

    *pbEnabled = ( fRenderAEC && fCaptureAEC ) ? VARIANT_TRUE : VARIANT_FALSE;

    LOG((RTC_TRACE, "CRTCClient::get_PreferredAEC - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::put_PreferredVideoDevice
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::put_PreferredVideoDevice(
        BSTR  bstrDeviceName
        )
{
    LOG((RTC_TRACE, "CRTCClient::put_PreferredVideoDevice - enter"));

    HRESULT hr;    

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredVideoDevice - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadStringPtrW( bstrDeviceName, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredVideoDevice - "
                            "bad string pointer"));

        return E_POINTER;
    }

    //
    // Get the IRTCTerminalManage interface
    //

    IRTCTerminalManage * pTerminalManage = NULL;

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTerminalManage,
                           (void **)&pTerminalManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredVideoDevice - "
                            "QI(TerminalManage) failed 0x%lx", hr));

        return hr;
    }

    //
    // Get the old terminal
    //

    IRTCTerminal * pOldTerminal = NULL;

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_VIDEO,
                            RTC_MD_CAPTURE,                                            
                            &pOldTerminal
                            );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredVideoDevice - "
                            "GetDefaultTerminal failed 0x%lx", hr));

        pTerminalManage->Release();
        pTerminalManage = NULL;

        return hr;
    }

    //
    // Get the terminal list
    //

    IRTCTerminal ** ppTerminals = NULL;
    DWORD dwCount = 0;

    hr = GetTerminalList( pTerminalManage, &ppTerminals, &dwCount );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredVideoDevice - "
                            "GetTerminalList failed 0x%lx", hr));

        if (pOldTerminal != NULL)
        {
            pOldTerminal->Release();
            pOldTerminal = NULL;
        }

        pTerminalManage->Release();
        pTerminalManage = NULL;

        return hr;
    }

    RTC_MEDIA_TYPE mt;
    RTC_MEDIA_DIRECTION md;
    WCHAR * szDescription;
    BOOL bFound = FALSE;

    for ( DWORD dw=0; (dw < dwCount) && !bFound; dw++ )
    {
        //
        // Get terminal media type, direction, and description
        //

        ppTerminals[dw]->GetMediaType( &mt );
        ppTerminals[dw]->GetDirection( &md );
        
        hr = ppTerminals[dw]->GetDescription( &szDescription );       

        if ( SUCCEEDED(hr) )
        {
            //
            // Is this terminal one which we want to select?
            //

            BOOL fSelect = FALSE;

            if ( mt == RTC_MT_VIDEO )
            {
                if ( md == RTC_MD_CAPTURE )
                {
                    if ( wcscmp( bstrDeviceName, szDescription ) == 0 )
                    {
                        if ( ppTerminals[dw] == pOldTerminal )
                        {
                            LOG((RTC_INFO, "CRTCClient::put_PreferredVideoDevice - "
                                    "terminal already selected"));
                        }
                        else
                        {
                            LOG((RTC_INFO, "CRTCClient::put_PreferredVideoDevice - "
                                    "selecting a terminal"));

                            hr = pTerminalManage->SetDefaultStaticTerminal( mt, md, ppTerminals[dw] );

                            if ( FAILED(hr) )
                            {
                                LOG((RTC_ERROR, "CRTCClient::put_PreferredVideoDevice - "
                                                    "SetDefaultStaticTerminal failed 0x%lx", hr));
                            }
                            else
                            {
                                //
                                // Mark our cached media capabilities as invalid
                                //

                                m_fMediaCapsCached = FALSE;

                                m_fVideoCaptureDisabled = FALSE;

                                //
                                // Save the settings
                                //

                                hr = StoreDefaultTerminals();

                                if ( FAILED(hr) )
                                {
                                    LOG((RTC_ERROR, "CRTCClient::put_PreferredVideoDevice - "
                                                "StoreDefaultTerminals failed 0x%lx", hr));
                                }

                                //
                                // Send an event
                                //

                                CRTCClientEvent::FireEvent(this, RTCCET_DEVICE_CHANGE);
                            }
                        }

                        bFound = TRUE;
                    }
                }
            }

            //
            // Free the description
            //

            ppTerminals[dw]->FreeDescription( szDescription );    
        }
    }

    FreeTerminalList( ppTerminals, dwCount );
    ppTerminals = NULL;

    if (pOldTerminal != NULL)
    {
        pOldTerminal->Release();
        pOldTerminal = NULL;
    }

    pTerminalManage->Release();
    pTerminalManage = NULL;

    if ( !bFound )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PreferredVideoDevice - "
                "terminal was not found"));

        return E_INVALIDARG;
    }

    LOG((RTC_TRACE, "CRTCClient::put_PreferredVideoDevice - exit 0x%lx"));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_PreferredVideoDevice
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_PreferredVideoDevice(
        BSTR * pbstrDeviceName
        )
{
    LOG((RTC_TRACE, "CRTCClient::get_PreferredVideoDevice - enter"));

    IRTCTerminalManage * pTerminalManage = NULL;
    IRTCTerminal       * pTerminal = NULL;
    HRESULT              hr;

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredVideoDevice - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( pbstrDeviceName, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredVideoDevice - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    //
    // Get the IRTCTerminalManage interface
    //

    hr = m_pMediaManage->QueryInterface(
                           IID_IRTCTerminalManage,
                           (void **)&pTerminalManage
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredVideoDevice - "
                            "QI(TerminalManage) failed 0x%lx", hr));

        return hr;
    }

    //
    // Get the terminal
    //

    hr = pTerminalManage->GetDefaultTerminal(
                            RTC_MT_VIDEO,
                            RTC_MD_CAPTURE,                                            
                            &pTerminal
                            );

    pTerminalManage->Release();
    pTerminalManage = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredVideoDevice - "
                            "GetDefaultTerminal failed 0x%lx", hr));

        return hr;
    }

    if ( pTerminal == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredVideoDevice - "
                        "NULL terminal"));

        return RTC_E_NO_DEVICE;
    }

    //
    // Get the description
    //

    WCHAR * szDescription = NULL;

    hr = pTerminal->GetDescription(
                       &szDescription
                      );
   
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredVideoDevice - "
                            "GetDescription failed 0x%lx", hr));     

        pTerminal->Release();
        pTerminal = NULL;

        return hr;
    }

    *pbstrDeviceName = SysAllocString( szDescription );

    pTerminal->FreeDescription( szDescription );
    szDescription = NULL;

    pTerminal->Release();
    pTerminal = NULL;

    if ( *pbstrDeviceName == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PreferredVideoDevice - "
                            "out of memory")); 
        
        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCClient::get_PreferredVideoDevice - exit S_OK"));

    return S_OK;
}

          
/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_ActiveMedia
//
// This is a method that will return the media types for which
// streams currently exist.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_ActiveMedia(
        long * plMediaTypes
        )
{
    LOG((RTC_TRACE, "CRTCClient::get_ActiveMedia - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_ActiveMedia - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( plMediaTypes, sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_ActiveMedia - "
                            "bad long pointer"));

        return E_POINTER;
    }

    *plMediaTypes = m_lActiveMedia;

    LOG((RTC_TRACE, "CRTCClient::get_ActiveMedia - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_MaxBitrate
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_MaxBitrate(
        long * plMaxBitrate
        )
{
    HRESULT     hr;

    LOG((RTC_TRACE, "CRTCClient::get_MaxBitrate - enter"));
    
    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_MaxBitrate - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadWritePtr( plMaxBitrate, sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_MaxBitrate - "
                            "bad long pointer"));

        return E_POINTER;
    }

    DWORD   dwMaxBitrate;

    hr = m_pMediaManage->GetMaxBitrate(&dwMaxBitrate);
    
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCClient::get_MaxBitrate - "
            "GetMaxBitrate with error 0x%x", hr));

        return hr;
    }

    *plMaxBitrate = (long)dwMaxBitrate;

    LOG((RTC_TRACE, "CRTCClient::get_MaxBitrate - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::put_MaxBitrate
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::put_MaxBitrate(
        long lMaxBitrate
        )
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "CRTCClient::put_MaxBitrate - enter"));
    
    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::put_MaxBitrate - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    // valid range 0-1000000
    if(lMaxBitrate<0 || lMaxBitrate>1000000)
    {
        LOG((RTC_ERROR, "CRTCClient::put_MaxBitrate - "
            "Value not in range"));

        return E_INVALIDARG;
    }

    hr = m_pMediaManage->SetMaxBitrate((DWORD)lMaxBitrate);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCClient::put_MaxBitrate - "
            "SetMaxBitrate with error 0x%x", hr));

        return hr;
    }

    LOG((RTC_TRACE, "CRTCClient::put_MaxBitrate - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_TemporalSpatialTradeOff
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_TemporalSpatialTradeOff(
        long * plValue
        )
{
    HRESULT     hr;

    LOG((RTC_TRACE, "CRTCClient::get_TemporalSpatialTradeOff - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_TemporalSpatialTradeOff - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadWritePtr( plValue, sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_TemporalSpatialTradeOff - "
                            "bad long pointer"));

        return E_POINTER;
    }

    DWORD   dwValue;

    hr = m_pMediaManage->GetTemporalSpatialTradeOff(&dwValue);
    
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCClient::get_TemporalSpatialTradeOff - "
            "GetTemporalSpatialTradeOff with error 0x%x", hr));

        return hr;
    }

    *plValue = (long)dwValue;

    LOG((RTC_TRACE, "CRTCClient::get_TemporalSpatialTradeOff - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::put_TemporalSpatialTradeOff
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::put_TemporalSpatialTradeOff(
        long lValue
        )
{
    HRESULT    hr;
    
    LOG((RTC_TRACE, "CRTCClient::put_TemporalSpatialTradeOff - enter"));
    
    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::put_TemporalSpatialTradeOff - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    // valid range 0-255
    if(lValue<0 || lValue>255)
    {
        LOG((RTC_ERROR, "CRTCClient::put_TemporalSpatialTradeOff - "
            "Value not in range"));

        return E_INVALIDARG;
    }

    hr = m_pMediaManage->SetTemporalSpatialTradeOff((DWORD)lValue);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCClient::put_TemporalSpatialTradeOff - "
            "SetTemporalSpatialTradeOff with error 0x%x", hr));

        return hr;
    }

    LOG((RTC_TRACE, "CRTCClient::put_TemporalSpatialTradeOff - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::OnDTMFTimer
//
/////////////////////////////////////////////////////////////////////////////
void
CRTCClient::OnDTMFTimer()
{
    LOG((RTC_TRACE, "CRTCClient::OnDTMFTimer - enter"));

    HRESULT hr;

    LOG((RTC_INFO, "CRTCClient::OnDTMFTimer - packets to send %d",
            m_lInprogressDTMFPacketsToSend));

    if ( m_lInprogressDTMFPacketsToSend > 1 )
    {        
        hr = m_pMediaManage->SendDTMFEvent(
                        m_dwDTMFToneID,
                        (DWORD) m_enInprogressDTMF,
                        10, // volume
                        20,
                        FALSE
                        );
       
        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::OnDTMFTimer - "
                                "SendDTMFEvent failed 0x%lx", hr));
        }
    }
    else
    {
        //
        // Kill the timer
        //

        KillTimer(m_hWnd, TID_DTMF_TIMER);

        //
        // Send the final packet
        //

        for (int i=0; i<3; i++)
        {
            hr = m_pMediaManage->SendDTMFEvent(
                            m_dwDTMFToneID,
                            (DWORD) m_enInprogressDTMF,
                            10, // volume
                            20,
                            TRUE
                            );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::OnDTMFTimer - "
                                    "SendDTMFEvent failed 0x%lx", hr));
            }
        }
    } 
    
    m_lInprogressDTMFPacketsToSend--;

    LOG((RTC_TRACE, "CRTCClient::OnDTMFTimer - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::SendDTMF
//
// This is an IRTCClient method that will send a DTMF to the active session
// and play a feedback tone using the wave player.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::SendDTMF(
        RTC_DTMF enDTMF
        )
{
    LOG((RTC_TRACE, "CRTCClient::SendDTMF - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::SendDTMF - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    HRESULT hr;

    if ( !((enDTMF >= RTC_DTMF_0) && (enDTMF <= RTC_DTMF_FLASH)) )
    {
        LOG((RTC_ERROR, "CRTCClient::SendDTMF - "
                            "invalid DTMF argument"));

        return E_INVALIDARG;
    }

    if ( m_pMediaManage != NULL )
    {
        hr = m_pMediaManage->IsOutOfBandDTMFEnabled();

        if ( hr == S_OK )
        {
            //
            // For out of band DTMF we need to send 10 DTMF packets of 20ms length
            //

            if ( m_lInprogressDTMFPacketsToSend != 0 )
            {
                //
                // We have an existing DTMF in progress. We must end it now.
                //

                KillTimer(m_hWnd, TID_DTMF_TIMER);

                m_lInprogressDTMFPacketsToSend = 0;

                for (int i=0; i<3; i++)
                {
                    hr = m_pMediaManage->SendDTMFEvent(
                            m_dwDTMFToneID,
                            (DWORD) m_enInprogressDTMF,
                            10, // volume
                            20,
                            TRUE
                            );

                    if ( FAILED(hr) )
                    {
                        LOG((RTC_ERROR, "CRTCClient::SendDTMF - "
                                            "SendDTMFEvent failed 0x%lx", hr));

                        return hr;
                    }
                }
            }

            //
            // Start the DTMF timer
            //
           
            DWORD dwID = (DWORD)SetTimer(m_hWnd, TID_DTMF_TIMER, 20, NULL);
            if (dwID==0)
            {                
                hr = HRESULT_FROM_WIN32(GetLastError());

                LOG((RTC_ERROR, "CRTCClient::SendDTMF - "
                               "SetTimer failed 0x%lx", hr));

                return hr;
            } 

            //
            // Send the first DTMF packet
            //             
            m_dwDTMFToneID ++;

            hr = m_pMediaManage->SendDTMFEvent(
                        m_dwDTMFToneID,
                        (DWORD) enDTMF,
                        10, // volume
                        20,
                        FALSE
                        );

            if ( FAILED(hr) )
            {               
                LOG((RTC_ERROR, "CRTCClient::SendDTMF - "
                                    "SendDTMFEvent failed 0x%lx", hr));

                return hr;
            }

            m_lInprogressDTMFPacketsToSend = 9;
            m_enInprogressDTMF = enDTMF;
        }
        else if ( hr == S_FALSE )
        {
            hr = m_pMediaManage->SendDTMFEvent(
                        m_dwDTMFToneID,
                        (DWORD) enDTMF,
                        10, // volume
                        100,
                        TRUE
                        );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::SendDTMF - "
                                    "SendDTMFEvent failed 0x%lx", hr));

                return hr;
            }
        }
        else
        {
            LOG((RTC_ERROR, "CRTCClient::SendDTMF - "
                                "IsOutOfBandDTMFEnabled failed 0x%lx", hr));

            return hr;
        }        
    }

    if ( !m_bCaptureDeviceMuted &&
         (enDTMF >= RTC_DTMF_0) && (enDTMF <= RTC_DTMF_D) )
    {
        //
        // We can play a feedback tone
        //

        if (m_pWavePlayerRenderTerminal != NULL)
        {
            hr = S_OK;

            if ( !m_pWavePlayerRenderTerminal->IsWaveDeviceOpen() )
            {
                IRTCAudioConfigure * pAudioCfg;

                hr = GetAudioCfg(
                         RTCAD_SPEAKER,
                         &pAudioCfg
                        );

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCClient::SendDTMF - "
                                        "GetAudioCfg(Render) failed 0x%lx", hr));     
                }
                else
                {
                    UINT uiWaveID;

                    hr = pAudioCfg->GetWaveID( &uiWaveID );

                    pAudioCfg->Release();
                    pAudioCfg = NULL;

                    if ( FAILED(hr) )
                    {
                        LOG((RTC_ERROR, "CRTCClient::SendDTMF - "
                                            "GetWaveID failed 0x%lx", hr));     
                    }
                    else
                    {
                        hr = m_pWavePlayerRenderTerminal->OpenWaveDevice(uiWaveID);

                        if ( FAILED(hr) )
                        {
                            LOG((RTC_ERROR, "CRTCClient::SendDTMF - "
                                                    "OpenWaveDevice failed 0x%lx", hr));
                        }
                    }
                }
            }

            if ( SUCCEEDED(hr) )
            {
                hr = m_pWavePlayerRenderTerminal->PlayWave( WAVE_TONE );   

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCClient::SendDTMF - "
                                        "PlayWave failed 0x%lx", hr));
                }
            }
        }
    }

    LOG((RTC_TRACE, "CRTCClient::SendDTMF - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::PlayRing
//
// This is an IRTCClient method that will play a ring using the wave player.
//
//  bPlay == VARIANT_TRUE   --> Plays a ring
//  bPlay == VARIANT_FALSE  --> Stops any playing
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::PlayRing(RTC_RING_TYPE enType, VARIANT_BOOL bPlay)
{
    LOG((RTC_TRACE, "CRTCClient::Ring - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::Ring - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    HRESULT hr;

    switch (enType)
    {
    case RTCRT_PHONE:
    case RTCRT_MESSAGE:
        if (m_pWavePlayerSystemDefault == NULL)
        {
            LOG((RTC_ERROR, "CRTCClient::Ring - "
                                "wave player not created"));

            return E_FAIL;
        }

        if (bPlay)
        {
            if ( !m_pWavePlayerSystemDefault->IsWaveDeviceOpen() )
            {
                hr = m_pWavePlayerSystemDefault->OpenWaveDevice(WAVE_MAPPER);

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCClient::Ring - "
                                            "OpenWaveDevice failed 0x%lx", hr));

                    return hr;
                }
            } 
        }
        break;

    case RTCRT_RINGBACK:
        if (m_pWavePlayerRenderTerminal == NULL)
        {
            LOG((RTC_ERROR, "CRTCClient::Ring - "
                                "wave player not created"));

            return E_FAIL;
        }

        if (bPlay)
        {
            if ( !m_pWavePlayerRenderTerminal->IsWaveDeviceOpen() )
            {
                hr = m_pWavePlayerRenderTerminal->OpenWaveDevice(WAVE_MAPPER);

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCClient::Ring - "
                                            "OpenWaveDevice failed 0x%lx", hr));

                    return hr;
                }
            } 
        }
        break;

    default:
        LOG((RTC_ERROR, "CRTCClient::Ring - "
                            "invalid ring type"));

        return E_INVALIDARG;
    }

    if (bPlay)
    {
        switch (enType)
        {
        case RTCRT_PHONE:            
            hr = m_pWavePlayerSystemDefault->PlayWave( WAVE_RING );   
            break;

        case RTCRT_MESSAGE:
            hr = m_pWavePlayerSystemDefault->PlayWave( WAVE_MESSAGE );
            break;

        case RTCRT_RINGBACK:           
            hr = m_pWavePlayerRenderTerminal->PlayWave( WAVE_RINGBACK );   
            break;
        }

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::Ring - "
                                "PlayWave failed 0x%lx", hr));

            return hr;
        }
    }
    else
    {
        switch (enType)
        {
        case RTCRT_PHONE:
        case RTCRT_MESSAGE:
            hr = m_pWavePlayerSystemDefault->StopWave();
            break;

        case RTCRT_RINGBACK:
            hr = m_pWavePlayerRenderTerminal->StopWave();
            break;
        }

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::Ring - "
                                "StopWave failed 0x%lx", hr));

            return hr;
        }
    }

    LOG((RTC_TRACE, "CRTCClient::Ring - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::FireEvent
//
// This is a public helper method the fire events.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::FireEvent(   
             RTC_EVENT   enEvent,
             IDispatch  * pDispatch
            )
{
    HRESULT                   hr;

    //LOG((RTC_TRACE, "CRTCClient::FireEvent - enter"));

    //
    // Filter events
    //

    switch ( enEvent )
    {
    case RTCE_CLIENT:
        if ( !(m_lEventFilter & RTCEF_CLIENT) )
        {
            return S_FALSE;
        }
        break;

    case RTCE_REGISTRATION_STATE_CHANGE:
        if ( !(m_lEventFilter & RTCEF_REGISTRATION_STATE_CHANGE) )
        {
            return S_FALSE;
        }
        break;

    case RTCE_SESSION_STATE_CHANGE:
        if ( !(m_lEventFilter & RTCEF_SESSION_STATE_CHANGE) )
        {
            return S_FALSE;
        }
        break;

    case RTCE_SESSION_OPERATION_COMPLETE:
        if ( !(m_lEventFilter & RTCEF_SESSION_OPERATION_COMPLETE) )
        {
            return S_FALSE;
        }
        break;

    case RTCE_PARTICIPANT_STATE_CHANGE:
        if ( !(m_lEventFilter & RTCEF_PARTICIPANT_STATE_CHANGE) )
        {
            return S_FALSE;
        }
        break;

    case RTCE_MEDIA:
        if ( !(m_lEventFilter & RTCEF_MEDIA) )
        {
            return S_FALSE;
        }
        break;

    case RTCE_INTENSITY:
        if ( !(m_lEventFilter & RTCEF_INTENSITY) )
        {
            return S_FALSE;
        }
        break;

    case RTCE_MESSAGING:
        if ( !(m_lEventFilter & RTCEF_MESSAGING) )
        {
            return S_FALSE;
        }
        break;

    case RTCE_BUDDY:
        if ( !(m_lEventFilter & RTCEF_BUDDY) )
        {
            return S_FALSE;
        }
        break;

    case RTCE_WATCHER:
        if ( !(m_lEventFilter & RTCEF_WATCHER) )
        {
            return S_FALSE;
        }
        break;

    case RTCE_PROFILE:
        if ( !(m_lEventFilter & RTCEF_PROFILE) )
        {
            return S_FALSE;
        }
        break;

    default:
        return E_INVALIDARG;
    }

    //
    // Do the event callbacks
    //
    
    _FireEvent( enEvent, pDispatch );
    _FireDispatchEvent( enEvent, pDispatch );

    //LOG((RTC_TRACE, "CRTCClient::FireEvent - exit"));

    return S_OK;
}          

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::NotifyIPAddrChange
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::NotifyIPAddrChange()
{
    LOG((RTC_TRACE, "CRTCClient::NotifyIPAddrChange - enter"));

    RefreshPresenceSessions(TRUE);

#ifdef DUMP_PRESENCE
    DumpWatchers("CHANGE IP");
#endif

    LOG((RTC_TRACE, "CRTCClient::NotifyIPAddrChange - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::NotifyRegisterRedirect
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::NotifyRegisterRedirect( 
    SIP_PROVIDER_ID     *pSipProviderID,
    ISipRedirectContext *pRegisterContext,
    SIP_CALL_STATUS     *pRegisterStatus
    )
{
    LOG((RTC_TRACE, "CRTCClient::NotifyRegisterRedirect - enter"));

    //
    // Find the profile
    //

    HRESULT       hr;
    CRTCProfile * pCProfile = NULL;
    BOOL          fFound = FALSE;

    for ( int n=0; n < m_ProfileArray.GetSize(); n++ )
    {   
        GUID ProfileGuid; 

        pCProfile = static_cast<CRTCProfile *>(m_ProfileArray[n]);
                      
        pCProfile->GetGuid( &ProfileGuid );

        if ( IsEqualGUID( *pSipProviderID, ProfileGuid ) )
        {
            LOG((RTC_INFO, "CRTCClient::NotifyRegisterRedirect - "
                            "found profile [%p]", pCProfile));

            fFound = TRUE;

            break;
        }
    }

    if ( !fFound )
    {
        LOG((RTC_ERROR, "CRTCClient::NotifyRegisterRedirect - "
                                "profile not found"));

        return RTC_E_NO_PROFILE;
    }   

    hr = pCProfile->Redirect( pRegisterContext );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::NotifyRegisterRedirect - "
                            "Redirect failed 0x%lx", hr));

        return hr;
    }      

    LOG((RTC_TRACE, "CRTCClient::NotifyRegisterRedirect - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::NotifyProviderStatusChange
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::NotifyProviderStatusChange(
        SIP_PROVIDER_STATUS * ProviderStatus
        )
{
    LOG((RTC_TRACE, "CRTCClient::NotifyProviderStatusChange - enter"));      

    HRESULT       hr = S_OK;
    CRTCProfile * pCProfile = NULL;
    BOOL          fFound = FALSE;

    for ( int n=0; n < m_HiddenProfileArray.GetSize(); n++ )
    {        
        GUID ProfileGuid; 

        pCProfile = static_cast<CRTCProfile *>(m_HiddenProfileArray[n]);
                      
        pCProfile->GetGuid( &ProfileGuid );

        if ( IsEqualGUID( ProviderStatus->ProviderID, ProfileGuid ) )
        {
            LOG((RTC_INFO, "CRTCClient::NotifyProviderStatusChange - "
                            "found hidden profile [%p]", pCProfile));

            fFound = TRUE;

            break;
        }
    }

    if ( !fFound )
    {
        for ( int n=0; n < m_ProfileArray.GetSize(); n++ )
        {        
            GUID ProfileGuid; 

            pCProfile = static_cast<CRTCProfile *>(m_ProfileArray[n]);
                      
            pCProfile->GetGuid( &ProfileGuid );

            if ( IsEqualGUID( ProviderStatus->ProviderID, ProfileGuid ) )
            {
                LOG((RTC_INFO, "CRTCClient::NotifyProviderStatusChange - "
                                "found profile [%p]", pCProfile));

                fFound = TRUE;

                break;
            }
        }
    }

    if ( !fFound )
    {
        LOG((RTC_ERROR, "CRTCClient::NotifyProviderStatusChange - "
                                "profile not found"));

        return RTC_E_NO_PROFILE;
    }       

    pCProfile->AddRef();

    switch( ProviderStatus->RegisterState )
    {
    case REGISTER_STATE_NONE:
        LOG((RTC_INFO, "CRTCClient::NotifyProviderStatusChange - "
                                "REGISTER_STATE_NONE"));

        break;

    case REGISTER_STATE_REGISTERED:
        LOG((RTC_INFO, "CRTCClient::NotifyProviderStatusChange - "
                                "REGISTER_STATE_REGISTERED"));

        hr = pCProfile->SetState( RTCRS_REGISTERED,
                                  ProviderStatus->Status.StatusCode,
                                  ProviderStatus->Status.StatusText );

        break;

    case REGISTER_STATE_UNREGISTERING:
        LOG((RTC_INFO, "CRTCClient::NotifyProviderStatusChange - "
                                "REGISTER_STATE_UNREGISTERING"));       

        hr = pCProfile->SetState( RTCRS_UNREGISTERING,
                                  ProviderStatus->Status.StatusCode,
                                  ProviderStatus->Status.StatusText );

        break;

    case REGISTER_STATE_UNREGISTERED:
        LOG((RTC_INFO, "CRTCClient::NotifyProviderStatusChange - "
                                "REGISTER_STATE_UNREGISTERED"));

        hr = pCProfile->SetState( RTCRS_NOT_REGISTERED,
                                  ProviderStatus->Status.StatusCode,
                                  ProviderStatus->Status.StatusText );
        
        break;

    case REGISTER_STATE_REGISTERING:
        LOG((RTC_INFO, "CRTCClient::NotifyProviderStatusChange - "
                                "REGISTER_STATE_REGISTERING"));

        hr = pCProfile->SetState( RTCRS_REGISTERING, 
                                  ProviderStatus->Status.StatusCode,
                                  ProviderStatus->Status.StatusText );

        break;        

    case REGISTER_STATE_REJECTED:
        LOG((RTC_INFO, "CRTCClient::NotifyProviderStatusChange - "
                                "REGISTER_STATE_REJECTED"));

        hr = pCProfile->SetState( RTCRS_REJECTED, 
                                  ProviderStatus->Status.StatusCode,
                                  ProviderStatus->Status.StatusText );

        break;

    case REGISTER_STATE_ERROR:
        LOG((RTC_INFO, "CRTCClient::NotifyProviderStatusChange - "
                                "REGISTER_STATE_ERROR"));

        hr = pCProfile->SetState( RTCRS_ERROR, 
                                  ProviderStatus->Status.StatusCode,
                                  ProviderStatus->Status.StatusText );

        break;

    case REGISTER_STATE_DEREGISTERED:
        LOG((RTC_INFO, "CRTCClient::NotifyProviderStatusChange - "
                                "REGISTER_STATE_DEREGISTERED"));

        hr = pCProfile->SetState( RTCRS_LOGGED_OFF,
                                  ProviderStatus->Status.StatusCode,
                                  ProviderStatus->Status.StatusText );
        break;

    case REGISTER_STATE_DROPSUB:
        LOG((RTC_INFO, "CRTCClient::NotifyProviderStatusChange - "
                                "REGISTER_STATE_DROPSUB"));

        hr = pCProfile->SetState( RTCRS_LOCAL_PA_LOGGED_OFF,
                                  ProviderStatus->Status.StatusCode,
                                  ProviderStatus->Status.StatusText );

        break;

    case REGISTER_STATE_PALOGGEDOFF:
        LOG((RTC_INFO, "CRTCClient::NotifyProviderStatusChange - "
                                "REGISTER_STATE_PALOGGEDOFF"));

        hr = pCProfile->SetState( RTCRS_REMOTE_PA_LOGGED_OFF,
                                  ProviderStatus->Status.StatusCode,
                                  ProviderStatus->Status.StatusText );
        
        break;

    default:
        LOG((RTC_ERROR, "CRTCClient::NotifyProviderStatusChange - "
                    "invalid REGISTER_STATE"));
    
        pCProfile->Release();
        return E_FAIL;
    }
    
    pCProfile->Release();
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::NotifyProviderStatusChange - "
                            "SetState failed 0x%lx", hr));

        return hr;
    } 

    LOG((RTC_TRACE, "CRTCClient::NotifyProviderStatusChange - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::OfferCall
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCClient::OfferCall(
        ISipCall       * Call,
        SIP_PARTY_INFO * CallerInfo
        )
{
    LOG((RTC_TRACE, "CRTCClient::OfferCall - enter"));

    HRESULT hr;

    //
    // Verify whether the incoming call is authorized
    //
    if(!IsIncomingSessionAuthorized(CallerInfo->URI))
    {
        hr = Call->Reject( 480 );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::OfferCall - "
                "Reject failed 0x%lx", hr));
    
            return hr;
        }

        return S_OK;
    }

    //
    // Create the session
    //

    IRTCSession * pSession = NULL;
    
    hr = InternalCreateSession( 
                               &pSession
                              );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::OfferCall - "
                            "InternalCreateSession failed 0x%lx", hr));
    
        return hr;
    }   
    
    //
    // Initialize the session
    //

    CRTCSession * pCSession = NULL;

    pCSession = static_cast<CRTCSession *>(pSession);
    
    hr = pCSession->InitializeIncoming(
                               this,                            
                               Call,                            
                               CallerInfo
                              );
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::OfferCall - "
                            "Initialize failed 0x%lx", hr));

        
        pSession->Release();        
        
        return hr;
    }  
   
    // Release the pointer, don't need it any more
    pSession -> Release();

    LOG((RTC_TRACE, "CRTCClient::OfferCall - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::NotifyIncomingSession
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCClient::NotifyIncomingSession(
        IIMSession     * pIMSession,
        BSTR             msg,
        BSTR             ContentType,
        SIP_PARTY_INFO * CallerInfo
        )
{
    LOG((RTC_TRACE, "CRTCClient::NotifyIncomingSession - enter"));

    HRESULT hr;
    
    //
    // Create the session
    //

    IRTCSession * pSession = NULL;
    
    hr = InternalCreateSession( 
                               &pSession
                              );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::NotifyIncomingSession - "
                            "InternalCreateSession failed 0x%lx", hr));
    
        return hr;
    }   
    
    //
    // Initialize the session
    //

    CRTCSession * pCSession = NULL;

    pCSession = static_cast<CRTCSession *>(pSession);
    
    hr = pCSession->InitializeIncomingIM(
                               this,
                               m_pSipStack,
                               pIMSession,  
                               msg,
                               ContentType,
                               CallerInfo
                              );
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::NotifyIncomingSession - "
                            "Initialize failed 0x%lx", hr));

        
        pSession->Release();        
        
        return hr;
    }  
   
    // Release the pointer, don't need it any more
    pSession -> Release();

    LOG((RTC_TRACE, "CRTCClient::NotifyIncomingSession - exit S_OK"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::IsIMSessionAuthorized
//
// Called by SIP IM part before NotifyIncomingSession
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::IsIMSessionAuthorized(
    BSTR pszCallerURI,
    BOOL  * bAuthorized)
{
    LOG((RTC_TRACE, "CRTCClient::IsIMSessionAuthorized - enter"));

    *bAuthorized = IsIncomingSessionAuthorized(pszCallerURI);

    LOG((RTC_TRACE, "CRTCClient::IsIMSessionAuthorized - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::GetCredentialsFromUI
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::GetCredentialsFromUI(
    IN  SIP_PROVIDER_ID        *pProviderID,
    IN  BSTR               Realm,
    IN OUT BSTR           *Username,
    OUT BSTR              *Password        
    )
{
    LOG((RTC_TRACE, "CRTCSession::GetCredentialsFromUI - not implemented.."));

    // equivalent to selecting Cancel
    return E_ABORT;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::GetCredentialsForRealm
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::GetCredentialsForRealm(
    IN  BSTR                 Realm,
    OUT BSTR                *Username,
    OUT BSTR                *Password,
    OUT SIP_AUTH_PROTOCOL   *pAuthProtocol
    )
{
    LOG((RTC_TRACE, "CRTCClient::GetCredentialsForRealm - Enter"));

    //
    // Find the profile
    //

    HRESULT       hr;
    CRTCProfile * pCProfile = NULL;
    BOOL          fFound = FALSE;

    for ( int n=0; n < m_ProfileArray.GetSize(); n++ )
    {   
        BSTR bstrRealm;

        pCProfile = static_cast<CRTCProfile *>(m_ProfileArray[n]);
                      
        hr = pCProfile->GetRealm( &bstrRealm );

        if ( SUCCEEDED(hr) )
        {
            if ( _wcsicmp( Realm, bstrRealm ) == 0 )
            {
                LOG((RTC_INFO, "CRTCClient::GetCredentialsForRealm - "
                            "found profile [%p]", pCProfile));

                SysFreeString( bstrRealm );
                fFound = TRUE;

                break;
            }

            SysFreeString( bstrRealm );
        }
    }

    if ( !fFound )
    {
        LOG((RTC_ERROR, "CRTCClient::GetCredentialsForRealm - "
                                "profile not found"));

        return RTC_E_NO_PROFILE;
    }      

    hr = pCProfile->GetCredentials( Username, Password, pAuthProtocol );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::GetCredentialsForRealm - "
                            "GetCredentials failed 0x%lx", hr));

        return hr;
    } 

    LOG((RTC_TRACE, "CRTCClient::GetCredentialsForRealm - Exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::OfferWatcher
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCClient::OfferWatcher(
        ISIPWatcher    * Watcher,
        SIP_PARTY_INFO * CallerInfo
        )
{
    HRESULT     hr;

    LOG((RTC_TRACE, "CRTCClient::OfferWatcher - enter"));
   
    if(!m_pSipWatcherManager)
    {
        // watchers are not enabled.
        // simply ignore the notification...
        LOG((RTC_WARN, "CRTCClient::OfferWatcher - watchers not expected, exiting..."));

        // should I put an error here ?
        return S_OK;
    }

    //
    // Search for this watcher in the internal list
    // 

    IRTCWatcher * pWatcher = NULL;

    hr = FindWatcherByURI(
        CallerInfo->URI,
        FALSE,
        &pWatcher);


    // There are two cases:
    //
    //   A. A watcher object is not found 
    //      
    //      A new CRTCWatcher is created (or reused from the hidden list)
    //   and added to the array
    //     
    //      A.1 Prompt Mode == RTCOWM_OFFER_WATCHER_EVENT
    //            CRTCWatcher is set to RTCWS_OFFERING mode
    //            The offered SIP watcher is added to CRTCWatcher
    //            IRTCWatcherEvent event is fired
    //      
    //      A.2 Prompt Mode == RTCOWM_AUTOMATICALLY_ADD_WATCHER
    //            CRTCWatcher is set to RTCWS_ALLOWED mode
    //            Any other SIP watcher is set to WATCHER_UNBLOCKED (very important !)
    //            The offered SIP watcher is added to CRTCWatcher and approved
    //
    //   B. A watcher object is found
    //            
    //      B.1 CRTCWatcher state == RTCWS_OFFERING
    //            The offered SIP watcher is added to CRTCWatcher.
    //
    //      B.2 CRTCWatcher state == RTCWS_ALLOWED
    //            The offered SIP watcher is added to CRTCWatcher and approved
    //  
    //      B.3 CRTCWatcher state == RTCWS_BLOCKED
    //            The offered SIP watcher is added to CRTCWatcher and rejected
    //
    
    if(hr != S_OK)
    {
        //
        // Create a watcher object
        //  This helper function also knows how to reuse a watcher from the hidden list    
        //

        hr = InternalCreateWatcher(
            CallerInfo->URI,
            CallerInfo->DisplayName,
            NULL,
            NULL,
            TRUE,   // persistent by default
            &pWatcher);

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCClient::OfferWatcher - InternalCreateWatcher failed 0x%lx", hr));

            return hr;
        }
        
        //
        // Add it to the array
        //
        
        BOOL fResult;

        fResult = m_WatcherArray.Add(pWatcher);

        if ( fResult == FALSE )
        {
            LOG((RTC_ERROR, "CRTCClient::OfferWatcher - "
                                    "out of memory"));
    
            pWatcher->Release();
            return E_OUTOFMEMORY;
        }
 
        //
        // Set the SIP Watcher
        //
        CRTCWatcher *pCWatcher = static_cast<CRTCWatcher *>(pWatcher);

        pCWatcher->m_bPersistent = TRUE;

        hr = pCWatcher->SetSIPWatcher(Watcher );

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCWatcher::OfferWatcher: "
                    "SetSIPWatcher failed: x%x.", hr));

            // if there's no SIP watcher in *pCWatcher, delete the entry
            if(pCWatcher->m_SIPWatchers.GetSize()==0)
            {
                m_WatcherArray.Remove(pWatcher);
            }

            pWatcher->Release();
            return hr;
        }

    
        if(m_nOfferWatcherMode == RTCOWM_OFFER_WATCHER_EVENT)
        {
            //
            // Set the watcher to OFFERING mode
            //
            pCWatcher->m_nState = RTCWS_OFFERING;

#ifdef DUMP_PRESENCE
            DumpWatchers("OFFER WATCHER (BLOCKING)");
#endif

            LOG((RTC_TRACE, "CRTCClient::OfferWatcher - firing event - may block for some time"));        

            CRTCWatcherEvent::FireEvent(this, pWatcher);

            hr = S_OK;
        }
        else
        {
            //
            // Set the watcher to ALLOWED mode
            //

            pCWatcher->m_nState = RTCWS_ALLOWED;

            //
            // Approve the offered watcher
            //
        
            hr = Watcher->ApproveSubscription(0);

            if(SUCCEEDED(hr))
            {
                //
                // Change the SIP watchers to ALLOWED status
                //  This updates all SIP watchers corresponding to 
                // the current core watcher
                //
                pCWatcher->ChangeBlockedStatus(WATCHER_UNBLOCKED);

                // update the storage
                UpdatePresenceStorage();
            }
            else
            {
                LOG((RTC_ERROR, "CRTCClient::OfferWatcher: "
                     "ApproveSubscription failed: x%x.", hr));
                
                // if there's no SIP watcher in *pCWatcher, delete the entry
                if(pCWatcher->m_SIPWatchers.GetSize()==0)
                {
                    m_WatcherArray.Remove(pWatcher);
                }

                pWatcher->Release();
                return hr;
            }
        }

        pWatcher->Release();
        pWatcher = NULL;
    }
    else
    {
        // found an entry the internal list
        
        CRTCWatcher *pCWatcher = static_cast<CRTCWatcher *>(pWatcher);

        //
        // Add the ISIPWatcher pointer to our watcher object
        //

        hr = pCWatcher->SetSIPWatcher(Watcher);

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCWatcher::OfferWatcher: "
                    "SetSIPWatcher failed: x%x.", hr));
        }

        pWatcher->Release();
        pWatcher = NULL;

        switch(pCWatcher->m_nState)
        {
        case RTCWS_OFFERING:
            // The UI is still displayed..
            //
            // We ignore this silently
        
            LOG((RTC_INFO, "CRTCClient::OfferWatcher - There's already an OFFERING watcher"));

            hr = S_OK;
            break;
        
        case RTCWS_BLOCKED:  
            
            LOG((RTC_INFO, "CRTCClient::OfferWatcher - automatically rejecting watcher"));
            
            hr = Watcher->RejectSubscription(REJECT_REASON_NONE);
             
            if(FAILED(hr))
            {
                LOG((RTC_ERROR, "CRTCWatcher::OfferWatcher: "
                        "RejectSubscription failed: x%x.", hr));
            }
            break;

        case RTCWS_ALLOWED:

            LOG((RTC_INFO, "CRTCClient::OfferWatcher - automatically approving watcher"));
        
            hr = Watcher->ApproveSubscription(0);

            if(FAILED(hr))
            {
                LOG((RTC_ERROR, "CRTCWatcher::put_State: "
                     "ApproveSubscription failed: x%x.", hr));
            }
            
            break;
        
        default:
            
            LOG((RTC_ERROR, "CRTCWatcher::OfferWatcher: "
                "Invalid watcher state, exiting"));

            hr = E_FAIL;
            break;
        }
    }

#ifdef DUMP_PRESENCE
    DumpWatchers("OFFER WATCHER");
#endif
    
    LOG((RTC_TRACE, "CRTCClient::OfferWatcher - exit S_OK"));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::WatcherOffline
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::WatcherOffline(
    ISIPWatcher    *pSipWatcher,
    WCHAR* pwstrPresentityURI
    )
{
    HRESULT     hr;

    LOG((RTC_TRACE, "CRTCClient::WatcherOffline - enter"));
    
    //
    // Search for this watcher in the internal list
    // 

    IRTCWatcher * pWatcher = NULL;

    hr = FindWatcherByURI(
        pwstrPresentityURI,
        FALSE,
        &pWatcher);

    if(hr == S_OK)
    {
        // found in the internal list
        
        CRTCWatcher *pCWatcher = static_cast<CRTCWatcher *>(pWatcher);

        pCWatcher->RemoveSIPWatcher(pSipWatcher, FALSE );

        pWatcher->Release();
        pWatcher = NULL;
    }
    else
    {
        // try the hidden list
        hr = FindWatcherByURI(
            pwstrPresentityURI,
            TRUE,
            &pWatcher);

        if(hr == S_OK)
        {

            CRTCWatcher *pCWatcher = static_cast<CRTCWatcher *>(pWatcher);

            pCWatcher->RemoveSIPWatcher(pSipWatcher, FALSE );
        
            //
            // Clean the hidden list of the entries without any SIP watcher
            //
            if(pCWatcher->m_SIPWatchers.GetSize() == 0)
            {
                m_HiddenWatcherArray.Remove(pWatcher);
            }

            pWatcher->Release();
            pWatcher = NULL;
        }
    }   

#ifdef DUMP_PRESENCE
    DumpWatchers("WATCHER OFFLINE");
#endif

    LOG((RTC_TRACE, "CRTCClient::WatcherOffline - exit"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::NotifyShutdownReady
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::NotifyShutdownReady()
{
    LOG((RTC_TRACE, "CRTCClient::NotifyShutdownReady - enter"));

    if ( m_enRtcState == RTC_STATE_PREPARING_SHUTDOWN3 )
    {
        InternalReadyForShutdown();
    }    

    LOG((RTC_TRACE, "CRTCClient::NotifyShutdownReady - exit"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::InternalCreateWatcher
//
/////////////////////////////////////////////////////////////////////////////
HRESULT
CRTCClient::InternalCreateWatcher(
            PCWSTR  szPresentityURI,
            PCWSTR  szUserName,
            PCWSTR  szData,
            PCWSTR  szShutdownBlob,
            BOOL    bPersistent,
            IRTCWatcher ** ppWatcher
            )
{
    HRESULT     hr;

    LOG((RTC_TRACE, "CRTCClient::InternalCreateWatcher - enter"));

    // try to reuse elements from the hidden list first hidden list
    IRTCWatcher * pWatcher = NULL;
    CComObject<CRTCWatcher> * pCWatcher;

    hr = FindWatcherByURI(
        szPresentityURI,
        TRUE,
        &pWatcher);

    if(hr == S_OK)
    {
        // reuse that entry
        pCWatcher = static_cast<CComObject<CRTCWatcher> *>(pWatcher);

        m_HiddenWatcherArray.Remove(pWatcher);
    }
    else
    {
        
        hr = CComObject<CRTCWatcher>::CreateInstance( &pCWatcher );

        if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
        {
            LOG((RTC_ERROR, "CRTCClient::InternalCreateWatcher - CreateInstance failed 0x%lx", hr));

            if ( hr == S_FALSE )
            {
                hr = E_FAIL;
            }
            return hr;
        }

        //
        // Get the IRTCWatcher interface
        //
 
        hr = pCWatcher->QueryInterface(
                               IID_IRTCWatcher,
                               (void **)&pWatcher
                              );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::InternalCreateWatcher - QI failed 0x%lx", hr));
        
            delete pCWatcher;
            return hr;
        }
    }

    //
    // Initialize the watcher
    //

    hr = pCWatcher->Initialize( 
        this,
        m_pSipWatcherManager,
        szPresentityURI,
        szUserName,
        szData,
        szShutdownBlob,
        bPersistent
        );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::InternalCreateWatcher - "
                                "Initialize failed 0x%lx", hr));

        pWatcher->Release();
        return hr;
    }

    *ppWatcher = pWatcher;

    LOG((RTC_TRACE, "CRTCClient::InternalCreateWatcher - enter"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::InternalCreateBuddy
//
/////////////////////////////////////////////////////////////////////////////
HRESULT
CRTCClient::InternalCreateBuddy(
            PCWSTR  szPresentityURI,
            PCWSTR  szUserName,
            PCWSTR  szData,
            BOOL    bPersistent,
            IRTCProfile * pProfile,
            long lFlags,
            IRTCBuddy ** ppBuddy
            )
{
    HRESULT     hr;

    LOG((RTC_TRACE, "CRTCClient::InternalCreateBuddy - enter"));

    CComObject<CRTCBuddy> * pCBuddy;
    hr = CComObject<CRTCBuddy>::CreateInstance( &pCBuddy );


    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCClient::InternalCreateBuddy - CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
        return hr;
    }

    //
    // Get the IRTCBuddy interface
    //

    IRTCBuddy * pBuddy = NULL;

    hr = pCBuddy->QueryInterface(
                           IID_IRTCBuddy,
                           (void **)&pBuddy
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::InternalCreateBuddy - QI failed 0x%lx", hr));
        
        delete pCBuddy;
        return hr;
    }

    //
    // Initialize the buddy
    //

    hr = pCBuddy->Initialize( 
        this,
        m_pSipBuddyManager,
        szPresentityURI,
        szUserName,
        szData,
        bPersistent,
        pProfile,
        lFlags
        );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::InternalCreateBuddy - "
                                "Initialize failed 0x%lx", hr));

        pBuddy->Release();
        return hr;
    }

    *ppBuddy = pBuddy;

    LOG((RTC_TRACE, "CRTCClient::InternalCreateBuddy - enter"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::FindWatcherByURI
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::FindWatcherByURI(
    IN  LPCWSTR                  lpwstrPresentityURI,
    IN  BOOL                    bHidden,
    OUT IRTCWatcher            **ppWatcher
    )
{
    INT             iIndex;
    IRTCWatcher    *pWatcher = NULL;
    
    if ( IsBadWritePtr( ppWatcher, sizeof(IRTCWatcher *) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::FindWatcherByURI - "
                            "bad IRTCWatcher* pointer"));

        return E_POINTER;
    } 

    *ppWatcher = NULL;

    CRTCObjectArray<IRTCWatcher *> *pArray = bHidden ? &m_HiddenWatcherArray : &m_WatcherArray;
    
    for( iIndex=0; iIndex < pArray->GetSize(); iIndex++ )
    {
        pWatcher = (*pArray)[iIndex];
        
        if( pWatcher != NULL )
        {
            CRTCWatcher *pCWatcher = static_cast<CRTCWatcher *>(pWatcher);

            if(IsEqualURI( pCWatcher->m_szPresentityURI, lpwstrPresentityURI ) )
            {
                *ppWatcher =  pWatcher;
                (*ppWatcher)->AddRef();
                return S_OK;
            }
        }
    }

    return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::FindBuddyByURI
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::FindBuddyByURI(
    IN  LPWSTR                  lpwstrPresentityURI,
    OUT IRTCBuddy            ** ppBuddy
    )
{
    INT             iIndex;
    IRTCBuddy     * pBuddy = NULL;

    if ( IsBadWritePtr( ppBuddy, sizeof(IRTCBuddy*) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::FindBuddyByURI - "
                            "bad IRTCBuddy* pointer"));

        return E_POINTER;
    } 

    *ppBuddy = NULL;
    
    for( iIndex=0; iIndex < m_BuddyArray.GetSize(); iIndex++ )
    {
        pBuddy = m_BuddyArray[iIndex];
        
        if( pBuddy != NULL )
        {
            CRTCBuddy *pCBuddy = static_cast<CRTCBuddy *>(pBuddy);

            if( IsEqualURI( pCBuddy->m_szPresentityURI, lpwstrPresentityURI ) )
            {
                *ppBuddy =  pBuddy;
                (*ppBuddy)->AddRef();
                return S_OK;
            }
        }
    }

    return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::RefreshPresenceSessions
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCClient::RefreshPresenceSessions(
    BOOL bIncludingWatchers)
{
    LOG((RTC_TRACE, "CRTCClient::RefreshPresenceSessions - enter"));

    //
    // Unsubscribe the SIP watchers
    //

    if ( bIncludingWatchers && m_pSipWatcherManager != NULL )
    { 
        CRTCWatcher * pCWatcher = NULL;

        for (int n = 0; n < m_WatcherArray.GetSize(); n++)
        {
            pCWatcher = reinterpret_cast<CRTCWatcher *>(m_WatcherArray[n]);

            if ( pCWatcher )
            {
                pCWatcher->RemoveSIPWatchers(FALSE);                   
            }
        }
        for (int n = 0; n < m_HiddenWatcherArray.GetSize(); n++)
        {
            pCWatcher = reinterpret_cast<CRTCWatcher *>(m_HiddenWatcherArray[n]);

            if ( pCWatcher )
            {
                pCWatcher->RemoveSIPWatchers(FALSE);                   
            }
        }
    }

    //
    // Re-subscribe the SIP buddies
    //

    if ( m_pSipBuddyManager != NULL )
    { 
        CRTCBuddy * pCBuddy = NULL;

        for (int n = 0; n < m_BuddyArray.GetSize(); n++)
        {
            pCBuddy = reinterpret_cast<CRTCBuddy *>(m_BuddyArray[n]);

            if ( pCBuddy )
            {                
                pCBuddy->BuddyUnsubscribed();      
            }
        }
    }

    LOG((RTC_TRACE, "CRTCClient::RefreshPresenceSessions - exit"));
}



/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_LocalUserURI
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_LocalUserURI(
        BSTR * pbstrUserURI
        )
{
    LOG((RTC_TRACE, "CRTCClient::get_LocalUserURI - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_LocalUserURI - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadWritePtr( pbstrUserURI, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_LocalUserURI - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szUserURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::get_LocalUserURI - "
                            "no local user URI"));

        return E_FAIL;
    }

    //
    // Allocate the BSTR to be returned
    //
    
    *pbstrUserURI = SysAllocString(m_szUserURI);

    if ( *pbstrUserURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::get_LocalUserURI - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }    
    
    LOG((RTC_TRACE, "CRTCClient::get_LocalUserURI - exit S_OK"));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::put_LocalUserURI
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::put_LocalUserURI(
        BSTR bstrUserURI
        )
{
    LOG((RTC_TRACE, "CRTCClient::put_LocalUserURI - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::put_LocalUserURI - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    HRESULT hr;

    if ( IsBadStringPtrW( bstrUserURI, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_LocalUserURI - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szUserURI != NULL )
    {
        RtcFree( m_szUserURI );
        m_szUserURI = NULL;
    }

    hr = AllocCleanSipString( bstrUserURI, &m_szUserURI );  

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_LocalUserURI - "
                            "AllocCleanSipString failed 0x%lx", hr));

        return hr;
    }    
    
    // this URI is used in presence only when a profile is not used
    // so we don't update any outgoing subscriptions here

    LOG((RTC_TRACE, "CRTCClient::put_LocalUserURI - exit S_OK"));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_LocalUserName
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_LocalUserName(
        BSTR * pbstrUserName
        )
{
    LOG((RTC_TRACE, "CRTCClient::get_LocalUserName - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_LocalUserName - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadWritePtr( pbstrUserName, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_LocalUserName - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szUserName == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::get_LocalUserName - "
                            "no local user URI"));

        return E_FAIL;
    }

    //
    // Allocate the BSTR to be returned
    //
    
    *pbstrUserName = SysAllocString(m_szUserName);

    if ( *pbstrUserName == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::get_LocalUserName - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }    
    
    LOG((RTC_TRACE, "CRTCClient::get_LocalUserName - exit S_OK"));

    return S_OK;
}   

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::put_LocalUserName
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::put_LocalUserName(
        BSTR bstrUserName
        )
{
    LOG((RTC_TRACE, "CRTCClient::put_LocalUserName - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::put_LocalUserName - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadStringPtrW( bstrUserName, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::put_LocalUserName - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szUserName != NULL )
    {
        RtcFree( m_szUserName );
        m_szUserName = NULL;
    }

    m_szUserName = RtcAllocString( bstrUserName );    

    if ( m_szUserName == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::put_LocalUserName - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }    

   // refresh the outgoing subscriptions
    RefreshPresenceSessions(FALSE);

    LOG((RTC_TRACE, "CRTCClient::put_LocalUserName - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::StartT120Applet
//
// Start Netmeeting T120 Applets
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::StartT120Applet(
        RTC_T120_APPLET enApplet
        )
{
    HRESULT hr;

    LOG((RTC_TRACE, "CRTCClient::StartT120Applet - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::StartT120Applet - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    _ASSERT (m_pMediaManage != NULL);

    UINT uiAppletID;

    switch ( enApplet )
    {
    case RTCTA_WHITEBOARD:
        uiAppletID = NM_APPID_T126_WHITEBOARD;
        break;

    case RTCTA_APPSHARING:
        uiAppletID = NM_APPID_APPSHARING;
        break;

    default:
        LOG((RTC_ERROR, "CRTCClient::StartT120Applet - invalid argument"));

        return E_INVALIDARG;
    }

    if (hr = m_pMediaManage->StartT120Applet(uiAppletID))
    {
        LOG((RTC_ERROR, "CRTCClient::StartT120Applet - StartT120Applet failed 0x%lx", hr));
        return hr;
    }

    LOG((RTC_TRACE, "CRTCClient::StartT120Applet - exit S_OK"));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::StopT120Applets
//
// Stop Netmeeting T120 Applets
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::StopT120Applets()
{
    HRESULT hr;

    LOG((RTC_TRACE, "CRTCClient::StopT120Applets - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::StopT120Applets - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    _ASSERT(m_pMediaManage != NULL);

    hr = m_pMediaManage->StopT120Applets();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::StopT120Applets - "
                    "StopT120Applets failed 0x%lx", hr));

        return hr;
    }

    LOG((RTC_TRACE, "CRTCClient::StopT120Applets - exit S_OK"));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// FindWindowFromResource
//
/////////////////////////////////////////////////////////////////////////////

HWND FindWindowFromResource(HWND hwndParent, UINT uResID, BOOL fDialog)
{
    HWND        hwnd;
    LPCTSTR     szWindowName;
    const TCHAR szDialogClassName[] = TEXT("#32770");

    szWindowName = RtcAllocString(_Module.GetResourceInstance(), uResID);

    if ( szWindowName == NULL )
    {
        LOG((RTC_ERROR, "FindWindowFromResource - "
                    "out of memory"));

        return NULL;
    }

    hwnd = FindWindowEx (hwndParent, NULL, fDialog ? szDialogClassName : NULL, szWindowName);
    RtcFree ((LPVOID)szWindowName);

    return hwnd;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::IsT120AppletRunning
//
// Check if Netmeeting T120 Applet is running
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCClient::get_IsT120AppletRunning(
            RTC_T120_APPLET   enApplet,
            VARIANT_BOOL * pfRunning
            )
{
    HRESULT hr;
    const TCHAR szNMWBClassName[] = TEXT("T126WBMainWindowClass");    

    LOG((RTC_TRACE, "CRTCClient::get_IsT120AppletRunning - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_IsT120AppletRunning - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadWritePtr( pfRunning, sizeof(VARIANT_BOOL) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_IsT120AppletRunning - "
                            "bad VARIANT_BOOL pointer"));

        return E_POINTER;
    }

    *pfRunning = VARIANT_FALSE;

    switch ( enApplet )
    {
    case RTCTA_WHITEBOARD:
        {
            HWND hwnd;

            //
            // Search the NM whiteboard window by class name
            //

            hwnd = FindWindow(szNMWBClassName, NULL);

            if (hwnd && IsWindowVisible(hwnd))
            {
                LOG((RTC_INFO, "CRTCClient::get_IsT120AppletRunning - "
                                "got Whiteboard window hwnd=0x%lx", hwnd));

                *pfRunning = VARIANT_TRUE;
            }
        }
        break;

    case RTCTA_APPSHARING:
        {
            HWND    hwnd;

            //
            // Search the NM Application sharing window with with the title of
            // Sharing - Not in a call
            // The test is further refined by testing the existance of a
            // "Unshare All" button
            //

            hwnd = FindWindowFromResource( NULL, IDS_NMAS_TITLE, TRUE );

            if ( hwnd == NULL )
            {
                hwnd = FindWindowFromResource( NULL, IDS_NMAS_NOTHING, TRUE );
            }

            if ( hwnd == NULL )
            {
                hwnd = FindWindowFromResource( NULL, IDS_NMAS_PROGRAMS, TRUE );
            }

            if ( hwnd == NULL )
            {
                hwnd = FindWindowFromResource( NULL, IDS_NMAS_DESKTOP, TRUE );
            }

            if (hwnd && IsWindowVisible(hwnd))
            {
                LOG((RTC_INFO, "CRTCClient::get_IsT120AppletRunning - "
                            "got Sharing window hwnd=0x%lx", hwnd));

                hwnd = FindWindowFromResource( hwnd, IDS_NMAS_UNSHAREALL, FALSE );

                if (hwnd)
                {
                    LOG((RTC_INFO, "CRTCClient::get_IsT120AppletRunning - "
                            "got Unshare_All button hwnd=0x%lx", hwnd));

                    *pfRunning = VARIANT_TRUE;
                }                        
            }
        }
        break;

    default:
        LOG((RTC_ERROR, "CRTCClient::get_IsT120AppletRunning - invalid argument"));

        return E_INVALIDARG;
    }

    LOG((RTC_TRACE, "CRTCClient::get_IsT120AppletRunning - exit S_OK"));

    return S_OK;
}
    
/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::EnablePresence
//
/////////////////////////////////////////////////////////////////////////////

HRESULT CRTCClient::EnablePresence(     
     VARIANT_BOOL fUseStorage,
     VARIANT varStorage
     )
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "CRTCClient::EnablePresence - enter"));
   
    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::EnablePresence - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Load the watcher manager interface
    //

    if ( m_pSipWatcherManager == NULL )
    {
        hr = m_pSipStack->QueryInterface(
            IID_ISIPWatcherManager, (LPVOID *)&m_pSipWatcherManager);

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCClient::EnablePresence: cannot retrieve "
                "ISIPWatcherManager interface: x%x.", hr));

            return hr;
        }
    }

    //
    // Load the buddy manager interface
    //

    if ( m_pSipBuddyManager == NULL )
    {
        hr = m_pSipStack->QueryInterface(
            IID_ISIPBuddyManager, (LPVOID *)&m_pSipBuddyManager);

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCClient::EnablePresence: cannot retrieve "
                "ISIPBuddyManager interface: x%x.", hr));

            return hr;
        }
    }

    //
    // Get storage info
    //

    m_varPresenceStorage = varStorage;
    m_fPresenceUseStorage = fUseStorage ? TRUE : FALSE;

    //
    // It's official
    //

    m_fPresenceEnabled = TRUE;

    //
    // Load presence info
    //

    if ( m_fPresenceUseStorage )
    {
        hr = Import( m_varPresenceStorage, VARIANT_TRUE );
            if (FAILED(hr))
            {
                LOG((RTC_ERROR, "CRTCClient::EnablePresence: - "
                                "Import failed 0x%lx", hr));
                return S_FALSE;
            }
    }

    LOG((RTC_TRACE, "CRTCClient::EnablePresence - exit"));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::CreateXMLDOMNodeForBuddyList
//
/////////////////////////////////////////////////////////////////////////////

HRESULT CRTCClient::CreateXMLDOMNodeForBuddyList(
     IXMLDOMDocument * pXMLDoc,
     IXMLDOMNode     ** ppBuddyList
     )
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "CRTCClient::CreateXMLDOMNodeForBuddyList - enter"));

    IXMLDOMNode * pBuddyList = NULL;
    IXMLDOMNode * pBuddyInfo = NULL;

    hr = pXMLDoc->createNode( CComVariant(NODE_ELEMENT), CComBSTR(_T("BuddyList")), NULL, &pBuddyList );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMNodeForBuddyList - "
                            "createNode failed 0x%lx", hr));

        return hr;
    }

    CRTCBuddy * pCBuddy = NULL;

    for (int n = 0; n < m_BuddyArray.GetSize(); n++)
    {
        pCBuddy = reinterpret_cast<CRTCBuddy *>(m_BuddyArray[n]);

        if ( pCBuddy->m_bPersistent )
        {
            hr = pCBuddy->CreateXMLDOMNode( pXMLDoc, &pBuddyInfo );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMNodeForBuddyList - "
                                    "CreateXMLDOMNode failed 0x%lx", hr));

                pBuddyList->Release();

                return hr;
            }

            hr = pBuddyList->appendChild( pBuddyInfo, NULL );

            pBuddyInfo->Release();

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMNodeForBuddyList - "
                                    "appendChild failed 0x%lx", hr));
            
                pBuddyList->Release();

                return hr;
            }
        }
    }

    *ppBuddyList = pBuddyList;

    LOG((RTC_TRACE, "CRTCClient::CreateXMLDOMNodeForBuddyList - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::CreateXMLDOMNodeForWatcherList
//
/////////////////////////////////////////////////////////////////////////////

HRESULT CRTCClient::CreateXMLDOMNodeForWatcherList(
     IXMLDOMDocument * pXMLDoc,
     IXMLDOMNode     ** ppWatcherList,
     IXMLDOMNode     ** ppBlockedList
     )
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "CRTCClient::CreateXMLDOMNodeForWatcherList - enter"));

    IXMLDOMNode * pWatcherList = NULL;
    IXMLDOMNode * pBlockedList = NULL;
    IXMLDOMNode * pWatcherInfo = NULL;

    hr = pXMLDoc->createNode( CComVariant(NODE_ELEMENT), CComBSTR(_T("WatcherList")), NULL, &pWatcherList );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMNodeForWatcherList - "
                            "createNode(WatcherList) failed 0x%lx", hr));

        return hr;
    }

    hr = pXMLDoc->createNode( CComVariant(NODE_ELEMENT), CComBSTR(_T("BlockedList")), NULL, &pBlockedList );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMNodeForWatcherList - "
                            "createNode(BlockedList) failed 0x%lx", hr));

        pWatcherList->Release();

        return hr;
    }

    CRTCWatcher * pCWatcher = NULL;

    for (int n = 0; n < m_WatcherArray.GetSize(); n++)
    {
        pCWatcher = reinterpret_cast<CRTCWatcher *>(m_WatcherArray[n]);

        if ( pCWatcher->m_bPersistent )
        {
            hr = pCWatcher->CreateXMLDOMNode( pXMLDoc, &pWatcherInfo );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMNodeForWatcherList - "
                                    "CreateXMLDOMNode failed 0x%lx", hr));

                pWatcherList->Release();
                pBlockedList->Release();

                return hr;
            }

            if ( pCWatcher->m_nState == RTCWS_ALLOWED )
            {
                hr = pWatcherList->appendChild( pWatcherInfo, NULL );
            }
            else if ( pCWatcher->m_nState == RTCWS_BLOCKED )
            {
                hr = pBlockedList->appendChild( pWatcherInfo, NULL );
            }        

            pWatcherInfo->Release();

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMNodeForWatcherList - "
                                    "appendChild failed 0x%lx", hr));
            
                pWatcherList->Release();
                pBlockedList->Release();

                return hr;
            }
        }
    }

    *ppWatcherList = pWatcherList;
    *ppBlockedList = pBlockedList;

    LOG((RTC_TRACE, "CRTCClient::CreateXMLDOMNodeForWatcherList - exit S_OK"));

    return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::CreateXMLDOMNodeForProperties
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::CreateXMLDOMNodeForProperties( IXMLDOMDocument * pXMLDoc, IXMLDOMNode ** ppXDN )
{
    IXMLDOMNode    * pProperties = NULL;
    IXMLDOMElement * pElement = NULL;
    HRESULT hr;

    LOG((RTC_TRACE, "CRTCClient::CreateXMLDOMNodeForProperties - enter"));

    hr = pXMLDoc->createNode( CComVariant(NODE_ELEMENT), CComBSTR(_T("Properties")), NULL, &pProperties );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMNodeForProperties - "
                        "createNode failed 0x%lx", hr));

        return hr;
    }
    
    hr = pProperties->QueryInterface( IID_IXMLDOMElement, (void**)&pElement );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMNodeForProperties - "
                        "QueryInterface failed 0x%lx", hr));

        pProperties->Release();

        return hr;
    }

    hr = pElement->setAttribute( CComBSTR(_T("OfferWatcherMode")),
         CComVariant( 
             m_nOfferWatcherMode == RTCOWM_AUTOMATICALLY_ADD_WATCHER ? 
              _T("AutomaticallyAddWatcher") : _T("OfferWatcherEvent")
             ));

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMNodeForProperties - "
                    "setAttribute(OfferWatcherMode) failed 0x%lx", hr));

        pElement->Release();
        pProperties->Release();

        return hr;
    }
    
    hr = pElement->setAttribute( CComBSTR(_T("PrivacyMode")),
         CComVariant( 
             m_nPrivacyMode == RTCPM_ALLOW_LIST_ONLY ? 
             _T("AllowListOnly") : _T("BlockListExcluded")
             ));

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMNodeForProperties - "
                    "setAttribute(PrivacyMode) failed 0x%lx", hr));

        pElement->Release();
        pProperties->Release();

        return hr;
    }

    pElement->Release();

    *ppXDN = pProperties;

    LOG((RTC_TRACE, "CRTCClient::CreateXMLDOMNodeForProperties - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::CreateXMLDOMDocumentForPresence
//
/////////////////////////////////////////////////////////////////////////////

HRESULT CRTCClient::CreateXMLDOMDocumentForPresence(
     IXMLDOMDocument ** ppXMLDoc
     )
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "CRTCClient::CreateXMLDOMDocumentForPresence - enter"));

    IXMLDOMDocument * pXMLDoc = NULL;
    IXMLDOMNode     * pDocument = NULL;
    IXMLDOMNode     * pPresence = NULL;

    //
    // Create the XML document
    //

    hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER,
            IID_IXMLDOMDocument, (void**)&pXMLDoc );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMDocumentForPresence - "
                            "CoCreateInstance failed 0x%lx", hr));

        return hr;
    }

    hr = pXMLDoc->QueryInterface( IID_IXMLDOMNode, (void**)&pDocument );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMDocumentForPresence - "
                            "QueryInterface failed 0x%lx", hr));

        pXMLDoc->Release();

        return hr;
    }

    //
    // Create the PresenceInfo node
    //
    
    hr = pXMLDoc->createNode( CComVariant(NODE_ELEMENT), CComBSTR(_T("PresenceInfo")), NULL, &pPresence );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMDocumentForPresence - "
                            "createNode failed 0x%lx", hr));

        pDocument->Release();
        pXMLDoc->Release();

        return hr;
    }

    hr = pDocument->appendChild( pPresence, NULL );

    pDocument->Release();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMDocumentForPresence - "
                            "appendChild failed 0x%lx", hr));

        pPresence->Release();        
        pXMLDoc->Release();

        return hr;
    }

    //
    // Fill in the Properties
    //

    IXMLDOMNode * pProperties = NULL;

    hr = CreateXMLDOMNodeForProperties( pXMLDoc, &pProperties );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMDocumentForPresence - "
                            "CreateXMLDOMNodeForProperties failed 0x%lx", hr));

        pPresence->Release();        
        pXMLDoc->Release();

        return hr;
    }

    hr = pPresence->appendChild( pProperties, NULL );

    pProperties->Release();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMDocumentForPresence - "
                            "appendChild(Properties) failed 0x%lx", hr));
    
        pPresence->Release();        
        pXMLDoc->Release();

        return hr;
    }

    //
    // Fill in the BuddyList
    //

    IXMLDOMNode * pBuddyList = NULL;

    hr = CreateXMLDOMNodeForBuddyList( pXMLDoc, &pBuddyList );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMDocumentForPresence - "
                            "CreateXMLDOMNodeForBuddyList failed 0x%lx", hr));

        pPresence->Release();        
        pXMLDoc->Release();

        return hr;
    }

    hr = pPresence->appendChild( pBuddyList, NULL );

    pBuddyList->Release();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMDocumentForPresence - "
                            "appendChild(BuddyList) failed 0x%lx", hr));
    
        pPresence->Release();        
        pXMLDoc->Release();

        return hr;
    }

    //
    // Fill in the WatcherList
    //

    IXMLDOMNode * pWatcherList = NULL;
    IXMLDOMNode * pBlockedList = NULL;

    hr = CreateXMLDOMNodeForWatcherList( pXMLDoc, &pWatcherList, &pBlockedList );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMDocumentForPresence - "
                            "CreateXMLDOMNodeForWatcherList failed 0x%lx", hr));

        pPresence->Release();        
        pXMLDoc->Release();

        return hr;
    }

    hr = pPresence->appendChild( pWatcherList, NULL );

    pWatcherList->Release();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMDocumentForPresence - "
                            "appendChild(WatcherList) failed 0x%lx", hr));
    
        pBlockedList->Release();
        pPresence->Release();        
        pXMLDoc->Release();

        return hr;
    }

    hr = pPresence->appendChild( pBlockedList, NULL );

    pBlockedList->Release();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::CreateXMLDOMDocumentForPresence - "
                            "appendChild(BlockedList) failed 0x%lx", hr));

        pPresence->Release();        
        pXMLDoc->Release();

        return hr;
    }

    pPresence->Release();

    *ppXMLDoc = pXMLDoc;

    LOG((RTC_TRACE, "CRTCClient::CreateXMLDOMDocumentForPresence - exit S_OK"));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::ParseXMLDOMNodeForBuddyList
//
/////////////////////////////////////////////////////////////////////////////

HRESULT CRTCClient::ParseXMLDOMNodeForBuddyList(
     IXMLDOMNode     * pBuddyList
     )
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "CRTCClient::ParseXMLDOMNodeForBuddyList - enter"));

    VARIANT_BOOL bHasChild;

    hr = pBuddyList->hasChildNodes( &bHasChild );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForBuddyList - "
                            "hasChildNodes failed 0x%lx", hr));

        return hr;
    }

    if ( bHasChild )
    {
        IXMLDOMNodeList * pNodeList = NULL;

        hr = pBuddyList->get_childNodes( &pNodeList );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForBuddyList - "
                                "get_childNodes failed 0x%lx", hr));

            return hr;
        }

        IXMLDOMNode * pNode = NULL;

        while ( pNodeList->nextNode( &pNode ) == S_OK )
        {
            IXMLDOMElement * pElement = NULL;

            hr = pNode->QueryInterface( IID_IXMLDOMElement, (void**)&pElement );

            pNode->Release();

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForBuddyList - "
                                    "QueryInterface failed 0x%lx", hr));

                pNodeList->Release();

                return hr;
            }

            CComVariant varPresentity;
            CComVariant varName;
            CComVariant varData;

            hr = pElement->getAttribute( CComBSTR(_T("Presentity")), &varPresentity );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForBuddyList - "
                                    "getAttribute(Presentity) failed 0x%lx", hr));

                pElement->Release();
                pNodeList->Release();

                return hr;
            }

            hr = pElement->getAttribute( CComBSTR(_T("Name")), &varName );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForBuddyList - "
                                    "getAttribute(Name) failed 0x%lx", hr));

                pElement->Release();
                pNodeList->Release();

                return hr;
            }

            hr = pElement->getAttribute( CComBSTR(_T("Data")), &varData );

            pElement->Release();

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForBuddyList - "
                                    "getAttribute(Data) failed 0x%lx", hr));

                pElement->Release();
                pNodeList->Release();

                return hr;
            }

            hr = AddBuddy( 
                    varPresentity.bstrVal,
                    varName.bstrVal,
                    varData.bstrVal,
                    VARIANT_TRUE,
                    NULL,
                    0,
                    NULL );

            if ( FAILED(hr) )
            {
                LOG((RTC_WARN, "CRTCClient::ParseXMLDOMNodeForBuddyList - "
                                    "AddBuddy failed 0x%lx", hr));
            }
        }

        pNodeList->Release();
    }  

    LOG((RTC_TRACE, "CRTCClient::ParseXMLDOMNodeForBuddyList - exit S_OK"));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::ParseXMLDOMNodeForWatcherList
//
/////////////////////////////////////////////////////////////////////////////

HRESULT CRTCClient::ParseXMLDOMNodeForWatcherList(
     IXMLDOMNode     * pWatcherList,
     VARIANT_BOOL      bBlocked
     )
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "CRTCClient::ParseXMLDOMNodeForWatcherList - enter"));

    VARIANT_BOOL bHasChild;

    hr = pWatcherList->hasChildNodes( &bHasChild );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForWatcherList - "
                            "hasChildNodes failed 0x%lx", hr));

        return hr;
    }

    if ( bHasChild )
    {
        IXMLDOMNodeList * pNodeList = NULL;

        hr = pWatcherList->get_childNodes( &pNodeList );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForWatcherList - "
                                "get_childNodes failed 0x%lx", hr));

            return hr;
        }

        IXMLDOMNode * pNode = NULL;

        while ( pNodeList->nextNode( &pNode ) == S_OK )
        {
            IXMLDOMElement * pElement = NULL;

            hr = pNode->QueryInterface( IID_IXMLDOMElement, (void**)&pElement );

            pNode->Release();

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForWatcherList - "
                                    "QueryInterface failed 0x%lx", hr));

                pNodeList->Release();

                return hr;
            }

            CComVariant varPresentity;
            CComVariant varName;
            CComVariant varData;
            CComVariant varShutdownBlob;

            hr = pElement->getAttribute( CComBSTR(_T("Presentity")), &varPresentity );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForWatcherList - "
                                    "getAttribute(Presentity) failed 0x%lx", hr));

                pElement->Release();
                pNodeList->Release();

                return hr;
            }

            hr = pElement->getAttribute( CComBSTR(_T("Name")), &varName );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForWatcherList - "
                                    "getAttribute(Name) failed 0x%lx", hr));

                pElement->Release();
                pNodeList->Release();

                return hr;
            }

            hr = pElement->getAttribute( CComBSTR(_T("Data")), &varData );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForWatcherList - "
                                    "getAttribute(Data) failed 0x%lx", hr));
                
                pNodeList->Release();

                return hr;
            }     
            
            hr = pElement->getAttribute( CComBSTR(_T("ShutdownBlob")), &varShutdownBlob );

            pElement->Release();

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForWatcherList - "
                                    "getAttribute(ShutdownBlob) failed 0x%lx", hr));
                
                pNodeList->Release();

                return hr;
            }   

            hr = InternalAddWatcher(
                    varPresentity.bstrVal,
                    varName.bstrVal,
                    varData.bstrVal,
                    varShutdownBlob.bstrVal,
                    bBlocked,
                    VARIANT_TRUE,
                    NULL );

            if ( FAILED(hr) )
            {
                LOG((RTC_WARN, "CRTCClient::ParseXMLDOMNodeForWatcherList - "
                                    "AddWatcher failed 0x%lx", hr));
            }
        }

        pNodeList->Release();
    }  

    LOG((RTC_TRACE, "CRTCClient::ParseXMLDOMNodeForWatcherList - exit S_OK"));
    
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::ParseXMLDOMNodeForProperties
//
/////////////////////////////////////////////////////////////////////////////

HRESULT CRTCClient::ParseXMLDOMNodeForProperties(
     IXMLDOMNode     * pProperties,
     RTC_OFFER_WATCHER_MODE * pnOfferWatcherMode,
     RTC_PRIVACY_MODE       * pnPrivacyMode
     )
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "CRTCClient::ParseXMLDOMNodeForProperties - enter"));

    IXMLDOMElement * pElement = NULL;

    hr = pProperties->QueryInterface( IID_IXMLDOMElement, (void**)&pElement );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForProperties - "
          "QueryInterface failed 0x%lx", hr));

        return hr;
    }

    CComVariant varOfferWatcherMode;
    CComVariant varPrivacyMode;

    hr = pElement->getAttribute( CComBSTR(_T("OfferWatcherMode")), &varOfferWatcherMode );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForProperties - "
            "getAttribute(OfferWatcherMode) failed 0x%lx", hr));

        pElement->Release();
        return hr;
    }
    
    
    hr = pElement->getAttribute( CComBSTR(_T("PrivacyMode")), &varPrivacyMode );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMNodeForProperties - "
            "getAttribute(PrivacyMode) failed 0x%lx", hr));

        pElement->Release();
        return hr;
    }

    // Process the values
    //
    
    if(_wcsicmp(varOfferWatcherMode.bstrVal, L"OfferWatcherEvent") == 0)
    {
        *pnOfferWatcherMode = RTCOWM_OFFER_WATCHER_EVENT;
    }
    else if(_wcsicmp(varOfferWatcherMode.bstrVal, L"AutomaticallyAddWatcher") == 0)
    {
        *pnOfferWatcherMode = RTCOWM_AUTOMATICALLY_ADD_WATCHER;
    }
    
    if(_wcsicmp(varPrivacyMode.bstrVal, L"BlockListExcluded") == 0)
    {
        *pnPrivacyMode = RTCPM_BLOCK_LIST_EXCLUDED;
    }
    else if(_wcsicmp(varPrivacyMode.bstrVal, L"AllowListOnly") == 0)
    {
        *pnPrivacyMode = RTCPM_ALLOW_LIST_ONLY;
    }
      
    pElement->Release();

    LOG((RTC_TRACE, "CRTCClient::ParseXMLDOMNodeForProperties - exit S_OK"));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::ParseXMLDOMDocumentForPresence
//
/////////////////////////////////////////////////////////////////////////////

HRESULT CRTCClient::ParseXMLDOMDocumentForPresence(
     IXMLDOMDocument * pXMLDoc,
     RTC_OFFER_WATCHER_MODE * pnOfferWatcherMode,
     RTC_PRIVACY_MODE       * pnPrivacyMode
     )
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "CRTCClient::ParseXMLDOMDocumentForPresence - enter"));

    IXMLDOMNode * pDocument = NULL;

    hr = pXMLDoc->QueryInterface( IID_IXMLDOMNode, (void**)&pDocument);

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMDocumentForPresence - "
                            "QueryInterface failed 0x%lx", hr));

        return hr;
    }

    //
    // Parse the Properties
    //

    IXMLDOMNode * pProperties = NULL;

    hr = pDocument->selectSingleNode( CComBSTR(_T("PresenceInfo/Properties")), &pProperties );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMDocumentForPresence - "
                            "selectSingleNode(Properties) failed 0x%lx", hr));

        pDocument->Release();

        return hr;
    }

    if ( hr == S_OK )
    {
        hr = ParseXMLDOMNodeForProperties( pProperties, pnOfferWatcherMode, pnPrivacyMode);

        pProperties->Release();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMDocumentForPresence - "
                                "ParseXMLDOMNodeForProperties failed 0x%lx", hr));

            pDocument->Release();

            return hr;
        }
    }
    else
    {
        LOG((RTC_WARN, "CRTCClient::ParseXMLDOMDocumentForPresence - "
                            "Properties not found"));

        // default values
        *pnOfferWatcherMode = RTCOWM_OFFER_WATCHER_EVENT;
        *pnPrivacyMode = RTCPM_BLOCK_LIST_EXCLUDED;
    }

    //
    // Parse the BuddyList
    //

    IXMLDOMNode * pBuddyList = NULL;

    hr = pDocument->selectSingleNode( CComBSTR(_T("PresenceInfo/BuddyList")), &pBuddyList );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMDocumentForPresence - "
                            "selectSingleNode(BuddyList) failed 0x%lx", hr));

        pDocument->Release();

        return hr;
    }

    if ( hr == S_OK )
    {
        hr = ParseXMLDOMNodeForBuddyList( pBuddyList );

        pBuddyList->Release();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMDocumentForPresence - "
                                "ParseXMLDOMNodeForBuddyList failed 0x%lx", hr));

            pDocument->Release();

            return hr;
        }
    }
    else
    {
        LOG((RTC_WARN, "CRTCClient::ParseXMLDOMDocumentForPresence - "
                            "BuddyList not found"));
    }

    //
    // Parse the WatcherList
    //

    IXMLDOMNode * pWatcherList = NULL;

    hr = pDocument->selectSingleNode( CComBSTR(_T("PresenceInfo/WatcherList")), &pWatcherList );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMDocumentForPresence - "
                            "selectSingleNode(WatcherList) failed 0x%lx", hr));

        pDocument->Release();

        return hr;
    }

    if ( hr == S_OK )
    {
        hr = ParseXMLDOMNodeForWatcherList( pWatcherList, VARIANT_FALSE );

        pWatcherList->Release();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMDocumentForPresence - "
                                "ParseXMLDOMNodeForWatcherList(WatcherList) failed 0x%lx", hr));

            pDocument->Release();

            return hr;
        }
    }
    else
    {
        LOG((RTC_WARN, "CRTCClient::ParseXMLDOMDocumentForPresence - "
                            "WatcherList not found"));
    }

    //
    // Parse the BlockedList
    //

    IXMLDOMNode * pBlockedList = NULL;

    hr = pDocument->selectSingleNode( CComBSTR(_T("PresenceInfo/BlockedList")), &pBlockedList );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMDocumentForPresence - "
                            "selectSingleNode(BlockedList) failed 0x%lx", hr));

        pDocument->Release();

        return hr;
    }

    if ( hr == S_OK )
    {
        hr = ParseXMLDOMNodeForWatcherList( pBlockedList, VARIANT_TRUE );

        pBlockedList->Release();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCClient::ParseXMLDOMDocumentForPresence - "
                                "ParseXMLDOMNodeForWatcherList(BlockedList) failed 0x%lx", hr));

            pDocument->Release();

            return hr;
        }
    }
    else
    {
        LOG((RTC_WARN, "CRTCClient::ParseXMLDOMDocumentForPresence - "
                            "BlockedList not found"));
    }

    pDocument->Release();

    LOG((RTC_TRACE, "CRTCClient::ParseXMLDOMDocumentForPresence - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::UpdatePresenceStorage
//
/////////////////////////////////////////////////////////////////////////////

HRESULT CRTCClient::UpdatePresenceStorage()
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "CRTCClient::UpdatePresenceStorage - enter"));

    if ( m_fPresenceUseStorage )
    {
        // Kill any existing timer
        KillTimer(m_hWnd, TID_PRESENCE_STORAGE);

        // Try to start the timer
        DWORD dwID = (DWORD)SetTimer(m_hWnd, TID_PRESENCE_STORAGE, PRESENCE_STORAGE_DELAY, NULL);
        if (dwID==0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            LOG((RTC_ERROR, "CRTCClient::UpdatePresenceStorage - "
                           "SetTimer failed 0x%lx", hr));

            return hr;
        }
    }

    LOG((RTC_TRACE, "CRTCClient::UpdatePresenceStorage - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::OnPresenceStorageTimer
//
/////////////////////////////////////////////////////////////////////////////

void CRTCClient::OnPresenceStorageTimer()
{
    LOG((RTC_TRACE, "CRTCClient::OnPresenceStorageTimer - enter"));

    // Kill the timer
    KillTimer(m_hWnd, TID_PRESENCE_STORAGE);

    // Store the presence information
    if ( m_fPresenceUseStorage )
    {
        InternalExport( m_varPresenceStorage );
    }  

    LOG((RTC_TRACE, "CRTCClient::OnPresenceStorageTimer - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::Export
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::Export(
     VARIANT varStorage
     )
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "CRTCClient::Export - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::Export - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    hr = InternalExport( varStorage );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Export - "
                            "InternalExport failed 0x%lx", hr));

        return hr;
    }

    LOG((RTC_TRACE, "CRTCClient::Export - exit S_OK"));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::InternalExport
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCClient::InternalExport(
     VARIANT varStorage
     )
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "CRTCClient::InternalExport - enter"));

    IXMLDOMDocument * pXMLDoc = NULL;

    //
    // Create the XML document
    //

    hr = CreateXMLDOMDocumentForPresence( &pXMLDoc );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::InternalExport - "
                            "CreateXMLDOMDocumentForPresence failed 0x%lx", hr));

        return hr;
    }

    //
    // Save the XML document
    //

    hr = pXMLDoc->save( varStorage );

    pXMLDoc->Release();

    if ( S_OK != hr )
    {
        LOG((RTC_ERROR, "CRTCClient::InternalExport - "
                            "save failed 0x%lx", hr));

        if ( S_FALSE == hr )
        {
            hr = E_FAIL;
        }
        
        return hr;
    }

    LOG((RTC_TRACE, "CRTCClient::InternalExport - exit S_OK"));
    
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::Import
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::Import(
     VARIANT varStorage,
     VARIANT_BOOL fReplaceAll
     )
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "CRTCClient::Import - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::Import - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    IXMLDOMDocument * pXMLDoc = NULL;
    IXMLDOMNode     * pDocument = NULL;
    IXMLDOMNode     * pPresence = NULL;

    //
    // Release the existing buddies and watchers
    //
    
    if ( fReplaceAll )
    {
        if ( m_pSipBuddyManager != NULL )
        { 
            CRTCBuddy * pCBuddy = NULL;

            for (int n = 0; n < m_BuddyArray.GetSize(); n++)
            {
                pCBuddy = reinterpret_cast<CRTCBuddy *>(m_BuddyArray[n]);

                if (pCBuddy->m_pSIPBuddy)
                {
                    m_pSipBuddyManager->RemoveBuddy(
                        pCBuddy->m_pSIPBuddy,
                        BUDDY_REMOVED_BYUSER);
                }
            }
        }

        m_BuddyArray.Shutdown();  

        if ( m_pSipWatcherManager != NULL )
        { 
            CRTCWatcher * pCWatcher = NULL;

            for (int n = 0; n < m_WatcherArray.GetSize(); n++)
            {
                pCWatcher = reinterpret_cast<CRTCWatcher *>(m_WatcherArray[n]);

                pCWatcher->RemoveSIPWatchers(FALSE);
            }
            for (int n = 0; n < m_HiddenWatcherArray.GetSize(); n++)
            {
                pCWatcher = reinterpret_cast<CRTCWatcher *>(m_HiddenWatcherArray[n]);

                pCWatcher->RemoveSIPWatchers(FALSE);
            }
        }

        m_WatcherArray.Shutdown();
        m_HiddenWatcherArray.Shutdown();
    }

    //
    // Load the XML document
    //

    hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER,
            IID_IXMLDOMDocument, (void**)&pXMLDoc );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Import - "
                            "CoCreateInstance failed 0x%lx", hr));

        return hr;
    }

    VARIANT_BOOL bSuccess;

    hr = pXMLDoc->load( varStorage, &bSuccess );

    if ( S_OK != hr ) // load failed
    {
        LOG((RTC_ERROR, "CRTCClient::Import - "
                            "load failed 0x%lx", hr));

        if ( S_FALSE == hr )
        {
            hr = E_FAIL;
        }

        return hr;
    }
    
    //
    // Parse the XML document
    //
    RTC_OFFER_WATCHER_MODE      nOfferWatcherMode;
    RTC_PRIVACY_MODE            nPrivacyMode;
    
    hr = ParseXMLDOMDocumentForPresence( 
        pXMLDoc,
        &nOfferWatcherMode,
        &nPrivacyMode);

    pXMLDoc->Release();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCClient::Import - "
                            "ParseXMLDOMDocumentForPresence failed 0x%lx", hr));
        
        return hr;
    }

    // replace the properties if fReplaceAll is TRUE
    if ( fReplaceAll )
    {
        m_nOfferWatcherMode = nOfferWatcherMode;
        m_nPrivacyMode = nPrivacyMode;
    }

#ifdef DUMP_PRESENCE
    DumpWatchers("IMPORT");
#endif

    LOG((RTC_TRACE, "CRTCClient::Import - exit S_OK"));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::EnumerateBuddies
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::EnumerateBuddies(   
            IRTCEnumBuddies ** ppEnum
            )
{
    HRESULT                 hr;

    LOG((RTC_TRACE, "CRTCClient::EnumerateBuddies enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::EnumerateBuddies - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadWritePtr( ppEnum, sizeof( IRTCEnumBuddies * ) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::EnumerateBuddies - "
                            "bad IRTCEnumBuddies pointer"));

        return E_POINTER;
    }

    if ( !m_fPresenceEnabled )
    {
        LOG((RTC_ERROR, "CRTCClient::EnumerateBuddies - "
                            "presence not enabled"));

        return RTC_E_PRESENCE_NOT_ENABLED;
    }

    //
    // Create the enumeration
    //
 
    CComObject< CRTCEnum< IRTCEnumBuddies,
                          IRTCBuddy,
                          &IID_IRTCEnumBuddies > > * p;
                          
    hr = CComObject< CRTCEnum< IRTCEnumBuddies,
                               IRTCBuddy,
                               &IID_IRTCEnumBuddies > >::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCClient::EnumerateBuddies - "
                            "CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
        
        return hr;
    }

    //
    // Initialize the enumeration (adds a reference)
    //
    
    hr = p->Initialize(m_BuddyArray);

    if ( S_OK != hr )
    {
        LOG((RTC_ERROR, "CRTCClient::EnumerateBuddies - "
                            "could not initialize enumeration" ));
    
        delete p;
        return hr;
    }

    *ppEnum = p;
    
    LOG((RTC_TRACE, "CRTCClient::EnumerateBuddies - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_Buddies
//
// This is an IRTCClientPresence method that enumerates buddies on
// the client.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCClient::get_Buddies(
        IRTCCollection ** ppCollection
        )
{
    HRESULT hr;
    
    LOG((RTC_TRACE, "CRTCClient::get_Buddies - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Buddies - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( ppCollection, sizeof(IRTCCollection *) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Buddies - "
                            "bad IRTCCollection pointer"));

        return E_POINTER;
    }

    if ( !m_fPresenceEnabled )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Buddies - "
                            "presence not enabled"));

        return RTC_E_PRESENCE_NOT_ENABLED;
    }

    //
    // Create the collection
    //
 
    CComObject< CRTCCollection< IRTCBuddy > > * p;
                          
    hr = CComObject< CRTCCollection< IRTCBuddy > >::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCClient::get_Buddies - "
                            "CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
        
        return hr;
    }

    //
    // Initialize the collection (adds a reference)
    //
    
    hr = p->Initialize(m_BuddyArray);

    if ( S_OK != hr )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Buddies - "
                            "could not initialize collection" ));
    
        delete p;
        return hr;
    }

    *ppCollection = p;

    LOG((RTC_TRACE, "CRTCClient::get_Buddies - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_Buddy
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_Buddy(
            BSTR    bstrPresentityURI,
            IRTCBuddy   **ppBuddy
            )
{
    
    HRESULT         hr;
    
    LOG((RTC_TRACE, "CRTCClient::get_Buddy - enter"));
    
    if ( IsBadWritePtr( ppBuddy, sizeof(IRTCBuddy*) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Buddy - "
                            "bad IRTCBuddy* pointer"));

        return E_POINTER;
    } 

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Buddy - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadStringPtrW( bstrPresentityURI, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Buddy - "
                            "bad URI pointer"));

        return E_POINTER;
    } 

    if ( !m_fPresenceEnabled )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Buddy - "
                            "presence not enabled"));

        return RTC_E_PRESENCE_NOT_ENABLED;
    }

    hr = FindBuddyByURI(
        bstrPresentityURI,
        ppBuddy);

    if(hr!=S_OK)
    {
        hr = E_FAIL;
    }

    LOG((RTC_TRACE, "CRTCClient::get_Buddy - exit"));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::AddBuddy
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::AddBuddy(
            BSTR    bstrPresentityURI,
            BSTR    bstrUserName,
            BSTR    bstrData,
            VARIANT_BOOL bPersistent,
            IRTCProfile * pProfile,
            long lFlags,
            IRTCBuddy ** ppBuddy
            )
{
    
    HRESULT         hr;
    
    LOG((RTC_TRACE, "CRTCClient::AddBuddy - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::AddBuddy - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // NULL is okay for ppBuddy
    //
    
    if ( (ppBuddy != NULL) &&
         IsBadWritePtr( ppBuddy, sizeof(IRTCBuddy *) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::AddBuddy - bad IRTCBuddy pointer"));

        return E_POINTER;
    }
    
    if ( IsBadStringPtrW( bstrPresentityURI, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::AddBuddy - "
                            "bad URI pointer"));

        return E_POINTER;
    } 

    if ( IsBadStringPtrW( bstrUserName, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::AddBuddy - "
                            "bad Name pointer"));

        return E_POINTER;
    } 
    
    if ( (bstrData != NULL) &&
        IsBadStringPtrW( bstrData, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::AddBuddy - "
                            "bad Data pointer"));

        return E_POINTER;
    } 

    if ( !m_fPresenceEnabled )
    {
        LOG((RTC_ERROR, "CRTCClient::AddBuddy - "
                            "presence not enabled"));

        return RTC_E_PRESENCE_NOT_ENABLED;
    }

    //
    // Clean the presentity URI
    //

    PWSTR szCleanPresentityURI = NULL;

    AllocCleanSipString( bstrPresentityURI, &szCleanPresentityURI );

    if ( szCleanPresentityURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::AddBuddy - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    //
    // Don't allow duplicates
    //

    IRTCBuddy *pBuddy = NULL;

    hr = FindBuddyByURI(
        szCleanPresentityURI,
        &pBuddy);

    if (hr == S_OK)
    {
        RtcFree( szCleanPresentityURI );
        szCleanPresentityURI = NULL;

        pBuddy->Release();
        
        LOG((RTC_ERROR, "CRTCClient::AddBuddy - "
                            "duplicate buddy"));

        return E_FAIL;
    }

    pBuddy = NULL;

    //
    // Create a buddy
    //

    hr = InternalCreateBuddy(
         szCleanPresentityURI,        
         bstrUserName,
         bstrData,
         bPersistent ? TRUE : FALSE,
         pProfile,
         lFlags,
         &pBuddy);

    RtcFree( szCleanPresentityURI );
    szCleanPresentityURI = NULL;

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCClient::AddBuddy - InternalCreateBuddy failed 0x%lx", hr));      

        return hr;
    }

    //
    // Add the buddy to the array
    //

    BOOL fResult;

    fResult = m_BuddyArray.Add(pBuddy);

    if ( fResult == FALSE )
    {
        LOG((RTC_ERROR, "CRTCClient::AddBuddy - "
                                    "out of memory"));       

        pBuddy->Release();
        pBuddy = NULL;

        return E_OUTOFMEMORY;
    }

    //
    // Update storage
    //

    UpdatePresenceStorage();

    //
    // Should we return the buddy?
    //
    
    if ( ppBuddy != NULL )
    {
        *ppBuddy = pBuddy;
    }
    else
    {
        pBuddy->Release();
        pBuddy = NULL;
    }

    LOG((RTC_TRACE, "CRTCClient::AddBuddy - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::RemoveBuddy
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::RemoveBuddy(
            IRTCBuddy * pBuddy
            )
{
    
    HRESULT         hr;
    
    LOG((RTC_TRACE, "CRTCClient::RemoveBuddy - enter"));
    
    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::RemoveBuddy - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadReadPtr( pBuddy, sizeof(IRTCBuddy) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::RemoveBuddy - "
                            "bad IRTCBuddy pointer"));

        return E_POINTER;
    } 

    if ( !m_fPresenceEnabled )
    {
        LOG((RTC_ERROR, "CRTCClient::RemoveBuddy - "
                            "presence not enabled"));

        return RTC_E_PRESENCE_NOT_ENABLED;
    }
   
    CRTCBuddy *pCBuddy   = reinterpret_cast<CRTCBuddy *>(pBuddy);

    if( pCBuddy )
    {
        hr = pCBuddy->RemoveSIPBuddy(FALSE);
          
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCClient::RemoveBuddy - RemoveSIPBuddy failed 0x%lx", hr));
        }
    }

    //
    // Remove the buddy object from the array
    //

    m_BuddyArray.Remove(pBuddy);

    //
    // Update storage
    //

    UpdatePresenceStorage();

    LOG((RTC_TRACE, "CRTCClient::RemoveBuddy - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::EnumerateWatchers
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::EnumerateWatchers(   
            IRTCEnumWatchers ** ppEnum
            )
{
    HRESULT                 hr;

    LOG((RTC_TRACE, "CRTCClient::EnumerateWatchers enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::EnumerateWatchers - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadWritePtr( ppEnum, sizeof( IRTCEnumWatchers * ) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::EnumerateWatchers - "
                            "bad IRTCEnumWatchers pointer"));

        return E_POINTER;
    }

    if ( !m_fPresenceEnabled )
    {
        LOG((RTC_ERROR, "CRTCClient::EnumerateWatchers - "
                            "presence not enabled"));

        return RTC_E_PRESENCE_NOT_ENABLED;
    }

    //
    // Create the enumeration
    //
 
    CComObject< CRTCEnum< IRTCEnumWatchers,
                          IRTCWatcher,
                          &IID_IRTCEnumWatchers > > * p;
                          
    hr = CComObject< CRTCEnum< IRTCEnumWatchers,
                               IRTCWatcher,
                               &IID_IRTCEnumWatchers > >::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCClient::EnumerateWatchers - "
                            "CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
        
        return hr;
    }

    //
    // Initialize the enumeration (adds a reference)
    //
    
    hr = p->Initialize(m_WatcherArray);

    if ( S_OK != hr )
    {
        LOG((RTC_ERROR, "CRTCClient::EnumerateWatchers - "
                            "could not initialize enumeration" ));
    
        delete p;
        return hr;
    }

    *ppEnum = p;
    
    LOG((RTC_TRACE, "CRTCClient::EnumerateWatchers exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_Watchers
//
// This is an IRTCClientPresence method that enumerates watchers on
// the client.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCClient::get_Watchers(
        IRTCCollection ** ppCollection
        )
{
    HRESULT hr;
    
    LOG((RTC_TRACE, "CRTCClient::get_Watchers - enter"));

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Watchers - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( ppCollection, sizeof(IRTCCollection *) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Watchers - "
                            "bad IRTCCollection pointer"));

        return E_POINTER;
    }

    if ( !m_fPresenceEnabled )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Watchers - "
                            "presence not enabled"));

        return RTC_E_PRESENCE_NOT_ENABLED;
    }

    //
    // Create the collection
    //
 
    CComObject< CRTCCollection< IRTCWatcher > > * p;
                          
    hr = CComObject< CRTCCollection< IRTCWatcher > >::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCClient::get_Watchers - "
                            "CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
        
        return hr;
    }

    //
    // Initialize the collection (adds a reference)
    //
    
    hr = p->Initialize(m_WatcherArray);

    if ( S_OK != hr )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Watchers - "
                            "could not initialize collection" ));
    
        delete p;
        return hr;
    }

    *ppCollection = p;

    LOG((RTC_TRACE, "CRTCClient::get_Watchers - exit S_OK"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_Watcher
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::get_Watcher(
            BSTR    bstrPresentityURI,
            IRTCWatcher **ppWatcher
            )
{
    
    HRESULT         hr;
    
    LOG((RTC_TRACE, "CRTCClient::get_Watcher - enter"));

    if ( IsBadWritePtr( ppWatcher, sizeof(IRTCWatcher *) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Watcher - "
                            "bad IRTCWatcher* pointer"));

        return E_POINTER;
    } 
    
    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Watcher - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadStringPtrW( bstrPresentityURI, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Watcher - "
                            "bad URI pointer"));

        return E_POINTER;
    } 

    if ( !m_fPresenceEnabled )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Watcher - "
                            "presence not enabled"));

        return RTC_E_PRESENCE_NOT_ENABLED;
    }

    hr = FindWatcherByURI(
        bstrPresentityURI,
        FALSE,
        ppWatcher);

    if( hr != S_OK )
    {
        hr = E_FAIL;
    }

    LOG((RTC_TRACE, "CRTCClient::get_Watcher - exit"));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::AddWatcher
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::InternalAddWatcher(   
            PCWSTR	  szPresentityURI,
            PCWSTR    szUserName,
            PCWSTR    szData,
            PCWSTR    szShutdownBlob,
            VARIANT_BOOL   fBlocked,
            VARIANT_BOOL   fPersistent,
            IRTCWatcher ** ppWatcher
            )
{
    HRESULT         hr;
    
    LOG((RTC_TRACE, "CRTCClient::InternalAddWatcher - enter"));

    //
    // Clean the presentity URI
    //

    PWSTR szCleanPresentityURI = NULL;

    AllocCleanSipString( szPresentityURI, &szCleanPresentityURI );

    if ( szCleanPresentityURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCClient::InternalAddWatcher - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    //
    // Don't allow duplicates
    //

    IRTCWatcher *pWatcher = NULL;

    hr = FindWatcherByURI(
        szCleanPresentityURI,
        FALSE,
        &pWatcher);

    if(hr == S_OK)
    {
        RtcFree( szCleanPresentityURI );
        szCleanPresentityURI = NULL;

        pWatcher->Release();
        
        LOG((RTC_ERROR, "CRTCClient::InternalAddWatcher - "
                            "duplicate watcher"));

        return E_FAIL;
    }

    pWatcher = NULL;

    //
    // Create a watcher
    //

    hr = InternalCreateWatcher(
         szCleanPresentityURI,        
         szUserName,
         szData,
         szShutdownBlob,
         fPersistent ? TRUE : FALSE,
         &pWatcher);

    RtcFree( szCleanPresentityURI );
    szCleanPresentityURI = NULL;

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCClient::InternalAddWatcher - "
                            "InternalCreateWatcher failed 0x%lx", hr));

        return hr;
    }

    //
    // Add the watcher to the array
    //

    BOOL fResult;

    fResult = m_WatcherArray.Add(pWatcher);

    if ( fResult == FALSE )
    {
        LOG((RTC_ERROR, "CRTCClient::InternalAddWatcher - "
                                    "out of memory"));
        
        pWatcher->Release();
        return E_OUTOFMEMORY;
    }

    CRTCWatcher *pCWatcher = reinterpret_cast<CRTCWatcher *>(pWatcher);

    pCWatcher->m_nState = fBlocked ? RTCWS_BLOCKED : RTCWS_ALLOWED;

    //
    // Make sure any existing SIP watchers are updated
    //
    pCWatcher->ChangeBlockedStatus(fBlocked ? WATCHER_BLOCKED : WATCHER_UNBLOCKED);

    //
    // Update storage
    //

    UpdatePresenceStorage();

    //
    // Should we return the watcher?
    //
    
    if ( ppWatcher != NULL )
    {
        *ppWatcher = pWatcher;
    }
    else
    {
        pWatcher->Release();
        pWatcher = NULL;
    }

    LOG((RTC_TRACE, "CRTCClient::InternalAddWatcher - exit"));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::AddWatcher
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCClient::AddWatcher(   
            BSTR	bstrPresentityURI,
            BSTR    bstrUserName,
            BSTR    bstrData,
			VARIANT_BOOL   fBlocked,
            VARIANT_BOOL   fPersistent,
            IRTCWatcher ** ppWatcher
            )
{    
    HRESULT         hr;
    
    LOG((RTC_TRACE, "CRTCClient::AddWatcher - enter"));
    
    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::AddWatcher - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // NULL is okay for ppWatcher
    //
    
    if ( (ppWatcher != NULL) &&
         IsBadWritePtr( ppWatcher, sizeof(IRTCWatcher *) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::AddWatcher - bad IRTCWatcher pointer"));

        return E_POINTER;
    }

    if ( IsBadStringPtrW( bstrPresentityURI, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::AddWatcher - "
                            "bad URI pointer"));

        return E_POINTER;
    } 

    if ( IsBadStringPtrW( bstrUserName, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::AddWatcher - "
                            "bad Name pointer"));

        return E_POINTER;
    } 

    if ( (bstrData != NULL) &&
         IsBadStringPtrW( bstrData, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::AddWatcher - "
                            "bad Data pointer"));

        return E_POINTER;
    } 

    if ( !m_fPresenceEnabled )
    {
        LOG((RTC_ERROR, "CRTCClient::AddWatcher - "
                            "presence not enabled"));

        return RTC_E_PRESENCE_NOT_ENABLED;
    }

    hr = InternalAddWatcher(   
            bstrPresentityURI,
            bstrUserName,
            bstrData,
            NULL,
			fBlocked,
            fPersistent,
            ppWatcher
            );

#ifdef DUMP_PRESENCE
    DumpWatchers("ADD WATCHER");
#endif

    LOG((RTC_TRACE, "CRTCClient::AddWatcher - exit"));

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::RemoveWatcher
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCClient::RemoveWatcher(   
            IRTCWatcher *pWatcher
            )
{
    HRESULT         hr;
    
    LOG((RTC_TRACE, "CRTCClient::RemoveWatcher - enter"));
    
    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::RemoveWatcher - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadReadPtr( pWatcher, sizeof( IRTCWatcher * ) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::RemoveWatcher - "
                            "bad IRTCWatcher pointer"));

        return E_POINTER;
    }

    if ( !m_fPresenceEnabled )
    {
        LOG((RTC_ERROR, "CRTCClient::RemoveWatcher - "
                            "presence not enabled"));

        return RTC_E_PRESENCE_NOT_ENABLED;
    }
    
    CRTCWatcher *pCWatcher   = reinterpret_cast<CRTCWatcher *>(pWatcher);

    // Block the watchers

    if( pCWatcher )
    {
        hr = pCWatcher->ChangeBlockedStatus(WATCHER_BLOCKED);
          
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCClient::RemoveWatcher - RemoveSIPWatcher failed 0x%lx", hr));
        }
    }
    
    // Remove from the watcher array
    // (it might have been removed as a side effect of ChangeBlockedStatus)
    
    m_WatcherArray.Remove(pWatcher);

    // If there's at least one remaining SIP watcher in *pCWatcher
    // add the object to the list of hidden watchers

    if(pCWatcher->m_SIPWatchers.GetSize()!=0)
    {
        BOOL fResult;

        fResult = m_HiddenWatcherArray.Add(pWatcher);

        if(!fResult)
        {
            // oom...
            // free everything.
            pCWatcher->RemoveSIPWatchers(FALSE);
        }
    }

    //
    // Update storage
    //

    UpdatePresenceStorage();

#ifdef DUMP_PRESENCE
    DumpWatchers("REMOVE WATCHER");
#endif

    LOG((RTC_TRACE, "CRTCClient::RemoveWatcher - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::SetLocalPresenceInfo
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCClient::SetLocalPresenceInfo(   
            RTC_PRESENCE_STATUS enStatus,
            BSTR bstrNotes
            )
{
    HRESULT         hr;
    
    LOG((RTC_TRACE, "CRTCClient::SetLocalPresenceInfo - enter"));
    
    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::SetLocalPresenceInfo - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( (bstrNotes != NULL) &&
         IsBadStringPtrW( bstrNotes, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCClient::SetLocalPresenceInfo - "
                            "bad string pointer"));

        return E_POINTER;
    }

    if ( !m_fPresenceEnabled )
    {
        LOG((RTC_ERROR, "CRTCClient::SetLocalPresenceInfo - "
                            "presence not enabled"));

        return RTC_E_PRESENCE_NOT_ENABLED;
    }

    SIP_PRESENCE_INFO   SipInfo;
    
    ZeroMemory(&SipInfo, sizeof(SipInfo));

    switch(enStatus)
    {
    case RTCXS_PRESENCE_OFFLINE:

        SipInfo.presenceStatus = BUDDY_OFFLINE;
        SipInfo.activeStatus = ACTIVE_STATUS_UNKNOWN;
        SipInfo.activeMsnSubstatus = MSN_SUBSTATUS_UNKNOWN;

        break;
    
    case RTCXS_PRESENCE_ONLINE:

        SipInfo.presenceStatus = BUDDY_ONLINE;
        SipInfo.activeStatus = DEVICE_ACTIVE;
        SipInfo.activeMsnSubstatus = MSN_SUBSTATUS_ONLINE;

        break;

    case RTCXS_PRESENCE_AWAY:

        SipInfo.presenceStatus = BUDDY_ONLINE;
        SipInfo.activeStatus = DEVICE_INACTIVE;
        SipInfo.activeMsnSubstatus = MSN_SUBSTATUS_AWAY;

        break;

    case RTCXS_PRESENCE_BUSY:

        SipInfo.presenceStatus = BUDDY_ONLINE;
        SipInfo.activeStatus = DEVICE_INUSE;
        SipInfo.activeMsnSubstatus = MSN_SUBSTATUS_BUSY;
        
        break;
        
    case RTCXS_PRESENCE_IDLE:

        SipInfo.presenceStatus = BUDDY_ONLINE;
        SipInfo.activeStatus = DEVICE_INACTIVE;
        SipInfo.activeMsnSubstatus = MSN_SUBSTATUS_IDLE;
        
        break;
    
    case RTCXS_PRESENCE_BE_RIGHT_BACK:

        SipInfo.presenceStatus = BUDDY_ONLINE;
        SipInfo.activeStatus = DEVICE_INACTIVE;
        SipInfo.activeMsnSubstatus = MSN_SUBSTATUS_BE_RIGHT_BACK;
        
        break;

    case RTCXS_PRESENCE_OUT_TO_LUNCH:

        SipInfo.presenceStatus = BUDDY_ONLINE;
        SipInfo.activeStatus = DEVICE_INACTIVE;
        SipInfo.activeMsnSubstatus = MSN_SUBSTATUS_OUT_TO_LUNCH;
        
        break;

    case RTCXS_PRESENCE_ON_THE_PHONE:

        SipInfo.presenceStatus = BUDDY_ONLINE;
        SipInfo.activeStatus = DEVICE_INUSE;
        SipInfo.activeMsnSubstatus = MSN_SUBSTATUS_ON_THE_PHONE;
        
        break;
        
    default:

        LOG((RTC_ERROR, "CRTCClient::SetLocalPresenceInfo - "
                            "invalid status %x", enStatus));

        return E_INVALIDARG;
    }

    // any text ?
    if( (bstrNotes != NULL) && wcscmp( bstrNotes, L"" ) )
    {
        WideCharToMultiByte(
            CP_UTF8,
            0,
            bstrNotes,
            -1,
            SipInfo.pstrSpecialNote,
            sizeof(SipInfo.pstrSpecialNote),
            NULL,
            NULL);
    }

    hr = m_pSipWatcherManager->SetPresenceInformation(&SipInfo);

    // cache this for IsIncomingSessionAuthorized function
    m_nLocalPresenceStatus = enStatus;

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCClient::SetLocalPresenceInfo - "
                            "error %x returned by m_pSipWatcherManager", hr));
    }

    LOG((RTC_TRACE, "CRTCClient::SetLocalPresenceInfo - exit"));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_OfferWatcherMode
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCClient::get_OfferWatcherMode(   
            RTC_OFFER_WATCHER_MODE * penMode
            )
{
    LOG((RTC_TRACE, "CRTCClient::get_OfferWatcherMode - enter"));
    
    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_OfferWatcherMode - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadWritePtr( penMode, sizeof(RTC_OFFER_WATCHER_MODE) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_OfferWatcherMode - "
                            "bad pointer"));

        return E_POINTER;
    }

    *penMode = m_nOfferWatcherMode;
    
    LOG((RTC_TRACE, "CRTCClient::get_OfferWatcherMode - exit"));
    
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::put_OfferWatcherMode
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCClient::put_OfferWatcherMode(   
            RTC_OFFER_WATCHER_MODE   enMode
            )
{
    LOG((RTC_TRACE, "CRTCClient::put_OfferWatcherMode - enter"));

    HRESULT hr;    

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::put_OfferWatcherMode - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if ( enMode != RTCOWM_OFFER_WATCHER_EVENT &&
         enMode != RTCOWM_AUTOMATICALLY_ADD_WATCHER )
    {
        LOG((RTC_ERROR, "CRTCClient::put_OfferWatcherMode - "
                            "bad argument"));

        return E_INVALIDARG;
    }

    // set the value
    m_nOfferWatcherMode = enMode;

    // save
    UpdatePresenceStorage();
    
    LOG((RTC_TRACE, "CRTCClient::put_OfferWatcherMode - exit"));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::get_PrivacyMode
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCClient::get_PrivacyMode(   
            RTC_PRIVACY_MODE * penMode
            )
{
    LOG((RTC_TRACE, "CRTCClient::get_PrivacyMode - enter"));
    
    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PrivacyMode - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    if ( IsBadWritePtr( penMode, sizeof(RTC_PRIVACY_MODE) ) )
    {
        LOG((RTC_ERROR, "CRTCClient::get_PrivacyMode - "
                            "bad pointer"));

        return E_POINTER;
    }

    *penMode = m_nPrivacyMode;
    
    LOG((RTC_TRACE, "CRTCClient::get_PrivacyMode - exit"));
    
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::put_PrivacyMode
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCClient::put_PrivacyMode(   
            RTC_PRIVACY_MODE   enMode
            )
{
    LOG((RTC_TRACE, "CRTCClient::put_PrivacyMode - enter"));
    
    HRESULT hr;    

    if ( m_enRtcState != RTC_STATE_INITIALIZED )
    {
        LOG((RTC_ERROR, "CRTCClient::put_PrivacyMode - "
                    "not initialized" ));

        return RTC_E_CLIENT_NOT_INITIALIZED;
    }

    //
    // Check the arguments
    //

    if (   enMode != RTCPM_BLOCK_LIST_EXCLUDED 
        && enMode != RTCPM_ALLOW_LIST_ONLY)
    {
        LOG((RTC_ERROR, "CRTCClient::put_PrivacyMode - "
                            "bad argument"));

        return E_INVALIDARG;
    }

    // set the value
    m_nPrivacyMode = enMode;

    // save
    UpdatePresenceStorage();
    
    LOG((RTC_TRACE, "CRTCClient::put_PrivacyMode - exit"));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::IsIncomingSessionAuthorized
//
// Authorizes the call if presence is enabled
//
/////////////////////////////////////////////////////////////////////////////

BOOL CRTCClient::IsIncomingSessionAuthorized(PCWSTR pszCallerURI)
{
    LOG((RTC_TRACE, "CRTCClient::IsIncomingSessionAuthorized - enter"));

    // 
    // If presence is disabled, the call is authorized
    if(!m_fPresenceEnabled)
    {
        LOG((RTC_TRACE, "CRTCClient::IsIncomingSessionAuthorized - "
            "presence disabled, so authorize the incoming session, exit"));
        
        return TRUE;
    }

    // Appear OFFLINE ?
    //
    if(m_nLocalPresenceStatus == RTCXS_PRESENCE_OFFLINE)
    {
        LOG((RTC_TRACE, "CRTCClient::IsIncomingSessionAuthorized - "
            "Client is offline, so reject the incoming session, exit"));
        
        return FALSE;
    }

    
    // search the caller in the list of watchers
    //
    IRTCWatcher *pWatcher = NULL;

    HRESULT     hr;

    hr = FindWatcherByURI(
        pszCallerURI,
        FALSE,
        &pWatcher);

    if(hr != S_OK)
    {
        // Watcher not found. Resolution is based on privacy mode
        if(m_nPrivacyMode == RTCPM_BLOCK_LIST_EXCLUDED)
        {
            LOG((RTC_TRACE, "CRTCClient::IsIncomingSessionAuthorized - "
                "Caller not in watcher list; authorize the incoming session, exit"));
        
            return TRUE;
        }
        else
        {
            LOG((RTC_TRACE, "CRTCClient::IsIncomingSessionAuthorized - "
                "Caller not in watcher list; reject the incoming session, exit"));
        
            return FALSE;
        }
    }

    // found the watcher. Ok, see if it is allowed.
    RTC_WATCHER_STATE  enState;

    hr = pWatcher->get_State(&enState);

    pWatcher->Release();
    pWatcher = NULL;

    if(hr != S_OK || enState != RTCWS_ALLOWED)
    {
        LOG((RTC_TRACE, "CRTCClient::IsIncomingSessionAuthorized - "
            "Watcher is not allowed; reject the incoming session, exit"));

        return FALSE;
    }

    LOG((RTC_TRACE, "CRTCClient::IsIncomingSessionAuthorized - "
            "Watcher not allowed; authorize the incoming session, exit"));

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::StartIntensityMonitor
//
// This is an IRTCClient method that starts the intensity monitoring.
// This should be called when the streaming has started.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::StartIntensityMonitor(LONG lMediaType)
{
    LOG((RTC_TRACE, "CRTCClient::StartIntensityMonitor - entered"));

    DWORD dwResult;
    HRESULT hr;

    if ( ( lMediaType != RTCMT_AUDIO_SEND ) && 
         ( lMediaType != RTCMT_AUDIO_RECEIVE )
       )
    {
        // We do not handle any other type

        LOG((RTC_INFO, "CRTCClient::StartIntensityMonitor - Can't handle "
                       "mediatype(%d).", lMediaType));
        return S_OK;
    }

    if(m_lActiveIntensity == 0)
    {
        // Try to start the timer
        DWORD dwID = (DWORD)SetTimer(m_hWnd, TID_INTENSITY, INTENSITY_POLL_INTERVAL, NULL);
        if(dwID==0)
        {
            dwResult = GetLastError();

            LOG((RTC_ERROR, "CRTCClient::StartIntensityMonitor - Failed "
                           "to start timer (%x).", dwResult));

            return HRESULT_FROM_WIN32(dwResult);
        }
    }

    if(lMediaType == RTCMT_AUDIO_SEND)
    {
        
        m_lActiveIntensity |= RTCMT_AUDIO_SEND;
        
        if(!m_pCaptureAudioCfg)
        {
            hr = GetAudioCfg(
                         RTCAD_MICROPHONE,
                         &m_pCaptureAudioCfg
                        );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::StartIntensityMonitor - "
                                    "GetAudioCfg(Capture) failed 0x%lx", hr));     

            }
        }

        m_uiMinCapture = 0;
        m_uiMaxCapture = 0;

        if(m_pCaptureAudioCfg)
        {
            m_pCaptureAudioCfg->GetAudioLevelRange(&m_uiMinCapture, &m_uiMaxCapture);
        }
    }
    
    else if(lMediaType == RTCMT_AUDIO_RECEIVE)
    {
        m_lActiveIntensity |= RTCMT_AUDIO_RECEIVE;

        if(!m_pRenderAudioCfg)
        {
            hr = GetAudioCfg(
                         RTCAD_SPEAKER,
                         &m_pRenderAudioCfg
                        );
            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCClient::StartIntensityMonitor - "
                                    "GetAudioCfg(Render) failed 0x%lx", hr));     

            }
        }

        m_uiMinRender = 0;
        m_uiMaxRender = 0;

        if(m_pRenderAudioCfg)
        {
            m_pRenderAudioCfg->GetAudioLevelRange(&m_uiMinRender, &m_uiMaxRender);
        }
    }
    
    LOG((RTC_TRACE, "CRTCClient::StartIntensityMonitor - exited"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::StopIntensityMonitor
//
// This is an IRTCClient method that stops the intensity monitoring
// This should be called when the streaming has ended.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCClient::StopIntensityMonitor(LONG lMediaType)
{
    LOG((RTC_TRACE, "CRTCClient::StopIntensityMonitor - entered"));

    DWORD dwResult;

    if ( ( lMediaType != RTCMT_AUDIO_SEND ) && 
         ( lMediaType != RTCMT_AUDIO_RECEIVE )
       )
    {
        // We do not handle any other type

        LOG((RTC_INFO, "CRTCClient::StartIntensityMonitor - Can't handle "
                       "mediatype(%d).", lMediaType));
        return S_OK;
    }

    if(lMediaType == RTCMT_AUDIO_SEND)
    {
        m_lActiveIntensity &= ~RTCMT_AUDIO_SEND;

        if(m_pCaptureAudioCfg)
        {
            m_pCaptureAudioCfg->Release();
            m_pCaptureAudioCfg = NULL;
        }

        CRTCIntensityEvent::FireEvent(this, 0, RTCAD_MICROPHONE, 0, 0);
    }
    
    if(lMediaType == RTCMT_AUDIO_RECEIVE)
    {
        m_lActiveIntensity &= ~RTCMT_AUDIO_RECEIVE;

        if(m_pRenderAudioCfg)
        {
            m_pRenderAudioCfg->Release();
            m_pRenderAudioCfg = NULL;
        }

        CRTCIntensityEvent::FireEvent(this, 0, RTCAD_SPEAKER, 0, 0);
    }

    if(m_lActiveIntensity == 0)
    {
        // Kill timer
        KillTimer(m_hWnd, TID_INTENSITY);
    }

    LOG((RTC_TRACE, "CRTCClient::StopIntensityMonitor - exited"));

    return S_OK;

}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCClient::OnIntensityTimer
//
/////////////////////////////////////////////////////////////////////////////

void CRTCClient::OnIntensityTimer()
{

    UINT uiCaptureLevel, uiRenderLevel;

    if(m_lActiveIntensity & RTCMT_AUDIO_RECEIVE)
    {
        uiRenderLevel = 0;

        if(m_pRenderAudioCfg)
        {
            m_pRenderAudioCfg->GetAudioLevel(&uiRenderLevel);
        }

        CRTCIntensityEvent::FireEvent(this, uiRenderLevel, RTCAD_SPEAKER, m_uiMinRender, m_uiMaxRender);
    }
    
    if(m_lActiveIntensity & RTCMT_AUDIO_SEND)
    {
        uiCaptureLevel = 0;

        // If the capture device is muted, fake the volume to 0
        if(!m_bCaptureDeviceMuted && m_pCaptureAudioCfg)
        {
             m_pCaptureAudioCfg->GetAudioLevel(&uiCaptureLevel);
        }

        CRTCIntensityEvent::FireEvent(this, uiCaptureLevel, RTCAD_MICROPHONE, m_uiMinCapture, m_uiMaxCapture);

    }
}


#ifdef DUMP_PRESENCE

void CRTCClient::DumpWatchers(PCSTR szString)
{
    ULONG l;

    IRTCWatcher **pCrt;
    IRTCWatcher **pEnd;

    LOG((RTC_INFO, ""));
    LOG((RTC_INFO, " !!!!!! WATCHER LIST - %s  !!!!!", szString));
    LOG((RTC_INFO, "VISIBLE"));

    for(pCrt = &m_WatcherArray[0], pEnd = pCrt + m_WatcherArray.GetSize();
        pCrt < pEnd;
        pCrt++)
    {
        CRTCWatcher *pCWatcher = static_cast<CRTCWatcher *>(*pCrt);

        LOG((RTC_INFO, "    %s  %s  %S", 
            pCWatcher->m_bPersistent ? "PERS" : "VOL ",
            pCWatcher->m_nState == 0 ? "UNKNOWN " :
          ( pCWatcher->m_nState == 1 ? "OFFERING" :
          ( pCWatcher->m_nState == 2 ? "ALLOWED " : "BLOCKED ")),
            pCWatcher->m_szPresentityURI));


        ISIPWatcher ** pSipCrt;
        ISIPWatcher ** pSipEnd;

        for(pSipCrt = &pCWatcher->m_SIPWatchers[0], pSipEnd = pSipCrt + pCWatcher->m_SIPWatchers.GetSize();
            pSipCrt < pSipEnd;
            pSipCrt ++)
        {
            LOG((RTC_INFO, "        SIP  watcher %p", 
                (*pSipCrt) ));
        }
    }

    LOG((RTC_INFO, "HIDDEN"));

    for(pCrt = &m_HiddenWatcherArray[0], pEnd = pCrt + m_HiddenWatcherArray.GetSize();
        pCrt < pEnd;
        pCrt++)
    {
        CRTCWatcher *pCWatcher = static_cast<CRTCWatcher *>(*pCrt);

        LOG((RTC_INFO, "                    %S", 
            pCWatcher->m_szPresentityURI));

        ISIPWatcher ** pSipCrt;
        ISIPWatcher ** pSipEnd;

        for(pSipCrt = &pCWatcher->m_SIPWatchers[0], pSipEnd = pSipCrt + pCWatcher->m_SIPWatchers.GetSize();
            pSipCrt < pSipEnd;
            pSipCrt ++)
        {
            LOG((RTC_INFO, "        SIP  watcher %p", 
                (*pSipCrt) ));
        }
    }
    LOG((RTC_INFO, " END WATCHER LIST - %s ", szString));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\rtcprofile.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCProfile.cpp

Abstract:

    Implementation of the CRTCProfile class

--*/

#include "stdafx.h"
/*
#include <wincrypt.h>
*/

#define RTCFREE(x) if(x){RtcFree(x);x=NULL;}

/*
const WCHAR  *      g_szMasterKeyWithColon = L"Microsoft Real-Time Communications authorized domain:";
const WCHAR  *      g_szKeyContainer = L"Microsoft.RTCContainer";

const BYTE          g_PublicKeyBlob[] = 
{
0x06, 0x02, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x52, 0x53, 0x41, 0x31, 0x00, 0x02, 0x00, 0x00, // .....$..RSA1....
0x01, 0x00, 0x01, 0x00, 0x4b, 0x5e, 0xb9, 0x9a, 0xff, 0x4b, 0x25, 0xf4, 0x17, 0x4f, 0xde, 0x9d, // ....K^...K%..O..
0xb2, 0x49, 0x68, 0x85, 0x64, 0xb6, 0x6a, 0xe7, 0x9c, 0x40, 0x97, 0x40, 0x62, 0x05, 0x4a, 0x9d, // .Ih.d.j..@.@b.J.
0xff, 0xe5, 0x4a, 0x97, 0x10, 0x7b, 0x59, 0x8a, 0xb8, 0x51, 0x9e, 0xd5, 0xe1, 0x51, 0x7a, 0x2b, // ..J..{Y..Q...Qz+
0x4e, 0x50, 0xb4, 0x2e, 0x57, 0x81, 0x70, 0x15, 0x2b, 0xf1, 0xbf, 0xed, 0x40, 0xe8, 0xb7, 0x6d, // NP..W.p.+...@..m
0xe9, 0x4c, 0x8b, 0xb6                                                                          // .L..
};
*/

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::FinalConstruct
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::FinalConstruct()
{
    LOG((RTC_TRACE, "CRTCProfile::FinalConstruct - enter"));

#if DBG
    m_pDebug = (PWSTR) RtcAlloc( 1 );
#endif

    ZeroMemory(&m_Provision, sizeof(PROF_PROVISION));
    ZeroMemory(&m_Provider, sizeof(PROF_PROVIDER));
    ZeroMemory(&m_Client, sizeof(PROF_CLIENT));
    ZeroMemory(&m_User, sizeof(PROF_USER));

    LOG((RTC_TRACE, "CRTCProfile::FinalConstruct - exit S_OK"));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCProfile::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCProfile::FinalRelease - enter"));

    FreeProvision(&m_Provision);
    FreeProvider(&m_Provider);
    FreeClient(&m_Client);
    FreeUser(&m_User);

    for (int n=0; n < m_ServerArray.GetSize(); n++)
    {
        FreeServer(&m_ServerArray[n]);
    }

    m_ServerArray.Shutdown();

/*
    for (int n=0; n < m_AccessControlArray.GetSize(); n++)
    {
        FreeAccessControl(&m_AccessControlArray[n]);
    }

    m_AccessControlArray.Shutdown();
*/

    RTCFREE(m_szProfileXML);

    if ( m_pSipStack != NULL )
    {
        m_pSipStack->Release();
        m_pSipStack = NULL;
    }

    if ( m_pCClient != NULL )
    {
        m_pCClient->Release();
        m_pCClient = NULL;
    }

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    LOG((RTC_TRACE, "CRTCProfile::FinalRelease - exit"));
}   

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::InternalAddRef
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CRTCProfile::InternalAddRef()
{
    DWORD dwR;

    dwR = InterlockedIncrement(&m_dwRef);

    LOG((RTC_INFO, "CRTCProfile::InternalAddRef - dwR %d", dwR));

    return dwR;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::InternalRelease
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CRTCProfile::InternalRelease()
{
    DWORD               dwR;
    
    dwR = InterlockedDecrement(&m_dwRef);

    LOG((RTC_INFO, "CRTCProfile::InternalRelease - dwR %d", dwR));

    return dwR;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::InitializeFromString
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCProfile::InitializeFromString(
                                  BSTR bstrProfileXML,
                                  CRTCClient * pCClient,
                                  ISipStack * pSipStack
                                 )
{
    LOG((RTC_TRACE, "CRTCProfile::InitializeFromString - enter"));

    HRESULT hr;

    //
    // Parse the XML
    // 

    IXMLDOMDocument * pXMLDoc = NULL;

    hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER,
            IID_IXMLDOMDocument, (void**)&pXMLDoc );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::InitializeFromString - "
                            "CoCreateInstance failed 0x%lx", hr));

        return hr;
    }

    VARIANT_BOOL bSuccess;

    hr = pXMLDoc->loadXML( bstrProfileXML, &bSuccess );

    if ( S_OK != hr )
    {
        LOG((RTC_ERROR, "CRTCProfile::InitializeFromString - "
                            "loadXML failed 0x%lx", hr));

        if ( S_FALSE == hr )
        {
            hr = E_FAIL;
        }

        pXMLDoc->Release();

        return hr;
    }

    hr = ParseXMLDOMDocument( pXMLDoc );

    pXMLDoc->Release();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::InitializeFromString - "
                            "ParseXMLDOMDocument failed 0x%lx", hr));

        return hr;
    }

    //
    // Store the XML
    //

    m_szProfileXML = (PWSTR)RtcAlloc( sizeof(WCHAR) * (lstrlenW(bstrProfileXML) + 1) );

    if ( m_szProfileXML == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::InitializeFromString - "
                            "out of memory"));
                            
        return E_OUTOFMEMORY;
    }

    lstrcpyW( m_szProfileXML, bstrProfileXML ); 

    //
    // Create the GUID
    //

    hr = CoCreateGuid( &m_ProfileGuid );
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::InitializeFromString - "
                            "CoCreateGuid failed 0x%lx", hr));

        return hr;
    }

    //
    // Addref the SIP stack and client
    //

    m_pSipStack = pSipStack;
    if (m_pSipStack)
    {
        m_pSipStack->AddRef();
    }

    m_pCClient = pCClient;
    if (m_pCClient)
    {
        m_pCClient->AddRef();
    }

    m_fValid = TRUE;
            
    LOG((RTC_TRACE, "CRTCProfile::InitializeFromString - exit S_OK"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::GetSipProviderProfile
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::GetSipProviderProfile(
                                   SIP_PROVIDER_PROFILE * pProfile,
                                   long lRegisterFlags
                                  )
{
    LOG((RTC_TRACE, "CRTCProfile::GetSipProviderProfile - enter"));

    //
    // First zero the memory
    //

    ZeroMemory( pProfile, sizeof(SIP_PROVIDER_PROFILE) );

    //
    // Fill in the GUID
    //

    CopyMemory( &(pProfile->ProviderID), &m_ProfileGuid, sizeof(GUID) );

    //
    // Default this flag to zero
    //

    pProfile->lRegisterAccept = 0;

    if ( lRegisterFlags )
    {
        //
        // For each server structure gather the needed info
        //

        for (int n=0; n < m_ServerArray.GetSize(); n++)
        {
            if ( m_ServerArray[n].fRegistrar == TRUE )
            {
                //
                // Found a registrar server
                //

                //
                // Fill in the server info
                //

                pProfile->Registrar.ServerAddress = 
                    RtcAllocString( m_ServerArray[n].szAddr );

                if ( pProfile->Registrar.ServerAddress == NULL )
                {
                    LOG((RTC_ERROR, "CRTCProfile::GetSipProviderProfile - "
                        "out of memory"));

                    return E_OUTOFMEMORY;
                }

                pProfile->Registrar.TransportProtocol = 
                    m_ServerArray[n].enProtocol;

                pProfile->Registrar.AuthProtocol =
                    m_ServerArray[n].enAuth;

                LOG((RTC_INFO, "CRTCProfile::GetSipProviderProfile - "
                                "Got a REGISTRAR server"));

                if ( lRegisterFlags & RTCRF_REGISTER_INVITE_SESSIONS )
                {
                    pProfile->lRegisterAccept |= 
                        SIP_REGISTER_ACCEPT_INVITE |
                        SIP_REGISTER_ACCEPT_OPTIONS |
                        SIP_REGISTER_ACCEPT_BYE |
                        SIP_REGISTER_ACCEPT_CANCEL| 
                        SIP_REGISTER_ACCEPT_ACK;
                }

                if ( lRegisterFlags & RTCRF_REGISTER_MESSAGE_SESSIONS )
                {
                    pProfile->lRegisterAccept |= 
                        SIP_REGISTER_ACCEPT_MESSAGE |
                        SIP_REGISTER_ACCEPT_INFO |
                        SIP_REGISTER_ACCEPT_OPTIONS |
                        SIP_REGISTER_ACCEPT_BYE |
                        SIP_REGISTER_ACCEPT_CANCEL;
                }

                if ( lRegisterFlags & RTCRF_REGISTER_PRESENCE )
                {
                    pProfile->lRegisterAccept |= 
                        SIP_REGISTER_ACCEPT_SUBSCRIBE |
                        SIP_REGISTER_ACCEPT_OPTIONS |
                        SIP_REGISTER_ACCEPT_NOTIFY;
                }

                break;
            }
        }
    }

    //
    // Get the user strings
    //

    if ( m_User.szAccount )
    {
        pProfile->UserCredentials.Username =
            RtcAllocString( m_User.szAccount );

        if ( pProfile->UserCredentials.Username == NULL )
        {
            LOG((RTC_ERROR, "CRTCProfile::GetSipProviderProfile - "
                "out of memory"));

            return E_OUTOFMEMORY;
        }
    }

    if ( m_User.szPassword )
    {
        pProfile->UserCredentials.Password =
            RtcAllocString( m_User.szPassword );

        if ( pProfile->UserCredentials.Password == NULL )
        {
            LOG((RTC_ERROR, "CRTCProfile::GetSipProviderProfile - "
                "out of memory"));

            return E_OUTOFMEMORY;
        }
    }

    if ( m_User.szUri )
    {
        pProfile->UserURI =
            RtcAllocString( m_User.szUri );

        if ( pProfile->UserURI == NULL )
        {
            LOG((RTC_ERROR, "CRTCProfile::GetSipProviderProfile - "
                "out of memory"));

            return E_OUTOFMEMORY;
        }
    }

    if ( m_User.szRealm )
    {
        pProfile->Realm =
            RtcAllocString( m_User.szRealm );

        if ( pProfile->Realm == NULL )
        {
            LOG((RTC_ERROR, "CRTCProfile::GetSipProviderProfile - "
                "out of memory"));

            return E_OUTOFMEMORY;
        }
    }
    
    LOG((RTC_TRACE, "CRTCProfile::GetSipProviderProfile - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::FreeSipProviderProfile
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::FreeSipProviderProfile(
                                    SIP_PROVIDER_PROFILE * pProfile
                                   )
{
    LOG((RTC_TRACE, "CRTCProfile::FreeSipProviderProfile[%p]", pProfile));

    //
    // Free server info
    //

    FreeSipServerInfo( &(pProfile->Registrar) );

    //
    // Free all the strings
    //

    RTCFREE( pProfile->UserCredentials.Username );
    RTCFREE( pProfile->UserCredentials.Password );
    RTCFREE( pProfile->UserURI );
    RTCFREE( pProfile->Realm );

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::GetSipProxyServerInfo
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::GetSipProxyServerInfo(
                                   long lSessionType,
                                   SIP_SERVER_INFO * pProxy
                                  )
{
    LOG((RTC_TRACE, "CRTCProfile::GetSipProxyServerInfo - enter"));

    //
    // First zero the memory
    //

    ZeroMemory( pProxy, sizeof(SIP_SERVER_INFO) );

    //
    // For each server structure gather the needed info
    //

    for (int n=0; n < m_ServerArray.GetSize(); n++)
    {
        if ( m_ServerArray[n].fRegistrar == FALSE )
        {
            //
            // Found a proxy server
            //

            if ( m_ServerArray[n].lSessions & lSessionType )
            {
                //
                // This proxy server supports the desired session type
                //

                //
                // Fill in the server info
                //

                pProxy->ServerAddress = 
                    RtcAllocString( m_ServerArray[n].szAddr );

                if ( pProxy->ServerAddress == NULL )
                {
                    LOG((RTC_ERROR, "CRTCProfile::GetSipProxyServerInfo - "
                        "out of memory"));

                    return E_OUTOFMEMORY;
                }

                pProxy->IsServerAddressSIPURI = FALSE;

                pProxy->TransportProtocol = 
                    m_ServerArray[n].enProtocol;

                pProxy->AuthProtocol =
                    m_ServerArray[n].enAuth;

                LOG((RTC_INFO, "CRTCProfile::GetSipProxyServerInfo - "
                                "Got a PROXY server"));

                return S_OK;
            }
        }
    }

    LOG((RTC_TRACE, "CRTCProfile::GetSipProxyServerInfo - "
                    "no proxy found for that session type"));

    return E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::FreeSipServerInfo
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::FreeSipServerInfo(
                               SIP_SERVER_INFO * pServerInfo
                              )
{
    LOG((RTC_TRACE, "CRTCProfile::FreeSipServerInfo[%p]", pServerInfo));

    //
    // Free all the strings
    //

    RTCFREE( pServerInfo->ServerAddress );

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::GetRealm
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCProfile::GetRealm(
        BSTR * pbstrRealm
        )
{
    LOG((RTC_TRACE, "CRTCProfile::GetRealm - enter"));

    if ( IsBadWritePtr( pbstrRealm, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::GetRealm - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::GetRealm - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    if ( m_User.szRealm == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::GetRealm - "
                            "no value"));

        return E_FAIL;
    }
    
    *pbstrRealm = SysAllocString( m_User.szRealm );
    
    if ( *pbstrRealm == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::GetRealm - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::GetRealm - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::GetCredentials
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::GetCredentials(
                     BSTR * pbstrUserAccount,
                     BSTR * pbstrUserPassword,
                     SIP_AUTH_PROTOCOL *pAuth
                     )
{
    LOG((RTC_TRACE, "CRTCProfile::GetCredentials - enter"));

    if ( IsBadWritePtr( pbstrUserAccount, sizeof(BSTR) ) ||
         IsBadWritePtr( pbstrUserPassword, sizeof(BSTR) ) ||
         IsBadWritePtr( pAuth, sizeof(SIP_AUTH_PROTOCOL) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::GetCredentials - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::GetCredentials - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    //
    // Get the account
    //

    if ( m_User.szAccount == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::GetCredentials - "
                            "no account value"));

        return E_FAIL;
    }

    if ( m_User.szAccount != NULL )
    {
        *pbstrUserAccount = SysAllocString( m_User.szAccount );

        if ( *pbstrUserAccount == NULL )
        {
            LOG((RTC_ERROR, "CRTCProfile::GetCredentials - "
                                "out of memory"));

            return E_OUTOFMEMORY;
        }
    }

    //
    // Get the password
    //

    if ( m_User.szPassword == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::GetCredentials - "
                            "no password value"));

        SysFreeString( *pbstrUserAccount );
        *pbstrUserAccount = NULL;

        return E_FAIL;
    }

    if ( m_User.szPassword != NULL )
    {
        *pbstrUserPassword = SysAllocString( m_User.szPassword );

        if ( *pbstrUserPassword == NULL )
        {
            LOG((RTC_ERROR, "CRTCProfile::GetCredentials - "
                                "out of memory"));

            SysFreeString( *pbstrUserAccount );
            *pbstrUserAccount = NULL;

            return E_OUTOFMEMORY;
        }
    }

    //
    // Get the auth protocol, try proxies first
    //

    for (int n=0; n < m_ServerArray.GetSize(); n++)
    {
        if ( m_ServerArray[n].fRegistrar == FALSE )
        {
            //
            // Found a proxy server
            //

            if ( m_ServerArray[n].lSessions & RTCSI_PC_TO_PC )
            {
                //
                // This proxy server supports the desired session type
                //

                *pAuth = m_ServerArray[n].enAuth;

                LOG((RTC_INFO, "CRTCProfile::GetCredentials - "
                                "Got a PROXY server"));

                return S_OK;
            }
        }
    }

    //
    // Get the auth protocol, try registrars next
    //

    for (int n=0; n < m_ServerArray.GetSize(); n++)
    {
        if ( m_ServerArray[n].fRegistrar == TRUE )
        {
            //
            // Found a registar server
            //

            *pAuth = m_ServerArray[n].enAuth;

            LOG((RTC_INFO, "CRTCProfile::GetCredentials - "
                            "Got a REGISTRAR server"));

            return S_OK;
        }
    }

    LOG((RTC_TRACE, "CRTCProfile::GetCredentials - "
                        "auth protocol not found"));

    return E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::ParseXMLDOMElementForAttribute
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::ParseXMLDOMElementForAttribute(
                        IXMLDOMElement * pElement,
                        PCWSTR szAttrib,
                        BOOL fRequired,
                        PWSTR * szValue
                        )
{
    HRESULT hr;
    CComVariant var;

    hr = pElement->getAttribute( CComBSTR(szAttrib), &var );

    if ( hr == S_FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMElementForAttribute - "
                            "%ws=NULL", szAttrib));

        if ( fRequired )
        {
            LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMElementForAttribute - "
                            "required attribute missing"));

            hr = E_FAIL;
        }

        return hr;
    }

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMElementForAttribute - "
                            "getAttribute failed 0x%lx", hr));

        return hr;
    }

    if ( var.vt != VT_BSTR )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMElementForAttribute - "
                            "not a string"));

        return E_FAIL;
    }

    *szValue = RtcAllocString( var.bstrVal );

    if ( *szValue == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMElementForAttribute - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMElementForAttribute - "
                        "%ws=\"%ws\"", szAttrib, *szValue));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::ParseXMLDOMNodeForData
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::ParseXMLDOMNodeForData(
                            IXMLDOMNode * pNode,
                            PWSTR * szValue
                            )
{
    IXMLDOMNode * pData = NULL;
    HRESULT hr;

    hr = pNode->selectSingleNode( CComBSTR(_T("data")), &pData );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForData - "
                            "selectSingleNode(data) failed 0x%lx", hr));

        return hr;
    }

    if ( hr == S_FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForData - "
                            "data=NULL"));

        return hr;
    }

    BSTR bstrData;

    hr = pData->get_xml( &bstrData );

    pData->Release();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForData - "
                        "get_xml failed 0x%lx", hr));

        return hr;
    }

    *szValue = RtcAllocString( bstrData );

    SysFreeString( bstrData );

    if ( *szValue == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForData - "
                        "out of memory"));       

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMNodeForData - "
                        "data=\"%ws\"", *szValue));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::ParseXMLDOMNodeForProvision
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCProfile::ParseXMLDOMNodeForProvision(
                        IXMLDOMNode * pNode,
                        PROF_PROVISION * pStruct
                        )
{
    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMNodeForProvision - enter"));

    ZeroMemory( pStruct, sizeof(PROF_PROVISION) );

    IXMLDOMElement * pElement = NULL;
    HRESULT hr;

    hr = pNode->QueryInterface( IID_IXMLDOMElement, (void**)&pElement );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForProvision - "
                            "QueryInterface failed 0x%lx", hr));

        return hr;
    }

    //
    // uri
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"key", TRUE, &pStruct->szKey );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForProvision - "
                            "ParseXMLDOMElementForAttribute(key) failed 0x%lx", hr));

        pElement->Release();

        return RTC_E_PROFILE_NO_KEY;
    }

    //
    // name
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"name", TRUE, &pStruct->szName );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForProvision - "
                            "ParseXMLDOMElementForAttribute(name) failed 0x%lx", hr));

        pElement->Release();

        return RTC_E_PROFILE_NO_NAME;
    }

    //
    // expires
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"expires", FALSE, &pStruct->szExpires );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForProvision - "
                            "ParseXMLDOMElementForAttribute(expires) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    pElement->Release();

    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMNodeForProvision - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::ParseXMLDOMNodeForProvider
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCProfile::ParseXMLDOMNodeForProvider(
                        IXMLDOMNode * pNode,
                        PROF_PROVIDER * pStruct
                        )
{
    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMNodeForProvider - enter"));

    ZeroMemory( pStruct, sizeof(PROF_PROVIDER) );

    IXMLDOMElement * pElement = NULL;
    HRESULT hr;

    hr = pNode->QueryInterface( IID_IXMLDOMElement, (void**)&pElement );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForProvider - "
                            "QueryInterface failed 0x%lx", hr));

        return hr;
    }

    //
    // name
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"name", FALSE, &pStruct->szName );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForProvider - "
                            "ParseXMLDOMElementForAttribute(name) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    //
    // homepage
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"homepage", FALSE, &pStruct->szHomepage );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForProvider - "
                            "ParseXMLDOMElementForAttribute(homepage) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    //
    // helpdesk
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"helpdesk", FALSE, &pStruct->szHelpdesk );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForProvider - "
                            "ParseXMLDOMElementForAttribute(helpdesk) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    //
    // personal
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"personal", FALSE, &pStruct->szPersonal );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForProvider - "
                            "ParseXMLDOMElementForAttribute(personal) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    //
    // calldisplay
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"calldisplay", FALSE, &pStruct->szCallDisplay );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForProvider - "
                            "ParseXMLDOMElementForAttribute(calldisplay) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    //
    // idledisplay
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"idledisplay", FALSE, &pStruct->szIdleDisplay );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForProvider - "
                            "ParseXMLDOMElementForAttribute(idledisplay) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    pElement->Release();

    //
    // data
    //

    hr = ParseXMLDOMNodeForData( pNode, &pStruct->szData );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForProvider - "
                            "ParseXMLDOMNodeForData failed 0x%lx", hr));

        return hr;
    }

    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMNodeForProvider - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::ParseXMLDOMNodeForClient
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCProfile::ParseXMLDOMNodeForClient(
                        IXMLDOMNode * pNode,
                        PROF_CLIENT * pStruct
                        )
{
    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMNodeForClient - enter"));

    ZeroMemory( pStruct, sizeof(PROF_CLIENT) );

    IXMLDOMElement * pElement = NULL;
    HRESULT hr;

    hr = pNode->QueryInterface( IID_IXMLDOMElement, (void**)&pElement );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForClient - "
                            "QueryInterface failed 0x%lx", hr));

        return hr;
    }

    //
    // name
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"name", TRUE, &pStruct->szName );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForClient - "
                            "ParseXMLDOMElementForAttribute(name) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    //
    // banner
    //

    PWSTR szBanner;

    hr = ParseXMLDOMElementForAttribute( pElement, L"banner", FALSE, &szBanner );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForClient - "
                            "ParseXMLDOMElementForAttribute(banner) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    if ( hr == S_OK )
    {
        if ( _wcsicmp( szBanner, L"true" ) == 0 )
        {
            pStruct->fBanner = TRUE;
        }
        else if ( _wcsicmp( szBanner, L"false" ) == 0 )
        {
            pStruct->fBanner = FALSE;
        }
        else
        {
            LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForClient - "
                            "unknown banner"));

            RTCFREE(szBanner);
            pElement->Release();

            return E_FAIL;
        }

        RTCFREE(szBanner);
    }

    //
    // minver
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"minver", FALSE, &pStruct->szMinVer );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForClient - "
                            "ParseXMLDOMElementForAttribute(minver) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    //
    // curver
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"curver", FALSE, &pStruct->szCurVer );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForClient - "
                            "ParseXMLDOMElementForAttribute(curver) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    //
    // updateuri
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"updateuri", FALSE, &pStruct->szUpdateUri );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForClient - "
                            "ParseXMLDOMElementForAttribute(updateuri) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    pElement->Release();

    //
    // data
    //

    hr = ParseXMLDOMNodeForData( pNode, &pStruct->szData );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForClient - "
                            "ParseXMLDOMNodeForData failed 0x%lx", hr));

        return hr;
    }

    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMNodeForClient - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::ParseXMLDOMNodeForUser
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCProfile::ParseXMLDOMNodeForUser(
                        IXMLDOMNode * pNode,
                        PROF_USER * pStruct
                        )
{
    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMNodeForUser - enter"));

    ZeroMemory( pStruct, sizeof(PROF_USER) );

    IXMLDOMElement * pElement = NULL;
    HRESULT hr;

    hr = pNode->QueryInterface( IID_IXMLDOMElement, (void**)&pElement );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForUser - "
                            "QueryInterface failed 0x%lx", hr));

        return hr;
    }

    //
    // account
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"account", FALSE, &pStruct->szAccount );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForUser - "
                            "ParseXMLDOMElementForAttribute(account) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    //
    // name
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"name", FALSE, &pStruct->szName );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForUser - "
                            "ParseXMLDOMElementForAttribute(name) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    //
    // uri
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"uri", TRUE, &pStruct->szUri );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForUser - "
                            "ParseXMLDOMElementForAttribute(uri) failed 0x%lx", hr));

        pElement->Release();

        return RTC_E_PROFILE_NO_USER_URI;
    }

    //
    // password
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"password", FALSE, &pStruct->szPassword );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForUser - "
                            "ParseXMLDOMElementForAttribute(password) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    //
    // realm
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"realm", FALSE, &pStruct->szRealm );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForUser - "
                            "ParseXMLDOMElementForAttribute(realm) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    pElement->Release();

    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMNodeForUser - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::ParseXMLDOMNodeForServer
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::ParseXMLDOMNodeForServer(
                        IXMLDOMNode * pNode,
                        PROF_SERVER * pStruct
                        )
{
    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMNodeForServer - enter"));

    ZeroMemory( pStruct, sizeof(PROF_SERVER) );

    IXMLDOMElement * pElement = NULL;
    HRESULT hr;

    hr = pNode->QueryInterface( IID_IXMLDOMElement, (void**)&pElement );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForServer - "
                            "QueryInterface failed 0x%lx", hr));

        return hr;
    }

    //
    // addr
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"addr", TRUE, &pStruct->szAddr );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForServer - "
                            "ParseXMLDOMElementForAttribute(addr) failed 0x%lx", hr));

        pElement->Release();

        return RTC_E_PROFILE_NO_SERVER_ADDRESS;
    }

/*
    BOOL fMatch = FALSE;

    for ( int n=0; n < m_AccessControlArray.GetSize(); n++ )
    {
        if ( IsMatchingAddress( pStruct->szAddr, m_AccessControlArray[n].szDomain ) )
        {
            fMatch = TRUE;

            break;
        }
    }

    if ( !fMatch )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForServer - "
                            "server address does not match an authorized domain"));

        pElement->Release();

        return RTC_E_PROFILE_SERVER_UNAUTHORIZED;
    }
*/

    //
    // protocol
    //

    PWSTR szProtocol;

    hr = ParseXMLDOMElementForAttribute( pElement, L"protocol", TRUE, &szProtocol );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForServer - "
                            "ParseXMLDOMElementForAttribute(protocol) failed 0x%lx", hr));

        pElement->Release();

        return RTC_E_PROFILE_NO_SERVER_PROTOCOL;
    }

    if ( _wcsicmp( szProtocol, L"udp" ) == 0 )
    {
        pStruct->enProtocol = SIP_TRANSPORT_UDP;
    }
    else if ( _wcsicmp( szProtocol, L"tcp" ) == 0 )
    {
        pStruct->enProtocol = SIP_TRANSPORT_TCP;
    }
    else if ( _wcsicmp( szProtocol, L"tls" ) == 0 )
    {
        pStruct->enProtocol = SIP_TRANSPORT_SSL;
    }
    else
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForServer - "
                        "unknown protocol"));

        RTCFREE(szProtocol);
        pElement->Release();

        return RTC_E_PROFILE_INVALID_SERVER_PROTOCOL;
    }

    RTCFREE(szProtocol);

    //
    // auth
    //

    PWSTR szAuth;

    hr = ParseXMLDOMElementForAttribute( pElement, L"auth", FALSE, &szAuth );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForServer - "
                            "ParseXMLDOMElementForAttribute(auth) failed 0x%lx", hr));

        pElement->Release();

        return hr;
    }

    if ( hr == S_OK )
    {
        if ( _wcsicmp( szAuth, L"basic" ) == 0 )
        {
            if ( pStruct->enProtocol != SIP_TRANSPORT_SSL )
            {
                LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForServer - "
                            "cannot use basic auth without TLS"));

                RTCFREE(szAuth);
                pElement->Release();

                return RTC_E_PROFILE_INVALID_SERVER_AUTHMETHOD;
            }

            pStruct->enAuth = SIP_AUTH_PROTOCOL_BASIC;
        }
        else if ( _wcsicmp( szAuth, L"digest" ) == 0 )
        {
            pStruct->enAuth = SIP_AUTH_PROTOCOL_MD5DIGEST;
        }
        /*
        else if ( _wcsicmp( szAuth, L"ntlm" ) == 0 )
        {
            pStruct->enAuth = SIP_AUTH_PROTOCOL_NTLM;
        }
        else if ( _wcsicmp( szAuth, L"kerberos" ) == 0 )
        {
            pStruct->enAuth = SIP_AUTH_PROTOCOL_KERBEROS;
        }
        else if ( _wcsicmp( szAuth, L"cert" ) == 0 )
        {
            pStruct->enAuth = SIP_AUTH_PROTOCOL_CERT;
        }
        */
        else
        {
            LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForServer - "
                            "unknown auth"));

            RTCFREE(szAuth);
            pElement->Release();

            return RTC_E_PROFILE_INVALID_SERVER_AUTHMETHOD;
        }

        RTCFREE(szAuth);
    }
    else
    {
        pStruct->enAuth = SIP_AUTH_PROTOCOL_NONE;
    }

    //
    // role
    //

    PWSTR szRole;

    hr = ParseXMLDOMElementForAttribute( pElement, L"role", TRUE, &szRole );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForServer - "
                            "ParseXMLDOMElementForAttribute(role) failed 0x%lx", hr));

        pElement->Release();

        return RTC_E_PROFILE_INVALID_SERVER_ROLE;
    }

    if ( _wcsicmp( szRole, L"proxy" ) == 0 )
    {
        pStruct->fRegistrar = FALSE;
    }
    else if ( _wcsicmp( szRole, L"registrar" ) == 0 )
    {
        pStruct->fRegistrar = TRUE;
    }        
    else
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForServer - "
                        "unknown role"));

        RTCFREE(szRole);
        pElement->Release();

        return RTC_E_PROFILE_INVALID_SERVER_ROLE;
    }

    RTCFREE(szRole);

    pElement->Release();

    //
    // session
    //

    IXMLDOMNodeList * pNodeList;
    IXMLDOMNode * pSession;
    long lSession;

    pStruct->lSessions = 0;

    hr = pNode->selectNodes( CComBSTR(_T("session")), &pNodeList );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForServer - "
                            "selectNodes(session) failed 0x%lx", hr));

        return hr;
    }
    
    while ( pNodeList->nextNode( &pSession ) == S_OK )
    {
        hr = ParseXMLDOMNodeForSession( pSession, &lSession );

        pSession->Release();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForServer - "
                            "ParseXMLDOMNodeForSession failed 0x%lx", hr));

            pNodeList->Release();

            return hr;
        }

        pStruct->lSessions |= lSession;
    }

    pNodeList->Release();

    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMNodeForServer - exit"));

    return S_OK;
}

/*
/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::ParseXMLDOMNodeForAccessControl
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::ParseXMLDOMNodeForAccessControl(
                        IXMLDOMNode * pNode,
                        PROF_ACCESSCONTROL * pStruct
                        )
{
    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMNodeForAccessControl - enter"));

    ZeroMemory( pStruct, sizeof(PROF_ACCESSCONTROL) );

    IXMLDOMElement * pElement = NULL;
    HRESULT hr;

    hr = pNode->QueryInterface( IID_IXMLDOMElement, (void**)&pElement );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForAccessControl - "
                            "QueryInterface failed 0x%lx", hr));

        return hr;
    }

    //
    // domain
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"domain", TRUE, &pStruct->szDomain );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForAccessControl - "
                            "ParseXMLDOMElementForAttribute(domain) failed 0x%lx", hr));

        pElement->Release();

        return RTC_E_PROFILE_NO_ACCESSCONTROL_DOMAIN;
    }

    //
    // sig
    //

    hr = ParseXMLDOMElementForAttribute( pElement, L"sig", TRUE, &pStruct->szSig );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForAccessControl - "
                            "ParseXMLDOMElementForAttribute(sig) failed 0x%lx", hr));

        pElement->Release();

        return RTC_E_PROFILE_NO_ACCESSCONTROL_SIGNATURE;
    }

    pElement->Release();

    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMNodeForAccessControl - exit"));

    return S_OK;
}
*/

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::ParseXMLDOMNodeForSession
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::ParseXMLDOMNodeForSession(
                        IXMLDOMNode * pNode,
                        long * plSession
                        )
{
    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMNodeForSession - enter"));

    IXMLDOMElement * pElement = NULL;
    HRESULT hr;

    hr = pNode->QueryInterface( IID_IXMLDOMElement, (void**)&pElement );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForSession - "
                            "QueryInterface failed 0x%lx", hr));

        return hr;
    }

    //
    // party
    //

    BOOL fFirstParty;
    PWSTR szParty;

    hr = ParseXMLDOMElementForAttribute( pElement, L"party", TRUE, &szParty );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForSession - "
                            "ParseXMLDOMElementForAttribute(party) failed 0x%lx", hr));

        pElement->Release();

        return RTC_E_PROFILE_INVALID_SESSION_PARTY;
    }

    if ( hr == S_OK )
    {
        if ( _wcsicmp( szParty, L"first" ) == 0 )
        {
            fFirstParty = TRUE;
        }
        else if ( _wcsicmp( szParty, L"third" ) == 0 )
        {
            fFirstParty = FALSE;
        }        
        else
        {
            LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForSession - "
                            "unknown party"));

            RTCFREE(szParty);
            pElement->Release();

            return RTC_E_PROFILE_INVALID_SESSION_PARTY;
        }

        RTCFREE(szParty);
    }

    //
    // type
    //

    PWSTR szType;

    hr = ParseXMLDOMElementForAttribute( pElement, L"type", TRUE, &szType );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForSession - "
                            "ParseXMLDOMElementForAttribute(type) failed 0x%lx", hr));

        pElement->Release();

        return RTC_E_PROFILE_INVALID_SESSION_TYPE;
    }

    if ( hr == S_OK )
    {
        if ( _wcsicmp( szType, L"pc2pc" ) == 0 )
        {
            if ( fFirstParty )
            {
                *plSession = RTCSI_PC_TO_PC;
            }
            else
            {
                LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForSession - "
                            "third party pc2pc not supported"));

                RTCFREE(szType);
                pElement->Release();

                return RTC_E_PROFILE_INVALID_SESSION;
            }
        }
        else if ( _wcsicmp( szType, L"pc2ph" ) == 0 )
        {
            if ( fFirstParty )
            {
                *plSession = RTCSI_PC_TO_PHONE;
            }
            else
            {
                LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForSession - "
                            "third party pc2ph not supported"));

                RTCFREE(szType);
                pElement->Release();

                return RTC_E_PROFILE_INVALID_SESSION;
            }
        } 
        else if ( _wcsicmp( szType, L"ph2ph" ) == 0 )
        {
            if ( fFirstParty )
            {
                LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForSession - "
                            "first party ph2ph not supported"));

                RTCFREE(szType);
                pElement->Release();

                return RTC_E_PROFILE_INVALID_SESSION;
            }
            else
            {
                *plSession = RTCSI_PHONE_TO_PHONE;
            }
        }
        else if ( _wcsicmp( szType, L"im" ) == 0 )
        {
            if ( fFirstParty )
            {
                *plSession = RTCSI_IM;
            }
            else
            {
                LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForSession - "
                            "third party im not supported"));

                RTCFREE(szType);
                pElement->Release();

                return RTC_E_PROFILE_INVALID_SESSION;
            }
        }
        else
        {
            LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMNodeForSession - "
                            "unknown type"));

            RTCFREE(szType);
            pElement->Release();

            return RTC_E_PROFILE_INVALID_SESSION_TYPE;
        }

        RTCFREE(szType);
    }

    pElement->Release();

    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMNodeForSession - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::ParseXMLDOMDocument
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::ParseXMLDOMDocument(
                        IXMLDOMDocument * pXMLDoc
                        )
{
    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMDocument - enter"));

    IXMLDOMNode * pDocument = NULL;
    IXMLDOMNode * pNode = NULL;
    HRESULT hr;

    hr = pXMLDoc->QueryInterface( IID_IXMLDOMNode, (void**)&pDocument);

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "QueryInterface failed 0x%lx", hr));

        return hr;
    }

    //
    // provision
    //

    hr = pDocument->selectSingleNode( CComBSTR(_T("provision")), &pNode );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "selectSingleNode(provision) failed 0x%lx", hr));

        pDocument->Release();

        return hr;
    }

    if ( hr == S_OK )
    {
        hr = ParseXMLDOMNodeForProvision( pNode, &m_Provision );

        pNode->Release();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument "
                                "ParseXMLDOMNodeForProvision failed 0x%lx", hr));

            pDocument->Release();

            return hr;
        }
    }
    else
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "provision not found"));

        pDocument->Release();

        return RTC_E_PROFILE_NO_PROVISION;
    }

    //
    // provider
    //

    hr = pDocument->selectSingleNode( CComBSTR(_T("provision/provider")), &pNode );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "selectSingleNode(provision/provider) failed 0x%lx", hr));

        pDocument->Release();

        return hr;
    }

    if ( hr == S_OK )
    {
        hr = ParseXMLDOMNodeForProvider( pNode, &m_Provider );

        pNode->Release();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument "
                                "ParseXMLDOMNodeForProvider failed 0x%lx", hr));

            pDocument->Release();

            return hr;
        }
    }
    else
    {
        LOG((RTC_WARN, "CRTCProfile::ParseXMLDOMDocument - "
                            "provider not found"));
    }

    //
    // client
    //

    hr = pDocument->selectSingleNode( CComBSTR(_T("provision/client")), &pNode );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "selectSingleNode(provision/client) failed 0x%lx", hr));

        pDocument->Release();

        return hr;
    }

    if ( hr == S_OK )
    {
        hr = ParseXMLDOMNodeForClient( pNode, &m_Client );

        pNode->Release();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument "
                                "ParseXMLDOMNodeForClient failed 0x%lx", hr));

            pDocument->Release();

            return hr;
        }
    }
    else
    {
        LOG((RTC_WARN, "CRTCProfile::ParseXMLDOMDocument - "
                            "client not found"));
    }

    //
    // user
    //

    hr = pDocument->selectSingleNode( CComBSTR(_T("provision/user")), &pNode );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "selectSingleNode(provision/user) failed 0x%lx", hr));

        pDocument->Release();

        return hr;
    }

    if ( hr == S_OK )
    {
        hr = ParseXMLDOMNodeForUser( pNode, &m_User );

        pNode->Release();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument "
                                "ParseXMLDOMNodeForUser failed 0x%lx", hr));

            pDocument->Release();

            return hr;
        }
    }
    else
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "user not found"));

        pDocument->Release();

        return RTC_E_PROFILE_NO_USER;
    }    

/*
    //
    // accesscontrol
    //
*/
    IXMLDOMNodeList * pNodeList;
/*
    PROF_ACCESSCONTROL AccessControl;

    hr = pDocument->selectNodes( CComBSTR(_T("provision/accesscontrol")), &pNodeList );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "selectNodes(provision/accesscontrol) failed 0x%lx", hr));

        pDocument->Release();

        return hr;
    }
    
    while ( pNodeList->nextNode( &pNode ) == S_OK )
    {
        hr = ParseXMLDOMNodeForAccessControl( pNode, &AccessControl );

        pNode->Release();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "ParseXMLDOMNodeForServer failed 0x%lx", hr));

            pNodeList->Release();
            FreeAccessControl( &AccessControl );
            pDocument->Release();

            return hr;
        }

        BOOL fResult;
        
        fResult = m_AccessControlArray.Add( AccessControl );

        if ( !fResult )
        {
            LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "out of memory"));

            pNodeList->Release();
            FreeAccessControl( &AccessControl );
            pDocument->Release();

            return E_OUTOFMEMORY;
        }
    }

    pNodeList->Release();

    if ( m_AccessControlArray.GetSize() == 0 )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "accesscontrol not found"));

        pDocument->Release();

        return RTC_E_PROFILE_NO_ACCESSCONTROL;
    } 

    hr = ValidateAccessControl();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                        "ValidateAccessControl failed 0x%lx", hr));

        pDocument->Release();

        return hr;
    }
*/

    //
    // server
    //

    PROF_SERVER Server;

    hr = pDocument->selectNodes( CComBSTR(_T("provision/sipsrv")), &pNodeList );

    pDocument->Release();

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "selectNodes(provision/sipsrv) failed 0x%lx", hr));

        return hr;
    }
    
    while ( pNodeList->nextNode( &pNode ) == S_OK )
    {
        hr = ParseXMLDOMNodeForServer( pNode, &Server );

        pNode->Release();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "ParseXMLDOMNodeForServer failed 0x%lx", hr));

            pNodeList->Release();
            FreeServer( &Server );

            return hr;
        }

        BOOL fResult;
        
        fResult = m_ServerArray.Add( Server );

        if ( !fResult )
        {
            LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "out of memory"));

            pNodeList->Release();
            FreeServer( &Server );

            return E_OUTOFMEMORY;
        }
    }

    pNodeList->Release();

    if ( m_ServerArray.GetSize() == 0 )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "sipsrv not found"));

        return RTC_E_PROFILE_NO_SERVER;
    }

    int nNumRegistrar = 0;

    for ( int n = 0; n < m_ServerArray.GetSize(); n++ )
    {
        if ( m_ServerArray[n].fRegistrar == TRUE )
        {
            nNumRegistrar++;
        }
    }

    if ( nNumRegistrar > 1 )
    {
        LOG((RTC_ERROR, "CRTCProfile::ParseXMLDOMDocument - "
                            "multiple registrar servers"));

        return RTC_E_PROFILE_MULTIPLE_REGISTRARS;
    }

    LOG((RTC_TRACE, "CRTCProfile::ParseXMLDOMDocument - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::FreeProvision
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCProfile::FreeProvision(PROF_PROVISION * pStruct)
{
    LOG((RTC_TRACE, "CRTCProfile::FreeProvision[%p]", pStruct));

    RTCFREE(pStruct->szKey);
    RTCFREE(pStruct->szName);
    RTCFREE(pStruct->szExpires);
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::FreeProvider
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCProfile::FreeProvider(PROF_PROVIDER * pStruct)
{
    LOG((RTC_TRACE, "CRTCProfile::FreeProvider[%p]", pStruct));

    RTCFREE(pStruct->szName);
    RTCFREE(pStruct->szHomepage);
    RTCFREE(pStruct->szHelpdesk);
    RTCFREE(pStruct->szPersonal);
    RTCFREE(pStruct->szCallDisplay);
    RTCFREE(pStruct->szIdleDisplay);
    RTCFREE(pStruct->szData);
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::FreeClient
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCProfile::FreeClient(PROF_CLIENT * pStruct)
{
    LOG((RTC_TRACE, "CRTCProfile::FreeClient[%p]", pStruct));

    RTCFREE(pStruct->szName);
    RTCFREE(pStruct->szMinVer);
    RTCFREE(pStruct->szCurVer);
    RTCFREE(pStruct->szUpdateUri);
    RTCFREE(pStruct->szData);
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::FreeUser
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCProfile::FreeUser(PROF_USER * pStruct)
{
    LOG((RTC_TRACE, "CRTCProfile::FreeUser[%p]", pStruct));

    RTCFREE(pStruct->szAccount);
    RTCFREE(pStruct->szName);
    RTCFREE(pStruct->szUri);
    RTCFREE(pStruct->szPassword);
    RTCFREE(pStruct->szRealm);
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::FreeServer
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCProfile::FreeServer(PROF_SERVER * pStruct)
{
    LOG((RTC_TRACE, "CRTCProfile::FreeServer[%p]", pStruct));

    RTCFREE(pStruct->szAddr);    
}

/*
/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::FreeAccessControl
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCProfile::FreeAccessControl(PROF_ACCESSCONTROL * pStruct)
{
    LOG((RTC_TRACE, "CRTCProfile::FreeAccessControl[%p]", pStruct));

    RTCFREE(pStruct->szDomain);
    RTCFREE(pStruct->szSig);
}

/////////////////////////////////////////////////////////////////////////////
//
// base64decode
//
/////////////////////////////////////////////////////////////////////////////

PBYTE 
base64decode(
    PWSTR pszBufCoded, 
    long * plDecodedSize
    )
{
    long lBytesDecoded;
    int pr2six[256];
    int i;
    int j=0;
    PWSTR pszCur = pszBufCoded;
    int fDone = FALSE;
    long lBufSize = 0;
    long lCount = 0;
    PWSTR pszBufIn = NULL;
    PBYTE pbBufOut = NULL;
    PBYTE pbTemp = NULL;    
    PBYTE pbBufDecoded = NULL;
    int lop_off;
    HRESULT hr = S_OK;

    //
    // Build up the reverse index from base64 characters to values
    // The multiple loops are easier
    //
    for (i=65; i<91; i++) {
         pr2six[i]=j++;
    }
    
    for (i=97; i<123; i++) {
         pr2six[i]=j++;
    }
    
    for (i=48; i<58; i++) {
        pr2six[i]=j++;
    }

    pr2six[43]=j++;
    pr2six[47]=j++;
    pr2six[61]=0;

    //
    // The old code relied on the size of the original data provided before 
    // the encoding. We don't have that, so we'll just allocate as much as 
    // the encoded data, relying on the fact that the encoded data is always 
    // larger. (+4 for good measure)
    // 
    lBufSize=wcslen(pszCur)-1+4;
    *plDecodedSize = lBufSize;

    pbBufDecoded = (PBYTE)RtcAlloc(lBufSize*sizeof(BYTE));
    if(!pbBufDecoded) {
        hr = E_OUTOFMEMORY;
        return NULL;
    }

        
    lCount=wcslen(pszCur);

    // Do the decoding to new buffer
    pszBufIn = pszCur;
    pbBufOut = pbBufDecoded;

    while(lCount > 0) {
        *(pbBufOut++) = (BYTE) (pr2six[*pszBufIn] << 2 | pr2six[pszBufIn[1]] >> 4);
        *(pbBufOut++) = (BYTE) (pr2six[pszBufIn[1]] << 4 | pr2six[pszBufIn[2]] >> 2);
        *(pbBufOut++) = (BYTE) (pr2six[pszBufIn[2]] << 6 | pr2six[pszBufIn[3]]);
        pszBufIn += 4;
        lCount -= 4;
    }

    //
    // The line below does not make much sense since \0 is really a valid 
    // binary value, so we can't add it to our data stream
    //
    //*(pbBufOut++) = '\0';
    
    //
    // Let's calculate the real size of our data
    //
    *plDecodedSize=(ULONG)(pbBufOut-pbBufDecoded);
    
    // 
    // if there were pads in the encoded stream, lop off the nulls the 
    // NULLS they created
    //
    lop_off=0;
    if (pszBufIn[-1]=='=') lop_off++;
    if (pszBufIn[-2]=='=') lop_off++;
    
    *plDecodedSize=*plDecodedSize-lop_off;

    pbTemp = (PBYTE) RtcAlloc((*plDecodedSize)*sizeof(BYTE));
    if (!pbTemp) {
        hr = E_OUTOFMEMORY;
        RtcFree(pbBufDecoded);
        return NULL;
    }
    memcpy(pbTemp, pbBufDecoded, (*plDecodedSize)*sizeof(BYTE));

    if (pbBufDecoded) {
        RtcFree(pbBufDecoded);
    }
    
    return pbTemp; 
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::ValidateAccessControl
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::ValidateAccessControl()
{
    LOG((RTC_TRACE, "CRTCProfile::ValidateAccessControl - enter"));

    HCRYPTPROV  hProv = NULL;
    HCRYPTKEY   hKey = NULL;
    HRESULT     hr;

    //
    // Delete any existing keyset
    //

    CryptAcquireContext(
        &hProv,
        g_szKeyContainer,
        MS_DEF_PROV,
        PROV_RSA_FULL,
        CRYPT_DELETEKEYSET);

    //
    // Initialize crypto API
    //

    if(!CryptAcquireContext(
        &hProv,
        g_szKeyContainer,
        MS_DEF_PROV,
        PROV_RSA_FULL,
        CRYPT_SILENT | CRYPT_NEWKEYSET))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        LOG((RTC_ERROR, "CRTCProfile::ValidateAccessControl - "
                            "CryptAcquireContext failed 0x%lx", hr));
        
        return hr;
    }

    //
    // Import public key
    //

    if(!CryptImportKey(
        hProv,
        g_PublicKeyBlob,
        sizeof(g_PublicKeyBlob),
        NULL,
        0,
        &hKey))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        LOG((RTC_ERROR, "CRTCProfile::ValidateAccessControl - "
                            "CryptImportKey failed 0x%lx", hr));

        CryptReleaseContext(hProv, 0);
        
        return hr;
    }

    for ( int n=0; n < m_AccessControlArray.GetSize(); n++ )
    {
        //
        // Validate the key (signature)
        //

        HCRYPTHASH  hHash = NULL;

        //
        // Create a hash object
        //

        if(!CryptCreateHash(
            hProv,
            CALG_MD5,
            NULL,
            0,
            &hHash))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            LOG((RTC_ERROR, "CRTCProfile::ValidateAccessControl - "
                                "CryptCreateHash failed 0x%lx", hr));

            CryptDestroyKey(hKey);
            CryptReleaseContext(hProv, 0);
        
            return hr;
        }

        //
        // Hash the pieces (mater key, a colon, and the suffix)
        //

        if(!CryptHashData(hHash, (BYTE *)g_szMasterKeyWithColon, wcslen(g_szMasterKeyWithColon)*sizeof(WCHAR), 0) ||
           !CryptHashData(hHash, (BYTE *)m_AccessControlArray[n].szDomain, wcslen(m_AccessControlArray[n].szDomain) * sizeof(WCHAR), 0) )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            LOG((RTC_ERROR, "CRTCProfile::ValidateAccessControl - "
                                "CryptHashData failed 0x%lx", hr));

            CryptDestroyHash(hHash);
            CryptDestroyKey(hKey);
            CryptReleaseContext(hProv, 0);
        
            return hr;
        }

        //
        // Convert the key to bytes
        //

        PBYTE   pSignature = NULL;
        DWORD   dwLength = 0;

        pSignature = base64decode(m_AccessControlArray[n].szSig, (long *)&dwLength);

        if (!pSignature)
        {
            LOG((RTC_ERROR, "CRTCProfile::ValidateAccessControl - "
                                "out of memory"));

            CryptDestroyHash(hHash);
            CryptDestroyKey(hKey);
            CryptReleaseContext(hProv, 0);
        
            return E_OUTOFMEMORY;
        }

        //
        // Verify the signature
        //

        if(!CryptVerifySignature(
            hHash,
            pSignature,
            dwLength,
            hKey,
            NULL,
            0))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            LOG((RTC_ERROR, "CRTCProfile::ValidateAccessControl - "
                                "CryptVerifySignature failed 0x%lx", hr));

            if( hr == HRESULT_FROM_WIN32(NTE_BAD_SIGNATURE) )
            {
                hr = RTC_E_PROFILE_INVALID_ACCESSCONTROL_SIGNATURE;

                LOG((RTC_ERROR, "CRTCProfile::ValidateAccessControl - "
                                    "invalid signature"));
            }

            RtcFree(pSignature);
            CryptDestroyHash(hHash);
            CryptDestroyKey(hKey);
            CryptReleaseContext(hProv, 0);

            return hr;
        }

        RtcFree(pSignature);
        CryptDestroyHash(hHash);
    }

    //
    // Release crypto objects
    //

    CryptDestroyKey(hKey);
    CryptReleaseContext(hProv, 0);
 
    LOG((RTC_TRACE, "CRTCProfile::ValidateAccessControl - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::IsMatchingAddress
//
/////////////////////////////////////////////////////////////////////////////

BOOL 
CRTCProfile::IsMatchingAddress(WCHAR *pszAddress, WCHAR *pszPattern)
{
    WCHAR * pwcAddrCrt = pszAddress;
    WCHAR * pwcPatternCrt = pszPattern;

    if(!pszAddress || !pszPattern)
    {
        return FALSE;
    }

    //
    // Go to the end
    //

    while(*pwcAddrCrt) 
    {
        if(*pwcAddrCrt==L':') // ignore the port
            break;

        pwcAddrCrt++;
    }

    while(*pwcPatternCrt) pwcPatternCrt++;

    //
    // Compare the suffix
    //

    while(1)
    {
        pwcPatternCrt--;
        pwcAddrCrt--;

        if(pwcPatternCrt >= pszPattern)
        {
            if(pwcAddrCrt >= pszAddress)
            {
                if(tolower(*pwcAddrCrt) != tolower(*pwcPatternCrt))
                {
                    //
                    // Doesn't match
                    //

                    return FALSE;
                }
            }
            else
            {
                //
                // The address is shorter, the matching failed
                //

                return FALSE;
            }
        }
        else
        {
            //
            // End of the pattern
            //

            if(pwcAddrCrt >= pszAddress)
            {
                //
                // Address is longer. Next char MUST be '.'
                //

                if(*pwcAddrCrt != L'.')
                {
                    return FALSE;
                }
                else
                {
                    return TRUE;
                }
            }
            else
            {
                //
                // Perfect match
                //

                return TRUE;
            }
        }
    }

    return FALSE;
}
*/

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::SetState
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::SetState(
        RTC_REGISTRATION_STATE enState,
        long lStatusCode,
        PCWSTR szStatusText
        )
{
    LOG((RTC_TRACE, "CRTCProfile::SetState - enter"));

    m_enState = enState;

    CRTCRegistrationStateChangeEvent::FireEvent(
                                                 m_pCClient,
                                                 this,
                                                 m_enState,
                                                 lStatusCode, // status code
                                                 szStatusText // status text
                                                 );

    if ( m_enState == RTCRS_NOT_REGISTERED )
    {
        //
        // Notify the core
        //

        PostMessage( m_pCClient->GetWindow(), WM_PROFILE_UNREG, (WPARAM)this, 0 );
    }

    LOG((RTC_TRACE, "CRTCProfile::SetState - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::Enable
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::Enable(long lRegisterFlags)
{
    LOG((RTC_TRACE, "CRTCProfile::Enable - enter"));

    if ( m_pSipStack == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::Enable - "
                            "no sip stack"));

        return E_UNEXPECTED;
    }

    //
    // Fill the SIP_PROVIDER_PROFILE structure
    //
   
    SIP_PROVIDER_PROFILE SipProfile;
    HRESULT hr;

    hr = GetSipProviderProfile( &SipProfile, lRegisterFlags );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::Enable - "
                            "GetSipProviderProfile failed 0x%lx", hr));   

        return hr;
    } 

    //
    // Set the SIP_PROVIDER_PROFILE in the SIP stack
    //

    hr = m_pSipStack->SetProviderProfile( &SipProfile );

    FreeSipProviderProfile( &SipProfile );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::Enable - "
                            "SetProviderProfile failed 0x%lx", hr));

        return hr;
    }

    m_fEnabled = TRUE;
    m_lRegisterFlags = lRegisterFlags;

    LOG((RTC_TRACE, "CRTCProfile::Enable - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::Disable
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::Disable()
{
    LOG((RTC_TRACE, "CRTCProfile::Disable - enter"));

    if ( m_pSipStack == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::Disable - "
                            "no sip stack"));

        return E_UNEXPECTED;
    }

    if ( IsEqualGUID( m_ProfileGuid, GUID_NULL ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::Disable - "
                            "null guid"));

        return E_UNEXPECTED;
    }

    if ( !m_lRegisterFlags )
    {
        //
        // Notify the core
        //

        PostMessage( m_pCClient->GetWindow(), WM_PROFILE_UNREG, (WPARAM)this, 0 );
    }

    if ( m_fEnabled )
    {
        HRESULT hr;

        hr = m_pSipStack->DeleteProviderProfile( &m_ProfileGuid );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCProfile::Disable - "
                                "DeleteProviderProfile failed 0x%lx", hr));

            return hr;
        }

        m_fEnabled = FALSE;
        m_lRegisterFlags = 0;
    }

    LOG((RTC_TRACE, "CRTCProfile::Disable - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::Redirect
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCProfile::Redirect(ISipRedirectContext * pSipRedirectContext)
{
    LOG((RTC_TRACE, "CRTCProfile::Redirect - enter"));

    if ( m_pSipStack == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::Redirect - "
                            "no sip stack"));

        return E_UNEXPECTED;
    }

    //
    // Get the next SIP URI
    //

    BSTR bstrRedirectURI = NULL;
    BSTR bstrRedirectName = NULL;
    HRESULT hr;

    hr = pSipRedirectContext->Advance();

    if ( hr != S_OK )
    {
        if ( hr == S_FALSE )
        {
            LOG((RTC_ERROR, "CRTCProfile::Redirect - "
                                "redirect list empty"));
        }
        else
        {
            LOG((RTC_ERROR, "CRTCProfile::Redirect - "
                                "Advance failed 0x%lx", hr));
        }

        return hr;
    }

    hr = pSipRedirectContext->GetSipUrlAndDisplayName( &bstrRedirectURI, &bstrRedirectName );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::Redirect - "
                            "GetSipUrlAndDisplayName failed 0x%lx", hr));

        return hr;
    }

    SysFreeString( bstrRedirectName );
    bstrRedirectName = NULL;

    //
    // Fill the SIP_PROVIDER_PROFILE structure
    //
   
    SIP_PROVIDER_PROFILE SipProfile;

    hr = GetSipProviderProfile( &SipProfile, m_lRegisterFlags );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::Redirect - "
                            "GetSipProviderProfile failed 0x%lx", hr));

        SysFreeString( bstrRedirectURI );
        bstrRedirectURI = NULL;        

        return hr;
    } 

    if ( SipProfile.lRegisterAccept != 0 )
    {
        RTCFREE( SipProfile.Registrar.ServerAddress );

        SipProfile.Registrar.ServerAddress = RtcAllocString( bstrRedirectURI );
        SipProfile.Registrar.IsServerAddressSIPURI = TRUE;
        SipProfile.Registrar.AuthProtocol = SIP_AUTH_PROTOCOL_NONE;
        SipProfile.Registrar.TransportProtocol = SIP_TRANSPORT_UNKNOWN;

        if ( SipProfile.Registrar.ServerAddress == NULL )
        {
            LOG((RTC_ERROR, "CRTCProfile::NotifyRegisterRedirect - "
                                "out of memory"));

            FreeSipProviderProfile( &SipProfile );

            SysFreeString( bstrRedirectURI );
            bstrRedirectURI = NULL;   

            return E_OUTOFMEMORY;
        }
    }

    SysFreeString( bstrRedirectURI );
    bstrRedirectURI = NULL;  

    //
    // Set the SIP_PROVIDER_PROFILE in the SIP stack
    //

    hr = m_pSipStack->SetProviderProfile( &SipProfile );

    FreeSipProviderProfile( &SipProfile );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::Redirect - "
                            "SetProviderProfile failed 0x%lx", hr));

        return hr;
    }

    LOG((RTC_TRACE, "CRTCProfile::Redirect - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::GetGuid
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCProfile::GetGuid(GUID * pGUID)
{
    LOG((RTC_TRACE, "CRTCProfile::GetGuid"));

    CopyMemory( pGUID, &m_ProfileGuid, sizeof(GUID) );
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_Key
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_Key(
        BSTR * pbstrKey
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_Key - enter"));

    if ( IsBadWritePtr( pbstrKey, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_Key - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_Key - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    if ( m_Provision.szKey == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_Key - "
                            "no value"));

        return E_FAIL;
    }
    
    *pbstrKey = SysAllocString( m_Provision.szKey );
    
    if ( *pbstrKey == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_Key - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::get_Key - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_Name
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_Name(
        BSTR * pbstrName
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_Name - enter"));

    if ( IsBadWritePtr( pbstrName, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_Name - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_Name - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    if ( m_Provision.szName == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_Name - "
                            "no value"));

        return E_FAIL;
    }
    
    *pbstrName = SysAllocString( m_Provision.szName );
    
    if ( *pbstrName == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_Name - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::get_Name - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_XML
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_XML(
        BSTR * pbstrXML
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_XML - enter"));

    if ( IsBadWritePtr( pbstrXML, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_XML - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_XML - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    if ( m_szProfileXML == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_XML - "
                            "no value"));

        return E_FAIL;
    }
    
    *pbstrXML = SysAllocString( m_szProfileXML );
    
    if ( *pbstrXML == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_XML - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::get_XML - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_ProviderName
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_ProviderName(
        BSTR * pbstrName
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_ProviderName - enter"));

    if ( IsBadWritePtr( pbstrName, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ProviderName - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ProviderName - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    if ( m_Provider.szName == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ProviderName - "
                            "no value"));

        return E_FAIL;
    }
    
    *pbstrName = SysAllocString( m_Provider.szName );
    
    if ( *pbstrName == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ProviderName - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::get_ProviderName - exit"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_ProviderURI
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_ProviderURI(
        RTC_PROVIDER_URI enURI,
        BSTR * pbstrURI
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_ProviderURI - enter"));

    if ( IsBadWritePtr( pbstrURI, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ProviderURI - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ProviderURI - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }    

    switch( enURI )
    {
    case RTCPU_URIHOMEPAGE:
        if ( m_Provider.szHomepage == NULL )
        {
            LOG((RTC_ERROR, "CRTCProfile::get_ProviderURI - "
                                "no value"));

            return E_FAIL;
        }

        *pbstrURI = SysAllocString( m_Provider.szHomepage );
        break;

    case RTCPU_URIHELPDESK:
        if ( m_Provider.szHelpdesk == NULL )
        {
            LOG((RTC_ERROR, "CRTCProfile::get_ProviderURI - "
                                "no value"));

            return E_FAIL;
        }

        *pbstrURI = SysAllocString( m_Provider.szHelpdesk );
        break;

    case RTCPU_URIPERSONALACCOUNT:
        if ( m_Provider.szPersonal == NULL )
        {
            LOG((RTC_ERROR, "CRTCProfile::get_ProviderURI - "
                                "no value"));

            return E_FAIL;
        }

        *pbstrURI = SysAllocString( m_Provider.szPersonal );
        break;

    case RTCPU_URIDISPLAYDURINGCALL:
        if ( m_Provider.szCallDisplay == NULL )
        {
            LOG((RTC_ERROR, "CRTCProfile::get_ProviderURI - "
                                "no value"));

            return E_FAIL;
        }

        *pbstrURI = SysAllocString( m_Provider.szCallDisplay );
        break;

    case RTCPU_URIDISPLAYDURINGIDLE:
        if ( m_Provider.szIdleDisplay == NULL )
        {
            LOG((RTC_ERROR, "CRTCProfile::get_ProviderURI - "
                                "no value"));

            return E_FAIL;
        }

        *pbstrURI = SysAllocString( m_Provider.szIdleDisplay );
        break;

    default:
        LOG((RTC_ERROR, "CRTCProfile::get_ProviderURI - "
                            "bad RTC_PROVIDER_URI"));

        return E_INVALIDARG;
    }
    
    if ( *pbstrURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ProviderURI - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::get_ProviderURI - exit"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_ProviderData
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_ProviderData(
        BSTR * pbstrData
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_ProviderData - enter"));

    if ( IsBadWritePtr( pbstrData, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ProviderData - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ProviderData - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    if ( m_Provider.szData == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ProviderData - "
                            "no value"));

        return E_FAIL;
    }
    
    *pbstrData = SysAllocString( m_Provider.szData );
    
    if ( *pbstrData == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ProviderData - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::get_ProviderData - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_ClientName
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_ClientName(
        BSTR * pbstrName
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_ClientName - enter"));

    if ( IsBadWritePtr( pbstrName, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientName - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientName - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    if ( m_Client.szName == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientName - "
                            "no value"));

        return E_FAIL;
    }
    
    *pbstrName = SysAllocString( m_Client.szName );
    
    if ( *pbstrName == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientName - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::get_ClientName - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_ClientBanner
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_ClientBanner(
        VARIANT_BOOL * pfBanner
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_ClientBanner - enter"));

    if ( IsBadWritePtr( pfBanner, sizeof(VARIANT_BOOL) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientBanner - "
                            "bad VARIANT_BOOL pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientBanner - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    *pfBanner = m_Client.fBanner ? VARIANT_TRUE : VARIANT_FALSE;

    LOG((RTC_TRACE, "CRTCProfile::get_ClientBanner - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_ClientMinVer
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_ClientMinVer(
        BSTR * pbstrMinVer
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_ClientMinVer - enter"));

    if ( IsBadWritePtr( pbstrMinVer, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientMinVer - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientMinVer - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    if ( m_Client.szMinVer == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientMinVer - "
                            "no value"));

        return E_FAIL;
    }
    
    *pbstrMinVer = SysAllocString( m_Client.szMinVer );
    
    if ( *pbstrMinVer == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientMinVer - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::get_ClientMinVer - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_ClientCurVer
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_ClientCurVer(
        BSTR * pbstrCurVer
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_ClientCurVer - enter"));

    if ( IsBadWritePtr( pbstrCurVer, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientCurVer - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientCurVer - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    if ( m_Client.szCurVer == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientCurVer - "
                            "no value"));

        return E_FAIL;
    }
    
    *pbstrCurVer = SysAllocString( m_Client.szCurVer );
    
    if ( *pbstrCurVer == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientCurVer - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::get_ClientCurVer - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_ClientUpdateURI
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_ClientUpdateURI(
        BSTR * pbstrUpdateURI
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_ClientUpdateURI - enter"));

    if ( IsBadWritePtr( pbstrUpdateURI, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientUpdateURI - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientUpdateURI - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    if ( m_Client.szUpdateUri == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientUpdateURI - "
                            "no value"));

        return E_FAIL;
    }
    
    *pbstrUpdateURI = SysAllocString( m_Client.szUpdateUri );
    
    if ( *pbstrUpdateURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientUpdateURI - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::get_ClientUpdateURI - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_ClientData
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_ClientData(
        BSTR * pbstrData
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_ClientData - enter"));

    if ( IsBadWritePtr( pbstrData, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientData - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientData - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    if ( m_Client.szData == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientData - "
                            "no value"));

        return E_FAIL;
    }
    
    *pbstrData = SysAllocString( m_Client.szData );
    
    if ( *pbstrData == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_ClientData - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::get_ClientData - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_UserURI
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_UserURI(
        BSTR * pbstrUserURI
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_UserURI - enter"));

    if ( IsBadWritePtr( pbstrUserURI, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_UserURI - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_UserURI - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    if ( m_User.szUri == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_UserURI - "
                            "no value"));

        return E_FAIL;
    }
    
    *pbstrUserURI = SysAllocString( m_User.szUri );
    
    if ( *pbstrUserURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_UserURI - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::get_UserURI - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_UserName
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_UserName(
        BSTR * pbstrUserName
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_UserName - enter"));

    if ( IsBadWritePtr( pbstrUserName, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_UserName - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_UserName - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    if ( m_User.szName == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_UserName - "
                            "no value"));

        return E_FAIL;
    }
    
    *pbstrUserName = SysAllocString( m_User.szName );
    
    if ( *pbstrUserName == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_UserName - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::get_UserName - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_UserAccount
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_UserAccount(
        BSTR * pbstrUserAccount
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_UserAccount - enter"));

    if ( IsBadWritePtr( pbstrUserAccount, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_UserAccount - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_UserAccount - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    if ( m_User.szAccount == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_UserAccount - "
                            "no value"));

        return E_FAIL;
    }
    
    *pbstrUserAccount = SysAllocString( m_User.szAccount );
    
    if ( *pbstrUserAccount == NULL )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_UserAccount - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCProfile::get_UserAccount - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::SetCredentials
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::SetCredentials(
        BSTR    bstrUserURI,
        BSTR    bstrUserAccount,
        BSTR    bstrPassword
        )
{
    LOG((RTC_TRACE, "CRTCProfile::SetCredentials - enter"));

    if ( IsBadStringPtrW( bstrUserURI, -1 ) ||
         ((bstrUserAccount != NULL) && IsBadStringPtrW( bstrUserAccount, -1 )) ||
         ((bstrPassword != NULL) && IsBadStringPtrW( bstrPassword, -1 )) )
    {
        LOG((RTC_ERROR, "CRTCProfile::SetCredentials - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::SetCredentials - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    PWSTR szUserURI = NULL;
    PWSTR szUserAccount = NULL;
    PWSTR szPassword = NULL;
    HRESULT hr;

    hr = AllocCleanSipString( bstrUserURI, &szUserURI );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCProfile::SetCredentials - "
                        "out of memory"));

        return E_OUTOFMEMORY;
    }

    if ( bstrUserAccount )
    {
        szUserAccount = RtcAllocString( bstrUserAccount );

        if ( szUserAccount == NULL )
        {
            LOG((RTC_ERROR, "CRTCProfile::SetCredentials - "
                            "out of memory"));

            RTCFREE(szUserURI);

            return E_OUTOFMEMORY;
        }
    }

    if ( bstrPassword )
    {
        szPassword = RtcAllocString( bstrPassword );

        if ( szPassword == NULL )
        {
            LOG((RTC_ERROR, "CRTCProfile::SetCredentials - "
                            "out of memory"));

            RTCFREE(szUserURI);
            RTCFREE(szUserAccount);

            return E_OUTOFMEMORY;
        }
    }

    RTCFREE(m_User.szUri);
    RTCFREE(m_User.szAccount);
    RTCFREE(m_User.szPassword);

    m_User.szUri = szUserURI;
    m_User.szAccount = szUserAccount;
    m_User.szPassword = szPassword;

    LOG((RTC_TRACE, "CRTCProfile::SetCredentials - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_SessionCapabilities
//
/////////////////////////////////////////////////////////////////////////////
    
STDMETHODIMP 
CRTCProfile::get_SessionCapabilities(
        long * plSupportedSessions
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_SessionCapabilities - enter"));

    if ( IsBadWritePtr( plSupportedSessions, sizeof(long) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_SessionCapabilities - "
                            "bad long pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_SessionCapabilities - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    *plSupportedSessions = 0;
    
    for ( int n=0; n < m_ServerArray.GetSize(); n++ )
    {
        *plSupportedSessions |= m_ServerArray[n].lSessions;
    }

    LOG((RTC_TRACE, "CRTCProfile::get_SessionCapabilities - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCProfile::get_State
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCProfile::get_State(
        RTC_REGISTRATION_STATE * penState
        )
{
    LOG((RTC_TRACE, "CRTCProfile::get_State - enter"));

    if ( IsBadWritePtr( penState, sizeof(RTC_REGISTRATION_STATE) ) )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_State - "
                            "bad RTC_REGISTRATION_STATE pointer"));

        return E_POINTER;
    }

    if ( m_fValid == FALSE )
    {
        LOG((RTC_ERROR, "CRTCProfile::get_State - "
                            "invlaid profile"));

        return RTC_E_INVALID_PROFILE;
    }

    *penState = m_enState;

    LOG((RTC_TRACE, "CRTCProfile::get_State - exit"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\rtcreg.cpp ===
#include "stdafx.h"
#include "rtcreg.h"

const TCHAR * g_szRtcKeyName = _T("Software\\Microsoft\\RTC");

WCHAR *g_szRtcRegistryStringNames[] =
{
    L"TermAudioCapture",
    L"TermAudioRender",
    L"TermVideoCapture"
};

WCHAR *g_szRtcRegistryDwordNames[] =
{
    L"PreferredMediaTypes",
    L"Tuned"
};

/////////////////////////////////////////////////////////////////////////////
//
// put_RegistryString
//
// This is a method that stores a settings string in
// the registry.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
put_RegistryString(
        RTC_REGISTRY_STRING enSetting,
        BSTR bstrValue            
        )
{
    // LOG((RTC_TRACE, "put_RegistryString - enter"));

    if ( IsBadStringPtrW( bstrValue, -1 ) )
    {
        LOG((RTC_ERROR, "put_RegistryString - "
                            "bad string pointer"));

        return E_POINTER;
    }  

    //
    // Open the RTCClient key
    //

    LONG lResult;
    HKEY hkeyRTC;

    lResult = RegCreateKeyEx(
                             HKEY_CURRENT_USER,
                             g_szRtcKeyName,
                             0,
                             NULL,
                             0,
                             KEY_WRITE,
                             NULL,
                             &hkeyRTC,
                             NULL
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "put_RegistryString - "
                            "RegCreateKeyEx(RTCClient) failed %d", lResult));
        
        return HRESULT_FROM_WIN32(lResult);
    }

    lResult = RegSetValueExW(
                             hkeyRTC,
                             g_szRtcRegistryStringNames[enSetting],
                             0,
                             REG_SZ,
                             (LPBYTE)bstrValue,
                             sizeof(WCHAR) * (lstrlenW(bstrValue) + 1)
                            );

    RegCloseKey( hkeyRTC );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "put_RegistryString - "
                            "RegSetValueEx failed %d", lResult));

        return HRESULT_FROM_WIN32(lResult);
    }    
      
    // LOG((RTC_TRACE, "put_RegistryString - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// get_RegistryString
//
// This is a method that gets a settings string from
// the registry.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
get_RegistryString(
        RTC_REGISTRY_STRING enSetting,
        BSTR * pbstrValue            
        )
{
    // LOG((RTC_TRACE, "get_RegistryString - enter"));

    if ( IsBadWritePtr( pbstrValue, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "get_RegistryString - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }  

    //
    // Open the RTCClient key
    //

    LONG lResult;
    HKEY hkeyRTC;

    lResult = RegCreateKeyEx(
                             HKEY_CURRENT_USER,
                             g_szRtcKeyName,
                             0,
                             NULL,
                             0,
                             KEY_READ,
                             NULL,
                             &hkeyRTC,
                             NULL
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_WARN, "get_RegistryString - "
                            "RegCreateKeyEx(RTCClient) failed %d", lResult));
        
        return HRESULT_FROM_WIN32(lResult);
    }

    PWSTR szString = NULL;

    szString = RtcRegQueryString( hkeyRTC, g_szRtcRegistryStringNames[enSetting] );

    RegCloseKey( hkeyRTC );

    if ( szString == NULL )
    {
        LOG((RTC_ERROR, "get_RegistryString - "
                            "RtcRegQueryString failed"));

        return E_FAIL;
    }
    
    *pbstrValue = SysAllocString( szString );

    RtcFree( szString );

    if ( *pbstrValue == NULL )
    {
        LOG((RTC_ERROR, "get_RegistryString - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }
      
    // LOG((RTC_TRACE, "get_RegistryString - exit S_OK"));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// DeleteRegistryString
//
// This is a method that deletes a settings string in
// the registry.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
DeleteRegistryString(
        RTC_REGISTRY_STRING enSetting         
        )
{
    // LOG((RTC_TRACE, "DeleteRegistryString - enter")); 

    //
    // Open the RTCClient key
    //

    LONG lResult;
    HKEY hkeyRTC;

    lResult = RegCreateKeyEx(
                             HKEY_CURRENT_USER,
                             g_szRtcKeyName,
                             0,
                             NULL,
                             0,
                             KEY_WRITE,
                             NULL,
                             &hkeyRTC,
                             NULL
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "DeleteRegistryString - "
                            "RegCreateKeyEx(RTCClient) failed %d", lResult));
        
        return HRESULT_FROM_WIN32(lResult);
    }

    lResult = RegDeleteValueW(
                             hkeyRTC,
                             g_szRtcRegistryStringNames[enSetting]
                            );

    RegCloseKey( hkeyRTC );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_WARN, "DeleteRegistryString - "
                            "RegDeleteValueW failed %d", lResult));

        return HRESULT_FROM_WIN32(lResult);
    }    
      
    // LOG((RTC_TRACE, "DeleteRegistryString - exit S_OK"));

    return S_OK;
}          

/////////////////////////////////////////////////////////////////////////////
//
// put_RegistryDword
//
// This is a method that stores a settings dword in
// the registry.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
put_RegistryDword(
        RTC_REGISTRY_DWORD enSetting,
        DWORD dwValue            
        )
{
    // LOG((RTC_TRACE, "put_RegistryDword - enter"));

    //
    // Open the RTCClient key
    //

    LONG lResult;
    HKEY hkeyRTC;

    lResult = RegCreateKeyEx(
                             HKEY_CURRENT_USER,
                             g_szRtcKeyName,
                             0,
                             NULL,
                             0,
                             KEY_WRITE,
                             NULL,
                             &hkeyRTC,
                             NULL
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "put_RegistryDword - "
                            "RegCreateKeyEx(RTCClient) failed %d", lResult));
        
        return HRESULT_FROM_WIN32(lResult);
    }

    lResult = RegSetValueExW(
                     hkeyRTC,
                     g_szRtcRegistryDwordNames[enSetting],
                     0,
                     REG_DWORD,
                     (LPBYTE)&dwValue,
                     sizeof(DWORD)
                    );

    RegCloseKey( hkeyRTC );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "put_RegistryDword - "
                            "RegSetValueEx failed %d", lResult));

        return HRESULT_FROM_WIN32(lResult);
    }    
      
    // LOG((RTC_TRACE, "put_RegistryDword - exit S_OK"));

    return S_OK;
}            

/////////////////////////////////////////////////////////////////////////////
//
// get_RegistryDword
//
// This is a method that gets a settings dword from
// the registry.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
get_RegistryDword(
        RTC_REGISTRY_DWORD enSetting,
        DWORD * pdwValue            
        )
{
    // LOG((RTC_TRACE, "get_RegistryDword - enter"));

    if ( IsBadWritePtr( pdwValue, sizeof(DWORD) ) )
    {
        LOG((RTC_ERROR, "get_RegistryDword - "
                            "bad DWORD pointer"));

        return E_POINTER;
    }

    //
    // Open the RTCClient key
    //

    LONG lResult;
    HKEY hkeyRTC;

    lResult = RegCreateKeyEx(
                             HKEY_CURRENT_USER,
                             g_szRtcKeyName,
                             0,
                             NULL,
                             0,
                             KEY_READ,
                             NULL,
                             &hkeyRTC,
                             NULL
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "get_RegistryDword - "
                            "RegCreateKeyEx(RTCClient) failed %d", lResult));
        
        return HRESULT_FROM_WIN32(lResult);
    }

    DWORD cbSize = sizeof(DWORD);

    lResult = RegQueryValueExW(
                               hkeyRTC,
                               g_szRtcRegistryDwordNames[enSetting],
                               0,
                               NULL,
                               (LPBYTE)pdwValue,
                               &cbSize
                              );

    RegCloseKey( hkeyRTC );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_WARN, "get_RegistryDword - "
                            "RegQueryValueExW failed %d", lResult));

        return HRESULT_FROM_WIN32(lResult);
    }    
      
    // LOG((RTC_TRACE, "get_RegistryDword - exit S_OK"));

    return S_OK;
}                    

/////////////////////////////////////////////////////////////////////////////
//
// DeleteRegistryDword
//
// This is a method that deletes a settings dword in
// the registry.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
DeleteRegistryDword(
        RTC_REGISTRY_DWORD enSetting
        )
{
    // LOG((RTC_TRACE, "DeleteRegistryDword - enter"));

    //
    // Open the RTCClient key
    //

    LONG lResult;
    HKEY hkeyRTC;

    lResult = RegCreateKeyEx(
                             HKEY_CURRENT_USER,
                             g_szRtcKeyName,
                             0,
                             NULL,
                             0,
                             KEY_WRITE,
                             NULL,
                             &hkeyRTC,
                             NULL
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "DeleteRegistryDword - "
                            "RegCreateKeyEx(RTCClient) failed %d", lResult));
        
        return HRESULT_FROM_WIN32(lResult);
    }

    lResult = RegDeleteValueW(
                     hkeyRTC,
                     g_szRtcRegistryDwordNames[enSetting]
                    );

    RegCloseKey( hkeyRTC );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_WARN, "DeleteRegistryDword - "
                            "RegDeleteValueW failed %d", lResult));

        return HRESULT_FROM_WIN32(lResult);
    }    
      
    // LOG((RTC_TRACE, "DeleteRegistryDword - exit S_OK"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\rtcsession.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCSession.cpp

Abstract:

    Implementation of the CRTCSession class

--*/

#include "stdafx.h"

#define     SIP_NAMESPACE_PREFIX    L"sip:"
#define     TEL_NAMESPACE_PREFIX    L"tel:"

#define     PREFIX_LENGTH           4

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::InitializeOutgoing
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCSession::InitializeOutgoing(
            CRTCClient        * pCClient,
            IRTCProfile       * pProfile,
            ISipStack         * pStack,
            RTC_SESSION_TYPE    enType,
            PCWSTR              szLocalName,
            PCWSTR              szLocalUserURI,
            PCWSTR              szLocalPhoneURI,
            long                lFlags
            )
{
    LOG((RTC_TRACE, "CRTCSession::InitializeOutgoing - enter"));

    HRESULT     hr;

    m_szLocalName = RtcAllocString(szLocalName);

    if ( m_szLocalName == NULL )
    {
        LOG((RTC_ERROR, "CRTCSession::InitializeOutgoing - "
                            "out of memory"));
        
        return E_OUTOFMEMORY;
    }

    m_szLocalUserURI = RtcAllocString(szLocalUserURI);

    if ( m_szLocalUserURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCSession::InitializeOutgoing - "
                            "out of memory"));
        
        return E_OUTOFMEMORY;
    }

    hr = AllocCleanTelString( szLocalPhoneURI, &m_szLocalPhoneURI);

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCSession::InitializeOutgoing - "
                            "AllocCleanTelString failed 0x%lx", hr));
        
        return hr;
    }   

    m_pCClient = pCClient;
    if (m_pCClient != NULL)
    {
        m_pCClient->AddRef();    
    }

    m_pProfile = pProfile;
    if (m_pProfile != NULL)
    {
        m_pProfile->AddRef();
    }

    m_pStack = pStack;
    if (m_pStack != NULL)
    {
        m_pStack->AddRef();
    }

    m_enType = enType;
    m_lFlags = lFlags;

    if ( enType == RTCST_PHONE_TO_PHONE )
    {
        hr = InitializeLocalPhoneParticipant();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::InitializeOutgoing - "
                            "InitializeLocalPhoneParticipant failed 0x%lx", hr));
        
            return hr;
        }
    }

    if ( enType == RTCST_IM )
    {
        hr = m_pStack->QueryInterface( IID_IIMManager, (void**)&m_pIMManager );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::InitializeOutgoing - "
                                "QI IIMManager failed 0x%lx", hr));         

            return hr;
        }
    }

    LOG((RTC_TRACE, "CRTCSession::InitializeOutgoing - exit S_OK"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::CreateSipSession
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCSession::CreateSipSession(
            PCWSTR              szDestUserURI
            )
{
    HRESULT hr;

    LOG((RTC_TRACE, "CRTCSession::CreateSipSession - enter"));

    //
    // Choose the best profile if needed
    //

    if ( !(m_lFlags & RTCCS_FORCE_PROFILE) )
    {
        IRTCProfile * pProfile;

        hr = m_pCClient->GetBestProfile(
                &m_enType,
                szDestUserURI,
                (m_pSipRedirectContext != NULL),
                &pProfile
                );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::CreateSipSession - "
                                "GetBestProfile failed 0x%lx", hr));

            return hr;
        }

        if ( m_pProfile != NULL )
        {
            m_pProfile->Release();
            m_pProfile = NULL;
        }

        m_pProfile = pProfile;
    }

    LOG((RTC_INFO, "CRTCSession::CreateSipSession - "
                                "profile [%p]", m_pProfile));

    //
    // Check session type 
    //

    SIP_CALL_TYPE sct;
    LONG lSessionType;

    switch (m_enType)
    {
        case RTCST_PC_TO_PC:
        {
            LOG((RTC_INFO, "CRTCSession::CreateSipSession - "
                    "RTCST_PC_TO_PC"));

            sct = SIP_CALL_TYPE_RTP;
            lSessionType = RTCSI_PC_TO_PC;

            break;
        }

        case RTCST_PC_TO_PHONE:
        {
            LOG((RTC_INFO, "CRTCSession::CreateSipSession - "
                    "RTCST_PC_TO_PHONE"));

            sct = SIP_CALL_TYPE_RTP;
            lSessionType = RTCSI_PC_TO_PHONE;

            break;
        }

        case RTCST_PHONE_TO_PHONE:
        {
            LOG((RTC_INFO, "CRTCSession::CreateSipSession - "
                    "RTCST_PHONE_TO_PHONE"));

            sct = SIP_CALL_TYPE_PINT;
            lSessionType = RTCSI_PHONE_TO_PHONE;

            if ( m_szLocalPhoneURI == NULL )
            {
                LOG((RTC_ERROR, "CRTCSession::CreateSipSession - "
                    "PHONE_TO_PHONE sessions need a local phone URI"));
            
                return RTC_E_LOCAL_PHONE_NEEDED;
            }

            break;
        }

        case RTCST_IM:
        {
            LOG((RTC_INFO, "CRTCSession::CreateSipSession - "
                    "RTCST_IM"));
            
            sct = SIP_CALL_TYPE_MESSAGE;
            lSessionType = RTCSI_IM;

            break;
        }

        default:
        {
            LOG((RTC_ERROR, "CRTCSession::CreateSipSession - "
                            "invalid session type"));
        
            return RTC_E_INVALID_SESSION_TYPE;
        }
    }

    //
    // Get profile info
    //

    SIP_PROVIDER_ID ProviderID = GUID_NULL;
    SIP_SERVER_INFO Proxy;        
    long lSupportedSessions = RTCSI_PC_TO_PC | RTCSI_IM;
    CRTCProfile * pCProfile = NULL;

    if ( m_pProfile != NULL )
    {
        //
        // Get pointer to profile object
        //

        pCProfile = static_cast<CRTCProfile *>(m_pProfile);

        //
        // Get the SIP provider ID from the profile. If the profile is NULL
        // then this call has no provider. In that case we just use GUID_NULL.
        //

        pCProfile->GetGuid( &ProviderID ); 

        //
        // Determine supported session types for this profile
        //

        hr = m_pProfile->get_SessionCapabilities( &lSupportedSessions );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::CreateSipSession - "
                                "get_SessionCapabilities failed 0x%lx", hr));
            
            return hr;
        }   
        
        //
        // Get the user name from the profile
        //
        
        BSTR bstrProfileUserName = NULL;

        hr = m_pProfile->get_UserName( &bstrProfileUserName );

        if ( FAILED(hr) )
        {
            LOG((RTC_WARN, "CRTCClient::CreateSession - "
                                "get_UserName failed 0x%lx", hr));
        }
        else
        {
            if ( m_szLocalName != NULL )
            {
                RtcFree( m_szLocalName );
                m_szLocalName = NULL;
            }

            m_szLocalName = RtcAllocString( bstrProfileUserName );

            SysFreeString( bstrProfileUserName );
            bstrProfileUserName = NULL;

            if ( m_szLocalName == NULL )
            {
                LOG((RTC_ERROR, "CRTCClient::CreateSession - "
                                "out of memory"));

                return E_OUTOFMEMORY;
            }                
        }

        //
        // Get the user URI from the profile
        //
        
        BSTR bstrProfileUserURI = NULL;

        hr = m_pProfile->get_UserURI( &bstrProfileUserURI );

        if ( FAILED(hr) )
        {
            LOG((RTC_WARN, "CRTCClient::CreateSession - "
                                "get_UserURI failed 0x%lx", hr));
        }
        else
        {
            if ( m_szLocalUserURI != NULL )
            {
                RtcFree( m_szLocalUserURI );
                m_szLocalUserURI = NULL;
            }

            m_szLocalUserURI = RtcAllocString( bstrProfileUserURI );

            SysFreeString( bstrProfileUserURI );
            bstrProfileUserURI = NULL;

            if ( m_szLocalUserURI == NULL )
            {
                LOG((RTC_ERROR, "CRTCClient::CreateSession - "
                                "out of memory"));

                return E_OUTOFMEMORY;
            }                
        }
    }

    //
    // Validate session type
    //

    if ( !(lSessionType & lSupportedSessions) )
    {
        LOG((RTC_ERROR, "CRTCSession::CreateSipSession - "
                            "session type is not supported by this profile"));

        return RTC_E_INVALID_SESSION_TYPE;
    }

    //
    // Get SIP proxy info
    //

    if ( pCProfile != NULL )
    {
        hr = pCProfile->GetSipProxyServerInfo( lSessionType, &Proxy );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::CreateSipSession - "
                                "GetSipProxyServerInfo failed 0x%lx", hr));

            return hr;
        } 
    }

    if ( m_szRedirectProxy != NULL )
    {
        //
        // We need to redirect to a different proxy
        //

        if ( Proxy.ServerAddress != NULL )
        {
            RtcFree( Proxy.ServerAddress );
        }

        Proxy.ServerAddress = m_szRedirectProxy;
        m_szRedirectProxy = NULL;

        Proxy.IsServerAddressSIPURI = TRUE;
        Proxy.AuthProtocol = SIP_AUTH_PROTOCOL_NONE;
        Proxy.TransportProtocol = SIP_TRANSPORT_UNKNOWN;
        
        ProviderID = GUID_NULL;
    }

    //
    // Create the SIP session
    //

    if ( m_enType == RTCST_IM )
    {
        BSTR bstrLocalName = SysAllocString(m_szLocalName);
        BSTR bstrLocalUserURI = SysAllocString(m_szLocalUserURI);

        hr = m_pIMManager->CreateSession(
                                       bstrLocalName,
                                       bstrLocalUserURI,
                                       &ProviderID,
                                       (pCProfile != NULL) ? &Proxy : NULL,
                                       m_pSipRedirectContext,
                                       &m_pIMSession
                                      );

        if (bstrLocalName != NULL)
        {
            SysFreeString(bstrLocalName);
            bstrLocalName = NULL;
        }

        if (bstrLocalUserURI != NULL)
        {
            SysFreeString(bstrLocalUserURI);
            bstrLocalUserURI = NULL;
        }

        if (pCProfile != NULL)
        {
            pCProfile->FreeSipServerInfo( &Proxy );
        }

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCSession::CreateSipSession - "
                                "CreateSession failed 0x%lx", hr));
        
            return hr;
        }

        hr = m_pIMSession->SetNotifyInterface(this);

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCSession::CreateSipSession - "
                                "SetNotifyInterface failed 0x%lx", hr));
        
            return hr;
        }
    }
    else 
    {
        //
        // This is a RTP or PINT session
        //

        hr = m_pStack->CreateCall(
                                     &ProviderID,
                                     (pCProfile != NULL) ? &Proxy : NULL,
                                     sct,
                                     m_pSipRedirectContext,
                                     &m_pCall
                                    ); 

        if (pCProfile != NULL)
        {
            pCProfile->FreeSipServerInfo( &Proxy );
        }

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCSession::CreateSipSession - "
                                "CreateCall failed 0x%lx", hr));
        
            return hr;
        }

        hr = m_pCall->SetNotifyInterface(this);

        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCSession::CreateSipSession - "
                                "SetNotifyInterface failed 0x%lx", hr));
        
            return hr;
        }
    }

    LOG((RTC_TRACE, "CRTCSession::CreateSipSession - exit S_OK"));

    return S_OK;
}   

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::InitializeLocalPhoneParticipant
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCSession::InitializeLocalPhoneParticipant()
{
    LOG((RTC_TRACE, "CRTCSession::InitializeLocalPhoneParticipant - enter"));

    HRESULT hr;

    //
    // Add a participant for ourselves in a phone-to-phone call
    //

    //
    // Create the participant
    //

    IRTCParticipant * pParticipant = NULL;

    hr = InternalCreateParticipant( &pParticipant );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::InitializeLocalPhoneParticipant - "
                            "failed to create participant 0x%lx", hr));
    
        return hr;
    }

    //
    // Initialize the participant
    //

    CRTCParticipant * pCParticipant = NULL;

    pCParticipant = static_cast<CRTCParticipant *>(pParticipant);

    hr = pCParticipant->Initialize( m_pCClient, 
                                    this,
                                    m_szLocalPhoneURI,
                                    m_szLocalName
                                   );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::InitializeLocalPhoneParticipant - "
                            "Initialize failed 0x%lx", hr));

        pParticipant->Release();
    
        return hr;
    }  

    //
    // Add the participant to the array
    //

    BOOL fResult;

    fResult = m_ParticipantArray.Add(pParticipant);

    pParticipant->Release();

    if ( fResult == FALSE )
    {
        LOG((RTC_ERROR, "CRTCSession::InitializeLocalPhoneParticipant - "
                            "out of memory"));
    
        return E_OUTOFMEMORY;
    }                

    LOG((RTC_TRACE, "CRTCSession::InitializeLocalPhoneParticipant - exit S_OK"));

    return S_OK;
}
                                            

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::InitializeIncoming
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCSession::InitializeIncoming(        
        CRTCClient        * pCClient,
        ISipCall          * pCall,  
        SIP_PARTY_INFO    * pCallerInfo
        )
{
    LOG((RTC_TRACE, "CRTCSession::InitializeIncoming - enter"));
  
    HRESULT hr;

    m_pCall = pCall;
    if (m_pCall != NULL)
    {
        m_pCall->AddRef();
    }

    m_pCClient = pCClient;
    if (m_pCClient != NULL)
    {
        m_pCClient->AddRef(); 
    }

    m_enType = RTCST_PC_TO_PC;

    hr = m_pCall->SetNotifyInterface(this);

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCSession::InitializeIncoming - "
                            "failed to set notify interface 0x%lx", hr));
        
        return hr;
    }

    //
    // Create the participant
    //

    IRTCParticipant * pParticipant = NULL;

    hr = InternalCreateParticipant( &pParticipant );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::InitializeIncoming - "
                            "failed to create participant 0x%lx", hr));
        
        return hr;
    }

    //
    // Initialize the participant
    //

    CRTCParticipant * pCParticipant = NULL;

    pCParticipant = static_cast<CRTCParticipant *>(pParticipant);
    
    hr = pCParticipant->Initialize( m_pCClient,  
                                    this,
                                    pCallerInfo->URI,
                                    pCallerInfo->DisplayName
                                   );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::InitializeIncoming - "
                            "Initialize failed 0x%lx", hr));

        pParticipant->Release();
        
        return hr;
    }  

    //
    // Add the participant to the array
    //

    BOOL fResult;

    fResult = m_ParticipantArray.Add(pParticipant);

    if ( fResult == FALSE )
    {
        LOG((RTC_ERROR, "CRTCSession::InitializeIncoming - "
                            "out of memory"));

        pParticipant->Release();
        
        return E_OUTOFMEMORY;
    }    

    //
    // Set the session state
    //

    SetState( RTCSS_INCOMING, 0, NULL );

    //
    // Release the participant pointer
    //
    
    pParticipant->Release();
   
    LOG((RTC_TRACE, "CRTCSession::InitializeIncoming - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::InitializeIncomingIM
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCSession::InitializeIncomingIM(
            CRTCClient        * pCClient,
            ISipStack         * pStack,
            IIMSession        * pSession,
            BSTR                msg,
            BSTR                ContentType,
            SIP_PARTY_INFO    * pCallerInfo
            )
{
    LOG((RTC_TRACE, "CRTCSession::InitializeIncomingIM - enter"));
  
    HRESULT hr;

    hr = pStack->QueryInterface( IID_IIMManager, (void**)&m_pIMManager );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::InitializeIncomingIM - "
                            "QI IIMManager failed 0x%lx", hr));

        return hr;
    }

    m_pIMSession = pSession;
    if (m_pIMSession != NULL)
    {
        m_pIMSession->AddRef();
    }

    m_pCClient = pCClient;
    if (m_pCClient != NULL)
    {
        m_pCClient->AddRef(); 
    }

    m_enType = RTCST_IM;

    hr = m_pIMSession->SetNotifyInterface(this);

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCSession::InitializeIncomingIM - "
                            "SetNotifyInterface failed 0x%lx", hr));
        
        return hr;
    }

    //
    // Create the participant
    //

    IRTCParticipant * pParticipant = NULL;

    hr = InternalCreateParticipant( &pParticipant );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::InitializeIncomingIM - "
                            "failed to create participant 0x%lx", hr));
        
        return hr;
    }

    //
    // Initialize the participant
    //

    CRTCParticipant * pCParticipant = NULL;

    pCParticipant = static_cast<CRTCParticipant *>(pParticipant);
    
    hr = pCParticipant->Initialize( m_pCClient, 
                                    this,
                                    pCallerInfo->URI,
                                    pCallerInfo->DisplayName
                                   );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::InitializeIncomingIM - "
                            "Initialize failed 0x%lx", hr));

        pParticipant->Release();
        
        return hr;
    }  

    //
    // Add the participant to the array
    //

    BOOL fResult;

    fResult = m_ParticipantArray.Add(pParticipant);

    if ( fResult == FALSE )
    {
        LOG((RTC_ERROR, "CRTCSession::InitializeIncomingIM - "
                            "out of memory"));

        pParticipant->Release();
        
        return E_OUTOFMEMORY;
    }    

    //
    // Set the session state
    //

    SetState( RTCSS_INCOMING, 0, NULL );

    SetState( RTCSS_CONNECTED, 0, NULL );

    //
    // Fire a message event
    //

    CRTCMessagingEvent::FireEvent(this, pParticipant, msg, ContentType, RTCMSET_MESSAGE, RTCMUS_IDLE);

    //
    // Release the participant pointer
    //
    
    pParticipant->Release();
   
    LOG((RTC_TRACE, "CRTCSession::InitializeIncomingIM - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::FinalConstruct
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCSession::FinalConstruct()
{
    LOG((RTC_TRACE, "CRTCSession::FinalConstruct [%p] - enter", this));

#if DBG
    m_pDebug = (PWSTR) RtcAlloc( sizeof(void *) );
    *((void **)m_pDebug) = this;
#endif

    LOG((RTC_TRACE, "CRTCSession::FinalConstruct [%p] - exit S_OK", this));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCSession::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCSession::FinalRelease [%p] - enter", this));

    m_ParticipantArray.Shutdown();

    if ( m_pCall != NULL )
    {
        m_pCall->SetNotifyInterface(NULL);

        m_pCall->Release();
        m_pCall = NULL;
    }

    if ( m_pIMSession != NULL )
    {
        m_pIMSession->SetNotifyInterface(NULL);

        m_pIMSession->Release();
        m_pIMSession = NULL;
    }

    if ( m_pIMManager != NULL )
    {
        m_pIMManager->Release();
        m_pIMManager = NULL;
    }
    
    if ( m_pStack != NULL )
    {
        m_pStack->Release();
        m_pStack = NULL;
    }

    if ( m_pProfile != NULL )
    {
        m_pProfile->Release();
        m_pProfile = NULL;
    }

    if ( m_pCClient != NULL )
    {
        m_pCClient->Release();
        m_pCClient = NULL;
    }

    if ( m_szLocalName != NULL )
    {
        RtcFree(m_szLocalName);
        m_szLocalName = NULL;
    }

    if ( m_szLocalUserURI != NULL )
    {
        RtcFree(m_szLocalUserURI);
        m_szLocalUserURI = NULL;
    }

    if ( m_szLocalPhoneURI != NULL )
    {
        RtcFree(m_szLocalPhoneURI);
        m_szLocalPhoneURI = NULL;
    }

    if ( m_szRemoteUserName != NULL )
    {
        RtcFree(m_szRemoteUserName);
        m_szRemoteUserName = NULL;
    }

    if ( m_szRemoteUserURI != NULL )
    {
        RtcFree(m_szRemoteUserURI);
        m_szRemoteUserURI = NULL;
    }

    if ( m_pSipRedirectContext != NULL )
    {
        m_pSipRedirectContext->Release();
        m_pSipRedirectContext = NULL;
    }

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    LOG((RTC_TRACE, "CRTCSession::FinalRelease [%p] - exit", this));
}  

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::InternalAddRef
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CRTCSession::InternalAddRef()
{
    DWORD dwR;

    dwR = InterlockedIncrement(&m_dwRef);

    LOG((RTC_INFO, "CRTCSession::InternalAddRef [%p] - dwR %d", this, dwR));

    return dwR;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::InternalRelease
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CRTCSession::InternalRelease()
{
    DWORD               dwR;
    
    dwR = InterlockedDecrement(&m_dwRef);

    LOG((RTC_INFO, "CRTCSession::InternalRelease [%p] - dwR %d", this, dwR));

    return dwR;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::GetClient
//
/////////////////////////////////////////////////////////////////////////////

CRTCClient * 
CRTCSession::GetClient()
{
    LOG((RTC_TRACE, "CRTCSession::GetClient"));

    return m_pCClient;
} 

/////////////////////////////////////////////////////////////////////////////
//
//  getPSfromSS  helper function for CRTCSession::SetState
//               map a  RTC_SESSION_STATE to a RTC_PARTICIPANT_STATE
//
/////////////////////////////////////////////////////////////////////////////
HRESULT getPSfromSS(RTC_SESSION_STATE ss, RTC_PARTICIPANT_STATE * p_ps)
{
    struct SessionState_ParticipantState_Map
    {
        RTC_SESSION_STATE ss;
        RTC_PARTICIPANT_STATE ps;
    } sessionParticipantMaps[]=
    {
        {RTCSS_IDLE	,RTCPS_IDLE},
        {RTCSS_INCOMING	,RTCPS_INCOMING},
        {RTCSS_ANSWERING	,RTCPS_ANSWERING},
        {RTCSS_INPROGRESS,RTCPS_INPROGRESS},
        {RTCSS_CONNECTED	,RTCPS_CONNECTED},
        {RTCSS_DISCONNECTED,RTCPS_DISCONNECTED}
    };
    
    int n=sizeof(sessionParticipantMaps)/sizeof(SessionState_ParticipantState_Map);
    for(int i=0;i<n;i++)
    {
        if(sessionParticipantMaps[i].ss == ss )
        {
            *p_ps = sessionParticipantMaps[i].ps;
            return S_OK;
        }
    }
    return E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::SetState
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCSession::SetState(
                      RTC_SESSION_STATE enState,
                      long lStatusCode,
                      PCWSTR szStatusText
                     )
{
    LOG((RTC_TRACE, "CRTCSession::SetState - enter"));

    HRESULT hr = S_OK;
    BOOL    fFireEvent = FALSE;
    BOOL    fNewState = FALSE;

    //
    // We only need to do something if this is a new state
    //
    
    if (m_enState != enState)
    {
        LOG((RTC_INFO, "CRTCSession::SetState - new state"));

        fFireEvent = TRUE;
        fNewState = TRUE;
        m_enState = enState;
    }
    else
    {
        //
        // We are already in this state. Only fire an event if we have a useful status
        // code to report.
        //

        if ( (lStatusCode != 0) || (szStatusText != NULL) )
        {
            fFireEvent = TRUE;
        }
    }

    if ( szStatusText != NULL )
    {
        LOG((RTC_INFO, "CRTCSession::SetState - "
                "state [%d] status [%d] text[%ws]", enState, lStatusCode, szStatusText));
    }
    else
    {
        LOG((RTC_INFO, "CRTCSession::SetState - "
                "state [%d] status [%d]", enState, lStatusCode));
    }

    if ( fFireEvent )
    {
        if ( m_enState != RTCSS_DISCONNECTED )
        {
            //
            // Fire a state change event. Since this is not a disconnected event, we want
            // to fire it before any related participant events.
            //
    
            CRTCSessionStateChangeEvent::FireEvent(this, m_enState, lStatusCode, szStatusText);
        }

        if ( fNewState && ((m_enState == RTCSS_DISCONNECTED) || (m_enType != RTCST_PHONE_TO_PHONE)) )
        {
            //
            // Propagate session state to all participants
            //

            RTC_PARTICIPANT_STATE psState;

            hr = getPSfromSS(m_enState, &psState);

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCSession::SetState - "
                    "Participant->getPSfromSS failed 0x%lx, m_enState=%d", hr, m_enState));
            }
            else
            {
                for (int n = 0; n < m_ParticipantArray.GetSize(); n++)
                {
                    CRTCParticipant * pCParticipant;
                    RTC_PARTICIPANT_STATE state;

                    pCParticipant = static_cast<CRTCParticipant *>(m_ParticipantArray[n]);
                
                    hr = pCParticipant->get_State(&state);

                    if ( FAILED(hr) )
                    {
                        LOG((RTC_ERROR, "CRTCSession::SetState - "
                                            "Participant->get_State failed 0x%lx", hr));

                        continue;
                    }
                
                    if ( state != psState )
                    {
                        hr = pCParticipant->SetState( psState, 0 );

                        if ( FAILED(hr) )
                        {
                            LOG((RTC_ERROR, "CRTCSession::SetState - "
                                                "Participant->SetState failed 0x%lx", hr));

                            continue;
                        }
                    }
                }
            }
        }

        if ( m_enState == RTCSS_DISCONNECTED )
        {
            m_ParticipantArray.Shutdown();

            //
            // Fire a state change event. Since this is a disconnected event, we want
            // to fire it after any related participant events.
            //
    
            CRTCSessionStateChangeEvent::FireEvent(this, m_enState, lStatusCode, szStatusText);
        }
    }

    //
    // Don't access any member variables after FireEvent. If the state was
    // changing to disconnected this object could be released.
    //

    LOG((RTC_TRACE, "CRTCSession::SetState - exit 0x%lx", hr));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::get_Client
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::get_Client(
                        IRTCClient ** ppClient
                       )
{
    LOG((RTC_TRACE, "CRTCSession::get_Client - enter"));

    if ( IsBadWritePtr(ppClient , sizeof(IRTCClient *) ) )
    {
        LOG((RTC_ERROR, "CRTCSession::get_Client - bad pointer"));

        return E_POINTER;
    }

    HRESULT hr;

    hr = m_pCClient->QueryInterface( 
                           IID_IRTCClient,
                           (void **)ppClient
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::get_Client - "
                            "QI failed 0x%lx", hr));

        return hr;
    }
   
    LOG((RTC_TRACE, "CRTCSession::get_Client - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::Answer
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::Answer()
{
    LOG((RTC_TRACE, "CRTCSession::Answer - enter"));

    HRESULT hr;
    
    //
    // Check that this session is RTCSS_INCOMING
    //

    if ( m_enState != RTCSS_INCOMING )
    {
        LOG((RTC_ERROR, "CRTCSession::Answer - "
                            "session is not incoming"));

        return RTC_E_INVALID_SESSION_STATE;
    }

    SetState( RTCSS_ANSWERING, 0, NULL );

    if ( m_enType == RTCST_IM )
    {
        hr = m_pIMSession->AcceptSession();
    }
    else
    {
        hr = m_pCall->Accept();
    }

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::Answer - "
                            "Accept failed 0x%lx", hr));

        SetState( RTCSS_DISCONNECTED, 0, NULL );

        //
        // Don't access any member variables after the state is
        // set to disconnected. This object could be released.
        //
        
        return hr;
    }  

    LOG((RTC_TRACE, "CRTCSession::Answer - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::Terminate
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::Terminate(
                       RTC_TERMINATE_REASON enReason
                      )
{
    LOG((RTC_TRACE, "CRTCSession::Terminate - enter"));

    HRESULT hr;

    if ( m_enType == RTCST_IM )
    {
        if ( m_pIMSession != NULL )
        {
            m_pIMManager->DeleteSession( m_pIMSession );
        }

        if ( m_enState != RTCSS_DISCONNECTED )
        {
            SetState( RTCSS_DISCONNECTED, 0, NULL );
        }

        //
        // Don't access any member variables after the state is
        // set to disconnected. This object could be released.
        //
    } 
    else
    {
        switch ( m_enState)
        {    
        case RTCSS_IDLE:
            {
                //
                // If we are idle, fail
                //

                LOG((RTC_ERROR, "CRTCSession::Terminate - "
                                    "session is idle"));

                return RTC_E_INVALID_SESSION_STATE;
            }

        case RTCSS_DISCONNECTED:
            {
                //
                // If we are already disconnected, return
                //

                LOG((RTC_ERROR, "CRTCSession::Terminate - "
                                    "session is already disconnected"));

                break;
            }

        case RTCSS_INCOMING:
            {
                //
                // If the session is incoming, reject it
                //

                SIP_STATUS_CODE Status;

                switch ( enReason )
                {
                case RTCTR_DND:
                    Status = 480;
                    break;

                case RTCTR_REJECT:
                    Status = 603;
                    break;

                case RTCTR_TIMEOUT:
                    Status = 408;
                    break;

                case RTCTR_BUSY:
                case RTCTR_SHUTDOWN:
                    Status = 486;
                    break;
            
                default:
                    LOG((RTC_ERROR, "CRTCSession::Terminate - "
                                    "invalid reason for reject"));

                    return E_INVALIDARG;
                }

                hr = m_pCall->Reject( Status );

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCSession::Terminate - "
                                        "Reject failed 0x%lx", hr));
    
                    return hr;
                }

                SetState( RTCSS_DISCONNECTED, 0, NULL );

                //
                // Don't access any member variables after the state is
                // set to disconnected. This object could be released.
                //

                break;
            }

        default:
            {
                //
                // Otherwise, disconnect it
                //

                if ( enReason != RTCTR_NORMAL && enReason != RTCTR_SHUTDOWN)
                {
                    LOG((RTC_ERROR, "CRTCSession::Terminate - "
                                    "invalid reason for disconnect"));

                    return E_INVALIDARG;
                }

                hr = m_pCall->Disconnect();

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCSession::Terminate - "
                                        "Disconnect failed 0x%lx", hr));
    
                    return hr;
                }
            }
        }
    }

    LOG((RTC_TRACE, "CRTCSession::Terminate - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::Redirect
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::Redirect(
        RTC_SESSION_TYPE enType,
        BSTR bstrLocalPhoneURI,
        IRTCProfile * pProfile,
        long     lFlags
        )
{
    LOG((RTC_TRACE, "CRTCSession::Redirect - enter"));

    HRESULT hr;

    if ( m_pSipRedirectContext == NULL )
    {
        LOG((RTC_ERROR, "CRTCSession::Redirect - no sip redirect context"));

        return RTC_E_INVALID_SESSION_STATE;
    }

    LOG((RTC_INFO, "CRTCSession::Redirect - enType [%d]",
        enType));
    LOG((RTC_INFO, "CRTCSession::Redirect - bstrLocalPhoneURI [%ws]",
        bstrLocalPhoneURI));
    LOG((RTC_INFO, "CRTCSession::Redirect - pProfile [0x%p]",
        pProfile));
    LOG((RTC_INFO, "CRTCSession::Redirect - lFlags [0x%lx]",
        lFlags));

    //
    // Clean up the old state
    //

    m_ParticipantArray.Shutdown();

    if ( m_pCall != NULL )
    {
        m_pCall->SetNotifyInterface(NULL);

        m_pCall->Release();
        m_pCall = NULL;
    }

    if ( m_pIMSession != NULL )
    {
        m_pIMSession->SetNotifyInterface(NULL);

        m_pIMSession->Release();
        m_pIMSession = NULL;
    }

    if ( m_pProfile != NULL )
    {
        m_pProfile->Release();
        m_pProfile = NULL;
    }

    if ( m_szLocalPhoneURI != NULL )
    {
        RtcFree(m_szLocalPhoneURI);
        m_szLocalPhoneURI = NULL;
    }

    m_enState = RTCSS_IDLE;

    //
    // Set the new state
    //

    hr = AllocCleanTelString( bstrLocalPhoneURI, &m_szLocalPhoneURI );

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCSession::Redirect - "
                            "AllocCleanTelString failed 0x%lx", hr));
        
        return hr;
    }

    m_pProfile = pProfile;
    if (m_pProfile != NULL)
    {
        m_pProfile->AddRef();
    }

    m_enType = enType;
    m_lFlags = lFlags;

    if ( enType == RTCST_PHONE_TO_PHONE )
    {
        hr = InitializeLocalPhoneParticipant();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::Redirect - "
                            "InitializeLocalPhoneParticipant failed 0x%lx", hr));
        
            return hr;
        }
    }

    LOG((RTC_TRACE, "CRTCSession::Redirect - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::get_State
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::get_State(
        RTC_SESSION_STATE * penState
        )
{
    LOG((RTC_TRACE, "CRTCSession::get_State - enter"));

    if ( IsBadWritePtr(penState , sizeof(RTC_SESSION_STATE) ) )
    {
        LOG((RTC_ERROR, "CRTCSession::get_State - bad pointer"));

        return E_POINTER;
    }

    *penState = m_enState;
   
    LOG((RTC_TRACE, "CRTCSession::get_State - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::get_Type
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::get_Type(
        RTC_SESSION_TYPE * penType
        )
{
    LOG((RTC_TRACE, "CRTCSession::get_Type - enter"));

    if ( IsBadWritePtr(penType , sizeof(RTC_SESSION_TYPE) ) )
    {
        LOG((RTC_ERROR, "CRTCSession::get_Type - bad pointer"));

        return E_POINTER;
    }

    *penType = m_enType;
   
    LOG((RTC_TRACE, "CRTCSession::get_Type - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::get_Profile
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::get_Profile(
        IRTCProfile ** ppProfile
        )
{
    LOG((RTC_TRACE, "CRTCSession::get_Profile - enter"));

    if ( IsBadWritePtr(ppProfile , sizeof(IRTCProfile *) ) )
    {
        LOG((RTC_ERROR, "CRTCSession::get_Profile - bad pointer"));

        return E_POINTER;
    }

    if ( m_pProfile == NULL )
    {
        LOG((RTC_ERROR, "CRTCSession::get_Profile - no profile"));

        return RTC_E_NO_PROFILE;
    } 

    *ppProfile = m_pProfile;
    m_pProfile->AddRef();
   
    LOG((RTC_TRACE, "CRTCSession::get_Profile - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::AddStream
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::AddStream(
        long lMediaType,
        long lCookie
        )
{
    LOG((RTC_TRACE, "CRTCSession::AddStream - enter"));

    HRESULT hr;

    if ( (m_enType != RTCST_PC_TO_PC) &&
         (m_enType != RTCST_PC_TO_PHONE) )
    {
        LOG((RTC_ERROR, "CRTCSession::AddStream - "
                "not a rtp call"));

        return RTC_E_INVALID_SESSION_TYPE;
    }

    if ( (m_enState != RTCSS_CONNECTED) &&
         (m_enState != RTCSS_INPROGRESS) )
    {
        LOG((RTC_ERROR, "CRTCSession::AddStream - "
                "invalid session state"));

        return RTC_E_INVALID_SESSION_STATE;
    }

    switch ( lMediaType )
    {
    case RTCMT_AUDIO_SEND:
        hr = m_pCall->StartStream( RTC_MT_AUDIO, RTC_MD_CAPTURE,
                                   lCookie
                                   );
        break;

    case RTCMT_AUDIO_RECEIVE:
        hr = m_pCall->StartStream( RTC_MT_AUDIO, RTC_MD_RENDER,
                                   lCookie
                                   );
        break;

    case RTCMT_VIDEO_SEND:
        hr = m_pCall->StartStream( RTC_MT_VIDEO, RTC_MD_CAPTURE,
                                   lCookie
                                   );
        break;

    case RTCMT_VIDEO_RECEIVE:
        hr = m_pCall->StartStream( RTC_MT_VIDEO, RTC_MD_RENDER,
                                   lCookie
                                   );
        break;

    case RTCMT_T120_SENDRECV:
        hr = m_pCall->StartStream( RTC_MT_DATA, RTC_MD_CAPTURE,
                                   lCookie
                                   );
        if (hr == RTC_E_SIP_STREAM_PRESENT)
        {
            //  Ignore stream already started error as it does happen (expected)
            hr = S_OK;
        }
        break;

    default:
        LOG((RTC_ERROR, "CRTCSession::AddStream - "
                "invalid media type"));

        return E_INVALIDARG;
    }

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::AddStream - "
                "StartStream failed 0x%lx", hr));

        return hr;
    } 

    LOG((RTC_TRACE, "CRTCSession::AddStream - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::RemoveStream
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::RemoveStream(
        long lMediaType,
        long lCookie
        )
{
    LOG((RTC_TRACE, "CRTCSession::RemoveStream - enter"));

    HRESULT hr;

    if ( (m_enType != RTCST_PC_TO_PC) &&
         (m_enType != RTCST_PC_TO_PHONE) )
    {
        LOG((RTC_ERROR, "CRTCSession::RemoveStream - "
                "not a rtp call"));

        return RTC_E_INVALID_SESSION_TYPE;
    }

    if ( (m_enState != RTCSS_CONNECTED) &&
         (m_enState != RTCSS_INPROGRESS) )
    {
        LOG((RTC_ERROR, "CRTCSession::RemoveStream - "
                "invalid session state"));

        return RTC_E_INVALID_SESSION_STATE;
    }

    switch ( lMediaType )
    {
    case RTCMT_AUDIO_SEND:
        hr = m_pCall->StopStream( RTC_MT_AUDIO, RTC_MD_CAPTURE,
                                  lCookie
                                  );
        break;

    case RTCMT_AUDIO_RECEIVE:
        hr = m_pCall->StopStream( RTC_MT_AUDIO, RTC_MD_RENDER,
                                  lCookie
                                  );
        break;

    case RTCMT_VIDEO_SEND:
        hr = m_pCall->StopStream( RTC_MT_VIDEO, RTC_MD_CAPTURE,
                                  lCookie
                                  );
        break;

    case RTCMT_VIDEO_RECEIVE:
        hr = m_pCall->StopStream( RTC_MT_VIDEO, RTC_MD_RENDER,
                                  lCookie
                                  );
        break;

    case RTCMT_T120_SENDRECV:
        hr = m_pCall->StopStream( RTC_MT_DATA, RTC_MD_CAPTURE,
                                  lCookie
                                  );

        break;

    default:
        LOG((RTC_ERROR, "CRTCSession::RemoveStream - "
                "invalid media type"));

        return E_INVALIDARG;
    }

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::RemoveStream - "
                "StopStream failed 0x%lx", hr));

        return hr;
    } 
   
    LOG((RTC_TRACE, "CRTCSession::RemoveStream - exit S_OK"));

    return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::put_EncryptionKey
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::put_EncryptionKey(
        long lMediaType,
        BSTR bstrEncryptionKey
        )
{
    LOG((RTC_TRACE, "CRTCSession::put_EncryptionKey - enter"));

    HRESULT hr;

    if ( (m_enType != RTCST_PC_TO_PC) &&
         (m_enType != RTCST_PC_TO_PHONE) )
    {
        LOG((RTC_ERROR, "CRTCSession::put_EncryptionKey - "
                "not a rtp call"));

        return RTC_E_INVALID_SESSION_TYPE;
    }
    
    LOG((RTC_INFO, "SSPPYY RTCMT_ALL_RTP                    %x", RTCMT_ALL_RTP));
    LOG((RTC_INFO, "SSPPYY ~RTCMT_ALL_RTP                   %x", ~RTCMT_ALL_RTP));
    LOG((RTC_INFO, "SSPPYY lMediaType & ~RTCMT_ALL_RTP      %x", lMediaType & ~RTCMT_ALL_RTP));

    if(lMediaType & ~RTCMT_ALL_RTP)
    {
        LOG((RTC_ERROR, "CRTCSession::put_EncryptionKey - "
                "invalid media type"));

        return E_INVALIDARG;
    }

    if ( IsBadStringPtrW( bstrEncryptionKey, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCSession::put_EncryptionKey - bad string pointer"));

        return E_POINTER;
    }

    // XXX - it's not per call right now
    hr = m_pCClient->SetEncryptionKey( lMediaType, bstrEncryptionKey );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::put_EncryptionKey - "
                "SetEncryptionKey failed 0x%lx", hr));

        return hr;
    } 
    if(m_pCall != NULL)
    {
        m_pCall->SetNeedToReinitializeMediaManager(TRUE);
    }
    else
    {
        LOG((RTC_TRACE, "CRTCSession::put_EncryptionKey - m_pCall"
            "is NULL, unable to call SetNeedToReinitializeMediaManager"));
    }
    LOG((RTC_TRACE, "CRTCSession::put_EncryptionKey - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::SendMessage
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::SendMessage(
        BSTR bstrMessageHeader,
        BSTR bstrMessage,
        long lCookie
        )
{
    LOG((RTC_TRACE, "CRTCSession::SendMessage - enter"));

    HRESULT hr;

    if ( m_enType != RTCST_IM )
    {
        LOG((RTC_ERROR, "CRTCSession::SendMessage - "
                "valid only for RTCST_IM sessions"));

        return RTC_E_INVALID_SESSION_TYPE;
    }

    if ( (m_enState != RTCSS_INPROGRESS) &&
         (m_enState != RTCSS_INCOMING) &&
         (m_enState != RTCSS_CONNECTED) )
    {
        LOG((RTC_ERROR, "CRTCSession::SendMessage - "
                "invalid session state"));

        return RTC_E_INVALID_SESSION_STATE;
    }

    if ( IsBadStringPtrW( bstrMessage, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCSession::SendMessage - bad message string pointer"));

        return E_POINTER;
    }

    if ( (bstrMessageHeader != NULL) &&
         IsBadStringPtrW( bstrMessageHeader, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCSession::SendMessage - bad message header string pointer"));

        return E_POINTER;
    }

    hr = m_pIMSession->SendTextMessage( bstrMessage, bstrMessageHeader, lCookie );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::SendMessage - "
                "SendTextMessage failed 0x%lx", hr));

        return hr;
    } 

    LOG((RTC_TRACE, "CRTCSession::SendMessage - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::SendMessageStatus
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::SendMessageStatus(
        RTC_MESSAGING_USER_STATUS enUserStatus,
        long lCookie
        )
{
    LOG((RTC_TRACE, "CRTCSession::SendMessageStatus - enter"));

    HRESULT hr;

    if ( m_enType != RTCST_IM )
    {
        LOG((RTC_ERROR, "CRTCSession::SendMessageStatus - "
                "valid only for RTCST_IM sessions"));

        return RTC_E_INVALID_SESSION_TYPE;
    }

    if ( (m_enState != RTCSS_INPROGRESS) &&
         (m_enState != RTCSS_INCOMING) &&
         (m_enState != RTCSS_CONNECTED) )
    {
        LOG((RTC_ERROR, "CRTCSession::SendMessageStatus - "
                "invalid session state"));

        return RTC_E_INVALID_SESSION_STATE;
    }

    USR_STATUS enSIPUserStatus;

    switch ( enUserStatus )
    {
    case RTCMUS_IDLE:
        enSIPUserStatus = USR_STATUS_IDLE;
        break;

    case RTCMUS_TYPING:
        enSIPUserStatus = USR_STATUS_TYPING;
        break;

    default:
        LOG((RTC_ERROR, "CRTCSession::SendMessageStatus - "
                "invalid RTC_MESSAGING_USER_STATUS"));

        return E_INVALIDARG;
    }

    hr = m_pIMSession->SendUsrStatus( enSIPUserStatus, lCookie );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::SendMessageStatus - "
                "SendUsrStatus failed 0x%lx", hr));

        return hr;
    }

    LOG((RTC_TRACE, "CRTCSession::SendMessageStatus - exit"));

    return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::InternalCreateParticipant
//
// Private helper method
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCSession::InternalCreateParticipant(
        IRTCParticipant ** ppParticipant
        )
{
    HRESULT hr;
    
    LOG((RTC_TRACE, "CRTCSession::InternalCreateParticipant - enter"));
  
    //
    // Create the participant
    //

    CComObject<CRTCParticipant> * pCParticipant;
    hr = CComObject<CRTCParticipant>::CreateInstance( &pCParticipant );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCSession::InternalCreateParticipant - CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
        
        return hr;
    }

    //
    // Get the IRTCParticipant interface
    //

    IRTCParticipant * pParticipant = NULL;

    hr = pCParticipant->QueryInterface(
                           IID_IRTCParticipant,
                           (void **)&pParticipant
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::InternalCreateParticipant - QI failed 0x%lx", hr));
        
        delete pCParticipant;
        
        return hr;
    }

    *ppParticipant = pParticipant;

    LOG((RTC_TRACE, "CRTCSession::InternalCreateParticipant - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::AddParticipant
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::AddParticipant(
        BSTR bstrUserURI,
        BSTR bstrName,
        IRTCParticipant ** ppParticipant
        )
{
    HRESULT     hr;

    LOG((RTC_TRACE, "CRTCSession::AddParticipant - enter"));

    //
    // NULL is okay for ppParticipant
    //
    
    if ( (ppParticipant != NULL) &&
         IsBadWritePtr( ppParticipant, sizeof(IRTCParticipant *) ) )
    {
        LOG((RTC_ERROR, "CRTCSession::AddParticipant - bad IRTCParticipant pointer"));

        return E_POINTER;
    }

    if ( IsBadStringPtrW( bstrUserURI, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCSession::AddParticipant - bad user URI string pointer"));

        return E_POINTER;
    }

    if ( (bstrName != NULL) &&
         IsBadStringPtrW( bstrName, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCSession::AddParticipant - bad user name string pointer"));

        return E_POINTER;
    }

    LOG((RTC_INFO, "CRTCSession::AddParticipant - bstrUserURI [%ws]",
        bstrUserURI));
    LOG((RTC_INFO, "CRTCSession::AddParticipant - bstrName [%ws]",
        bstrName));

    //
    // Reject an empty UserURI string
    //

    if ( *bstrUserURI == L'\0' )
    {
        LOG((RTC_ERROR, "CRTCSession::AddParticipant - empty string"));

        return HRESULT_FROM_WIN32(ERROR_INVALID_NETNAME);
    }

    //
    // If the session is idle, create the SIP session
    //

    if ( m_enState == RTCSS_IDLE )
    {
        hr = CreateSipSession( bstrUserURI );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::AddParticipant - "
                                "CreateSipSession failed 0x%lx", hr));

            return hr;
        }
    }

    //
    // Allocate a remote UserName
    //

    if ( m_szRemoteUserName != NULL )
    {
        RtcFree(m_szRemoteUserName);
        m_szRemoteUserName = NULL;
    }

    if ( bstrName )
    {
        m_szRemoteUserName = RtcAllocString( bstrName );
    }
    else
    {
        m_szRemoteUserName = RtcAllocString( L"" );
    }

    //
    // Allocate a remote UserURI
    //

    if ( m_szRemoteUserURI != NULL )
    {
        RtcFree(m_szRemoteUserURI);
        m_szRemoteUserURI = NULL;
    }

    switch ( m_enType )
    {

    case RTCST_PHONE_TO_PHONE:
        {
            hr = AllocCleanTelString( bstrUserURI, &m_szRemoteUserURI );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCSession::AddParticipant - "
                        "AllocCleanTelString failed 0x%lx", hr));

                return hr;
            }
            break;
        }

    case RTCST_PC_TO_PHONE:
        {
            if ( _wcsnicmp(bstrUserURI, SIP_NAMESPACE_PREFIX, PREFIX_LENGTH) == 0 )
            {
                hr = AllocCleanSipString( bstrUserURI, &m_szRemoteUserURI );
                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCSession::AddParticipant - "
                         "AllocCleanSipString failed 0x%lx", hr));
                    return hr;
                }
            }
            else
            {
                hr = AllocCleanTelString( bstrUserURI, &m_szRemoteUserURI );
                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCSession::AddParticipant - "
                         "AllocCleanTelString failed 0x%lx", hr));
                    return hr;
                }
            }
            
            break;
        }
    case RTCST_PC_TO_PC:
        {
            hr = AllocCleanSipString( bstrUserURI, &m_szRemoteUserURI );
            
            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCSession::AddParticipant - "
                        "AllocCleanSipString failed 0x%lx", hr));

                return hr;
            }
            break;
        }
    case RTCST_IM:
        {
            hr = AllocCleanSipString( bstrUserURI, &m_szRemoteUserURI );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCSession::AddParticipant - "
                        "AllocCleanSipString failed 0x%lx", hr));

                return hr;
            }
            break;
        }

    default:
        {
            LOG((RTC_ERROR, "CRTCSession::AddParticipant - "
                                "invalid session type"));

            return RTC_E_INVALID_SESSION_TYPE;
        }
    }  

    LOG((RTC_INFO, "CRTCSession::AddParticipant - m_szRemoteUserURI [%ws]",
        m_szRemoteUserURI));

    //
    // Search the pariticipant array and make sure we are not
    // trying to add a duplicate
    //

    IRTCParticipant * pSearchParticipant = NULL;
    BSTR              bstrSearchUserURI = NULL;

    for (int n = 0; n < m_ParticipantArray.GetSize(); n++)
    {
        pSearchParticipant = m_ParticipantArray[n];

        hr = pSearchParticipant->get_UserURI( &bstrSearchUserURI );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::AddParticipant - "
                                "get_UserURI[%p] failed 0x%lx",
                                pSearchParticipant, hr));

            return hr;
        }

        if ( IsEqualURI( m_szRemoteUserURI, bstrSearchUserURI ) )
        {
            //
            // This is a match, return an error
            //

            LOG((RTC_ERROR, "CRTCSession::AddParticipant - "
                                "duplicate participant already exists"));

            SysFreeString( bstrSearchUserURI );

            return HRESULT_FROM_WIN32(ERROR_USER_EXISTS);
        }

        SysFreeString( bstrSearchUserURI );
    }

    //
    // Create the participant
    //

    IRTCParticipant * pParticipant = NULL;

    hr = InternalCreateParticipant( &pParticipant );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::AddParticipant - "
                            "failed to create participant 0x%lx", hr));

        return hr;
    }

    //
    // Initialize the participant
    //

    CRTCParticipant * pCParticipant = NULL;

    pCParticipant = static_cast<CRTCParticipant *>(pParticipant);
    
    hr = pCParticipant->Initialize( m_pCClient, 
                                    this,
                                    m_szRemoteUserURI,
                                    m_szRemoteUserName,
                                    m_enType == RTCST_PHONE_TO_PHONE
                                   );

    
 
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::AddParticipant - Initialize failed 0x%lx", hr));

        pParticipant->Release();
        
        return hr;
    }  

    //
    // Add the participant to the array
    //

    BOOL fResult;

    fResult = m_ParticipantArray.Add(pParticipant);

    if ( fResult == FALSE )
    {
        LOG((RTC_ERROR, "CRTCSession::AddParticipant - out of memory"));

        pParticipant->Release();
        
        return E_OUTOFMEMORY;
    }   

    switch ( m_enType )
    {

    case RTCST_PHONE_TO_PHONE:
        {
            //
            // This is a RTCST_PHONE_TO_PHONE session. We can add participants as long as
            // the call is IDLE, INPROGRESS, or CONNECTED.
            //

            if ( (m_enState != RTCSS_IDLE) &&
                 (m_enState != RTCSS_INPROGRESS) &&
                 (m_enState != RTCSS_CONNECTED) )
            {
                LOG((RTC_ERROR, "CRTCSession::AddParticipant - "
                                    "session can not add participants"));

                m_ParticipantArray.Remove(pParticipant);
                pParticipant->Release();                

                return RTC_E_INVALID_SESSION_STATE;
            }        

            //
            // Fill in the SIP_PARTY_INFO.
            //

            SIP_PARTY_INFO spi;

            ZeroMemory(&spi, sizeof(SIP_PARTY_INFO));

            spi.DisplayName = m_szRemoteUserName;
            spi.URI = m_szRemoteUserURI;

            //
            // Add the party to the SIP call.
            //

            hr = m_pCall->AddParty( &spi );
                                 
            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCSession::AddParticipant - AddParty failed 0x%lx", hr));

                m_ParticipantArray.Remove(pParticipant);
                pParticipant->Release();     

                return hr;
            }   

            //
            // If the session state is idle, we need to call Connect to place the call.
            //
    
            if ( m_enState == RTCSS_IDLE )
            {
                hr = m_pCall->Connect(
                                  m_szLocalName,
                                  m_szLocalUserURI,
                                  m_szLocalUserURI,
                                  m_szLocalPhoneURI
                                 );
                                 
                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CRTCSession::AddParticipant - Connect failed 0x%lx", hr));        

                    m_ParticipantArray.Remove(pParticipant);
                    pParticipant->Release();     

                    return hr;
                } 
                
                //
                // Set the session state
                //

                SetState( RTCSS_INPROGRESS, 0, NULL );
            }

            break;
        }

    case RTCST_PC_TO_PC:
    case RTCST_PC_TO_PHONE:
        {
            //
            // This is a RTCST_PC_TO_X session. We can only add participants when the session state
            // is IDLE.
            //

            if ( m_enState != RTCSS_IDLE )
            {
                LOG((RTC_ERROR, "CRTCSession::AddParticipant - "
                                "session can not add participants"));

                m_ParticipantArray.Remove(pParticipant);
                pParticipant->Release();     

                return RTC_E_INVALID_SESSION_STATE;
            }
         
            //
            // Call Connect to place the call.
            //

            hr = m_pCall->Connect(
                                  m_szLocalName,
                                  m_szLocalUserURI,
                                  m_szRemoteUserURI,
                                  NULL
                                 );
                                 
            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCSession::AddParticipant - Connect failed 0x%lx", hr));

                m_ParticipantArray.Remove(pParticipant);
                pParticipant->Release();     

                return hr;
            }   

            //
            // Set the session state
            //

            SetState( RTCSS_INPROGRESS, 0, NULL );

            break;
        }

    case RTCST_IM:
        {
            //
            // This is a RTCST_IM session. We can only add participants when the session state
            // is IDLE.
            //

            if ( m_enState != RTCSS_IDLE )
            {
                LOG((RTC_ERROR, "CRTCSession::AddParticipant - "
                                "session can not add participants"));

                m_ParticipantArray.Remove(pParticipant);
                pParticipant->Release();     

                return RTC_E_INVALID_SESSION_STATE;
            }

            //
            // Fill in the SIP_PARTY_INFO.
            //

            SIP_PARTY_INFO spi;

            ZeroMemory(&spi, sizeof(SIP_PARTY_INFO));

            spi.DisplayName = m_szRemoteUserName;
            spi.URI = m_szRemoteUserURI;

            //
            // Add the party to the SIP call.
            //

            hr = m_pIMSession->AddParty( &spi );
                                 
            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCSession::AddParticipant - AddParty failed 0x%lx", hr));

                m_ParticipantArray.Remove(pParticipant);
                pParticipant->Release();     

                return hr;
            }  
            
            //
            // Set the session state
            //

            SetState( RTCSS_INPROGRESS, 0, NULL );

            break;
        } 
    }

    //
    // Should we return the participant?
    //
    
    if ( ppParticipant != NULL )
    {
        *ppParticipant = pParticipant;
    }
    else
    {
        pParticipant->Release();
        pParticipant = NULL;
    }

    LOG((RTC_TRACE, "CRTCSession::AddParticipant - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::RemoveParticipant
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::RemoveParticipant(
        IRTCParticipant * pParticipant
        )
{
    LOG((RTC_TRACE, "CRTCSession::RemoveParticipant - enter"));   

    if ( IsBadReadPtr( pParticipant, sizeof(IRTCParticipant) ) )
    {
        LOG((RTC_ERROR, "CRTCSession::RemoveParticipant - "
                            "bad IRTCParticipant pointer"));

        return E_POINTER;
    }
    
    //
    // Check to see if the participant is removable
    //

    VARIANT_BOOL fRemovable;
    HRESULT hr;

    hr = pParticipant->get_Removable( &fRemovable );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::RemoveParticipant - "
                            "get_Removable failed 0x%lx", hr));

        return hr;
    }

    if ( fRemovable == VARIANT_FALSE )
    {
        LOG((RTC_ERROR, "CRTCSession::RemoveParticipant - "
                            "this participant is not removeable"));

        return E_FAIL;
    }

    //
    // Get the UserURI
    // 

    BSTR bstrUserURI = NULL;

    hr = pParticipant->get_UserURI( &bstrUserURI );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::RemoveParticipant - "
                            "get_UserURI failed 0x%lx", hr));        
    }  
    else
    {
        //
        // Remove the party from the SIP call
        //

        hr = m_pCall->RemoveParty( bstrUserURI );

        SysFreeString( bstrUserURI );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::RemoveParticipant - "
                                "RemoveParty failed 0x%lx", hr));
        }
    }

    //
    // The participant will be removed from the list once it reaches the
    // RTCSS_DISCCONNECTED state. However, if RemoveParty failed we will
    // need to do this right now.
    //

    if ( FAILED(hr) )
    {
        //
        // Set participant state
        //

        CRTCParticipant * pCParticipant;

        pCParticipant = static_cast<CRTCParticipant *>(pParticipant);

        pCParticipant->SetState( RTCPS_DISCONNECTED, 0 );
        
        //
        // Remove the participant from our array
        //

        BOOL fResult;

        fResult = m_ParticipantArray.Remove(pParticipant);

        if ( fResult == FALSE )
        {
            LOG((RTC_ERROR, "CRTCSession::RemoveParticipant - "
                                "participant not found"));
        }
    }

    LOG((RTC_TRACE, "CRTCSession::RemoveParticipant - exit 0x%lx", hr));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::EnumerateParticipants
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::EnumerateParticipants(
        IRTCEnumParticipants ** ppEnum
        )
{
    HRESULT                 hr;

    LOG((RTC_TRACE, "CRTCSession::EnumerateParticipants enter"));

    if ( IsBadWritePtr( ppEnum, sizeof( IRTCEnumParticipants * ) ) )
    {
        LOG((RTC_ERROR, "CRTCSession::EnumerateParticipants - "
                            "bad IRTCEnumParticipants pointer"));

        return E_POINTER;
    }

    //
    // Create the enumeration
    //
 
    CComObject< CRTCEnum< IRTCEnumParticipants,
                          IRTCParticipant,
                          &IID_IRTCEnumParticipants > > * p;
                          
    hr = CComObject< CRTCEnum< IRTCEnumParticipants,
                               IRTCParticipant,
                               &IID_IRTCEnumParticipants > >::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCSession::EnumerateParticipants - "
                            "CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
        
        return hr;
    }

    //
    // Initialize the enumeration (adds a reference)
    //
    
    hr = p->Initialize( m_ParticipantArray );

    if (S_OK != hr)
    {
        LOG((RTC_ERROR, "CRTCSession::EnumerateParticipants - "
                            "could not initialize enumeration" ));
    
        delete p;
        return hr;
    }

    *ppEnum = p;

    LOG((RTC_TRACE, "CRTCSession::EnumerateParticipants - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::get_Participants
//
// This is an IRTCSession method that enumerates participants on
// the session.
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRTCSession::get_Participants(
        IRTCCollection ** ppCollection
        )
{
    HRESULT hr;
    
    LOG((RTC_TRACE, "CRTCSession::get_Participants - enter"));

    //
    // Check the arguments
    //

    if ( IsBadWritePtr( ppCollection, sizeof(IRTCCollection *) ) )
    {
        LOG((RTC_ERROR, "CRTCSession::get_Participants - "
                            "bad IRTCCollection pointer"));

        return E_POINTER;
    }

    //
    // Create the collection
    //
 
    CComObject< CRTCCollection< IRTCParticipant > > * p;
                          
    hr = CComObject< CRTCCollection< IRTCParticipant > >::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCClient::get_Participants - "
                            "CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
        
        return hr;
    }

    //
    // Initialize the collection (adds a reference)
    //
    
    hr = p->Initialize(m_ParticipantArray);

    if ( S_OK != hr )
    {
        LOG((RTC_ERROR, "CRTCClient::get_Participants - "
                            "could not initialize collection" ));
    
        delete p;
        return hr;
    }

    *ppCollection = p;

    LOG((RTC_TRACE, "CRTCSession::get_Participants - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::get_CanAddParticipants
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::get_CanAddParticipants(
        VARIANT_BOOL * pfCanAdd
        )
{
    LOG((RTC_TRACE, "CRTCSession::get_CanAddParticipants - enter"));

    if ( IsBadWritePtr(pfCanAdd , sizeof(VARIANT_BOOL) ) )
    {
        LOG((RTC_ERROR, "CRTCSession::get_CanAddParticipants - bad pointer"));

        return E_POINTER;
    }

    //
    // Set this to TRUE for now
    //

    *pfCanAdd = VARIANT_TRUE;

    switch ( m_enType )
    {

    case RTCST_PHONE_TO_PHONE:
        {
            //
            // This is a RTCST_PHONE_TO_PHONE session. We can add participants as long as 
            // the call is IDLE, INPROGRESS, or CONNECTED.
            //

            if ( (m_enState != RTCSS_IDLE) &&
                 (m_enState != RTCSS_INPROGRESS) &&
                 (m_enState != RTCSS_CONNECTED) )
            {
                LOG((RTC_ERROR, "CRTCSession::get_CanAddParticipants - "
                                    "session can not add participants"));

                *pfCanAdd = VARIANT_FALSE;
            }

            break;
        }

    case RTCST_PC_TO_PC:
    case RTCST_PC_TO_PHONE:
        {
            //
            // This is a RTCST_PC_TO_X session. We can only add participants when the session state
            // is IDLE.
            //

            if ( m_enState != RTCSS_IDLE )
            {
                LOG((RTC_ERROR, "CRTCSession::get_CanAddParticipants - "
                                "session can not add participants"));

                *pfCanAdd = VARIANT_FALSE;
            }

            break;
        }

    case RTCST_IM:
        {
            //
            // This is a RTCST_IM session. We can only add participants when the session state
            // is IDLE.
            //

            if ( m_enState != RTCSS_IDLE )
            {
                LOG((RTC_ERROR, "CRTCSession::get_CanAddParticipants - "
                                "session can not add participants"));

                *pfCanAdd = VARIANT_FALSE;
            }

            break;
        }

    default:
        {
            LOG((RTC_ERROR, "CRTCSession::get_CanAddParticipants - "
                                "invalid session type"));

            *pfCanAdd = VARIANT_FALSE;
        }
    }

    LOG((RTC_TRACE, "CRTCSession::get_CanAddParticipants - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::get_RedirectedUserURI
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::get_RedirectedUserURI(
        BSTR * pbstrUserURI
        )
{
    LOG((RTC_TRACE, "CRTCSession::get_RedirectedUserURI - enter" ));

    if ( IsBadWritePtr(pbstrUserURI , sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCSession::get_RedirectedUserURI - bad pointer"));

        return E_POINTER;
    }

    if ( m_pSipRedirectContext == NULL )
    {
        LOG((RTC_ERROR, "CRTCSession::get_RedirectedUserURI - no sip redirect context"));

        return RTC_E_INVALID_SESSION_STATE;
    }

    BSTR bstrSipUrl = NULL;
    BSTR bstrDisplayName = NULL;
    HRESULT hr;

    hr = m_pSipRedirectContext->GetSipUrlAndDisplayName(
                                    &bstrSipUrl,
                                    &bstrDisplayName
                                    );

    if ( SUCCEEDED(hr) )
    {
        LOG((RTC_INFO, "CRTCSession::get_RedirectedUserURI - [%ws]", bstrSipUrl ));

        *pbstrUserURI = bstrSipUrl;

        SysFreeString( bstrDisplayName );
    }

    LOG((RTC_TRACE, "CRTCSession::get_RedirectedUserURI - exit" ));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::get_RedirectedUserName
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::get_RedirectedUserName(
        BSTR * pbstrUserName
        )
{
    LOG((RTC_TRACE, "CRTCSession::get_RedirectedUserName - enter" ));

    if ( IsBadWritePtr(pbstrUserName , sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCSession::get_RedirectedUserName - bad pointer"));

        return E_POINTER;
    }

    if ( m_pSipRedirectContext == NULL )
    {
        LOG((RTC_ERROR, "CRTCSession::get_RedirectedUserName - no sip redirect context"));

        return RTC_E_INVALID_SESSION_STATE;
    }

    BSTR bstrSipUrl = NULL;
    BSTR bstrDisplayName = NULL;
    HRESULT hr;

    hr = m_pSipRedirectContext->GetSipUrlAndDisplayName(
                                    &bstrSipUrl,
                                    &bstrDisplayName
                                    );

    if ( SUCCEEDED(hr) )
    {
        LOG((RTC_INFO, "CRTCSession::get_RedirectedUserName - [%ws]", bstrDisplayName ));

        *pbstrUserName = bstrDisplayName;

        SysFreeString( bstrSipUrl );
    }

    LOG((RTC_TRACE, "CRTCSession::get_RedirectedUserName - exit" ));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::NextRedirectedUser
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::NextRedirectedUser()
{
    LOG((RTC_TRACE, "CRTCSession::NextRedirectedUser - enter" ));

    if ( m_pSipRedirectContext == NULL )
    {
        LOG((RTC_ERROR, "CRTCSession::NextRedirectedUser - no sip redirect context"));

        return RTC_E_INVALID_SESSION_STATE;
    }

    HRESULT hr;

    hr = m_pSipRedirectContext->Advance();

    LOG((RTC_TRACE, "CRTCSession::NextRedirectedUser - exit" ));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::NotifyCallChange
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCSession::NotifyCallChange(
        SIP_CALL_STATUS * CallStatus
        )
{
    LOG((RTC_TRACE, "CRTCSession::NotifyCallChange - enter"));

    switch (CallStatus->State)
    {
        case SIP_CALL_STATE_IDLE:
            SetState(RTCSS_IDLE,
                CallStatus->Status.StatusCode,
                CallStatus->Status.StatusText);
            break;

        case SIP_CALL_STATE_OFFERING:
            SetState(RTCSS_INCOMING,
                CallStatus->Status.StatusCode,
                CallStatus->Status.StatusText);
            break;

        case SIP_CALL_STATE_REJECTED:               
        case SIP_CALL_STATE_DISCONNECTED:
        case SIP_CALL_STATE_ERROR: 
            SetState(RTCSS_DISCONNECTED,
                CallStatus->Status.StatusCode,
                CallStatus->Status.StatusText);
            
            //
            // Don't access any member variables after the state is
            // set to disconnected. This object could be released.
            //
            break;

        case SIP_CALL_STATE_ALERTING:
        case SIP_CALL_STATE_CONNECTING:
            SetState(RTCSS_INPROGRESS,
                CallStatus->Status.StatusCode,
                CallStatus->Status.StatusText);
            break;

        case SIP_CALL_STATE_CONNECTED:
            SetState(RTCSS_CONNECTED,
                CallStatus->Status.StatusCode,
                CallStatus->Status.StatusText);
            break;        

        default:
            LOG((RTC_ERROR, "CRTCSession::NotifyCallChange - "
                                "invalid call state"));                                
    }

    LOG((RTC_TRACE, "CRTCSession::NotifyCallChange - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::NotifyStartOrStopStreamCompletion
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCSession::NotifyStartOrStopStreamCompletion(
        long                   lCookie,
        SIP_STATUS_BLOB       *pStatus
        )
{
    LOG((RTC_TRACE, "CRTCSession::NotifyStartOrStopStreamCompletion - enter"));

    CRTCSessionOperationCompleteEvent::FireEvent(
                                         this,
                                         lCookie,
                                         pStatus->StatusCode,
                                         pStatus->StatusText
                                        );   

    LOG((RTC_TRACE, "CRTCSession::NotifyStartOrStopStreamCompletion - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::NotifyPartyChange
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCSession::NotifyPartyChange(
        SIP_PARTY_INFO * PartyInfo
        )
{
    LOG((RTC_TRACE, "CRTCSession::NotifyPartyChange - enter"));

    //
    // Find the participant that we are being notified about
    //

    IRTCParticipant * pParticipant = NULL; 
    BSTR bstrUserURI = NULL;
    BOOL bFound = FALSE;
    HRESULT hr;

    for (int n = 0; (n < m_ParticipantArray.GetSize()) && (!bFound); n++)
    {
        pParticipant = m_ParticipantArray[n];

        hr = pParticipant->get_UserURI( &bstrUserURI );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::NotifyPartyChange - "
                                "get_UserURI[%p] failed 0x%lx",
                                pParticipant, hr));

            return hr;
        }

        if ( IsEqualURI( PartyInfo->URI, bstrUserURI ) )
        {
            //
            // This is a match
            //

            CRTCParticipant * pCParticipant;

            pCParticipant = static_cast<CRTCParticipant *>(pParticipant);            

            switch( PartyInfo->State )
            {
            case SIP_PARTY_STATE_CONNECT_INITIATED: // consider this a pending situation
            case SIP_PARTY_STATE_PENDING:
                pCParticipant->SetState(RTCPS_PENDING, PartyInfo->StatusCode);
                break;

            case SIP_PARTY_STATE_CONNECTING:
                pCParticipant->SetState(RTCPS_INPROGRESS, PartyInfo->StatusCode);
                break;
            
            case SIP_PARTY_STATE_DISCONNECT_INITIATED:
            case SIP_PARTY_STATE_DISCONNECTING:
                pCParticipant->SetState(RTCPS_DISCONNECTING, PartyInfo->StatusCode);
                break;

            case SIP_PARTY_STATE_REJECTED:
            case SIP_PARTY_STATE_DISCONNECTED:  
            case SIP_PARTY_STATE_ERROR:
                pCParticipant->SetState(RTCPS_DISCONNECTED, PartyInfo->StatusCode);

                //
                // Remove the participant from our array
                //
                m_ParticipantArray.Remove(pParticipant);  
                
                break;           

            case SIP_PARTY_STATE_CONNECTED:
                pCParticipant->SetState(RTCPS_CONNECTED, PartyInfo->StatusCode);
                break;
            
            default:
                LOG((RTC_ERROR, "CRTCSession::NotifyPartyChange - "
                                    "invalid party state"));               
            }

            bFound = TRUE;
        }

        SysFreeString( bstrUserURI );
    }

    if (!bFound)
    {
        LOG((RTC_ERROR, "CRTCSession::NotifyPartyChange - "
                            "participant not found")); 
        
        return E_FAIL;
    }

    LOG((RTC_TRACE, "CRTCSession::NotifyPartyChange - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::NotifyRedirect
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCSession::NotifyRedirect(
        ISipRedirectContext * pSipRedirectContext,
        SIP_CALL_STATUS * pCallStatus
        )
{
    LOG((RTC_TRACE, "CRTCSession::NotifyRedirect - enter"));

    HRESULT hr;

    //
    // Save the redirect context
    //

    if ( m_pSipRedirectContext != NULL )
    {
        m_pSipRedirectContext->Release();
        m_pSipRedirectContext = NULL;
    }

    m_pSipRedirectContext = pSipRedirectContext;
    m_pSipRedirectContext->AddRef();
  
    if ( m_lFlags & RTCCS_FAIL_ON_REDIRECT )
    {
        //
        // Change the session state, notifying the UI
        //

        SetState(RTCSS_DISCONNECTED,
                    pCallStatus->Status.StatusCode,
                    pCallStatus->Status.StatusText);

        //
        // Don't access any member variables after the state is
        // set to disconnected. This object could be released.
        //
    }
    else
    {
        //
        // Do the redirection
        //

        BSTR bstrLocalPhoneURI = NULL;
        BSTR bstrRedirectedUserURI = NULL;
        BSTR bstrRedirectedUserName = NULL;

        hr = m_pSipRedirectContext->Advance();

        if ( hr != S_OK )
        {            
            if ( hr == S_FALSE )
            {
                LOG((RTC_ERROR, "CRTCSession::NotifyRedirect - "
                            "redirect list empty"));
            }
            else
            {
                LOG((RTC_ERROR, "CRTCSession::NotifyRedirect - "
                            "Advance failed 0x%lx", hr)); 
            }

            SetState(RTCSS_DISCONNECTED,
                    pCallStatus->Status.StatusCode,
                    pCallStatus->Status.StatusText);

            //
            // Don't access any member variables after the state is
            // set to disconnected. This object could be released.
            //
    
            return hr;
        }

        hr = m_pSipRedirectContext->GetSipUrlAndDisplayName( &bstrRedirectedUserURI, &bstrRedirectedUserName );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::NotifyRedirect - "
                        "GetSipUrlAndDisplayName failed 0x%lx", hr)); 

            SetState(RTCSS_DISCONNECTED,
                    pCallStatus->Status.StatusCode,
                    pCallStatus->Status.StatusText);

            //
            // Don't access any member variables after the state is
            // set to disconnected. This object could be released.
            //

            return hr;
        }

        if ( m_szLocalPhoneURI != NULL )
        {
            bstrLocalPhoneURI = SysAllocString( m_szLocalPhoneURI );

            if ( bstrLocalPhoneURI == NULL )
            {
                LOG((RTC_ERROR, "CRTCSession::NotifyRedirect - "
                            "out of memory")); 

                SysFreeString( bstrRedirectedUserName );
                bstrRedirectedUserName = NULL;

                SysFreeString( bstrRedirectedUserURI );
                bstrRedirectedUserURI = NULL;

                SetState(RTCSS_DISCONNECTED,
                    pCallStatus->Status.StatusCode,
                    pCallStatus->Status.StatusText);

                //
                // Don't access any member variables after the state is
                // set to disconnected. This object could be released.
                //
        
                return E_OUTOFMEMORY;
            }
        }

        if ( m_enType == RTCST_PHONE_TO_PHONE )
        {
            //
            // We must redirect to a new phone to phone proxy
            //

            m_szRedirectProxy = RtcAllocString( bstrRedirectedUserURI );

            SysFreeString( bstrRedirectedUserName );
            bstrRedirectedUserName = NULL;

            SysFreeString( bstrRedirectedUserURI );
            bstrRedirectedUserURI = NULL;

            if ( m_szRedirectProxy == NULL )
            {
                LOG((RTC_ERROR, "CRTCSession::NotifyRedirect - "
                            "out of memory")); 

                SetState(RTCSS_DISCONNECTED,
                    pCallStatus->Status.StatusCode,
                    pCallStatus->Status.StatusText);

                //
                // Don't access any member variables after the state is
                // set to disconnected. This object could be released.
                //
        
                return E_OUTOFMEMORY;
            }

            //
            // Use the Name and URI of last participant
            //

            bstrRedirectedUserName = SysAllocString( m_szRemoteUserName );

            if ( bstrRedirectedUserName == NULL )
            {
                LOG((RTC_ERROR, "CRTCSession::NotifyRedirect - "
                            "out of memory")); 

                RtcFree(m_szRedirectProxy);
                m_szRedirectProxy = NULL;

                SetState(RTCSS_DISCONNECTED,
                    pCallStatus->Status.StatusCode,
                    pCallStatus->Status.StatusText);

                //
                // Don't access any member variables after the state is
                // set to disconnected. This object could be released.
                //
        
                return E_OUTOFMEMORY;
            }
            
            bstrRedirectedUserURI = SysAllocString( m_szRemoteUserURI );

            if ( bstrRedirectedUserURI == NULL )
            {
                LOG((RTC_ERROR, "CRTCSession::NotifyRedirect - "
                            "out of memory")); 

                RtcFree(m_szRedirectProxy);
                m_szRedirectProxy = NULL;

                SysFreeString(bstrRedirectedUserName);
                bstrRedirectedUserName = NULL;

                SetState(RTCSS_DISCONNECTED,
                    pCallStatus->Status.StatusCode,
                    pCallStatus->Status.StatusText);

                //
                // Don't access any member variables after the state is
                // set to disconnected. This object could be released.
                //
        
                return E_OUTOFMEMORY;
            }
        }

        IRTCProfile * pProfile = m_pProfile;

        if ( pProfile != NULL )
        {
            pProfile->AddRef();
        }

        hr = Redirect( m_enType, bstrLocalPhoneURI, pProfile, m_lFlags & ~RTCCS_FORCE_PROFILE );

        if ( pProfile != NULL )
        {
            pProfile->Release();
            pProfile = NULL;
        }

        if ( bstrLocalPhoneURI != NULL )
        {
            SysFreeString( bstrLocalPhoneURI );
            bstrLocalPhoneURI = NULL;
        }

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::NotifyRedirect - "
                        "Redirect failed 0x%lx", hr)); 

            if ( m_szRedirectProxy != NULL )
            {
                RtcFree(m_szRedirectProxy);
                m_szRedirectProxy = NULL;
            }

            SysFreeString( bstrRedirectedUserName );
            bstrRedirectedUserName = NULL;

            SysFreeString( bstrRedirectedUserURI );
            bstrRedirectedUserURI = NULL;

            SetState(RTCSS_DISCONNECTED,
                    pCallStatus->Status.StatusCode,
                    pCallStatus->Status.StatusText);

            //
            // Don't access any member variables after the state is
            // set to disconnected. This object could be released.
            //
    
            return hr;
        }
        
        hr = AddParticipant( bstrRedirectedUserURI, bstrRedirectedUserName, NULL );

        if ( m_szRedirectProxy != NULL )
        {
            RtcFree(m_szRedirectProxy);
            m_szRedirectProxy = NULL;
        }

        SysFreeString( bstrRedirectedUserName );
        bstrRedirectedUserName = NULL;

        SysFreeString( bstrRedirectedUserURI );
        bstrRedirectedUserURI = NULL;

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::NotifyRedirect - "
                        "AddParticipant failed 0x%lx", hr)); 

            SetState(RTCSS_DISCONNECTED,
                    pCallStatus->Status.StatusCode,
                    pCallStatus->Status.StatusText);

            //
            // Don't access any member variables after the state is
            // set to disconnected. This object could be released.
            //
    
            return hr;
        }
    }

    LOG((RTC_TRACE, "CRTCSession::NotifyRedirect - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::NotifyMessageRedirect
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::NotifyMessageRedirect(
            ISipRedirectContext    *pRedirectContext,
            SIP_CALL_STATUS        *pCallStatus,
            BSTR                   bstrMsg,
            BSTR                   bstrContentType,
            USR_STATUS             UsrStatus,
            long                   lCookie
            )
{
    HRESULT hr;

    LOG((RTC_TRACE, "CRTCSession::NotifyMessageRedirect - enter"));
    
    //
    // First, do normal redirect processing
    //

    hr = NotifyRedirect(pRedirectContext, pCallStatus);

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::NotifyMessageRedirect - "
                    "NotifyRedirect failed 0x%lx", hr)); 
       
        //
        // Due to failure we need to notify operation complete
        //
       
        CRTCSessionOperationCompleteEvent::FireEvent(
                                         this,
                                         lCookie,
                                         pCallStatus->Status.StatusCode,
                                         pCallStatus->Status.StatusText
                                        ); 

        SetState( RTCSS_DISCONNECTED, pCallStatus->Status.StatusCode, pCallStatus->Status.StatusText );

        //
        // Don't access any member variables after the state is
        // set to disconnected. This object could be released.
        //

        return hr;
    }

    if ( m_lFlags & RTCCS_FAIL_ON_REDIRECT )
    {
        //
        // Due to failure we need to notify operation complete
        //

        CRTCSessionOperationCompleteEvent::FireEvent(
                                         this,
                                         lCookie,
                                         pCallStatus->Status.StatusCode,
                                         pCallStatus->Status.StatusText
                                        ); 

        SetState( RTCSS_DISCONNECTED, pCallStatus->Status.StatusCode, pCallStatus->Status.StatusText );

        //
        // Don't access any member variables after the state is
        // set to disconnected. This object could be released.
        //
    }
    else
    {
        //
        // Resend the message/info
        //

        if ( bstrMsg != NULL )
        {
            hr = m_pIMSession->SendTextMessage( bstrMsg, bstrContentType, lCookie );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCSession::NotifyMessageRedirect - "
                        "SendTextMessage failed 0x%lx", hr));

                //
                // Due to failure we need to notify operation complete
                //

                CRTCSessionOperationCompleteEvent::FireEvent(
                                                 this,
                                                 lCookie,
                                                 pCallStatus->Status.StatusCode,
                                                 pCallStatus->Status.StatusText
                                                ); 

                SetState( RTCSS_DISCONNECTED, pCallStatus->Status.StatusCode, pCallStatus->Status.StatusText );

                //
                // Don't access any member variables after the state is
                // set to disconnected. This object could be released.
                //

                return hr;
            } 
        }
        else
        {
            hr = m_pIMSession->SendUsrStatus( UsrStatus, lCookie );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CRTCSession::NotifyMessageRedirect - "
                        "SendUsrStatus failed 0x%lx", hr));

                //
                // Due to failure we need to notify operation complete
                //

                CRTCSessionOperationCompleteEvent::FireEvent(
                                                 this,
                                                 lCookie,
                                                 pCallStatus->Status.StatusCode,
                                                 pCallStatus->Status.StatusText
                                                ); 

                SetState( RTCSS_DISCONNECTED, pCallStatus->Status.StatusCode, pCallStatus->Status.StatusText );

                //
                // Don't access any member variables after the state is
                // set to disconnected. This object could be released.
                //

                return hr;
            }
        }
    }

    LOG((RTC_TRACE, "CRTCSession::NotifyMessageRedirect - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::NotifyIncomingMessage
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCSession::NotifyIncomingMessage(
            IIMSession *pSession,
            BSTR msg,
            BSTR ContentType,
            SIP_PARTY_INFO * CallerInfo
            )
{
    LOG((RTC_TRACE, "CRTCSession::NotifyIncomingMessage - enter"));

    if ( m_enType != RTCST_IM )
    {
        LOG((RTC_ERROR, "CRTCSession::NotifyIncomingMessage - "
                "valid only for RTCST_IM sessions"));

        return RTC_E_INVALID_SESSION_TYPE;
    }

    //
    // Find the participant that we are being notified about
    //

    IRTCParticipant * pParticipant = NULL; 
    BSTR bstrUserURI = NULL;
    BOOL bFound = FALSE;
    HRESULT hr;

    for (int n = 0; (n < m_ParticipantArray.GetSize()) && (!bFound); n++)
    {
        pParticipant = m_ParticipantArray[n];

        hr = pParticipant->get_UserURI( &bstrUserURI );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::NotifyIncomingMessage - "
                                "get_UserURI[%p] failed 0x%lx",
                                pParticipant, hr));

            return hr;
        }

        if ( IsEqualURI( CallerInfo->URI, bstrUserURI ) )
        {
            //
            // This is a match
            //

            //
            // Fire a message event
            //
    
            CRTCMessagingEvent::FireEvent(this, pParticipant, msg, ContentType, RTCMSET_MESSAGE, RTCMUS_IDLE);

            bFound = TRUE;
        }

        SysFreeString( bstrUserURI );
    }

    if (!bFound)
    {
        LOG((RTC_ERROR, "CRTCSession::NotifyIncomingMessage - "
                            "participant not found")); 
        
        return E_FAIL;
    }

    LOG((RTC_TRACE, "CRTCSession::NotifyIncomingMessage - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::NotifyUsrStatus
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::NotifyUsrStatus(
        USR_STATUS  UsrStatus,
        SIP_PARTY_INFO * CallerInfo
        )
{
    LOG((RTC_TRACE, "CRTCSession::NotifyUsrStatus - enter"));

    if ( m_enType != RTCST_IM )
    {
        LOG((RTC_ERROR, "CRTCSession::NotifyUsrStatus - "
                "valid only for RTCST_IM sessions"));

        return RTC_E_INVALID_SESSION_TYPE;
    }

    //
    // Find the participant that we are being notified about
    //

    IRTCParticipant * pParticipant = NULL; 
    BSTR bstrUserURI = NULL;
    BOOL bFound = FALSE;
    HRESULT hr;

    for (int n = 0; (n < m_ParticipantArray.GetSize()) && (!bFound); n++)
    {
        pParticipant = m_ParticipantArray[n];

        hr = pParticipant->get_UserURI( &bstrUserURI );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCSession::NotifyUsrStatus - "
                                "get_UserURI[%p] failed 0x%lx",
                                pParticipant, hr));

            return hr;
        }

        if ( IsEqualURI( CallerInfo->URI, bstrUserURI ) )
        {
            //
            // This is a match
            //

            //
            // Fire a message event
            //
            
            switch ( UsrStatus )
            {
            case USR_STATUS_IDLE:
                CRTCMessagingEvent::FireEvent(this, pParticipant, NULL, NULL, RTCMSET_STATUS, RTCMUS_IDLE);
                break;

            case USR_STATUS_TYPING:
                CRTCMessagingEvent::FireEvent(this, pParticipant, NULL, NULL, RTCMSET_STATUS, RTCMUS_TYPING);
                break;

            default:
                LOG((RTC_ERROR, "CRTCSession::NotifyUsrStatus - "
                            "invalid USR_STATUS")); 
            }

            bFound = TRUE;
        }

        SysFreeString( bstrUserURI );
    }

    if (!bFound)
    {
        LOG((RTC_ERROR, "CRTCSession::NotifyUsrStatus - "
                            "participant not found")); 
        
        return E_FAIL;
    }

    LOG((RTC_TRACE, "CRTCSession::NotifyUsrStatus - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::NotifyMessageCompletion
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::NotifyMessageCompletion(
        SIP_STATUS_BLOB *      pStatus,
        long                   lCookie
        )
{
    LOG((RTC_TRACE, "CRTCSession::NotifyMessageCompletion - enter"));

    if ( (HRESULT_FACILITY(pStatus->StatusCode) == FACILITY_SIP_STATUS_CODE) &&
         (HRESULT_CODE(pStatus->StatusCode) >= 300) &&
         (HRESULT_CODE(pStatus->StatusCode) <= 399) )  
    {
        //
        // Ignore the redirect because we will handle this in NotifyMessageRedirect. We
        // will notify completion on redirection error, or on completion of the
        // redirected message.
        //

        LOG((RTC_TRACE, "CRTCSession::NotifyMessageCompletion - ignoring redirect"));

        return S_OK;
    }

    if ( SUCCEEDED(pStatus->StatusCode) && (m_enState != RTCSS_CONNECTED) )
    {
        //
        // If the first result is success, set the session state to connected
        //

        SetState( RTCSS_CONNECTED, pStatus->StatusCode, pStatus->StatusText );
    }

    CRTCSessionOperationCompleteEvent::FireEvent(
                                         this,
                                         lCookie,
                                         pStatus->StatusCode,
                                         pStatus->StatusText
                                        );  

    if ( FAILED(pStatus->StatusCode) && (m_enState != RTCSS_CONNECTED) )
    {
        //
        // If the first result is failure, set the session state to disconnected
        //

        SetState( RTCSS_DISCONNECTED, pStatus->StatusCode, pStatus->StatusText );

        //
        // Don't access any member variables after the state is
        // set to disconnected. This object could be released.
        //
    }

    LOG((RTC_TRACE, "CRTCSession::NotifyMessageCompletion - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCSession::SetPortManager
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCSession::SetPortManager(
            IRTCPortManager * pPortManager
            )
{
    IRTCMediaManage * pMedia = NULL;
    HRESULT hr;

    LOG((RTC_TRACE, "CRTCSession::SetPortManager - enter"));

    if ( (pPortManager != NULL) &&
         IsBadReadPtr( pPortManager, sizeof(IRTCPortManager) ) )
    {
        LOG((RTC_ERROR, "CRTCSession::SetPortManager - "
                            "bad IRTCPortManager pointer"));

        return E_POINTER;
    }

    // port manager can only be set on pc-to-XXX sessions
    if ( m_enType != RTCST_PC_TO_PHONE )
    {
        LOG((RTC_ERROR, "CRTCSession::SetPortManager - "
                "not a pc2phone call"));

        return RTC_E_INVALID_SESSION_TYPE;
    }

    hr = m_pCClient->GetMediaManager(&pMedia);

    if (FAILED(hr))
    {
        return hr;
    }

    hr = pMedia->SetPortManager(pPortManager);

    pMedia->Release();

    LOG((RTC_TRACE, "CRTCSession::SetPortManager - exit"));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\rtcreg.h ===
//
// rtcreg.h
//

#ifndef __RTCREG_H_
#define __RTCREG_H_

typedef enum RTC_REGISTRY_STRING
{
    RTCRS_TERM_AUDIO_CAPTURE,
    RTCRS_TERM_AUDIO_RENDER,
    RTCRS_TERM_VIDEO_CAPTURE
    
} RTC_REGISTRY_STRING;

typedef enum RTC_REGISTRY_DWORD
{
    RTCRD_PREFERRED_MEDIA_TYPES,
    RTCRD_TUNED
    
} RTC_REGISTRY_DWORD;


HRESULT put_RegistryString(
        RTC_REGISTRY_STRING enSetting,
        BSTR bstrValue            
        ); 

HRESULT get_RegistryString(
        RTC_REGISTRY_STRING enSetting,
        BSTR * pbstrValue            
        ); 

HRESULT DeleteRegistryString(
        RTC_REGISTRY_STRING enSetting
        );

HRESULT put_RegistryDword(
        RTC_REGISTRY_DWORD enSetting,
        DWORD dwValue            
        ); 

HRESULT get_RegistryDword(
        RTC_REGISTRY_DWORD enSetting,
        DWORD * pdwValue            
        ); 

HRESULT DeleteRegistryDword(
        RTC_REGISTRY_DWORD enSetting
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\rtcprofile.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCProfile.h

Abstract:

    Definition of the CRTCProfile class

--*/

#ifndef __RTCPROFILE__
#define __RTCPROFILE__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

struct PROF_PROVISION
{
    PWSTR szKey;
    PWSTR szName;
    PWSTR szExpires;
};

struct PROF_PROVIDER
{
    PWSTR szName;
    PWSTR szHomepage;
    PWSTR szHelpdesk;
    PWSTR szPersonal;
    PWSTR szCallDisplay;
    PWSTR szIdleDisplay;
    PWSTR szData;
};

struct PROF_CLIENT
{
    PWSTR szName;
    BOOL fBanner;
    PWSTR szMinVer;
    PWSTR szCurVer;
    PWSTR szUpdateUri;
    PWSTR szData;
};

struct PROF_USER
{
    PWSTR szAccount;
    PWSTR szName;
    PWSTR szUri;
    PWSTR szPassword;
    PWSTR szRealm;
};

struct PROF_SERVER
{
    PWSTR szAddr;
    SIP_TRANSPORT enProtocol;
    SIP_AUTH_PROTOCOL enAuth;    
    long lSessions;
    BOOL fRegistrar;
};

/*
struct PROF_ACCESSCONTROL
{
    PWSTR szDomain;
    PWSTR szSig;
};
*/

/////////////////////////////////////////////////////////////////////////////
// CRTCProfile

class ATL_NO_VTABLE CRTCProfile :
#ifdef TEST_IDISPATCH
    public IDispatchImpl<IRTCProfile, &IID_IRTCProfile, &LIBID_RTCCORELib>,
#else
    public IRTCProfile,
#endif
    public CComObjectRoot
{
public:
    CRTCProfile() : m_pCClient(NULL),
                    m_szProfileXML(NULL),
                    m_ProfileGuid(GUID_NULL),
                    m_enState(RTCRS_NOT_REGISTERED),
                    m_fValid(FALSE),
                    m_fEnabled(FALSE),
                    m_lRegisterFlags(0),
                    m_pSipStack(NULL)
    {}
    
BEGIN_COM_MAP(CRTCProfile)
#ifdef TEST_IDISPATCH
    COM_INTERFACE_ENTRY(IDispatch)
#endif
    COM_INTERFACE_ENTRY(IRTCProfile)
END_COM_MAP()

    HRESULT FinalConstruct();

    void FinalRelease();   

    STDMETHOD_(ULONG, InternalAddRef)();

    STDMETHOD_(ULONG, InternalRelease)(); 
                      
    HRESULT InitializeFromString(
                                 BSTR bstrProfileXML,
                                 CRTCClient * pCClient,
                                 ISipStack * pSipStack
                                );

    HRESULT GetSipProviderProfile(
                                  SIP_PROVIDER_PROFILE * pProfile,
                                  long lRegisterFlags
                                 );

    HRESULT FreeSipProviderProfile(
                                   SIP_PROVIDER_PROFILE * pProfile
                                  );

    HRESULT GetSipProxyServerInfo(
                                  long lSessionType,
                                  SIP_SERVER_INFO * pProxy
                                 );

    HRESULT FreeSipServerInfo(
                              SIP_SERVER_INFO * pServerInfo
                             );

    HRESULT GetRealm(
                     BSTR * pbstrRealm
                    );

    HRESULT GetCredentials(
                     BSTR * pbstrUserAccount,
                     BSTR * pbstrUserPassword,
                     SIP_AUTH_PROTOCOL *pAuth
                     );

    //
    // XML Parsing
    //

    HRESULT ParseXMLDOMElementForAttribute(
                            IXMLDOMElement * pElement,
                            PCWSTR szAttrib,
                            BOOL fRequired,
                            PWSTR * szValue
                            );

    HRESULT ParseXMLDOMNodeForData(
                            IXMLDOMNode * pNode,
                            PWSTR * szValue
                            );

    HRESULT ParseXMLDOMNodeForProvision(
                            IXMLDOMNode * pNode,
                            PROF_PROVISION * pStruct
                            );

    HRESULT ParseXMLDOMNodeForProvider(
                            IXMLDOMNode * pNode,
                            PROF_PROVIDER * pStruct
                            );

    HRESULT ParseXMLDOMNodeForClient(
                            IXMLDOMNode * pNode,
                            PROF_CLIENT * pStruct
                            );

    HRESULT ParseXMLDOMNodeForUser(
                            IXMLDOMNode * pNode,
                            PROF_USER * pStruct
                            );

    HRESULT ParseXMLDOMNodeForServer(
                            IXMLDOMNode * pNode,
                            PROF_SERVER * pStruct
                            );

    HRESULT ParseXMLDOMNodeForSession(
                            IXMLDOMNode * pNode,
                            long * plSession
                            );

/*
    HRESULT ParseXMLDOMNodeForAccessControl(
                            IXMLDOMNode * pNode,
                            PROF_ACCESSCONTROL * pStruct
                            );
*/

    HRESULT ParseXMLDOMDocument(
                            IXMLDOMDocument * pXMLDoc
                            );

    void FreeProvision(PROF_PROVISION * pStruct);
    void FreeProvider(PROF_PROVIDER * pStruct);
    void FreeClient(PROF_CLIENT * pStruct);
    void FreeUser(PROF_USER * pStruct);
    void FreeServer(PROF_SERVER * pStruct);

/*
    void FreeAccessControl(PROF_ACCESSCONTROL * pStruct);

    HRESULT ValidateAccessControl();

    BOOL IsMatchingAddress(WCHAR *pszAddress, WCHAR *pszPattern);
*/

    HRESULT SetState(
            RTC_REGISTRATION_STATE enState,
            long lStatusCode,
            PCWSTR szStatusText
            );

    HRESULT Enable(long lRegisterFlags);

    HRESULT Disable();

    HRESULT Redirect(ISipRedirectContext * pSipRedirectContext);

    void GetGuid(GUID * pGUID);

private:

    CRTCClient            * m_pCClient;
    PWSTR                   m_szProfileXML;
    GUID                    m_ProfileGuid;
    RTC_REGISTRATION_STATE  m_enState;
    BOOL                    m_fValid;
    BOOL                    m_fEnabled;
    long                    m_lRegisterFlags;
    ISipStack             * m_pSipStack;

    PROF_PROVISION          m_Provision;
    PROF_PROVIDER           m_Provider;
    PROF_CLIENT             m_Client;
    PROF_USER               m_User;
    CRTCArray<PROF_SERVER>  m_ServerArray;
/*
    CRTCArray<PROF_ACCESSCONTROL> m_AccessControlArray;
*/

#if DBG
    PWSTR                   m_pDebug;
#endif
    
// IRTCProfile
public:
    STDMETHOD(get_Key)(
            BSTR * pbstrKey
            );

    STDMETHOD(get_Name)(
            BSTR * pbstrName
            );

    STDMETHOD(get_XML)(
            BSTR * pbstrXML
            );

    // Provider

    STDMETHOD(get_ProviderName)(
            BSTR * pbstrName
            ); 

    STDMETHOD(get_ProviderURI)(
            RTC_PROVIDER_URI enURI,
            BSTR * pbstrURI
            ); 

    STDMETHOD(get_ProviderData)(
            BSTR * pbstrData
            );

    // Client

    STDMETHOD(get_ClientName)(
            BSTR * pbstrName
            ); 

    STDMETHOD(get_ClientBanner)(
            VARIANT_BOOL * pfBanner
            ); 

    STDMETHOD(get_ClientMinVer)(
            BSTR * pbstrMinVer
            ); 

    STDMETHOD(get_ClientCurVer)(
            BSTR * pbstrCurVer
            ); 

    STDMETHOD(get_ClientUpdateURI)(
            BSTR * pbstrUpdateURI
            ); 

    STDMETHOD(get_ClientData)(
            BSTR * pbstrData
            ); 

    // User

    STDMETHOD(get_UserURI)(
            BSTR * pbstrUserURI
            );

    STDMETHOD(get_UserName)(
            BSTR * pbstrUserName
            );
    
    STDMETHOD(get_UserAccount)(
            BSTR * pbstrUserAccount
            );

    STDMETHOD(SetCredentials)(
            BSTR    bstrUserURI,
            BSTR    bstrUserAccount,
            BSTR    bstrPassword
            );

    // Server
        
    STDMETHOD(get_SessionCapabilities)(
            long * plSupportedSessions
            );

    // Registration

    STDMETHOD(get_State)(
            RTC_REGISTRATION_STATE * penState
            );
};

#endif //__RTCPROFILE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\rtcwatcher.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCWatcher.cpp

Abstract:

    Definition of the CRTCWatcher class

--*/
#include "stdafx.h"


/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::FinalConstruct
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCWatcher::FinalConstruct()
{
    LOG((RTC_TRACE, "CRTCWatcher::FinalConstruct [%p] - enter", this));

#if DBG
    m_pDebug = (PWSTR) RtcAlloc( sizeof(void *) );
    *((void **)m_pDebug) = this;
#endif

    LOG((RTC_TRACE, "CRTCWatcher::FinalConstruct [%p] - exit S_OK", this));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCWatcher::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCWatcher::FinalRelease [%p] - enter", this));

    RemoveSIPWatchers(FALSE);

    ReleaseAll();

    m_SIPWatchers.Shutdown();

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    LOG((RTC_TRACE, "CRTCWatcher::FinalRelease [%p] - exit", this));
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::InternalAddRef
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CRTCWatcher::InternalAddRef()
{
    DWORD dwR;

    dwR = InterlockedIncrement(&m_dwRef);

    LOG((RTC_INFO, "CRTCWatcher::InternalAddRef [%p] - dwR %d", this, dwR));

    return dwR;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::InternalRelease
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CRTCWatcher::InternalRelease()
{
    DWORD               dwR;
    
    dwR = InterlockedDecrement(&m_dwRef);

    LOG((RTC_INFO, "CRTCWatcher::InternalRelease [%p] - dwR %d", this, dwR));

    return dwR;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::ReleaseAll
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCWatcher::ReleaseAll()
{
    if ( m_pCClient != NULL )
    {
        m_pCClient->Release();
        m_pCClient = NULL;
    }

    if ( m_pSIPWatcherManager != NULL )
    {
        m_pSIPWatcherManager->Release();
        m_pSIPWatcherManager = NULL;
    }

    if ( m_szName != NULL )
    {
        RtcFree(m_szName);
        m_szName = NULL;
    }
    
    if ( m_szData != NULL )
    {
        RtcFree(m_szData);
        m_szData = NULL;
    }

	if ( m_szShutdownBlob != NULL )
    {
        RtcFree(m_szShutdownBlob);
        m_szShutdownBlob = NULL;
    }

    if ( m_szPresentityURI != NULL )
    {
        RtcFree(m_szPresentityURI);
        m_szPresentityURI = NULL;
    }
}



/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::Initialize
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCWatcher::Initialize(
                            CRTCClient         * pCClient, 
                            ISIPWatcherManager * pSIPWatcherManager,
                            PCWSTR               szPresentityURI,
                            PCWSTR               szName,
                            PCWSTR               szData,
                            PCWSTR               szShutdownBlob,
                            BOOL                 bPersistent
                            )
{
    LOG((RTC_TRACE, "CRTCWatcher::Initialize - enter"));

    if ( IsBadReadPtr( pCClient, sizeof(CRTCClient) ) )
    {
        LOG((RTC_ERROR, "CRTCWatcher::Initialize - "
                            "bad CRTCClient pointer"));

        return E_POINTER;
    }

    if ( IsBadReadPtr( pSIPWatcherManager, sizeof(ISIPWatcherManager) ) )
    {
        LOG((RTC_ERROR, "CRTCWatcher::Initialize - "
                            "bad ISIPWatcherManager pointer"));

        return E_POINTER;
    }

    // this object supports re-initialize
    ReleaseAll();

    m_szPresentityURI = RtcAllocString(szPresentityURI);
    m_szName = RtcAllocString(szName);
    m_szData = RtcAllocString(szData);
    m_szShutdownBlob = RtcAllocString(szShutdownBlob);

    m_bPersistent = bPersistent;

    m_pCClient = pCClient;
    m_pCClient->AddRef();

    m_pSIPWatcherManager = pSIPWatcherManager;
    m_pSIPWatcherManager->AddRef();

    LOG((RTC_TRACE, "CRTCWatcher::Initialize - exit S_OK"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::SetSIPWatcher
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCWatcher::SetSIPWatcher(
        ISIPWatcher * pSIPWatcher
)
{
    LOG((RTC_TRACE, "CRTCWatcher::SetSIPWatcher - enter"));

    HRESULT     hr;

    //
    // Clear the watcher shutdown blob
    //

    if ( m_szShutdownBlob != NULL )
    {
        RtcFree( m_szShutdownBlob );
        m_szShutdownBlob = NULL;
    }

    //
    // Search an existing entry. Add the pointer only when it is not yet in the array
    //
    int   iIndex;

    iIndex = m_SIPWatchers.Find(pSIPWatcher);

    if(iIndex!=-1)
    {
        // Hmm, the SIP watcher is already here...

        LOG((RTC_WARN, "CRTCWatcher::SetSIPWatcher - "
                                "Duplicate offer watcher"));

        return S_OK;
    }

    // there is no entry
    // create one
    BOOL fResult;

    fResult = m_SIPWatchers.Add(pSIPWatcher);
    
    if(!fResult)
    {
        LOG((RTC_ERROR, "CRTCClient::SetSIPWatcher - "
                               "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCWatcher::SetSIPWatcher - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::RemoveSIPWatcher
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCWatcher::RemoveSIPWatcher(
        ISIPWatcher * pSIPWatcher,
        BOOL bShutdown)
{
    LOG((RTC_TRACE, "CRTCWatcher::RemoveSIPWatcher - enter"));

    HRESULT hr; 

    //
    // Search in the array
    //

    int   iIndex;

    iIndex = m_SIPWatchers.Find(pSIPWatcher);

    if(iIndex==-1)
    {
        LOG((RTC_WARN, "CRTCWatcher::RemoveSIPWatcher - "
            "SIP watcher not found in the array"));

        // remove it from the SIP list of watchers.

        m_pSIPWatcherManager->RemoveWatcher(
        pSIPWatcher,
        bShutdown ? APPLICATION_SHUTDOWN : BUDDY_REMOVED_BYUSER);

        return E_FAIL;
        // continue
    }

    // remove from the SIP watcher list
    // There are some cases (for some of the core watchers in OFFERING state)
    // this call is not necessary, but we'd better call it rather than leaking something
    //

    hr = RemoveSIPWatcher(iIndex, bShutdown);

    if ( FAILED(hr) )
    {        
        LOG((RTC_ERROR, "CRTCWatcher::RemoveSIPWatcher - "
                        "RemoveSIPWatcher (index) failed 0x%lx", hr));
    } 

    LOG((RTC_TRACE, "CRTCWatcher::RemoveSIPWatcher - exit S_OK"));

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::RemoveSIPWatcher (by index)
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCWatcher::RemoveSIPWatcher(
        int  iIndex,
        BOOL bShutdown)
{
    LOG((RTC_TRACE, "CRTCWatcher::RemoveSIPWatcher (index) - enter"));

    HRESULT hr; 

    // remove from the SIP watcher list
    // There are some cases (for some of the core watchers in OFFERING state)
    // this call is not necessary, but we'd better call it rather than leaking something
    //

    hr = m_pSIPWatcherManager->RemoveWatcher(
            m_SIPWatchers[iIndex],
            bShutdown ? APPLICATION_SHUTDOWN : BUDDY_REMOVED_BYUSER);

    if ( FAILED(hr) )
    {        
        LOG((RTC_ERROR, "CRTCWatcher::RemoveSIPWatcher (index) - "
                        "RemoveWatcher failed 0x%lx", hr));
    } 

    // Don't change the array if we are in the middle of some iteration
    if(m_bIsNested)
    {
        ISIPWatcher     *pSIPWatcher;
        
        pSIPWatcher = m_SIPWatchers[iIndex];
        m_SIPWatchers[iIndex] = NULL;
        
        pSIPWatcher->Release();
    }
    else
    {
        // remove from array
        //
        m_SIPWatchers.RemoveAt(iIndex);
    }

    LOG((RTC_TRACE, "CRTCWatcher::RemoveSIPWatcher (index) - exit S_OK"));

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::ChangeBlockedStatus
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCWatcher::ChangeBlockedStatus(
    WATCHER_BLOCKED_STATUS Status)
{
    HRESULT         hrAll = S_OK;
    
    if ( Status == WATCHER_UNBLOCKED )
    {
        //
        // Send the watcher shutdown blob if it exists
        //

        SendSIPWatcherShutdownBlob();
    }

    ISIPWatcher     ** pCrt;
    ISIPWatcher     ** pEnd;

    m_bIsNested = TRUE;

    for(pCrt = &m_SIPWatchers[0], pEnd = pCrt + m_SIPWatchers.GetSize();
        pCrt < pEnd;
        pCrt ++)
    {
        HRESULT     hr;

        hr = (*pCrt)->ChangeBlockedStatus(Status);
    
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCWatcher::ChangeBlockStatus - "
                            "ChangeBlockStatus failed 0x%lx", hr));

            if(hrAll==S_OK)
            {
                hrAll = hr;
            }
        }
    }

    m_bIsNested = FALSE;

    PostSIPWatchersCleanUp();

    return hrAll;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::RemoveSIPWatchers
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCWatcher::RemoveSIPWatchers(
        BOOL bShutdown)
{
    HRESULT         hrAll = S_OK;

    LOG((RTC_TRACE, "CRTCWatcher::RemoveSIPWatchers - enter"));

    m_bIsNested = TRUE;

    int iIndex;    

    for(iIndex = 0;
        iIndex < m_SIPWatchers.GetSize();
        iIndex ++)
    {
        HRESULT     hr;

        hr = RemoveSIPWatcher(
            iIndex,
            bShutdown);
    
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCWatcher::RemoveSIPWatchers - "
                            "RemoveSIPWatcher (index) failed 0x%lx", hr));

            if(hrAll==S_OK)
            {
                hrAll = hr;
            }
        }
    }

    m_bIsNested = FALSE;

    PostSIPWatchersCleanUp();
    
    LOG((RTC_TRACE, "CRTCWatcher::RemoveSIPWatchers - exit"));

    return hrAll;    
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::ApproveSubscription
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCWatcher::ApproveSubscription(
        DWORD dwPresenceInfoRules)
{
    HRESULT         hrAll = S_OK;

    LOG((RTC_TRACE, "CRTCWatcher::ApproveSubscription - enter"));

    ISIPWatcher     ** pCrt;
    ISIPWatcher     ** pEnd;

    m_bIsNested = TRUE;

    for(pCrt = &m_SIPWatchers[0], pEnd = pCrt + m_SIPWatchers.GetSize();
        pCrt < pEnd;
        pCrt ++)
    {
        HRESULT     hr;

        hr = (*pCrt)->ApproveSubscription(dwPresenceInfoRules);
    
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCWatcher::ApproveSubscription - "
                            "ApproveSubscription failed 0x%lx", hr));

            if(hrAll==S_OK)
            {
                hrAll = hr;
            }
        }
    }

    m_bIsNested = FALSE;

    PostSIPWatchersCleanUp();
    
    LOG((RTC_TRACE, "CRTCWatcher::ApproveSubscription - exit"));

    return hrAll;    
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::RejectSubscription
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCWatcher::RejectSubscription(
    WATCHER_REJECT_REASON ulReason
    )
{
    HRESULT         hrAll = S_OK;

    LOG((RTC_TRACE, "CRTCWatcher::RejectSubscription - enter"));

    ISIPWatcher      ** pCrt;
    ISIPWatcher      ** pEnd;

    m_bIsNested = TRUE;

    for(pCrt = &m_SIPWatchers[0], pEnd = pCrt + m_SIPWatchers.GetSize();
        pCrt < pEnd;
        pCrt ++)
    {
        HRESULT     hr;

        hr = (*pCrt)->RejectSubscription(ulReason);
    
        if(FAILED(hr))
        {
            LOG((RTC_ERROR, "CRTCWatcher::RejectSubscription - "
                            "RejectSubscription failed 0x%lx", hr));

            if(hrAll==S_OK)
            {
                hrAll = hr;
            }
        }
    }

    m_bIsNested = FALSE;

    PostSIPWatchersCleanUp();
    
    LOG((RTC_TRACE, "CRTCWatcher::RejectSubscription - exit"));

    return hrAll;    
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::PostSIPWatchersCleanUp
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCWatcher::PostSIPWatchersCleanUp(void)
{
    ISIPWatcher ** pCrt;
    ISIPWatcher ** pEnd;

    for(pCrt = &m_SIPWatchers[0], pEnd = pCrt + m_SIPWatchers.GetSize();
        pCrt < pEnd;
        )
    {
        if((*pCrt)==NULL)
        {
            m_SIPWatchers.RemoveAt((int)(pCrt - &m_SIPWatchers[0]));
            pEnd -- ;
        }
        else
        {
            pCrt++;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::GetSIPWatcherShutdownBlob
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCWatcher::GetSIPWatcherShutdownBlob()
{
    LOG((RTC_TRACE, "CRTCWatcher::GetSIPWatcherShutdownBlob - enter"));

    ISIPWatcher      ** pCrt;
    ISIPWatcher      ** pEnd;
    HRESULT             hr;
    DWORD               dwLength;
    PSTR                szShutdown = NULL;
    PWSTR               wszShutdown = NULL;    

    if ( m_szShutdownBlob != NULL )
    {
        LOG((RTC_INFO, "CRTCWatcher::GetSIPWatcherShutdownBlob - "
                            "already have a shutdown blob"));

        return S_OK;
    }

    szShutdown = (PSTR)RtcAlloc(2000); // maximum size for the shutdown data

    if ( szShutdown == NULL )
    {
        LOG((RTC_ERROR, "CRTCWatcher::GetSIPWatcherShutdownBlob - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    for(pCrt = &m_SIPWatchers[0], pEnd = pCrt + m_SIPWatchers.GetSize();
        pCrt < pEnd;
        pCrt ++)
    {
        dwLength = 2000;        

        hr = (*pCrt)->GetWatcherShutdownData(szShutdown, &dwLength);
    
        if ( SUCCEEDED(hr) )
        {
            LOG((RTC_INFO, "CRTCWatcher::GetSIPWatcherShutdownBlob - "
                            "got a shutdown data blob"));

            DWORD dwWideLength;
            
            dwWideLength = MultiByteToWideChar( CP_ACP, 0, szShutdown, dwLength, NULL, 0 );

            if ( dwWideLength == 0 )
            {
                hr = HRESULT_FROM_WIN32(GetLastError());

                LOG((RTC_ERROR, "CRTCWatcher::GetSIPWatcherShutdownBlob - "
                            "MultiByteToWideChar failed 0xlx", hr));

                RtcFree( szShutdown );

                return hr;
            }

            wszShutdown = (PWSTR)RtcAlloc( (dwWideLength + 1) * sizeof(WCHAR) );

            if ( wszShutdown == NULL )
            {
                LOG((RTC_ERROR, "CRTCWatcher::GetSIPWatcherShutdownBlob - "
                            "out of memory"));

                RtcFree( szShutdown );

                return E_OUTOFMEMORY;
            }

            ZeroMemory( wszShutdown, (dwWideLength + 1) * sizeof(WCHAR) );

            if ( MultiByteToWideChar( CP_ACP, 0, szShutdown, dwLength, wszShutdown, dwWideLength ) == 0 )
            {
                hr = HRESULT_FROM_WIN32(GetLastError());

                LOG((RTC_ERROR, "CRTCWatcher::GetSIPWatcherShutdownBlob - "
                            "MultiByteToWideChar failed 0xlx", hr));

                RtcFree( szShutdown );
                RtcFree( wszShutdown );

                return hr;
            }

            break;
        }
    }

    RtcFree( szShutdown );

    m_szShutdownBlob = wszShutdown;

    LOG((RTC_TRACE, "CRTCWatcher::GetSIPWatcherShutdownBlob - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::SendSIPWatcherShutdownBlob
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCWatcher::SendSIPWatcherShutdownBlob()
{
    LOG((RTC_TRACE, "CRTCWatcher::SendSIPWatcherShutdownBlob - enter"));

    HRESULT hr;
    PSTR    szShutdown = NULL;
    DWORD   dwLength;

    if ( m_szShutdownBlob == NULL )
    {
        LOG((RTC_INFO, "CRTCWatcher::GetSIPWatcherShutdownBlob - "
                            "no shutdown blob"));

        return S_OK;
    }

    dwLength = WideCharToMultiByte( CP_ACP, 0, m_szShutdownBlob, -1, NULL, 0, NULL, NULL);

    if ( dwLength == 0 )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        LOG((RTC_ERROR, "CRTCWatcher::SendSIPWatcherShutdownBlob - "
                    "WideCharToMultiByte failed 0xlx", hr));

        return hr;
    }

    szShutdown = (PSTR)RtcAlloc( dwLength + 1 );

    if ( szShutdown == NULL )
    {
        LOG((RTC_ERROR, "CRTCWatcher::SendSIPWatcherShutdownBlob - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    ZeroMemory( szShutdown, dwLength + 1 );

    if ( WideCharToMultiByte( CP_ACP, 0, m_szShutdownBlob, -1, szShutdown, dwLength, NULL, NULL) == 0 )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        LOG((RTC_ERROR, "CRTCWatcher::SendSIPWatcherShutdownBlob - "
                    "WideCharToMultiByte failed 0xlx", hr));

        RtcFree( szShutdown );

        return hr;
    }

    IRTCProfile * pProfile = NULL;
    RTC_SESSION_TYPE enType = RTCST_PC_TO_PC;

    hr = m_pCClient->GetBestProfile(
            &enType,
            m_szPresentityURI,
            FALSE,
            &pProfile
            );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::SendSIPWatcherShutdownBlob - "
                            "GetBestProfile failed 0x%lx", hr));

        RtcFree( szShutdown );

        return hr;
    }

    if ( pProfile == NULL )
    {
        LOG((RTC_ERROR, "CRTCSession::SendSIPWatcherShutdownBlob - "
                            "no profile found"));

        RtcFree( szShutdown );

        return hr;
    }

    SIP_SERVER_INFO Proxy;            
    CRTCProfile * pCProfile = NULL;

    pCProfile = static_cast<CRTCProfile *>(pProfile);  

    hr = pCProfile->GetSipProxyServerInfo( RTCSI_PC_TO_PC, &Proxy );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCSession::SendSIPWatcherShutdownBlob - "
                            "GetSipProxyServerInfo failed 0x%lx", hr));

        pProfile->Release();
        RtcFree( szShutdown );

        return hr;
    }

    hr = m_pSIPWatcherManager->SendUnsubToWatcher( szShutdown, dwLength, &Proxy );

    pCProfile->FreeSipServerInfo( &Proxy );
    pProfile->Release();

    RtcFree( szShutdown );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWatcher::SendSIPWatcherShutdownBlob - "
                    "SendUnsubToWatcher failed 0xlx", hr));

        return hr;
    }

    RtcFree( m_szShutdownBlob );
    m_szShutdownBlob = NULL;

    LOG((RTC_TRACE, "CRTCWatcher::SendSIPWatcherShutdownBlob - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::CreateXMLDOMNode
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCWatcher::CreateXMLDOMNode( IXMLDOMDocument * pXMLDoc, IXMLDOMNode ** ppXDN )
{
    IXMLDOMNode    * pWatcherInfo = NULL;
    IXMLDOMElement * pElement = NULL;
    HRESULT hr;

    LOG((RTC_TRACE, "CRTCWatcher::CreateXMLDOMNode - enter"));

    hr = pXMLDoc->createNode( CComVariant(NODE_ELEMENT), CComBSTR(_T("WatcherInfo")), NULL, &pWatcherInfo );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWatcher::CreateXMLDOMNode - "
                        "createNode failed 0x%lx", hr));

        return hr;
    }
    
    hr = pWatcherInfo->QueryInterface( IID_IXMLDOMElement, (void**)&pElement );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWatcher::CreateXMLDOMNode - "
                        "QueryInterface failed 0x%lx", hr));

        pWatcherInfo->Release();

        return hr;
    }

    if (m_szPresentityURI != NULL)
    {
        hr = pElement->setAttribute( CComBSTR(_T("Presentity")), CComVariant( m_szPresentityURI ) );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCWatcher::CreateXMLDOMNode - "
                        "setAttribute(Presentity) failed 0x%lx", hr));

            pElement->Release();
            pWatcherInfo->Release();

            return hr;
        }
    }

    if (m_szName != NULL)
    {
        hr = pElement->setAttribute( CComBSTR(_T("Name")), CComVariant( m_szName ) );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCWatcher::CreateXMLDOMNode - "
                        "setAttribute(Name) failed 0x%lx", hr));

            pElement->Release();
            pWatcherInfo->Release();

            return hr;
        }
    }

    if (m_szData != NULL)
    {
        hr = pElement->setAttribute( CComBSTR(_T("Data")), CComVariant( m_szData ) );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCWatcher::CreateXMLDOMNode - "
                        "setAttribute(Data) failed 0x%lx", hr));

            pElement->Release();
            pWatcherInfo->Release();

            return hr;
        }
    }

    if (m_szShutdownBlob != NULL)
    {
        hr = pElement->setAttribute( CComBSTR(_T("ShutdownBlob")), CComVariant( m_szShutdownBlob ) );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCWatcher::CreateXMLDOMNode - "
                        "setAttribute(ShutdownBlob) failed 0x%lx", hr));

            pElement->Release();
            pWatcherInfo->Release();

            return hr;
        }
    }

    pElement->Release();

    *ppXDN = pWatcherInfo;

    LOG((RTC_TRACE, "CRTCWatcher::CreateXMLDOMNode - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::GetClient
//
/////////////////////////////////////////////////////////////////////////////

CRTCClient * 
CRTCWatcher::GetClient()
{
    LOG((RTC_TRACE, "CRTCWatcher::GetClient"));

    return m_pCClient;
} 


/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::get_PresentityURI
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCWatcher::get_PresentityURI(
        BSTR * pbstrPresentityURI
        )
{
    LOG((RTC_TRACE, "CRTCWatcher::get_PresentityURI - enter"));

    if ( IsBadWritePtr( pbstrPresentityURI, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCWatcher::get_PresentityURI - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szPresentityURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCWatcher::get_PresentityURI - "
                            "watcher has no address"));

        return E_FAIL;
    }

    //
    // Allocate the BSTR to be returned
    //
    
    *pbstrPresentityURI = SysAllocString(m_szPresentityURI);

    if ( *pbstrPresentityURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCWatcher::get_PresentityURI - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }    
    
    LOG((RTC_TRACE, "CRTCWatcher::get_PresentityURI - exit S_OK"));

    return S_OK;
}    

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::put_PresentityURI
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCWatcher::put_PresentityURI(
        BSTR bstrPresentityURI
        )
{
    LOG((RTC_TRACE, "CRTCWatcher::put_PresentityURI - enter"));

    HRESULT hr;

    if ( IsBadStringPtrW( bstrPresentityURI, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCWatcher::put_PresentityURI - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    //
    // Clean the presentity URI
    //

    PWSTR szCleanPresentityURI = NULL;

    AllocCleanSipString( bstrPresentityURI, &szCleanPresentityURI );

    if ( szCleanPresentityURI == NULL )
    {
        LOG((RTC_ERROR, "CRTCWatcher::put_PresentityURI - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    //
    // Is this different than the existing presentity URI?
    //

    if ( !IsEqualURI( m_szPresentityURI, bstrPresentityURI ) )
    {
        //
        // Don't allow duplicates
        //

        IRTCWatcher *pWatcher = NULL;

        hr = m_pCClient->FindWatcherByURI(
            szCleanPresentityURI,
            FALSE,
            &pWatcher);

        if (hr == S_OK)
        {
            RtcFree( szCleanPresentityURI );
            szCleanPresentityURI = NULL;
        
            LOG((RTC_ERROR, "CRTCWatcher::put_PresentityURI - "
                                    "duplicate watcher"));

            return E_FAIL;
        }

        // 
        // If there's a hidden watcher, we free it.
        //
        // It is not worth reusing it. 
        //
        
        hr = m_pCClient->FindWatcherByURI(
            szCleanPresentityURI,
            TRUE,
            &pWatcher);

        if(hr == S_OK)
        {
            CRTCWatcher * pCWatcher = static_cast<CRTCWatcher *>(pWatcher);

            pCWatcher->RemoveSIPWatchers(FALSE);

            m_pCClient->RemoveHiddenWatcher(pWatcher);

            pWatcher->Release();
            pWatcher = NULL;
        }

        //
        // Release the SIP watchers
        //

        PWSTR szOldPresentityURI = m_szPresentityURI;
      
        m_szPresentityURI = szCleanPresentityURI;
        szCleanPresentityURI = NULL;
        
        hr = RemoveSIPWatchers(FALSE);

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCWatcher::put_PresentityURI - RemoveSIPWatchers failed 0x%lx", hr));

            RtcFree(m_szPresentityURI);
            m_szPresentityURI = szOldPresentityURI;

            return hr;
        }

        if ( szOldPresentityURI != NULL )
        {
            RtcFree( szOldPresentityURI );
            szOldPresentityURI = NULL;
        }

        //
        // Update storage
        //

        if ( m_bPersistent )
        {
            m_pCClient->UpdatePresenceStorage();
        }

#ifdef DUMP_PRESENCE
        m_pCClient->DumpWatchers("PUT_PRESENTITYURI");
#endif

    }
    else
    {
        RtcFree( szCleanPresentityURI );
        szCleanPresentityURI = NULL;
    }
        
    LOG((RTC_TRACE, "CRTCWatcher::put_PresentityURI - exit S_OK"));

    return S_OK;
}            

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::get_Name
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCWatcher::get_Name(
        BSTR * pbstrName
        )
{
    LOG((RTC_TRACE, "CRTCWatcher::get_Name - enter"));

    if ( IsBadWritePtr( pbstrName, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCWatcher::get_Name - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szName == NULL )
    {
        LOG((RTC_ERROR, "CRTCWatcher::get_Name - "
                            "watcher has no name"));

        return E_FAIL;
    }

    //
    // Allocate the BSTR to be returned
    //
    
    *pbstrName = SysAllocString(m_szName);

    if ( *pbstrName == NULL )
    {
        LOG((RTC_ERROR, "CRTCWatcher::get_Name - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }    
    
    LOG((RTC_TRACE, "CRTCWatcher::get_Name - exit S_OK"));

    return S_OK;
}    

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::put_Name
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCWatcher::put_Name(
        BSTR bstrName
        )
{
    LOG((RTC_TRACE, "CRTCWatcher::put_Name - enter"));

    if ( IsBadStringPtrW( bstrName, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCWatcher::put_Name - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szName != NULL )
    {
        RtcFree( m_szName );
        m_szName = NULL;
    }

    m_szName = RtcAllocString( bstrName );    

    if ( m_szName == NULL )
    {
        LOG((RTC_ERROR, "CRTCWatcher::put_Name - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }    

    //
    // Update storage
    //

    if ( m_bPersistent )
    {
        m_pCClient->UpdatePresenceStorage();
    }
    
    LOG((RTC_TRACE, "CRTCWatcher::put_Name - exit S_OK"));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::get_Data
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCWatcher::get_Data(
        BSTR * pbstrData
        )
{
    LOG((RTC_TRACE, "CRTCWatcher::get_Data - enter"));

    if ( IsBadWritePtr( pbstrData, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCWatcher::get_Data - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szData == NULL )
    {
        LOG((RTC_ERROR, "CRTCWatcher::get_Data - "
                            "watcher has no guid string"));

        return E_FAIL;
    }

    //
    // Allocate the BSTR to be returned
    //
    
    *pbstrData = SysAllocString(m_szData);

    if ( *pbstrData == NULL )
    {
        LOG((RTC_ERROR, "CRTCWatcher::get_Data - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }    
    
    LOG((RTC_TRACE, "CRTCWatcher::get_Data - exit S_OK"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::put_Data
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCWatcher::put_Data(
        BSTR bstrData
        )
{
    LOG((RTC_TRACE, "CRTCWatcher::put_Data - enter"));

    if ( IsBadStringPtrW( bstrData, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCWatcher::put_Data - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    if ( m_szData != NULL )
    {
        RtcFree( m_szData );
        m_szData = NULL;
    }

    m_szData = RtcAllocString( bstrData );    

    if ( m_szData == NULL )
    {
        LOG((RTC_ERROR, "CRTCWatcher::put_Data - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }  
    
    //
    // Update storage
    //

    if ( m_bPersistent )
    {
        m_pCClient->UpdatePresenceStorage();
    }
    
    LOG((RTC_TRACE, "CRTCWatcher::put_Data - exit S_OK"));

    return S_OK;
}      
    
/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::get_Persistent
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCWatcher::get_Persistent(
            VARIANT_BOOL * pfPersistent
            )
{
    LOG((RTC_TRACE, "CRTCWatcher::get_Persistent - enter"));

    if ( IsBadWritePtr( pfPersistent, sizeof(VARIANT_BOOL) ) )
    {
        LOG((RTC_ERROR, "CRTCWatcher::pfPersistent - "
                            "bad pointer"));

        return E_POINTER;
    }

    *pfPersistent = m_bPersistent ? VARIANT_TRUE : VARIANT_FALSE;

    LOG((RTC_TRACE, "CRTCWatcher::get_Persistent - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::put_Persistent
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCWatcher::put_Persistent(
            VARIANT_BOOL fPersistent
            )
{
    LOG((RTC_TRACE, "CRTCWatcher::put_Persistent - enter"));

    m_bPersistent = fPersistent ? TRUE : FALSE;

    //
    // Update storage
    //

    m_pCClient->UpdatePresenceStorage();

#ifdef DUMP_PRESENCE
    m_pCClient->DumpWatchers("PUT_PERSISTENT");
#endif

    LOG((RTC_TRACE, "CRTCWatcher::put_Persistent - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::get_State
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCWatcher::get_State(
            RTC_WATCHER_STATE * penState
            )
{
    LOG((RTC_TRACE, "CRTCWatcher::get_State - enter"));

    if ( IsBadWritePtr( penState, sizeof(RTC_WATCHER_STATE) ) )
    {
        LOG((RTC_ERROR, "CRTCWatcher::get_State - "
                            "bad pointer"));

        return E_POINTER;
    }

    *penState = m_nState;

    LOG((RTC_TRACE, "CRTCWatcher::get_State - exit"));

    return S_OK;
}
    
/////////////////////////////////////////////////////////////////////////////
//
// CRTCWatcher::put_State
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCWatcher::put_State(
            RTC_WATCHER_STATE  enState
            )
{
    HRESULT         hr;

    LOG((RTC_TRACE, "CRTCWatcher::put_State - enter"));

    if(enState != RTCWS_ALLOWED && 
       enState != RTCWS_BLOCKED)
    {
        LOG((RTC_ERROR, "CRTCWatcher::put_State - invalid state"));

        return E_INVALIDARG;
    }

    if(m_nState == RTCWS_OFFERING)
    {
        // Offering state ? Ok, depending on the new state
        // we approve or reject the subscription 
        //

        if(enState == RTCWS_ALLOWED)
        {
            hr = ApproveSubscription(0);

            if(FAILED(hr))
            {
                LOG((RTC_ERROR, "CRTCWatcher::put_State: "
                    "ApproveSubscription failed: x%x.", hr));
            }
        }
        else
        {
            hr = RejectSubscription(REJECT_REASON_NONE);
            
            if(FAILED(hr))
            {
                LOG((RTC_ERROR, "CRTCWatcher::put_State: "
                    "RejectSubscription failed: x%x.", hr));
            }
        }
    }
    else
    {
        if((enState == RTCWS_ALLOWED && m_nState != RTCWS_ALLOWED) ||
            (enState == RTCWS_BLOCKED && m_nState != RTCWS_BLOCKED))
        {
            hr = ChangeBlockedStatus(
                enState == RTCWS_ALLOWED ? WATCHER_UNBLOCKED : WATCHER_BLOCKED
                );

            if(FAILED(hr))
            {
                LOG((RTC_ERROR, "CRTCWatcher::put_State: "
                    "ChangeBlockedStatus failed: x%x.", hr));
            }
        }
    }


    //
    // Change the local state
    //

    m_nState = enState;

    //
    // Update storage
    //

    if ( m_bPersistent )
    {
        m_pCClient->UpdatePresenceStorage();
    }

#ifdef DUMP_PRESENCE
    m_pCClient->DumpWatchers("PUT_STATE");
#endif

    LOG((RTC_TRACE, "CRTCWatcher::put_State - exit"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\rtcsession.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCSession.h

Abstract:

    Definition of the CRTCSession class

--*/

#ifndef __RTCSESSION__
#define __RTCSESSION__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CRTCSession

class ATL_NO_VTABLE CRTCSession : 
#ifdef TEST_IDISPATCH
    public IDispatchImpl<IRTCSession, &IID_IRTCSession, &LIBID_RTCCORELib>, 
#else
    public IRTCSession,
#endif
    public IRTCSessionPortManagement,
    public ISipCallNotify,
	public CComObjectRoot
{
public:
    CRTCSession() : m_pCClient(NULL),
                    m_pCall(NULL),
                    m_pStack(NULL),
                    m_pIMManager(NULL),
                    m_pIMSession(NULL),
                    m_enState(RTCSS_IDLE),
                    m_szLocalName(NULL),
                    m_szLocalUserURI(NULL),
                    m_szLocalPhoneURI(NULL),
                    m_szRemoteUserName(NULL),
                    m_szRemoteUserURI(NULL),
                    m_szRedirectProxy(NULL),
                    m_pProfile(NULL),
                    m_pSipRedirectContext(NULL),
                    m_lFlags(0)
    {}
BEGIN_COM_MAP(CRTCSession)
#ifdef TEST_IDISPATCH
    COM_INTERFACE_ENTRY(IDispatch)
#endif
    COM_INTERFACE_ENTRY(IRTCSession)
    COM_INTERFACE_ENTRY(IRTCSessionPortManagement)
    COM_INTERFACE_ENTRY(ISipCallNotify)
END_COM_MAP()

    HRESULT FinalConstruct();

    void FinalRelease();

    STDMETHOD_(ULONG, InternalAddRef)();

    STDMETHOD_(ULONG, InternalRelease)(); 
    
    CRTCClient * GetClient();

    HRESULT InitializeOutgoing(
            CRTCClient        * pCClient,
            IRTCProfile       * pProfile,
            ISipStack         * pStack,
            RTC_SESSION_TYPE    enType,
            PCWSTR              szLocalName,
            PCWSTR              szLocalUserURI,
            PCWSTR              szLocalPhoneURI,
            long                lFlags
            );

    HRESULT InitializeIncoming(
            CRTCClient        * pCClient,
            ISipCall          * pCall,
            SIP_PARTY_INFO    * pCallerInfo
            );

    HRESULT InitializeIncomingIM(
            CRTCClient        * pCClient,
            ISipStack         * pStack,
            IIMSession        * pSession,
            BSTR                msg,
            BSTR                ContentType,
            SIP_PARTY_INFO    * pCallerInfo
            );

    HRESULT SetState(
            RTC_SESSION_STATE enState,
            long lStatusCode,
            PCWSTR szStatusText
            );

private:

    CRTCClient                        * m_pCClient;
    ISipCall                          * m_pCall; 
    ISipStack                         * m_pStack;
    IIMManager                        * m_pIMManager;
    IIMSession                        * m_pIMSession;
    IRTCProfile                       * m_pProfile;
    RTC_SESSION_STATE                   m_enState;
    RTC_SESSION_TYPE                    m_enType;
    PWSTR                               m_szLocalName;
    PWSTR                               m_szLocalUserURI;
    PWSTR                               m_szLocalPhoneURI;
    PWSTR                               m_szRemoteUserName;
    PWSTR                               m_szRemoteUserURI;
    PWSTR                               m_szRedirectProxy;
    ISipRedirectContext               * m_pSipRedirectContext;
    long                                m_lFlags;
    
    CRTCObjectArray<IRTCParticipant *>  m_ParticipantArray;

#if DBG
    PWSTR                               m_pDebug;
#endif

    HRESULT InternalCreateParticipant(
        IRTCParticipant ** ppParticipant
        );

    HRESULT CreateSipSession(
            PCWSTR              szDestUserURI
            );

    HRESULT InitializeLocalPhoneParticipant();
    
// IRTCSession
public:
    STDMETHOD(get_Client)(
            IRTCClient ** ppClient
            );
                        
    STDMETHOD(Answer)(); 

    STDMETHOD(Terminate)(
            RTC_TERMINATE_REASON enReason
            );  

    STDMETHOD(Redirect)(
            RTC_SESSION_TYPE enType,
            BSTR bstrLocalPhoneURI,
            IRTCProfile * pProfile,
            long     lFlags
            );  

    STDMETHOD(get_State)(
            RTC_SESSION_STATE * penState
            ); 
    
    STDMETHOD(get_Type)(
            RTC_SESSION_TYPE * penType
            );

    STDMETHOD(get_Profile)(
            IRTCProfile ** ppProfile
            );

    STDMETHOD(AddParticipant)(
            BSTR bstrUserURI,
            BSTR bstrName,
            IRTCParticipant ** ppParticipant
            );  

    STDMETHOD(RemoveParticipant)(
            IRTCParticipant * pParticipant
            );      

    STDMETHOD(EnumerateParticipants)(
            IRTCEnumParticipants ** ppEnum
            ); 

    STDMETHOD(get_Participants)(
            IRTCCollection ** ppCollection
            );

    STDMETHOD(get_CanAddParticipants)(
            VARIANT_BOOL * pfCanAdd
            );  
    
    STDMETHOD(get_RedirectedUserURI)(
                           BSTR * pbstrUserURI
                          );

    STDMETHOD(get_RedirectedUserName)(
                           BSTR * pbstrUserName
                          );

    STDMETHOD(NextRedirectedUser)();
    
    STDMETHOD(SendMessage)(
            BSTR bstrMessageHeader,
            BSTR bstrMessage,
            long lCookie
            );

    STDMETHOD(SendMessageStatus)(
            RTC_MESSAGING_USER_STATUS enUserStatus,
            long lCookie
            );

    STDMETHOD(AddStream)(
            long lMediaType,
            long lCookie
            );

    STDMETHOD(RemoveStream)(
            long lMediaType,
            long lCookie
            );

    STDMETHOD(put_EncryptionKey)(
            long lMediaType,
            BSTR EncryptionKey
            );

// ISipCallNotify
    STDMETHOD(NotifyCallChange)(
            SIP_CALL_STATUS * CallStatus
            );

    STDMETHOD(NotifyStartOrStopStreamCompletion)(
            long                   lCookie,
            SIP_STATUS_BLOB       *pStatus
            );
    
    STDMETHOD(NotifyPartyChange)(
            SIP_PARTY_INFO * PartyInfo
            );

    STDMETHOD(NotifyRedirect)(
            ISipRedirectContext *pSipRedirectContext,
            SIP_CALL_STATUS * pCallStatus
            );

    STDMETHOD(NotifyMessageRedirect)(
            ISipRedirectContext    *pRedirectContext,
            SIP_CALL_STATUS        *pCallStatus,
            BSTR                   bstrMsg,
            BSTR                   bstrContentType,
            USR_STATUS             UsrStatus,
            long                   lCookie
            );

    STDMETHOD(NotifyIncomingMessage)(
		    IIMSession *pSession,
		    BSTR msg,
            BSTR ContentType,
		    SIP_PARTY_INFO * CallerInfo
		    );

    STDMETHOD(NotifyUsrStatus)(
            USR_STATUS  UsrStatus,
            SIP_PARTY_INFO * CallerInfo
            );

    STDMETHOD(NotifyMessageCompletion)(
            SIP_STATUS_BLOB *      pStatus,
            long                   lCookie
            );

// IRTCSessionPortManagement
    STDMETHOD(SetPortManager)(
            IRTCPortManager * pPortManager
            );
};

#endif //__RTCSESSION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\rtcwaves.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCWaves.cpp

Abstract:

    Implementation of the CWavePlayer class

--*/

#include "stdafx.h"

BOOL DSParseWaveResource(void *pvRes, WAVEFORMATEX **ppWaveHeader, BYTE ** ppbWaveData, DWORD *pdwWaveSize);
static const TCHAR c_szWAV[] = _T("WAVE");

BOOL   CWavePlayer::m_fInitialized = FALSE;
LPBYTE CWavePlayer::m_lpWaveform[ NUM_WAVES ];
DWORD  CWavePlayer::m_dwWaveformSize[ NUM_WAVES ];

///////////////////////////////////////////////////////////////////////////////
//
// DSGetWaveResource
//
///////////////////////////////////////////////////////////////////////////////

BOOL DSGetWaveResource(HMODULE hModule, LPCTSTR lpName,
    WAVEFORMATEX **ppWaveHeader, BYTE **ppbWaveData, DWORD *pcbWaveSize)
{
    HRSRC hResInfo;
    HGLOBAL hResData;
    void *pvRes;

    if (((hResInfo = FindResource(hModule, lpName, c_szWAV)) != NULL) &&
        ((hResData = LoadResource(hModule, hResInfo)) != NULL) &&
        ((pvRes = LockResource(hResData)) != NULL) &&
        DSParseWaveResource(pvRes, ppWaveHeader, ppbWaveData, pcbWaveSize))
    {
         return TRUE;
    }
   
    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

BOOL DSParseWaveResource(void *pvRes, WAVEFORMATEX **ppWaveHeader, BYTE **
ppbWaveData,DWORD *pcbWaveSize)
{   
    DWORD *pdw;
    DWORD *pdwEnd;
    DWORD dwRiff;
    DWORD dwType;
    DWORD dwLength;

    if (ppWaveHeader)
    {
        *ppWaveHeader = NULL;
    }

    if (ppbWaveData)
    {
        *ppbWaveData = NULL;
    }

    if (pcbWaveSize)
    {
        *pcbWaveSize = 0;
    }

    pdw = (DWORD *)pvRes;
    dwRiff = *pdw++;
    dwLength = *pdw++;
    dwType = *pdw++;

    if (dwRiff != mmioFOURCC('R', 'I', 'F', 'F'))
        goto exit;      // not even RIFF

    if (dwType != mmioFOURCC('W', 'A', 'V', 'E'))
        goto exit;      // not a WAV

    pdwEnd = (DWORD *)((BYTE *)pdw + dwLength-4);

    while (pdw < pdwEnd)
    {
        dwType = *pdw++;
        dwLength = *pdw++;

        switch (dwType)
        {
        case mmioFOURCC('f', 'm', 't', ' '):
            if (ppWaveHeader && !*ppWaveHeader)
            {
                if (dwLength < sizeof(WAVEFORMAT))
                {
                    goto exit;      // not a WAV
                }

                *ppWaveHeader = (WAVEFORMATEX *)pdw;

                if ((!ppbWaveData || *ppbWaveData) &&
                    (!pcbWaveSize || *pcbWaveSize))
                {                 
                    return TRUE;
                }
            }
            break;

        case mmioFOURCC('d', 'a', 't', 'a'):
            if ((ppbWaveData && !*ppbWaveData) ||
                (pcbWaveSize && !*pcbWaveSize))
            {
                if (ppbWaveData)
                {
                    *ppbWaveData = (LPBYTE)pdw;
                }

                if (pcbWaveSize)
                {
                    *pcbWaveSize = dwLength;
                }

                if (!ppWaveHeader || *ppWaveHeader)
                {     
                    return TRUE;
                }
            }
            break;
        }

        pdw = (DWORD *)((BYTE *)pdw + ((dwLength+1)&~1));
    }

exit:
    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
//

CWavePlayer::CWavePlayer()
{
    m_hWaveOut = NULL;
}

//////////////////////////////////////////////////////////////////////////////
//

CWavePlayer::~CWavePlayer()
{
    //
    // We should have closed the wave device by now.
    //

    _ASSERTE( m_hWaveOut == NULL );
}

//////////////////////////////////////////////////////////////////////////////
//

HRESULT CWavePlayer::Initialize(void)
{
    LOG((RTC_TRACE, "CWavePlayer::Initialize - enter"));
    
    int i;

    //
    // It's wasteful to initialize twice, but it won't break anything.
    //

    _ASSERTE( m_fInitialized == FALSE );

    //
    // Read all wave data resources.
    // We ignore the size and the wave header -- since these are our own
    // resources, we do not expect any surprises.
    //

    BOOL fResult;

    //
    // For each wave
    //

    for ( i = 0; i < NUM_WAVES; i ++ )
    {
        //
        // Read the wave resource for this tone.
        //

       fResult = DSGetWaveResource(
            _Module.GetResourceInstance(),   // HMODULE hModule,
            (LPCTSTR)UlongToPtr(IDR_WAV_TONE + i),    // LPCTSTR lpName,
            NULL,                            // WAVEFORMATEX **ppWaveHeader,
            &m_lpWaveform[i],                // BYTE **ppbWaveData,
            &m_dwWaveformSize[i]             // DWORD *pcbWaveSize
            );

        if ( fResult == FALSE )
        { 
            LOG((RTC_ERROR, "CWavePlayer::Initialize - DSGetWaveResource failed"));
            
            return E_FAIL;
        }
    }

    //
    // We can now go ahead with the other methods.
    //

    m_fInitialized = TRUE;

    LOG((RTC_TRACE, "CWavePlayer::Initialize - exit S_OK"));

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//

HRESULT CWavePlayer::PlayWave(WAVE enWave)
{
    LOG((RTC_TRACE, "CWavePlayer::PlayWave - enter"));
    
    MMRESULT mmresult;

    if ( m_fInitialized == FALSE )
    {
        _ASSERTE( FALSE );
        return E_UNEXPECTED;
    }

    if ( m_hWaveOut == NULL )
    {
        _ASSERTE( FALSE );
        return E_FAIL;
    }
     
    //
    // Reset the wave device to flush out any pending buffers.
    //

    mmresult = waveOutReset( m_hWaveOut );

    if ( mmresult != MMSYSERR_NOERROR )
    {
        LOG((RTC_ERROR, "CWavePlayer::PlayWave - "
                            "waveOutReset failed 0x%lx", mmresult));
        
        return E_FAIL;
    }

    //
    // Construct a wave header structure that will indicate what to play
    // in waveOutWrite.
    //
 
    ZeroMemory( & m_WaveHeader, sizeof( m_WaveHeader ) );

    m_WaveHeader.lpData          = (LPSTR)m_lpWaveform[(long)enWave];
    m_WaveHeader.dwBufferLength  = m_dwWaveformSize[(long)enWave];
    m_WaveHeader.dwFlags         = 0;
    m_WaveHeader.dwLoops         = (DWORD) 0;

    //
    // Submit the data to the wave device. The wave header indicated that
    // we want to loop. Need to prepare the header first, but it can
    // only be prepared after the device has been opened.
    //

    mmresult = waveOutPrepareHeader(m_hWaveOut,
                                    & m_WaveHeader,
                                    sizeof(WAVEHDR)
                                    );

    if ( mmresult != MMSYSERR_NOERROR )
    {
        return E_FAIL;
    }

    mmresult = waveOutWrite(m_hWaveOut,
                            & m_WaveHeader,
                            sizeof(WAVEHDR)
                            );

    if ( mmresult != MMSYSERR_NOERROR )
    {
        LOG((RTC_ERROR, "CWavePlayer::PlayWave - "
                            "waveOutWrite failed 0x%lx", mmresult));
        
        return E_FAIL;
    }

    LOG((RTC_TRACE, "CWavePlayer::PlayWave - exit S_OK"));
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//

HRESULT CWavePlayer::StopWave()
{
    LOG((RTC_TRACE, "CWavePlayer::StopWave - enter"));

    MMRESULT mmresult;

    if ( m_fInitialized == FALSE )
    {
        _ASSERTE( FALSE );
        return E_UNEXPECTED;
    }

    if ( m_hWaveOut == NULL )
    {
        _ASSERTE( FALSE );
        return E_FAIL;
    } 

    //
    // Reset the wave device.
    //

    mmresult = waveOutReset( m_hWaveOut );

    if ( mmresult != MMSYSERR_NOERROR )
    {
        LOG((RTC_ERROR, "CWavePlayer::StopWave - "
                            "waveOutReset failed 0x%lx", mmresult));
                            
        return E_FAIL;
    }  

    LOG((RTC_TRACE, "CWavePlayer::StopWave - exit S_OK"));

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//

HRESULT CWavePlayer::OpenWaveDevice(
    long lWaveID
    )
{
    LOG((RTC_TRACE, "CWavePlayer::OpenWaveDevice - enter"));
    
    MMRESULT mmresult; 

    if ( m_fInitialized == FALSE )
    {
        _ASSERTE( FALSE );
        return E_UNEXPECTED;
    }

    //
    // We expect that the wave device will not be opened twice. This is
    // dependent on the calling code.
    //

    _ASSERTE( m_hWaveOut == NULL );

    //
    // Open the wave device. Here we specify a hard-coded audio format.
    //

    WAVEFORMATEX waveFormat;

    waveFormat.wFormatTag      = WAVE_FORMAT_PCM; // linear PCM
    waveFormat.nChannels       = 1;               // mono
    waveFormat.nSamplesPerSec  = 8000;            // 8 KHz
    waveFormat.wBitsPerSample  = 16;              // 16-bit samples
    waveFormat.nBlockAlign     = waveFormat.nChannels * waveFormat.wBitsPerSample / 8;
    waveFormat.nAvgBytesPerSec = waveFormat.nSamplesPerSec *  waveFormat.nBlockAlign;
    waveFormat.cbSize          = 0;               // no extra format info

    mmresult = waveOutOpen(& m_hWaveOut,        // returned handle
                           lWaveID,             // which device to use
                           &waveFormat,         // wave format to use
                           0,                   // callback function pointer
                           0,                   // callback instance data
                           WAVE_FORMAT_DIRECT   // we don't want ACM
                           );

    if ( mmresult != MMSYSERR_NOERROR )
    {
        LOG((RTC_ERROR, "CWavePlayer::OpenWaveDevice - "
                            "waveOutOpen failed 0x%lx", mmresult));
                            
        m_hWaveOut = NULL;
        return E_FAIL;
    }

    LOG((RTC_TRACE, "CWavePlayer::OpenWaveDevice - exit S_OK"));

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//

void CWavePlayer::CloseWaveDevice(void)
{
    LOG((RTC_TRACE, "CWavePlayer::CloseWaveDevice - enter"));
    
    if ( m_fInitialized == FALSE )
    {
        _ASSERTE( FALSE );
    }

    if ( m_hWaveOut != NULL )
    {
        waveOutReset( m_hWaveOut );
        waveOutClose( m_hWaveOut );

        m_hWaveOut = NULL;
    }

    LOG((RTC_TRACE, "CWavePlayer::CloseWaveDevice - exit"));
}

//////////////////////////////////////////////////////////////////////////////
//

BOOL CWavePlayer::IsWaveDeviceOpen(void)
{        
    if ( m_fInitialized == FALSE )
    {
        _ASSERTE( FALSE );
    }

    BOOL fResult = ( m_hWaveOut != NULL );

    LOG((RTC_TRACE, "CWavePlayer::IsWaveDeviceOpen - %s", fResult ? "TRUE" : "FALSE" ));

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\rtcwatcher.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCWatcher.h

Abstract:

    Definition of the CRTCWatcher class

--*/

#pragma once


/////////////////////////////////////////////////////////////////////////////
// CRTCParticipant

class ATL_NO_VTABLE CRTCWatcher :
#ifdef TEST_IDISPATCH
    public IDispatchImpl<IRTCWatcher, &IID_IRTCWatcher, &LIBID_RTCCORELib>, 
#else
    public IRTCWatcher,
#endif
	public CComObjectRoot
{

friend CRTCClient;

public:
    CRTCWatcher() : m_pCClient(NULL),
                    m_pSIPWatcherManager(NULL),
                    m_szPresentityURI(NULL),
                    m_szName(NULL),
                    m_szData(NULL),
                    m_bPersistent(FALSE),
                    m_nState(RTCWS_UNKNOWN),
                    m_bIsNested(FALSE),
                    m_szShutdownBlob(NULL)

    {}
BEGIN_COM_MAP(CRTCWatcher)
#ifdef TEST_IDISPATCH
    COM_INTERFACE_ENTRY(IDispatch)
#endif
    COM_INTERFACE_ENTRY(IRTCWatcher)
    COM_INTERFACE_ENTRY(IRTCPresenceContact)
END_COM_MAP()

    HRESULT FinalConstruct();

    void FinalRelease();

    STDMETHOD_(ULONG, InternalAddRef)();

    STDMETHOD_(ULONG, InternalRelease)(); 

    CRTCClient * GetClient();

    void    ReleaseAll();

    HRESULT Initialize(
                      CRTCClient         * pCClient,
                      ISIPWatcherManager * pSIPWatcherManager,
                      PCWSTR               szPresentityURI,
                      PCWSTR               szName,
                      PCWSTR               szData,
                      PCWSTR               szShutdownBlob,
                      BOOL                 bPersistent
                      );

    HRESULT SetSIPWatcher(
        ISIPWatcher * pSIPWatcher
        );

    HRESULT RemoveSIPWatcher(
        ISIPWatcher * pSIPWatcher,
        BOOL          bShutdown);
    
    HRESULT RemoveSIPWatcher(
        int           iIndex,
        BOOL          bShutdown);

    HRESULT GetSIPWatcherShutdownBlob();

    HRESULT SendSIPWatcherShutdownBlob();
    
    HRESULT CreateXMLDOMNode( IXMLDOMDocument * pXMLDoc, IXMLDOMNode ** ppXDN );

    HRESULT ChangeBlockedStatus(
        WATCHER_BLOCKED_STATUS Status);

    HRESULT ApproveSubscription(
        DWORD dwPresenceInfoRules 
        );

    HRESULT RejectSubscription(
        WATCHER_REJECT_REASON ulReason
        );

    HRESULT RemoveSIPWatchers(
        BOOL          bShutdown);

    void    PostSIPWatchersCleanUp(void);
       
private:

    CRTCClient            * m_pCClient;
    ISIPWatcherManager    * m_pSIPWatcherManager;
    PWSTR                   m_szPresentityURI;
    PWSTR                   m_szName;
    PWSTR                   m_szData;
    PWSTR                   m_szShutdownBlob;
    BOOL                    m_bPersistent;
    CRTCObjectArray<ISIPWatcher *>
                            m_SIPWatchers;
    RTC_WATCHER_STATE       m_nState;
    BOOL                    m_bIsNested;      

 
#if DBG
    PWSTR                   m_pDebug;
#endif

// IRTCWatcher
public:

    STDMETHOD(get_PresentityURI)(
            BSTR * pbstrPresentityURI
            );   

    STDMETHOD(put_PresentityURI)(
            BSTR bstrPresentityURI
            ); 

    STDMETHOD(get_Name)(
            BSTR * pbstrName
            );

    STDMETHOD(put_Name)(
            BSTR bstrName
            );

    STDMETHOD(get_Data)(
            BSTR * pbstrData
            );

    STDMETHOD(put_Data)(
            BSTR bstrData
            );

    STDMETHOD(get_Persistent)(
            VARIANT_BOOL *pfPersistent
            );                 
	
    STDMETHOD(put_Persistent)(
            VARIANT_BOOL fPersistent
            );                 

    STDMETHOD(get_State)(
            RTC_WATCHER_STATE * penState
            );                
    
    STDMETHOD(put_State)(
            RTC_WATCHER_STATE  enState
            );                
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\rtcwaves.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCWaves.h

Abstract:

    Definition of the CWavePlayer class

--*/

#ifndef __RTCWAVES__
#define __RTCWAVES__

#include <mmsystem.h>

#define NUM_WAVES 4

typedef enum WAVE
{
	WAVE_TONE,
	WAVE_RING,
    WAVE_MESSAGE,
    WAVE_RINGBACK
	
} WAVE;

//////////////////////////////////////////////////////////////////////////////
//
// class CWavePlayer
//
//

class CWavePlayer
{
public:

	CWavePlayer();
    ~CWavePlayer();

    static HRESULT Initialize(void);

    HRESULT OpenWaveDevice(long lWaveId);
    void    CloseWaveDevice(void);

    BOOL IsWaveDeviceOpen(void);

    HRESULT PlayWave(WAVE enWave);
    HRESULT StopWave();

private:

    // TRUE if Initialize has succeeded.
    static BOOL    m_fInitialized;

    // Handle to the wave out device. NULL when the device is not open.
    HWAVEOUT m_hWaveOut;

    // Wave header
    WAVEHDR m_WaveHeader;

    // Buffers for the tones
    static LPBYTE   m_lpWaveform[ NUM_WAVES ];

    static DWORD    m_dwWaveformSize[ NUM_WAVES ];
};

#endif // __RTCWAVES__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__971134B4_012C_4FC2_B7EB_6CD55D5EE1B0__INCLUDED_)
#define AFX_STDAFX_H__971134B4_012C_4FC2_B7EB_6CD55D5EE1B0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <control.h>
#include <RTCCore.h>

#include "rtcerr.h"
#include "rtcsip.h"
#include "RTCLog.h"
#include "RTCMem.h"
#include "RTCReg.h"
#include "RTCUtils.h"
#include "RTCWaves.h"
#include "RTCConnect.h"
#include "RTCClient.h"
#include "RTCSession.h"
#include "RTCParticipant.h"
#include "RTCBuddy.h"
#include "RTCWatcher.h"
#include "RTCProfile.h"
#include "RTCEnum.h"
#include "RTCColl.h"
#include "RTCEvents.h"
#include "RTCURI.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__971134B4_012C_4FC2_B7EB_6CD55D5EE1B0__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\genkey\genkey.cpp ===
// genkey.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

PWSTR 
base64encode(
    PBYTE pbBufInput, 
    long nBytes
    );

#define MASTER_KEY   L"Microsoft Real-Time Communications authorized domain"

BYTE    OurSecretKeyBlob[1024]; 

#define KEY_CONTAINER   L"Microsoft.RTCContainer"


int __cdecl wmain(int argc, WCHAR* argv[])
{
    DWORD   dwError;
    HCRYPTPROV  hProv = NULL;
    HCRYPTKEY   hKey = NULL;
    HANDLE hFile = NULL;
    DWORD      dwKeyLength = 0;
    PWSTR      pszName;

    // open the private key file
    pszName = argc>1 ? argv[1] : L"rtcpriv.bin";

    hFile = CreateFile(
        pszName,                         // file name
        GENERIC_READ,                      // access mode
        0,                          // share mode
        NULL, // SD
        OPEN_EXISTING,                // how to create
        FILE_ATTRIBUTE_NORMAL,                 // file attributes
        NULL);

    if(hFile == INVALID_HANDLE_VALUE)
    {
        dwError = GetLastError();

        fwprintf(stderr, L"Error %x returned by CreateFile\n", dwError);

        return dwError;
    }

    if(!ReadFile(
        hFile,
        OurSecretKeyBlob,
        sizeof(OurSecretKeyBlob),
        &dwKeyLength,
        NULL))
    {
        dwError = GetLastError();

        fwprintf(stderr, L"Error %x returned by ReadFile\n", dwError);
        CloseHandle(hFile);

        return dwError;
    }
    
    CloseHandle(hFile);

    // delete any existing container
    CryptAcquireContext(
        &hProv,
        KEY_CONTAINER,
        MS_DEF_PROV,
        PROV_RSA_FULL,
        CRYPT_DELETEKEYSET);

    // initialize crypto, create a new keyset
    if(!CryptAcquireContext(
        &hProv,
        KEY_CONTAINER,
        MS_DEF_PROV,
        PROV_RSA_FULL,
        CRYPT_NEWKEYSET | CRYPT_SILENT))
    {
        dwError = GetLastError();

        fwprintf(stderr, L"Error %x returned by CryptAcquireContext\n", dwError);

        return dwError;
    }

    // import the key
    if(!CryptImportKey(
        hProv,
        OurSecretKeyBlob,
        dwKeyLength,
        NULL,
        0,
        &hKey))
    {
        dwError = GetLastError();

        fwprintf(stderr, L"Error %x returned by CryptImportKey\n", dwError);

        CryptReleaseContext(hProv, 0);

        return dwError;
    }

    WCHAR   szLine[1024];  // hope it's enough

    // loop
    while(NULL != _getws(szLine))
    {
        HCRYPTHASH  hHash = NULL;
        WCHAR   szText[2048];
        BYTE    Signature[0x100]; // should be enough
        DWORD   dwSignatureLength = sizeof(Signature);
        
        // create a hash
        if(!CryptCreateHash(
            hProv,
            CALG_MD5,
            NULL,
            0,
            &hHash))

        {
            dwError = GetLastError();

            fwprintf(stderr, L"Error %x returned by CryptCreateHash\n", dwError);

            CryptDestroyKey(hKey);        
            CryptReleaseContext(hProv, 0);
    
            return dwError;
        }

        // create the text
        swprintf(szText, L"%s:%s", MASTER_KEY, szLine);

        // Hash it
        if(!CryptHashData(
            hHash,
            (BYTE *)szText,
            wcslen(szText) * sizeof(WCHAR), // length in bytes, without the NULL
            0))
        {
            dwError = GetLastError();
            
            fwprintf(stderr, L"Error %x returned by CryptHashData\n", dwError);
            
            CryptDestroyHash(hHash);
            CryptDestroyKey(hKey);        
            CryptReleaseContext(hProv, 0);

            return dwError;
        }

        // sign the hash
        if(!CryptSignHash(
            hHash,
            AT_SIGNATURE,
            NULL,
            0,
            Signature,
            &dwSignatureLength))

        {
            dwError = GetLastError();
            
            fwprintf(stderr, L"Error %x returned by CryptGetHashParam\n", dwError);
            
            CryptDestroyKey(hKey);        
            CryptDestroyHash(hHash);
            CryptReleaseContext(hProv, 0);

            return dwError;
        }
        
        // release the hash object and the key
        CryptDestroyHash(hHash);
        hHash = NULL;

        // convert the hash value to base64
        PWSTR pszStringValue = NULL;

        pszStringValue = base64encode(Signature, dwSignatureLength);
        if(!pszStringValue)
        {
            fwprintf(stderr, L"Out of memory\n");
         
            CryptDestroyKey(hKey);       
            CryptReleaseContext(hProv, 0);

            return ERROR_OUTOFMEMORY;
        }
        
        wprintf(L"%s\n", pszStringValue);

        LocalFree(pszStringValue);
    }

    CryptDestroyKey(hKey);       
    CryptReleaseContext(hProv, 0);

	return 0;
}



//
// the map for the encoder, according to RFC 1521
//
WCHAR _six2pr64[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};


//-------------------------------------------------------------------------------------------
// Function:     base64encode()
//
// Description:  base-64 encode a string of data
//
// Arguments:    bufin          -pointer to data to encode
//               nbytes         -number of bytes to encode (do not include the trailing '\0'
//                                                               in this measurement if it is a string.)
//
// Return Value: Returns '\0' terminated string if successful; otherwise NULL is returned.
//-------------------------------------------------------------------------------------------
PWSTR 
base64encode(
    PBYTE pbBufInput, 
    long nBytes
    )
{
    PWSTR pszOut = NULL;
    PWSTR pszReturn = NULL;
    long i;
    long OutBufSize;
    PWSTR six2pr = _six2pr64;
    PBYTE pbBufIn = NULL;
    PBYTE pbBuffer = NULL;
    DWORD nPadding;
    HRESULT hr;

    //  
    // Size of input buffer * 133%
    //  
    OutBufSize = nBytes + ((nBytes + 3) / 3) + 5; 

    //
    //  Allocate buffer with 133% of nBytes
    //
    pszOut = (PWSTR)LocalAlloc(LPTR, (OutBufSize + 1)*sizeof(WCHAR));
    if (pszOut == NULL)
    {
        hr = E_OUTOFMEMORY;
        return NULL;
    }
    pszReturn = pszOut;

    nPadding = 3 - (nBytes % 3);
    if (nPadding == 3) {
        pbBufIn = pbBufInput;
    }
    else {
        pbBuffer = (PBYTE)LocalAlloc(LPTR, nBytes + nPadding);
        if (pbBuffer == NULL)
        {
            hr = E_OUTOFMEMORY;
            LocalFree(pszOut);
            return NULL;
        }
        pbBufIn = pbBuffer;
        memcpy(pbBufIn,pbBufInput,nBytes);
        while (nPadding) {
            pbBufIn[nBytes+nPadding-1] = 0;
            nPadding--;
        }
    }
    

    //
    // Encode everything
    //  
    for (i=0; i<nBytes; i += 3) {
        *(pszOut++) = six2pr[*pbBufIn >> 2];                                     // c1 
        *(pszOut++) = six2pr[((*pbBufIn << 4) & 060) | ((pbBufIn[1] >> 4) & 017)]; // c2
        *(pszOut++) = six2pr[((pbBufIn[1] << 2) & 074) | ((pbBufIn[2] >> 6) & 03)];// c3
        *(pszOut++) = six2pr[pbBufIn[2] & 077];                                  // c4 
        pbBufIn += 3;
    }

    //
    // If nBytes was not a multiple of 3, then we have encoded too
    // many characters.  Adjust appropriately.
    //
    if (i == nBytes+1) {
        // There were only 2 bytes in that last group 
        pszOut[-1] = '=';
    } 
    else if (i == nBytes+2) {
        // There was only 1 byte in that last group 
        pszOut[-1] = '=';
        pszOut[-2] = '=';
    }

    *pszOut = '\0';

    LocalFree(pbBuffer);
    
    return pszReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\genkey\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	genkey.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\genkey\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__E1A62BB8_7960_40A9_9860_3DD97CD5A656__INCLUDED_)
#define AFX_STDAFX_H__E1A62BB8_7960_40A9_9860_3DD97CD5A656__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__E1A62BB8_7960_40A9_9860_3DD97CD5A656__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\test\rtctest.h ===
#ifndef __RTCTEST__
#define __RTCTEST__

#define WM_CORE_EVENT      WM_USER+100
#define WM_CREATE_SESSION  WM_USER+101
#define WM_LISTEN          WM_USER+102

#define TID_CALL_TIMER     100

class CRTCEvents :
	public IRTCEventNotification
{
private:
    DWORD m_dwRefCount;
    DWORD m_dwCookie;
    HWND  m_hWnd;

public:
    CRTCEvents() : m_dwRefCount(NULL),
                   m_dwCookie(NULL),
                   m_hWnd(NULL)
    {
    }

    /////////////////////////////////////////////
    //
    // QueryInterface
    // 

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppvObject)
    {
        if (iid == IID_IRTCEventNotification)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        if (iid == IID_IUnknown)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        return E_NOINTERFACE;
    }

    /////////////////////////////////////////////
    //
    // AddRef
    // 

	ULONG STDMETHODCALLTYPE AddRef()
    {
        m_dwRefCount++;
        return m_dwRefCount;
    }
    
    /////////////////////////////////////////////
    //
    // Release
    // 

	ULONG STDMETHODCALLTYPE Release()
    {
        m_dwRefCount--;

        if ( 0 == m_dwRefCount)
        {
            delete this;
        }

        return 1;
    }

    /////////////////////////////////////////////
    //
    // Advise
    // 

    HRESULT Advise(IRTCClient * pClient, HWND hWnd)
    {    
	    IConnectionPointContainer * pCPC;
	    IConnectionPoint * pCP;

	    HRESULT hr = pClient->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);

	    if (SUCCEEDED(hr))
        {
		    hr = pCPC->FindConnectionPoint(IID_IRTCEventNotification, &pCP);

            pCPC->Release();

            if (SUCCEEDED(hr))
            {
		        hr = pCP->Advise(this, &m_dwCookie);

                pCP->Release();
            }
        }

        m_hWnd = hWnd;

	    return hr;
    }

    /////////////////////////////////////////////
    //
    // Unadvise
    // 

    HRESULT Unadvise(IRTCClient * pClient)
    {
	    IConnectionPointContainer * pCPC;
	    IConnectionPoint * pCP;

	    HRESULT hr = pClient->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);

	    if (SUCCEEDED(hr))
        {
		    hr = pCPC->FindConnectionPoint(IID_IRTCEventNotification, &pCP);

            pCPC->Release();

            if (SUCCEEDED(hr))
            {
		        hr = pCP->Unadvise(m_dwCookie);

                pCP->Release();
            }
        }

	    return hr;
    }

    /////////////////////////////////////////////
    //
    // Event
    // 

	HRESULT STDMETHODCALLTYPE Event(
        RTC_EVENT enEvent,
        IDispatch * pDisp
        )
    {
        pDisp->AddRef();

        PostMessage( m_hWnd, WM_CORE_EVENT, (WPARAM)enEvent, (LPARAM)pDisp );

        return S_OK;
    }
};

#endif //__RTCTEST__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\test\rtctest.cpp ===
#define UNICODE
#include <windows.h>
#include <RTCCore.h>
#include <rtcerr.h>
#include <stdio.h>

#include "RTCTest.h"

IRTCClient  * g_pClient = NULL;
IRTCSession * g_pSession = NULL;
CRTCEvents  * g_pEvents = NULL;

/////////////////////////////////////////////
//
// WndProc
// 

LRESULT CALLBACK WndProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HRESULT hr;

    switch ( uMsg )
    {
    case WM_CREATE:
        {
            hr = CoCreateInstance(
                                  CLSID_RTCClient,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IRTCClient,
                                  (LPVOID *)&g_pClient
                                 );

            if ( FAILED(hr) )
            {
                printf("CoCreateInstance failed 0x%lx\n", hr);

                return -1;
            }

            hr = g_pClient->Initialize();

            if ( FAILED(hr) )
            {
                printf("Initialize failed 0x%lx\n", hr);

                return -1;
            }

            hr = g_pClient->SetPreferredMediaTypes( 
                         RTCMT_AUDIO_SEND |
                         RTCMT_AUDIO_RECEIVE |
                         RTCMT_VIDEO_SEND |
                         RTCMT_VIDEO_RECEIVE,
                         VARIANT_FALSE
                         );

            if ( FAILED(hr) )
            {
                printf("SetPreferredMediaTypes failed 0x%lx\n", hr);

                return -1;
            }

            hr = g_pClient->put_EventFilter( 
                         RTCEF_SESSION_STATE_CHANGE |
                         RTCEF_MEDIA |
                         RTCEF_CLIENT
                         );

            if ( FAILED(hr) )
            {
                printf("put_EventFilter failed 0x%lx\n", hr);

                return -1;
            }


            g_pEvents = new CRTCEvents;

            hr = g_pEvents->Advise( g_pClient, hWnd );

            if ( FAILED(hr) )
            {
                printf("Advise failed 0x%lx\n", hr);

                return -1;
            }
    
            return 0;
        }

    case WM_DESTROY:        
        {
            printf("Exiting...\n");

            if ( g_pEvents )
            {
                hr = g_pEvents->Unadvise( g_pClient );

                if ( FAILED(hr) )
                {
                    printf("Unadvise failed 0x%lx\n", hr);
                }

                g_pEvents = NULL;
            }

            if ( g_pSession )
            {
                g_pSession->Release();
                g_pSession = NULL;
            }
            
            if ( g_pClient )
            {
                hr = g_pClient->Shutdown();

                if ( FAILED(hr) )
                {
                    printf("Shutdown failed 0x%lx\n", hr);
                }

                g_pClient->Release();
                g_pClient = NULL;
            }

            PostQuitMessage(0);

            return 0;
        }

    case WM_TIMER:
        {
            if ( wParam == TID_CALL_TIMER )
            {
                KillTimer( hWnd, TID_CALL_TIMER );

                if ( g_pSession )
                {
                    hr = g_pSession->Terminate( RTCTR_NORMAL );

                    if ( FAILED(hr) )
                    {
                        printf("Terminate failed 0x%lx\n", hr);

                        DestroyWindow(hWnd);
                    }
                }
            }

            return 0;
        }

    case WM_CORE_EVENT:
        {
            switch ( wParam )
            {
                case RTCE_SESSION_STATE_CHANGE:
                    {
                        IRTCSessionStateChangeEvent * pSSC;
                        IRTCSession                 * pSession;
                        RTC_SESSION_STATE             enSS;
                        IDispatch                   * pDisp;
                        long                          lStatus;
                        BSTR                          bstrStatus;
                
                        pDisp = (IDispatch *)lParam;

                        pDisp->QueryInterface( IID_IRTCSessionStateChangeEvent,
                                               (void **)&pSSC
                                             );

                        pDisp->Release();
                                       
                        hr = pSSC->get_State(&enSS);

                        if ( FAILED(hr) )
                        {
                            printf("get_State failed 0x%lx\n", hr);

                            pSSC->Release();
                            return 0;
                        }

                        hr = pSSC->get_StatusCode(&lStatus);

                        if ( FAILED(hr) )
                        {
                            printf("get_StatusCode failed 0x%lx\n", hr);

                            pSSC->Release();
                            return 0;
                        }

                        hr = pSSC->get_StatusText(&bstrStatus);

                        if ( FAILED(hr) && (hr != E_FAIL))
                        {
                            printf("get_StatusText failed 0x%lx\n", hr);
                            
                            pSSC->Release();
                            return 0;
                        }

                        if (HRESULT_FACILITY(lStatus) == FACILITY_SIP_STATUS_CODE)
                        {
                            printf("Status: %d %ws\n", HRESULT_CODE(lStatus), bstrStatus);
                        }

                        SysFreeString( bstrStatus );

                        hr = pSSC->get_Session(&pSession);

                        if ( FAILED(hr) )
                        {
                            printf("get_Session failed 0x%lx\n", hr);

                            pSSC->Release();
                            return 0;
                        }

                        if ( (g_pSession == pSession) ||
                             (enSS == RTCSS_INCOMING) )
                        {
                            switch(enSS)
                            {
                                case RTCSS_IDLE:
                                    printf("IDLE [0x%lx]\n", pSession);
                                    break;

                                case RTCSS_INPROGRESS:
                                    printf("INPROGRESS [0x%lx]\n", pSession);
                                    break;

                                case RTCSS_INCOMING:
                                    printf("INCOMING [0x%lx]\n", pSession);

                                    if ( g_pSession ) g_pSession->Release();

                                    g_pSession = pSession;
                                    g_pSession->AddRef();

                                    hr = g_pSession->Answer();

                                    if ( FAILED(hr) )
                                    {
                                        printf("Answer failed 0x%lx\n", hr);

                                        DestroyWindow(hWnd);
                                    }

                                    break;

                                case RTCSS_CONNECTED:
                                    printf("CONNECTED [0x%lx]\n", pSession);

                                    SetTimer( hWnd, TID_CALL_TIMER, 30000, NULL);

                                    break;

                                case RTCSS_DISCONNECTED:
                                    printf("DISCONNECTED [0x%lx]\n", pSession);

                                    if ( g_pSession ) g_pSession->Release();
                                    g_pSession = NULL;

                                    hr = g_pClient->PrepareForShutdown();

                                    if ( FAILED(hr) )
                                    {
                                        printf("PrepareForShutdown failed 0x%lx\n", hr);

                                        DestroyWindow(hWnd);
                                    }
                                    break;
                            }
                        }

                        pSSC->Release();
                        pSession->Release();
                    }            
                    break;  
                    
                case RTCE_MEDIA:
                    {
                        IRTCMediaEvent        * pM;
                        IDispatch             * pDisp;
                        RTC_MEDIA_EVENT_TYPE	enEventType; 
                        long                    lMediaType;
                
                        pDisp = (IDispatch *)lParam;

                        pDisp->QueryInterface( IID_IRTCMediaEvent,
                                               (void **)&pM
                                             );

                        pDisp->Release();
                                       
                        hr = pM->get_EventType(&enEventType);

                        if ( FAILED(hr) )
                        {
                            printf("get_EventType failed 0x%lx\n", hr);

                            pM->Release();
                            return 0;
                        }

                        hr = pM->get_MediaType(&lMediaType);

                        if ( FAILED(hr) )
                        {
                            printf("get_MediaType failed 0x%lx\n", hr);

                            pM->Release();
                            return 0;
                        }
                        
                        IVideoWindow * pVid = NULL;
                           
                        if ( lMediaType == RTCMT_VIDEO_SEND )
                        {
                            hr = g_pClient->get_IVideoWindow(RTCVD_PREVIEW, &pVid);
                        }
                        else if ( lMediaType == RTCMT_VIDEO_RECEIVE )
                        {
                            hr = g_pClient->get_IVideoWindow(RTCVD_RECEIVE, &pVid);
                        }

                        if ( (pVid != NULL) && SUCCEEDED(hr) )
                        {
                            if ( enEventType == RTCMET_STARTED )
                            {
                                pVid->put_Visible( -1 );
                            }
                            else if ( enEventType == RTCMET_STOPPED )
                            {
                                pVid->put_Visible( 0 );
                            }

                            pVid->Release();
                        }                     
                        
                        pM->Release();
                    }            
                    break;  
                    
                case RTCE_CLIENT:
                    {
                        IRTCClientEvent       * pC;
                        IDispatch             * pDisp;
                        RTC_CLIENT_EVENT_TYPE	enEventType; 
                
                        pDisp = (IDispatch *)lParam;

                        pDisp->QueryInterface( IID_IRTCClientEvent,
                                               (void **)&pC
                                             );

                        pDisp->Release();
                                       
                        hr = pC->get_EventType(&enEventType);

                        if ( FAILED(hr) )
                        {
                            printf("get_EventType failed 0x%lx\n", hr);

                            pC->Release();
                            return 0;
                        }

                        if ( enEventType == RTCCET_ASYNC_CLEANUP_DONE )
                        {
                            DestroyWindow(hWnd);
                        }
                        
                        pC->Release();
                    }            
                    break; 
            }

            return 0;
        }

    case WM_CREATE_SESSION:
        {
            printf("Calling %ws...\n", (BSTR)wParam);

            hr = g_pClient->CreateSession( RTCST_PC_TO_PC, NULL, NULL, 0, &g_pSession );

            if ( FAILED(hr) )
            {
                printf("CreateSession failed 0x%lx\n", hr);

                DestroyWindow(hWnd);
            }

            hr = g_pSession->AddParticipant( (BSTR)wParam, NULL, NULL);

            if ( FAILED(hr) )
            {
                printf("AddParticipant failed 0x%lx\n", hr);

                DestroyWindow(hWnd);
            }

            SysFreeString( (BSTR)wParam );

            return 0;
        }

    case WM_LISTEN:
        {
            printf("Listening...\n");

            hr = g_pClient->put_ListenForIncomingSessions( RTCLM_BOTH );

            if ( FAILED(hr) )
            {
                printf("put_ListenForIncomingSessions failed 0x%lx\n", hr);

                DestroyWindow(hWnd);
            }

            return 0;
        }


    default:
        return DefWindowProc( hWnd, uMsg, wParam, lParam );
    }

    return 0;
}

/////////////////////////////////////////////
//
// Main
// 

int _cdecl main(int argc, char* argv[])
{
    WNDCLASS wc;
    HWND     hWnd;
    MSG      msg;
    HRESULT  hr;

    hr =  CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

    if ( FAILED(hr) )
    {
        printf("CoInitializeEx failed 0x%lx\n", hr);

        return 0;
    }
    
    ZeroMemory(&wc, sizeof(WNDCLASS));

    wc.lpfnWndProc = WndProc;
    wc.hInstance = GetModuleHandle(NULL);
    wc.lpszClassName = TEXT("RTCTestClass");
    
    if ( !RegisterClass( &wc ) )
    {
        printf("RegisterClass failed 0x%lx\n", HRESULT_FROM_WIN32(GetLastError()));

        return 0;
    }
    
    hWnd = CreateWindow(
            TEXT("RTCTestClass"),
            TEXT("RTCTest"),
            WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            NULL,
            NULL,
            GetModuleHandle(NULL),
            NULL
            );

    if ( hWnd == NULL )
    {
        printf("CreateWindow failed 0x%lx\n", HRESULT_FROM_WIN32(GetLastError()));

        return 0;
    }           

    if ( argc > 1 )
    {
        BSTR bstrURI;
        WCHAR szURI[256];

        MultiByteToWideChar( CP_ACP, 0, argv[1], -1, szURI, 256 );

        bstrURI = SysAllocString(szURI);

        PostMessage( hWnd, WM_CREATE_SESSION, (WPARAM)bstrURI, 0 );
    }
    else
    {
        PostMessage( hWnd, WM_LISTEN, 0, 0 );
    }

    while ( GetMessage( &msg, NULL, 0, 0 ) > 0 )
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }

    CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\stress\rtcstress.cpp ===
#define UNICODE
#include <windows.h>
#include <RTCCore.h>
#include <stdio.h>

#include "RTCStress.h"

IRTCClient  * g_pClient = NULL;
CRTCEvents  * g_pEvents = NULL;
IRTCClientProvisioning * g_pProv = NULL;

CRTCObjectArray<IRTCProfile *> g_ProfileArray;
int g_nProfilesEnabled = 0;
int g_nProfilesUpdated = 0;
int g_nProfilesDisabled = 0;
int g_nProfilesRegistering = 0;
int g_nProfilesRegistered = 0;
int g_nProfilesUnregistering = 0;
int g_nProfilesUnregistered = 0;
int g_nProfilesReject = 0;
int g_nProfilesError = 0;

HWND g_hEditWnd = NULL;
BOOL g_bExit = FALSE;

/////////////////////////////////////////////
//
// WndProc
// 

LRESULT CALLBACK WndProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HRESULT hr;

    switch ( uMsg )
    {
    case WM_CREATE:
        {
            hr = CoCreateInstance(
                                  CLSID_RTCClient,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IRTCClient,
                                  (LPVOID *)&g_pClient
                                 );

            if ( FAILED(hr) )
            {
                printf("CoCreateInstance failed 0x%lx\n", hr);

                return -1;
            }

            hr = g_pClient->Initialize();

            if ( FAILED(hr) )
            {
                printf("Initialize failed 0x%lx\n", hr);

                return -1;
            }

            hr = g_pClient->put_EventFilter( 
                         RTCEF_REGISTRATION_STATE_CHANGE |
                         RTCEF_CLIENT
                         );

            if ( FAILED(hr) )
            {
                printf("put_EventFilter failed 0x%lx\n", hr);

                return -1;
            }


            g_pEvents = new CRTCEvents;

            hr = g_pEvents->Advise( g_pClient, hWnd );

            if ( FAILED(hr) )
            {
                printf("Advise failed 0x%lx\n", hr);

                return -1;
            }

            hr = g_pClient->QueryInterface( IID_IRTCClientProvisioning, (void**)&g_pProv );

            if ( FAILED(hr) )
            {
                printf("QueryInterface failed 0x%lx\n", hr);

                return -1;
            }            

            PostMessage( hWnd, WM_TEST, 0, 0 );
    
            return 0;
        }

    case WM_DESTROY:        
        {
            printf("Exiting...\n");

            if ( g_pEvents )
            {
                hr = g_pEvents->Unadvise( g_pClient );

                if ( FAILED(hr) )
                {
                    printf("Unadvise failed 0x%lx\n", hr);
                }

                delete g_pEvents;
            }

            if ( g_pProv )
            {
                g_pProv->Release();
            }
            
            if ( g_pClient )
            {
                hr = g_pClient->Shutdown();

                if ( FAILED(hr) )
                {
                    printf("Shutdown failed 0x%lx\n", hr);
                }

                g_pClient->Release();
            }

            PostQuitMessage(0);

            return 0;
        }

    case WM_TEST:
        {
            switch ( rand() & 3 )
            {
            case 0: // enable a profile
                {
                    int n = rand();                    

                    WCHAR szXML[1000];
                    _snwprintf( szXML, 1000, L"<provision key=\"%x\" name=\"Amun\"><provider name=\"Amun\" homepage=\"http://winrtc/phoenix\"><data>test</data></provider><client name=\"Phoenix\" banner=\"false\"/><user uri=\"sip:rtctest@microsoft.com\"/><accesscontrol domain=\"ntdev.microsoft.com\" sig=\"43r8mXTFvSMBZHajABKbd5ee1vHXUDqJIUxhsmtF67UZZryIolEdp/1qs2oiTKbKrAlAsIzOoCL75lTzZSbacA==\" /><sipsrv addr=\"amun1.ntdev.microsoft.com\" protocol=\"udp\" role=\"registrar\"/><sipsrv addr=\"amun1.ntdev.microsoft.com\" protocol=\"udp\" role=\"proxy\"><session party=\"first\" type=\"pc2pc\"/><session party=\"first\" type=\"pc2ph\"/><session party=\"first\" type=\"im\"/></sipsrv></provision>", n );
                   
                    IRTCProfile * pProfile;

                    BSTR bstrXML = SysAllocString( szXML );
                    hr = g_pProv->CreateProfile( bstrXML, &pProfile );

                    SysFreeString( bstrXML );

                    if ( FAILED(hr) )
                    {
                        printf("CreateProfile failed 0x%lx\n", hr);

                        DebugBreak();

                        break;
                    }

                    printf("Enabling profile 0x%x...\n", pProfile);

                    hr = g_pProv->EnableProfile( pProfile, RTCRF_REGISTER_ALL );

                    if ( FAILED(hr) )
                    {
                        printf("EnableProfile failed 0x%lx\n", hr);

                        DebugBreak();

                        break;
                    }

                    g_ProfileArray.Add(pProfile);
                    g_nProfilesEnabled++;

                    pProfile->Release();     
                }
                break;

            case 1: // update a profile
                {
                    if ( g_ProfileArray.GetSize() == 0 ) break;

                    int index = rand() % g_ProfileArray.GetSize();

                    BSTR bstrXML;
                                     
                    hr = g_ProfileArray[index]->get_XML( &bstrXML );

                    if ( FAILED(hr) )
                    {
                        printf("get_XML failed 0x%lx\n", hr);

                        DebugBreak();

                        break;
                    }

                    IRTCProfile * pProfile;

                    hr = g_pProv->CreateProfile( bstrXML, &pProfile );

                    SysFreeString( bstrXML );

                    if ( FAILED(hr) )
                    {
                        printf("CreateProfile failed 0x%lx\n", hr);

                        DebugBreak();

                        break;
                    }

                    printf("Updating profile 0x%x -> 0x%x...\n", g_ProfileArray[index], pProfile);

                    hr = g_pProv->EnableProfile( pProfile, RTCRF_REGISTER_ALL );

                    if ( FAILED(hr) )
                    {
                        printf("EnableProfile failed 0x%lx\n", hr);

                        DebugBreak();

                        break;
                    }

                    g_ProfileArray.RemoveAt(index);
                    g_ProfileArray.Add(pProfile);
                    g_nProfilesUpdated++;

                    pProfile->Release();     
                }

            case 2: // disable a profile
                {
                    if ( g_ProfileArray.GetSize() == 0 ) break;

                    int index = rand() % g_ProfileArray.GetSize();

                    printf("Disable profile 0x%x...\n", g_ProfileArray[index]);

                    hr = g_pProv->DisableProfile( g_ProfileArray[index] );

                    if ( FAILED(hr) )
                    {
                        printf("DisableProfile failed 0x%lx\n", hr);

                        DebugBreak();

                        break;
                    }

                    g_ProfileArray.RemoveAt(index);
                    g_nProfilesDisabled++;  
                }
            }

            SendMessage( hWnd, WM_UPDATE, 0, 0 );

            SetTimer( hWnd, TID_TIMER, 100, NULL);

            return 0;
        }

    case WM_UPDATE:
        {
            WCHAR szText[1000];
            _snwprintf( szText, 1000, L"Enabled = %d\nUpdated = %d\nDisabled = %d\n\nRegistering = %d\nRegistered = %d\nUnregistering = %d\nUnregistered = %d\nReject = %d\nError = %d",
                g_nProfilesEnabled,
                g_nProfilesUpdated,
                g_nProfilesDisabled,
                g_nProfilesRegistering,
                g_nProfilesRegistered,
                g_nProfilesUnregistering,
                g_nProfilesUnregistered,
                g_nProfilesReject,
                g_nProfilesError);

            SetWindowTextW( g_hEditWnd, szText );

            return 0;
        }

    case WM_TIMER:
        {
            switch ( wParam )
            {
            case TID_TIMER:
                {
                    KillTimer( hWnd, TID_TIMER );

                    if ( !g_bExit ) PostMessage( hWnd, WM_TEST, 0, 0 );
                }
                break;
            }

            return 0;
        }

    case WM_CLOSE:
        {
            if ( g_bExit )
            {
                SetWindowText( hWnd, TEXT("RTCStress - Shutdown...") );

                g_pClient->PrepareForShutdown();

                return 0;
            }

            g_bExit = TRUE;

            SetWindowText( hWnd, TEXT("RTCStress - Waiting...") );

            while ( g_ProfileArray.GetSize() )
            {
                printf("Disable profile 0x%x...\n", g_ProfileArray[0]);

                hr = g_pProv->DisableProfile( g_ProfileArray[0] ); 

                if ( FAILED(hr) )
                {
                    printf("DisableProfile failed 0x%lx\n", hr);

                    DebugBreak();

                    break;
                }

                g_ProfileArray.RemoveAt(0);
                g_nProfilesDisabled++;
            }

            //MessageBox( hWnd, TEXT("Finished!"), TEXT("RTCStress"), MB_OK );

            //DestroyWindow( hWnd );

            return 0;
        }

    case WM_CORE_EVENT:
        {
            switch ( wParam )
            {
                case RTCE_REGISTRATION_STATE_CHANGE:
                    {
                        IRTCRegistrationStateChangeEvent * pRSC;
                        IRTCProfile                      * pProfile;
                        RTC_REGISTRATION_STATE             enRS;
                        IDispatch                        * pDisp;
                
                        pDisp = (IDispatch *)lParam;

                        pDisp->QueryInterface( IID_IRTCRegistrationStateChangeEvent,
                                               (void **)&pRSC
                                             );

                        pDisp->Release();
                                       
                        hr = pRSC->get_State(&enRS);

                        if ( FAILED(hr) )
                        {
                            printf("get_State failed 0x%lx\n", hr);

                            pRSC->Release();
                            return 0;
                        }

                        hr = pRSC->get_Profile(&pProfile);

                        if ( FAILED(hr) )
                        {
                            printf("get_Profile failed 0x%lx\n", hr);

                            pRSC->Release();
                            return 0;
                        }

                        switch(enRS)
                        {
                            case RTCRS_NOT_REGISTERED:
                                printf("RTCRS_NOT_REGISTERED [0x%lx]\n", pProfile);

                                g_nProfilesUnregistered++;
                                break;

                            case RTCRS_REGISTERING:
                                printf("RTCRS_REGISTERING [0x%lx]\n", pProfile);

                                g_nProfilesRegistering++;
                                break;

                            case RTCRS_REGISTERED:
                                printf("RTCRS_REGISTERED [0x%lx]\n", pProfile);

                                g_nProfilesRegistered++;
                                break;

                            case RTCRS_REJECTED:
                                printf("RTCRS_REJECTED [0x%lx]\n", pProfile);

                                g_nProfilesReject++;
                                break;

                            case RTCRS_UNREGISTERING:
                                printf("RTCRS_UNREGISTERING [0x%lx]\n", pProfile);

                                g_nProfilesUnregistering++;
                                break;

                            case RTCRS_ERROR:
                                printf("RTCRS_ERROR [0x%lx]\n", pProfile);

                                g_nProfilesError++;
                                break;
                        }

                        pRSC->Release();
                        pProfile->Release();

                        SendMessage( hWnd, WM_UPDATE, 0, 0 );
                    }            
                    break;            
                    
                case RTCE_CLIENT:
                    {
                        IRTCClientEvent       * pC;
                        IDispatch             * pDisp;
                        RTC_CLIENT_EVENT_TYPE	enEventType; 
                
                        pDisp = (IDispatch *)lParam;

                        pDisp->QueryInterface( IID_IRTCClientEvent,
                                               (void **)&pC
                                             );

                        pDisp->Release();
                                       
                        hr = pC->get_EventType(&enEventType);

                        if ( FAILED(hr) )
                        {
                            printf("get_EventType failed 0x%lx\n", hr);

                            pC->Release();
                            return 0;
                        }

                        if ( enEventType == RTCCET_ASYNC_CLEANUP_DONE )
                        {
                            DestroyWindow(hWnd);
                        }
                        
                        pC->Release();
                    }            
                    break; 
            }

            return 0;
        }

    default:
        return DefWindowProc( hWnd, uMsg, wParam, lParam );
    }

    return 0;
}

/////////////////////////////////////////////
//
// Main
// 

int _cdecl main(int argc, char* argv[])
{
    WNDCLASS wc;
    HWND     hWnd;
    MSG      msg;
    HRESULT  hr;

    hr =  CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

    if ( FAILED(hr) )
    {
        printf("CoInitializeEx failed 0x%lx\n", hr);

        return 0;
    }
    
    ZeroMemory(&wc, sizeof(WNDCLASS));

    wc.lpfnWndProc = WndProc;
    wc.hInstance = GetModuleHandle(NULL);
    wc.lpszClassName = TEXT("RTCStressClass");
    
    if ( !RegisterClass( &wc ) )
    {
        printf("RegisterClass failed 0x%lx\n", HRESULT_FROM_WIN32(GetLastError()));

        return 0;
    }

#define WIDTH 300
#define HEIGHT 200
    
    hWnd = CreateWindow(
            TEXT("RTCStressClass"),
            TEXT("RTCStress"),
            WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            WIDTH,
            HEIGHT,
            NULL,
            NULL,
            GetModuleHandle(NULL),
            NULL
            );

    if ( hWnd == NULL )
    {
        printf("CreateWindow failed 0x%lx\n", HRESULT_FROM_WIN32(GetLastError()));

        return 0;
    } 

    g_hEditWnd = CreateWindow(
            TEXT("STATIC"),
            TEXT(""),
            WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS,
            0,
            0,
            WIDTH,
            HEIGHT,
            hWnd,
            NULL,
            GetModuleHandle(NULL),
            NULL
            );

    if ( g_hEditWnd == NULL )
    {
        printf("CreateWindow failed 0x%lx\n", HRESULT_FROM_WIN32(GetLastError()));

        return 0;
    }
    
    ShowWindow( hWnd, SW_SHOW );
    UpdateWindow( hWnd );

    while ( GetMessage( &msg, NULL, 0, 0 ) > 0 )
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }

    CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\test2\rtctest.h ===
#ifndef __RTCTEST__
#define __RTCTEST__

#define WM_CORE_EVENT      WM_USER+100

#define TID_TIMER1         100
#define TID_TIMER2         101
#define TID_TIMER3         102
#define TID_TIMER4         103
#define TID_TIMER5         104

class CRTCEvents :
	public IRTCEventNotification
{
private:
    DWORD m_dwRefCount;
    DWORD m_dwCookie;
    HWND  m_hWnd;

public:
    CRTCEvents() : m_dwRefCount(NULL),
                   m_dwCookie(NULL),
                   m_hWnd(NULL)
    {
    }

    /////////////////////////////////////////////
    //
    // QueryInterface
    // 

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppvObject)
    {
        if (iid == IID_IRTCEventNotification)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        if (iid == IID_IUnknown)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        return E_NOINTERFACE;
    }

    /////////////////////////////////////////////
    //
    // AddRef
    // 

	ULONG STDMETHODCALLTYPE AddRef()
    {
        m_dwRefCount++;
        return m_dwRefCount;
    }
    
    /////////////////////////////////////////////
    //
    // Release
    // 

	ULONG STDMETHODCALLTYPE Release()
    {
        m_dwRefCount--;

        if ( 0 == m_dwRefCount)
        {
            delete this;
        }

        return 1;
    }

    /////////////////////////////////////////////
    //
    // Advise
    // 

    HRESULT Advise(IRTCClient * pClient, HWND hWnd)
    {    
	    IConnectionPointContainer * pCPC;
	    IConnectionPoint * pCP;

	    HRESULT hr = pClient->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);

	    if (SUCCEEDED(hr))
        {
		    hr = pCPC->FindConnectionPoint(IID_IRTCEventNotification, &pCP);

            pCPC->Release();

            if (SUCCEEDED(hr))
            {
		        hr = pCP->Advise(this, &m_dwCookie);

                pCP->Release();
            }
        }

        m_hWnd = hWnd;

	    return hr;
    }

    /////////////////////////////////////////////
    //
    // Unadvise
    // 

    HRESULT Unadvise(IRTCClient * pClient)
    {
	    IConnectionPointContainer * pCPC;
	    IConnectionPoint * pCP;

	    HRESULT hr = pClient->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);

	    if (SUCCEEDED(hr))
        {
		    hr = pCPC->FindConnectionPoint(IID_IRTCEventNotification, &pCP);

            pCPC->Release();

            if (SUCCEEDED(hr))
            {
		        hr = pCP->Unadvise(m_dwCookie);

                pCP->Release();
            }
        }

	    return hr;
    }

    /////////////////////////////////////////////
    //
    // Event
    // 

	HRESULT STDMETHODCALLTYPE Event(
        RTC_EVENT enEvent,
        IDispatch * pDisp
        )
    {
        pDisp->AddRef();

        PostMessage( m_hWnd, WM_CORE_EVENT, (WPARAM)enEvent, (LPARAM)pDisp );

        return S_OK;
    }
};

#endif //__RTCTEST__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\stress\rtcstress.h ===
#ifndef __RTCTEST__
#define __RTCTEST__

#define WM_CORE_EVENT      WM_USER+100
#define WM_TEST            WM_USER+101
#define WM_UPDATE          WM_USER+102

#define TID_TIMER          100

class CRTCEvents :
	public IRTCEventNotification
{
private:
    DWORD m_dwRefCount;
    DWORD m_dwCookie;
    HWND  m_hWnd;

public:
    CRTCEvents() : m_dwRefCount(NULL),
                   m_dwCookie(NULL),
                   m_hWnd(NULL)
    {
    }

    /////////////////////////////////////////////
    //
    // QueryInterface
    // 

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppvObject)
    {
        if (iid == IID_IRTCEventNotification)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        if (iid == IID_IUnknown)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        return E_NOINTERFACE;
    }

    /////////////////////////////////////////////
    //
    // AddRef
    // 

	ULONG STDMETHODCALLTYPE AddRef()
    {
        m_dwRefCount++;
        return m_dwRefCount;
    }
    
    /////////////////////////////////////////////
    //
    // Release
    // 

	ULONG STDMETHODCALLTYPE Release()
    {
        m_dwRefCount--;

        if ( 0 == m_dwRefCount)
        {
            delete this;
        }

        return 1;
    }

    /////////////////////////////////////////////
    //
    // Advise
    // 

    HRESULT Advise(IRTCClient * pClient, HWND hWnd)
    {    
	    IConnectionPointContainer * pCPC;
	    IConnectionPoint * pCP;

	    HRESULT hr = pClient->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);

	    if (SUCCEEDED(hr))
        {
		    hr = pCPC->FindConnectionPoint(IID_IRTCEventNotification, &pCP);

            pCPC->Release();

            if (SUCCEEDED(hr))
            {
		        hr = pCP->Advise(this, &m_dwCookie);

                pCP->Release();
            }
        }

        m_hWnd = hWnd;

	    return hr;
    }

    /////////////////////////////////////////////
    //
    // Unadvise
    // 

    HRESULT Unadvise(IRTCClient * pClient)
    {
	    IConnectionPointContainer * pCPC;
	    IConnectionPoint * pCP;

	    HRESULT hr = pClient->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);

	    if (SUCCEEDED(hr))
        {
		    hr = pCPC->FindConnectionPoint(IID_IRTCEventNotification, &pCP);

            pCPC->Release();

            if (SUCCEEDED(hr))
            {
		        hr = pCP->Unadvise(m_dwCookie);

                pCP->Release();
            }
        }

	    return hr;
    }

    /////////////////////////////////////////////
    //
    // Event
    // 

	HRESULT STDMETHODCALLTYPE Event(
        RTC_EVENT enEvent,
        IDispatch * pDisp
        )
    {
        pDisp->AddRef();

        PostMessage( m_hWnd, WM_CORE_EVENT, (WPARAM)enEvent, (LPARAM)pDisp );

        return S_OK;
    }
};

/////////////////////////////////////////////

template <class T>
class CRTCObjectArray
{
private:
    
	T           * m_aT;
	int           m_nSize;
    int           m_nUsed;

public:
	CRTCObjectArray() : m_aT(NULL), m_nSize(0), m_nUsed(0){}

	~CRTCObjectArray()
	{}

	int GetSize() const
	{
		return m_nUsed;
	}
    
	BOOL Add(T& t)
	{
		if(m_nSize == m_nUsed)
		{
			T       * aT;
            int       nNewSize;
                    
			nNewSize = (m_nSize == 0) ? 1 : (m_nSize * 2);
            
			aT = (T*) malloc (nNewSize * sizeof(T));
            
			if(aT == NULL)
            {
				return FALSE;
            }

            CopyMemory(
                       aT,
                       m_aT,
                       m_nUsed * sizeof(T)
                      );

            free( m_aT );

            m_aT = aT;
            
			m_nSize = nNewSize;
		}

        m_aT[m_nUsed] = t;

        if(t)
        {
            t->AddRef();
        }

		m_nUsed++;
        
		return TRUE;
	}
    
	BOOL Remove(T& t)
	{
		int nIndex = Find(t);
        
		if(nIndex == -1)
			return FALSE;
        
		return RemoveAt(nIndex);
	}
    
	BOOL RemoveAt(int nIndex)
	{
        T t = m_aT[nIndex];
        m_aT[nIndex] = NULL;

        if(t)
        {
            t->Release();
        }

        if(nIndex != (m_nUsed - 1))
        {
			MoveMemory(
                       (void*)&m_aT[nIndex],
                       (void*)&m_aT[nIndex + 1],
                       (m_nUsed - (nIndex + 1)) * sizeof(T)
                      );
        }
        

		m_nUsed--;
        
		return TRUE;
	}
    
	void Shutdown()
	{
		if( NULL != m_aT )
		{
            int     index;

            for (index = 0; index < m_nUsed; index++)
            {
                T t = m_aT[index];
                m_aT[index] = NULL;

                if(t)
                {
                    t->Release();
                }
            }

			free(m_aT);
            
			m_aT = NULL;
			m_nUsed = 0;
			m_nSize = 0;
		}
	}
    
	T& operator[] (int nIndex) const
	{
		return m_aT[nIndex];
	}
    
	int Find(T& t) const
	{
		for(int i = 0; i < m_nUsed; i++)
		{
			if(m_aT[i] == t)
				return i;
		}
		return -1;	// not found
	}
};

#endif //__RTCTEST__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\test3\rtctest.cpp ===
#define UNICODE
#include <windows.h>
#include <RTCCore.h>
#include <stdio.h>

#define MAX_XML_LEN 8192

IRTCClient  * g_pClient = NULL;
IRTCClientProvisioning * g_pProv = NULL;

/////////////////////////////////////////////
//
// Main
// 

int _cdecl main(int argc, char* argv[])
{
    WNDCLASS wc;
    HWND     hWnd;
    MSG      msg;
    HRESULT  hr;
    WCHAR    wszFilename[MAX_PATH];    

    if ( argc != 2 )
    {
        printf("Usage: RTCTest <filename>\n");

        return 0;
    }

    //
    // Get the filename
    //

    if ( !MultiByteToWideChar( CP_ACP, 0, argv[1], -1, wszFilename, MAX_PATH ) )
    {
        printf("MultiByteToWideChar failed 0x%lx\n", HRESULT_FROM_WIN32(GetLastError()) );

        return 0;
    }

    HANDLE hFile;
    DWORD  dwBytesRead;
    char   szXML[MAX_XML_LEN];
    WCHAR  wszXML[MAX_XML_LEN];
    BSTR   bstrXML;

    //
    // Read the XML from the file
    //
    
    hFile = CreateFile( wszFilename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        printf("CreateFile failed 0x%lx\n", HRESULT_FROM_WIN32(GetLastError()) );

        return 0;
    }

    if ( !ReadFile( hFile, szXML, MAX_XML_LEN, &dwBytesRead, NULL ) )
    {
        printf("ReadFile failed 0x%lx\n", HRESULT_FROM_WIN32(GetLastError()) );

        CloseHandle( hFile );

        return 0;
    }

    printf("Read file '%ws' %d bytes\n", wszFilename, dwBytesRead);

    CloseHandle( hFile );

    if ( !MultiByteToWideChar( CP_ACP, 0, szXML, dwBytesRead, wszXML, MAX_XML_LEN ) )
    {
        printf("MultiByteToWideChar failed 0x%lx\n", HRESULT_FROM_WIN32(GetLastError()) );

        return 0;
    }

    printf("%ws\n", wszXML);

    //
    // Initialize RTC
    //

    hr =  CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

    if ( FAILED(hr) )
    {
        printf("CoInitializeEx failed 0x%lx\n", hr);

        return 0;
    }

    hr = CoCreateInstance(
                          CLSID_RTCClient,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IRTCClient,
                          (LPVOID *)&g_pClient
                         );

    if ( FAILED(hr) )
    {
        printf("CoCreateInstance failed 0x%lx\n", hr);

        goto exit;
    }

    hr = g_pClient->Initialize();

    if ( FAILED(hr) )
    {
        printf("Initialize failed 0x%lx\n", hr);

        goto exit;
    }

    hr = g_pClient->QueryInterface( IID_IRTCClientProvisioning, (void**)&g_pProv );

    if ( FAILED(hr) )
    {
        printf("QueryInterface failed 0x%lx\n", hr);

        goto exit;
    }

    //
    // Parse the profile
    //

    IRTCProfile * pProfile;

    bstrXML = SysAllocString(wszXML);

    if ( bstrXML == NULL )
    {
        printf("SysAllocString failed\n");

        goto exit;
    }

    hr = g_pProv->CreateProfile( bstrXML, &pProfile );

    SysFreeString( bstrXML );

    if ( FAILED(hr) )
    {
        printf("CreateProfile failed 0x%lx\n", hr);

        goto exit;
    }

    printf("CreateProfile succeeded\n");

    pProfile->Release();   

    //
    // Shutdown
    //

exit:
    
    if ( g_pProv )
    {
        g_pProv->Release();
    }
    
    if ( g_pClient )
    {
        hr = g_pClient->Shutdown();

        if ( FAILED(hr) )
        {
            printf("Shutdown failed 0x%lx\n", hr);
        }

        g_pClient->Release();
    }

    CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\test2\rtctest.cpp ===
#define UNICODE
#include <windows.h>
#include <RTCCore.h>
#include <stdio.h>

#include "RTCTest.h"

IRTCClient  * g_pClient = NULL;
CRTCEvents  * g_pEvents = NULL;
IRTCClientProvisioning * g_pProv = NULL;

/////////////////////////////////////////////
//
// WndProc
// 

LRESULT CALLBACK WndProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HRESULT hr;

    switch ( uMsg )
    {
    case WM_CREATE:
        {
            hr = CoCreateInstance(
                                  CLSID_RTCClient,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IRTCClient,
                                  (LPVOID *)&g_pClient
                                 );

            if ( FAILED(hr) )
            {
                printf("CoCreateInstance failed 0x%lx\n", hr);

                return -1;
            }

            hr = g_pClient->Initialize();

            if ( FAILED(hr) )
            {
                printf("Initialize failed 0x%lx\n", hr);

                return -1;
            }

            hr = g_pClient->put_EventFilter( 
                         RTCEF_REGISTRATION_STATE_CHANGE |
                         RTCEF_CLIENT
                         );

            if ( FAILED(hr) )
            {
                printf("put_EventFilter failed 0x%lx\n", hr);

                return -1;
            }


            g_pEvents = new CRTCEvents;

            hr = g_pEvents->Advise( g_pClient, hWnd );

            if ( FAILED(hr) )
            {
                printf("Advise failed 0x%lx\n", hr);

                return -1;
            }

            hr = g_pClient->QueryInterface( IID_IRTCClientProvisioning, (void**)&g_pProv );

            if ( FAILED(hr) )
            {
                printf("QueryInterface failed 0x%lx\n", hr);

                return -1;
            }

            IRTCProfile * pProfile;

            BSTR bstrXML = SysAllocString( L"<provision key=\"amun1\" name=\"Amun\"><provider name=\"Amun\" homepage=\"http://winrtc/phoenix\"><data>test</data></provider><client name=\"Phoenix\" banner=\"false\"/><user uri=\"sip:rtctest@microsoft.com\"/><accesscontrol domain=\"ntdev.microsoft.com\" sig=\"43r8mXTFvSMBZHajABKbd5ee1vHXUDqJIUxhsmtF67UZZryIolEdp/1qs2oiTKbKrAlAsIzOoCL75lTzZSbacA==\" /><sipsrv addr=\"amun1.ntdev.microsoft.com\" protocol=\"udp\" role=\"registrar\"/><sipsrv addr=\"amun1.ntdev.microsoft.com\" protocol=\"udp\" role=\"proxy\"><session party=\"first\" type=\"pc2pc\"/><session party=\"first\" type=\"pc2ph\"/><session party=\"first\" type=\"im\"/></sipsrv></provision>" );
 
            hr = g_pProv->CreateProfile( bstrXML, &pProfile );

            printf("Adding profile 1...[%p]\n", pProfile);

            SysFreeString( bstrXML );

            if ( FAILED(hr) )
            {
                printf("CreateProfile failed 0x%lx\n", hr);

                return -1;
            }

            hr = g_pProv->EnableProfile( pProfile, RTCRF_REGISTER_ALL );

            if ( FAILED(hr) )
            {
                printf("EnableProfile failed 0x%lx\n", hr);

                return -1;
            }

            pProfile->Release();      

            SetTimer( hWnd, TID_TIMER1, 3000, NULL );
    
            return 0;
        }

    case WM_DESTROY:        
        {
            printf("Exiting...\n");

            if ( g_pEvents )
            {
                hr = g_pEvents->Unadvise( g_pClient );

                if ( FAILED(hr) )
                {
                    printf("Unadvise failed 0x%lx\n", hr);
                }

                g_pEvents = NULL;
            }

            if ( g_pProv )
            {
                g_pProv->Release();
                g_pProv = NULL;
            }
            
            if ( g_pClient )
            {
                hr = g_pClient->Shutdown();

                if ( FAILED(hr) )
                {
                    printf("Shutdown failed 0x%lx\n", hr);
                }

                g_pClient->Release();
                g_pClient = NULL;
            }

            PostQuitMessage(0);

            return 0;
        }

    case WM_TIMER:
        {
            switch ( wParam )
            {
            case TID_TIMER1:
                {
                    KillTimer( hWnd, TID_TIMER1 );

                    IRTCProfile * pProfile;

                    BSTR bstrXML = SysAllocString( L"<provision key=\"amun1\" name=\"Amun\"><provider name=\"Amun\" homepage=\"http://winrtc/phoenix\"><data>test</data></provider><client name=\"Phoenix\" banner=\"false\"/><user uri=\"sip:rtctest@microsoft.com\"/><accesscontrol domain=\"ntdev.microsoft.com\" sig=\"43r8mXTFvSMBZHajABKbd5ee1vHXUDqJIUxhsmtF67UZZryIolEdp/1qs2oiTKbKrAlAsIzOoCL75lTzZSbacA==\" /><sipsrv addr=\"amun1.ntdev.microsoft.com\" protocol=\"udp\" role=\"registrar\"/><sipsrv addr=\"amun1.ntdev.microsoft.com\" protocol=\"udp\" role=\"proxy\"><session party=\"first\" type=\"pc2pc\"/><session party=\"first\" type=\"pc2ph\"/><session party=\"first\" type=\"im\"/></sipsrv></provision>" );
                    
                    hr = g_pProv->CreateProfile( bstrXML, &pProfile );

                    printf("Replacing profile 1...[%p]\n", pProfile);

                    SysFreeString( bstrXML );

                    if ( FAILED(hr) )
                    {
                        printf("CreateProfile failed 0x%lx\n", hr);

                        return 0;
                    }

                    hr = g_pProv->EnableProfile( pProfile, RTCRF_REGISTER_ALL );

                    if ( FAILED(hr) )
                    {
                        printf("EnableProfile failed 0x%lx\n", hr);

                        return 0;
                    }

                    pProfile->Release();      

                    SetTimer( hWnd, TID_TIMER2, 3000, NULL );
                }
                break;

            case TID_TIMER2:
                {
                    KillTimer( hWnd, TID_TIMER2 );                    

                    IRTCProfile * pProfile;

                    BSTR bstrXML = SysAllocString( L"<provision key=\"amun2\" name=\"Amun\"><provider name=\"Amun\" homepage=\"http://winrtc/phoenix\"><data>test</data></provider><client name=\"Phoenix\" banner=\"false\"/><user uri=\"sip:rtctest@microsoft.com\"/><accesscontrol domain=\"ntdev.microsoft.com\" sig=\"43r8mXTFvSMBZHajABKbd5ee1vHXUDqJIUxhsmtF67UZZryIolEdp/1qs2oiTKbKrAlAsIzOoCL75lTzZSbacA==\" /><sipsrv addr=\"amun1.ntdev.microsoft.com\" protocol=\"udp\" role=\"registrar\"/><sipsrv addr=\"amun1.ntdev.microsoft.com\" protocol=\"udp\" role=\"proxy\"><session party=\"first\" type=\"pc2pc\"/><session party=\"first\" type=\"pc2ph\"/><session party=\"first\" type=\"im\"/></sipsrv></provision>" );
                    
                    hr = g_pProv->CreateProfile( bstrXML, &pProfile );

                    printf("Adding profile 2 [don't register]...[%p]\n", pProfile);

                    SysFreeString( bstrXML );

                    if ( FAILED(hr) )
                    {
                        printf("CreateProfile failed 0x%lx\n", hr);

                        return 0;
                    }

                    hr = g_pProv->EnableProfile( pProfile, 0 );

                    if ( FAILED(hr) )
                    {
                        printf("EnableProfile failed 0x%lx\n", hr);

                        return 0;
                    }

                    pProfile->Release();      

                    SetTimer( hWnd, TID_TIMER3, 3000, NULL );
                }
                break;

            case TID_TIMER3:
                {
                    KillTimer( hWnd, TID_TIMER3 );                    

                    IRTCProfile * pProfile;

                    BSTR bstrXML = SysAllocString( L"<provision key=\"amun3\" name=\"Amun\"><provider name=\"Amun\" homepage=\"http://winrtc/phoenix\"><data>test</data></provider><client name=\"Phoenix\" banner=\"false\"/><user uri=\"sip:rtctest@microsoft.com\"/><accesscontrol domain=\"ntdev.microsoft.com\" sig=\"43r8mXTFvSMBZHajABKbd5ee1vHXUDqJIUxhsmtF67UZZryIolEdp/1qs2oiTKbKrAlAsIzOoCL75lTzZSbacA==\" /><sipsrv addr=\"amun1.ntdev.microsoft.com\" protocol=\"udp\" role=\"registrar\"/><sipsrv addr=\"amun1.ntdev.microsoft.com\" protocol=\"udp\" role=\"proxy\"><session party=\"first\" type=\"pc2pc\"/><session party=\"first\" type=\"pc2ph\"/><session party=\"first\" type=\"im\"/></sipsrv></provision>" );
                    
                    hr = g_pProv->CreateProfile( bstrXML, &pProfile );

                    printf("Adding profile 3...[%p]\n", pProfile);

                    SysFreeString( bstrXML );

                    if ( FAILED(hr) )
                    {
                        printf("CreateProfile failed 0x%lx\n", hr);

                        return 0;
                    }

                    hr = g_pProv->EnableProfile( pProfile, RTCRF_REGISTER_ALL );

                    if ( FAILED(hr) )
                    {
                        printf("EnableProfile failed 0x%lx\n", hr);

                        return 0;
                    }

                    pProfile->Release();      

                    SetTimer( hWnd, TID_TIMER4, 3000, NULL );
                }
                break;

            case TID_TIMER4:
                {
                    KillTimer( hWnd, TID_TIMER4 );

                    printf("Removing profile 1...\n");

                    IRTCEnumProfiles * pEnum;

                    hr = g_pProv->EnumerateProfiles( &pEnum );

                    if ( FAILED(hr) )
                    {
                        printf("EnumerateProfiles failed 0x%lx\n", hr);

                        return 0;
                    }

                    IRTCProfile * pProfile;
                    
                    hr = pEnum->Next( 1, &pProfile, NULL );

                    pEnum->Release();

                    if ( FAILED(hr) )
                    {
                        printf("Next failed 0x%lx\n", hr);

                        return 0;
                    }

                    hr = g_pProv->DisableProfile( pProfile );

                    pProfile->Release();

                    if ( FAILED(hr) )
                    {
                        printf("DisableProfile failed 0x%lx\n", hr);

                        return 0;
                    }

                    SetTimer( hWnd, TID_TIMER5, 3000, NULL );
                }
                break;

            case TID_TIMER5:
                {
                    KillTimer( hWnd, TID_TIMER5 );

                    printf("Shuting down...\n");

                    hr = g_pClient->PrepareForShutdown();

                    if ( FAILED(hr) )
                    {
                        printf("PrepareForShutdown failed 0x%lx\n", hr);
                    }
                }
                break;
            }

            return 0;
        }

    case WM_CORE_EVENT:
        {
            switch ( wParam )
            {
                case RTCE_REGISTRATION_STATE_CHANGE:
                    {
                        IRTCRegistrationStateChangeEvent * pRSC;
                        IRTCProfile                      * pProfile;
                        RTC_REGISTRATION_STATE             enRS;
                        IDispatch                        * pDisp;
                
                        pDisp = (IDispatch *)lParam;

                        pDisp->QueryInterface( IID_IRTCRegistrationStateChangeEvent,
                                               (void **)&pRSC
                                             );

                        pDisp->Release();
                                       
                        hr = pRSC->get_State(&enRS);

                        if ( FAILED(hr) )
                        {
                            printf("get_State failed 0x%lx\n", hr);

                            pRSC->Release();
                            return 0;
                        }

                        hr = pRSC->get_Profile(&pProfile);

                        if ( FAILED(hr) )
                        {
                            printf("get_Profile failed 0x%lx\n", hr);

                            pRSC->Release();
                            return 0;
                        }

                        switch(enRS)
                        {
                            case RTCRS_NOT_REGISTERED:
                                printf("RTCRS_NOT_REGISTERED [0x%lx]\n", pProfile);
                                break;

                            case RTCRS_REGISTERING:
                                printf("RTCRS_REGISTERING [0x%lx]\n", pProfile);
                                break;

                            case RTCRS_REGISTERED:
                                printf("RTCRS_REGISTERED [0x%lx]\n", pProfile);
                                break;

                            case RTCRS_REJECTED:
                                printf("RTCRS_REJECTED [0x%lx]\n", pProfile);
                                break;

                            case RTCRS_UNREGISTERING:
                                printf("RTCRS_UNREGISTERING [0x%lx]\n", pProfile);
                                break;

                            case RTCRS_ERROR:
                                printf("RTCRS_ERROR [0x%lx]\n", pProfile);
                                break;
                        }

                        pRSC->Release();
                        pProfile->Release();
                    }            
                    break;            
                    
                case RTCE_CLIENT:
                    {
                        IRTCClientEvent       * pC;
                        IDispatch             * pDisp;
                        RTC_CLIENT_EVENT_TYPE	enEventType; 
                
                        pDisp = (IDispatch *)lParam;

                        pDisp->QueryInterface( IID_IRTCClientEvent,
                                               (void **)&pC
                                             );

                        pDisp->Release();
                                       
                        hr = pC->get_EventType(&enEventType);

                        if ( FAILED(hr) )
                        {
                            printf("get_EventType failed 0x%lx\n", hr);

                            pC->Release();
                            return 0;
                        }

                        if ( enEventType == RTCCET_ASYNC_CLEANUP_DONE )
                        {
                            DestroyWindow(hWnd);
                        }
                        
                        pC->Release();
                    }            
                    break; 
            }

            return 0;
        }

    default:
        return DefWindowProc( hWnd, uMsg, wParam, lParam );
    }

    return 0;
}

/////////////////////////////////////////////
//
// Main
// 

int _cdecl main(int argc, char* argv[])
{
    WNDCLASS wc;
    HWND     hWnd;
    MSG      msg;
    HRESULT  hr;

    hr =  CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

    if ( FAILED(hr) )
    {
        printf("CoInitializeEx failed 0x%lx\n", hr);

        return 0;
    }
    
    ZeroMemory(&wc, sizeof(WNDCLASS));

    wc.lpfnWndProc = WndProc;
    wc.hInstance = GetModuleHandle(NULL);
    wc.lpszClassName = TEXT("RTCTestClass");
    
    if ( !RegisterClass( &wc ) )
    {
        printf("RegisterClass failed 0x%lx\n", HRESULT_FROM_WIN32(GetLastError()));

        return 0;
    }
    
    hWnd = CreateWindow(
            TEXT("RTCTestClass"),
            TEXT("RTCTest"),
            WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            NULL,
            NULL,
            GetModuleHandle(NULL),
            NULL
            );

    if ( hWnd == NULL )
    {
        printf("CreateWindow failed 0x%lx\n", HRESULT_FROM_WIN32(GetLastError()));

        return 0;
    }           

    while ( GetMessage( &msg, NULL, 0, 0 ) > 0 )
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }

    CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\dll\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\test4\rtctest.h ===
#ifndef __RTCTEST__
#define __RTCTEST__

#define WM_CORE_EVENT      WM_USER+100
#define WM_CREATE_SESSION  WM_USER+101
#define WM_LISTEN          WM_USER+102
#define WM_CREATE_PROFILE  WM_USER+103

#define TID_CALL_TIMER     100

class CRTCEvents :
	public IRTCEventNotification
{
private:
    DWORD m_dwRefCount;
    DWORD m_dwCookie;
    HWND  m_hWnd;

public:
    CRTCEvents() : m_dwRefCount(NULL),
                   m_dwCookie(NULL),
                   m_hWnd(NULL)
    {
    }

    /////////////////////////////////////////////
    //
    // QueryInterface
    // 

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppvObject)
    {
        if (iid == IID_IRTCEventNotification)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        if (iid == IID_IUnknown)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        return E_NOINTERFACE;
    }

    /////////////////////////////////////////////
    //
    // AddRef
    // 

	ULONG STDMETHODCALLTYPE AddRef()
    {
        m_dwRefCount++;
        return m_dwRefCount;
    }
    
    /////////////////////////////////////////////
    //
    // Release
    // 

	ULONG STDMETHODCALLTYPE Release()
    {
        m_dwRefCount--;

        if ( 0 == m_dwRefCount)
        {
            delete this;
        }

        return 1;
    }

    /////////////////////////////////////////////
    //
    // Advise
    // 

    HRESULT Advise(IRTCClient * pClient, HWND hWnd)
    {    
	    IConnectionPointContainer * pCPC;
	    IConnectionPoint * pCP;

	    HRESULT hr = pClient->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);

	    if (SUCCEEDED(hr))
        {
		    hr = pCPC->FindConnectionPoint(IID_IRTCEventNotification, &pCP);

            pCPC->Release();

            if (SUCCEEDED(hr))
            {
		        hr = pCP->Advise(this, &m_dwCookie);

                pCP->Release();
            }
        }

        m_hWnd = hWnd;

	    return hr;
    }

    /////////////////////////////////////////////
    //
    // Unadvise
    // 

    HRESULT Unadvise(IRTCClient * pClient)
    {
	    IConnectionPointContainer * pCPC;
	    IConnectionPoint * pCP;

	    HRESULT hr = pClient->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);

	    if (SUCCEEDED(hr))
        {
		    hr = pCPC->FindConnectionPoint(IID_IRTCEventNotification, &pCP);

            pCPC->Release();

            if (SUCCEEDED(hr))
            {
		        hr = pCP->Unadvise(m_dwCookie);

                pCP->Release();
            }
        }

	    return hr;
    }

    /////////////////////////////////////////////
    //
    // Event
    // 

	HRESULT STDMETHODCALLTYPE Event(
        RTC_EVENT enEvent,
        IDispatch * pDisp
        )
    {
        pDisp->AddRef();

        PostMessage( m_hWnd, WM_CORE_EVENT, (WPARAM)enEvent, (LPARAM)pDisp );

        return S_OK;
    }
};

#endif //__RTCTEST__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\dll\makefile.inc ===
$(O)\rtcerrlocal.mc: $(PROJECT_ROOT)\published\inc\rtcerr.mc
    -copy /v $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\rtc\phoenix\src\core\test4\rtctest.cpp ===
#define UNICODE
#include <windows.h>
#include <RTCCore.h>
#include <rtcerr.h>
#include <stdio.h>

#include "RTCTest.h"

IRTCClient  * g_pClient = NULL;
IRTCSession * g_pSession = NULL;
IRTCProfile * g_pProfile = NULL;
CRTCEvents  * g_pEvents = NULL;

/////////////////////////////////////////////
//
// WndProc
// 

LRESULT CALLBACK WndProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HRESULT hr;

    switch ( uMsg )
    {
    case WM_CREATE:
        {
            hr = CoCreateInstance(
                                  CLSID_RTCClient,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IRTCClient,
                                  (LPVOID *)&g_pClient
                                 );

            if ( FAILED(hr) )
            {
                printf("CoCreateInstance failed 0x%lx\n", hr);

                return -1;
            }

            hr = g_pClient->Initialize();

            if ( FAILED(hr) )
            {
                printf("Initialize failed 0x%lx\n", hr);

                return -1;
            }

            hr = g_pClient->SetPreferredMediaTypes( 
                         RTCMT_AUDIO_SEND |
                         RTCMT_AUDIO_RECEIVE |
                         RTCMT_VIDEO_SEND |
                         RTCMT_VIDEO_RECEIVE,
                         VARIANT_FALSE
                         );

            if ( FAILED(hr) )
            {
                printf("SetPreferredMediaTypes failed 0x%lx\n", hr);

                return -1;
            }

            hr = g_pClient->put_EventFilter( 
                         RTCEF_SESSION_STATE_CHANGE |
                         