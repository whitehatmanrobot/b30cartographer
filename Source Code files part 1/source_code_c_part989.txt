=================

    hRes = CRepository::GetObject(
             m_pSession,
             m_pNsHandle,
             pszClassName,
             0,
             &pStaticClassDef
             );

    CReleaseMe _1(pStaticClassDef);

    if (SUCCEEDED(hRes))
    {
        bInRepository = TRUE;
        if (!Allowed(WBEM_FULL_WRITE_REP))
            return pSink->Return(WBEM_E_ACCESS_DENIED);
        if (pStaticClassDef == 0)
            return pSink->Return(WBEM_E_CRITICAL_ERROR);
    }

    // Build up a synchronous sink to receive the class.
    // =================================================

    pSyncSink = new CSynchronousSink;
    if (pSyncSink == NULL)
        return pSink->Return(WBEM_E_OUT_OF_MEMORY);
    pSyncSink->AddRef();
    CReleaseMe _3(pSyncSink);

    // Try to get it.
    // ==============

    bstrClass = SysAllocString(pszClassName);
    if (bstrClass == 0)
        return pSink->Return(WBEM_E_OUT_OF_MEMORY);

    // If the class was in the repository, we are merely advising dynamic
    // class providers that the class is going away.
    // ==================================================================

    if (bInRepository)
        lFlags |= WBEM_FLAG_ADVISORY;
    else
    {
        if (!Allowed(WBEM_WRITE_PROVIDER))
            return pSink->Return(WBEM_E_ACCESS_DENIED);
    }

    try
    {
        hRes = pClassProv->DeleteClassAsync(bstrClass, lFlags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS, pCtx, pSyncSink);
    }
    catch(...)
    {
        ExceptionCounter c;    
        hRes = WBEM_E_CRITICAL_ERROR;
    }

    SysFreeString(bstrClass);

    if (FAILED(hRes) && hRes != WBEM_E_NOT_FOUND)
        return pSink->Return(hRes);

    pSyncSink->Block();
    pSyncSink->GetStatus(&hRes, NULL, &pErrorObj);

    if (FAILED(hRes))
    {
        pSink->Return(hRes, pErrorObj);
        if (pErrorObj)
            pErrorObj->Release();
        return hRes;
    }

    // If here, we can go ahead with it.
    // =================================

    if (pHook)
        pHook->PreDelete(WBEM_FLAG_CLASS_DELETE, lFlags, pCtx, NULL,
                                       m_pThisNamespace, pszClassName );

    if (bInRepository)
        hRes = CRepository::DeleteByPath(m_pSession, m_pNsHandle, pszClassName, 0);

    if (pHook)
        pHook->PostDelete(WBEM_FLAG_CLASS_DELETE, hRes, pCtx, NULL, m_pThisNamespace, pszClassName, NULL);

    return pSink->Return(hRes);
}


//***************************************************************************
//
//  CWbemNamespace::Exec_CreateClassEnum
//
//***************************************************************************

HRESULT CWbemNamespace::Exec_CreateClassEnum(
    LPWSTR pszSuperclass,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pCallerSink
    )
{
    HRESULT hRes;
    IWbemClassObject* pErrorObj = 0;
    IWbemServices *pClassProv = 0;
    CSynchronousSink* pSyncSink = 0;
    BSTR bstrClass = 0;
    IWbemClassObject* pResultObj = 0;
    CCombiningSink* pCombiningSink = NULL;
    CLocaleMergingSink * pLocaleSink = NULL;
    CBasicObjectSink  *pTmp = 0;
    BSTR bstrSuperclass = 0;
    bool bProvSSNotFound = false;
    bool bRepNotFound = false;

    // Quick check of parms.
    // =====================

    if (pCallerSink == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (pszSuperclass == 0)     // Ensure we point to a blank instead of NULL with no superclass
        pszSuperclass = L"";
    else
      {
      if (illFormatedClass2 (pszSuperclass))
        return pCallerSink->Return(WBEM_E_INVALID_CLASS);
      }


    // Prepare some sinks to hold everything.
    // ======================================

    if ((lFlags & WBEM_FLAG_USE_AMENDED_QUALIFIERS))
    {
        pLocaleSink = new CLocaleMergingSink(pCallerSink, m_wsLocale, m_pThisNamespace);
        if (pLocaleSink == NULL)
            return pCallerSink->Return(WBEM_E_OUT_OF_MEMORY);
        pLocaleSink->AddRef();
        pTmp = pLocaleSink;
    }
    else
        pTmp = pCallerSink;
    CReleaseMe _1(pLocaleSink);

    pCombiningSink = new CCombiningSink(pTmp);
    CReleaseMe _2(pCombiningSink);

    if (!pCombiningSink)
        return pCallerSink->Return(WBEM_E_OUT_OF_MEMORY);

    pCombiningSink->AddRef();

    // Bring up the dynamic class provider symposium for consultation.
    // ===============================================================

    if ( !m_bRepositOnly && m_pProvFact)
    {

        hRes = m_pProvFact->GetClassProvider(
                    0,                  // lFlags
                    pCtx,
                    m_wszUserName,
                    m_wsLocale,
                    m_pThisNamespace,                     // IWbemPath pointer
                    0,
                    IID_IWbemServices,
                    (LPVOID *) &pClassProv
                    );

        if (FAILED(hRes))
            return pCombiningSink->Return(hRes);
    }

    CReleaseMe _3(pClassProv);

    // Get the repository classes.
    // ===========================

    BOOL bUseStatic = !(lFlags & WBEM_FLAG_NO_STATIC);
    if (bUseStatic)
    {
        if ((lFlags & WBEM_MASK_DEPTH) == WBEM_FLAG_DEEP)
        {
            // DEEP ENUM
            // ==========
            IWbemObjectSink *pObjSink = (IWbemObjectSink *) pCombiningSink;
            hRes = CRepository::QueryClasses(
                        m_pSession,
                        m_pNsHandle,
                        WBEM_FLAG_DEEP | WBEM_FLAG_VALIDATE_CLASS_EXISTENCE,
                        pszSuperclass,
                        pObjSink
                        );
        }
        else
        {
            // SHALLOW ENUM
            // =============
            IWbemObjectSink *pObjSink = (IWbemObjectSink *) pCombiningSink;
            hRes = CRepository::QueryClasses(
                        m_pSession,
                        m_pNsHandle,
                        WBEM_FLAG_SHALLOW | WBEM_FLAG_VALIDATE_CLASS_EXISTENCE,
                        pszSuperclass,
                        pObjSink
                        );
        }

        //If a SetStatus of INVALID_CLASS was indicated it means there is no static
        //class, however we need to continue on with dynamic classes, so we need
        //to clear the error.
        if ((pCombiningSink->GetHResult() == WBEM_E_NOT_FOUND) || (hRes == WBEM_E_NOT_FOUND))
        {
            bRepNotFound = true;
            pCombiningSink->ClearHResult();
            hRes = WBEM_S_NO_ERROR;
        }

        if (FAILED(hRes))
        {
            // A real failure.  Give up.
            // =========================
            return pCombiningSink->Return(hRes);
        }
    }

    if (m_bRepositOnly || m_pProvFact == NULL)
        return pCombiningSink->Return(WBEM_S_NO_ERROR);

    // If here, we have to merge in the dynamic classes.
    // =================================================
    // Build up a synchronous sink to receive the classes.
    // ===================================================

    pSyncSink = new CSynchronousSink;
    if (pSyncSink == NULL)
        return pCallerSink->Return(WBEM_E_OUT_OF_MEMORY);
    pSyncSink->AddRef();
    CReleaseMe _4(pSyncSink);

    // Try to get it.
    // ==============

    bstrSuperclass = SysAllocString(pszSuperclass);
    if (bstrSuperclass == 0)
        return pCallerSink->Return(WBEM_E_OUT_OF_MEMORY);
    CSysFreeMe sfm99(bstrSuperclass);

    try
    {
        CDecoratingSink * pDecore = new CDecoratingSink(pSyncSink, this);
        if(pDecore == NULL)
            return pCallerSink->Return(WBEM_E_OUT_OF_MEMORY);
        pDecore->AddRef();
        CReleaseMe cdecor(pDecore);
        hRes = pClassProv->CreateClassEnumAsync(bstrSuperclass, (lFlags & (~WBEM_FLAG_USE_AMENDED_QUALIFIERS)) & ~WBEM_FLAG_NO_STATIC, pCtx, pDecore);
        if ((pSyncSink->GetHResult() == WBEM_E_NOT_FOUND) || (hRes == WBEM_E_NOT_FOUND))
        {
            bProvSSNotFound = true;
            pSyncSink->ClearHResult();
            hRes = WBEM_S_NO_ERROR;
        }
    }
    catch(...)
    {
        ExceptionCounter c;    
        hRes = WBEM_E_CRITICAL_ERROR;
    }

    if (bProvSSNotFound && bRepNotFound)
    {
        //Neither the provider subsystem nor the repository found this object,
        //therefore we need to actually return an error!
        return pCombiningSink->Return(WBEM_E_INVALID_CLASS);
    }

    if (FAILED(hRes) && hRes != WBEM_E_NOT_FOUND)
        return pCombiningSink->Return(hRes);

    pSyncSink->Block();
    pSyncSink->GetStatus(&hRes, NULL, &pErrorObj);

    if (FAILED(hRes))
    {
        pCombiningSink->Return(hRes, pErrorObj);
        if (pErrorObj)
            pErrorObj->Release();
        return hRes;
    }

    // Otherwise, somebody claimed to have supplied some classes.  Add them into to the
    // combining sink.
    // =================================================================================

    CRefedPointerArray<IWbemClassObject>& raObjects = pSyncSink->GetObjects();

    for (int i = 0; i < raObjects.GetSize(); i++)
    {
        IWbemClassObject *pClsDef = (IWbemClassObject *) raObjects[i];
        pCombiningSink->Indicate(1, &pClsDef);
    }

    return pCombiningSink->Return(WBEM_S_NO_ERROR);
}


//***************************************************************************
//
//***************************************************************************
//
BOOL CWbemNamespace::IsDerivableClass(LPCWSTR wszClassName, CWbemClass* pClass)
{
    // Check if it is a system class
    // =============================

    if (wszClassName == NULL || wszClassName[0] != L'_')
        return TRUE;

    if(!wbem_wcsicmp(wszClassName, L"__EventConsumer") ||
       !wbem_wcsicmp(wszClassName, L"__ExtrinsicEvent") ||
       !wbem_wcsicmp(wszClassName, L"__ExtendedStatus") ||
       !wbem_wcsicmp(wszClassName, L"__Win32Provider") ||
       !wbem_wcsicmp(wszClassName, L"__Namespace"))
    {
        return TRUE;
    }

    return FALSE;
}

//***************************************************************************
//
//  CWbemNamespace::Exec_PutClass
//
//***************************************************************************

HRESULT CWbemNamespace::Exec_PutClass(
    READONLY IWbemClassObject* pObj,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pSink,
    BOOL fIsInternal
    )
{
    HRESULT hRes;
    IWbemClassObject* pErrorObj = 0;
    IWbemServices *pClassProv = 0;
    CSynchronousSink* pSyncSink = 0;
    BSTR bstrClass = 0;
    IWbemClassObject* pStaticClassDef = 0;
    BOOL bInRepository = FALSE;

    // Maintains old functionality
    long lRealFlags = lFlags;
//  lFlags = 0L;            // commented out by a-shawnb

    if (pSink == 0)
        return WBEM_E_INVALID_PARAMETER;

    // Extract the class name.
    // =======================
    CVARIANT v;
    if ( pObj )
    {
        hRes = pObj->Get(L"__CLASS", 0, &v, 0, 0);
        if (FAILED(hRes))
            return pSink->Return(hRes);
    }

    //
    
    //
    COperationError OpInfo(pSink, L"PutClass", v.GetStr());

    if (pObj == 0)
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_PARAMETER);

    _IWmiObject * pIntObj = NULL;
    hRes = pObj->QueryInterface(IID__IWmiObject,(void **)&pIntObj);
    CReleaseMe rm1(pIntObj);
    if (SUCCEEDED(hRes))
    {
        if (WBEM_S_NO_ERROR == pIntObj->IsObjectInstance())
            return  OpInfo.ErrorOccurred(WBEM_E_INVALID_OPERATION);
    }


    CVARIANT v2;
    hRes = pObj->Get(L"__SuperClass", 0, &v2, 0, 0);
    if (FAILED(hRes))
        return OpInfo.ErrorOccurred(hRes);

    if (v2.GetStr() && wcslen(v2.GetStr()))
    {
        if (CSystemProperties::IsIllegalDerivedClass(v2.GetStr()))
            return OpInfo.ErrorOccurred(WBEM_E_INVALID_SUPERCLASS);
    }

    if (!fIsInternal )
    {
        if ((v.GetStr() == NULL) || (v.GetStr()[0] == '_'))
            return OpInfo.ErrorOccurred(WBEM_E_INVALID_OPERATION);
        if (v.GetStr()[wcslen(v.GetStr())-1] == '_')
            return OpInfo.ErrorOccurred(WBEM_E_INVALID_OBJECT);
    }

    if ( !m_bRepositOnly && !fIsInternal && m_pProvFact )
    {
        // Bring up the dynamic class provider symposium for consultation.
        // ===============================================================

        hRes = m_pProvFact->GetClassProvider(
                    0,                  // lFlags
                    pCtx,
                    m_wszUserName,
                    m_wsLocale,
                    m_pThisNamespace,                     // IWbemPath pointer
                    0,
                    IID_IWbemServices,
                    (LPVOID *) &pClassProv
                    );

        if (FAILED(hRes))
            return OpInfo.ErrorOccurred(hRes);
    }

    CReleaseMe _2(pClassProv);

    // Set up a new per-task hook.
    // ===========================

    _IWmiCoreWriteHook *pHook = 0;
    hRes = m_pCoreSvc->NewPerTaskHook(&pHook);
    if (FAILED(hRes))
        return OpInfo.ErrorOccurred(hRes);
    CReleaseMe _(pHook);
    HRESULT hHookResult = 0;


    // First, try repository.
    // ======================

    if (m_bRepositOnly || fIsInternal || m_pProvFact == NULL)
    {
        if (!Allowed(WBEM_FULL_WRITE_REP))
            return OpInfo.ErrorOccurred(WBEM_E_ACCESS_DENIED);

        if (pHook)
        {
            pHook->PrePut(WBEM_FLAG_CLASS_PUT, lFlags, pCtx, 0,
                          m_pThisNamespace, v.GetStr(), (_IWmiObject *)pObj);
        }


        hRes = CRepository::PutObject(m_pSession, m_pNsHandle, IID_IWbemClassObject, pObj, lFlags);

        if (pHook)
        {
            pHook->PostPut(WBEM_FLAG_CLASS_PUT, hRes, pCtx, 0, m_pThisNamespace, v.GetStr() , (_IWmiObject *)pObj, NULL);
        }


        return OpInfo.ErrorOccurred(hRes);
    }

    hRes = CRepository::GetObject(
             m_pSession,
             m_pNsHandle,
             v.GetStr(),
             0,
             &pStaticClassDef
             );

    CReleaseMe _1(pStaticClassDef);

    if (SUCCEEDED(hRes))
    {
        bInRepository = TRUE;

        if (pStaticClassDef != 0)
		{
			// Remove all the amended qualifiers
			// =================================

			if (lFlags & WBEM_FLAG_USE_AMENDED_QUALIFIERS )
			{
				int nRes = SplitLocalized( (CWbemObject*) pObj, (CWbemObject*) pStaticClassDef );
				if (FAILED(nRes))
				{
					return pSink->Return(nRes);
				}
			}
		}
		else
		{
            return OpInfo.ErrorOccurred(WBEM_E_CRITICAL_ERROR);
		}
    }

    // Build up a synchronous sink to receive the class.
    // =================================================

    pSyncSink = new CSynchronousSink;
    if (pSyncSink == NULL)
        return OpInfo.ErrorOccurred(WBEM_E_OUT_OF_MEMORY);
    pSyncSink->AddRef();
    CReleaseMe _3(pSyncSink);

    // Try to put it.
    // ==============

    // If the class was in the repository, we are merely advising dynamic
    // class providers that the class is going away.
    // ==================================================================

    if (bInRepository)
        lFlags |= WBEM_FLAG_ADVISORY;

    try
    {
        if (!Allowed(WBEM_WRITE_PROVIDER))
            hRes = WBEM_E_ACCESS_DENIED;
        else
            hRes = pClassProv->PutClassAsync(pObj, lFlags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS, pCtx, pSyncSink);
    }
    catch(...)
    {
        ExceptionCounter c;    
        hRes = WBEM_E_CRITICAL_ERROR;
    }

    if (FAILED(hRes) && hRes != WBEM_E_NOT_FOUND)
        return OpInfo.ErrorOccurred(hRes);

    pSyncSink->Block();
    pSyncSink->GetStatus(&hRes, NULL, &pErrorObj);

    if (SUCCEEDED(hRes)&&(!bInRepository))
    {
        pSink->Return(hRes, pErrorObj);
        if (pErrorObj)
            pErrorObj->Release();
        return hRes;
    }

    if (FAILED(hRes) && hRes != WBEM_E_NOT_FOUND)
    {
        pSink->Return(hRes, pErrorObj);
        if (pErrorObj)
            pErrorObj->Release();
        return hRes;
    }

    // If here, we can go ahead with it.
    // =================================

    if (!Allowed(WBEM_FULL_WRITE_REP))
        return OpInfo.ErrorOccurred(WBEM_E_ACCESS_DENIED);

    if (pHook)
    {
        pHook->PrePut(WBEM_FLAG_CLASS_PUT, lFlags, pCtx, 0,
                      m_pThisNamespace, v.GetStr(), (_IWmiObject *)pObj);
    }

    hRes = CRepository::PutObject(m_pSession, m_pNsHandle, IID_IWbemClassObject, pObj, lFlags);

    // Workaround for forceupdate and instances problem
    if ( WBEM_E_CLASS_HAS_INSTANCES == hRes && ( lRealFlags & WBEM_FLAG_UPDATE_FORCE_MODE ) )
    {
        VARIANT v;

        VariantInit( &v );
        hRes = pObj->Get( L"__CLASS", 0L, &v, NULL, NULL );

        if ( SUCCEEDED( hRes ) && V_VT( &v ) == VT_BSTR )
        {

            hRes = DeleteObject( V_BSTR( &v ), 0L, pCtx, NULL );

            if ( SUCCEEDED( hRes ) )
            {
                hRes = CRepository::PutObject(m_pSession, m_pNsHandle, IID_IWbemClassObject, pObj, lFlags);
            }

            VariantClear( &v );
        }
        else
        {
            hRes = WBEM_E_CLASS_HAS_INSTANCES;
        }
    }

    if (pHook)
    {
        pHook->PostPut(WBEM_FLAG_CLASS_PUT, hRes, pCtx, 0, m_pThisNamespace, v.GetStr() , (_IWmiObject *)pObj, NULL);
    }


    return OpInfo.ErrorOccurred(hRes);
}


//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::Exec_CancelAsyncCall(
    IWbemObjectSink* pSink
    )
{

    _IWmiArbitrator *pArb = CWmiArbitrator::GetUnrefedArbitrator();
    HRESULT hRes = pArb->CancelTasksBySink(0, IID_IWbemObjectSink, pSink);
    return hRes;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::Exec_CancelProvAsyncCall(
    IWbemServices* pProv, IWbemObjectSink* pSink
    )
{
	// Call to the actual provider
    HRESULT hRes = pProv->CancelAsyncCall( pSink );
    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//

bool IsSetupRunning()
{
    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                    L"system\\Setup",
                    0, KEY_READ, &hKey);
    if(lRes)
        return false;

    DWORD dwSetupRunning;
    DWORD dwLen = sizeof(DWORD);
    lRes = RegQueryValueExW(hKey, L"SystemSetupInProgress", NULL, NULL,
                (LPBYTE)&dwSetupRunning, &dwLen);
    RegCloseKey(hKey);

    if(lRes == ERROR_SUCCESS && (dwSetupRunning == 1))
    {
        return true;
    }
    return false;
}

//***************************************************************************
//
//  CWbemNamespace::Exec_PutInstance
//
//  Actually stores the instance in the database. If the class is dynamic, the
//  call is propagated to the provider.
//  Raises instance creation or modification event.
//
//  Parameters and return values are exacly the same as those for PutInstance
//  as described in help
//
//***************************************************************************

HRESULT CWbemNamespace::Exec_PutInstance(
    IWbemClassObject* pInst,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pSink
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    if ( pSink == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    
    //
    COperationError OpInfo(pSink, L"PutInstance", L"");

    if(pInst == NULL)
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_PARAMETER);

    // Check that the sink allocations succeeded
    if ( !OpInfo.IsOk() )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CWbemObject *pObj = (CWbemObject *) pInst;
    HRESULT hres;

    if (!pObj->IsInstance())
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_OBJECT);

    if (!pObj->IsKeyed())
        return OpInfo.ErrorOccurred(WBEM_E_NO_KEY);

    if (pObj->IsLimited())
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_OBJECT);

    if (pObj->IsClientOnly())
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_OBJECT);

    // Check if localization bits are set, and if so, that the
    // AMENDED_QUALIFIERS flag was specified.

    if ( ((CWbemObject*) pObj)->IsLocalized() &&
        !( lFlags & WBEM_FLAG_USE_AMENDED_QUALIFIERS ) )
    {
        return OpInfo.ErrorOccurred( WBEM_E_AMENDED_OBJECT );
    }

    if((lFlags & WBEM_FLAG_UPDATE_ONLY) == 0)
    {
        // Make sure that put extensions are not used without UPDATE_ONLY
        // ==============================================================

        BOOL bExtended;
        hres = GetContextBoolean(pCtx, L"__PUT_EXTENSIONS", &bExtended);
        if(FAILED(hres) || bExtended)
            return OpInfo.ErrorOccurred(WBEM_E_INVALID_CONTEXT);
    }

    BSTR strPropName;
    if(!pObj->ValidateRange(&strPropName))
    {
        OpInfo.SetParameterInfo(strPropName);
        SysFreeString(strPropName);
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_PROPERTY);
    }

    // Build the key string.
    // =====================

    CVar vClass;
    hres = pObj->GetClassName(&vClass);
    if (FAILED(hres))
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_OBJECT);

    OpInfo.SetParameterInfo(vClass.GetLPWSTR());

    // Get the class definition
    // ========================

    CWbemClass *pClassDef = 0;

    IWbemClassObject* pErrorObj = NULL;
    IWbemClassObject* pClassObj = NULL;
    hres = Exec_GetObjectByPath(vClass.GetLPWSTR(), 0, pCtx,
        &pClassObj, &pErrorObj);

    if(hres == WBEM_E_NOT_FOUND) hres = WBEM_E_INVALID_CLASS;

    if(FAILED(hres))
    {
        OpInfo.ErrorOccurred(hres, pErrorObj);
        if(pErrorObj) pErrorObj->Release();
        return hres;
    }

    pClassDef = (CWbemClass*)pClassObj;
    CReleaseMe rm1((IWbemClassObject*)pClassDef);

    // Dont allow write of old security classes.  This prevents
    // a nefarious user from trying to slip in some extra rights

    if (wbem_wcsicmp(vClass.GetLPWSTR(), L"__NTLMUser") == 0 ||
        wbem_wcsicmp(vClass.GetLPWSTR(), L"__NTLMGroup") == 0)
    {
        if (!Allowed(WRITE_DAC))
            return OpInfo.ErrorOccurred(WBEM_E_ACCESS_DENIED);
        if((lFlags & WBEM_FLAG_ONLY_STATIC) == 0)
        {
            return PutSecurityClassInstances(vClass.GetLPWSTR(), pInst ,
                        pSink, pCtx, lFlags);
        }
    }


    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Dont allow write on the __thisnamespace instance -- except during an upgrade in setup
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if (wbem_wcsicmp(vClass.GetLPWSTR(), L"__thisnamespace") == 0 && !IsSetupRunning())
    {
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_OPERATION);
    }

    // Make sure that the instance and the class match
    // ===============================================

    // SJS - Amendment is the same as Abstract
    if( pClassDef->IsAmendment() || pClassDef->IsAbstract() || !pClassDef->IsKeyed() )
    {
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_OPERATION);
    }

    try // internal fastprox interface
    {
        if(!((CWbemInstance*)pObj)->IsInstanceOf(pClassDef))
        {
            return OpInfo.ErrorOccurred(WBEM_E_INVALID_CLASS);
        }
    }
    catch (CX_MemoryException &)
    {
        // Provider crashed.
        // ==================
        return WBEM_E_OUT_OF_MEMORY;
    }

    // Verify provider validity
    // ========================

    if(pObj->InheritsFrom(L"__Provider") == S_OK)
    {
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Check if we're running as NETWORK/LOCAL SERVICE. If so, deny
        // access to writing instances of __Provider derived classes
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        HANDLE hAccess;
        hres = GetAccessToken (hAccess);
        if ( FAILED (hres) )
        {
            if ( hres != 0x80041007 )
            {
                return OpInfo.ErrorOccurred(WBEM_E_ACCESS_DENIED);
            }
        }
        else
        {
            if ( IsNetworkService (hAccess) || IsLocalService (hAccess) )
            {
                CloseHandle ( hAccess );
                return OpInfo.ErrorOccurred(WBEM_E_ACCESS_DENIED);
            }
            CloseHandle ( hAccess );
        }
    }

    // While the class may not be dynamically provided, some of the
    // properties might be.
    // ============================================================

    hres = GetOrPutDynProps(pObj, PUT, pClassDef->IsDynamic());
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_WBEMCORE, "Failed to pre-process an instance using "
            "a property provider. Error code: %X\n", hres));
    }

    // Recursively Put in all the right places
    // ======================================

    CCombiningSink* pCombSink = new CCombiningSink(OpInfo.GetSink());
    if(pCombSink == NULL)
        return OpInfo.ErrorOccurred(WBEM_E_OUT_OF_MEMORY);
    pCombSink->AddRef();
    CReleaseMe rm2(pCombSink);

    return RecursivePutInstance((CWbemInstance*)pObj, pClassDef, lFlags,
                pCtx, pCombSink, TRUE);
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::RecursivePutInstance(
    CWbemInstance* pInst,
    CWbemClass* pClassDef,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pSink,
    BOOL bLast
    )
{
    HRESULT hRes;


    // See if any action is required at this level
    // ===========================================

    if (pClassDef->IsAbstract() || pClassDef->IsAmendment() || !pClassDef->IsKeyed())
        return WBEM_S_FALSE;

    // See if we need to go up
    // =======================

    BOOL bParentTookCareOfItself = TRUE;

    if (pClassDef->IsDynamic())
    {
        // Get the parent class
        // ====================

        CVar vParentName;
        pClassDef->GetSuperclassName(&vParentName);
        if (!vParentName.IsNull())
        {
            IWbemClassObject* pParentClass = NULL;
            IWbemClassObject* pErrorObj = NULL;
            hRes = Exec_GetObjectByPath(vParentName.GetLPWSTR(), 0, pCtx,
                        &pParentClass, &pErrorObj);
            CReleaseMe rm1(pParentClass);
            CReleaseMe rm2(pErrorObj);
            if (FAILED(hRes))
            {
                pSink->SetStatus(0, hRes, NULL, pErrorObj);
                return hRes;
            }

            // Get it to put it's portion
            // ==========================

            hRes = RecursivePutInstance(pInst, (CWbemClass*)pParentClass,
                        lFlags, pCtx, pSink, FALSE);
            if(FAILED(hRes))
                return hRes;

            if(hRes == WBEM_S_FALSE)
                bParentTookCareOfItself = FALSE;
        }
    }

    // Parent Puts have been taken care of. Call it on our own class.
    // ==============================================================

    // Convert the instance to the right class
    // =======================================

    CWbemInstance* pNewInst = NULL;
    pInst->ConvertToClass(pClassDef, &pNewInst);
    CReleaseMe rm1((IWbemClassObject*)pNewInst);

    if (pNewInst == NULL)
    {
        ERRORTRACE((LOG_WBEMCORE, "Failed to convert an instance to a base "
            "class\n"));
        return pSink->Return(WBEM_E_CRITICAL_ERROR);
    }

    if (pClassDef->IsDynamic())
    {
        // Check if we need to do a put at this level
        // ==========================================

        if (!bLast && (lFlags & WBEM_FLAG_UPDATE_ONLY))
        {
            hRes = IsPutRequiredForClass(pClassDef, pInst, pCtx, bParentTookCareOfItself);
            if (FAILED(hRes))
                return pSink->Return(hRes);
            if (hRes == WBEM_S_FALSE)
            {
                // No need to put this class
                // =========================

                return pSink->Return(WBEM_S_NO_ERROR);
            }
        }

        // Get the provider name.
        // ======================

        CVar vProv;
        hRes = pClassDef->GetQualifier(L"Provider", &vProv);
        if (FAILED(hRes) || vProv.GetType() != VT_BSTR)
        {
            return pSink->Return(WBEM_E_INVALID_PROVIDER_REGISTRATION);
        }

        // Access the provider cache.  First check permission
        // ==================================================

        if (!Allowed(WBEM_WRITE_PROVIDER))
            return pSink->Return(WBEM_E_ACCESS_DENIED);

        CSynchronousSink* pSyncSink = new CSynchronousSink(pSink);
        if(pSyncSink == NULL)
            return pSink->Return(WBEM_E_OUT_OF_MEMORY);
        pSyncSink->AddRef();

        IWbemServices *pProv = 0;

        if(m_pProvFact == NULL)
            hRes = WBEM_E_CRITICAL_ERROR;
        else
        {
            WmiInternalContext t_InternalContext ;
            ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

            hRes = m_pProvFact->GetProvider(

                t_InternalContext ,
                0,                  // lFlags
                pCtx,
                0,
                m_wszUserName,
                m_wsLocale,
                0,                      // IWbemPath pointer
                vProv,              // Provider
                IID_IWbemServices,
                (LPVOID *) &pProv
            );
        }

        if (FAILED(hRes))
        {
            pSyncSink->Release() ;
            return pSink->Return(hRes);
        }

        CReleaseMe _(pProv);

        pProv->PutInstanceAsync(pNewInst, lFlags& ~WBEM_FLAG_USE_AMENDED_QUALIFIERS, pCtx, pSyncSink);

        pSyncSink->Block();

        IWbemClassObject* pErrorObj = NULL;
        BSTR str;
        pSyncSink->GetStatus(&hRes, &str, &pErrorObj);
        CSysFreeMe sfm(str);
        pSyncSink->Release();

        // It is ok if the upper levels report "provider not capable".
        // ===========================================================

        if (!bLast && hRes == WBEM_E_PROVIDER_NOT_CAPABLE)
            hRes = 0;

        if (FAILED(hRes))
        {
            //
            
            //
            COperationError OpInfo(pSink, L"PutInstance", L"");

            if (OpInfo.IsOk())
            {
                OpInfo.ProviderReturned(vProv.GetLPWSTR(), hRes, pErrorObj);
            }
            else
            {
                hRes = WBEM_E_OUT_OF_MEMORY;
            }

            if (pErrorObj) pErrorObj->Release();

            return hRes;
        }
        else if (str)
        {
            pSink->SetStatus(0, hRes, str, NULL);
        }

        // Provider passes back NULL, we should construct the instance path and return to client
        // NT RAID: 186286 [marioh]
        // ======================================================================================
        else
        {
            BSTR str;
            LPWSTR wszPath = pNewInst->GetRelPath();
            if ( !wszPath )
            {
                str=NULL;
            }
            else
            {
                str = SysAllocString(wszPath);
                delete [] wszPath;
            }

            pSink->SetStatus(0, hRes, str, NULL);
            SysFreeString(str);
        }

        return WBEM_S_NO_ERROR;
    }

    // The class is not dynamically provided.
    // ======================================

    hRes = ((CWbemInstance*)pNewInst)->PlugKeyHoles();
    if (FAILED(hRes))
        return pSink->Return(hRes);

    // Get the path.
    // =============

    CVar vClass;
    hRes = pNewInst->GetClassName(&vClass);
    if (FAILED(hRes))
    	return pSink->Return(WBEM_E_OUT_OF_MEMORY);

    WString ClassNameStr = vClass.GetLPWSTR();

    // Check permissions for writes on system classes.
    // ===============================================

    if ((ClassNameStr[0] == L'_' && !Allowed(WBEM_FULL_WRITE_REP)) ||
        (ClassNameStr[0] != L'_' && !Allowed(WBEM_PARTIAL_WRITE_REP)))
            return pSink->Return(WBEM_E_ACCESS_DENIED);

    CVARIANT v;
    hRes = pNewInst->Get(L"__RELPATH", 0, &v, 0, 0);
    if(FAILED(hRes))
        return pSink->Return(hRes);
    if(v.GetType() != VT_BSTR)
        return pSink->Return(WBEM_E_CRITICAL_ERROR);



    // Set up a new per-task hook.
    // ===========================

    _IWmiCoreWriteHook *pHook = 0;
    hRes = m_pCoreSvc->NewPerTaskHook(&pHook);
    if (FAILED(hRes))
        return pSink->Return(hRes);
    CReleaseMe _(pHook);
    HRESULT hHookResult = 0;

    // See if the instance already exists.
    // ===================================

    IWbemClassObject *pExistingObject = 0;
    hRes = CRepository::GetObject(m_pSession, m_pScopeHandle, v.GetStr(), 0, &pExistingObject);
    CReleaseMe _2(pExistingObject);


    if (FAILED(hRes))
    {
        // If we here, we failed to get it from the repository.  Thus, it needs to be created from scratch.
        // ================================================================================================

        // Remove all the amended qualifiers
        // =================================

        if (lFlags & WBEM_FLAG_USE_AMENDED_QUALIFIERS )
        {
            int nRes = SplitLocalized(pNewInst);
            if (FAILED(nRes))
                return pSink->Return(nRes);
        }

        if((lFlags & WBEM_MASK_CREATE_UPDATE) == WBEM_FLAG_UPDATE_ONLY)
        {
            return pSink->Return(WBEM_E_NOT_FOUND);
        }

        // As a special case, see if the object is
        // of class <__NAMESPACE>.  If so, create a new namespace
        // for it.
        // ======================================================

        if ((wbem_wcsicmp(vClass.GetLPWSTR(), L"__NAMESPACE") == 0) ||
            (CRepository::InheritsFrom(m_pSession, m_pNsHandle, L"__NAMESPACE", vClass.GetLPWSTR()) == 0))
        {
            hRes = CreateNamespace(pNewInst);
            if (FAILED(hRes))
                return pSink->Return(hRes);
        }
        // Not a __NAMESPACE or derivative.
        // ================================

        else
        {
            // If here, the object didn't already exist in the repository, so we
            // can add it to the database.
            // ==================================================================

            // Check if this instance makes any sense to
            // hook callbacks.
            // =========================================

            DecorateObject(pNewInst);
            IWbemClassObject* pInstObj = pNewInst;
            IWbemClassObject* pOldObj = 0;

            if (pHook)
            {
                // If there are hooks, try them and note whether callback is required.
                // ===================================================================
                hHookResult = pHook->PrePut(WBEM_FLAG_INST_PUT, lFlags, pCtx, 0,
                                            m_pThisNamespace, ClassNameStr, pNewInst
                                            );
            }

            if (FAILED(hHookResult))
            {
                return pSink->Return(hHookResult);
            }

            if (hHookResult == WBEM_S_POSTHOOK_WITH_BOTH)
            {
                CRepository::GetObject(m_pSession, m_pNsHandle, v.GetStr(), 0, &pOldObj);
            }

             // Actually create it in the database
            // ==================================

            hRes = CRepository::PutObject(m_pSession, m_pScopeHandle, IID_IWbemClassObject, LPVOID(pNewInst), DWORD(lFlags));

            if (pHook)
                pHook->PostPut(WBEM_FLAG_INST_PUT, hRes, pCtx, 0, m_pThisNamespace, ClassNameStr, pNewInst, (_IWmiObject *) pOldObj);

            delete pOldObj;

            if (FAILED(hRes))
            {
                return pSink->Return(hRes);
            }
        }
    }

    // If here, the object was already in the repository and requires updating.
    // ========================================================================

    else
    {
        if((lFlags & WBEM_MASK_CREATE_UPDATE) == WBEM_FLAG_CREATE_ONLY)
        {
            return pSink->Return(WBEM_E_ALREADY_EXISTS);
        }

        // Remove all the amended qualifiers
        // =================================

        if (lFlags & WBEM_FLAG_USE_AMENDED_QUALIFIERS )
        {
            int nRes = SplitLocalized(pNewInst, (CWbemObject *) pExistingObject);
            if (FAILED(nRes))
            {
                return pSink->Return(nRes);
            }
        }

        // Check if this update makes any sense to the ESS
        // ===============================================

        DecorateObject(pNewInst);
        IWbemClassObject* pInstObj = pNewInst;

        // Check pre-hook.
        // ===============

        if (pHook)
        {
            // If there are hooks, try them and note whether callback is required.
            // ===================================================================
             hHookResult = pHook->PrePut(WBEM_FLAG_INST_PUT, lFlags, pCtx, 0,
                                         m_pThisNamespace, ClassNameStr, pNewInst
                                        );
        }

        if (FAILED(hHookResult))
            return pSink->Return(hHookResult);

        // Actually create it in the database
        // ==================================

        hRes = CRepository::PutObject(m_pSession, m_pScopeHandle, IID_IWbemClassObject, LPVOID(pNewInst), DWORD(lFlags));

        // Post put.
        // =========

        if (pHook)
            pHook->PostPut(WBEM_FLAG_INST_PUT, hRes, pCtx, 0, m_pThisNamespace, ClassNameStr, pNewInst, (_IWmiObject *) pExistingObject);

        if (FAILED(hRes))
            return pSink->Return(hRes);
    }


    // Assign appropriate value to the path
    // ====================================

    LPWSTR wszPath = pNewInst->GetRelPath();
    BSTR str = SysAllocString(wszPath);
    delete [] wszPath;

    pSink->SetStatus(0, WBEM_S_NO_ERROR, str, NULL);
    SysFreeString(str);

    return WBEM_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::CreateNamespace(CWbemInstance *pNewInst)
{
    //
    // internal interface throws
    //
    CVar vNsName;
    HRESULT hRes = pNewInst->GetProperty(L"Name", &vNsName);
    if (FAILED(hRes) || vNsName.IsNull())
    {
        return WBEM_E_INVALID_NAMESPACE;
    }

    // verify that this name is valid
    // ==============================

    if (!IsValidElementName(vNsName.GetLPWSTR()))
    {
        return WBEM_E_INVALID_NAMESPACE;
    }

    if (!Allowed(WBEM_FULL_WRITE_REP))
    {
        return WBEM_E_ACCESS_DENIED;
    }

    //Get a new session for transactioning purposes...
    IWmiDbSession *pSession = NULL;
    IWmiDbSessionEx *pSessionEx = NULL;

    hRes = CRepository::GetNewSession(&pSession);
    if (FAILED(hRes))
        return hRes;

    //Get an EX version that supports transactioning...
    pSession->QueryInterface(IID_IWmiDbSessionEx, (void**)&pSessionEx);
    if (pSessionEx)
    {
        pSession->Release();
        pSession = pSessionEx;
    }
    CReleaseMe relMe1(pSession);

    //If we have transactionable session, use it!
    if (pSessionEx)
    {
        hRes = pSessionEx->BeginWriteTransaction(0);
        if (FAILED(hRes))
        {
            return hRes;
        }
    }

    try
    {
        // Build the new namespace name.
        // =============================

        // Create the namespace
        // =====================
        if (SUCCEEDED(hRes))
            hRes = CRepository::PutObject(pSession, m_pScopeHandle, IID_IWbemClassObject, LPVOID(pNewInst), 0);

        // Set the default instances.
        // ===============================

        CWbemNamespace* pNewNs = NULL;

        if (SUCCEEDED(hRes))
            pNewNs = CWbemNamespace::CreateInstance();

        if (SUCCEEDED(hRes) && pNewNs != NULL)
        {
            int iLen = 2;
            if(m_pThisNamespace)
                iLen += wcslen(m_pThisNamespace);
            if(vNsName.GetLPWSTR())
                iLen += wcslen(vNsName.GetLPWSTR());
            WCHAR * pTemp = new WCHAR[iLen];
            if(pTemp)
            {
                *pTemp = NULL;
                if(m_pThisNamespace)
                {
                    wcscpy(pTemp, m_pThisNamespace);
                    wcscat(pTemp, L"\\");
                }
                if(vNsName.GetLPWSTR())
                    wcscat(pTemp, vNsName.GetLPWSTR());

                //Initialize the namespace object
                hRes = pNewNs->Initialize(pTemp,GetUserName(), 0, 0, FALSE, TRUE,
                                          NULL, 0xFFFFFFFF, TRUE, pSession);
                delete pTemp;
            }
            else
            {
                hRes = WBEM_E_OUT_OF_MEMORY;
            }

            if(SUCCEEDED(hRes))
            {
                hRes = CRepository::EnsureNsSystemInstances(pSession, pNewNs->m_pNsHandle, pSession, m_pNsHandle);
            }

            if (SUCCEEDED(hRes))
                hRes = InitializeSD(pSession);

            pNewNs->Release();
        }
        else if (SUCCEEDED(hRes))
        {
            hRes = WBEM_E_OUT_OF_MEMORY;
        }
    }
    catch (CX_MemoryException &)
    {
        hRes = WBEM_E_OUT_OF_MEMORY;    
    }    
    catch (...)
    {
        ExceptionCounter c;    
        ERRORTRACE((LOG_WBEMCORE, "Namespace Creation of <%S> caused a very critical error!\n", vNsName.GetLPWSTR()));
        hRes = WBEM_E_CRITICAL_ERROR;
    }
    if (FAILED(hRes))
    {
        ERRORTRACE((LOG_WBEMCORE, "Namespace Creation of <%S> caused an error <0x%X>!\n", vNsName.GetLPWSTR(), hRes));
        if (pSessionEx)
            pSessionEx->AbortTransaction(0);
    }
    else
    {
        DecorateObject(pNewInst);
        if (pSessionEx)
        {
            hRes = pSessionEx->CommitTransaction(0);
        }
    }

    return hRes;
}

//***************************************************************************
//
//  CWbemNamespace::Exec_DeleteInstance
//
//  Actually deletes the instance from the database. No instance provider
//  support. Raises instance deletion event.
//
//  Parameters and return values are exacly the same as those for DeleteInstance
//  as described in help
//
//***************************************************************************
HRESULT CWbemNamespace::Exec_DeleteInstance(
    READONLY LPWSTR wszObjectPath,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pSink
    )
{
    return DeleteSingleInstance(wszObjectPath, lFlags, pCtx, pSink);
}


HRESULT CWbemNamespace::RecursiveDeleteInstance(LPCWSTR wszObjectPath,
            CDynasty* pDynasty, long lFlags, IWbemContext* pCtx,
            CBasicObjectSink* pSink)
{
    // Convert the object path to the right class
    // ==========================================

    BSTR strNewPath = CQueryEngine::AdjustPathToClass(wszObjectPath,
        pDynasty->m_wszClassName);
    CSysFreeMe rm(strNewPath);

    if(strNewPath == NULL)
        return pSink->Return(WBEM_E_INVALID_OBJECT_PATH);

    CBasicObjectSink* pChildSink = NULL;

    if(pDynasty->IsKeyed())
    {
        // Delete this particular instance
        // ===============================

        DeleteSingleInstance(strNewPath, lFlags, pCtx, pSink);

        // Deletes on our children are advisory --- their success cannot
        // influence the outcome
        // =============================================================

        pChildSink = new CSuccessSuppressionSink(pSink, WBEM_E_NOT_FOUND,
                            WBEM_E_PROVIDER_NOT_CAPABLE);
        if(pChildSink == NULL)
            return pSink->Return(WBEM_E_OUT_OF_MEMORY);
        pChildSink->AddRef();
    }
    else
    {
        // Our children are important
        // ==========================

        pChildSink = pSink;
        pChildSink->AddRef();
    }

    CReleaseMe rm1(pChildSink);

    // Recurse
    // =======

    if(pDynasty->m_pChildren)
    {
        for(int i = 0; i < pDynasty->m_pChildren->Size(); i++)
        {
            CDynasty* pChildDyn =
                (CDynasty*)pDynasty->m_pChildren->GetAt(i);
            RecursiveDeleteInstance(wszObjectPath, pChildDyn, lFlags, pCtx,
                pChildSink);
        }
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::DeleteSingleInstance(
    READONLY LPWSTR wszObjectPath,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pSink
    )
{
    HRESULT hRes;
    int nRes;

    //
    
    //
    COperationError OpInfo(pSink, L"DeleteInstance", wszObjectPath);

    // Check that the sink allocations succeeded
    // =========================================

    if ( !OpInfo.IsOk() )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    // Parse the object path to get the class involved.
    // ================================================
    ParsedObjectPath* pOutput = 0;

    CObjectPathParser p;
    int nStatus = p.Parse(wszObjectPath,  &pOutput);

    if (nStatus != 0 || !pOutput->IsInstance())
    {
        p.Free(pOutput);
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_OBJECT_PATH);
    }

    // Exception for __WinMgmtIdentification
    // ====================================

    if (!wbem_wcsicmp(pOutput->m_pClass, L"__CIMOMIdentification") ||
        !wbem_wcsicmp(pOutput->m_pClass, L"__SystemSecurity") ||
        !wbem_wcsicmp(pOutput->m_pClass, L"__ADAPStatus" ) )
    {
        p.Free(pOutput);
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_OPERATION);
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Dont allow deletion on the __thisnamespace instance
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if (wbem_wcsicmp(pOutput->m_pClass, L"__thisnamespace") == 0 )
    {
        p.Free(pOutput);
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_OPERATION);
    }


    // Special case for  the old security classes
    // ==========================================

    if (wbem_wcsicmp(pOutput->m_pClass, L"__NTLMUser") == 0 ||
        wbem_wcsicmp(pOutput->m_pClass, L"__NTLMGroup") == 0)
    {
        if (!Allowed(WRITE_DAC))
        {
            p.Free(pOutput);
            return OpInfo.ErrorOccurred(WBEM_E_ACCESS_DENIED);
        }
        if((lFlags & WBEM_FLAG_ONLY_STATIC) == 0)
        {
            HRESULT hr = DeleteSecurityClassInstances(pOutput, pSink, pCtx,lFlags);
            p.Free(pOutput);
            return hr;
        }
    }

    // As a special case, see if the object is
    // of class <__NAMESPACE>.  If so, (TEMP) disallow deletion.
    // =========================================================

    WString wsNamespaceName;

    if (wbem_wcsicmp(pOutput->m_pClass, L"__NAMESPACE") == 0 ||
        CRepository::InheritsFrom(m_pSession, m_pScopeHandle, L"__NAMESPACE", pOutput->m_pClass) == 0
        )

    {
        if (!Allowed(WBEM_FULL_WRITE_REP))
		{
	        p.Free(pOutput);
            return OpInfo.ErrorOccurred(WBEM_E_ACCESS_DENIED);
		}

        if (pOutput->m_dwNumKeys != 1)
        {
            p.Free(pOutput);
            return OpInfo.ErrorOccurred(WBEM_E_INVALID_OBJECT_PATH);
        }

        KeyRef* pKey = pOutput->m_paKeys[0];
        if (pKey->m_pName != NULL && wbem_wcsicmp(pKey->m_pName, L"name"))
        {
            p.Free(pOutput);
            return OpInfo.ErrorOccurred(WBEM_E_INVALID_OBJECT_PATH);
        }

        if (V_VT(&pKey->m_vValue) != VT_BSTR)
        {
            p.Free(pOutput);
            return OpInfo.ErrorOccurred(WBEM_E_INVALID_OBJECT_PATH);
        }

        // Prevent deletion of standard namespaces.
        // ========================================

        if (_wcsicmp(m_pThisNamespace, L"ROOT") == 0)
        {
            BSTR pNs = V_BSTR(&pKey->m_vValue);
            if (!pNs)
			{
		        p.Free(pOutput);
                return OpInfo.ErrorOccurred(WBEM_E_INVALID_OBJECT_PATH);
			}
            if (_wcsicmp(pNs, L"SECURITY") == 0)
			{
		        p.Free(pOutput);
                return OpInfo.ErrorOccurred(WBEM_E_ACCESS_DENIED);
			}
            if (_wcsicmp(pNs, L"DEFAULT") == 0)
			{
		        p.Free(pOutput);
                return OpInfo.ErrorOccurred(WBEM_E_ACCESS_DENIED);
			}
        }

        // Set up hook.
        // ============

        _IWmiCoreWriteHook *pHook = 0;
        HRESULT hRes = m_pCoreSvc->NewPerTaskHook(&pHook);
        CReleaseMe _(pHook);
        HRESULT hHookResult = 0;
        LPWSTR pszClassName = 0;
        IWbemPath *pPath = 0;

        CVectorDeleteMe<WCHAR> vdmClassName(&pszClassName);

        if (pHook)
        {
            // Parse the object path.
            // ======================

            hRes = m_pCoreSvc->CreatePathParser(0, &pPath);
            if (FAILED(hRes))
			{
		        p.Free(pOutput);
                return OpInfo.ErrorOccurred(hRes);
			}

            CReleaseMe _3Path(pPath);

            hRes = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, wszObjectPath);
            if (FAILED(hRes))
			{
		        p.Free(pOutput);
                return OpInfo.ErrorOccurred(hRes);
			}

            ULONG uBuf = 0;
            hRes = pPath->GetClassName(&uBuf, 0);
            if (FAILED(hRes))
			{
		        p.Free(pOutput);
                return OpInfo.ErrorOccurred(hRes);
			}

            pszClassName = new wchar_t[uBuf+1];
            if (pszClassName == 0)
			{
		        p.Free(pOutput);
                return OpInfo.ErrorOccurred(WBEM_E_OUT_OF_MEMORY);
			}

            hRes = pPath->GetClassName(&uBuf, pszClassName);
            if (FAILED(hRes))
			{
		        p.Free(pOutput);
                return OpInfo.ErrorOccurred(hRes);
			}

            // If there are hooks, try them and note whether callback is required.
            // ===================================================================
            hHookResult = pHook->PreDelete(WBEM_FLAG_INST_DELETE, lFlags, pCtx, pPath,
                                       m_pThisNamespace, pszClassName
                                       );

            if (FAILED(hHookResult))
			{
		        p.Free(pOutput);
                return OpInfo.ErrorOccurred(hHookResult);
			}

            pPath->AddRef();
        }

        CReleaseMe _2Path(pPath);

        // Ensure the object can be reached so that we can delete it.
        // ==========================================================

        IWbemClassObject *pExistingObject = 0;
        hRes = CRepository::GetObject(m_pSession, m_pScopeHandle, wszObjectPath, 0, &pExistingObject);

        if (FAILED(hRes))
        {
            p.Free(pOutput);
            return OpInfo.ErrorOccurred(hRes);
        }

        CReleaseMe _2(pExistingObject);

        if (hRes == WBEM_S_NO_ERROR)    // new test
        {
            // Check if we may
            // ===============

            if (!Allowed(WBEM_FULL_WRITE_REP))
			{
		        p.Free(pOutput);
                return OpInfo.ErrorOccurred(WBEM_E_ACCESS_DENIED);
			}

            // Go ahead and try the deletion.
            // ==============================

            WString sNamespace = "__Namespace='";
            sNamespace += V_BSTR(&pKey->m_vValue);
            sNamespace += "'";

            hRes = CRepository::DeleteByPath(m_pSession, m_pScopeHandle, LPWSTR(sNamespace), 0);

            // Call post hook.
            // ===============
            if (pHook)
                pHook->PostDelete(WBEM_FLAG_INST_DELETE, hRes, pCtx, pPath,
                    m_pThisNamespace, pszClassName, (_IWmiObject *) pExistingObject);

            // Decide what to do if things didn't work out.
            // ============================================

            if (FAILED(hRes))
            {
                p.Free(pOutput);
                return OpInfo.ErrorOccurred(hRes);
            }
        }
        else
        {
            p.Free(pOutput);
            return OpInfo.ErrorOccurred(hRes);
        }

        wsNamespaceName = V_BSTR(&pKey->m_vValue);
        p.Free(pOutput);

        return OpInfo.ErrorOccurred(WBEM_S_NO_ERROR);
    }

    // See if the class is dynamic
    // ===========================

    CWbemObject *pClassDef = 0;
    IWbemClassObject* pErrorObj = NULL;
    IWbemClassObject* pClassObj = NULL;

    HRESULT hres = Exec_GetObjectByPath(pOutput->m_pClass, 0, pCtx,
        &pClassObj, &pErrorObj);

    if(hres == WBEM_E_NOT_FOUND) hres = WBEM_E_INVALID_CLASS;

    if(FAILED(hres))
    {
        p.Free(pOutput);
        OpInfo.ErrorOccurred(hres, pErrorObj);
        if(pErrorObj) pErrorObj->Release();
        return WBEM_S_NO_ERROR;
    }
    pClassDef = (CWbemObject*)pClassObj;

    CVar vDynFlag;
    hres = pClassDef->GetQualifier(L"Dynamic", &vDynFlag);
    if (SUCCEEDED(hres) && vDynFlag.GetType() == VT_BOOL && vDynFlag.GetBool())
    {
        p.Free(pOutput);

        // Get the provider name.
        // ======================

        CVar vProv;
        hres = pClassDef->GetQualifier(L"Provider", &vProv);
        if (FAILED(hres) || vProv.GetType() != VT_BSTR)
        {
            pClassDef->Release();
            return OpInfo.ErrorOccurred(WBEM_E_INVALID_PROVIDER_REGISTRATION);
        }

        if (!Allowed(WBEM_WRITE_PROVIDER))
            return OpInfo.ErrorOccurred(WBEM_E_ACCESS_DENIED);

        // Access the provider cache.
        // ==========================

        IWbemServices *pProv = 0;
        HRESULT hRes;
        if(m_pProvFact == NULL)
            hRes = WBEM_E_CRITICAL_ERROR;
        else
        {
            WmiInternalContext t_InternalContext ;
            ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

            hRes = m_pProvFact->GetProvider(

                t_InternalContext ,
                0,                  // lFlags
                pCtx,
                0,
                m_wszUserName,
                m_wsLocale,
                0,                      // IWbemPath pointer
                vProv,     // Provider
                IID_IWbemServices,
                (LPVOID *) &pProv
            );
        }

        if (FAILED(hRes))
        {
            return OpInfo.ErrorOccurred(hRes);
        }

        CReleaseMe _(pProv);

        hRes = pProv->DeleteInstanceAsync(
            wszObjectPath,
            lFlags& ~WBEM_FLAG_USE_AMENDED_QUALIFIERS,
            pCtx,
            OpInfo.GetSink()
            );

        pClassDef->Release();
        return WBEM_S_NO_ERROR;
    }

    // The class is not dynamically provided.
    // ======================================

    pClassDef->Release();

    if ((*pOutput->m_pClass == L'_' && !Allowed(WBEM_FULL_WRITE_REP)) ||
        (*pOutput->m_pClass != L'_' && !Allowed(WBEM_PARTIAL_WRITE_REP)))
	{
        p.Free(pOutput);
        return OpInfo.ErrorOccurred(WBEM_E_ACCESS_DENIED);
	}

    // If here, it is a normal object.   First retrieve
    // the object for the event subsystem, then go ahead and delete it.
    // ================================================================

    // Prehook.
    // ========

    _IWmiCoreWriteHook *pHook = 0;
    hRes = m_pCoreSvc->NewPerTaskHook(&pHook);
    CReleaseMe _(pHook);
    HRESULT hHookResult = 0;
    LPWSTR pszClassName = 0;
    IWbemPath *pPath = 0;
    IWbemClassObject *pDoomedInstance = 0;

    CVectorDeleteMe<WCHAR> vdmClassName(&pszClassName);

    if (pHook)
    {
        // Parse the object path.
        // ======================

        hRes = m_pCoreSvc->CreatePathParser(0, &pPath);
        if (FAILED(hRes))
		{
	        p.Free(pOutput);
            return OpInfo.ErrorOccurred(hRes);
		}

        CReleaseMe _3Path(pPath);

        hRes = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, wszObjectPath);
        if (FAILED(hRes))
		{
	        p.Free(pOutput);
            return OpInfo.ErrorOccurred(hRes);
		}

        ULONG uBuf = 0;
        hRes = pPath->GetClassName(&uBuf, 0);
        if (FAILED(hRes))
		{
	        p.Free(pOutput);
            return OpInfo.ErrorOccurred(hRes);
		}

        pszClassName = new wchar_t[uBuf+1];
        if (pszClassName == 0)
		{
	        p.Free(pOutput);
            return OpInfo.ErrorOccurred(WBEM_E_OUT_OF_MEMORY);
		}

        hRes = pPath->GetClassName(&uBuf, pszClassName);
        if (FAILED(hRes))
		{
	        p.Free(pOutput);
            return OpInfo.ErrorOccurred(hRes);
		}

        // If there are hooks, try them and note whether callback is required.
        // ===================================================================
        hHookResult = pHook->PreDelete(WBEM_FLAG_INST_DELETE, lFlags, pCtx, pPath,
                                       m_pThisNamespace, pszClassName
                                       );

        if (FAILED(hHookResult))
        {
            p.Free(pOutput);

            return OpInfo.ErrorOccurred(hHookResult);
        }

        // If anybody wants to see the old object, get it.
        // ===============================================
        pDoomedInstance = NULL ;
		if (hHookResult == WBEM_S_POSTHOOK_WITH_OLD)
            hRes = CRepository::GetObject(m_pSession, m_pScopeHandle, wszObjectPath,0, &pDoomedInstance);

        pPath->AddRef();
    }
    CReleaseMe _Doomed (pDoomedInstance) ;
    CReleaseMe _3Path(pPath);

    if (SUCCEEDED(hRes))
    {
        hRes = CRepository::DeleteByPath(m_pSession, m_pScopeHandle, wszObjectPath, 0);  // new

    // Posthook.
    // =========

        if (pHook)
            pHook->PostDelete(WBEM_FLAG_INST_DELETE, hRes, pCtx, pPath,
                m_pThisNamespace, pszClassName, (_IWmiObject *) pDoomedInstance);

        if ( FAILED (hRes) )
        {
	     p.Free(pOutput);
            
            return OpInfo.ErrorOccurred(hRes);
        }

    }
    else
    {
        p.Free(pOutput);
        return OpInfo.ErrorOccurred(hRes);
    }

    p.Free(pOutput);
    
    return OpInfo.ErrorOccurred(WBEM_NO_ERROR);
}


//***************************************************************************
//
//  CWbemNamespace::Exec_CreateInstanceEnum
//
//  Actually creates the enumerator for all instances of a given class,
//  optionally recursively. Interacts with instance providers. Class provider
//  interaction works, but is sparsely tested.
//
//  Parameters and return values are exacly the same as those for
//  CreateInstanceEnum as described in help
//
//***************************************************************************

HRESULT CWbemNamespace::Exec_CreateInstanceEnum(
    LPWSTR wszClass,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pSink
    )
{

    //
    
    //
    COperationError OpInfo(pSink, L"CreateInstanceEnum", wszClass);

    // Check that the sink allocations succeeded
    if ( !OpInfo.IsOk() )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    // Make sure the name of the class is a name
    // =========================================

    if(wcschr(wszClass, L':'))
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_CLASS);

    // Create equivalent query
    // =======================

    WString wsQuery;
    wsQuery += L"select * from ";
    wsQuery += wszClass;

    if((lFlags & WBEM_MASK_DEPTH) == WBEM_FLAG_SHALLOW)
    {
        wsQuery += L" where __CLASS = \"";
        wsQuery += wszClass;
        wsQuery += L"\"";
    }

    CErrorChangingSink* pErrSink = new CErrorChangingSink(OpInfo.GetSink(),
        WBEM_E_INVALID_QUERY, WBEM_E_INVALID_CLASS);
    if(pErrSink == NULL)
        return OpInfo.ErrorOccurred(WBEM_E_OUT_OF_MEMORY);
    pErrSink->AddRef();

    // Execute it
    // ==========

    CQueryEngine::ExecQuery(
        this,
        L"WQL",
        (LPWSTR)wsQuery,
        lFlags,
        pCtx,
        pErrSink
        );
    pErrSink->Release();

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

void CWbemNamespace::SetUserName(LPWSTR wName)
{
    try
    {
        delete m_wszUserName;
        m_wszUserName = (wName) ? Macro_CloneLPWSTR(wName):NULL;
    }
    catch(...)
    {
        ExceptionCounter c;    
        m_wszUserName = 0;
    }
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::GetObjectByFullPath(
    READONLY LPWSTR wszObjectPath,
    IWbemPath * pOutput,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pSink
    )
{

    // Get the namespace part of the path

    DWORD dwSizeNamespace = 0;
    HRESULT hres = pOutput->GetText(WBEMPATH_GET_NAMESPACE_ONLY, &dwSizeNamespace, NULL);
    if(FAILED(hres))
        return hres;

    LPWSTR wszNewNamespace = new WCHAR[dwSizeNamespace];
    if(wszNewNamespace == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CDeleteMe<WCHAR> dm1(wszNewNamespace);

    hres = pOutput->GetText(WBEMPATH_GET_NAMESPACE_ONLY, &dwSizeNamespace, wszNewNamespace);
    if(FAILED(hres))
        return hres;

    // Get the relative part of the path

    DWORD dwSizeRelative = 0;
    hres = pOutput->GetText(WBEMPATH_GET_RELATIVE_ONLY, &dwSizeRelative, NULL);
    if(FAILED(hres))
        return hres;

    LPWSTR wszRelativePath = new WCHAR[dwSizeRelative];
    if(wszRelativePath == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CDeleteMe<WCHAR> dm2(wszRelativePath);

    hres = pOutput->GetText(WBEMPATH_GET_RELATIVE_ONLY, &dwSizeRelative, wszRelativePath);
    if(FAILED(hres))
        return hres;

    if (pOutput->IsLocal(ConfigMgr::GetMachineName()))
    {
        // In win2k, we allowed \\.\root\default:whatever, but not root\default:whatever
        // So, the following additional test was added

        ULONGLONG uFlags;
        hres = pOutput->GetInfo(0, &uFlags);
        if(SUCCEEDED(hres))
        {
            if((uFlags & WBEMPATH_INFO_PATH_HAD_SERVER) == 0)
                return pSink->Return(WBEM_E_INVALID_OBJECT_PATH);
        }

        bool bAlreadyAuthenticated = (m_dwSecurityFlags & SecFlagWin9XLocal) != 0;
        CWbemNamespace* pNewLocal = CWbemNamespace::CreateInstance();
        if(pNewLocal == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        hres = pNewLocal->Initialize(wszNewNamespace, m_wszUserName,
                                        (bAlreadyAuthenticated) ? m_dwSecurityFlags : 0,
                                        (bAlreadyAuthenticated) ? m_dwPermission : 0,
                                         m_bForClient, false,
                                         m_pszClientMachineName,
                                         m_dwClientProcessID,
                                         FALSE,NULL);
        if (FAILED(hres))
        {
            pNewLocal->Release();
            return hres;
        }
        else if (pNewLocal->GetStatus())
        {
            hres = pNewLocal->GetStatus();
            pNewLocal->Release();
            return hres;
        }

        // check for security if this isnt the local 9x case

        if(!bAlreadyAuthenticated)
        {
            DWORD dwAccess = pNewLocal->GetUserAccess();
            if((dwAccess  & WBEM_ENABLE) == 0)
            {
                delete pNewLocal;
                return WBEM_E_ACCESS_DENIED;
            }
            else
               pNewLocal->SetPermissions(dwAccess);
        }

        if(pNewLocal->GetStatus())
        {
            hres = pNewLocal->GetStatus();
            delete pNewLocal;
            return pSink->Return(hres);
        }

#if 0
        pNewLocal->AddRef();
#endif
        pNewLocal->SetLocale(GetLocale());

        hres = pNewLocal->Exec_GetObject(wszRelativePath,
            lFlags, pCtx, pSink);
        pNewLocal->Release();
        return hres;
    }
    else
    {
        // Disable remote retrieval for V1
        // ===============================

        return pSink->Return(WBEM_E_NOT_SUPPORTED);
/*
        IWbemServices* pNewGlobal = NULL;
        LPWSTR wszFullNamespace =
            new WCHAR[wcslen(pOutput->m_pServer) +
                      wcslen(wszNewNamespace) +
                      10];
        if(wszFullNamespace == NULL)
            return pSink->Return(WBEM_E_OUT_OF_MEMORY);

        swprintf(wszFullNamespace, L"\\\\%s\\%s",
            pOutput->m_pServer, wszNewNamespace);

        IWbemLocator * pLocator = NULL;
        hres = CoCreateInstance(CLSID_WbemLocator, NULL,
            CLSCTX_INPROC_SERVER, IID_IWbemLocator, (void**)&pLocator);
        if(hres == S_OK)
        {
            hres = pLocator->ConnectServer(wszFullNamespace, NULL, NULL, NULL,
                0, NULL, NULL, &pNewGlobal);
            pLocator->Release();
        }

        delete [] wszFullNamespace;
        if(FAILED(hres)) return pSink->Return(hres);


        hres = pNewGlobal->GetObjectAsync(wszRelativePath,
            lFlags & ~WBEM_FLAG_NO_STATIC, NULL, pSink);
        pNewGlobal->Release();
        return hres;
        */
    }
}

//***************************************************************************
//
//  CWbemNamespace::Exec_GetObjectByPath
//
//  Actually retrieves an object (a class or an instance) from the database.
//  Interacts properly with class and instance providers and uses property
//  providers for post-processing (See GetOrPutDynProps).
//
//  Parameters and return values are exacly the same as those for GetObject
//  as described in help
//
//***************************************************************************
HRESULT CWbemNamespace::Exec_GetObjectByPath(
    READONLY LPWSTR wszObjectPath,
    long lFlags,
    IWbemContext* pCtx,
    NEWOBJECT IWbemClassObject** ppObj,
    NEWOBJECT IWbemClassObject** ppErrorObj
    )
{
    HRESULT hres = WBEM_S_NO_ERROR;

    CSynchronousSink* pSyncSink = new CSynchronousSink;
    if(pSyncSink == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pSyncSink->AddRef();
    IWbemClassObject* pErrorObj = NULL;
    IWbemClassObject* pObj = NULL;

    hres = Exec_GetObject(wszObjectPath, lFlags, pCtx, pSyncSink);
    if (SUCCEEDED(hres))
    {
        pSyncSink->Block();
        pSyncSink->GetStatus(&hres, NULL, &pErrorObj);

        if(SUCCEEDED(hres))
        {
            if(pSyncSink->GetObjects().GetSize() < 1)
            {
                pSyncSink->Release();
                ERRORTRACE((LOG_WBEMCORE, "Sync sink returned success with no objects!\n"));
                return WBEM_E_CRITICAL_ERROR;
            }
            pObj = pSyncSink->GetObjects()[0];
            pObj->AddRef();
        }
    }

    pSyncSink->Release();

    if(ppObj) *ppObj = pObj;
    else if(pObj) pObj->Release();

    if(ppErrorObj) *ppErrorObj = pErrorObj;
    else if(pErrorObj) pErrorObj->Release();

    return hres;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::Exec_GetObject(
    READONLY LPWSTR wszObjectPath,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pSink)
{

    // Create a sink that will merge the localized qualifiers
    // over the top of the default qualifiers (if specified)
    // ======================================================

    CLocaleMergingSink *pLocaleSink = NULL;

    HRESULT hres = WBEM_S_NO_ERROR;
    if (wszObjectPath && wcslen(wszObjectPath) && wszObjectPath[0] != L'_')
    {
        if ((lFlags & WBEM_FLAG_USE_AMENDED_QUALIFIERS))
        {
            pLocaleSink = new CLocaleMergingSink(pSink, m_wsLocale, m_pThisNamespace);
            if(pLocaleSink == NULL)
                hres = WBEM_E_OUT_OF_MEMORY;
            else
            {
                pLocaleSink->AddRef();
                pSink = pLocaleSink;
            }
        }
    }

	CReleaseMe rm(pLocaleSink);
//    taskprintf("<CWbemNamespace::Exec_GetObject='%S'>", wszObjectPath);

    if (SUCCEEDED(hres))
    {
        //
        //  BUGBUG can throw
        // 
        COperationError OpInfo(pSink, L"GetObject", wszObjectPath);

        // Check that the sink allocations succeeded
        if ( !OpInfo.IsOk() )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        // Check if the path is NULL --- that's valid
        // ==========================================

        if (wszObjectPath == NULL || wcslen(wszObjectPath) == 0)
        {
            CWbemClass* pNewObj = new CWbemClass;
            if(pNewObj == NULL)
                return OpInfo.ErrorOccurred(WBEM_E_OUT_OF_MEMORY);
            pNewObj->InitEmpty(0);
            IWbemClassObject* pObj = pNewObj;
            pSink->Indicate(1, &pObj);
            pObj->Release();

            return OpInfo.ErrorOccurred(WBEM_NO_ERROR);
        }

        // Parse the object path to get the class involved.
        // ================================================

        IWbemPath *pPath = ConfigMgr::GetNewPath();
        if (pPath == 0)
        {
            return OpInfo.ErrorOccurred(WBEM_E_OUT_OF_MEMORY);
        }

        CReleaseMe _1(pPath);
        hres = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, wszObjectPath);
        if (FAILED(hres))
        {
            return OpInfo.ErrorOccurred(WBEM_E_INVALID_OBJECT_PATH);
        }

        ULONGLONG uResponse;
        hres = pPath->GetInfo(0, &uResponse);
        if (FAILED(hres) || (
            (uResponse & WBEMPATH_INFO_IS_INST_REF) == 0 &&
            (uResponse & WBEMPATH_INFO_IS_CLASS_REF) == 0))
        {
            return OpInfo.ErrorOccurred(WBEM_E_INVALID_OBJECT_PATH);
        }


        if (!pPath->IsRelative(ConfigMgr::GetMachineName(), m_pThisNamespace))
        {
            // This path points to another namespace. Delegate to it instead
            // =============================================================

            hres = GetObjectByFullPath(wszObjectPath, pPath,
                    lFlags, pCtx, OpInfo.GetSink());

            return OpInfo.ErrorOccurred(hres);
        }

        BOOL bInstance = (uResponse & WBEMPATH_INFO_IS_INST_REF);

        // The repository code can't handle paths like root\default:classname
        // So if there is a colon, pass a pointer to one past it

        WCHAR * pRelativePath = wszObjectPath;
        for(WCHAR * pTest = wszObjectPath;*pTest;pTest++)
            if(*pTest == L':')
            {
                // In win2k, we allowed \\.\root\default:whatever, but not root\default:whatever
                // So, the following additional test was added

                if((uResponse & WBEMPATH_INFO_PATH_HAD_SERVER) == 0)
                    return OpInfo.ErrorOccurred(WBEM_E_INVALID_OBJECT_PATH);

                pRelativePath = pTest+1;
                break;
            }
            else if (*pTest==L'=')
                break;      //got to key part...

        if (bInstance)
        {
            CFinalizingSink* pFinalSink =
                new CFinalizingSink(this, OpInfo.GetSink());
            if(pFinalSink == NULL)
                return OpInfo.ErrorOccurred(WBEM_E_OUT_OF_MEMORY);
            pFinalSink->AddRef();

            hres = Exec_GetInstance(pRelativePath, pPath, lFlags, pCtx, pFinalSink);

            pFinalSink->Release();
        }
        else
        {
            hres = Exec_GetClass(pRelativePath, lFlags, pCtx, OpInfo.GetSink());
            if ( FAILED (hres) )
            {
                return OpInfo.ErrorOccurred(hres);
            }
        }
    }
    else
    {
        //
        
        //
        COperationError OpInfo(pSink, L"GetObject", wszObjectPath);

        // Check that the sink allocations succeeded
        if ( !OpInfo.IsOk() )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        return OpInfo.ErrorOccurred(hres);
    }

    return hres;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::Exec_GetInstance(LPCWSTR wszObjectPath,
        IWbemPath* pParsedPath, long lFlags, IWbemContext* pCtx,
        CBasicObjectSink* pSink)
{

    if (pParsedPath->IsSameClassName(L"__NTLMUser") ||
        pParsedPath->IsSameClassName(L"__NTLMGroup"))
    {
        if((lFlags & WBEM_FLAG_ONLY_STATIC) == 0)
        {

            ParsedObjectPath* pOutput = 0;         // todo, convert to use new parser
            CObjectPathParser p;
            int nStatus = p.Parse(wszObjectPath,  &pOutput);
            if (nStatus != 0)
            {
                p.Free(pOutput);
                return WBEM_E_INVALID_OBJECT_PATH;
            }

            HRESULT hr = GetSecurityClassInstances(pOutput, pSink, pCtx,lFlags);
            p.Free(pOutput);
            return hr;
        }
    }

    // Try static database first
    // =========================

    if((lFlags & WBEM_FLAG_NO_STATIC) == 0)
    {
        IWbemClassObject *pObj = 0;
        HRESULT hRes = CRepository::GetObject(m_pSession, m_pScopeHandle, wszObjectPath, lFlags, &pObj);

        if (SUCCEEDED(hRes))
        {
            hRes = WBEM_S_NO_ERROR;
            pSink->Add(pObj);
            pObj->Release();
            return pSink->Return(hRes);
        }

    }

    // Try dynamic
    // ===========

    return DynAux_GetInstance((LPWSTR)wszObjectPath, lFlags, pCtx, pSink);
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::Exec_GetClass(
    LPCWSTR pszClassName,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pSink
    )
{
    HRESULT hRes = 0;
    IWbemClassObject* pErrorObj = 0;
    IWbemServices *pClassProv = 0;
    CSynchronousSink* pSyncSink = 0;
    BSTR bstrClass = 0;
    IWbemClassObject* pResultObj = 0;

    if (pszClassName == 0 || pSink == 0)
        return pSink->Return(WBEM_E_INVALID_PARAMETER);


    if (!m_bRepositOnly && m_pProvFact)
    {
        hRes = m_pProvFact->GetClassProvider(
                    0,                  // lFlags
                    pCtx,
                    m_wszUserName,
                    m_wsLocale,
                    m_pThisNamespace,                     // IWbemPath pointer
                    0,
                    IID_IWbemServices,
                    (LPVOID *) &pClassProv
                    );

        if (FAILED(hRes))
            return pSink->Return(hRes);
    }

    CReleaseMe _1(pClassProv);

    // First, try repository.  If it's there, end of story.
    // ====================================================

    if ((lFlags & WBEM_FLAG_NO_STATIC) == 0)
    {
        if (m_pNsHandle)
        {
            hRes = CRepository::GetObject(
                m_pSession,
                m_pNsHandle,
                pszClassName,
                0,
                &pResultObj
                );
        }
        else        // Something drastically wrong
        {
            hRes = WBEM_E_CRITICAL_ERROR;
            return pSink->Return(hRes);
        }

        if (SUCCEEDED(hRes) && pResultObj)
        {
            pSink->Add(pResultObj);
            pResultObj->Release();
            return pSink->Return(hRes);
        }
    }

    // If we are in repository-only mode, we don't bother
    // with dynamic classes.
    // ===================================================

    if (m_bRepositOnly || m_pProvFact == NULL)
        return pSink->Return(WBEM_E_NOT_FOUND);

    // If here, try the dynamic class providers.
    // =========================================
    // Build up a synchronous sink to receive the class.
    // =================================================

    pSyncSink = new CSynchronousSink;
    if (pSyncSink == NULL)
        return pSink->Return(WBEM_E_OUT_OF_MEMORY);
    pSyncSink->AddRef();
    CReleaseMe _2(pSyncSink);

    // Try to get it.
    // ==============


    bstrClass = SysAllocString(pszClassName);
    if (bstrClass == 0)
        return pSink->Return(WBEM_E_OUT_OF_MEMORY);

    try
    {
        CDecoratingSink * pDecore = new CDecoratingSink(pSyncSink, this);
        if(pDecore == NULL)
            return pSink->Return(WBEM_E_OUT_OF_MEMORY);
        pDecore->AddRef();
        hRes = pClassProv->GetObjectAsync(bstrClass, lFlags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS, pCtx, pDecore);
        pDecore->Release();
    }
    catch(...)
    {
        ExceptionCounter c;    
        hRes = WBEM_E_CRITICAL_ERROR;
    }

    SysFreeString(bstrClass);

    if (FAILED(hRes))
        return pSink->Return(hRes);

    pSyncSink->Block();
    pSyncSink->GetStatus(&hRes, NULL, &pErrorObj);

    if (FAILED(hRes))
    {
        pSink->Return(hRes, pErrorObj);
        if (pErrorObj)
            pErrorObj->Release();
        return hRes;
    }

    // Otherwise, somebody claimed to have supplied it. Do we really believe them?  No choice.
    // =======================================================================================

    if(pSyncSink->GetObjects().GetSize() < 1)
    {
        ERRORTRACE((LOG_WBEMCORE, "Sync sink returned success with no objects!\n"));
        return pSink->Return(WBEM_E_CRITICAL_ERROR);
    }
    pResultObj = pSyncSink->GetObjects()[0];
    pSink->Add(pResultObj);
    pSink->Return(WBEM_S_NO_ERROR);

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
// ok
HRESULT CWbemNamespace::ExecNotificationQuery(
    const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext* pCtx,
    IEnumWbemClassObject** ppEnum
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::ExecNotificationQuery\n"
        "   BSTR QueryLanguage = %S\n"
        "   BSTR Query = %S\n"
        "   lFlags = 0x%X\n"
        "   IEnumWbemClassObject **pEnum = 0x%X\n",
        QueryLanguage,
        Query,
        lFlags,
        ppEnum
        ));

    // Validate parameters
    // ===================

    if (ppEnum == NULL)
        return WBEM_E_INVALID_PARAMETER;
    *ppEnum = NULL;

    if ((lFlags & WBEM_FLAG_RETURN_IMMEDIATELY) == 0)
        return WBEM_E_INVALID_PARAMETER;

    if ((lFlags & WBEM_FLAG_FORWARD_ONLY) == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (lFlags
        & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS
        & ~WBEM_RETURN_IMMEDIATELY
        & ~WBEM_FLAG_FORWARD_ONLY
#ifdef _WBEM_WHISTLER_UNCUT
        & ~WBEM_FLAG_MONITOR
#endif
        )
        return WBEM_E_INVALID_PARAMETER;

    // Create Finalizer.
    // =================

    _IWmiFinalizer *pFnz = 0;
    hRes = CreateSyncFinalizer(pCtx, &pFnz);
    if (FAILED(hRes))
        return hRes;
    CReleaseMe _1(pFnz);

    ULONG uTaskType = WMICORE_TASK_EXEC_NOTIFICATION_QUERY;
    if (lFlags & WBEM_RETURN_IMMEDIATELY)
        uTaskType |= WMICORE_TASK_TYPE_SEMISYNC;
    else
        uTaskType |= WMICORE_TASK_TYPE_SYNC;

    // Do the work.
    // ============

    hRes = _ExecNotificationQueryAsync(uTaskType, pFnz, 0, QueryLanguage, Query,
                    lFlags & ~WBEM_RETURN_IMMEDIATELY & ~WBEM_FLAG_FORWARD_ONLY,
                    pCtx, NULL);

    if (FAILED(hRes))
    {
        return hRes;
    }

    if ((lFlags & WBEM_RETURN_IMMEDIATELY) == 0)
        pFnz->GetOperationResult(0, INFINITE, &hRes);

    if (SUCCEEDED(hRes))
    {
        IEnumWbemClassObject* pEnum = NULL;
        hRes = pFnz->GetResultObject(0, IID_IEnumWbemClassObject, (LPVOID*)&pEnum);
        if (FAILED(hRes))
            return hRes;
        CReleaseMe _2(pEnum);

        if (SUCCEEDED(hRes))
        {
            *ppEnum = pEnum;
            pEnum->AddRef();    // Counteract CReleaseMe
        }
    }

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::_ExecNotificationQueryAsync(
    IN ULONG uInternalFlags,
    IN _IWmiFinalizer *pFnz,
    IN _IWmiCoreHandle *phTask,
    IN const BSTR strQueryLanguage,
    IN const BSTR strQuery,
    IN long lFlags,
    IN IWbemContext __RPC_FAR *pCtx,
    IN IWbemObjectSink __RPC_FAR *pHandler
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    if (!Allowed(WBEM_ENABLE))
        return WBEM_E_ACCESS_DENIED;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::_ExecNotificationQueryAsync\n"
        "   BSTR QueryLanguage = %S\n"
        "   BSTR Query = %S\n"
        "   lFlags = 0x%X\n"
        "   IWbemObjectSink* pHandler = 0x%X\n",
        strQueryLanguage,
        strQuery,
        lFlags,
        pHandler
        ));

    // Parameter validation.
    // =====================
    if (pFnz == 0 && pHandler == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (strQueryLanguage == 0 || strQuery == 0 || wcslen(strQueryLanguage) == 0)
        return WBEM_E_INVALID_PARAMETER;
    if( wcslen(strQuery) == 0)
        return WBEM_E_UNPARSABLE_QUERY;

    if (lFlags & ~WBEM_FLAG_SEND_STATUS & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS
#ifdef _WBEM_WHISTLER_UNCUT
            & ~WBEM_FLAG_MONITOR
#endif
        )
        return WBEM_E_INVALID_PARAMETER;

    m_bForClient=FALSE;     // Forces a cheap fast-track

    // Create Finalizer.
    // =================

    IWbemObjectSinkEx *pPseudoSink = 0;
    if (pFnz == 0)
    {
        hRes = CreateAsyncFinalizer(pCtx, pHandler, &pFnz, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
    }
    else // borrowed finalizer
    {
        hRes = pFnz->NewInboundSink(0, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
        pFnz->AddRef();
    }

    CReleaseMe _1(pPseudoSink);
    CReleaseMe _2(pFnz);

    // Add the request to the queue.
    // =============================

    IWbemEventSubsystem_m4* pEss = ConfigMgr::GetEssSink();
    CReleaseMe _3(pEss);
    if (pEss == 0)
    {
        return WBEM_E_NOT_SUPPORTED;  // ESS must be disabled
    }

    // Create an event to return the validation code returned by ESS
    // if the query is valid.
    // =============================================================
    HANDLE hEssValidate = CreateEvent(0, 0, 0, 0);
    if (hEssValidate == 0)
        return WBEM_E_OUT_OF_MEMORY;

    // Enqueue the request.
    // ====================
    HRESULT hResEssCheck = 0;
    CAsyncReq_ExecNotificationQueryAsync *pReq = 0;
    try
    {
        pReq = new CAsyncReq_ExecNotificationQueryAsync(this, pEss, strQueryLanguage,
                        strQuery, lFlags, pPseudoSink, pCtx,
                        &hResEssCheck, hEssValidate
                        );
    }
    catch(...)
    {
        ExceptionCounter c;    
        pReq = 0;
    }

    if (NULL == pReq)
		return WBEM_E_OUT_OF_MEMORY;

	if ( NULL == pReq->GetContext() )
	{
		delete pReq;
		return WBEM_E_OUT_OF_MEMORY;
	}

    hRes = InitNewTask(pReq, pFnz, uInternalFlags, pReq->GetContext(), pHandler);
    if (FAILED(hRes))
    {
        CloseHandle ( hEssValidate );
        delete pReq;
        return hRes;
    }

    _1.release();
    hRes = ConfigMgr::EnqueueRequest(pReq);

    if (FAILED(hRes))
    {
        pFnz->CancelTask ( 0 );
        delete pReq;
        CloseHandle(hEssValidate);
        return hRes;
    }

    // In this case, we have to wait long enough for ESS to accept the task.
    // =====================================================================

    WaitForSingleObject(hEssValidate, INFINITE);    // Lev says this INFINITE thing is okay; who knows
    CloseHandle(hEssValidate);

    // If ESS failed, we should cancel the task
    // ========================================
    if ( FAILED (hResEssCheck) )
    {
        pFnz->CancelTask ( 0 );
    }
    return hResEssCheck;
}


//***************************************************************************
//
//***************************************************************************
// done

HRESULT CWbemNamespace::ExecNotificationQueryAsync(
    IN const BSTR strQueryLanguage,
    IN const BSTR strQuery,
    IN long lFlags,
    IN IWbemContext __RPC_FAR *pCtx,
    IN IWbemObjectSink __RPC_FAR *pHandler
    )
{
    return _ExecNotificationQueryAsync(
        WMICORE_TASK_TYPE_ASYNC | WMICORE_TASK_EXEC_NOTIFICATION_QUERY,
        0, 0,
        strQueryLanguage, strQuery, lFlags, pCtx, pHandler
        );
}



//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::GetImplementationClass(
    IWbemClassObject * pTestClass,
    LPWSTR wszMethodName,
    IWbemContext* pCtx,
    IWbemClassObject ** ppClassObj
    )
{
    try
    {

    // If the method is disabled, or implemented in this class, we are done!
    // =====================================================================

    CVar Var;
    CWbemClass * pClassDef = (CWbemClass *)pTestClass;

    HRESULT hres = pClassDef->GetMethodQualifier(wszMethodName, L"DISABLED", &Var);
    if(hres == S_OK && Var.GetBool() == VARIANT_TRUE)
        return WBEM_E_METHOD_DISABLED;

    hres = pClassDef->GetMethodQualifier(wszMethodName, L"IMPLEMENTED", &Var);
    if(hres == S_OK && Var.GetBool() == VARIANT_TRUE)
    {
        // The test class is correct, return it

        pTestClass->AddRef();
        *ppClassObj = pTestClass;
        return S_OK;
    }
    // Not done, get the name of the parent class.

    SCODE hRes = pClassDef->GetSystemPropertyByName(L"__superclass", &Var);
    if(hRes != S_OK)
        return WBEM_E_CRITICAL_ERROR;

    if(Var.GetType() != VT_BSTR)
        return WBEM_E_METHOD_NOT_IMPLEMENTED; // no superclass --- no implementation

    BSTR bstrParent = Var.GetBSTR();
    if(bstrParent == NULL)
        return WBEM_E_CRITICAL_ERROR; // NULL, but not VT_NULL

    if(wcslen(bstrParent) < 1)
    {
        SysFreeString(bstrParent);
        return WBEM_E_FAILED; // empty parent name????
    }

    IWbemClassObject * pParent = NULL;
    hres = Exec_GetObjectByPath(bstrParent, 0, pCtx, &pParent, NULL);
    SysFreeString(bstrParent);
    if(FAILED(hres))
        return WBEM_E_FAILED; // class provider failure or weird interaction

    hRes = GetImplementationClass(pParent, wszMethodName, pCtx, ppClassObj);
    pParent->Release();
    return hRes;

    }
    catch(...)
    {
        ExceptionCounter c;    
        return WBEM_E_FAILED;
    }
}

//***************************************************************************
//
//  CWbemNamespace::Exec_ExecMethod
//
//  Executes a method.  If the method is not tagged by the [bypass_getobject]
//  qualifier, the method is passed directly to the method provider.  Otherwise,
//  a GetObject call is done first to ensure the instance is valid.
//
//***************************************************************************
//
HRESULT CWbemNamespace::Exec_ExecMethod(
    LPWSTR wszObjectPath,
    LPWSTR wszMethodName,
    long lFlags,
    IWbemClassObject *pInParams,
    IWbemContext *pCtx,
    CBasicObjectSink* pSink
    )
{
    // Lotsa useful variables.
    // =======================

    HRESULT hRes;
    IWbemClassObject* pClassDef = NULL;
    IWbemClassObject* pImplementationClass = NULL;
    IWbemPath *pPath = 0;
    IWbemQualifierSet *pQSet = 0;
    IWbemClassObject* pErrorObj = NULL;
    BOOL bPathIsToClassObject = FALSE;
    LPWSTR pszClassName = 0;
    ULONGLONG uInf = 0;

    // Set up a sink error object and check it.
    // ========================================

    //
    
    //
    COperationError OpInfo(pSink, L"ExecMethod", wszObjectPath);
    if ( !OpInfo.IsOk() )
        return WBEM_E_OUT_OF_MEMORY;

    // Parse the path to the object.
    // =============================

	// Backwards compatibility - parsing a NULL path returns WBEM_E_INVALID_OBJECT_PATH
	if ( NULL == wszObjectPath || NULL == *wszObjectPath )
	{
        return OpInfo.ErrorOccurred( WBEM_E_INVALID_METHOD );
	}

    hRes = m_pCoreSvc->CreatePathParser(0, &pPath);
    if (FAILED(hRes))
        return OpInfo.ErrorOccurred(hRes);
    CReleaseMe _1(pPath);

    hRes = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, wszObjectPath);
    if (FAILED(hRes))
        return OpInfo.ErrorOccurred(hRes);

    ULONG uBuf = 0;
    hRes = pPath->GetClassName(&uBuf, 0);      // Discover the buffer size
    if (FAILED(hRes))
        return OpInfo.ErrorOccurred(hRes);

    pszClassName = new wchar_t[uBuf+1];         // Allocate a buffer for the class name
    if (pszClassName == 0)
        return OpInfo.ErrorOccurred(WBEM_E_OUT_OF_MEMORY);

    wmilib::auto_buffer <wchar_t> _2(pszClassName);   // Auto-delete buffer

    hRes = pPath->GetClassName(&uBuf, pszClassName);    // Get class name
    if (FAILED(hRes))
        return OpInfo.ErrorOccurred(hRes);

    // Find out if a path to an instance or a class.
    // ==============================================
    hRes = pPath->GetInfo(0, &uInf);
    if (FAILED(hRes))
        return OpInfo.ErrorOccurred(hRes);

    if (uInf & WBEMPATH_INFO_IS_INST_REF)
        bPathIsToClassObject = FALSE;
    else
        bPathIsToClassObject = TRUE;

    // Get the class definition.  We'll need it whether or not we validate the
    // instance or not.
    // =======================================================================

    hRes = Exec_GetObjectByPath(pszClassName,
            (lFlags & WBEM_FLAG_USE_AMENDED_QUALIFIERS),  pCtx,
            &pClassDef, &pErrorObj);

    if (FAILED(hRes))
    {
        OpInfo.ErrorOccurred(hRes, pErrorObj);
        if (pErrorObj)
            pErrorObj->Release();
        return hRes;
    }

    CReleaseMe _3(pClassDef);

    // Now see if the method exists and if the class definition
    // has the [bypass_getobject] qualifier on that method.
    // ========================================================

    hRes = pClassDef->GetMethodQualifierSet(wszMethodName, &pQSet);
    if (FAILED(hRes))
	{
		// Means the method doesn't even exist
        if ( WBEM_E_NOT_FOUND == hRes )
        {
            hRes = WBEM_E_INVALID_METHOD;
        }

        return OpInfo.ErrorOccurred(hRes);
	}
    CReleaseMe _4(pQSet);

    hRes = pQSet->Get(L"bypass_getobject", 0, 0, 0);

    if (hRes == WBEM_E_NOT_FOUND)
    {
        // If here, we are going to get the object pointed to by the path first to ensure it is
        // valid. Note that the object may be either an instance or class object
        //
        // First, merge in the __GET_EXT_KEYS_ONLY during the GetObject calls to allow
        // the provider to quickly verify the existence of the object.  We don't
        // actually care about the property values other than the keys. We use
        // a copy of the context object, as we want to merge in KEYS_ONLY behavior
        // for the next call only.
        // ============================================================================
        IWbemClassObject *pVerifiedObj = 0;
        IWbemContext *pCopy = 0;

        if (pCtx)
            pCtx->Clone(&pCopy);
        hRes = MergeGetKeysCtx(pCopy);
        if (FAILED(hRes))
            return OpInfo.ErrorOccurred(hRes);

        // If here, we are verifying the object exists before passing the
        // control to the method handler.
        // ==============================================================

        hRes = Exec_GetObjectByPath(wszObjectPath, lFlags, pCopy,
            &pVerifiedObj, &pErrorObj);

        if (pCopy)
            pCopy->Release();

        if (FAILED(hRes))
        {
            OpInfo.ErrorOccurred(hRes, pErrorObj);
            if (pErrorObj)
                pErrorObj->Release();
            return hRes;
        }

        // If here, the class or instance exists!!
        // =======================================

        pVerifiedObj->Release();
    }
    else if (FAILED(hRes))
    {
        return OpInfo.ErrorOccurred(hRes);
    }


    // If this is the special internal security object, handle it internally
    // ======================================================================

    CVar Value;
    hRes = ((CWbemClass *) pClassDef)->GetSystemPropertyByName(L"__CLASS", &Value);
    if (hRes == S_OK && Value.GetType() == VT_BSTR && !Value.IsDataNull())
       if (!wbem_wcsicmp(Value.GetLPWSTR(), L"__SystemSecurity"))
           return SecurityMethod(wszMethodName, lFlags, pInParams, pCtx, pSink);

    // Make sure we have security.
    // ===========================

    if (!Allowed(WBEM_METHOD_EXECUTE))
        return OpInfo.ErrorOccurred(WBEM_E_ACCESS_DENIED);

    // Now, we locate the exact implementation of the method. After all, the
    // subclass may have been very lazy and relied on its parent implementation,
    // the way many kids rely on their parents for gas money.
    // =========================================================================

    hRes = GetImplementationClass(pClassDef, wszMethodName, pCtx, &pImplementationClass);
    if (FAILED(hRes))
        return OpInfo.ErrorOccurred(hRes);

    // The "pImplementatinClass" now points to the class object where the methods is implemented
    // =========================================================================================

    CReleaseMe rm2(pImplementationClass);
    CWbemClass * pImplementationDef = (CWbemClass*)pImplementationClass;

    // Make sure that class paths are only used with static methods.
    // =============================================================

    CVar Var;
    if (bPathIsToClassObject)
    {
        hRes = pImplementationDef->GetMethodQualifier(wszMethodName, L"STATIC", &Var);
        if (hRes != S_OK || Var.GetBool() != VARIANT_TRUE)
        {
            return OpInfo.ErrorOccurred(WBEM_E_INVALID_METHOD_PARAMETERS);
        }
    }

    // Get the provider name.
    // ======================

    CVar vProv;
    hRes = pImplementationDef->GetQualifier(L"Provider", &vProv);

    if (FAILED(hRes) || vProv.GetType() != VT_BSTR)
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_PROVIDER_REGISTRATION);

    // Adjust the path to reference the class of implementation
    // ========================================================

    CVar vImpClassName;
    hRes = pImplementationDef->GetClassName(&vImpClassName);
    if (FAILED(hRes) || vImpClassName.GetType() != VT_BSTR)
        return OpInfo.ErrorOccurred(WBEM_E_CRITICAL_ERROR);

    BSTR strNewPath = CQueryEngine::AdjustPathToClass(wszObjectPath,
                                                    vImpClassName.GetLPWSTR());
    if (strNewPath == NULL)
        return OpInfo.ErrorOccurred(WBEM_E_CRITICAL_ERROR);

    CSysFreeMe sfm1(strNewPath);

    // Load the provider and execute it.
    // ==================================

    CMethodSink * pMethSink = new CMethodSink(OpInfo.GetSink());
    if(pMethSink == NULL)
       return OpInfo.ErrorOccurred(WBEM_E_OUT_OF_MEMORY);
    pMethSink->AddRef();
    CReleaseMe _5(pMethSink);

    // Find provider.
    // ==============

    IWbemServices *pProv = 0;
    if(m_pProvFact == NULL)
        hRes = WBEM_E_CRITICAL_ERROR;
    else
    {
        WmiInternalContext t_InternalContext ;
        ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

        hRes = m_pProvFact->GetProvider(

            t_InternalContext ,
            0,                  // lFlags
            pCtx,
            0,
            m_wszUserName,
            m_wsLocale,
            0,                      // IWbemPath pointer
            vProv,     // Provider
            IID_IWbemServices,
            (LPVOID *) &pProv
        );
    }

    if (FAILED(hRes))
    {
        return pSink->Return(hRes);
    }

    CReleaseMe _(pProv);

    hRes = pProv->ExecMethodAsync(
        strNewPath,
        wszMethodName,
        lFlags& ~WBEM_FLAG_USE_AMENDED_QUALIFIERS,
        pCtx,
        pInParams,
        pMethSink
        );

    return hRes;
}



//***************************************************************************
//
//  CWbemNamespace::GetOrPutDynProps
//
//  Processes an instance to see if any properties have been marked
//  as 'dynamic'.
//
//  Short-circuit logic is in effect.  The instance as a whole must be
//  marked with the following Qualifier to signal that the instance has
//  dynamic properties which need evaluation:
//
//      "DYNPROPS" (VT_BOOL) = VARIANT_TRUE
//
//  Optionally, the instance may contain:
//      "INSTANCECONTEXT" VT_BSTR = <provider specific string>
//
//  In addition, each dynamic property is marked
//
//      "DYNAMIC"           VT_BOOL     VARIANT_TRUE
//      "LOCATORCLSID"      VT_BSTR     CLSID of the provider
//      "PROPERTYCONTEXT"   VT_BSTR     <provider specific string>
//
//  "INSTANCECONTEXT" and "PROPERTYCONTEXT" are not checked by this code,
//  since they are optional for each provider.
//
//  PARAMETERS:
//
//      IWbemClassObject* pObj       The object to fill in dynamic properties
//                                  in.
//      Operation op                Can be GET or PUT depending on what is
//                                  needed.
//      bool bIsDynamic             True if a dynamically provided class.  Note that it
//                                  would be very strange to have a dynamic class with
//                                  dynamic properties.
//  RETURN VALUES:
//      <WBEM_NO_ERROR>  No provider was involved or if a provider was
//                        involved, properties were all evaluated.
//
//      <WBEM_E_INVALID_OBJECT>
//          Object was marked as dynamic, but other Qualifiers were missing.
//
//      <WBEM_E_PROVIDER_NOT_FOUND>
//          One or more of the specified providers could not be found.
//
//      <WBEM_E_PROVIDER_FAILURE>
//          One or more providers were not able to provide the properties.
//
//      <WBEM_E_CRITICAL_ERROR>
//
//***************************************************************************

HRESULT CWbemNamespace::GetOrPutDynProps(
    IWbemClassObject *pObj,
    Operation op,
    BOOL bIsDynamic
    )
{
    HRESULT hRes;
    IWbemContext *pCtx = 0;
    CVar vDynTest;
    _IWmiDynamicPropertyResolver *pResolver = 0;
    IWbemQualifierSet *pQSet = 0;
    IWbemClassObject *pClassDef = 0;
    CVARIANT v;

    // Examine the instance to see if there are any dynamic properties.
    // ================================================================

    hRes = pObj->GetQualifierSet(&pQSet);
    if (FAILED(hRes))
        return WBEM_NO_ERROR;
    CReleaseMe _1(pQSet);

    hRes = pQSet->Get(L"DYNPROPS", 0, &v, 0);
    if (FAILED(hRes))
        return WBEM_S_NO_ERROR;
    if (v.GetBool() == FALSE)
        return WBEM_S_NO_ERROR;

    v.Clear();
    hRes = pObj->Get(L"__CLASS", 0, &v, 0, 0);
    if (FAILED(hRes))
        return hRes;

    // Get the class definition for the object.
    // Must be static.
    // ========================================

    hRes = CRepository::GetObject(
             m_pSession,
             m_pNsHandle,
             v.GetStr(),
             0,
             &pClassDef
             );

    CReleaseMe _2(pClassDef);
    if (FAILED(hRes))
        return hRes;

    // Access provider subsystem to do the dirty work.
    // ================================================


    if (m_pProvFact == NULL)
        hRes = WBEM_E_CRITICAL_ERROR;
    else
    {
        pCtx = ConfigMgr::GetNewContext();
        if ( pCtx == NULL )
            return WBEM_E_OUT_OF_MEMORY;
            
        hRes = m_pProvFact->GetDynamicPropertyResolver (
                                 0,          // lFlags
                                 pCtx,   // context
                                 m_wszUserName,
                                 m_wsLocale,
                                 IID__IWmiDynamicPropertyResolver,
                                 (LPVOID *)&pResolver);
    }

    CReleaseMe _1_pCtx (pCtx) ;

    if (FAILED(hRes))
        return hRes;

    CReleaseMe _3(pResolver);

    // Determine if a put or a get.
    // ============================

    if (op == GET)
    {
        hRes = pResolver->Read(pCtx, pClassDef, &pObj);
    }
    else if (op == PUT)
    {
        hRes = pResolver->Write(pCtx, pClassDef, pObj);
    }
    else
        return WBEM_E_INVALID_PARAMETER;

    return hRes;
}

//***************************************************************************
//
//  AddKey
//
//  Adds a keyname/value pair to a normalized path
//
//  throw CX_MemoryException
//
//***************************************************************************

HRESULT AddKey(WString & wNormalString, WCHAR * pwsKeyName, VARIANT *pvKeyValue,
                                                            int & iNumKey, CWbemInstance* pClassDef)
{
    if(iNumKey++ > 0)
        wNormalString += L",";              // prepend comma for all but the first key

    wNormalString += pwsKeyName;
    wNormalString += "=";
    if(pvKeyValue->vt == VT_BSTR)
    {
        wNormalString += L"\"";

        // if there are any quotes, they must be prepended with a back slash;
        // Also, any back slashes should be doubled up.

        int iLen = 1;       // one for the terminator;
        WCHAR * pTest;
        for(pTest = pvKeyValue->bstrVal;*pTest; pTest++, iLen++)
            if(*pTest == L'\"' || *pTest == L'\\')
                iLen++;
        WCHAR * pString = new WCHAR[iLen];
        if(pString == NULL)
            throw CX_MemoryException();
        wmilib::auto_buffer<WCHAR> rm_(pString);

        WCHAR * pTo = pString;
        for(pTest = pvKeyValue->bstrVal;*pTest; pTest++, pTo++)
        {
            if(*pTest == L'\"' || *pTest == L'\\')
            {
                *pTo = L'\\';
                pTo++;
            }
            *pTo = *pTest;
        }
        *pTo = 0;

        wNormalString += pString;
        wNormalString += L"\"";
        return S_OK;
    }
    if(pvKeyValue->vt != VT_EMPTY && pvKeyValue->vt != VT_NULL)
    {

        // special case for large unsigned numbers
        if(pvKeyValue->vt == VT_I4 && pvKeyValue->lVal < 0)
        {
            CIMTYPE ct;
            HRESULT hRes = pClassDef->Get(pwsKeyName, 0, NULL, &ct, NULL);
            if(hRes == S_OK && ct == CIM_UINT32)
            {
                WCHAR wBuff[15];
                swprintf(wBuff, L"%u",pvKeyValue->lVal);
                wNormalString += wBuff;
                return S_OK;
            }
        }

        _variant_t var;
        HRESULT hRes = VariantChangeType(&var, pvKeyValue, 0, VT_BSTR);
        if(hRes == S_OK)
        {
            wNormalString += var.bstrVal;
        }

        return hRes;
    }
    return WBEM_E_INVALID_OBJECT_PATH;
}

//***************************************************************************
//
//  NormalizeObjectPath
//
//  Creates a normalized object path for passing to providers.
//***************************************************************************

HRESULT NormalizeObjectPath(ParsedObjectPath*pOutput, WString & wNormalString,
                            CWbemInstance* pClassDef)
{
    try
    {
        HRESULT hRes;

        // For singleton, so long as the class is singleton

        if(pOutput->m_bSingletonObj)
        {
            CVar Singleton;
            hRes = pClassDef->GetQualifier(L"SINGLETON", &Singleton);
            if (hRes == 0 && Singleton.GetBool() != 0)
            {
                wNormalString = pOutput->m_pClass;
                wNormalString += "=@";
                return S_OK;
            }
            else
                return WBEM_E_INVALID_OBJECT_PATH;
        }

        int iKeyNum = 0;
        int iNumMatch = 0;          // number of keys in the path which were found in the class def

        // Start off by writting the class name followe by a dot

        wNormalString = pOutput->m_pClass;
        wNormalString += L".";

        CWStringArray ClassKeyNames;
        if(!pClassDef->GetKeyProps(ClassKeyNames))
            return WBEM_E_INVALID_CLASS;

        // For each key in the class definition

        for(int iClassKey = 0; iClassKey < ClassKeyNames.Size(); iClassKey++)
        {
            // look for the class key in the path

            bool bClassKeyIsInPath = false;
            int iPathKey;

            for(iPathKey = 0; iPathKey < pOutput->m_dwNumKeys; iPathKey++)
            {
                KeyRef * key = pOutput->m_paKeys[iPathKey];
                if(key->m_pName == 0 && ClassKeyNames.Size() == 1 && pOutput->m_dwNumKeys==1)
                {
                    bClassKeyIsInPath = true;
                    break;
                }
                else if(key->m_pName && !wbem_wcsicmp(key->m_pName, ClassKeyNames[iClassKey]))
                {
                    bClassKeyIsInPath = true;
                    break;
                }
            }
            if(bClassKeyIsInPath)
            {
                iNumMatch++;
                // todo, check type

                KeyRef * key = pOutput->m_paKeys[iPathKey];
                hRes = AddKey(wNormalString, ClassKeyNames[iClassKey],
                                      &key->m_vValue, iKeyNum, pClassDef);
                if(FAILED(hRes))
                    return hRes;
            }
            else
            {
                // If the key has a default value, then use it
                _variant_t var;
                hRes = pClassDef->Get(ClassKeyNames[iClassKey], 0, &var, NULL, NULL);
                if(FAILED(hRes) || var.vt == VT_EMPTY || var.vt == VT_NULL)
                    return WBEM_E_INVALID_OBJECT_PATH;
                hRes = AddKey(wNormalString, ClassKeyNames[iClassKey], &var, iKeyNum,pClassDef);
                if(FAILED(hRes))
                    return hRes;
            }
        }

        if(iNumMatch == pOutput->m_dwNumKeys)
            return S_OK;
        else
            return WBEM_E_INVALID_OBJECT_PATH;
    }
    catch (CX_MemoryException &)
    {

        return WBEM_E_OUT_OF_MEMORY;
    }
}

//***************************************************************************
//
//  CWbemNamespace::DynAux_GetInstance
//
//  Retrieves an instance identified by its path from the dynamic provider
//  registered for that class.
//
//  PARAMETERS:
//
//      IN DWORD  dwNamespace             Namespace handle to the current
//                                        namespace (see objdb.h)
//      IN LPWSTR pObjectPath             Object path to the instance.
//      IN long lFlags                    Flags. Propagated to provider.
//      OUT IWbemClassObject** pObj        Destination for the class definition.
//                                        The caller must release this object
//                                        if the call is successful.
//      OUT IWbemClassObject** ppErrorObj  Destination for the error object. May
//                                        be NULL. Otherwise, the returned
//                                        pointer must be released if not NULL.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              Success.
//      WBEM_E_NOT_FOUND             No such instance, says provider, or the
//                                  class is not dynamic.
//      WBEM_E_INVALID_PARAMETER     One or more parameters are invalid.
//      WBEM_E_INVALID_CLASS         The class specified in the path does not
//                                  exist.
//      WBEM_E_FAILED                Unexpected error occured.
//      WBEM_E_PROVIDER_NOT_FOUND    Provider for this class could not be
//                                  located --- not registered with us or COM.
//      WBEM_E_PROVIDER_FAILURE      Provider reported an error while looking
//                                  for this object.
//      WBEM_E_PROVIDER_NOT_CAPABLE  Provider for this class is not capable of
//                                  getting objects by path.
//
//***************************************************************************

HRESULT CWbemNamespace::DynAux_GetInstance(
    IN LPWSTR wszObjectPath,
    IN long lFlags,
    IN IWbemContext* pCtx,
    IN CBasicObjectSink* pSink
    )
{
    // Parse the object path to get the class involved.
    // ================================================
    ParsedObjectPath* pOutput = 0;

    CObjectPathParser p;
    int nStatus = p.Parse(wszObjectPath,  &pOutput);

    if (nStatus != 0 || !pOutput->IsInstance())
        return pSink->Return(WBEM_E_INVALID_OBJECT_PATH);

    // See if this class is actually provided dynamically
    // ==================================================

    CWbemInstance *pClassDef = 0;

    IWbemClassObject* pClassObj = NULL;

    BSTR strClass = SysAllocString(pOutput->m_pClass);
    CSysFreeMe sfm(strClass);

    HRESULT hres = Exec_GetObjectByPath(strClass,
                            lFlags & WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                            pCtx,&pClassObj, NULL);
    if(FAILED(hres))
    {
        p.Free(pOutput);
        return pSink->Return((hres == WBEM_E_NOT_FOUND) ? WBEM_E_INVALID_CLASS : WBEM_E_FAILED);
    }

    CReleaseMe rm(pClassObj);
    pClassDef = (CWbemInstance*)pClassObj;

    WString wNormalPath;
    hres = NormalizeObjectPath(pOutput, wNormalPath, pClassDef);
    p.Free(pOutput);
    if(FAILED(hres))
        return pSink->Return(hres);

    if(!pClassDef->IsKeyed())
        return pSink->Return(WBEM_E_INVALID_CLASS);

    // Make sure that this class is not static ---
    // i.e. either dynamic or abstract
    // ===========================================

    CVar vDynamic;
    hres = pClassDef->GetQualifier(L"Dynamic", &vDynamic);
    if(FAILED(hres) || vDynamic.GetType() != VT_BOOL || !vDynamic.GetBool())
    {
        // Not dynamic. Check if it is abstract
        // ====================================

        CVar vAbstract;
        hres = pClassDef->GetQualifier(L"Abstract", &vAbstract);
        if(FAILED(hres) || vAbstract.GetType() != VT_BOOL || !vAbstract.GetBool())
            return pSink->Return(WBEM_E_NOT_FOUND);
    }

    // Build the class hierarchy
    // =========================

    CDynasty* pDynasty;
    IWbemClassObject* pErrorObj = NULL;
    hres = DynAux_BuildClassHierarchy(strClass, lFlags, pCtx, &pDynasty,
                &pErrorObj);

    if(FAILED(hres))
    {
        hres = pSink->Return(hres, pErrorObj);
        if(pErrorObj)
            pErrorObj->Release();
        return hres;
    }

    // If direct read is requested, only ask the provider in question.
    // ===============================================================

    if (lFlags & WBEM_FLAG_DIRECT_READ)
    {
        DynAux_GetSingleInstance((CWbemClass*) pClassObj,
             lFlags, wszObjectPath, pCtx, pSink);
    }
    else
    {
        // Create merging sink
        // ===================

        CSingleMergingSink* pMergeSink = new CSingleMergingSink(pSink, strClass);
        if(pMergeSink == NULL)
            return pSink->Return(WBEM_E_OUT_OF_MEMORY);
        pMergeSink->AddRef();

        // Ask all providers
        // =================

        DynAux_AskRecursively(pDynasty, lFlags, wNormalPath, pCtx,
            pMergeSink);
        pMergeSink->Release();
    }

    delete pDynasty;
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::DynAux_AskRecursively(CDynasty* pDynasty,
                                              long lFlags,
                                              LPWSTR wszObjectPath,
                                              IWbemContext* pCtx,
                                              CBasicObjectSink* pSink)
{
    // Convert the path to the new class
    // =================================

    BSTR strNewPath = CQueryEngine::AdjustPathToClass(wszObjectPath,
        pDynasty->m_wszClassName);
    if(strNewPath == NULL)
        return pSink->Return(WBEM_E_INVALID_OBJECT_PATH);

    // Get this provider's object
    // ==========================

    DynAux_GetSingleInstance((CWbemClass*)pDynasty->m_pClassObj,
        lFlags, strNewPath, pCtx, pSink);
    SysFreeString(strNewPath);

    if(pDynasty->m_pChildren == NULL)
    {
        // That was that
        // =============

        return WBEM_S_NO_ERROR;
    }

    // Get the children's objects
    // ==========================

    for(int i = 0; i < pDynasty->m_pChildren->Size(); i++)
    {
        CDynasty* pChildDyn = (CDynasty*)pDynasty->m_pChildren->GetAt(i);

        DynAux_AskRecursively(pChildDyn, lFlags, wszObjectPath, pCtx,
                                pSink);
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::DynAux_GetSingleInstance(CWbemClass* pClassDef,
                                                 long lFlags,
                                                 LPWSTR wszObjectPath,
                                                 IWbemContext* pCtx,
                                                 CBasicObjectSink* pSink)
{
    //
    
    //
    COperationError OpInfo(pSink, L"GetObject", wszObjectPath, FALSE);

    // Check that the sink allocations succeeded
    if ( !OpInfo.IsOk() )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    // Verify that the class is indeed dynamic
    // =======================================

    if(!pClassDef->IsDynamic())
        return OpInfo.ErrorOccurred(WBEM_E_NOT_FOUND);

    CVar vProvName;
    HRESULT hres = pClassDef->GetQualifier(L"Provider", &vProvName);
    if(FAILED(hres) || vProvName.GetType() != VT_BSTR)
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_PROVIDER_REGISTRATION);

    OpInfo.SetProviderName(vProvName.GetLPWSTR());

    // Access the provider cache.
    // ==========================

    IWbemServices *pProv = 0;
    HRESULT hRes;
    if(m_pProvFact == NULL)
        hRes = WBEM_E_CRITICAL_ERROR;
    else
    {
        WmiInternalContext t_InternalContext ;
        ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

        hRes = m_pProvFact->GetProvider(

            t_InternalContext ,
            0,                  // lFlags
            pCtx,
            0,
            m_wszUserName,
            m_wsLocale,
            0,                      // IWbemPath pointer
            vProvName,     // Provider
            IID_IWbemServices,
            (LPVOID *) &pProv
        );
    }

    if (FAILED(hRes))
    {
     return pSink->Return(hRes);
    }

    CReleaseMe _(pProv);
    CDecoratingSink * pDecore = new CDecoratingSink(OpInfo.GetSink(), this);
    if(pDecore == NULL)
        return pSink->Return(WBEM_E_OUT_OF_MEMORY);
    pDecore->AddRef();
    CReleaseMe cdecor(pDecore);

//    taskprintf("Accessing Provider->GetObjectAsync='%S'", wszObjectPath);

    hRes = pProv->GetObjectAsync(wszObjectPath, lFlags& ~WBEM_FLAG_USE_AMENDED_QUALIFIERS, pCtx, pDecore);

    return hRes;
}

//***************************************************************************
//
//  CWbemNamespace::DynAux_GetInstances
//
//  Gets all instances from the provider specified in the class
//  definition.  Does no inheritance joins; this is a simple retrieval
//  of all instances from the specified class.
//
//  Preconditions:
//  1. The class <pClassDef> is known to be marked 'dynamic', but no
//     other verification has been done on the class definition.
//  2. <pClassDef> is not NULL.
//
//  Postconditions:
//  1. <aInstances> is empty on all error conditions.
//
//  PARAMETERS:
//
//      READONLY CWbemObject *pClassDef  The definition of the class to retrieve
//                                      instances of.
//      long lFlags                     The flags (deep/shallow)
//      CFlexArray &aInstances          Destination for the instances.
//      IWbemClassObject** ppErrorObj    Destination for the error object. If
//                                      not NULL, an error object may be placed
//                                      here. It is the caller's responsibility
//                                      to release it if not NULL.
//  RETURN VALUES:
//
//      WBEM_NO_ERROR  No errors. This includes a no-error situation
//                  with zero instances returned.
//      WBEM_E_INVALID_PROVIDE_REGISTRATION  Provider registration for this
//                                          class is incomplete.
//      WBEM_E_PROVIDER_NOT_FOUND    Provider could not be located. It is not
//                                  registered with us or with COM.
//      WBEM_E_PROVIDER_NOT_CAPABLE  Provider is not capable of enumerating
//                                  instances.
//      WBEM_E_FAILED                Unexpected error has occured.
//
//***************************************************************************

HRESULT CWbemNamespace::DynAux_GetInstances(

    READONLY CWbemObject *pClassDef,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pSink ,
    BOOL bComplexQuery
)
{

	// First, get the current task - if there isn't one, something
	// is very wrong.

	CWbemRequest*		pCurrReq = CWbemQueue::GetCurrentRequest();

	_DBG_ASSERT( NULL != pCurrReq && NULL != pCurrReq->m_phTask );

	if ( NULL == pCurrReq || NULL == pCurrReq->m_phTask )
	{
		return WBEM_E_FAILED;
	}

	_IWmiFinalizer*	pMainFnz = NULL;
	
	// We'll need the finalizer in case we need to cancel something
	HRESULT	hr = ((CWmiTask*) pCurrReq->m_phTask)->GetFinalizer( &pMainFnz );
	CReleaseMe	rm( pMainFnz );

	if ( SUCCEEDED( hr ) )
	{
		CWmiMerger*				pWmiMerger = NULL;

		// Check if query arbitration is enabled
		if ( ConfigMgr::GetEnableQueryArbitration() )
		{
			// Get the arbitrated query pointer and cast to a merger as appropriate
			_IWmiArbitratedQuery*	pArbQuery = NULL;

			hr = ((CWmiTask*) pCurrReq->m_phTask)->GetArbitratedQuery( 0L, &pArbQuery );

			if ( SUCCEEDED( hr ) )
			{
				hr = pArbQuery->IsMerger();

				if ( SUCCEEDED( hr ) )
				{
					pWmiMerger = (CWmiMerger*) pArbQuery;
				}
				else
				{
					pArbQuery->Release();
				}
			}

			// Clear errors
			hr = WBEM_S_NO_ERROR;

		}	// IF Query arbitration enabled

		// Auto cleanup
		CReleaseMe	rm( (_IWmiArbitratee*) pWmiMerger );

		// Perform correct handling based on whether or not we have a merger
		if ( NULL != pWmiMerger )
		{

			hr = pWmiMerger->RegisterArbitratedInstRequest( pClassDef, lFlags, pCtx, pSink,	bComplexQuery, this );

			if ( FAILED( hr ) )
			{
				pMainFnz->CancelTask( 0 );
			}

			
		}	// If NULL != pWmiMerger
		else
		{
            CAsyncReq_DynAux_GetInstances *pReq = 0;
            try
            {
                 pReq = new CAsyncReq_DynAux_GetInstances (
				    this,
				    pClassDef,
				    lFlags,
	    			pCtx,
    				pSink
		    	    );
            }
            catch(...)
            {
		        ExceptionCounter c;            
                pReq = 0;
            }

			if ( pReq == NULL)
			{
				pMainFnz->CancelTask ( 0 );
				return WBEM_E_OUT_OF_MEMORY;
			}

			if ( NULL == pReq->GetContext() )
			{
				pMainFnz->CancelTask ( 0 );
				delete pReq;
				return WBEM_E_OUT_OF_MEMORY;
			}

			// Set the task for the request - we'll just use the existing one
			pCurrReq->m_phTask->AddRef();
			pReq->m_phTask = pCurrReq->m_phTask;
			
			hr = ConfigMgr::EnqueueRequest(pReq);

			if (FAILED(hr))
			{
				pMainFnz->CancelTask ( 0 );
				delete pReq;
			}

		}

	}	// IF Got finalizer

    return hr;

}

//***************************************************************************
//
//  CWbemNamespace::DynAux_GetInstances
//
//  Gets all instances from the provider specified in the class
//  definition.  Does no inheritance joins; this is a simple retrieval
//  of all instances from the specified class.
//
//  Preconditions:
//  1. The class <pClassDef> is known to be marked 'dynamic', but no
//     other verification has been done on the class definition.
//  2. <pClassDef> is not NULL.
//
//  Postconditions:
//  1. <aInstances> is empty on all error conditions.
//
//  PARAMETERS:
//
//      READONLY CWbemObject *pClassDef  The definition of the class to retrieve
//                                      instances of.
//      long lFlags                     The flags (deep/shallow)
//      CFlexArray &aInstances          Destination for the instances.
//      IWbemClassObject** ppErrorObj    Destination for the error object. If
//                                      not NULL, an error object may be placed
//                                      here. It is the caller's responsibility
//                                      to release it if not NULL.
//  RETURN VALUES:
//
//      WBEM_NO_ERROR  No errors. This includes a no-error situation
//                  with zero instances returned.
//      WBEM_E_INVALID_PROVIDE_REGISTRATION  Provider registration for this
//                                          class is incomplete.
//      WBEM_E_PROVIDER_NOT_FOUND    Provider could not be located. It is not
//                                  registered with us or with COM.
//      WBEM_E_PROVIDER_NOT_CAPABLE  Provider is not capable of enumerating
//                                  instances.
//      WBEM_E_FAILED                Unexpected error has occured.
//
//***************************************************************************

HRESULT CWbemNamespace::Exec_DynAux_GetInstances(
    READONLY CWbemObject *pClassDef,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pSink
    )
{
    //
    
    //
    COperationError OpInfo(pSink, L"CreateInstanceEnum", L"", FALSE);
    CVar vProv;
    CVar vClassName;

    // Check that the sink allocations succeeded
    if ( !OpInfo.IsOk() )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    // Get the provider name.
    // ======================

    try // internal fastprox interfaces throw
    {
        HRESULT hres = pClassDef->GetQualifier(L"Provider", &vProv);
        if (FAILED(hres) || vProv.GetType() != VT_BSTR)
            return OpInfo.ErrorOccurred(WBEM_E_INVALID_PROVIDER_REGISTRATION);
        if (FAILED(pClassDef->GetClassName(&vClassName)))
        	return pSink->Return(WBEM_E_OUT_OF_MEMORY);
        OpInfo.SetParameterInfo(vClassName.GetLPWSTR());
    }
    catch(CX_MemoryException &)
    {
        return pSink->Return(WBEM_E_OUT_OF_MEMORY);
    }

    // Access Provider Subsystem.
    // ==========================

    IWbemServices *pProv = 0;
    HRESULT hRes;

    if (m_pProvFact == NULL)
        hRes = WBEM_E_CRITICAL_ERROR;
    else
    {
        try
        {
            WmiInternalContext t_InternalContext ;
            ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

            hRes = m_pProvFact->GetProvider(
                t_InternalContext ,
                0,                  // lFlags
                pCtx,
                0,
                m_wszUserName,
                m_wsLocale,
                0,                      // IWbemPath pointer
                vProv,     // Provider
                IID_IWbemServices,
                (LPVOID *) &pProv
            );
        }
        catch(...)
        {
	        ExceptionCounter c;        
            hRes = WBEM_E_CRITICAL_ERROR;
        }
    }

    if (FAILED(hRes))
         return pSink->Return(hRes);
    CReleaseMe _1(pProv);

    // Set up the sink chain to be delivered to the provider.
    // The code & destruct sequence is critical and the
    // refcounting is very carefully thought out.  Do not
    // change this code unless you know exactly what you are
    // doing.  And don't even change it then.
    // ======================================================

    CProviderSink *pProvSink = new CProviderSink(1, vClassName.GetLPWSTR());
    if (pProvSink == 0)
        return pSink->Return(WBEM_E_OUT_OF_MEMORY);
    CReleaseMe _3(pProvSink);

    CDecoratingSink * pDecore = new CDecoratingSink(pSink, this);
    if (pDecore == NULL)
        return pSink->Return(WBEM_E_OUT_OF_MEMORY);
    pProvSink->SetNextSink(pDecore);

    // Before calling the provider, map the provider to the
    // task so that we can cancel it proactively, if required.
    // =======================================================

    try
    {
        hRes = ((CWmiArbitrator *) m_pArb)->MapProviderToTask(0, pCtx, pProv, pProvSink);
        if (FAILED(hRes))
            return pSink->Return(hRes);
    }
    catch(...)
    {
        ExceptionCounter c;    
        return pSink->Return(WBEM_E_CRITICAL_ERROR);
    }

//    taskprintf("Accessing Provider->CreateInstanceEnumAsync='%S'", vClassName.GetLPWSTR());

    // Now tell the provider to start enumerating.
    // ===========================================

    try
    {
        hRes = pProv->CreateInstanceEnumAsync(
            vClassName.GetLPWSTR(),
            lFlags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS,
            pCtx,
            pProvSink
            );
    }
    catch(...)
    {
        ExceptionCounter c;    
        return pSink->Return(WBEM_E_CRITICAL_ERROR);
    }

    return hRes;
}

//***************************************************************************
//
//  CWbemNamespace::DynAux_ExecQueryAsync
//
//  Executes a SQL-1 query against a dynamic instance provider for the class
//  in the query.
//
//  PARAMETERS:
//
//      IN DWORD dwNamespace            Namespace handle to the current
//                                      namespace (see objdb.h)
//      IN CWbemObject* pClassDef        Class definition of the class in the
//                                      query. Must be dynamic.
//      IN LPWSTR Query                 The query string.
//      IN LPWSTR QueryFormat           The query language. Must be WQL.
//      IN long lFlags                  The flags. Not used.
//      OUT CFlexArray &aInstances      Destinatino for the instances found.
//      OUT IWbemClassObject** ppErrorObj Destination for the error object. IF
//                                      not NULL, an error object may be placed
//                                      here. In this case, it is the caller's
//                                      responsibility to release it.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR                  Success (even though there may not be
//                                      any instances).
//      WBEM_E_INVALID_PROVIDE_REGISTRATION  Provider registration for this
//                                          class is incomplete.
//      WBEM_E_PROVIDER_NOT_FOUND    Provider could not be located. It is not
//                                  registered with us or with COM.
//      WBEM_E_PROVIDER_NOT_CAPABLE  Provider is not capable of enumerating
//                                  instances.
//      WBEM_E_FAILED                Unexpected error has occured.
//
//***************************************************************************

HRESULT CWbemNamespace::DynAux_ExecQueryAsync (

    CWbemObject* pClassDef,
    LPWSTR Query,
    LPWSTR QueryFormat,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pSink,
    BOOL bComplexQuery
)
{
	// First, get the current task - if there isn't one, something
	// is very wrong.

	CWbemRequest*		pCurrReq = CWbemQueue::GetCurrentRequest();

	_DBG_ASSERT( NULL != pCurrReq && NULL != pCurrReq->m_phTask );

	if ( NULL == pCurrReq || NULL == pCurrReq->m_phTask )
	{
		return WBEM_E_FAILED;
	}

	// We'll need the finalizer in case we need to cancel something
	_IWmiFinalizer*	pMainFnz = NULL;
	
	HRESULT	hr = ((CWmiTask*) pCurrReq->m_phTask)->GetFinalizer( &pMainFnz );
	CReleaseMe	rm( pMainFnz );

	if ( SUCCEEDED( hr ) )
	{
		CWmiMerger*				pWmiMerger = NULL;

		// Check if query arbitration is enabled
		if ( ConfigMgr::GetEnableQueryArbitration() )
		{
			// Get the arbitrated query pointer and cast to a merger as appropriate
			_IWmiArbitratedQuery*	pArbQuery = NULL;

			hr = ((CWmiTask*) pCurrReq->m_phTask)->GetArbitratedQuery( 0L, &pArbQuery );

			if ( SUCCEEDED( hr ) )
			{
				hr = pArbQuery->IsMerger();

				if ( SUCCEEDED( hr ) )
				{
					pWmiMerger = (CWmiMerger*) pArbQuery;
				}
				else
				{
					pArbQuery->Release();
				}
			}

			// Clear errors
			hr = WBEM_S_NO_ERROR;

		}	// IF Query arbitration enabled

		// Auto cleanup
		CReleaseMe	rm( (_IWmiArbitratee*) pWmiMerger );

		// Perform correct handling based on whether or not we have a merger
		if ( NULL != pWmiMerger )
		{
			hr = pWmiMerger->RegisterArbitratedQueryRequest( pClassDef, lFlags, Query, QueryFormat, pCtx, pSink, this );

			if (FAILED(hr))
			{
				pMainFnz->CancelTask ( 0 );
			}

		}
		else
		{
            CAsyncReq_DynAux_ExecQueryAsync *pReq = 0;
            try
            {
                pReq = new CAsyncReq_DynAux_ExecQueryAsync (
				    this,
				    pClassDef,
				    Query,
				    QueryFormat,
				    lFlags,
				    pCtx,
				    pSink
			    );
            }
            catch(...)
            {
		        ExceptionCounter c;            
                pReq = 0;
            }

			if (pReq == NULL)
			{
				pMainFnz->CancelTask ( 0 );
				return WBEM_E_OUT_OF_MEMORY;
			}

			if ( NULL == pReq->GetContext() )
			{
				pMainFnz->CancelTask ( 0 );
				delete pReq;
				return WBEM_E_OUT_OF_MEMORY;
			}

			hr = pReq->Initialize () ;
			if ( SUCCEEDED ( hr ) )
			{

				// Set the task for the request - we'll just use the existing one
				pCurrReq->m_phTask->AddRef();
				pReq->m_phTask = pCurrReq->m_phTask;
				
				hr = ConfigMgr::EnqueueRequest(pReq);

				if (FAILED(hr))
				{
					pMainFnz->CancelTask ( 0 );
					delete pReq;
				}

			}	// IF Request Initialized
			else
			{
				pMainFnz->CancelTask ( 0 );
				delete pReq;
			}

		}

    }

	return hr;
}

//***************************************************************************
//
//  CWbemNamespace::DynAux_ExecQueryAsync
//
//  Executes a SQL-1 query against a dynamic instance provider for the class
//  in the query.
//
//  PARAMETERS:
//
//      IN DWORD dwNamespace            Namespace handle to the current
//                                      namespace (see objdb.h)
//      IN CWbemObject* pClassDef        Class definition of the class in the
//                                      query. Must be dynamic.
//      IN LPWSTR Query                 The query string.
//      IN LPWSTR QueryFormat           The query language. Must be WQL.
//      IN long lFlags                  The flags. Not used.
//      OUT CFlexArray &aInstances      Destinatino for the instances found.
//      OUT IWbemClassObject** ppErrorObj Destination for the error object. IF
//                                      not NULL, an error object may be placed
//                                      here. In this case, it is the caller's
//                                      responsibility to release it.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR                  Success (even though there may not be
//                                      any instances).
//      WBEM_E_INVALID_PROVIDE_REGISTRATION  Provider registration for this
//                                          class is incomplete.
//      WBEM_E_PROVIDER_NOT_FOUND    Provider could not be located. It is not
//                                  registered with us or with COM.
//      WBEM_E_PROVIDER_NOT_CAPABLE  Provider is not capable of enumerating
//                                  instances.
//      WBEM_E_FAILED                Unexpected error has occured.
//
//***************************************************************************

HRESULT CWbemNamespace::Exec_DynAux_ExecQueryAsync (

    CWbemObject* pClassDef,
    LPWSTR Query,
    LPWSTR QueryFormat,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pSink
)
{
    //    
    //
    COperationError OpInfo(pSink, L"ExecQuery", Query, FALSE);

    // Check that the sink allocations succeeded
    if ( !OpInfo.IsOk() )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    // Get the provider name.
    // ======================

    CVar vProv;
    HRESULT hres = pClassDef->GetQualifier(L"Provider", &vProv);
    if (FAILED(hres) || vProv.GetType() != VT_BSTR)
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_PROVIDER_REGISTRATION);

    // Access the provider cache.
    // ==========================

    IWbemServices *pProv = 0;
    HRESULT hRes;
    if(m_pProvFact == NULL)
        hRes = WBEM_E_CRITICAL_ERROR;
    else
    {
        WmiInternalContext t_InternalContext ;
        ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

        hRes = m_pProvFact->GetProvider(

            t_InternalContext ,
            0,                  // lFlags
            pCtx,
            0,
            m_wszUserName,
            m_wsLocale,
            0,                      // IWbemPath pointer
            vProv,     // Provider
            IID_IWbemServices,
            (LPVOID *) &pProv
            );
    }

    if (FAILED(hRes))
    {
        return pSink->Return(hRes);
    }

    CReleaseMe _1(pProv);

    // Set up the sink chain to be delivered to the provider.
    // The code & destruct sequence is critical and the
    // refcounting is very carefully thought out.  Do not
    // change this code unless you know exactly what you are
    // doing.  And don't even change it then.
    // ======================================================

    CProviderSink *pProvSink = new CProviderSink(1, Query);
    if (pProvSink == 0)
        return pSink->Return(WBEM_E_OUT_OF_MEMORY);
    CReleaseMe _3(pProvSink);

    CDecoratingSink * pDecore = new CDecoratingSink(pSink, this);
    if (pDecore == NULL)
        return pSink->Return(WBEM_E_OUT_OF_MEMORY);
    pProvSink->SetNextSink(pDecore);

    // Before calling the provider, map the provider to the
    // task so that we can cancel it proactively, if required.
    // =======================================================

    try
    {
        hRes = ((CWmiArbitrator *) m_pArb)->MapProviderToTask(0, pCtx, pProv, pProvSink);
        if (FAILED(hRes))
            return pSink->Return(hRes);
    }
    catch(...)
    {
        ExceptionCounter c;    
        return pSink->Return(WBEM_E_CRITICAL_ERROR);
    }

    // Now tell the provider to start enumerating.
    // ===========================================

    try
    {
        hRes = pProv->ExecQueryAsync(QueryFormat, Query, lFlags& ~WBEM_FLAG_USE_AMENDED_QUALIFIERS,
            pCtx, pProvSink);
    }
    catch(...)
    {
        ExceptionCounter c;    
        return pSink->Return(WBEM_E_CRITICAL_ERROR);
    }

    return hRes;
}

//***************************************************************************
//
//  CWbemNamespace::DynAux_ExecQueryAsync
//
//  Executes a SQL-1 query against a dynamic instance provider for the class
//  in the query.
//
//  PARAMETERS:
//
//      IN DWORD dwNamespace            Namespace handle to the current
//                                      namespace (see objdb.h)
//      IN CWbemObject* pClassDef        Class definition of the class in the
//                                      query. Must be dynamic.
//      IN LPWSTR Query                 The query string.
//      IN LPWSTR QueryFormat           The query language. Must be WQL.
//      IN long lFlags                  The flags. Not used.
//      OUT CFlexArray &aInstances      Destinatino for the instances found.
//      OUT IWbemClassObject** ppErrorObj Destination for the error object. IF
//                                      not NULL, an error object may be placed
//                                      here. In this case, it is the caller's
//                                      responsibility to release it.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR                  Success (even though there may not be
//                                      any instances).
//      WBEM_E_INVALID_PROVIDE_REGISTRATION  Provider registration for this
//                                          class is incomplete.
//      WBEM_E_PROVIDER_NOT_FOUND    Provider could not be located. It is not
//                                  registered with us or with COM.
//      WBEM_E_PROVIDER_NOT_CAPABLE  Provider is not capable of enumerating
//                                  instances.
//      WBEM_E_FAILED                Unexpected error has occured.
//
//***************************************************************************

HRESULT CWbemNamespace::DynAux_ExecQueryExtendedAsync(

    LPWSTR wsProvider,
    LPWSTR Query,
    LPWSTR QueryFormat,
    long lFlags,
    IWbemContext* pCtx,
    CComplexProjectionSink* pSink
)
{
    //
    // BUGBU can throw
    //
    COperationError OpInfo(pSink, L"ExecQuery", Query, FALSE);

    // Check that the sink allocations succeeded
    if ( !OpInfo.IsOk() )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    // Access the provider cache.
    // ==========================

    IWbemServices *pProv = 0;
    HRESULT hRes;
    if(m_pProvFact == NULL)
        hRes = WBEM_E_CRITICAL_ERROR;
    else
    {
        WmiInternalContext t_InternalContext ;
        ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

        hRes = m_pProvFact->GetProvider(

            t_InternalContext ,
            0,                  // lFlags
            pCtx,
            0,
            m_wszUserName,
            m_wsLocale,
            0,                      // IWbemPath pointer
            wsProvider,              // provider name
            IID_IWbemServices,
            (LPVOID *) &pProv
        );
    }

    if (FAILED(hRes))
    {
        return pSink->Return(hRes);
    }

    CReleaseMe _(pProv);

    _IWmiProviderConfiguration *t_Configuration = NULL ;
    hRes = pProv->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & t_Configuration ) ;
    if ( SUCCEEDED ( hRes ) )
    {
        CReleaseMe _1(t_Configuration);

        VARIANT t_Variant ;
        VariantInit ( & t_Variant ) ;

        hRes = t_Configuration->Query (

            this ,
            lFlags& ~WBEM_FLAG_USE_AMENDED_QUALIFIERS ,
            pCtx ,
            WBEM_PROVIDER_CONFIGURATION_CLASS_ID_INSTANCE_PROVIDER_REGISTRATION ,
            WBEM_PROVIDER_CONFIGURATION_PROPERTY_ID_EXTENDEDQUERY_SUPPORT ,
            & t_Variant
        ) ;

        if ( SUCCEEDED ( hRes ) )
        {
            if ( t_Variant.boolVal == VARIANT_TRUE )
            {
                CDecoratingSink * pDecore = new CDecoratingSink(pSink, this);
                if(pDecore == NULL)
                    return pSink->Return(WBEM_E_OUT_OF_MEMORY);
                pDecore->AddRef();
                CReleaseMe cdecor(pDecore);

                hRes = pProv->ExecQueryAsync(QueryFormat, Query, lFlags& ~WBEM_FLAG_USE_AMENDED_QUALIFIERS, pCtx, pDecore);
            }
            else
            {
                hRes = WBEM_E_INVALID_QUERY ;
            }

            VariantClear ( & t_Variant ) ;
        }
        else
        {
            hRes = WBEM_E_UNEXPECTED ;
        }
    }
    else
    {
        hRes = WBEM_E_UNEXPECTED ;
    }

    return hRes;
}

//***************************************************************************
//
//  CWbemNamespace::Static_QueryRepository
//
//  Performs query against the repository.  This only happens if there is an
//	associated task.  If not, then we execute the query on the same thread.
//
//  PARAMETERS:
//
//      READONLY CWbemObject *pClassDef  The definition of the class to retrieve
//                                      instances of.
//      long lFlags                     The flags (deep/shallow)
//		
//  RETURN VALUES:
//
//      WBEM_NO_ERROR  No errors. This includes a no-error situation
//                  with zero instances returned.
//      WBEM_E_INVALID_PROVIDE_REGISTRATION  Provider registration for this
//                                          class is incomplete.
//      WBEM_E_PROVIDER_NOT_FOUND    Provider could not be located. It is not
//                                  registered with us or with COM.
//      WBEM_E_PROVIDER_NOT_CAPABLE  Provider is not capable of enumerating
//                                  instances.
//      WBEM_E_FAILED                Unexpected error has occured.
//
//***************************************************************************

HRESULT CWbemNamespace::Static_QueryRepository(

    READONLY CWbemObject *pClassDef,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pSink ,
	QL_LEVEL_1_RPN_EXPRESSION* pParsedQuery,
	LPCWSTR pwszClassName,
	CWmiMerger* pWmiMerger
)
{

	HRESULT	hr = WBEM_S_NO_ERROR;

	// First, get the current task and request.  If there isn't one, we're most
	// likely being called on an ESS callback, and will just perform the call on
	// this thread.

	CWbemRequest*		pCurrReq = CWbemQueue::GetCurrentRequest();

	if ( NULL != pCurrReq && NULL != pCurrReq->m_phTask && ConfigMgr::GetEnableQueryArbitration() )
	{
		// We'll need the finalizer in case we need to cancel something
		_IWmiFinalizer*	pMainFnz = NULL;
		
		HRESULT	hr = ((CWmiTask*) pCurrReq->m_phTask)->GetFinalizer( &pMainFnz );
		CReleaseMe	rm( pMainFnz );

		if ( SUCCEEDED( hr ) )
		{

			hr = pWmiMerger->RegisterArbitratedStaticRequest( pClassDef, lFlags, pCtx, pSink, this, pParsedQuery );

			if (FAILED(hr))
			{
				pMainFnz->CancelTask ( 0 );
			}

		}	// IF Got Finalizer

		// In the case of an error we should do a setstatus of the error.  Otherwise, the setstatus will occur
		// when the new request is processed.
		if ( FAILED( hr ) )
		{
			pSink->SetStatus( 0L, hr, 0L, NULL );
		}

/*
		int nRes = CQueryEngine::ExecAtomicDbQuery(
					GetNsSession(),
					GetNsHandle(),
					GetScope(),
					pwszClassName,
					pParsedQuery,
					pSink,
					this );

		if (nRes == CQueryEngine::invalid_query)
			hr = WBEM_E_INVALID_QUERY;
		else if(nRes != 0)
			hr = WBEM_E_FAILED;
		else
			hr = WBEM_S_NO_ERROR;

		pSink->SetStatus( 0L, hr, 0L, NULL );
*/
	}
	else
	{
		// If we're here, then we should disallow merger specific throttling since
		// this request is happening through an internal thread without following
		// the request/task hierarchy, meaning that there shouldn't be a hierarchy
		// we need to worry about for this class, so don't let the merger do any
		// internal throttling

		pWmiMerger->EnableMergerThrottling( false );

		int nRes = CQueryEngine::ExecAtomicDbQuery(
					GetNsSession(),
					GetNsHandle(),
					GetScope(),
					pwszClassName,
					pParsedQuery,
					pSink,
					this );

		if (nRes == CQueryEngine::invalid_query)
			hr = WBEM_E_INVALID_QUERY;
		else if(nRes != 0)
			hr = WBEM_E_FAILED;
		else
			hr = WBEM_S_NO_ERROR;

		pSink->SetStatus( 0L, hr, 0L, NULL );

	}

	return hr;
}

//***************************************************************************
//
//  CWbemNamespace::DecorateObject
//
//  Sets the origin information on a given object to reflect this namespace
//  and this server. See CWbemObject::Decorate in fastobj.h for details.
//  THIS FUNCTION CAN ONLY DECORATE CWbemObject POINTERS, NOT OTHER PEOPLE'S
//  IMPLEMENTATIONS of IWbemClassObject.
//
//  PARAMETERS:
//
//      IWbemClassObject* pObject        The object to decorate.
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              Success
//      WBEM_E_INVALID_PARAMETER     pObject == NULL.
//
//***************************************************************************

HRESULT CWbemNamespace::DecorateObject(IWbemClassObject* pObject)
{
    if(pObject == NULL)
        return WBEM_E_INVALID_PARAMETER;

    ((CWbemObject*)pObject)->Decorate(
        ConfigMgr::GetMachineName(),
        m_pThisNamespace);

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

typedef std::map<LPWSTR, CDynasty*, wcsiless, wbem_allocator<CDynasty*> > CCDynastyMap;

HRESULT AddAllMembers(CDynasty* pDynasty, CCDynastyMap& Map)
{
    // Catch any exceptions the allocator might throw
    try
    {
        Map[pDynasty->m_wszClassName] = pDynasty;
    }
    catch(CX_MemoryException &)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    HRESULT hr = WBEM_S_NO_ERROR;

    CFlexArray* pChildren = pDynasty->m_pChildren;
    if(pChildren)
    {
        for(int i = 0; SUCCEEDED(hr) && i < pChildren->Size(); i++)
        {
            hr = AddAllMembers((CDynasty*)pChildren->GetAt(i), Map);
        }
    }

    return hr;
}


//***************************************************************************
//
//  CWbemNamespace::DynAux_BuildClassHierarchy
//
//  Recursively builds the hierarchy of classes derived from a given one.
//  The structure used to represent the hierarchy -- CDynasty is described
//  in objdb.h
//
//  PARAMETERS:
//
//      IN LPWSTR wszClassName      The name of the parent class.
//      IN LONG lFlags              If SHALLOW, just the class itself is
//                                  returned. If DEEP, recursive enumeration
//                                  is performed.
//      OUT CDynasty** ppDynasty  Destination for the tree. The caller must
//                                  delete the pointer on success.
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              Success
//      Any of the return values returned by GetObject or CreateClassEnum,
//      as documented in the help file.
//
//***************************************************************************

HRESULT CWbemNamespace::DynAux_BuildClassHierarchy(
                                              IN LPWSTR wszClassName,
                                              IN LONG lFlags,
                                              IN IWbemContext* pCtx,
                                              OUT CDynasty** ppDynasty,
                                              OUT IWbemClassObject** ppErrorObj)
{
    HRESULT hres;
    *ppDynasty = NULL;
    *ppErrorObj = NULL;

    // Get the list of classes from all class providers
    // ================================================

    CSynchronousSink* pSyncSink = new CSynchronousSink;
    if(pSyncSink == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pSyncSink->AddRef();
    CReleaseMe rm1(pSyncSink);

    hres = Exec_CreateClassEnum(wszClassName,
        lFlags | WBEM_FLAG_NO_STATIC, pCtx,
        pSyncSink
    );
    pSyncSink->Block();
    pSyncSink->GetStatus(&hres, NULL, ppErrorObj);

    if(FAILED(hres))
        return hres;

    // Get the static dynasty
    // ======================

    CDynasty* pMainDynasty;

    HRESULT hRes = CRepository::BuildClassHierarchy(
        m_pSession,
        m_pNsHandle,
        wszClassName,
        lFlags & WBEM_MASK_DEPTH,
        &pMainDynasty
        );

    if (hRes == WBEM_E_NOT_FOUND)
    {
        IWbemClassObject* pObj;
        HRESULT hres = Exec_GetObjectByPath(wszClassName, lFlags, pCtx,
                                            &pObj, ppErrorObj);
        if(FAILED(hres))
            return hres;
        pMainDynasty = new CDynasty((CWbemObject*)pObj);
        if(pMainDynasty == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        if(pMainDynasty->m_pClassObj == NULL)
        {
            delete pMainDynasty;
            ERRORTRACE((LOG_WBEMCORE, "Provider returned invalid class for %S!\n",
                wszClassName));
            return WBEM_E_PROVIDER_FAILURE;
        }
        pObj->Release();
    }
    else if (FAILED(hRes))
    {
        return hRes;
    }

    CRefedPointerArray<IWbemClassObject> &rProvidedClasses =
        pSyncSink->GetObjects();

    // Create a map of class names to their dynasties
    // ==============================================

    CCDynastyMap mapClasses;
    hres = AddAllMembers(pMainDynasty, mapClasses);

    if ( FAILED(hres))
    {
        return hres;
    }

    typedef std::vector<CDynasty*, wbem_allocator<CDynasty*> > CDynastyPtrArray;

    CDynastyPtrArray aProvidedDyns;

    try
    {
        aProvidedDyns.reserve(rProvidedClasses.GetSize());
    }
    catch(CX_MemoryException &)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    for(int i = 0; i < rProvidedClasses.GetSize(); i++)
    {
        CDynasty* pNew = new CDynasty((CWbemObject*)rProvidedClasses[i]);
        if(pNew == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        if(pNew->m_pClassObj == NULL)
        {
            delete pNew;
            ERRORTRACE((LOG_WBEMCORE, "Provider returned invalid class!\n"));
            continue;
        }

        // The vector or the map may throw exceptions
        try
        {
            mapClasses[pNew->m_wszClassName] = pNew;
            aProvidedDyns.push_back(pNew);
        }
        catch(CX_MemoryException &)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

    }

    // Go through it once and add all classes to their parent's dynasty
    // ================================================================

    for(CDynastyPtrArray::iterator it = aProvidedDyns.begin();
        it != aProvidedDyns.end(); it++)
    {
        CDynasty* pDyn = *it;
        CVar vParent;
        CWbemObject *pObj = (CWbemObject *) pDyn->m_pClassObj;

        if(FAILED(pObj->GetSuperclassName(&vParent)) ||
                            vParent.IsNull())
        {
            ERRORTRACE((LOG_WBEMCORE,"Provider returned top-level class %S as a child "
                "of %S\n", pDyn->m_wszClassName, wszClassName));
            continue;
        }

        CCDynastyMap::iterator itParent =
            mapClasses.find(vParent.GetLPWSTR());

        if((itParent == mapClasses.end()))
        {
            if(wbem_wcsicmp(pDyn->m_wszClassName, wszClassName))
            {
                ERRORTRACE((LOG_WBEMCORE,"Provider returned class %S without parent!\n",
                    vParent.GetLPWSTR()));
            }
            continue;
        }
        CDynasty* pParentDyn = itParent->second;
        pParentDyn->AddChild(pDyn);
    }

    // Build the chain up to the highest keyed parent
    // ==============================================

    hres = DynAux_BuildChainUp(pMainDynasty, pCtx, ppDynasty, ppErrorObj);
    if(FAILED(hres))
    {
        delete pMainDynasty;
        *ppDynasty = NULL;
    }

    return hres;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::DynAux_BuildChainUp(IN CDynasty* pOriginal,
                                            IN IWbemContext* pCtx,
                                            OUT CDynasty** ppTop,
                                            OUT IWbemClassObject** ppErrorObj)
{
    *ppTop = pOriginal;
    *ppErrorObj = NULL;

    // Go up while there is a key at this level and we are dynamic
    // ===========================================================

    while((*ppTop)->IsDynamic() && (*ppTop)->IsKeyed())
    {
        CVar vParentName;
        CWbemObject *pObj = (CWbemObject *) (*ppTop)->m_pClassObj;

        if(FAILED(pObj->GetSuperclassName(&vParentName)) ||
                vParentName.IsNull())
        {
            // Top level --- time to quit
            // ==========================
            break;
        }

        IWbemClassObject* pParent;
        HRESULT hres = Exec_GetObjectByPath(vParentName.GetLPWSTR(), 0,
                                            pCtx,
                                            &pParent,  ppErrorObj);
        if(FAILED(hres))
            return hres;

        if(pParent == NULL)
            return WBEM_E_PROVIDER_FAILURE;

        // SJS - Amendment is the same as Abstract
        if(!((CWbemClass*)pParent)->IsKeyed() ||
            ((CWbemClass*)pParent)->IsAbstract() ||
            ((CWbemClass*)pParent)->IsAmendment() )
        {
            // We are it
            // =========

            pParent->Release();
            break;
        }

        // Extend the dynasty by this class
        // ================================

        CDynasty* pNew = new CDynasty(pParent);
        if (pNew == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        pParent->Release();
        if(pNew->m_pClassObj == NULL)
        {
            delete pNew;
            return WBEM_E_PROVIDER_FAILURE;
        }

        pNew->AddChild(*ppTop);
        *ppTop = pNew;
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::IsPutRequiredForClass(CWbemClass* pClass,
                            CWbemInstance* pInst, IWbemContext* pCtx,
                            BOOL bParentTakenCareOf)
{
    HRESULT hres;

    // Get the per-property put information out of the context
    // =======================================================

    BOOL bRestrictedPut = FALSE;
    BOOL bStrictNulls = FALSE;
    BOOL bPropertyList = FALSE;
    CWStringArray awsProperties;

    hres = GetContextPutExtensions(pCtx, bRestrictedPut, bStrictNulls,
                                bPropertyList, awsProperties);
    if(FAILED(hres))
        return hres;

    if(bRestrictedPut && bStrictNulls && !bPropertyList)
    {
        // All properties must be put, even the NULL ones
        // ==============================================

        return WBEM_S_NO_ERROR;
    }

    // Enumerate all properties of the class
    // =====================================

    long lEnumFlags = 0;
    if(bParentTakenCareOf)
    {
        // Only look at local (non-propagated) properties
        // ==============================================
        lEnumFlags = WBEM_FLAG_LOCAL_ONLY;
    }
    else
    {
        // We are in charge of our parent's properties
        // ===========================================
        lEnumFlags = WBEM_FLAG_NONSYSTEM_ONLY;
    }

    pClass->BeginEnumeration(lEnumFlags);
    BSTR strName = NULL;
    while((hres = pClass->Next(0, &strName, NULL, NULL, NULL)) == S_OK)
    {
        hres = DoesNeedToBePut(strName, pInst, bRestrictedPut,
                            bStrictNulls, bPropertyList, awsProperties);
        SysFreeString(strName);
        if(hres == WBEM_S_NO_ERROR)
        {
            // Found a needed property
            // =======================

            return WBEM_S_NO_ERROR;
        }
        if(FAILED(hres))
            return hres;
    }

    // No properties of this class need to be put
    // ==========================================

    return WBEM_S_FALSE;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::DoesNeedToBePut(LPCWSTR wszName, CWbemInstance* pInst,
            BOOL bRestrictedPut, BOOL bStrictNulls, BOOL bPropertyList,
            CWStringArray& awsProperties)
{
    HRESULT hres;

    // Check if the property is a key
    // ==============================

    CVar vKey;
    pInst->GetPropQualifier((LPWSTR)wszName, L"key", &vKey);
    if(vKey.GetType() == VT_BOOL && vKey.GetBool())
    {
        // It's a key --- no such thing as updating its value, and this code
        // only applies to updates.
        // =================================================================

        return WBEM_S_FALSE;
    }

    // Determine if NULLness and or membership in the list play any role
    // =================================================================

    BOOL bCheckNullness = FALSE;
    BOOL bCheckMembership = FALSE;

    if(bRestrictedPut)
    {
        bCheckNullness = !bStrictNulls;
        bCheckMembership = bPropertyList;
    }
    else
    {
        bCheckNullness = TRUE;
        bCheckMembership = FALSE;
    }

    // Check NULLness and/or membership if required
    // ============================================

    BOOL bNullnessChecked = FALSE;
    BOOL bMembershipChecked = FALSE;

    if(bCheckNullness)
    {
        CVar vVal;
        hres = pInst->GetNonsystemPropertyValue((LPWSTR)wszName, &vVal);
        if(FAILED(hres))
            return hres;

        bNullnessChecked = !vVal.IsNull();
    }
    else
        bNullnessChecked = TRUE;

    if(bCheckMembership)
    {
        int nIndex = awsProperties.FindStr(wszName, CWStringArray::no_case);
        bMembershipChecked = (nIndex >= 0);
    }
    else
        bMembershipChecked = TRUE;

    // Make sure that both NULLness and membership either checked out or were
    // not required
    // ======================================================================

    if(bMembershipChecked && bNullnessChecked)
    {
        return WBEM_S_NO_ERROR;
    }
    else
    {
        return WBEM_S_FALSE;
    }
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::GetContextPutExtensions(IWbemContext* pCtx,
            BOOL& bRestrictedPut, BOOL& bStrictNulls, BOOL& bPropertyList,
            CWStringArray& awsProperties)
{
    HRESULT hres;

    if(pCtx == NULL)
    {
        //
        // Default is: no restructions, which makes the rest of the properties
        // irrelevant
        //

        bRestrictedPut = FALSE;
        return WBEM_S_NO_ERROR;
    }

    // Initialize out-params
    // =====================

    bRestrictedPut = FALSE;
    bStrictNulls = FALSE;
    bPropertyList = FALSE;
    awsProperties.Empty();

    // Check if the context is even present
    // ====================================

    if(pCtx == NULL)
        return WBEM_S_NO_ERROR;

    // Check if put extensions are specified
    // =====================================

    hres = GetContextBoolean(pCtx, L"__PUT_EXTENSIONS", &bRestrictedPut);
    if(FAILED(hres)) return hres;

    if(!bRestrictedPut)
        return WBEM_S_NO_ERROR;

    // Check if NULLs are strict
    // =========================

    hres = GetContextBoolean(pCtx, L"__PUT_EXT_STRICT_NULLS",
                &bStrictNulls);
    if(FAILED(hres)) return hres;

    // Check if the list of properties is available
    // ============================================

    VARIANT v;
    VariantInit(&v);
    CClearMe cm1(&v);

    hres = pCtx->GetValue(L"__PUT_EXT_PROPERTIES", 0, &v);
    if(FAILED(hres))
    {
        if(hres == WBEM_E_NOT_FOUND)
        {
            return WBEM_S_NO_ERROR;
        }
        else
        {
            ERRORTRACE((LOG_WBEMCORE, "Error retrieving list of properties "
                        "from context: %X\n", hres));
            return hres;
        }
    }

    if(V_VT(&v) != (VT_BSTR | VT_ARRAY))
    {
        ERRORTRACE((LOG_WBEMCORE, "Invalid type is used for "
            "the list of properties in the context: must be "
            "string array.  The value will be ignored\n"));
        return WBEM_S_NO_ERROR;
    }

    bPropertyList = TRUE;

    // Transfer property names to the array
    // ====================================

    CSafeArray saProperties(V_ARRAY(&v), VT_BSTR,
                    CSafeArray::no_delete | CSafeArray::bind);

    for(int i = 0; i < saProperties.Size(); i++)
    {
        BSTR strProp = saProperties.GetBSTRAt(i);
        awsProperties.Add(strProp);
        SysFreeString(strProp);
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::GetContextBoolean(IWbemContext* pCtx,
                LPCWSTR wszName, BOOL* pbValue)
{
    HRESULT hres;
    *pbValue = FALSE;

    //
    // NULL context means "FALSE"
    //

    if(pCtx == NULL)
        return WBEM_S_NO_ERROR;

    VARIANT v;
    VariantInit(&v);
    CClearMe cm1(&v);

    hres = pCtx->GetValue((LPWSTR)wszName, 0, &v);
    if(FAILED(hres))
    {
        if(hres == WBEM_E_NOT_FOUND)
        {
            return WBEM_S_NO_ERROR;
        }
        else
        {
            ERRORTRACE((LOG_WBEMCORE, "Error retrieving context property %S:"
                        " %X\n", wszName, hres));
            return hres;
        }
    }

    if(V_VT(&v) != VT_BOOL)
    {
        ERRORTRACE((LOG_WBEMCORE, "Invalid type is used for "
            "%S property of the context: must be "
            "boolean.  The value will be ignored\n", wszName));
        return WBEM_S_NO_ERROR;
    }

    if(V_BOOL(&v) != VARIANT_TRUE)
    {
        return WBEM_S_NO_ERROR;
    }

    *pbValue = TRUE;
    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CWbemNamespace::FindKeyRoot(LPCWSTR wszClassName,
                                IWbemClassObject** ppKeyRootClass)
{
    //
    // Check if the namespace is still valid (returns if not)
    //
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    //
    // Call on the database to do the job
    //

    hRes = CRepository::FindKeyRoot(m_pSession, m_pNsHandle, wszClassName, ppKeyRootClass);

    return hRes;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CWbemNamespace::GetNormalizedPath( BSTR pstrPath,
                                                BSTR* pstrStandardPath )
{
    //
    // Check if the namespace is still valid (returns if not)
    //
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    //
    // check parameters.
    //

    if ( NULL == pstrPath || NULL == pstrStandardPath )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT hres;
    *pstrStandardPath = NULL;

    // Parse it
    // ========

    CObjectPathParser Parser;
    ParsedObjectPath* pPath;

    int nRes = Parser.Parse(pstrPath, &pPath);

    if( nRes != CObjectPathParser::NoError )
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    CDeleteMe<ParsedObjectPath> dm(pPath);

    //
    // Figure out the class that defined the key
    //

    IWbemClassObject* pKeyRootClass = NULL;

    hres = FindKeyRoot(pPath->m_pClass, &pKeyRootClass);

    if(FAILED(hres))
    {
        return hres;
    }

    CReleaseMe rm(pKeyRootClass);

    _IWmiObject* pWmiObject = NULL;
    hres = pKeyRootClass->QueryInterface(IID__IWmiObject, (void**)&pWmiObject);

    if(FAILED(hres))
    {
        return hres;
    }

    CReleaseMe rm1(pWmiObject);

    long    lHandle = 0L;
    ULONG   uFlags = 0L;
    WCHAR   wszClassName[64];
    DWORD   dwBuffSize = 64;
    DWORD   dwBuffUsed = 0;
    BOOL    fNull = FALSE;
    LPWSTR  pwszName = wszClassName;
    LPWSTR  pwszDelete = NULL;

    // Try to read in the class name.  Allocate a buffer if we have to.
    hres = pWmiObject->ReadProp( L"__CLASS", 0L, dwBuffSize, NULL, NULL, &fNull, &dwBuffUsed, pwszName );

    if ( FAILED( hres ) )
    {
        if ( WBEM_E_BUFFER_TOO_SMALL == hres )
        {
            pwszName = new WCHAR[dwBuffUsed/2];

            if ( NULL == pwszName )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
            else
            {
                dwBuffSize = dwBuffUsed;

                // Try to read in the class name.  Allocate a buffer if we have to.
                hres = pWmiObject->ReadProp( L"__CLASS", 0L, dwBuffSize, NULL, NULL, &fNull, &dwBuffUsed, pwszName );

                if ( FAILED( hres ) )
                {
                    delete [] pwszName;
                    return hres;
                }

                // Allows for scoped cleanup only if we alloctaed something
                pwszDelete = pwszName;
            }
        }
        else
        {
            return hres;
        }
    }

    //
    // Ensures proper cleanup.  If we didn't allocate a buffer to delete,
    // this pointer will be NULL.
    //
    CVectorDeleteMe<WCHAR> vdm1(pwszDelete);

    // oop
    if ( fNull )
    {
        return WBEM_E_INVALID_OPERATION;
    }

    //
    // want to normalize out the single key prop exception
    //

    if ( pPath->m_dwNumKeys == 1 )
    {
        delete pPath->m_paKeys[0]->m_pName;
        pPath->m_paKeys[0]->m_pName = NULL;
    }

    //
    // set the normalized class on the path if different
    // than the one in the path.
    //

    if ( _wcsicmp( pPath->m_pClass, pwszName ) != 0 )
    {
        if ( !pPath->SetClassName( pwszName ) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    //
    // now unparse the normalized path
    //

    LPWSTR wszNormPath;

    nRes = CObjectPathParser::Unparse( pPath, &wszNormPath );

    if ( nRes != CObjectPathParser::NoError )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    *pstrStandardPath = SysAllocString( wszNormPath );

    delete wszNormPath;

    return *pstrStandardPath != NULL ? WBEM_S_NO_ERROR : WBEM_E_OUT_OF_MEMORY;
}

class CRevertCallSec
{
    BOOL m_bEnabled;
    IUnknown * m_pCallSec;
public:
	CRevertCallSec(BOOL bEnabled,IUnknown * pCallSec):
		m_bEnabled(bEnabled),
		m_pCallSec(pCallSec){};
	~CRevertCallSec(){
	    if (m_bEnabled){
	    	IUnknown * pOld = NULL;
	    	CoSwitchCallContext(m_pCallSec,&pOld);
	    }	
	};
};

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CWbemNamespace::InternalGetClass(
            LPCWSTR wszClassName,
            IWbemClassObject** ppClass)
{
    IWbemContext *pContext = NULL ;

    CWbemRequest* pReq = CWbemQueue::GetCurrentRequest() ;
    if (pReq == NULL)
    {
        pContext = ConfigMgr::GetNewContext();
        if ( pContext == NULL )
            return WBEM_E_OUT_OF_MEMORY;
    }
    else
    {
        pContext = pReq->GetContext();
        pContext->AddRef () ;   //for CReleaseMe
    }

    CReleaseMe _1_pContext (pContext) ;

    HRESULT hr;

    // determine if there is a call context.  If there is, then we
    // dont do anything.

    IServerSecurity * pSec = NULL;
    IWbemCallSecurity * pCallSec = NULL;
    IUnknown * pOld = NULL, *pNew = NULL;
    hr = CoGetCallContext(IID_IServerSecurity, (void**)&pSec);
    if(SUCCEEDED(hr))
    {
        pSec->Release();
    }
    else
    {
        // provider subsystem needs a call context, so create on
        
        pCallSec = CWbemCallSecurity::CreateInst();
        if(pCallSec == NULL)
            return WBEM_E_OUT_OF_MEMORY;
    }
    CReleaseMe rm(pCallSec);

    // initialize call security for provider sub system
    
    if(pCallSec)
    {
        hr = pCallSec->CloneThreadContext(TRUE);
        if(FAILED(hr))
            return hr;
        hr = CoSwitchCallContext(pCallSec, &pOld);
        if(FAILED(hr))
            return hr;
    }
    CRevertCallSec Revert(pCallSec?TRUE:FALSE,pOld);

    hr = Exec_GetObjectByPath((LPWSTR)wszClassName, 0, pContext, ppClass, NULL);

    return hr;
}

//***************************************************************************
//
//***************************************************************************
/*
int __cdecl CWbemNamespace::taskprintf(const char *fmt, ...)
{
    CWbemRequest* pReq = CWbemQueue::GetCurrentRequest() ;
    if (pReq == NULL)
        return 0;

    CWmiTask *pTask = (CWmiTask *) pReq->m_phTask;
    if (pTask == 0)
        return 0;

    char buffer[2048];

    va_list argptr;
    int cnt;
    va_start(argptr, fmt);
    cnt = _vsnprintf(buffer, 2047, fmt, argptr);
    va_end(argptr);

    pTask->printf("%s", buffer);

    return cnt;
}
*/


//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CWbemNamespace::InternalGetInstance(
            LPCWSTR wszPath,
            IWbemClassObject** ppInstance)
{
    IWbemContext *pContext = NULL ;

    CWbemRequest* pReq = CWbemQueue::GetCurrentRequest() ;
    if (pReq == NULL)
    {
        pContext = ConfigMgr::GetNewContext();
        if ( pContext == NULL )
            return WBEM_E_OUT_OF_MEMORY;
    }
    else
    {
        pContext = pReq->GetContext();
        pContext->AddRef () ;   //for CReleaseMe
    }

    CReleaseMe _1_pContext (pContext) ;

    return Exec_GetObjectByPath((LPWSTR)wszPath, 0, pContext, ppInstance, NULL);
}

//***************************************************************************
//
//***************************************************************************

class CSimpleWrapperSink : public CBasicObjectSink
{
protected:
    IWbemObjectSink* m_pDest;
public:
    CSimpleWrapperSink(IWbemObjectSink* pDest) : m_pDest(pDest){}
    ~CSimpleWrapperSink(){}

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray)
    {
        return m_pDest->Indicate(lObjectCount, pObjArray);
    }
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam)
    {
        return m_pDest->SetStatus(lFlags, lParam, strParam, pObjParam);
    }
    STDMETHOD_(ULONG, AddRef)()
    {
        return m_pDest->AddRef();
    }
    STDMETHOD_(ULONG, Release)()
    {
        return m_pDest->Release();
    }
};

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CWbemNamespace::InternalExecQuery(
             LPCWSTR wszQueryLanguage,
             LPCWSTR wszQuery,
             long lFlags,
             IWbemObjectSink* pSink)
{
    IWbemContext *pContext = NULL ;

    CWbemRequest* pReq = CWbemQueue::GetCurrentRequest() ;
    if (pReq == NULL)
    {
        pContext = ConfigMgr::GetNewContext();
        if ( pContext == NULL )
            return WBEM_E_OUT_OF_MEMORY;
    }
    else
    {
        pContext = pReq->GetContext();
        pContext->AddRef () ;   //for CReleaseMe
    }

    CReleaseMe _1_pContext (pContext) ;

    CSimpleWrapperSink ws(pSink);
    return CQueryEngine::ExecQuery(this, (LPWSTR)wszQueryLanguage,
                (LPWSTR)wszQuery, lFlags, pContext, &ws);
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CWbemNamespace::InternalCreateInstanceEnum(
             LPCWSTR wszClassName,
             long lFlags,
             IWbemObjectSink* pSink)
{
    IWbemContext *pContext = NULL ;

    CWbemRequest* pReq = CWbemQueue::GetCurrentRequest() ;
    if (pReq == NULL)
    {
        pContext = ConfigMgr::GetNewContext();
        if ( pContext == NULL )
            return WBEM_E_OUT_OF_MEMORY;
    }
    else
    {
        pContext = pReq->GetContext();
        pContext->AddRef () ;   //for CReleaseMe
    }

    CReleaseMe _1_pContext (pContext) ;

    CSimpleWrapperSink ws(pSink);
    return Exec_CreateInstanceEnum((LPWSTR)wszClassName, lFlags, pContext, &ws);
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CWbemNamespace::InternalPutInstance(
             IWbemClassObject* pInst)
{
    IWbemContext *pContext = NULL ;

    CWbemRequest* pReq = CWbemQueue::GetCurrentRequest() ;
    if (pReq == NULL)
    {
        pContext = ConfigMgr::GetNewContext();
        if ( pContext == NULL )
            return WBEM_E_OUT_OF_MEMORY;
    }
    else
    {
        pContext = pReq->GetContext();
        pContext->AddRef () ;   //for CReleaseMe
    }

    CReleaseMe _1_pContext (pContext) ;

    CSynchronousSink* pSink = new CSynchronousSink;
    if(pSink == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pSink->AddRef();
    CReleaseMe rm1(pSink);

    Exec_PutInstance(pInst, 0, pContext, pSink);

    HRESULT hres = WBEM_E_CRITICAL_ERROR;
    pSink->GetStatus(&hres, NULL, NULL);
    return hres;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CWbemNamespace::GetDbInstance(
             LPCWSTR wszDbKey,
             IWbemClassObject** ppInstance
             )
{
    return CRepository::GetObject(m_pSession, m_pScopeHandle, wszDbKey, 0, ppInstance);
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CWbemNamespace::GetDbReferences(
             IWbemClassObject* pEndpoint,
             IWbemObjectSink* pSink)
{
    LPWSTR wszRelPath = ((CWbemObject*)pEndpoint)->GetRelPath();
    CVectorDeleteMe<WCHAR> dm(wszRelPath);

    CSimpleWrapperSink ws(pSink);

    HRESULT hRes = CRepository::GetInstanceRefs(m_pSession,m_pScopeHandle, wszRelPath, &ws);

    return hRes;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::InternalPutStaticClass(
             IWbemClassObject* pClass)
{
    IWbemContext *pContext = NULL ;

    CWbemRequest* pReq = CWbemQueue::GetCurrentRequest() ;
    if (pReq == NULL)
    {
        pContext = ConfigMgr::GetNewContext();
        if ( pContext == NULL )
            return WBEM_E_OUT_OF_MEMORY;
    }
    else
    {
        pContext = pReq->GetContext();
        pContext->AddRef () ;   //for CReleaseMe
    }

    CReleaseMe _1_pContext (pContext) ;

    CSynchronousSink* pSink = new CSynchronousSink;
    if(pSink == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pSink->AddRef();
    CReleaseMe rm1(pSink);

    Exec_PutClass( pClass, 0, pContext, pSink, TRUE );

    HRESULT hres = WBEM_E_CRITICAL_ERROR;
    pSink->GetStatus(&hres, NULL, NULL);
    return hres;
}


//***************************************************************************
//
//  CWbemNamespace::AdjustPutContext
//
//***************************************************************************

HRESULT CWbemNamespace::AdjustPutContext(
    IWbemContext *pCtx
    )
{
    // See if per-property puts are being used.
    // ========================================

    HRESULT hRes;

    if (pCtx == 0)
        return WBEM_S_NO_ERROR;

    CVARIANT v;
    hRes = pCtx->GetValue(L"__PUT_EXTENSIONS", 0, &v);

    if (SUCCEEDED(hRes))
    {
        // If here, they are being used.  Next we have to check and see
        // if the reentrancy flag is set or not.
        // =============================================================

        hRes = pCtx->GetValue(L"__PUT_EXT_CLIENT_REQUEST", 0, &v);
        if (SUCCEEDED(hRes))
        {
            pCtx->DeleteValue(L"__PUT_EXT_CLIENT_REQUEST", 0);
            return WBEM_S_NO_ERROR;
        }

        // If here, we have to clear out the put extensions.
        // =================================================
        pCtx->DeleteValue(L"__PUT_EXTENSIONS", 0);
        pCtx->DeleteValue(L"__PUT_EXT_CLIENT_REQUEST", 0);
        pCtx->DeleteValue(L"__PUT_EXT_ATOMIC", 0);
        pCtx->DeleteValue(L"__PUT_EXT_PROPERTIES", 0);
        pCtx->DeleteValue(L"__PUT_EXT_STRICT_NULLS", 0);
    }

    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//  CWbemNamespace::MergeGetKeysCtx
//
//***************************************************************************
//
HRESULT CWbemNamespace::MergeGetKeysCtx(
    IN IWbemContext *pCtx
    )
{
    HRESULT hRes;
    if (pCtx == 0)
        return WBEM_S_NO_ERROR;
    CVARIANT v;
    v.SetBool(TRUE);
    hRes = pCtx->SetValue(L"__GET_EXTENSIONS", 0, &v);
    hRes |= pCtx->SetValue(L"__GET_EXT_KEYS_ONLY", 0, &v);
    hRes |= pCtx->SetValue(L"__GET_EXT_CLIENT_REQUEST", 0, &v);
    return hRes;
}






//***************************************************************************
//
//  CWbemNamespace::CheckNs
//
//  Does a quick check on the available system resources before allowing
//  a new call to proceed.  Retries for 30 seconds.
//
//***************************************************************************
//
HRESULT CWbemNamespace::CheckNs()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (g_bDontAllowNewConnections || m_bShutDown)
    {
        return WBEM_E_SHUTTING_DOWN;
    }

    // Quick memory check. If we are strapped for RAM/Pagefile,
    // wait a while and try again. Requirements are 1 meg of
    // available RAM and 1 meg of available page file.

    int nRetries = 0;

    for (int i = 0; i < 30; i++)
    {
        MEMORYSTATUS ms;
        GlobalMemoryStatus(&ms);

        if (ms.dwMemoryLoad < 99)
            return WBEM_S_NO_ERROR;

        // If here, we have to be careful.  The system is loaded at 99%.
        // =============================================================
        if (nRetries > 30)
        {
            // Sixty seconds waiting for enough memory. Give up.
            return WBEM_E_OUT_OF_MEMORY;
        }

        DWORD dwPracticalMemory = ms.dwAvailPhys + ms.dwAvailPageFile;

        if (dwPracticalMemory < 0x200000)   // 2 meg
        {
            Sleep(2000);
            // Try a 1 meg allocation to see if will succeed.
            LPVOID pTestMem = HeapAlloc(GetProcessHeap(), 0, 0x100000);
            if (pTestMem == 0)
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
            // Free the memory.  The previous allocation may have
            // grown the pagefile and thus we can succeed.
            HeapFree(GetProcessHeap(), 0, pTestMem);
            nRetries++;
        }
        else
        {
            // If here, we have a load of 99%, yet more than 2 meg of memory
            // still available. Now 99% may mean there is a lot of free memory
            // because the machine has huge resources or it may mean we are just
            // about out of memory completely.  We need hard data. If we
            // have at least 5 meg anyway, this is clearly adequate, so we just
            // break out of the loop and let the call continue.
            //
            // Otherwise, we have between 2 and 5 meg, which is starting to push
            // it. We enter a waiting loop and hope for more memory.  After a few
            // retries if we continue to have between 2 and 5 meg, we'll let the call
            // through and let the arbitrator deal with it, since the system appears
            // to have stabilized at this usage.
            //
            hr = WBEM_S_NO_ERROR;

            if (ms.dwAvailPhys < 0x200000)  // If low on physical memory back off a bit for recovery via pagefile
                Sleep(1000);

            if (dwPracticalMemory > 0x100000 * 5)  // > 5 meg; break out immediately
                break;

            // Under 5 meg free, retry a few times to let things clear up and get
            // more memory.  But, we succeed in the end anyway.
            // ==================================================================
            Sleep(1000);
            if (nRetries++ > 5)
            {
                hr = WBEM_S_NO_ERROR;
                break;
            }
        }
    }

    return hr;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::TestForVector(
    IN  IWbemClassObject *pAllegedVector,
    OUT BSTR *strVectorPath
    )
{
    HRESULT hRes;

    if (pAllegedVector == 0 || strVectorPath == 0)
        return WBEM_E_INVALID_PARAMETER;

    *strVectorPath = 0;

    // See if the object is a vector object.
    // =====================================

    IWbemQualifierSet *pQSet = 0;
    hRes = pAllegedVector->GetQualifierSet(&pQSet);
    if (FAILED(hRes))
        return hRes;
    CReleaseMe _1(pQSet);

    CVARIANT v;
    hRes = pQSet->Get(L"VECTOR", 0, &v, 0);
    if (FAILED(hRes))
        return WBEM_S_NO_ERROR;
    if (v.GetBool() == FALSE)
        return WBEM_S_NO_ERROR;

    // If here, it's a vector.  Get the reference.
    // ===========================================

    BOOL bFound = FALSE;

    pAllegedVector->BeginEnumeration(WBEM_FLAG_REFS_ONLY);

    while (1)
    {
        BSTR strPropName = 0;
        hRes = pAllegedVector->Next(
            0,                  // Flags
            &strPropName,       // Name
            0,                  // Value
            0,
            0
            );

        CSysFreeMe _1(strPropName);

        if (hRes == WBEM_S_NO_MORE_DATA)
            break;

        *strVectorPath = strPropName;
        bFound = TRUE;
        break;
    }

    pAllegedVector->EndEnumeration();

    if (bFound)
        return WBEM_S_NO_ERROR;

    return WBEM_E_NOT_FOUND;
}


//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CWbemNamespace::SetMustPreventUnloading(boolean bPrevent)
{
    if (bPrevent && !m_bForClient)
        gClientCounter.AddClientPtr((IWbemServices *)this, NAMESPACE);
    if (!bPrevent && m_bForClient)
        gClientCounter.RemoveClientPtr((IWbemServices *)this);
    m_bForClient = (bPrevent?true:false);
    return S_OK;
}


//***************************************************************************
//
//***************************************************************************
//

HRESULT CWbemNamespace::UniversalConnect(
    CWbemNamespace  *pParent,
    IWbemContext    *pCtx,
    LPCWSTR pszNewScope,
    LPCWSTR pszAssocSelector,
    LPCWSTR pszUserName,
    _IWmiCallSec    *pCallSec,
    _IWmiUserHandle *pUser,
    DWORD  dwUserFlags,
    DWORD  dwInternalFlags,
    DWORD  dwSecFlags,
    DWORD  dwPermission,
    BOOL   bForClient,
    BOOL   bRepositOnly,
    LPCWSTR pszClientMachineName,
    DWORD dwClientProcessID,
    IN  REFIID riid,
    OUT LPVOID *pConnection
    )
{
    HRESULT hRes;
    if(dwUserFlags & WBEM_FLAG_CONNECT_REPOSITORY_ONLY)
        bRepositOnly = TRUE;

    // Validate.
    // =========

    if (pszNewScope == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (riid == IID_IWbemClassObject)
    {
        // Parse the path

        IWbemPath *pPath = ConfigMgr::GetNewPath();
        if (pPath == 0)
            return WBEM_E_OUT_OF_MEMORY;
        CReleaseMe _1(pPath);

        HRESULT hres = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, pszNewScope);
        if (FAILED(hres))
            return WBEM_E_INVALID_OBJECT_PATH;


        // Get the namespace part of the path

        DWORD dwSizeNamespace = 0;
        hres = pPath->GetText(WBEMPATH_GET_NAMESPACE_ONLY, &dwSizeNamespace, NULL);
        if(FAILED(hres))
            return hres;

        LPWSTR wszNewNamespace = new WCHAR[dwSizeNamespace];
        if(wszNewNamespace == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        CDeleteMe<WCHAR> dm1(wszNewNamespace);

        hres = pPath->GetText(WBEMPATH_GET_NAMESPACE_ONLY, &dwSizeNamespace, wszNewNamespace);
        if(FAILED(hres))
            return hres;

        // Open the namespace

        IWbemServicesEx * pServices = NULL;
        hRes = UniversalConnect(
            0,                          // Parent CWbemNamespace; not known
            pCtx,                       // Context
            wszNewNamespace,                    // Path
            pszAssocSelector,
            pszUserName,
            pCallSec,
            pUser,
            dwUserFlags,
            dwInternalFlags,
            dwSecFlags,
            dwPermission,
            bForClient,
            bRepositOnly,
            pszClientMachineName,
            dwClientProcessID,
            IID_IWbemServicesEx,
            (void **)&pServices);

        if(FAILED(hRes))
            return hRes;

        CReleaseMe rm2(pServices);
        CWbemNamespace * pNS = (CWbemNamespace *)pServices;

        // check if allowed access

        DWORD dwAccess = pNS->GetUserAccess();
        if((dwAccess  & WBEM_ENABLE) == 0)
        {
            Sleep(5000);
            return WBEM_E_ACCESS_DENIED;
        }
        pNS->SetPermissions(dwAccess);



        // Get the relative part of the path

        DWORD dwSizeRelative = 0;
        hres = pPath->GetText(WBEMPATH_GET_RELATIVE_ONLY, &dwSizeRelative, NULL);
        if(FAILED(hres))
            return hres;

        LPWSTR wszRelativePath = new WCHAR[dwSizeRelative];
        if(wszRelativePath == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        CDeleteMe<WCHAR> dm2(wszRelativePath);

        hres = pPath->GetText(WBEMPATH_GET_RELATIVE_ONLY, &dwSizeRelative, wszRelativePath);
        if(FAILED(hres))
            return hres;

        // Get the object

        hRes = pNS->InternalGetInstance(wszRelativePath, (IWbemClassObject **)pConnection);
        return hRes;
    }

    if (riid != IID_IWbemServices && riid != IID_IWbemServicesEx)
        return E_NOINTERFACE;

    // Parse the path.
    // ===============

    IWbemPath *pPath = ConfigMgr::GetNewPath();
    if (pPath == 0)
        return WBEM_E_OUT_OF_MEMORY;
    CReleaseMe _1(pPath);

    hRes = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL | WBEMPATH_TREAT_SINGLE_IDENT_AS_NS, pszNewScope);
    if (FAILED(hRes))
        return hRes;

    // If no parent, then this is an 'absolute' connect.
    // =================================================

    if (!pParent)
    {
        CWbemNamespace *pNs = new CWbemNamespace;
        if (!pNs)
            return WBEM_E_OUT_OF_MEMORY;

        pNs->AddRef();

        hRes = pNs->Initialize(
                        LPWSTR(pszNewScope),
                        LPWSTR(pszUserName),
                        dwSecFlags,
                        dwPermission,
                        bForClient,
                        bRepositOnly,
                        pszClientMachineName,
                        dwClientProcessID,
                        FALSE,
                        NULL);

        if (FAILED(hRes))
        {
            pNs->Release();
            return hRes;
        }

        *pConnection = pNs;
        return WBEM_S_NO_ERROR;
    }


    // If here, we are opening a child scope
    // =====================================

    CWbemNamespace *pNs = new CWbemNamespace;
    if (!pNs)
        return WBEM_E_OUT_OF_MEMORY;

    WString sScope = pParent->m_pThisNamespace;
    sScope += ":";
    sScope += pszNewScope;

    hRes = pNs->Initialize(
                        sScope,
                        LPWSTR(pszUserName),
                        dwSecFlags,
                        dwPermission,
                        bForClient,
                        bRepositOnly,
                        pszClientMachineName,
                        dwClientProcessID,
                        FALSE, NULL);

   if (FAILED(hRes))
   {
       delete pNs;
       return hRes;
   }

   pNs->AddRef();
   *pConnection = pNs;
   return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//  Called by _IWmiCoreServices to establish a connection from the 'outside'.
//
//***************************************************************************
//
HRESULT CWbemNamespace::PathBasedConnect(
            /* [in] */ LPCWSTR pszPath,
            /* [in] */ LPCWSTR pszUser,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ ULONG uClientFlags,
            /* [in] */ DWORD dwSecFlags,
            /* [in] */ DWORD dwPermissions,
            /* [in] */ ULONG uInternalFlags,
            /* [in] */ LPCWSTR pszClientMachineName,
            /* [in] */ DWORD dwClientProcessID,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pServices
            )
{
    HRESULT hRes;

    BOOL bForClient = FALSE;

    if ((uInternalFlags & WMICORE_CLIENT_ORIGIN_LOCAL) ||
        (uInternalFlags & WMICORE_CLIENT_ORIGIN_REMOTE) ||
        (uInternalFlags & WMICORE_CLIENT_TYPE_ALT_TRANSPORT)
       )
    {
        bForClient = TRUE;
    }

    hRes = UniversalConnect(
        0,                          // Parent CWbemNamespace; not known
        pCtx,                       // Context
        pszPath,                    // Path
        0,                          // No assoc selector at this point
        pszUser,                    // User
        0,                          // Call security
        0,                          // User handle
        uClientFlags,               // Flags from client
        uInternalFlags,             // Internal flags
        dwSecFlags,                 // Copy
        dwPermissions,              // Copy
        bForClient,                 // For client?
        FALSE,                      // Repository only
        pszClientMachineName,
        dwClientProcessID,
        riid,
        pServices
        );

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::InitNewTask(
    IN CAsyncReq *pReq,
    IN _IWmiFinalizer *pFnz,
    IN ULONG uTaskType,
    IN IWbemContext *pCtx,
    IN IWbemObjectSink *pAsyncClientSink
    )
{
    HRESULT hRes;

    if (pReq == 0 || pFnz == 0)
        return WBEM_E_INVALID_PARAMETER;

    try
    {
        // Create a task for tracking the operation.
        // =========================================

        CWmiTask *pNewTask = CWmiTask::CreateTask();
        if (pNewTask == 0)
            return WBEM_E_OUT_OF_MEMORY;
        CReleaseMe _2(pNewTask);

        hRes = pNewTask->Initialize(this, uTaskType, pCtx, pAsyncClientSink);
        if (FAILED(hRes))
            return hRes;

        hRes = pFnz->SetTaskHandle((_IWmiCoreHandle *) pNewTask);
        if (FAILED(hRes))
            return hRes;

        pReq->SetTaskHandle((_IWmiCoreHandle *) pNewTask);
    }
    catch(...)
    {
        ExceptionCounter c;    
        return WBEM_E_CRITICAL_ERROR;
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::CreateSyncFinalizer(
        IN  IWbemContext *pCtx,
        IN _IWmiFinalizer **pResultFnz
        )
{
    HRESULT hRes;

    ULONG uFlags = WMI_FNLZR_FLAG_FAST_TRACK;

    // Determine calling context to see if the call is reentrant or what.
    // ==================================================================

    IWbemCausalityAccess *pCaus = 0;
    if (pCtx != 0)
    {
        hRes = pCtx->QueryInterface(IID_IWbemCausalityAccess, (LPVOID *) &pCaus);
        if (SUCCEEDED(hRes))
        {
            long lNumParents = 0;
            long lNumSiblings = 0;
            pCaus->GetHistoryInfo(&lNumParents, &lNumSiblings);
            if (lNumParents)
                uFlags = WMI_FNLZR_FLAG_FAST_TRACK;
            pCaus->Release();
        }
    }

    // Create Finalizer.
    // =================
    _IWmiFinalizer *pFnz = 0;
    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;
    CReleaseMe _(pFnz);

    hRes = pFnz->Configure(uFlags, 0);
    if (FAILED(hRes))
        return hRes;

    pFnz->AddRef();
    *pResultFnz = pFnz;
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::CreateAsyncFinalizer(
    IWbemContext *pCtx,
    IWbemObjectSink *pStartingSink,
    _IWmiFinalizer **pResultFnz,
    IWbemObjectSinkEx **pResultSinkEx
    )
{
    HRESULT hRes;

    ULONG uFlags = WMI_FNLZR_FLAG_FAST_TRACK;

    // temporarily remove this since all we need to know
    // is if we are in proc or out of proc.
    /*if ((m_uClientMask & WMICORE_CLIENT_TYPE_USER) ||
        (m_uClientMask & WMICORE_CLIENT_ORIGIN_LOCAL) ||
        (m_uClientMask & WMICORE_CLIENT_ORIGIN_REMOTE))
        uFlags = WMI_FNLZR_FLAG_DECOUPLED; */
    if ( m_bForClient )
        uFlags = WMI_FNLZR_FLAG_DECOUPLED;

    // Determine calling context to see if the call is reentrant or what.
    // ==================================================================
    IWbemCausalityAccess *pCaus = 0;
    if (pCtx != 0)
    {
        hRes = pCtx->QueryInterface(IID_IWbemCausalityAccess, (LPVOID *) &pCaus);
        if (SUCCEEDED(hRes))
        {
            long lNumParents = 0;
            long lNumSiblings = 0;
            pCaus->GetHistoryInfo(&lNumParents, &lNumSiblings);
            if (lNumParents)
                uFlags = WMI_FNLZR_FLAG_FAST_TRACK;
            pCaus->Release();
        }
    }

    // Create Finalizer.
    // =================
    _IWmiFinalizer *pFnz = 0;
    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;
    CReleaseMe _(pFnz);

    hRes = pFnz->Configure(uFlags, 0);
    if (FAILED(hRes))
        return hRes;

    // if the sink supports IID_IWbemObjectSinkEx, then use that

    IWbemObjectSinkEx * pStartingSinkEx = NULL;
    hRes = pStartingSink->QueryInterface(IID_IWbemObjectSinkEx, (void **)&pStartingSinkEx);
    if(SUCCEEDED(hRes))
    {
        hRes = pFnz->SetDestinationSink(0, IID_IWbemObjectSinkEx, (LPVOID) pStartingSinkEx);
        pStartingSinkEx->Release();
    }
    else
        hRes = pFnz->SetDestinationSink(0, IID_IWbemObjectSink, (LPVOID) pStartingSink);

    if (FAILED(hRes))
        return hRes;

    hRes = pFnz->NewInboundSink(0, pResultSinkEx);
    if (FAILED(hRes))
        return hRes;

    pFnz->AddRef();
    *pResultFnz = pFnz;
    return WBEM_S_NO_ERROR;
}


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//  Native async operations
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//  InstEnum    Sync[ ]  Async Impl[x]  AsyncEntry[x]
//  ClassEnum   Sync[ ]  Async Impl[x]  AsyncEntry[x]
//
//  PutInst     Sync[ ]  Async Impl[x]  AsyncEntry[x]
//  PutClass    Sync[ ]  Async Impl[x]  AsyncEntry[x]
//  DelInst     Sync[ ]  Async Impl[x]  AsyncEntry[x]
//  DelClass    Sync[ ]  Async Impl[x]  AsyncEntry[x]
//
//  GetObject   Sync[ ]  Async Impl[x]  AsyncEntry[x]
//
//  ExecQuery   Sync[ ]  Async Impl[x]  AsyncEntry[x]
//  ExecMethod  Sync[ ]  Async Impl[x]  AsyncEntry[x]
//
//  Add         Sync[ ]  Async Impl[x]  AsyncEntry[x]
//  Remove      Sync[ ]  Async Impl[x]  AsyncEntry[x]
//  Open        Sync[ ]  Async Impl[x]  AsyncEntry[x]
//  Rename      Sync[ ]  Async Impl[x]  AsyncEntry[x]
//  Refresh     Sync[ ]  Async Impl[x]  AsyncEntry[x]
//
//

//***************************************************************************
//
//***************************************************************************
// ok
HRESULT CWbemNamespace::DeleteClassAsync(
    const BSTR strClass,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    return _DeleteClassAsync(
        WMICORE_TASK_TYPE_ASYNC | WMICORE_TASK_DELETE_CLASS,
        0, 0, strClass, lFlags, pCtx, pHandler
        );
}

//***************************************************************************
//
//***************************************************************************
// ok
HRESULT CWbemNamespace::CreateClassEnumAsync(
    const BSTR strParent,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    return _CreateClassEnumAsync(
        WMICORE_TASK_TYPE_ASYNC | WMICORE_TASK_ENUM_CLASSES,
        0, 0, strParent, lFlags, pCtx, pHandler
        );
}

//***************************************************************************
//
//***************************************************************************
// ok
HRESULT CWbemNamespace::PutClassAsync(
    READONLY IWbemClassObject* pObj,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    return _PutClassAsync(
        WMICORE_TASK_TYPE_ASYNC | WMICORE_TASK_PUT_CLASS,
        0, 0, pObj, lFlags, pCtx, pHandler
        );
}


//***************************************************************************
//
//***************************************************************************
// ok
HRESULT CWbemNamespace::PutInstanceAsync(
    IWbemClassObject* pInst,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    return _PutInstanceAsync(
        WMICORE_TASK_TYPE_ASYNC| WMICORE_TASK_PUT_INSTANCE,
        0, 0, pInst, lFlags, pCtx, pHandler
        );
}

//***************************************************************************
//
//***************************************************************************
//  ok
HRESULT CWbemNamespace::DeleteInstanceAsync(
    const BSTR strObjectPath,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    return _DeleteInstanceAsync(
        WMICORE_TASK_TYPE_ASYNC| WMICORE_TASK_DELETE_INSTANCE,
        0, 0, strObjectPath, lFlags, pCtx, pHandler
        );
}

//***************************************************************************
//
//***************************************************************************
//  ok
HRESULT CWbemNamespace::CreateInstanceEnumAsync(
    const BSTR strClass,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    return _CreateInstanceEnumAsync(
        WMICORE_TASK_TYPE_ASYNC | WMICORE_TASK_ENUM_INSTANCES,
        0, 0,
        strClass, lFlags, pCtx, pHandler
        );
}

//***************************************************************************
//
//***************************************************************************
//  ok
HRESULT CWbemNamespace::ExecQueryAsync(
    const BSTR strQueryFormat,
    const BSTR strQuery,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    return _ExecQueryAsync(
        WMICORE_TASK_TYPE_ASYNC | WMICORE_TASK_EXEC_QUERY,
        0, 0,
        strQueryFormat, strQuery, lFlags, pCtx, pHandler
        );
}

//***************************************************************************
//
//***************************************************************************
//  ok
HRESULT CWbemNamespace::ExecMethodAsync(
    const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext *pCtx,
    IWbemClassObject *pInParams,
    IWbemObjectSink* pHandler
    )
{
    return _ExecMethodAsync(
        WMICORE_TASK_TYPE_ASYNC | WMICORE_TASK_EXEC_METHOD,
        0, 0,
        ObjectPath,
        MethodName,
        lFlags,
        pCtx,
        pInParams,
        pHandler
        );
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::GetObjectAsync(
    const BSTR strObjectPath,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;
    if (!Allowed(WBEM_ENABLE))
        return WBEM_E_ACCESS_DENIED;

    return _GetObjectAsync(
        WMICORE_TASK_TYPE_ASYNC | WMICORE_TASK_GET_OBJECT,
        0, 0,
        strObjectPath,
        lFlags,
        pCtx,
        pHandler
        );
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::AddAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pHandler
            )
{
    return _AddAsync(
        WMICORE_TASK_TYPE_ASYNC | WMICORE_TASK_ADD,
        0, 0,
        strObjectPath,
        lFlags,
        pCtx,
        pHandler
        );
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::RemoveAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pHandler
            )
{
    return _RemoveAsync(
        WMICORE_TASK_TYPE_ASYNC | WMICORE_TASK_REMOVE,
        0, 0,
        strObjectPath,
        lFlags,
        pCtx,
        pHandler
        );
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::OpenAsync(
            /* [in] */ const BSTR strScope,
            /* [in] */ const BSTR strParam,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSinkEx __RPC_FAR *pHandler
            )
{
    return _OpenAsync(
        WMICORE_TASK_TYPE_ASYNC | WMICORE_TASK_OPEN,
        0, 0,
        strScope,
        strParam,
        lFlags,
        pCtx,
        pHandler
        );
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::RefreshObjectAsync(
            /* [out][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pTarget,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSinkEx __RPC_FAR *pHandler
            )
{
    return _RefreshObjectAsync(
        WMICORE_TASK_TYPE_ASYNC | WMICORE_TASK_REFRESH_OBJECT,
        0, 0,
        pTarget,
        lFlags,
        pCtx,
        pHandler
        );
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::RenameObjectAsync(
            /* [in] */ const BSTR strOldObjectPath,
            /* [in] */ const BSTR strNewObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pHandler
            )
{
    return _RenameObjectAsync(
        WMICORE_TASK_TYPE_ASYNC | WMICORE_TASK_RENAME_OBJECT,
        0, 0,
        strOldObjectPath,
        strNewObjectPath,
        lFlags,
        pCtx,
        pHandler
        );
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::_PutInstanceAsync(
    IN ULONG uInternalFlags,
    IN _IWmiFinalizer *pFnz,
    IN _IWmiCoreHandle *phTask,
    IWbemClassObject* pInst,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::PutInstanceAsync"
        "   long lFlags = 0x%X\n"
        "   IWbemClassObject *pInst = 0x%X\n"
        "   IWbemObjectSink* pHandler = 0x%X\n",
        lFlags,
        pInst,
        pHandler
        ));

    // Parameter and object validation.
    // ================================

    if (pFnz == 0 && pHandler == 0)
       return WBEM_E_INVALID_PARAMETER;

    if (pInst == NULL)
       return WBEM_E_INVALID_PARAMETER;

    long lMainFlags = lFlags & ~WBEM_FLAG_SEND_STATUS & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS & ~WBEM_FLAG_OWNER_UPDATE;

    if (lMainFlags != WBEM_FLAG_CREATE_ONLY &&
        lMainFlags != WBEM_FLAG_UPDATE_ONLY &&
        lMainFlags != WBEM_FLAG_CREATE_OR_UPDATE)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    if (!m_bProvider && (lFlags & WBEM_FLAG_OWNER_UPDATE))
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    if (lFlags & WBEM_FLAG_OWNER_UPDATE)
    {
        lFlags -= WBEM_FLAG_OWNER_UPDATE;
        lFlags += WBEM_FLAG_NO_EVENTS;
    }

    // Check for per-property put context info.
    // ========================================

    if (pCtx)
        AdjustPutContext(pCtx);

    // Create Finalizer.
    // =================

    IWbemObjectSinkEx *pPseudoSink = 0;
    if (pFnz == 0)
    {
        hRes = CreateAsyncFinalizer(pCtx, pHandler, &pFnz, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
    }
    else // borrowed finalizer
    {
        hRes = pFnz->NewInboundSink(0, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
        pFnz->AddRef();
    }

    CReleaseMe _1(pPseudoSink);
    CReleaseMe _2(pFnz);

    // Schedule the request.
    // =====================

    CAsyncReq_PutInstanceAsync* pReq = 0;
    try
    {
        pReq = new CAsyncReq_PutInstanceAsync(
            this, pInst, lFlags, pPseudoSink, pCtx);
    }
    catch(...)
    {
        ExceptionCounter c;    
        pReq = 0;
    }

    if (pReq == NULL)
        return WBEM_E_OUT_OF_MEMORY;

	if ( NULL == pReq->GetContext() )
	{
		delete pReq;
		return WBEM_E_OUT_OF_MEMORY;
	}

    hRes = InitNewTask(pReq, pFnz, uInternalFlags, pReq->GetContext(), pHandler);
    if (FAILED(hRes))
    {
        delete pReq;
        return hRes;
    }

    _1.release();
    hRes = ConfigMgr::EnqueueRequest(pReq);
    if (FAILED(hRes))
    {
        pFnz->CancelTask ( 0 );
        delete pReq;
    }

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::_DeleteClassAsync(
    IN ULONG uInternalFlags,
    IN _IWmiFinalizer *pFnz,
    IN _IWmiCoreHandle *phTask,
    const BSTR strClass,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Parameter validation.
    // =====================

    if (pFnz == 0 && pHandler == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (strClass == 0 || wcslen(strClass) == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (!m_bProvider && (lFlags & WBEM_FLAG_OWNER_UPDATE))
        return WBEM_E_INVALID_PARAMETER;

    if (lFlags & ~WBEM_FLAG_SEND_STATUS & ~WBEM_FLAG_OWNER_UPDATE)
        return WBEM_E_INVALID_PARAMETER;

    if (lFlags & WBEM_FLAG_OWNER_UPDATE)
    {
        lFlags -= WBEM_FLAG_OWNER_UPDATE;
        lFlags += WBEM_FLAG_NO_EVENTS;
    }

    // Create Finalizer.
    // =================

    IWbemObjectSinkEx *pPseudoSink = 0;
    if (pFnz == 0)
    {
        hRes = CreateAsyncFinalizer(pCtx, pHandler, &pFnz, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
    }
    else // borrowed finalizer
    {
        hRes = pFnz->NewInboundSink(0, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
        pFnz->AddRef();
    }

    CReleaseMe _1(pPseudoSink);
    CReleaseMe _2(pFnz);

    // Create request.
    // ===============

    CAsyncReq_DeleteClassAsync* pReq = 0;
    try
    {
        pReq = new CAsyncReq_DeleteClassAsync(
        this, strClass, lFlags, pPseudoSink, pCtx);
    }
    catch(...)
    {
        ExceptionCounter c;    
        pReq = 0;
    }
    if (pReq == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    // Create a task for tracking the operation.
    // =========================================

	if (NULL == pReq->GetContext())
	{
		delete pReq;
		return WBEM_E_OUT_OF_MEMORY;
	}

    hRes = InitNewTask(pReq, pFnz, uInternalFlags, pReq->GetContext(), pHandler);
    if (FAILED(hRes))
    {
        delete pReq;
        return hRes;
    }
    _1.release();
    hRes = ConfigMgr::EnqueueRequest(pReq);
    if (FAILED(hRes))
    {
        pFnz->CancelTask ( 0 );
        delete pReq;
    }

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::_CreateClassEnumAsync(
    IN ULONG uInternalFlags,
    IN _IWmiFinalizer *pFnz,
    IN _IWmiCoreHandle *phTask,
    const BSTR strParent,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;
    if (!Allowed(WBEM_ENABLE))
        return WBEM_E_ACCESS_DENIED;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::CreateClassEnumAsync\n"
        "   BSTR strParent = %S\n"
        "   long lFlags = 0x%X\n"
        "   IWbemObjectSink* pHandler = 0x%X\n",
        strParent,
        lFlags,
        pHandler
        ));

    // Parameter validation.
    // =====================

    if (pFnz == 0 && pHandler == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (lFlags & ~(WBEM_FLAG_DEEP | WBEM_FLAG_SHALLOW | WBEM_FLAG_SEND_STATUS) & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS)
        return WBEM_E_INVALID_PARAMETER;

    // Create Finalizer.
    // =================

    IWbemObjectSinkEx *pPseudoSink = 0;
    if (pFnz == 0)
    {
        hRes = CreateAsyncFinalizer(pCtx, pHandler, &pFnz, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
    }
    else // borrowed finalizer
    {
        hRes = pFnz->NewInboundSink(0, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
        pFnz->AddRef();
    }

    CReleaseMe _1(pPseudoSink);
    CReleaseMe _2(pFnz);


    // Add this request to the queue.
    // ==============================

    CAsyncReq_CreateClassEnumAsync *pReq = 0;
    try
    {
        pReq = new CAsyncReq_CreateClassEnumAsync(this, strParent, lFlags, pPseudoSink,
            pCtx);
    }
    catch(...)
    {
        ExceptionCounter c;    
        pReq = 0;
    }

    if (pReq == NULL)
        return WBEM_E_OUT_OF_MEMORY;

	if (NULL == pReq->GetContext())
	{
		delete pReq;
		return WBEM_E_OUT_OF_MEMORY;
	}

    hRes = InitNewTask(pReq, pFnz, uInternalFlags, pReq->GetContext(), pHandler);
    if (FAILED(hRes))
    {
        delete pReq;
        return hRes;
    }
    _1.release();
    hRes = ConfigMgr::EnqueueRequest(pReq);

    if (FAILED(hRes))
    {
        pFnz->CancelTask ( 0 );
        delete pReq;
    }

    return hRes;

}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::_PutClassAsync(
    IN ULONG uInternalFlags,
    IN _IWmiFinalizer *pFnz,
    IN _IWmiCoreHandle *phTask,
    READONLY IWbemClassObject* pObj,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    CVARIANT vClass;
    if (pObj)
    {
        hRes = pObj->Get(L"__CLASS", 0, &vClass, 0, 0);
    }
    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::PutClassAsync\n"
        "   long lFlags = 0x%X\n"
        "   IWbemClassObject *pObj = 0x%X\n"
        "   IWbemObjectSink* pNotify = 0x%X\n"
        "   __CLASS=%S\n",
        lFlags,
        pObj,
        pHandler,
        vClass.GetStr()
        ));

    if (pFnz == 0 && pHandler == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (pObj == NULL)
        return WBEM_E_INVALID_PARAMETER;

    if(!m_bProvider && (lFlags & WBEM_FLAG_OWNER_UPDATE))
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    long lTestFlags = lFlags & ~WBEM_FLAG_SEND_STATUS & ~WBEM_FLAG_OWNER_UPDATE
        & ~WBEM_MASK_UPDATE_MODE & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS;

    if (!((lTestFlags == WBEM_FLAG_CREATE_OR_UPDATE) ||
          (lTestFlags == WBEM_FLAG_UPDATE_ONLY) ||
          (lTestFlags == WBEM_FLAG_CREATE_ONLY) ||
          (lTestFlags == WBEM_FLAG_UPDATE_SAFE_MODE) ||
          (lTestFlags == WBEM_FLAG_UPDATE_FORCE_MODE) ||
          (lTestFlags == (WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_UPDATE_SAFE_MODE)) ||
          (lTestFlags == (WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_UPDATE_FORCE_MODE))))
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    if (lFlags & WBEM_FLAG_OWNER_UPDATE)
    {
        lFlags -= WBEM_FLAG_OWNER_UPDATE;
        lFlags += WBEM_FLAG_NO_EVENTS;
    }

    // Create Finalizer.
    // =================

    IWbemObjectSinkEx *pPseudoSink = 0;
    if (pFnz == 0)
    {
        hRes = CreateAsyncFinalizer(pCtx, pHandler, &pFnz, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
    }
    else // borrowed finalizer
    {
        hRes = pFnz->NewInboundSink(0, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
        pFnz->AddRef();
    }

    CReleaseMe _1(pPseudoSink);
    CReleaseMe _2(pFnz);

    // Create request.
    // ===============

    CAsyncReq_PutClassAsync* pReq = 0;
    try
    {
        pReq = new CAsyncReq_PutClassAsync(
            this, pObj, lFlags, pPseudoSink, pCtx);
    }
    catch(...)
    {
        ExceptionCounter c;    
        pReq = 0;
    }
    if (pReq == NULL)
        return WBEM_E_OUT_OF_MEMORY;

	if ( NULL == pReq->GetContext() )
	{
		delete pReq;
		return WBEM_E_OUT_OF_MEMORY;
	}

    hRes = InitNewTask(pReq, pFnz, uInternalFlags, pReq->GetContext(), pHandler);
    if (FAILED(hRes))
    {
        delete pReq;
        return hRes;
    }
    _1.release();
    hRes = ConfigMgr::EnqueueRequest(pReq);
    if (FAILED(hRes))
    {
        pFnz->CancelTask ( 0 );
        delete pReq;
    }

    return hRes;
}




//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::_DeleteInstanceAsync(
    IN ULONG uInternalFlags,
    IN _IWmiFinalizer *pFnz,
    IN _IWmiCoreHandle *phTask,
    READONLY const BSTR strObjectPath,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::DeleteInstance\n"
        "   BSTR ObjectPath = %S\n"
        "   long lFlags = %d\n"
        "   IWbemObjectSink* pHandler = 0x%X\n",
        strObjectPath, lFlags, pHandler
        ));

    // Parameter validation.
    // =====================

    if (pFnz == 0 && pHandler == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (strObjectPath == 0 || wcslen(strObjectPath) == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (!m_bProvider && (lFlags & WBEM_FLAG_OWNER_UPDATE))
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    if (lFlags & ~WBEM_FLAG_SEND_STATUS & ~WBEM_FLAG_OWNER_UPDATE)
        return WBEM_E_INVALID_PARAMETER;

    if (lFlags & WBEM_FLAG_OWNER_UPDATE)
    {
        lFlags -= WBEM_FLAG_OWNER_UPDATE;
        lFlags += WBEM_FLAG_NO_EVENTS;
    }

    // Create Finalizer.
    // =================

    IWbemObjectSinkEx *pPseudoSink = 0;
    if (pFnz == 0)
    {
        hRes = CreateAsyncFinalizer(pCtx, pHandler, &pFnz, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
    }
    else // borrowed finalizer
    {
        hRes = pFnz->NewInboundSink(0, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
        pFnz->AddRef();
    }

    CReleaseMe _1(pPseudoSink);
    CReleaseMe _2(pFnz);

    // Create request.
    // ===============

    CAsyncReq_DeleteInstanceAsync* pReq = 0;
    try
    {
        pReq = new CAsyncReq_DeleteInstanceAsync(
        this, strObjectPath, lFlags, pPseudoSink, pCtx);
    }
    catch(...)
    {
        ExceptionCounter c;    
        pReq = 0;
    }

    if (pReq == NULL)
        return WBEM_E_OUT_OF_MEMORY;

	if ( NULL == pReq->GetContext() )
	{
		delete pReq;
		return WBEM_E_OUT_OF_MEMORY;
	}

    hRes = InitNewTask(pReq, pFnz, uInternalFlags, pReq->GetContext(), pHandler);
    if (FAILED(hRes))
    {
        delete pReq;
        return hRes;
    }
    _1.release();
    hRes = ConfigMgr::EnqueueRequest(pReq);
    if (FAILED(hRes))
    {
        pFnz->CancelTask ( 0 );
        delete pReq;
    }

    return hRes;
}


//***************************************************************************
//
//  CWbemNamespace::CreateInstanceEnumAsync
//
//  Schedules an asynchrnous request that eventuall calls
//  Exec_CreateInstanceEnum.
//
//  Parameters and return values are described in help
//
//***************************************************************************
//
HRESULT CWbemNamespace::_CreateInstanceEnumAsync(
    IN ULONG uInternalFlags,
    IN _IWmiFinalizer *pFnz,
    IN _IWmiCoreHandle *phTask,
    const BSTR strClass,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;
    if (!Allowed(WBEM_ENABLE))
        return WBEM_E_ACCESS_DENIED;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::CreateInstanceEnumAsync\n"
        "   BSTR Class = %S\n"
        "   long lFlags = 0x%X\n"
        "   IWbemObjectSink pHandler = 0x%X\n",
        strClass,
        lFlags,
        pHandler
        ));

    // Parameter validation.
    // =====================
    if (pFnz == 0 && pHandler == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (strClass == 0 || wcslen(strClass) == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (lFlags & ~(WBEM_FLAG_DEEP | WBEM_FLAG_SHALLOW | WBEM_FLAG_SEND_STATUS |
        WBEM_FLAG_USE_AMENDED_QUALIFIERS | WBEM_FLAG_DIRECT_READ))
            return WBEM_E_INVALID_PARAMETER;

    // Create Finalizer.
    // =================

    IWbemObjectSinkEx *pPseudoSink = 0;
    if (pFnz == 0)
    {
        hRes = CreateAsyncFinalizer(pCtx, pHandler, &pFnz, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
    }
    else // borrowed finalizer
    {
        hRes = pFnz->NewInboundSink(0, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
        pFnz->AddRef();
    }

    CReleaseMe _1(pPseudoSink);
    CReleaseMe _2(pFnz);

    // Add this request to the async queue.
    // ====================================

    CAsyncReq_CreateInstanceEnumAsync *pReq = 0;
    try
    {
        pReq = new CAsyncReq_CreateInstanceEnumAsync(this, strClass, lFlags, pPseudoSink,pCtx);
    }
    catch(...)
    {
        ExceptionCounter c;    
        pReq = 0;
    }
    if (pReq == NULL)
        return WBEM_E_OUT_OF_MEMORY;

	if ( NULL == pReq->GetContext() )
	{
		delete pReq;
		return WBEM_E_OUT_OF_MEMORY;
	}

    hRes = InitNewTask(pReq, pFnz, uInternalFlags, pReq->GetContext(), pHandler);
    if (FAILED(hRes))
    {
        delete pReq;
        return hRes;
    }
    _1.release();
    hRes = ConfigMgr::EnqueueRequest(pReq);
    if (FAILED(hRes))
    {
        pFnz->CancelTask ( 0 );
        delete pReq;
    }

    return hRes;
}


//***************************************************************************
//
//  CWbemNamespace::ExecQueryAsync
//
//  Schedules an asynchronous request that eventually calls
//  CQueryEngine::ExecQuery (see qengine.h)
//
//  Parameters and return values are described in help
//
//***************************************************************************
//
HRESULT CWbemNamespace::_ExecQueryAsync(
    IN ULONG uInternalFlags,
    IN _IWmiFinalizer *pFnz,
    IN _IWmiCoreHandle *phTask,
    const BSTR strQueryFormat,
    const BSTR strQuery,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    if (!Allowed(WBEM_ENABLE))
        return WBEM_E_ACCESS_DENIED;


    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::ExecQueryAsync\n"
        "   BSTR QueryFormat = %S\n"
        "   BSTR Query = %S\n"
        "   IWbemObjectSink* pHandler = 0x%X\n",
        strQueryFormat,
        strQuery,
        pHandler
        ));

    // Parameter validation.
    // =====================
    if (pFnz == 0 && pHandler == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (strQueryFormat == 0 || strQuery == 0 ||
            wcslen(strQueryFormat) == 0 || wcslen(strQuery) == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (!wcslen(strQuery))
        return WBEM_E_INVALID_QUERY;

    if (lFlags & ~WBEM_FLAG_PROTOTYPE & ~WBEM_FLAG_SEND_STATUS &
            ~WBEM_FLAG_ENSURE_LOCATABLE & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS &
            ~WBEM_FLAG_KEEP_SHAPE & ~WBEM_FLAG_DIRECT_READ
            )
        return WBEM_E_INVALID_PARAMETER;

    // Create Finalizer.
    // =================

    IWbemObjectSinkEx *pPseudoSink = 0;
    if (pFnz == 0)
    {
        hRes = CreateAsyncFinalizer(pCtx, pHandler, &pFnz, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
    }
    else // borrowed finalizer
    {
        hRes = pFnz->NewInboundSink(0, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
        pFnz->AddRef();
    }

    CReleaseMe _1(pPseudoSink);
    CReleaseMe _2(pFnz);

    // Add the request to the queue.
    // =============================

    // will throw CX_MemoryException
    CAsyncReq_ExecQueryAsync *pReq = new
        CAsyncReq_ExecQueryAsync(this, strQueryFormat, strQuery, lFlags,
                                    pPseudoSink, pCtx);
    if (NULL == pReq)
		return WBEM_E_OUT_OF_MEMORY;

	if ( NULL == pReq->GetContext() )
	{
		delete pReq;
		return WBEM_E_OUT_OF_MEMORY;
	}

    hRes = InitNewTask(pReq, pFnz, uInternalFlags, pReq->GetContext(), pHandler);
    if (FAILED(hRes))
    {
        delete pReq;
        return hRes;
    }
    _1.release();
    hRes = ConfigMgr::EnqueueRequest(pReq);
    if (FAILED(hRes))
    {
        pFnz->CancelTask ( 0 );
        delete pReq;
    }

    return hRes;
}

//***************************************************************************
//
//  CWbemNamespace::GetObjectAsync
//
//  Schedules an asynchrnous request that eventuall calls Exec_GetObjectByPath.
//
//  Parameters and return values are described in help
//
//***************************************************************************
//
HRESULT CWbemNamespace::_GetObjectAsync(
    IN ULONG uInternalFlags,
    IN _IWmiFinalizer *pFnz,
    IN _IWmiCoreHandle *phTask,
    const BSTR strObjectPath,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::GetObjectAsync\n"
        "   BSTR ObjectPath = %S\n"
        "   long lFlags = %d\n"
        "   IWbemObjectSink* pHandler = 0x%X\n",
        strObjectPath,
        lFlags,
        pHandler
        ));

    // Parameter validation.
    // =====================
    if (pFnz == 0 && pHandler == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (lFlags & ~WBEM_FLAG_SEND_STATUS & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS
        & ~WBEM_FLAG_DIRECT_READ)
        return WBEM_E_INVALID_PARAMETER;

    // Create Finalizer.
    // =================

    IWbemObjectSinkEx *pPseudoSink = 0;
    if (pFnz == 0)
    {
        hRes = CreateAsyncFinalizer(pCtx, pHandler, &pFnz, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
    }
    else // borrowed finalizer
    {
        hRes = pFnz->NewInboundSink(0, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
        pFnz->AddRef();    // Compensate for CReleaseMe to follow
    }

    CReleaseMe _1(pPseudoSink);
    CReleaseMe _2(pFnz);

    // Add request to the async queue.
    // ===============================

    CAsyncReq_GetObjectAsync *pReq = 0;
    try
    {
        pReq = new CAsyncReq_GetObjectAsync(this, strObjectPath, lFlags, pPseudoSink, pCtx);
    }
    catch(...)
    {
        ExceptionCounter c;    
        pReq = 0;
    }
    if (pReq == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    // Create a task for tracking the operation.
    // =========================================

	if ( NULL == pReq->GetContext() )
	{
		delete pReq;
		return WBEM_E_OUT_OF_MEMORY;
	}

    hRes = InitNewTask(pReq, pFnz, uInternalFlags, pReq->GetContext(), pHandler);
    if (FAILED(hRes))
    {
        delete pReq;
        return hRes;
    }
    _1.release();
    hRes = ConfigMgr::EnqueueRequest(pReq);
    if (FAILED(hRes))
    {
        pFnz->CancelTask ( 0 );
        delete pReq;
    }

    return hRes;
}


//***************************************************************************
//
//  CWbemNamespace::ExecMethodAsync
//
//***************************************************************************
//
HRESULT CWbemNamespace::_ExecMethodAsync(
    IN ULONG uInternalFlags,
    IN _IWmiFinalizer *pFnz,
    IN _IWmiCoreHandle *phTask,
    const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext *pCtx,
    IWbemClassObject *pInParams,
    IWbemObjectSink* pHandler
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::ExecMethodAsync\n"
        "   BSTR ObjectPath = %S\n"
        "   BSTR MethodName = %S\n"
        "   long lFlags = %d\n"
        "   IWbemClassObject * pIn = 0x%X\n",
        ObjectPath, MethodName, lFlags, pInParams
        ));

    // Parameter validation.
    // =====================
    if (pFnz ==0 && pHandler == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (lFlags & ~WBEM_FLAG_SEND_STATUS)
        return WBEM_E_INVALID_PARAMETER;

    // Create Finalizer.
    // =================

    IWbemObjectSinkEx *pPseudoSink = 0;
    if (pFnz == 0)
    {
        hRes = CreateAsyncFinalizer(pCtx, pHandler, &pFnz, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
    }
    else // borrowed finalizer
    {
        hRes = pFnz->NewInboundSink(0, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
        pFnz->AddRef();
    }

    CReleaseMe _1(pPseudoSink);
    CReleaseMe _2(pFnz);

    // Add request to the async queue.
    // ===============================

    CAsyncReq_ExecMethodAsync *pReq = new
        CAsyncReq_ExecMethodAsync(this, ObjectPath, MethodName, lFlags,
                        pInParams, pPseudoSink, pCtx);

    if (NULL == pReq)
		return WBEM_E_OUT_OF_MEMORY;

	if ( NULL == pReq->GetContext() )
	{
		delete pReq;
		return WBEM_E_OUT_OF_MEMORY;
	}

    hRes = InitNewTask(pReq, pFnz, uInternalFlags, pReq->GetContext(), pHandler);
    if (FAILED(hRes))
    {
        delete pReq;
        return hRes;
    }
    _1.release();
    hRes = ConfigMgr::EnqueueRequest(pReq);
    if (FAILED(hRes))
    {
        pFnz->CancelTask ( 0 );
        delete pReq;
    }

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::_OpenAsync(
            IN ULONG uInternalFlags,
            IN _IWmiFinalizer *pFnz,
            IN _IWmiCoreHandle *phTask,
            IN const BSTR strScope,
            IN const BSTR strParam,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSinkEx __RPC_FAR *pHandler
            )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::OpenAsync"
        "   strScope = %S\n"
        "   strParam = %S\n"
        "   lFlags = 0x%X\n"
        "   pCtx   = 0x%X\n"
        "   pHandler = 0x%X\n",
        strScope,
        strParam,
        lFlags,
        pCtx,
        pHandler
        ));

    // Parameter and object validation.
    // ================================

    if (pHandler == 0 && pFnz == 0)
        return WBEM_E_INVALID_PARAMETER;

    // Create Finalizer.
    // =================

    IWbemObjectSinkEx *pPseudoSink = 0;
    if (pFnz == 0)
    {
        hRes = CreateAsyncFinalizer(pCtx, pHandler, &pFnz, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
    }
    else // borrowed finalizer
    {
        hRes = pFnz->NewInboundSink(0, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
        pFnz->AddRef();
    }

    CReleaseMe _1(pPseudoSink);
    CReleaseMe _2(pFnz);

    // Schedule the request.
    // =====================

    CAsyncReq_Open* pReq = 0;
    try
    {
        pReq = new CAsyncReq_Open(
            this, strScope, strParam, lFlags, pCtx, pPseudoSink
            );
    }
    catch(...)
    {
        ExceptionCounter c;    
        pReq = 0;
    }

    if (pReq == NULL)
        return WBEM_E_OUT_OF_MEMORY;

	if ( NULL == pReq->GetContext() )
	{
		delete pReq;
		return WBEM_E_OUT_OF_MEMORY;
	}

    hRes = InitNewTask(pReq, pFnz, uInternalFlags, pReq->GetContext(), pHandler);
    if (FAILED(hRes))
    {
        delete pReq;
        return hRes;
    }
    _1.release();
    hRes = ConfigMgr::EnqueueRequest(pReq);
    if (FAILED(hRes))
    {
        pFnz->CancelTask ( 0 );
        delete pReq;
    }

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::_AddAsync(
     IN ULONG uInternalFlags,
     IN _IWmiFinalizer *pFnz,
     IN _IWmiCoreHandle *phTask,
     const BSTR strObjectPath,
     long lFlags,
     IWbemContext __RPC_FAR *pCtx,
     IWbemObjectSink __RPC_FAR *pHandler
     )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::AddAsync"
        "   strObjectPath = %S\n"
        "   lFlags = 0x%X\n"
        "   pCtx   = 0x%X\n"
        "   pHandler = 0x%X\n",
        strObjectPath,
        lFlags,
        pCtx,
        pHandler
        ));

    // Parameter and object validation.
    // ================================

    if (pHandler == 0 && pFnz == 0)
        return WBEM_E_INVALID_PARAMETER;

    // Create Finalizer.
    // =================

    IWbemObjectSinkEx *pPseudoSink = 0;
    if (pFnz == 0)
    {
        hRes = CreateAsyncFinalizer(pCtx, pHandler, &pFnz, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
    }
    else // borrowed finalizer
    {
        hRes = pFnz->NewInboundSink(0, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
        pFnz->AddRef();
    }

    CReleaseMe _1(pPseudoSink);
    CReleaseMe _2(pFnz);

    // Schedule the request.
    // =====================

    CAsyncReq_Add* pReq = 0;
    try
    {
        pReq = new CAsyncReq_Add(
            this, strObjectPath, lFlags, pCtx, pPseudoSink
            );
    }
    catch(...)
    {
        ExceptionCounter c;    
        pReq = 0;
    }

    if (pReq == NULL)
        return WBEM_E_OUT_OF_MEMORY;

	if ( NULL == pReq->GetContext() )
	{
		delete pReq;
		return WBEM_E_OUT_OF_MEMORY;
	}

    hRes = InitNewTask(pReq, pFnz, uInternalFlags, pReq->GetContext(), pHandler);
    if (FAILED(hRes))
    {
        delete pReq;
        return hRes;
    }
    _1.release();
    hRes = ConfigMgr::EnqueueRequest(pReq);
    if (FAILED(hRes))
        delete pReq;

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::_RemoveAsync(
    IN ULONG uInternalFlags,
    IN _IWmiFinalizer *pFnz,
    IN _IWmiCoreHandle *phTask,
    const BSTR strObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pHandler
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::RemoveAsync"
        "   strObjectPath = %S\n"
        "   lFlags = 0x%X\n"
        "   pCtx   = 0x%X\n"
        "   pHandler = 0x%X\n",
        strObjectPath,
        lFlags,
        pCtx,
        pHandler
        ));

    // Parameter and object validation.
    // ================================

    if (pHandler == 0 && pFnz == 0)
        return WBEM_E_INVALID_PARAMETER;

    // Create Finalizer.
    // =================

    IWbemObjectSinkEx *pPseudoSink = 0;
    if (pFnz == 0)
    {
        hRes = CreateAsyncFinalizer(pCtx, pHandler, &pFnz, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
    }
    else // borrowed finalizer
    {
        hRes = pFnz->NewInboundSink(0, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
        pFnz->AddRef();
    }

    CReleaseMe _1(pPseudoSink);
    CReleaseMe _2(pFnz);

    // Schedule the request.
    // =====================

    CAsyncReq_Remove* pReq = 0;
    try
    {
        pReq = new CAsyncReq_Remove(
        this, strObjectPath, lFlags, pCtx, pPseudoSink
        );
    }
    catch(...)
    {
        ExceptionCounter c;    
        pReq = 0;
    }

    if (pReq == NULL)
        return WBEM_E_OUT_OF_MEMORY;

	if ( NULL == pReq->GetContext() )
	{
		delete pReq;
		return WBEM_E_OUT_OF_MEMORY;
	}

    hRes = InitNewTask(pReq, pFnz, uInternalFlags, pReq->GetContext(), pHandler);
    if (FAILED(hRes))
    {
        delete pReq;
        return hRes;
    }
    _1.release();
    hRes = ConfigMgr::EnqueueRequest(pReq);
    if (FAILED(hRes))
        delete pReq;

    return hRes;
}



//***************************************************************************
//
//***************************************************************************
//

HRESULT CWbemNamespace::_RefreshObjectAsync(
    IN ULONG uInternalFlags,
    IN _IWmiFinalizer *pFnz,
    IN _IWmiCoreHandle *phTask,
    IWbemClassObject __RPC_FAR *__RPC_FAR *pTarget,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSinkEx __RPC_FAR *pHandler
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::RefreshObjectAsync"
        "   pTarget= 0x%X\n"
        "   lFlags = 0x%X\n"
        "   pCtx   = 0x%X\n"
        "   pHandler = 0x%X\n",
        pTarget,
        lFlags,
        pCtx,
        pHandler
        ));

    // Parameter and object validation.
    // ================================

    if (pHandler == 0 && pFnz == 0)
        return WBEM_E_INVALID_PARAMETER;

    // Create Finalizer.
    // =================

    IWbemObjectSinkEx *pPseudoSink = 0;
    if (pFnz == 0)
    {
        hRes = CreateAsyncFinalizer(pCtx, pHandler, &pFnz, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
    }
    else // borrowed finalizer
    {
        hRes = pFnz->NewInboundSink(0, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
        pFnz->AddRef();
    }

    CReleaseMe _1(pPseudoSink);
    CReleaseMe _2(pFnz);

    // Schedule the request.
    // =====================

    CAsyncReq_Refresh* pReq = 0;
    try
    {
        pReq = new CAsyncReq_Refresh(
        this, pTarget, lFlags, pCtx, pPseudoSink
        );
    }
    catch(...)
    {
        ExceptionCounter c;    
        pReq = 0;
    }

    if (pReq == NULL)
        return WBEM_E_OUT_OF_MEMORY;

	if ( NULL == pReq->GetContext() )
	{
		delete pReq;
		return WBEM_E_OUT_OF_MEMORY;
	}

    hRes = InitNewTask(pReq, pFnz, uInternalFlags, pReq->GetContext(), pHandler);
    if (FAILED(hRes))
    {
        delete pReq;
        return hRes;
    }
    _1.release();
    hRes = ConfigMgr::EnqueueRequest(pReq);
    if (FAILED(hRes))
        delete pReq;

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::_RenameObjectAsync(
    IN ULONG uInternalFlags,
    IN _IWmiFinalizer *pFnz,
    IN _IWmiCoreHandle *phTask,
    const BSTR strOldObjectPath,
    const BSTR strNewObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pHandler
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::RenameObjectAsync"
        "   strOldObjectPath = %S\n"
        "   strNewObjectPath = %S\n"
        "   lFlags = 0x%X\n"
        "   pCtx   = 0x%X\n"
        "   pHandler = 0x%X\n",
        strOldObjectPath,
        strNewObjectPath,
        lFlags,
        pCtx,
        pHandler
        ));

    // Parameter and object validation.
    // ================================

    if (pFnz == 0 && pHandler == 0)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Create Finalizer.
    // =================

    IWbemObjectSinkEx *pPseudoSink = 0;
    if (pFnz == 0)
    {
        hRes = CreateAsyncFinalizer(pCtx, pHandler, &pFnz, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
    }
    else // borrowed finalizer
    {
        hRes = pFnz->NewInboundSink(0, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
        pFnz->AddRef();
    }

    CReleaseMe _1(pPseudoSink);
    CReleaseMe _2(pFnz);

    // Schedule the request.
    // =====================

    CAsyncReq_Rename* pReq = 0;
    try
    {
        pReq = new CAsyncReq_Rename(
        this, strOldObjectPath, strNewObjectPath, lFlags, pCtx, pPseudoSink
        );
    }
    catch(...)
    {
        ExceptionCounter c;    
        pReq = 0;
    }

    if (pReq == NULL)
        return WBEM_E_OUT_OF_MEMORY;

	if ( NULL == pReq->GetContext() )
	{
		delete pReq;
		return WBEM_E_OUT_OF_MEMORY;
	}

    hRes = InitNewTask(pReq, pFnz, uInternalFlags, pReq->GetContext(), pHandler);
    if (FAILED(hRes))
    {
        delete pReq;
        return hRes;
    }
    _1.release();
    hRes = ConfigMgr::EnqueueRequest(pReq);
    if (FAILED(hRes))
        delete pReq;

    return hRes;
}



//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//  Native sync operations
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


//***************************************************************************
//
//  CWbemNamespace::DeleteClass
//
//  Calls DeleteClassAsync and waits for completion
//
//  Parameters and return values are described in help
//
//***************************************************************************
//
HRESULT CWbemNamespace::DeleteClass(
    const BSTR strClass,
    long lFlags,
    IWbemContext* pCtx,
    IWbemCallResult** ppResult
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::DeleteClass"
        "   BSTR Class = %S\n"
        "   long lFlags = 0x%X\n",
        strClass,
        lFlags
        ));

    // Parameter validation.
    // =====================

    if (lFlags
        & ~WBEM_FLAG_RETURN_IMMEDIATELY
        & ~WBEM_FLAG_OWNER_UPDATE
        )
        return WBEM_E_INVALID_PARAMETER;

    if ((lFlags & WBEM_RETURN_IMMEDIATELY) && ppResult == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // Create Finalizer.
    // =================

    _IWmiFinalizer *pFnz = 0;
    hRes = CreateSyncFinalizer(pCtx, &pFnz);
    if (FAILED(hRes))
        return hRes;
    CReleaseMe _1(pFnz);

    ULONG uTaskType = WMICORE_TASK_DELETE_CLASS;
    if (ppResult)
        uTaskType |= WMICORE_TASK_TYPE_SEMISYNC;
    else
        uTaskType |= WMICORE_TASK_TYPE_SYNC;

    // Call the async side.
    // ====================

    hRes = _DeleteClassAsync(uTaskType, pFnz, 0, strClass, lFlags & ~WBEM_RETURN_IMMEDIATELY,
                pCtx, NULL);

    if (FAILED(hRes))
        return hRes;

    // Check for the two return paradigms.
    // ===================================

    if ((lFlags & WBEM_RETURN_IMMEDIATELY) == 0)
    {
        HRESULT hResTemp = pFnz->GetOperationResult(0, INFINITE, &hRes);
        if (FAILED(hResTemp))
            return hResTemp;
    }
    if (ppResult)
    {
        hRes = pFnz->GetResultObject(0, IID_IWbemCallResult, (LPVOID *) ppResult);
    }


    return hRes;
}

//***************************************************************************
//
//  CWbemNamespace::PutClass
//
//  Calls PutClassAsync and waits for completion
//
//  Parameters and return values are described in help
//
//***************************************************************************

HRESULT CWbemNamespace::PutClass(
    READONLY IWbemClassObject* pObj,
    long lFlags,
    IWbemContext* pCtx,
    NEWOBJECT IWbemCallResult** ppResult
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    CVARIANT vClass;
    if (pObj)
    {
        hRes = pObj->Get(L"__CLASS", 0, &vClass, 0, 0);
    }

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::PutClass\n"
        "   long lFlags = 0x%X\n"
        "   IWbemClassObject *pObj = 0x%X\n"
        "   __CLASS=%S\n",
        lFlags,
        pObj,
        vClass.GetStr()
        ));


    if (lFlags
        & ~WBEM_FLAG_RETURN_IMMEDIATELY
        & ~WBEM_FLAG_OWNER_UPDATE
        & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS
        & ~WBEM_FLAG_CREATE_OR_UPDATE
        & ~WBEM_FLAG_UPDATE_ONLY
        & ~WBEM_FLAG_CREATE_ONLY
        & ~WBEM_FLAG_UPDATE_SAFE_MODE
        & ~WBEM_FLAG_UPDATE_FORCE_MODE
        )
        return WBEM_E_INVALID_PARAMETER;

    if ((lFlags & WBEM_RETURN_IMMEDIATELY) && ppResult == NULL)
        return WBEM_E_INVALID_PARAMETER;

    try
    {
	    if( ((lFlags & WBEM_FLAG_RETURN_IMMEDIATELY) == 0)&&(ppResult==NULL))
	    {
	        HANDLE hCurrentToken;
	        if(OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE,
	                            &hCurrentToken))
	        {
	            //
	            // Got a thread token --- cannot fast-track because otherwise we
	            // will have a thread token on a thread executing internal code
	            //

	            CloseHandle(hCurrentToken);
	        }
	        else if (CWbemQueue::GetCurrentRequest() == NULL)
	        {
	            if (lFlags & WBEM_FLAG_OWNER_UPDATE)
	            {
	                lFlags -= WBEM_FLAG_OWNER_UPDATE;
	                lFlags += WBEM_FLAG_NO_EVENTS;
	            }

	            IWbemContext *pContext = pCtx ;
	            if (pContext)
	                pContext->AddRef () ;
	                else
	            {
	                pContext = ConfigMgr::GetNewContext();
	                if ( pContext == NULL )
	                    return WBEM_E_OUT_OF_MEMORY;
	            }

	            CReleaseMe _1_pContext (pContext) ;

	            CSynchronousSink *pSyncSink = new CSynchronousSink;
	            if (pSyncSink == NULL)
	            {
	                return WBEM_E_OUT_OF_MEMORY;
	            }

	            pSyncSink->AddRef();
	            CReleaseMe _2(pSyncSink);

	            hRes = Exec_PutClass(pObj, lFlags, pContext, pSyncSink);
	            //if (FAILED(hRes))
	            //{
	            //  return hRes;
	            //}

	            // Extract the new object from the sink.
	            // ======================================

	            pSyncSink->Block();

	            IWbemClassObject* pErrorObj = NULL;
	            pSyncSink->GetStatus(&hRes, NULL, &pErrorObj);
	            CReleaseMe rm1(pErrorObj);

	            if(pErrorObj)
	            {
	                IErrorInfo* pErrorInfo = NULL;
	                pErrorObj->QueryInterface(IID_IErrorInfo,
	                                       (void**)&pErrorInfo);
	                SetErrorInfo(0, pErrorInfo);
	                pErrorInfo->Release();
	            }

	            return hRes;
	        }
	    }

	    // Create Finalizer.
	    // =================

	    _IWmiFinalizer *pFnz = 0;
	    hRes = CreateSyncFinalizer(pCtx, &pFnz);
	    if (FAILED(hRes))
	        return hRes;
	    CReleaseMe _1(pFnz);

	    ULONG uTaskType = WMICORE_TASK_PUT_CLASS;
	    if (ppResult)
	        uTaskType |= WMICORE_TASK_TYPE_SEMISYNC;
	    else
	        uTaskType |= WMICORE_TASK_TYPE_SYNC;

	    // Do the work elsewhere.
	    // ======================

	    hRes = _PutClassAsync(uTaskType, pFnz, 0, pObj, lFlags & ~WBEM_RETURN_IMMEDIATELY,
	                     pCtx, NULL);

	    if (FAILED(hRes))
	        return hRes;

	    // Check for the two return paradigms.
	    // ===================================

	    if ((lFlags & WBEM_RETURN_IMMEDIATELY) == 0)
	    {
	        HRESULT hResTemp = pFnz->GetOperationResult(0, INFINITE, &hRes);
	        if (FAILED(hResTemp))
	            return hResTemp;
	    }
	    if (ppResult)
	    {
	        hRes = pFnz->GetResultObject(0, IID_IWbemCallResult, (LPVOID *) ppResult);
	    }

	    return hRes;

    }
    catch(...) // this interface calls the Exec_[MetrhodName] straight
    {
        ExceptionCounter c;    
        return WBEM_E_CRITICAL_ERROR;
    }
}


//***************************************************************************
//
//  CWbemNamespace::CancelAsyncRequest.
//
//  Currently a noop, eventually this function will cancel an asynchrnous
//  request based on the handle value it returned.
//
//  Parameters and return values are described in help
//
//***************************************************************************
HRESULT CWbemNamespace::CancelAsyncCall(IWbemObjectSink* pSink)
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Note that LOMEM_CHECK is not needed or wanted here

    if (pSink == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // Quickly cancel via Arbitrator.
    // ===============================
    if (m_pArb)
	{
		hRes = m_pArb->CancelTasksBySink(WMIARB_CALL_CANCELLED_CLIENT, IID_IWbemObjectSink, pSink);
	}

	return hRes ;

    /*
	// Add the request to the queue.
    // =============================

    hRes = WBEM_S_NO_ERROR;
    HRESULT hres;

    CAsyncReq_CancelAsyncCall *pReq = new
        CAsyncReq_CancelAsyncCall(pSink, NULL);

    if (!pReq)
        return WBEM_E_OUT_OF_MEMORY;

    hRes = ConfigMgr::EnqueueRequest(pReq);

    if (FAILED(hRes))
    {
        delete pReq;
        return WBEM_E_FAILED;
    }

    return WBEM_S_NO_ERROR;
	*/
}



//***************************************************************************
//
//  CWbemNamespace::PutInstance
//
//  Calls PutInstanceAsync and waits for completion
//
//  Parameters and return values are described in help
//
//***************************************************************************


HRESULT CWbemNamespace::PutInstance(
    IWbemClassObject* pInst,
    long lFlags,
    IWbemContext* pCtx,
    IWbemCallResult** ppResult
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Parameter validation.
    // =====================

    if (lFlags
        & ~WBEM_RETURN_IMMEDIATELY
        & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS
        & ~WBEM_FLAG_OWNER_UPDATE
        & ~WBEM_FLAG_CREATE_ONLY
        & ~WBEM_FLAG_UPDATE_ONLY
        & ~WBEM_FLAG_CREATE_OR_UPDATE
        )
        return WBEM_E_INVALID_PARAMETER;

    try
    {
	    if( ((lFlags & WBEM_FLAG_RETURN_IMMEDIATELY) == 0)&&(ppResult==NULL))
	    {
	        HANDLE hCurrentToken;
	        if(OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE,
	                            &hCurrentToken))
	        {
	            //
	            // Got a thread token --- cannot fast-track because otherwise we
	            // will have a thread token on a thread executing internal code
	            //

	            CloseHandle(hCurrentToken);
	        }
	        else if (CWbemQueue::GetCurrentRequest() == NULL)
	        {
	            IWbemContext *pContext = pCtx ;
	            if (pContext)
	                pContext->AddRef () ;
	            else
	            {
	                pContext = ConfigMgr::GetNewContext();
	                if ( pContext == NULL )
	                    return WBEM_E_OUT_OF_MEMORY;
	            }

	            CReleaseMe _1_pContext (pContext) ;

	            CSynchronousSink *pSyncSink = new CSynchronousSink;
	            if (pSyncSink == NULL)
	                return WBEM_E_OUT_OF_MEMORY;

	            pSyncSink->AddRef();
	            CReleaseMe _2(pSyncSink);

	            hRes = Exec_PutInstance(pInst, lFlags, pContext, pSyncSink);
	            //if (FAILED(hRes))
	            //    return hRes;

	            // Extract the new object from the sink.
	            // ======================================

	            pSyncSink->Block();

	            IWbemClassObject* pErrorObj = NULL;
	            pSyncSink->GetStatus(&hRes, NULL, &pErrorObj);
	            CReleaseMe rm1(pErrorObj);

	            if(pErrorObj)
	            {
	                IErrorInfo* pErrorInfo = NULL;
	                pErrorObj->QueryInterface(IID_IErrorInfo,
	                                       (void**)&pErrorInfo);
	                SetErrorInfo(0, pErrorInfo);
	                pErrorInfo->Release();
	            }

	            return hRes;
	        }
	    }


	    _variant_t v;
	    pInst->Get(L"__RELPATH", 0, &v, NULL, NULL);
	    if(V_VT(&v) == VT_BSTR)
	    {
	        DEBUGTRACE((LOG_WBEMCORE,
	            "CALL CWbemNamespace::PutInstance"
	            "   long lFlags = 0x%X\n"
	            "   IWbemClassObject *pInst = 0x%X\n"
	            "   __RELPATH = %S\n",
	            lFlags,
	            pInst,
	            V_BSTR(&v)
	            ));
	    }
	    else
	    {
	        DEBUGTRACE((LOG_WBEMCORE,
	            "CALL CWbemNamespace::PutInstance"
	            "   long lFlags = 0x%X\n"
	            "   IWbemClassObject *pInst = 0x%X\n",
	            lFlags,
	            pInst
	            ));
	    }



	    if ((lFlags & WBEM_RETURN_IMMEDIATELY) && ppResult == NULL)
	        return WBEM_E_INVALID_PARAMETER;

	    // Create Finalizer.
	    // =================

	    _IWmiFinalizer *pFnz = 0;
	    hRes = CreateSyncFinalizer(pCtx, &pFnz);
	    if (FAILED(hRes))
	        return hRes;
	    CReleaseMe _1(pFnz);

	    ULONG uTaskType = WMICORE_TASK_PUT_INSTANCE;
	    if (ppResult)
	        uTaskType |= WMICORE_TASK_TYPE_SEMISYNC;
	    else
	        uTaskType |= WMICORE_TASK_TYPE_SYNC;

	    // Do the work elsewhere.
	    // ======================

	    hRes = _PutInstanceAsync(uTaskType, pFnz, 0, pInst, lFlags & ~WBEM_RETURN_IMMEDIATELY,
	                     pCtx, NULL);

	    if (FAILED(hRes))
	        return hRes;

	    // Check for the two return paradigms.
	    // ===================================

	    if ((lFlags & WBEM_RETURN_IMMEDIATELY) == 0)
	    {
	        HRESULT hResTemp = pFnz->GetOperationResult(0, INFINITE, &hRes);
	        if (FAILED(hResTemp))
	            return hResTemp;
	    }
	    if (ppResult)
	    {
	        hRes = pFnz->GetResultObject(0, IID_IWbemCallResult, (LPVOID *) ppResult);
	    }

	    return hRes;

    }
    catch(...) // this interfaces calls the Exec_[MethodName]
    {
        ExceptionCounter c;    
        return WBEM_E_CRITICAL_ERROR;
    }
}


//***************************************************************************
//
//  CWbemNamespace::DeleteInstance
//
//  Calls DeleteInstanceAsync and waits for completion
//
//  Parameters and return values are described in help
//
//***************************************************************************

HRESULT CWbemNamespace::DeleteInstance(
    READONLY const BSTR strObjectPath,
    long lFlags,
    IWbemContext* pCtx,
    IWbemCallResult** ppResult
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::DeleteInstance\n"
        "   BSTR ObjectPath = %S\n"
        "   long lFlags = %d\n",
        strObjectPath, lFlags
        ));

    if (lFlags & ~WBEM_FLAG_RETURN_IMMEDIATELY &~ WBEM_FLAG_OWNER_UPDATE)
        return WBEM_E_INVALID_PARAMETER;

    if((lFlags & WBEM_RETURN_IMMEDIATELY) && ppResult == NULL)
        return WBEM_E_INVALID_PARAMETER;


    // Create Finalizer.
    // =================

    _IWmiFinalizer *pFnz = 0;
    hRes = CreateSyncFinalizer(pCtx, &pFnz);
    if (FAILED(hRes))
        return hRes;
    CReleaseMe _1(pFnz);

    ULONG uTaskType = WMICORE_TASK_DELETE_INSTANCE;
    if (ppResult)
        uTaskType |= WMICORE_TASK_TYPE_SEMISYNC;
    else
        uTaskType |= WMICORE_TASK_TYPE_SYNC;

    // Do the work elsewhere.
    // ======================

    hRes = _DeleteInstanceAsync(uTaskType, pFnz, 0, strObjectPath, lFlags & ~WBEM_RETURN_IMMEDIATELY,
                     pCtx, NULL);

    if (FAILED(hRes))
        return hRes;

    // Check for the two return paradigms.
    // ===================================

    if ((lFlags & WBEM_RETURN_IMMEDIATELY) == 0)
    {
        HRESULT hResTemp = pFnz->GetOperationResult(0,INFINITE, &hRes);
        if (FAILED(hResTemp))
            return hResTemp;
    }
    if (ppResult)
    {
        hRes = pFnz->GetResultObject(0, IID_IWbemCallResult, (LPVOID *) ppResult);
    }

    return hRes;
}


//***************************************************************************
//
//  CWbemNamespace::GetObject
//
//  Calls GetObjectAsync and waits for completion
//
//  Parameters and return values are described in help
//
//***************************************************************************

HRESULT CWbemNamespace::GetObject(
    READONLY const BSTR strObjectPath,
    long lFlags,
    IWbemContext* pCtx,
    NEWOBJECT IWbemClassObject** ppObj,
    NEWOBJECT IWbemCallResult** ppResult
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;
    if (!Allowed(WBEM_ENABLE))
        return WBEM_E_ACCESS_DENIED;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::GetObject\n"
        "   BSTR ObjectPath = %S\n"
        "   long lFlags = %d\n"
        "   IWbemClassObject ** pObj = 0x%X\n",
        strObjectPath,
        lFlags,
        ppObj
        ));

    if (ppObj)
        *ppObj = NULL;

    if (lFlags
        & ~WBEM_FLAG_RETURN_IMMEDIATELY
        & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS
        & ~WBEM_FLAG_DIRECT_READ
        )
        return WBEM_E_INVALID_PARAMETER;

    if ((lFlags & WBEM_RETURN_IMMEDIATELY) && ppResult == NULL)
        return WBEM_E_INVALID_PARAMETER;

    try
    {
	    if( ((lFlags & WBEM_FLAG_RETURN_IMMEDIATELY) == 0)&&(ppResult==NULL))
	    {
	        HANDLE hCurrentToken;
	        if(OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE,
	                            &hCurrentToken))
	        {
	            //
	            // Got a thread token --- cannot fast-track because otherwise we
	            // will have a thread token on a thread executing internal code
	            //

	            CloseHandle(hCurrentToken);
	        }
	        else if (CWbemQueue::GetCurrentRequest() == NULL)
	        {
	            IWbemContext *pContext = pCtx ;
	            if (pContext)
	                pContext->AddRef () ;
	                else
	            {
	                pContext = ConfigMgr::GetNewContext();
	                if ( pContext == NULL )
	                    return WBEM_E_OUT_OF_MEMORY;
	            }

	            CReleaseMe _1_pContext (pContext) ;

	            CSynchronousSink *pSyncSink = new CSynchronousSink;
	            if (pSyncSink == NULL)
	                return WBEM_E_OUT_OF_MEMORY;

	            pSyncSink->AddRef();
	            CReleaseMe _2(pSyncSink);

	            hRes = Exec_GetObject(strObjectPath, lFlags, pContext, pSyncSink);
	            //if (FAILED(hRes))
	            //{
	            //  return hRes;
	            //}

	            // Extract the new object from the sink.
	            // ======================================

	            pSyncSink->Block();

	            IWbemClassObject* pErrorObj = NULL;
	            pSyncSink->GetStatus(&hRes, NULL, &pErrorObj);
	            CReleaseMe rm1(pErrorObj);

	            if(pErrorObj)
	            {
	                IErrorInfo* pErrorInfo = NULL;
	                pErrorObj->QueryInterface(IID_IErrorInfo,
	                                       (void**)&pErrorInfo);
	                SetErrorInfo(0, pErrorInfo);
	                pErrorInfo->Release();
	            }

	            if (SUCCEEDED(hRes))
	            {
	                if(pSyncSink->GetObjects().GetSize() != 1)
	                    return WBEM_E_CRITICAL_ERROR;

	                // Only access the returned object if ppObj is non-NULL.
	                if ( NULL != ppObj )
	                {
	                    *ppObj = pSyncSink->GetObjects()[0];
	                    (*ppObj)->AddRef();
	                }
	            }

	            return hRes;
	        }
	    }

	    // Create Finalizer.
	    // =================

	    _IWmiFinalizer *pFnz = 0;
	    hRes = CreateSyncFinalizer(pCtx, &pFnz);
	    if (FAILED(hRes))
	        return hRes;
	    CReleaseMe _1(pFnz);

	    ULONG uTaskType = WMICORE_TASK_GET_OBJECT;
	    if (ppResult)
	        uTaskType |= WMICORE_TASK_TYPE_SEMISYNC;
	    else
	        uTaskType |= WMICORE_TASK_TYPE_SYNC;

	    // Do the work elsewhere.
	    // ======================

	    hRes = _GetObjectAsync(uTaskType, pFnz, 0, strObjectPath, lFlags & ~WBEM_RETURN_IMMEDIATELY,
	                     pCtx, NULL);

	    if (FAILED(hRes))
	    {
	        return hRes;
	    }

	    // Check for the two return paradigms.
	    // ===================================

	    if ((lFlags & WBEM_RETURN_IMMEDIATELY) == 0)
	    {
	        HRESULT hResTemp = pFnz->GetOperationResult(0, INFINITE, &hRes);
	        if (FAILED(hResTemp))
	            return hResTemp;
	        if (FAILED(hRes))
	            return hRes;
	    }

	    if (ppResult)
	    {
	        hRes = pFnz->GetResultObject(0, IID_IWbemCallResult, (LPVOID *) ppResult);
	        if (FAILED(hRes))
	        {
	            return hRes;
	        }
	        if (ppObj && ((lFlags & WBEM_RETURN_IMMEDIATELY) == 0))
	            hRes = (*ppResult)->GetResultObject(INFINITE, ppObj);
	    }
	    else if (ppObj && ((lFlags & WBEM_RETURN_IMMEDIATELY) == 0))
	    {
	        hRes = pFnz->GetResultObject(0, IID_IWbemClassObject, (LPVOID *) ppObj);
	    }

	    return hRes;
    }
    catch(...) // this interface goes to the Exec_[MethodName straight]
    {
        ExceptionCounter c;    
        return WBEM_E_CRITICAL_ERROR;
    }
}


//***************************************************************************
//
//  CWbemNamespace::ExecMethod
//
//***************************************************************************

HRESULT CWbemNamespace::ExecMethod(
    const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext *pCtx,
    IWbemClassObject *pInParams,
    IWbemClassObject **ppOutParams,
    IWbemCallResult  **ppResult
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::ExecMethod\n"
        "   BSTR ObjectPath = %S\n"
        "   BSTR MethodName = %S\n"
        "   long lFlags = %d\n"
        "   IWbemClassObject * pIn = 0x%X\n",
        ObjectPath, MethodName, lFlags, pInParams
        ));

    // Parameter validation.
    // =====================

    if (ppOutParams)
        *ppOutParams = NULL;

    if (lFlags & ~WBEM_FLAG_RETURN_IMMEDIATELY)
        return WBEM_E_INVALID_PARAMETER;

    // Create Finalizer.
    // =================

    _IWmiFinalizer *pFnz = 0;
    hRes = CreateSyncFinalizer(pCtx, &pFnz);
    if (FAILED(hRes))
        return hRes;
    CReleaseMe _1(pFnz);

    ULONG uTaskType = WMICORE_TASK_EXEC_METHOD;
    if (ppResult)
        uTaskType |= WMICORE_TASK_TYPE_SEMISYNC;
    else
        uTaskType |= WMICORE_TASK_TYPE_SYNC;

    // Do the work elsewhere.
    // ======================

    hRes = _ExecMethodAsync(uTaskType, pFnz, 0, ObjectPath, MethodName,
               lFlags & ~WBEM_RETURN_IMMEDIATELY, pCtx, pInParams, NULL);

    if (FAILED(hRes))
        return hRes;

    // Check for the two return paradigms.
    // ===================================

    if ((lFlags & WBEM_RETURN_IMMEDIATELY) == 0)
    {
        HRESULT hResTemp = pFnz->GetOperationResult(0, INFINITE, &hRes);
        if (FAILED(hResTemp))
            return hResTemp;
        if (FAILED(hRes))
            return hRes;
        if (ppResult)
        {
            hRes = pFnz->GetResultObject(0, IID_IWbemCallResult, (LPVOID *) ppResult);
            if (FAILED(hRes))
                return hRes;
            if (ppOutParams)
            {
                hRes = (*ppResult)->GetResultObject(INFINITE, ppOutParams);
                if (hRes == WBEM_E_NOT_FOUND)   //If there was no object we still return success!
                    hRes = WBEM_S_NO_ERROR;
            }
        }
        else
        {
            hRes = pFnz->GetResultObject(0, IID_IWbemClassObject, (LPVOID *) ppOutParams);
            if (hRes == WBEM_E_NOT_FOUND)   //If there was no object we still return success!
                hRes = WBEM_S_NO_ERROR;
        }
    }
    else
    {
		//
		// If we have a call result pointer we should try to use it
		//
		if ( ppResult )
		{
			hRes = pFnz->GetResultObject(0, IID_IWbemCallResult, (LPVOID *) ppResult);
			if (hRes == WBEM_E_NOT_FOUND)   //If there was no object we still return success!
				hRes = WBEM_S_NO_ERROR;
		}
    }


    return hRes;
}

//***************************************************************************
//
//  CWbemNamespace::CreateInstanceEnum
//
//  Calls CreateInstanceEnumAsync and waits for completion
//
//  Parameters and return values are described in help
//
//***************************************************************************
HRESULT CWbemNamespace::CreateInstanceEnum(
    const BSTR strClass,
    long lFlags,
    IWbemContext* pCtx,
    IEnumWbemClassObject** ppEnum
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::CreateInstanceEnum\n"
        "   long lFlags = 0x%X\n"
        "   BSTR Class = %S\n"
        "   IEnumWbemClassObject **pEnum = 0x%X\n",
        lFlags,
        strClass,
        ppEnum
        ));

    // Validate parameters
    // ===================

    if (lFlags
        & ~WBEM_RETURN_IMMEDIATELY
        & ~WBEM_FLAG_FORWARD_ONLY
        & ~WBEM_FLAG_DEEP
        & ~WBEM_FLAG_SHALLOW
        & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS
        & ~WBEM_FLAG_DIRECT_READ
        )
        return WBEM_E_INVALID_PARAMETER;

    if (ppEnum == NULL)
        return WBEM_E_INVALID_PARAMETER;
    *ppEnum = NULL;

    // Create Finalizer.
    // =================

    _IWmiFinalizer *pFnz = 0;
    hRes = CreateSyncFinalizer(pCtx, &pFnz);
    if (FAILED(hRes))
        return hRes;
    CReleaseMe _1(pFnz);

    ULONG uTaskType = WMICORE_TASK_ENUM_INSTANCES;
    if (lFlags & WBEM_RETURN_IMMEDIATELY)
        uTaskType |= WMICORE_TASK_TYPE_SEMISYNC;
    else
        uTaskType |= WMICORE_TASK_TYPE_SYNC;

    // Do the work.
    // ============

    hRes = _CreateInstanceEnumAsync(uTaskType, pFnz, 0, strClass,
                    lFlags & ~WBEM_RETURN_IMMEDIATELY & ~WBEM_FLAG_FORWARD_ONLY,
                    pCtx, NULL);

    if (FAILED(hRes))
        return hRes;

    if ((lFlags & WBEM_RETURN_IMMEDIATELY) == 0)
        pFnz->GetOperationResult(0, INFINITE, &hRes);

    if (SUCCEEDED(hRes))
    {
        IEnumWbemClassObject* pEnum = NULL;
        HRESULT hResTemp = pFnz->GetResultObject(lFlags, IID_IEnumWbemClassObject, (LPVOID*)&pEnum);
        if (FAILED(hResTemp))
            return hResTemp;
        CReleaseMe _2(pEnum);

        *ppEnum = pEnum;
        pEnum->AddRef();    // counteract CReleaseMe
    }

    return hRes;
}


//***************************************************************************
//
//  CWbemNamespace::CreateClassEnum
//
//  Invokes CreateClassEnumAsync and waits for completion. Actual work is
//  performed in Exec_CreateClassEnum.
//
//  Parameters and return values are described in help
//
//***************************************************************************
HRESULT CWbemNamespace::CreateClassEnum(
    const BSTR strParent,
    long lFlags,
    IWbemContext* pCtx,
    IEnumWbemClassObject **ppEnum
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::CreateClassEnum\n"
        "   BSTR Parent = %S\n"
        "   long lFlags = 0x%X\n"
        "   IEnumWbemClassObject = 0x%X\n",
        strParent,
        lFlags,
        ppEnum
        ));

    // Validate parameters
    // ===================

   if (lFlags
        & ~WBEM_FLAG_DEEP
        & ~WBEM_FLAG_SHALLOW
        & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS
        & ~WBEM_FLAG_RETURN_IMMEDIATELY
        & ~WBEM_FLAG_FORWARD_ONLY
        )
        return WBEM_E_INVALID_PARAMETER;

    if (ppEnum == NULL)
        return WBEM_E_INVALID_PARAMETER;

    *ppEnum = NULL;

    // Create Finalizer.
    // =================

    _IWmiFinalizer *pFnz = 0;
    hRes = CreateSyncFinalizer(pCtx, &pFnz);
    if (FAILED(hRes))
        return hRes;
    CReleaseMe _1(pFnz);

    ULONG uTaskType = WMICORE_TASK_ENUM_CLASSES;
    if (lFlags & WBEM_RETURN_IMMEDIATELY)
        uTaskType |= WMICORE_TASK_TYPE_SEMISYNC;
    else
        uTaskType |= WMICORE_TASK_TYPE_SYNC;

    // Do the work.
    // ============

    hRes = _CreateClassEnumAsync(uTaskType, pFnz, 0, strParent,
                    lFlags & ~WBEM_RETURN_IMMEDIATELY & ~WBEM_FLAG_FORWARD_ONLY,
                    pCtx, NULL);

    if (FAILED(hRes))
        return hRes;

    if ((lFlags & WBEM_RETURN_IMMEDIATELY) == 0)
        pFnz->GetOperationResult(0, INFINITE, &hRes);

    if (SUCCEEDED(hRes))
    {
        IEnumWbemClassObject* pEnum = NULL;
        HRESULT hResTemp = pFnz->GetResultObject(lFlags, IID_IEnumWbemClassObject, (LPVOID*)&pEnum);
        if (FAILED(hResTemp))
            return hResTemp;
        CReleaseMe _2(pEnum);

        *ppEnum = pEnum;
        pEnum->AddRef();    // Counteract CReleaseMe
    }
    return hRes;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::ExecQuery(
    READONLY const BSTR strQueryFormat,
    READONLY const BSTR strQuery,
    long lFlags,
    IWbemContext* pCtx,
    NEWOBJECT IEnumWbemClassObject** ppEnum
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::ExecQuery\n"
        "   BSTR QueryFormat = %S\n"
        "   BSTR Query = %S\n"
        "   IEnumWbemClassObject **pEnum = 0x%X\n",
        strQueryFormat,
        strQuery,
        ppEnum
        ));

    // Validate parameters
    // ===================

    if (lFlags
        & ~WBEM_FLAG_PROTOTYPE
        & ~WBEM_FLAG_ENSURE_LOCATABLE
        & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS
        & ~WBEM_FLAG_KEEP_SHAPE
        & ~WBEM_RETURN_IMMEDIATELY
        & ~WBEM_FLAG_FORWARD_ONLY
        & ~WBEM_FLAG_DIRECT_READ
        )
        return WBEM_E_INVALID_PARAMETER;

    if (ppEnum == NULL)
        return WBEM_E_INVALID_PARAMETER;

    try
    {        
	    *ppEnum = NULL;

	    // Create Finalizer.
	    _IWmiFinalizer *pFnz = 0;
	    hRes = CreateSyncFinalizer(pCtx, &pFnz);
	    if (FAILED(hRes))
	        return hRes;
	    CReleaseMe _1(pFnz);

	    ULONG uTaskType = WMICORE_TASK_EXEC_QUERY;
	    if (lFlags & WBEM_RETURN_IMMEDIATELY)
	        uTaskType |= WMICORE_TASK_TYPE_SEMISYNC;
	    else
	        uTaskType |= WMICORE_TASK_TYPE_SYNC;

	    // Do the work.
	    // ============

	    hRes = _ExecQueryAsync(uTaskType, pFnz, 0, strQueryFormat, strQuery,
	                    lFlags & ~WBEM_RETURN_IMMEDIATELY & ~WBEM_FLAG_FORWARD_ONLY,
	                    pCtx, NULL);

	    if (FAILED(hRes))
	        return hRes;

	    if ((lFlags & WBEM_RETURN_IMMEDIATELY) == 0)
	        pFnz->GetOperationResult(0, INFINITE, &hRes);

	    if (SUCCEEDED(hRes))
	    {
	        IEnumWbemClassObject* pEnum = NULL;
	        HRESULT hResTemp = pFnz->GetResultObject(lFlags, IID_IEnumWbemClassObject, (LPVOID*)&pEnum);
	        if (FAILED(hResTemp))
	            return hResTemp;
	        CReleaseMe _2(pEnum);

	        *ppEnum = pEnum;
	        pEnum->AddRef();    // Counteract CReleaseMe
	    }

	    return hRes;

    }
    catch(CX_MemoryException &)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        ExceptionCounter c;    
        return WBEM_E_CRITICAL_ERROR;
    }
}


//***************************************************************************
//
//  CWbemNamespace::Open
//
//***************************************************************************

HRESULT CWbemNamespace::Open(
            /* [in] */ const BSTR strScope,
            /* [in] */ const BSTR strParam,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServicesEx __RPC_FAR *__RPC_FAR *ppScope,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppResult
            )
{
    HRESULT hRes;

    // Check params.
    // =============

    if (strScope == 0)
        return WBEM_E_INVALID_PARAMETER;

    // Check flags.
    // ============

/*
    if (lFlags
       & ~WBEM_FLAG_OPEN_COLLECTION
       & ~WBEM_FLAG_OPEN_SCOPE
       & ~WBEM_FLAG_OPEN_NESTED_ONLY
       & ~WBEM_FLAG_OPEN_NAMESPACE
       & ~WBEM_FLAG_OPEN_VECTOR
       & ~WBEM_FLAG_OPEN_ALLOW_NS_TRAVERSAL
       & ~WBEM_FLAG_OPEN_ALLOW_MACHINE_TRAVERSAL
       )
       return WBEM_E_INVALID_PARAMETER;
*/
    if ((lFlags & WBEM_RETURN_IMMEDIATELY) && ppResult == NULL)
        return WBEM_E_INVALID_PARAMETER;

    if((lFlags & WBEM_FLAG_RETURN_IMMEDIATELY) == 0 || ppResult == NULL)
    {

        // Do the synchronous case.

        hRes = UniversalConnect(
            this,                   // Parent object
            pCtx,                   // Context
            strScope,               // New scope
            0,                      // Assoc selector
            m_wszUserName,          // User
            0,                      // _IWmiCallSec
            0,                      // _IWmiUser
            DWORD(lFlags),          // user flags
            0,                      // internal flags
            0,                      // sec flags
            0,                      // permission flags
            m_bForClient,           // for client
            m_bRepositOnly,
            NULL,
            0XFFFFFFFF,
            IID_IWbemServicesEx,    // temp
            (LPVOID *) ppScope
            );

        return hRes;
    }

    // Do semi synchronous
    // Create Finalizer.
    // =================

    _IWmiFinalizer *pFnz = 0;
    hRes = CreateSyncFinalizer(pCtx, &pFnz);
    if (FAILED(hRes))
        return hRes;
    CReleaseMe _1(pFnz);

    // Do the work elsewhere.
    // ======================

    hRes = _OpenAsync(
        WMICORE_TASK_TYPE_SEMISYNC | WMICORE_TASK_OPEN,
        pFnz, 0,
        strScope,
        strParam,
        lFlags,
        pCtx,
        NULL
        );

    if (FAILED(hRes))
        return hRes;

    hRes = pFnz->GetResultObject(0, IID_IWbemCallResult, (LPVOID *) ppResult);

    return hRes;
}


class CSecureEssNamespaceSink
    : public CUnkBase<IWbemObjectSink, &IID_IWbemObjectSink>
{
    CWbemPtr<CWbemNamespace> m_pNamespace;
    CWbemPtr<IWbemObjectSink> m_pSink;

public:
    CSecureEssNamespaceSink( CWbemNamespace* pNamespace,
                             IWbemObjectSink* pSink )
     : m_pNamespace(pNamespace), m_pSink(pSink) {}

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray)
    {
        HRESULT hRes = m_pNamespace->CheckNs();
        if (FAILED(hRes))
            return hRes;

        if ( !m_pNamespace->Allowed( WBEM_FULL_WRITE_REP ) )
            return WBEM_E_ACCESS_DENIED;
        
        return m_pSink->Indicate( lObjectCount, pObjArray );
    }

    STDMETHOD(SetStatus)(long a, long b, BSTR c, IWbemClassObject* d)
    {
        HRESULT hRes = m_pNamespace->CheckNs();
        if (FAILED(hRes))
            return hRes;

        if ( !m_pNamespace->Allowed( WBEM_FULL_WRITE_REP ) )
            return WBEM_E_ACCESS_DENIED;
        return m_pSink->SetStatus( a, b, c, d );
    }
};

//***************************************************************************
//
//  CWbemNamespace::QueryObjectSink
//
//  Returns the pointer to the ESS event handler. Clients can use this pointer
//  to supply events to WINMGMT. NOTE: this pointer will be NULL if ESS is
//  disabled (see cfgmgr.h).
//
//  Parameters and return values are described in help
//
//***************************************************************************
HRESULT CWbemNamespace::QueryObjectSink(
    long lFlags,
    IWbemObjectSink** ppHandler
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    if (!Allowed(WBEM_FULL_WRITE_REP))
        return WBEM_E_ACCESS_DENIED;

    if (ppHandler == NULL)
        return WBEM_E_INVALID_PARAMETER;

    if (lFlags != 0)
        return WBEM_E_INVALID_PARAMETER;

    IWbemEventSubsystem_m4* pEss = ConfigMgr::GetEssSink();
    if (pEss)
    {
        CReleaseMe rm_(pEss);
        WString sAdjustedNs;
        try
        {
            sAdjustedNs = "\\\\.\\";
            sAdjustedNs += m_pThisNamespace;
        }
        catch(CX_MemoryException &)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        CWbemPtr<IWbemObjectSink> pEssSink;
        hRes = pEss->GetNamespaceSink(sAdjustedNs, &pEssSink);

        if ( FAILED(hRes) )
            return hRes;

        CWbemPtr<CSecureEssNamespaceSink> pSecureSink =
            new CSecureEssNamespaceSink(this,pEssSink);

        if ( pSecureSink == NULL )
            return WBEM_E_OUT_OF_MEMORY;

        hRes = pSecureSink->QueryInterface( IID_IWbemObjectSink,
                                            (void**)ppHandler );

        return hRes;
    }
    else
    {
        return WBEM_E_NOT_SUPPORTED;
    }
}



//***************************************************************************
//
//  CWbemNamespace::OpenNamespace
//
//  Opens a child namespace of this one. Username, password, locale id,
//  flags and error object parameters are ignored.
//
//  Parameters:
//
//    BSTR NsPath                   Relative path to the namespace
//    BSTR User                     Reserved, must be NULL.
//    BSTR Password                 Reserved, must be NULL.
//    long lLocaleId                Reserved, must be NULL.
//    long lFlags                   Reserved, must be NULL.
//    IWbemServices **pNewContext    Destination for the new namespace pointer.
//                                  Must be released by the caller.
//    IWbemClassObject** ppErrorObj  Reserved, must be NULL.
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              On success
//      WBEM_E_INVALID_PARAMETER     Invalid name.
//
//***************************************************************************

HRESULT CWbemNamespace::OpenNamespace(
    const BSTR NsPath,
    long lFlags,
    IWbemContext* pCtx,
    IWbemServices **ppNewNamespace,
    IWbemCallResult **ppResult
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::OpenNamespace\n"
        "   BSTR NsPath = %S\n"
        "   long lFlags = %d\n"
        "   IWbemContext* pCtx = 0x%X\n"
        "   IWbemServices **pNewContext = 0x%X\n",
        NsPath,
        lFlags,
        pCtx,
        ppNewNamespace
        ));

    // Parameter validation.
    // =====================

    if (NsPath == 0 || wcslen(NsPath) == 0 ||
        (ppNewNamespace == NULL && ppResult == NULL))
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    if (ppNewNamespace == NULL && (lFlags & WBEM_RETURN_IMMEDIATELY) == 0)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    if ((lFlags & WBEM_RETURN_IMMEDIATELY) && ppNewNamespace)
        return WBEM_E_INVALID_PARAMETER;

    if(ppNewNamespace)
        *ppNewNamespace = NULL;
    if(ppResult)
        *ppResult = NULL;

    if((lFlags & ~WBEM_RETURN_IMMEDIATELY & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS & ~WBEM_FLAG_CONNECT_REPOSITORY_ONLY) != 0)
        return WBEM_E_INVALID_PARAMETER;

    bool bWin9XLocalSecurity = false;

    if(!IsNT())
        if(m_dwSecurityFlags & SecFlagWin9XLocal)
            bWin9XLocalSecurity = true;

    // If here, we found the object, so we open the
    // corresponding namespace.
    // ============================================

    WString NewNs = m_pThisNamespace;
    NewNs += L"\\";
    NewNs += NsPath;

    CCallResult* pResult = new CCallResult;
    if(pResult == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    // Schedule a request and wait
    // ===========================

    bool bForClient = m_bForClient ? true : false;

    CAsyncReq_OpenNamespace* pReq = 0;
    try
    {
        pReq = new CAsyncReq_OpenNamespace(
        this, NewNs,
        (bWin9XLocalSecurity) ? SecFlagWin9XLocal : lFlags & WBEM_FLAG_CONNECT_REPOSITORY_ONLY,
        (bWin9XLocalSecurity) ? m_dwPermission : 0,
        pCtx, pResult, bForClient);
    }
    catch(...)
    {
        ExceptionCounter c;    
        pReq = 0;
    }

    if (pReq == NULL)
    {
        delete pResult;
        return WBEM_E_OUT_OF_MEMORY;
    }

    HRESULT hres = ConfigMgr::EnqueueRequest(pReq);

    if ( FAILED(hres) )
    {
        delete pReq;
        pResult->Release();
        return hres;
    }

    if (ppResult)
    {
        *ppResult = pResult;
        pResult->AddRef();
    }

    if ((lFlags & WBEM_RETURN_IMMEDIATELY) == 0)
    {
        hres = pResult->GetResultServices(INFINITE, ppNewNamespace);
    }


    pResult->Release();

    return hres;
}


//***************************************************************************
//
//***************************************************************************
//

HRESULT CWbemNamespace::Add(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppResult
            )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::Add\n"
        "   BSTR ObjectPath = %S\n"
        "   long lFlags = %d\n"
        "   pCtx = 0x%X\n"
        "   ppCallResult = 0x%X\n",
        strObjectPath, lFlags, pCtx, ppResult
        ));


    // Create Finalizer.
    // =================

    _IWmiFinalizer *pFnz = 0;
    hRes = CreateSyncFinalizer(pCtx, &pFnz);
    if (FAILED(hRes))
        return hRes;
    CReleaseMe _1(pFnz);

    ULONG uTaskType = WMICORE_TASK_ADD;
    if (ppResult)
        uTaskType |= WMICORE_TASK_TYPE_SEMISYNC;
    else
        uTaskType |= WMICORE_TASK_TYPE_SYNC;

    // Do the work elsewhere.
    // ======================

    hRes = _AddAsync(uTaskType, pFnz, 0, strObjectPath, lFlags & ~WBEM_RETURN_IMMEDIATELY,
                     pCtx, NULL);

    if (FAILED(hRes))
        return hRes;

    // Check for the two return paradigms.
    // ===================================

    if ((lFlags & WBEM_RETURN_IMMEDIATELY) == 0)
    {
        HRESULT hResTemp = pFnz->GetOperationResult(0, INFINITE, &hRes);
        if (FAILED(hResTemp))
            return hResTemp;
    }
    else
    {
        hRes = pFnz->GetResultObject(0, IID_IWbemCallResult, (LPVOID *) ppResult);
    }

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWbemNamespace::Remove(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppResult
            )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::Remove\n"
        "   BSTR ObjectPath = %S\n"
        "   long lFlags = %d\n"
        "   pCtx = 0x%X\n"
        "   ppCallResult = 0x%X\n",
        strObjectPath, lFlags, pCtx, ppResult
        ));

    // Create Finalizer.
    // =================

    _IWmiFinalizer *pFnz = 0;
    hRes = CreateSyncFinalizer(pCtx, &pFnz);
    if (FAILED(hRes))
        return hRes;
    CReleaseMe _1(pFnz);

    ULONG uTaskType = WMICORE_TASK_REMOVE;
    if (ppResult)
        uTaskType |= WMICORE_TASK_TYPE_SEMISYNC;
    else
        uTaskType |= WMICORE_TASK_TYPE_SYNC;

    // Do the work elsewhere.
    // ======================

    hRes = _RemoveAsync(uTaskType, pFnz, 0, strObjectPath, lFlags & ~WBEM_RETURN_IMMEDIATELY,
                     pCtx, NULL);

    if (FAILED(hRes))
        return hRes;

    // Check for the two return paradigms.
    // ===================================

    if ((lFlags & WBEM_RETURN_IMMEDIATELY) == 0)
    {
        HRESULT hResTemp = pFnz->GetOperationResult(0, INFINITE, &hRes);
        if (FAILED(hResTemp))
            return hResTemp;
    }
    else
    {
        hRes = pFnz->GetResultObject(0, IID_IWbemCallResult, (LPVOID *) ppResult);
    }

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWbemNamespace:: RefreshObject(
            /* [out][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pTarget,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppResult
            )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::Refresh\n"
        "   pTarget = 0x%X\n"
        "   long lFlags = %d\n"
        "   pCtx = 0x%X\n"
        "   ppCallResult = 0x%X\n",
        pTarget, lFlags, pCtx, ppResult
        ));


    // Create Finalizer.
    // =================

    _IWmiFinalizer *pFnz = 0;
    hRes = CreateSyncFinalizer(pCtx, &pFnz);
    if (FAILED(hRes))
        return hRes;
    CReleaseMe _1(pFnz);

    ULONG uTaskType = WMICORE_TASK_ADD;
    if (ppResult)
        uTaskType |= WMICORE_TASK_TYPE_SEMISYNC;
    else
        uTaskType |= WMICORE_TASK_TYPE_SYNC;

    // Do the work elsewhere.
    // ======================

    hRes = _RefreshObjectAsync(uTaskType, pFnz, 0, pTarget, lFlags & ~WBEM_RETURN_IMMEDIATELY,
                     pCtx, NULL);

    if (FAILED(hRes))
        return hRes;

    // Check for the two return paradigms.
    // ===================================

    if ((lFlags & WBEM_RETURN_IMMEDIATELY) == 0)
    {
        HRESULT hResTemp = pFnz->GetOperationResult(0, INFINITE, &hRes);
        if (FAILED(hResTemp))
            return hResTemp;
    }
    else
    {
        hRes = pFnz->GetResultObject(0, IID_IWbemCallResult, (LPVOID *) ppResult);
    }

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWbemNamespace:: RenameObject(
            /* [in] */ const BSTR strOldObjectPath,
            /* [in] */ const BSTR strNewObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppResult
            )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::RenameObject\n"
        "   BSTR OldObjectPath = %S\n"
        "   BSTR NewObjectPath = %S\n"
        "   long lFlags = %d\n"
        "   pCtx = 0x%X\n"
        "   ppCallResult = 0x%X\n",
        strOldObjectPath,strNewObjectPath,
        lFlags, pCtx, ppResult
        ));


    // Create Finalizer.
    // =================

    _IWmiFinalizer *pFnz = 0;
    hRes = CreateSyncFinalizer(pCtx, &pFnz);
    if (FAILED(hRes))
        return hRes;
    CReleaseMe _1(pFnz);

    ULONG uTaskType = WMICORE_TASK_ADD;
    if (ppResult)
        uTaskType |= WMICORE_TASK_TYPE_SEMISYNC;
    else
        uTaskType |= WMICORE_TASK_TYPE_SYNC;

    // Do the work elsewhere.
    // ======================

    hRes = _RenameObjectAsync(uTaskType, pFnz, 0, strOldObjectPath, strNewObjectPath, lFlags & ~WBEM_RETURN_IMMEDIATELY,
                     pCtx, NULL);

    if (FAILED(hRes))
        return hRes;

    // Check for the two return paradigms.
    // ===================================

    if ((lFlags & WBEM_RETURN_IMMEDIATELY) == 0)
    {
        HRESULT hResTemp = pFnz->GetOperationResult(0, INFINITE, &hRes);
        if (FAILED(hResTemp))
            return hResTemp;
    }
    else
    {
        hRes = pFnz->GetResultObject(0, IID_IWbemCallResult, (LPVOID *) ppResult);
    }

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//


HRESULT CWbemNamespace::DeleteObject(
            IN const BSTR strObjectPath,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    HRESULT hRes;
    ULONGLONG uInf;

    // Parse the path and determine if a class or instance.

    IWbemPath *pPath = ConfigMgr::GetNewPath();
    CReleaseMe _(pPath);

    hRes = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, strObjectPath);
    if (FAILED(hRes))
        return hRes;

    hRes = pPath->GetInfo(0, &uInf);
    if (FAILED(hRes))
        return hRes;

    if (uInf & WBEMPATH_INFO_IS_CLASS_REF)
        return DeleteClass(strObjectPath, lFlags, pCtx, ppCallResult);
    else if (uInf & WBEMPATH_INFO_IS_INST_REF)
        return DeleteInstance(strObjectPath, lFlags, pCtx, ppCallResult);
    else
        return WBEM_E_INVALID_PARAMETER;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWbemNamespace::DeleteObjectAsync(
            IN const BSTR strObjectPath,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    HRESULT hRes;
    ULONGLONG uInf;

    // Parse the path and determine if a class or instance.

    IWbemPath *pPath = ConfigMgr::GetNewPath();
    CReleaseMe _(pPath);

    hRes = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, strObjectPath);
    if (FAILED(hRes))
        return hRes;

    hRes = pPath->GetInfo(0, &uInf);
    if (FAILED(hRes))
        return hRes;

    if (uInf & WBEMPATH_INFO_IS_CLASS_REF)
        return DeleteClassAsync(strObjectPath, lFlags, pCtx, pResponseHandler);
    else if (uInf & WBEMPATH_INFO_IS_INST_REF)
        return DeleteInstanceAsync(strObjectPath, lFlags, pCtx, pResponseHandler);
    else
        return WBEM_E_INVALID_PARAMETER;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWbemNamespace::PutObject(
            IN IWbemClassObject __RPC_FAR *pObj,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    HRESULT hRes;

    if (pObj == 0)
        return WBEM_E_INVALID_PARAMETER;

    CVARIANT v;
    pObj->Get(L"__GENUS", 0, &v, 0, 0);
    if (v.GetLONG() == 1)
        hRes = PutClass(pObj, lFlags, pCtx, ppCallResult);
    else if (v.GetLONG() == 2)
        hRes = PutInstance(pObj, lFlags, pCtx, ppCallResult);
    else
        hRes = WBEM_E_INVALID_OBJECT;

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::PutObjectAsync(
            IN IWbemClassObject __RPC_FAR *pObj,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    HRESULT hRes;

    if (pObj == 0)
        return WBEM_E_INVALID_PARAMETER;

    CVARIANT v;
    pObj->Get(L"__GENUS", 0, &v, 0, 0);
    if (v.GetLONG() == 1)
        hRes = PutClassAsync(pObj, lFlags, pCtx, pResponseHandler);
    else if (v.GetLONG() == 2)
        hRes = PutInstanceAsync(pObj, lFlags, pCtx, pResponseHandler);
    else
        hRes = WBEM_E_INVALID_OBJECT;

    return hRes;

}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//  Shutdown & Transactions
//
//

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWbemNamespace::Shutdown(
            /* [in] */ LONG uReason,
            /* [in] */ ULONG uMaxMilliseconds,
            /* [in] */ IWbemContext __RPC_FAR *pCtx
            )
{
    // Block access
    Status = WBEM_E_SHUTTING_DOWN;
    return WBEM_S_NO_ERROR;
}



//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::Exec_Open(
    LPWSTR pszScope,
    LPWSTR pszParam,
    LONG lUserFlags,
    IWbemContext *pCtx,
    IWbemObjectSinkEx *pSink
    )
{
    HRESULT hRes;
    IWbemServicesEx *pSvc = 0;

    hRes = UniversalConnect(
        this,           // Parent ns
        pCtx,           // Ctx
        pszScope,       // New scope
        pszParam,       // Assoc selector
        m_wszUserName,  // User name
        0,              // Call sec
        0,              // User obj
        lUserFlags,     // User Flags
        0,              // Internal flags
        m_dwSecurityFlags, // sec flags
        m_dwPermission,
        m_bForClient,
        m_bRepositOnly,
        NULL,
        0XFFFFFFFF,
        IID_IWbemServicesEx,
        (LPVOID *) &pSvc
        );

    if (SUCCEEDED(hRes))
    {
        pSink->Set(0, IID_IWbemServicesEx, pSvc);
    }
    pSink->SetStatus(0, hRes, 0, 0);
    return hRes;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::Exec_Add(
    LPWSTR pszPath,
    LONG lUserFlags,
    IWbemContext *pCtx,
    IWbemObjectSink *pSink
    )
{
    HRESULT hRes;
    IWbemClassObject *pNewAssocInst = 0;

    // Create an instance of the association and point it to the
    // known endpoint and the new object.

    if (pszPath == 0 || m_pCollectionClass == 0)
    {
        hRes = WBEM_E_INVALID_PARAMETER;
        pSink->SetStatus(0, hRes, 0, 0);
        return hRes;
    }

    hRes = m_pCollectionClass->SpawnInstance(0, &pNewAssocInst);
    if (FAILED(hRes))
    {
        pSink->SetStatus(0, hRes, 0, 0);
        return hRes;
    }
    CReleaseMe _1(pNewAssocInst);

    // Set the paths in the new assoc.
    // ===============================

    IWbemObjectAccess *pAcc = 0;
    hRes = pNewAssocInst->QueryInterface(IID_IWbemObjectAccess, (LPVOID *) pAcc);
    if (FAILED(hRes))
    {
        pSink->SetStatus(0, hRes, 0, 0);
        return hRes;
    }
    CReleaseMe _2(pAcc);

    hRes = pAcc->WritePropertyValue(m_lEpRefPropHandle, (wcslen(m_pszCollectionEpPath)+1) * 2,
        (BYTE *) m_pszCollectionEpPath);

    if (FAILED(hRes))
    {
        pSink->SetStatus(0, hRes, 0, 0);
        return hRes;
    }

    if (pszPath)
    {
        pAcc->WritePropertyValue(m_lTargetRefPropHandle, (wcslen(pszPath)+1) * 2, (BYTE *) pszPath);
        if (FAILED(hRes))
        {
            pSink->SetStatus(0, hRes, 0, 0);
            return hRes;
        }
    }
    else
    {
        pAcc->WritePropertyValue(m_lTargetRefPropHandle, 0, 0);
        if (FAILED(hRes))
        {
            pSink->SetStatus(0, hRes, 0, 0);
            return hRes;
        }
    }

    hRes = Exec_PutInstance(pNewAssocInst, 0, pCtx, (CBasicObjectSink *) pSink);    // Dangerous cast
    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::Exec_Remove(
    LPWSTR pszPath,
    LONG lUserFlags,
    IWbemContext *pCtx,
    IWbemObjectSink *pSink
    )
{
    // Find the association with the matching endpoint and remove it.

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::Exec_Rename(
    LPWSTR pszOld,
    LPWSTR pszNew,
    LONG lUserFlags,
    IWbemContext *pCtx,
    IWbemObjectSink *pSink
    )
{
    HRESULT hRes;

    if (pszOld == 0 || pszNew == 0)
    {
        hRes = WBEM_E_INVALID_PARAMETER;
        pSink->SetStatus(0, hRes, 0, 0);
        return hRes;
    }

    IWbemPath *pNewPath = ConfigMgr::GetNewPath();
    IWbemPath *pOldPath = ConfigMgr::GetNewPath();
    CReleaseMe _1(pNewPath);
    CReleaseMe _2(pOldPath);

    if (pNewPath == 0 || pOldPath == 0)
    {
        hRes = WBEM_E_OUT_OF_MEMORY;
        pSink->SetStatus(0, hRes, 0, 0);
        return hRes;
    }

    hRes = pNewPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, pszNew);
    if (FAILED(hRes))
    {
        pSink->SetStatus(0, hRes, 0, 0);
        return hRes;
    }

    hRes = pOldPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, pszOld);
    if (FAILED(hRes))
    {
        pSink->SetStatus(0, hRes, 0, 0);
        return hRes;
    }

    hRes = m_pSession->RenameObject(pOldPath, pNewPath, 0, 0, 0);
    pSink->SetStatus(0, hRes, 0, 0);

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::Exec_Refresh(
    IWbemClassObject *pObj,
    LONG lUserFlags,
    IWbemContext *pCtx,
    IWbemObjectSink *pSink
    )
{
    HRESULT hRes;
    _IWmiObject *pOld = 0, *pNew = 0;
    IWbemClassObject *pErrorObj = 0;

    if (pObj == 0)
    {
        hRes = WBEM_E_INVALID_PARAMETER;
        pSink->SetStatus(0, hRes, 0, 0);
        return hRes;
    }

    hRes = pObj->QueryInterface(IID__IWmiObject, (LPVOID *) &pOld);
    if (FAILED(hRes))
    {
        pSink->SetStatus(0, hRes, 0, 0);
        return hRes;
    }
    CReleaseMe _1(pOld);

    // Get the path of the object to be refreshed.
    // ===========================================

    CVARIANT vPath;
    hRes = pObj->Get(L"__PATH", 0, vPath, 0, 0);
    if (FAILED(hRes))
    {
        pSink->SetStatus(0, hRes, 0, 0);
        return hRes;
    }

    // Receive the new copy.
    // =====================

    CSynchronousSink *pSyncSink = new CSynchronousSink;
    if (pSyncSink == NULL)
    {
        hRes = WBEM_E_OUT_OF_MEMORY;
        pSink->SetStatus(0, hRes, 0, 0);
        return hRes;
    }
    pSyncSink->AddRef();
    CReleaseMe _2(pSyncSink);

    hRes = Exec_GetObject(vPath.GetStr(), 0, pCtx, pSyncSink);
    if (FAILED(hRes))
        return hRes;

    // Extract the new object from the sink.
    // ======================================

    pSyncSink->Block();
    pSyncSink->GetStatus(&hRes, NULL, &pErrorObj);

    if (FAILED(hRes))
    {
        pSink->SetStatus(0, hRes, 0, pErrorObj);
        if (pErrorObj)
            pErrorObj->Release();
        return hRes;
    }

    CRefedPointerArray<IWbemClassObject>& raObjects = pSyncSink->GetObjects();
    IWbemClassObject *pTarget = (IWbemClassObject *) raObjects[0];
    hRes = pTarget->QueryInterface(IID__IWmiObject, (LPVOID *) &pNew);
    if (FAILED(hRes))
    {
        pSink->SetStatus(0, hRes, 0, 0);
        return hRes;
    }
    CReleaseMe _3(pNew);

    // Replace the innards of the object we have.
    // ==========================================
    hRes = pOld->CopyInstanceData(0, pNew);
    pSink->SetStatus(0, hRes, 0, 0);
    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::ExecSyncQuery(
    IN  LPWSTR pszQuery,
    IN  IWbemContext *pCtx,
    IN  LONG lFlags,
    OUT CFlexArray &aDest
    )
{
    HRESULT hRes;
    CSynchronousSink* pSink = 0;

    pSink = new CSynchronousSink;
    if (NULL == pSink)
        return WBEM_E_OUT_OF_MEMORY;
    pSink->AddRef();
    CReleaseMe _1(pSink);

    hRes = CQueryEngine::ExecQuery(this, L"WQL", pszQuery, lFlags, pCtx, pSink);

    if (FAILED(hRes))
        return WBEM_E_CRITICAL_ERROR;

    pSink->GetStatus(&hRes, NULL, NULL);

    CRefedPointerArray<IWbemClassObject>& raObjects = pSink->GetObjects();

    for (int i = 0; i < raObjects.GetSize(); i++)
    {
        IWbemClassObject *pClsDef = (IWbemClassObject *) raObjects[i];
        pClsDef->AddRef();
        aDest.Add(pClsDef);
    }

    return hRes;
}

//***************************************************************************
//
//  CWbemNamespace::MapAssocRefsToClasses
//
//  Analyzes the association and determines which reference properties
//  point to which endpoints.  <pszAssocRef1> is the ref property
//  which can point to instances of <pClsDef1> and <pszAssocRef2> is
//  the property which can point to instances of <pClsDef2>.
//
//***************************************************************************
//
HRESULT CWbemNamespace::MapAssocRefsToClasses(
    IN  IWbemClassObject *pAssocClass,
    IN  IWbemClassObject *pClsDef1,
    IN  IWbemClassObject *pClsDef2,
    IN  LPWSTR *pszAssocRef1,
    OUT LPWSTR *pszAssocRef2
    )
{
    HRESULT hRes;

    // Note 97: Not valid for ternary assoc types
    // or derived types.
    // ===========================================

    // For each ref property, see if it can point to one of the endpoints.
    // ===================================================================

    pAssocClass->BeginEnumeration(WBEM_FLAG_REFS_ONLY);

    while (1)
    {
        BSTR strPropName = 0;
        hRes = pAssocClass->Next(
            0,                  // Flags
            &strPropName,       // Name
            0,                  // Value
            0,
            0
            );

        CSysFreeMe _1(strPropName);

        if (hRes == WBEM_S_NO_MORE_DATA)
            break;


        hRes = CAssocQuery::RoleTest(pClsDef1, pAssocClass, this, strPropName, ROLETEST_MODE_CIMREF_TYPE);
        if (SUCCEEDED(hRes))
        {
            *pszAssocRef1 = Macro_CloneLPWSTR(strPropName);
            continue;
        }

        hRes = CAssocQuery::RoleTest(pClsDef2, pAssocClass, this, strPropName, ROLETEST_MODE_CIMREF_TYPE);
        if (SUCCEEDED(hRes))
        {
            *pszAssocRef2 = Macro_CloneLPWSTR(strPropName);
            continue;
        }
    }   // Enum of ref properties


    pAssocClass->EndEnumeration();

    if (*pszAssocRef1 == 0 || *pszAssocRef2 == 0)
    {
        delete (*pszAssocRef1);
        delete (*pszAssocRef2);
        *pszAssocRef1 = 0;
        *pszAssocRef2 = 0;
        return WBEM_E_FAILED;
    }

    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::BuildAssocTriads(
    IN  IWbemClassObject *pAssocClass,              // Assoc class
    IN  IWbemClassObject *pClsDef1,                 // Class for EP1
    IN  IWbemClassObject *pClsDef2,                 // Class for EP2
    IN  LPWSTR pszJoinProp1,                        // Matching prop in EP1
    IN  LPWSTR pszJoinProp2,                        // Matching prop in EP2
    IN  LPWSTR pszAssocRef1,                        // Prop which points to EP1
    IN  LPWSTR pszAssocRef2,                        // Prop which points to EP2
    IN  CFlexArray &aEp1,                           // EP1 instances
    IN  CFlexArray &aEp2,                           // EP2 instances
    IN OUT CFlexArray &aTriads                      // OUT : Triad list
    )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    if (pszJoinProp1 == 0 || pszJoinProp2 == 0 || pAssocClass == 0 ||
        pszAssocRef1 == 0 || pszAssocRef2 == 0)
        return WBEM_E_INVALID_PARAMETER;

    // Do the matching.
    // ================

    for (int i = 0; i < aEp1.Size(); i++)
    {
        IWbemClassObject *pObj1 = (IWbemClassObject *) aEp1[i];
        CVARIANT v1;
        pObj1->Get(pszJoinProp1, 0, &v1, 0, 0);

        for (int i2 = 0; i2 < aEp2.Size(); i2++)
        {
            BOOL bMatch = FALSE;

            IWbemClassObject *pObj2 = (IWbemClassObject *) aEp2[i2];
            CVARIANT v2;
            pObj2->Get(pszJoinProp2, 0, &v2, 0, 0);

            if (V_VT(&v1) == VT_I4 && V_VT(&v2) == VT_I4)
            {
                if (v1.GetLONG() == v2.GetLONG())
                {
                    bMatch = TRUE;
                }
            }
            else if (V_VT(&v1) == VT_BSTR && V_VT(&v2) == VT_BSTR)
            {
                if (_wcsicmp(v1.GetStr(), v2.GetStr()) == 0)
                {
                    bMatch = TRUE;
                }
            }

            // If a match, spawn the association and bind it.
            // ==============================================

            if (bMatch)
            {
                IWbemClassObject *pAssocInst = 0;
                pAssocClass->SpawnInstance(0, &pAssocInst);

                CVARIANT vPath1, vPath2;

                pObj1->Get(L"__RELPATH", 0, &vPath1, 0, 0);
                pObj2->Get(L"__RELPATH", 0, &vPath2, 0, 0);

                pAssocInst->Put(pszAssocRef1, 0, &vPath1, 0);
                pAssocInst->Put(pszAssocRef2, 0, &vPath2, 0);

                SAssocTriad *pTriad = new SAssocTriad;

                if (pTriad)
                {
	                pTriad->m_pEp1 = pObj1;
	                pTriad->m_pEp1->AddRef();
	                pTriad->m_pEp2 = pObj2;
	                pTriad->m_pEp2->AddRef();
	                pTriad->m_pAssoc = pAssocInst;

	                aTriads.Add(pTriad);
                }
                else
                {
                    hRes = WBEM_E_OUT_OF_MEMORY;
                }
            }
        }
    }

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::ExtractEpInfoFromQuery(
    IN IWbemQuery *pQuery,
    OUT LPWSTR *pszRetClass1,
    OUT LPWSTR *pszRetProp1,
    OUT LPWSTR *pszRetClass2,
    OUT LPWSTR *pszRetProp2
    )
{
    HRESULT hRes;
    SWQLNode *pRoot;

    hRes = pQuery->GetAnalysis(
        WMIQ_ANALYSIS_RESERVED,
        0,
        (LPVOID *) &pRoot
        );

    if (FAILED(hRes))
        return hRes;

    // Move down the parse tree to find the JOIN clause.
    // =================================================

    if (!pRoot || pRoot->m_dwNodeType != TYPE_SWQLNode_QueryRoot)
        return WBEM_E_INVALID_QUERY;
    pRoot = pRoot->m_pLeft;
    if (!pRoot || pRoot->m_dwNodeType != TYPE_SWQLNode_Select)
        return WBEM_E_INVALID_QUERY;
    pRoot = pRoot->m_pLeft;
    if (!pRoot || pRoot->m_dwNodeType != TYPE_SWQLNode_TableRefs)
        return WBEM_E_INVALID_QUERY;
    pRoot = pRoot->m_pRight;
    if (!pRoot || pRoot->m_dwNodeType != TYPE_SWQLNode_FromClause)
        return WBEM_E_INVALID_QUERY;
    pRoot = pRoot->m_pLeft;
    if (!pRoot || pRoot->m_dwNodeType != TYPE_SWQLNode_Join)
        return WBEM_E_INVALID_QUERY;

    // We are now at the JOIN node.
    // ============================

    SWQLNode_Join *pJoin = (SWQLNode_Join *) pRoot;

    /* The parse tree is left-heavy and looks like this:

             JN               Join node
            /   \             /        \
          JP     OC       JoinPair     OnClause
         /  \               /   \
        TR   TR        TableRef TableRef
    */

    // First, get the first table & prop.
    // ==================================
    SWQLNode_JoinPair *pPair = (SWQLNode_JoinPair *) pJoin->m_pLeft;
    if (!pPair || pPair->m_dwNodeType != TYPE_SWQLNode_JoinPair)
        return WBEM_E_INVALID_QUERY;

    SWQLNode_TableRef *pT1 = (SWQLNode_TableRef *) pPair->m_pLeft;
    SWQLNode_TableRef *pT2 = (SWQLNode_TableRef *) pPair->m_pRight;

    if (!pT1 || !pT2)
        return WBEM_E_INVALID_QUERY;

    SWQLNode_OnClause *pOC = (SWQLNode_OnClause *) pJoin->m_pRight;
    if (!pOC)
        return WBEM_E_INVALID_QUERY;

    SWQLNode_RelExpr *pRE = (SWQLNode_RelExpr *) pOC->m_pLeft;
    if (!pRE)
        return WBEM_E_INVALID_QUERY;

    if (pRE->m_dwExprType != WQL_TOK_TYPED_EXPR)
        return WBEM_E_INVALID_QUERY;

    // We now have the table names available and the matching condition.
    // ==================================================================

    LPWSTR pszClass = pRE->m_pTypedExpr->m_pTableRef;
    LPWSTR pszProp = pRE->m_pTypedExpr->m_pColRef;
    LPWSTR pszClass2 = pRE->m_pTypedExpr->m_pJoinTableRef;
    LPWSTR pszProp2 = pRE->m_pTypedExpr->m_pJoinColRef;

    if (_wcsicmp(pT1->m_pTableName, pszClass) != 0)
        pszClass = pT1->m_pAlias;

    if (_wcsicmp(pT2->m_pTableName, pszClass2) != 0)
        pszClass2 = pT2->m_pAlias;

    if (pszClass == 0 || pszProp == 0 || pszClass2 == 0 || pszProp2 == 0)
        return WBEM_E_INVALID_QUERY;


    *pszRetClass1 = Macro_CloneLPWSTR(pszClass);
    *pszRetProp1 = Macro_CloneLPWSTR(pszProp);
    *pszRetClass2 = Macro_CloneLPWSTR(pszClass2),
    *pszRetProp2 = Macro_CloneLPWSTR(pszProp2);

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//  CWbemNamespace::BuildRuleBasedPathToInst
//
//  Based on the incoming info, computes the path to the would-be other
//  endpoint.
//
//  <pEp>           The known endpoint.
//  <pszJoinProp1>  The property in <pEp> which matches the property in the
//                  unknown EP.
//  <pEp2>          Class for the other endpoint.
//  <pszJoinProp2>  The property in the other class which matches the
//                  <pszJoinProp1> in the known endpoint class.
//  <wsNewPath>     The proposed path to the instance of class <pEp2>. Who
//                  knows whether or not we will find it, but we can try.
//
//***************************************************************************
//
HRESULT CWbemNamespace::BuildRuleBasedPathToInst(
    IWbemClassObject *pEp,
    LPWSTR pszJoinProp1,
    IWbemClassObject *pEp2,
    LPWSTR pszJoinProp2,
    OUT WString &wsNewPath
    )
{
    HRESULT hRes;

    // Get the property from the <pEp> which is the cause of all the fuss.
    // ===================================================================

    CVARIANT vProp;
    hRes = pEp->Get(pszJoinProp1, 0, &vProp, 0, 0);
    if (FAILED(hRes))
        return hRes;

    CVARIANT vClass2;
    hRes = pEp2->Get(L"__CLASS", 0, &vClass2, 0, 0);

    wsNewPath = vClass2.GetStr();
    wsNewPath += L".";
    wsNewPath += pszJoinProp2;
    wsNewPath += L"=";

    // Note 98: Doesn't work for compound keys!! Yuck.
    // ===============================================

    VARIANT vDest;
    VariantInit(&vDest);
    hRes = VariantChangeType(&vDest, &vProp, 0, VT_BSTR);
	if ( SUCCEEDED ( hRes ) )
	{
	    wsNewPath += V_BSTR(&vDest);
	}
    VariantClear(&vDest);

    return hRes;
}

//***************************************************************************
//
//  CWbemNamespace::ManufactureAssocs
//
//  Manufactures the associations based on the rule in the <pszJoinQuery>
//  which was extracted from the <rulebased> qualifier.  Queries the two
//  endpoint classes and joins the instances to produce the associations
//
//  <pAssocClass>   The association class definition which contains the rule.
//  <pEp>           Optional endpoint object.  If not NULL, only objects
//                  which associate to this endpoint will be returned in
//                  the triad list, typically a single object.
//  <pCtx>          Call context
//  <pszJoinQuery>  The rule query text
//  <aTriads>       Receives the output, an array of SAssocTriad pointers.
//                  Caller must call SAssocTriad::ArrayCleanup.
//
//***************************************************************************

HRESULT CWbemNamespace::ManufactureAssocs(
    IN  IWbemClassObject *pAssocClass,
    IN  IWbemClassObject *pEp,          // Optional
    IN  IWbemContext *pCtx,
    IN  LPWSTR pszJoinQuery,
    OUT CFlexArray &aTriads
    )
{
    HRESULT hRes;
    WString q1, q2;

    CFlexArray aEp1List, aEp2List;
    LPWSTR pClassName1 = 0;
    LPWSTR pClassName2 = 0;
    LPWSTR pszJoinProp1 = 0;
    LPWSTR pszJoinProp2 = 0;
    LPWSTR pszAssocRef1 = 0;
    LPWSTR pszAssocRef2 = 0;
    _IWmiQuery *pQuery = 0;
    IWbemClassObject *pClsDef1 = 0, *pClsDef2 = 0;
    IWbemClassObject *pEp2 = 0;

    // Parse the query.
    // ================
    CCoreServices *pSvc = CCoreServices::CreateInstance();
    CReleaseMe _1(pSvc);

    hRes = pSvc->CreateQueryParser(0, &pQuery);
    if (FAILED(hRes))
        return hRes;    
    CReleaseMe _2(pQuery);

    hRes = pQuery->Parse(L"SQL", pszJoinQuery, 0);
    if (FAILED(hRes))
        return hRes;

    // Extract the endpoint class names.
    // ==================================

    hRes = ExtractEpInfoFromQuery(pQuery, &pClassName1, &pszJoinProp1, &pClassName2, &pszJoinProp2);
    if (FAILED(hRes))
        goto Exit;

    // Get the endpoint class defs.
    // ============================

    hRes = InternalGetClass(pClassName1, &pClsDef1);
    if (FAILED(hRes))
        goto Exit;

    hRes = InternalGetClass(pClassName2, &pClsDef2);
    if (FAILED(hRes))
        goto Exit;

    // Map which assoc ref properties point to which class.
    // ====================================================
    hRes = MapAssocRefsToClasses(pAssocClass, pClsDef1, pClsDef2, &pszAssocRef1, &pszAssocRef2);
    if (FAILED(hRes))
        goto Exit;

    // If no specific endpoint, an enumeration is requested.  We query the endpoint
    // classes completely and match everything up.
    // ============================================================================

    if (pEp == 0)
    {
        // Build the queries.
        // ===================
        q1 = "select * from ";
        q1 += pClassName1;
        q2 = "select * from ";
        q2 += pClassName2;

        hRes = ExecSyncQuery(q1, pCtx, 0, aEp1List);
        if (FAILED(hRes))
            goto Exit;

        hRes = ExecSyncQuery(q2, pCtx, 0, aEp2List);
        if (FAILED(hRes))
            goto Exit;
    }
    else
    {
        // Note 99: Oversimplified in that it doesn't do an enum; assumes a 1:1 mapping.
        // Compute the path to the other endpoint based on the rule.
        // =============================================================================

        WString wsNewPath;
        hRes = BuildRuleBasedPathToInst(pEp, pszJoinProp1, pClsDef2, pszJoinProp2, wsNewPath);
        if (FAILED(hRes))
            goto Exit;

        // Do a get object.
        // ================

        hRes = InternalGetInstance(wsNewPath, &pEp2);
        if (FAILED(hRes))
            goto Exit;

        aEp1List.Add(pEp);
        aEp2List.Add(pEp2);
    }

    // Now, match up the results.
    // For single-object type scenarios, the arrays simply have one element in them. Ho hum.
    // =====================================================================================

    hRes = BuildAssocTriads(
        pAssocClass,
        pClsDef1,
        pClsDef2,
        pszJoinProp1,
        pszJoinProp2,
        pszAssocRef1,
        pszAssocRef2,
        aEp1List,
        aEp2List,
        aTriads                         // OUT
        );

    if (FAILED(hRes))
    {
        EmptyObjectList(aTriads);
        goto Exit;
    }

    hRes = WBEM_S_NO_ERROR;

Exit:
    EmptyObjectList(aEp1List);
    EmptyObjectList(aEp2List);
    ReleaseIfNotNULL(pClsDef1);
    ReleaseIfNotNULL(pClsDef2);
    ReleaseIfNotNULL(pEp2);
    delete [] pClassName1;
    delete [] pClassName2;
    delete [] pszJoinProp1;
    delete [] pszJoinProp2;
    delete [] pszAssocRef1;
    delete [] pszAssocRef2;

    return hRes;
}

void CWbemNamespace::EmptyObjectList(CFlexArray &aTarget)
{
    for (int i = 0; i < aTarget.Size(); i++)
    {
        IWbemClassObject *pObj = (IWbemClassObject *) aTarget[i];
        pObj->Release();
    }
    aTarget.Empty();
}


//***************************************************************************
//
//  CWbemNamespace::GetAceList
//
//  Retrieves the ACEs associated with this namespace
//
//  <ppAceList>     Flexarray to hold ACE list
//
//***************************************************************************
HRESULT CWbemNamespace::GetAceList(CFlexAceArray** ppAceList)
{
    HRESULT hRes=S_OK;

    *ppAceList = new CFlexAceArray;
    if (ppAceList==NULL)
        hRes = WBEM_E_OUT_OF_MEMORY;
    else
    {
        // 1. Get security descriptor
        CNtSecurityDescriptor& sd = GetSDRef();

        // 2. Get the DACL
        CNtAcl* pDacl;
        pDacl = sd.GetDacl();
        if ( pDacl==NULL )
            return WBEM_E_OUT_OF_MEMORY;

        CDeleteMe<CNtAcl> dm(pDacl);

        // 3. Loop through DACL
        int iNumAces = pDacl->GetNumAces();
        for ( int i=0; i<iNumAces; i++ )
        {
            CNtAce* Ace;
            Ace = pDacl->GetAce(i);
            if ( Ace == NULL )
                return WBEM_E_OUT_OF_MEMORY;

            (*ppAceList)->Add (Ace);
        }
    }
    return hRes;
}



//***************************************************************************
//
//  CWbemNamespace::PutAceList
//
//  Puts the ACEs associated with this namespace
//
//  <ppAceList>     Flexarray ACE list
//
//***************************************************************************
HRESULT CWbemNamespace::PutAceList(CFlexAceArray* pFlex)
{
    SCODE sc = S_OK;

    CNtAcl DestAcl;

    int iNumAces = pFlex->Size();
    for (int i=0; i<iNumAces; i++ )
    {
        if ( DestAcl.AddAce ((CNtAce*) pFlex->GetAt(i)) == FALSE )
        {
            return WBEM_E_INVALID_OBJECT;
        }
    }
    if ( m_sd.SetDacl (&DestAcl) == FALSE )
        return WBEM_E_INVALID_OBJECT;

    sc = StoreSDIntoNamespace(m_pSession, m_pNsHandle, m_sd);
    if ( !FAILED (sc) )
        sc = RecursiveSDMerge();
    return sc;
}

//***************************************************************************
//
//  CWbemNamespace::GetDynamicReferenceClasses
//
//  Asks the provider subsystem for dynamic association classes.
//
//
//***************************************************************************
HRESULT CWbemNamespace::GetDynamicReferenceClasses( long lFlags, IWbemContext
* pCtx, IWbemObjectSink* pSink )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    _IWmiProviderAssociatorsHelper* pAssocHelp = NULL;

    if ( m_pProvFact)
    {
        hRes = m_pProvFact->GetClassProvider(
                    0,                  // lFlags
                    pCtx,
                    m_wszUserName,
                    m_wsLocale,
                    m_pThisNamespace,                     // IWbemPath pointer
                    0,
                    IID__IWmiProviderAssociatorsHelper,
                    (LPVOID *) &pAssocHelp
                    );
     
        CReleaseMe  rm( pAssocHelp );

        if ( SUCCEEDED( hRes ) )
        {
            hRes = pAssocHelp->GetReferencesClasses( lFlags, pCtx, pSink );
        }

        if ( FAILED( hRes ) )
        {
            pSink->SetStatus( 0L, hRes, 0L, 0L );
        }
    }
    else
    {
        pSink->SetStatus( 0L, WBEM_S_NO_ERROR, 0L, 0L );
    }

    return hRes;

}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\sysclass2.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SYSCLASS.H

Abstract:

    System class generation function.


History:

--*/

#ifndef __SYSCLASS__H_
#define __SYSCLASS__H_

HRESULT GetSystemStdObjects(CFlexArray * Results);
HRESULT GetSystemSecurityObjects(CFlexArray * Results);
HRESULT GetSystemRootObjects(CFlexArray * Results);
struct prop
{
	WCHAR * pName;
	VARTYPE vtCimType;
	WCHAR * pValue;			// all values are expressed in strings which will be converted
};

struct qual
{
	WCHAR * pName;
	WCHAR * pPropName;		// null if class qualifier
	VARTYPE vtCimType;
	WCHAR * pValue;			// all values are expressed in strings which will be converted
	DWORD dwFlavor;
};

struct Method
{
	WCHAR * pName;
	VARTYPE vtReturnType;
	prop * pProps;
	qual * pQuals;
};


struct ObjectDef
{
	WCHAR * pName;
	ObjectDef * pParent;
	int iNumProps;
	prop * pProps;
	int iNumQuals;
	qual * pQuals;
	int iNumMethods;
	Method * pMethods;
};

class CGenClass : public CWbemClass
{
public:
    CGenClass(){}
};
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\wmiarbitrator.cpp ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    WmiArbitrator.cpp

Abstract:
    Implementation of the arbitrator.  The arbitrator is the class which
    watches over everything to make sure it is not using too many resources.
    Big brother is watching over you :-)


History:
    paulall     09-Apr-00       Created.
    raymcc      08-Aug-00       Made it actually do something useful

--*/

#include "precomp.h"
#include "wbemint.h"
#include "wbemcli.h"

#include "wbemcore.h"
#include "wmiarbitrator.h"
#include "wmifinalizer.h"
#include "wmimerger.h"
#include "cfgmgr.h"

#include <sync.h>
#include <tchar.h>
#include <malloc.h>

CWmiArbitrator *CWmiArbitrator::m_pArb = 0;

static DWORD g_dwHighwaterTasks = 0;
static DWORD g_dwThrottlingEnabled = 1;

extern LONG s_Finalizer_ObjectCount ;

#define MEM_CHECK_INTERVAL              3000            //  3 seconds
#define POLL_INTERVAL                     75            // milliseconds

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Arbitrator defaults
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#define ARBITRATOR_NO_THROTTLING        0
#define ARBITRATOR_DO_THROTTLING        1

#define ARB_DEFAULT_SYSTEM_HIGH				0x4c4b400               // System limits [80megs]
#define ARB_DEFAULT_SYSTEM_HIGH_FACTOR		50						// System limits [80megs] factor
#define ARB_DEFAULT_SYSTEM_REQUEST_FACTOR	0.9						// Percentage factor determining new request approval
#define ARB_DEFAULT_MAX_SLEEP_TIME			300000                  // Default max sleep time for each task
#define ARB_DEFAULT_HIGH_THRESHOLD1			90                      // High threshold 1
#define ARB_DEFAULT_HIGH_THRESHOLD1MULT		2                       // High threshold 1 multiplier
#define ARB_DEFAULT_HIGH_THRESHOLD2			95                      // High threshold 1
#define ARB_DEFAULT_HIGH_THRESHOLD2MULT		3                       // High threshold 1 multiplier
#define ARB_DEFAULT_HIGH_THRESHOLD3			98                      // High threshold 1
#define ARB_DEFAULT_HIGH_THRESHOLD3MULT		4                       // High threshold 1 multiplier


#define REGKEY_CIMOM                    "Software\\Microsoft\\Wbem\\CIMOM"
#define REGVALUE_SYSHIGH                "ArbSystemHighMaxLimit"
#define REGVALUE_MAXSLEEP               "ArbTaskMaxSleep"
#define REGVALUE_HT1                    "ArbSystemHighThreshold1"
#define REGVALUE_HT1M                   "ArbSystemHighThreshold1Mult"
#define REGVALUE_HT2                    "ArbSystemHighThreshold2"
#define REGVALUE_HT2M                   "ArbSystemHighThreshold2Mult"
#define REGVALUE_HT3                    "ArbSystemHighThreshold3"
#define REGVALUE_HT3M                   "ArbSystemHighThreshold3Mult"
#define REGVALUE_THROTTLING_ENABLED     "ArbThrottlingEnabled"


static DWORD ProcessCommitCharge();
static DWORD WINAPI TaskDiagnosticThread(CWmiArbitrator *pArb);

// Enables debug messages for additional info.
#ifdef DBG
  //#define __DEBUG_ARBITRATOR_THROTTLING
#endif


BOOL CWmiArbitrator::CheckSetupSwitch ( void )
{
    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                    L"system\\Setup",
                    0, KEY_READ, &hKey);
    if(lRes)
        return FALSE;

    DWORD dwSetupRunning;
    DWORD dwLen = sizeof(DWORD);
    lRes = RegQueryValueExW(hKey, L"SystemSetupInProgress", NULL, NULL,
                (LPBYTE)&dwSetupRunning, &dwLen);
    RegCloseKey(hKey);

    if(lRes == ERROR_SUCCESS && (dwSetupRunning == 1))
    {
        return TRUE;
    }
    return FALSE;
}



//***************************************************************************
//
//***************************************************************************
HRESULT CWmiArbitrator::Initialize(
    IN _IWmiArbitrator ** ppArb
    )
{
    if (!ppArb)
    	return WBEM_E_INVALID_PARAMETER;
    if (NULL == m_pArb)
        m_pArb = new CWmiArbitrator; // inital refcout == 1
    if (!m_pArb)
        return WBEM_E_OUT_OF_MEMORY;

    if (m_pArb->m_hTerminateEvent)
    {
        if (!TaskDiagnosticThread(m_pArb))
        {
            // no diagnostic thread, do not leak the vent
            CloseHandle(m_pArb->m_hTerminateEvent);
            m_pArb->m_hTerminateEvent = NULL;
        }
    }


    m_pArb->InitializeRegistryData ( );

    *ppArb = m_pArb;
    (* ppArb)->AddRef();

    return WBEM_S_NO_ERROR;
}



//***************************************************************************
//
//***************************************************************************
HRESULT CWmiArbitrator::InitializeRegistryData( )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

	m_bSetupRunning = FALSE;

    m_uTotalMemoryUsage = 0;
    m_uTotalSleepTime = 0;

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Get Arbitrator related info from registry
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    ULONG ulSystemHighFactor = ARB_DEFAULT_SYSTEM_HIGH_FACTOR ;

	ConfigMgr::GetArbitratorValues( &g_dwThrottlingEnabled, &ulSystemHighFactor, &m_lMaxSleepTime,
                                &m_dThreshold1, &m_lThreshold1Mult, &m_dThreshold2,
                                &m_lThreshold2Mult, &m_dThreshold3, &m_lThreshold3Mult );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Initially, Floating Low is the same as System High
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	m_fSystemHighFactor = ulSystemHighFactor / ( (double) 100 ) ;
	m_lFloatingLow = 0 ;
	m_uSystemHigh = 0 ;

	UpdateMemoryCounters ( TRUE ) ;								// TRUE = Force the update of counters since we're just starting up


    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Calculate the base multiplier
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    m_lMultiplier = ( ARB_DEFAULT_MAX_SLEEP_TIME / (double) m_uSystemHigh ) ;

	m_bSetupRunning = CheckSetupSwitch ( );
	if ( m_bSetupRunning )
	{
		g_dwThrottlingEnabled = FALSE;
	}

	m_lUncheckedCount = ConfigMgr::GetUncheckedTaskCount ( );

    return hRes;
}


//***************************************************************************
//
HRESULT CWmiArbitrator::Shutdown(BOOL bIsSystemShutdown)
{
    if (m_pArb)
    {
        // Mark all namespaces so as to no longer accept requests

        {
            CInCritSec _cs ( &m_pArb->m_csNamespace );

            if (m_pArb->m_hTerminateEvent)
                SetEvent(m_pArb->m_hTerminateEvent);

            for (int i = 0; i < m_pArb->m_aNamespaces.Size(); i++)
            {
                CWbemNamespace *pRemove = (CWbemNamespace *) m_pArb->m_aNamespaces[i];
                if(pRemove)
                {
                    pRemove->StopClientCalls();
                }
            }
        }

        // cancel all tasks

        CFlexArray aCanceled;

        // Grab all outstanding tasks which require cancellation.
        // ======================================================


        {
            CInCritSec _cs2 ( &m_pArb->m_csTask );
            for (int i = 0; i < m_pArb->m_aTasks.Size(); i++)
            {
                CWmiTask *pTask = (CWmiTask *) m_pArb->m_aTasks[i];
                if (pTask == 0)
                    continue;

                pTask->AddRef();
                int nRes = aCanceled.Add(pTask);
                if (nRes)   // On error only
                    pTask->Release();
            }
        }


        // Now cancel all those.
        // =====================

        if (!bIsSystemShutdown)
        {
	        for (int i = 0; i < aCanceled.Size(); i++)
	        {
	            CWmiTask *pTask = (CWmiTask *) aCanceled[i];
	            if (pTask)
	            {
	                pTask->Cancel();
	                pTask->Release();
	            }
	        }
        }


        {
            CInCritSec _cs2 ( &m_pArb->m_csTask );
            for (int i = m_pArb->m_aTasks.Size() - 1; i >= 0; i--)
            {
                CWmiTask *pTask = (CWmiTask *) m_pArb->m_aTasks[i];
                if (pTask == 0)
                    continue;
              
				pTask->Release();
            }
            m_pArb->m_aTasks.Empty();
        }

		{
			CInCritSec cs (  &m_pArb->m_csArbitration );

			ULONG lDelta = -(m_pArb->m_uTotalMemoryUsage) ;
			m_pArb->m_uTotalMemoryUsage += lDelta ;

			// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			// Since the first thing we do in ReportMemoryUsage and Throttle is to
			// call UpdateCounters we could be in the position where someone
			// attempts to call with a delta that drops us below zero. If so, we
			// ignore it
			// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			m_pArb->m_lFloatingLow -= lDelta;
		}
	}
   
    if (m_pArb)
    {
        m_pArb->Release();
        m_pArb = NULL;
    }
    	
    return WBEM_S_NO_ERROR;
}


//////// test test test test test

BOOL CWmiArbitrator::IsTaskInList(CWmiTask * pf)
{
    CInCritSec cs(&m_csTask);

    for (int i = 0; i < m_aTasks.Size(); i++)
    {
        CWmiTask *phTest = (CWmiTask *) m_aTasks[i];

        if (phTest == pf)
        {
            return TRUE;
        }
    }
    return FALSE;
}



//////// test test test test test

//***************************************************************************
//
//***************************************************************************
CWmiArbitrator::CWmiArbitrator()
{
    m_lRefCount = 1;

    m_uTotalTasks = 0;
    m_uTotalPrimaryTasks = 0;
	m_uTotalThrottledTasks = 0 ;

    //InitializeCriticalSection(&m_csTask);
    //InitializeCriticalSection(&m_csNamespace);
    //InitializeCriticalSection ( &m_csArbitration );

    m_hTerminateEvent = CreateEvent(NULL,TRUE,FALSE,NULL);

}

//***************************************************************************
//
//***************************************************************************
CWmiArbitrator::~CWmiArbitrator()
{
    //DeleteCriticalSection(&m_csTask);
    //DeleteCriticalSection(&m_csNamespace);
    //DeleteCriticalSection( &m_csArbitration );

    if (m_hTerminateEvent)
        CloseHandle(m_hTerminateEvent);
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = 0;

    if (IID_IUnknown==riid || IID__IWmiArbitrator==riid)
    {
        *ppvObj = (_IWmiArbitrator*)this;
        AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;

}

//***************************************************************************
//
//***************************************************************************
ULONG CWmiArbitrator::AddRef()
{
    //DWORD * p = (DWORD *)_alloca(sizeof(DWORD));
    return InterlockedIncrement(&m_lRefCount);
}

//***************************************************************************
//
//***************************************************************************
ULONG CWmiArbitrator::Release()
{
    //DWORD * p = (DWORD *)_alloca(sizeof(DWORD));
    ULONG uNewCount = InterlockedDecrement(&m_lRefCount);
    if (0 == uNewCount)
        delete this;
    return uNewCount;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::RegisterTask(
    /*[in]*/ _IWmiCoreHandle *phTask
    )
{
    CWmiTask *pTsk = (CWmiTask *) phTask;

    if (pTsk == 0 || phTask == 0)
        return WBEM_E_INVALID_PARAMETER;

    ULONG uTaskType = pTsk->GetTaskType();

    // For primary task types only.
    // ============================

    DWORD dwMaxTasksAllowed = ConfigMgr::GetMaxTaskCount();

    if (dwMaxTasksAllowed && (uTaskType & WMICORE_TASK_TYPE_PRIMARY))
    {
        // Initial check.  If too many tasks, wait a bit.
        // No need for strict synchronization with the critsec
        // or exact maximum.  An approximation can obviously
        // happen (several threads can be let through and the maximum
        // exceeded by several units) No big deal, though.
        // ==========================================================

        int nTotalRetryTime = 0;

        if ( 
        		!pTsk->IsESSNamespace ( ) && 
	        	!pTsk->IsProviderNamespace ( ) &&         		
	        	CORE_TASK_TYPE(uTaskType) != WMICORE_TASK_EXEC_NOTIFICATION_QUERY && 
	        	!m_bSetupRunning &&
				IsTaskArbitrated ( pTsk ) )
          {
            while (m_uTotalPrimaryTasks > dwMaxTasksAllowed)
            {
                Sleep(POLL_INTERVAL);
                nTotalRetryTime += POLL_INTERVAL;
                if (nTotalRetryTime > ConfigMgr::GetMaxWaitBeforeDenial())
                    return WBEM_E_SERVER_TOO_BUSY;
            }
        }

		nTotalRetryTime = 0;

        // Check max committed memory.
        // ============================
        if ( !m_bSetupRunning )
        {
	        /*DWORD dwMaxMem = ConfigMgr::GetMaxMemoryQuota();
	        DWORD dwCurrentCharge = ProcessCommitCharge();*/

	        while ( ( AcceptsNewTasks ( ) == FALSE ) && 
					( uTaskType & WMICORE_TASK_TYPE_PRIMARY ) &&
					( pTsk->IsESSNamespace ( ) == FALSE ) && 
					( pTsk->IsProviderNamespace ( ) == FALSE ) && 
					( m_bSetupRunning == FALSE ) &&
					( IsTaskArbitrated ( pTsk ) == TRUE ) )

	        {
	            Sleep(POLL_INTERVAL);
	            nTotalRetryTime += POLL_INTERVAL;
	            if (nTotalRetryTime > ConfigMgr::GetMaxWaitBeforeDenial())
	                return WBEM_E_QUOTA_VIOLATION;
	        }
        }


        // Now, we fit within the max. Still, if there are several
        // ongoing tasks, sleep various amounts.
        // ========================================================

        nTotalRetryTime = 0;


        if ( 
	        	!pTsk->IsESSNamespace ( ) && 
				!pTsk->IsProviderNamespace ( ) && 
		        CORE_TASK_TYPE(uTaskType) != WMICORE_TASK_EXEC_NOTIFICATION_QUERY && 
	        	!m_bSetupRunning &&
				IsTaskArbitrated ( pTsk ) )
        {
            //if (m_uTotalPrimaryTasks > ConfigMgr::GetUncheckedTaskCount())
            //if (m_uTotalPrimaryTasks > m_lUncheckedCount )
			if (m_uTotalThrottledTasks > m_lUncheckedCount )
            {
                int nTotalTime = m_uTotalThrottledTasks * ConfigMgr::GetNewTaskResistance();

                while (nTotalRetryTime < nTotalTime)
                {
                    Sleep(POLL_INTERVAL);
                    nTotalRetryTime += POLL_INTERVAL;
                    if (m_uTotalThrottledTasks <= m_lUncheckedCount )
                        break;
                }
            }
        }
    }

    // Go ahead and add the task.
    // ==========================

    {
        CInCritSec _cs2 ( &m_csTask );

        phTask->AddRef();
        int nRes = m_aTasks.Add(phTask);
        if (nRes != CFlexArray::no_error)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

		m_uTotalTasks++;

        if (m_uTotalTasks > g_dwHighwaterTasks)
            g_dwHighwaterTasks = m_uTotalTasks;

        if ( ( uTaskType & WMICORE_TASK_TYPE_PRIMARY ) && CORE_TASK_TYPE(uTaskType) != WMICORE_TASK_EXEC_NOTIFICATION_QUERY )
        {
            m_uTotalPrimaryTasks++;
			
			//
			// If this task hasnt been accounted for in the number of throttled tasks,
			// increase the nymber of throttled tasks
			//
			if ( pTsk->IsAccountedForThrottling ( ) == FALSE )
			{
				RegisterTaskForEntryThrottling ( pTsk ) ;
			}
        }
        m_lMultiplierTasks = ( m_uTotalPrimaryTasks / (DOUBLE) 100 ) + 1;
    }
    return WBEM_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::UnregisterTask(
    /*[in]*/ _IWmiCoreHandle *phTask
    )
{
    CWmiTask *pTsk = (CWmiTask *) phTask;
    
    if (pTsk == 0)
        return WBEM_E_INVALID_PARAMETER;

    ULONG uTaskType = pTsk->GetTaskType();

    CCheckedInCritSec _cs2 ( &m_csTask );

    for (int i = 0; i < m_aTasks.Size(); i++)
    {
        _IWmiCoreHandle *phTest = (_IWmiCoreHandle *) m_aTasks[i];

        if (phTest == phTask)
        {
            CWmiTask *pTsk = (CWmiTask *) phTask;   // Cannot be NULL due to precondition above

            m_aTasks.RemoveAt(i);
			m_uTotalTasks--;

			ClearCounters ( 0 ) ;
		
			ULONG uType = pTsk->GetTaskType();
            if ( ( uType & WMICORE_TASK_TYPE_PRIMARY ) && CORE_TASK_TYPE(uTaskType) != WMICORE_TASK_EXEC_NOTIFICATION_QUERY )
			{
				m_uTotalPrimaryTasks--;
		
				//
				// If this task hasnt been accounted for in the number of throttled tasks,
				// increase the nymber of throttled tasks
				//
				if ( pTsk->IsAccountedForThrottling ( ) == TRUE )
				{
					UnregisterTaskForEntryThrottling ( pTsk ) ;
				}
			}

			

            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // Throttle code
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            if ( g_dwThrottlingEnabled )
            {
                if ( IsTaskArbitrated ( pTsk ) )
                {
                    m_lMultiplierTasks = ( m_uTotalPrimaryTasks / (DOUBLE) 100 ) + 1;

                    //
					// What we _were_ doing here was to update the counters with the total amount of memory
					// the task had consumed, since we were cancelling it. Problem with this is that the 
					// finalizer may be in the process of being destructed in which case it called to report
					// negative memory usage and we hit a brk pnt due to total memory usage going below 0.
					//
					/*ULONG uTaskMemUsage;
                    pTsk->GetMemoryUsage ( &uTaskMemUsage );
                    LONG lDelta = uTaskMemUsage*-1;
					UpdateCounters ( lDelta, pTsk ); 

					if ( m_aTasks.Size() == 0 )
					{
						UpdateCounters ( -m_uTotalMemoryUsage, NULL ) ;
					} */
                }

                // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                // When we unregister a task we also have to make sure the task
                // isnt suspended (throttled). If it is, we need to wake up the
                // throttled thread.
                // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                if ( pTsk->GetTaskStatus ( ) == WMICORE_TASK_STATUS_SUSPENDED )
                {
                    SetEvent ( pTsk->GetTimerHandle ( ) );
                }
            }

            _cs2.Leave ( );

            //
			// If we cancelled due to throttling, ensure that we use the client flag to avoid returning -1 as the
			// operation result.
			//
			if ( pTsk->GetCancelledState ( ) == TRUE )
			{
				pTsk->Cancel ( WMIARB_CALL_CANCELLED_THROTTLING) ;
			}
			else
			{
				pTsk->Cancel ( ) ;
			}
            
            phTask->Release();

            return WBEM_S_NO_ERROR;
        }
    }
    return WBEM_E_NOT_FOUND;
}


//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::RegisterUser(
    /*[in]*/ _IWmiCoreHandle *phUser
    )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::UnregisterUser(
    /*[in]*/ _IWmiCoreHandle *phUser
    )
{
    return E_NOTIMPL;
}


//***************************************************************************
//
//***************************************************************************
//
STDMETHODIMP CWmiArbitrator::CancelTasksBySink(
    ULONG uFlags,
    REFIID riid,
    LPVOID pSink
    )
{
    int nRes;
    HRESULT hRes;

    if (riid != IID_IWbemObjectSink)
        return WBEM_E_NOT_SUPPORTED;

    if (pSink == 0)
        return WBEM_E_INVALID_PARAMETER;

    try
    {
        CFlexArray aCanceled;

        // Grab all outstanding tasks which require cancellation.
        // ======================================================

        // scope for critsect

        {
            CInCritSec _cs2 ( &m_csTask );

            // Loop through tasks looking for matchin sink.
            // ============================================

            for (int i = 0; i < m_aTasks.Size(); i++)
            {
                CWmiTask *pTask = (CWmiTask *) m_aTasks[i];
                if (pTask == 0)
                    continue;

                if (pTask->HasMatchingSink(pSink, riid) == WBEM_S_NO_ERROR)
                {
                    pTask->AddRef();
                    nRes = aCanceled.Add(pTask);
                    if (nRes)
                    {
                        pTask->Release();
                        return WBEM_E_OUT_OF_MEMORY;
                    }
                }
            }

            // Next get all dependent tasks, because they also need cancelling.
            // Essentially a transitive closure of all child tasks.
            // ================================================================

            for (i = 0; i < aCanceled.Size(); i++)
            {
                CWmiTask *pTask = (CWmiTask *) aCanceled[i];
                CWbemContext *pCtx = pTask->GetCtx();
                if (pCtx == 0)
                    continue;
                GUID PrimaryId = GUID_NULL;
                pCtx->GetRequestId(&PrimaryId);
                if (PrimaryId == GUID_NULL)
                    continue;

                // <Id> is now the context request ID which needs cancellation.

                for (int i2 = 0; i2 < m_aTasks.Size(); i2++)
                {
                    CWmiTask *pTask2 = (CWmiTask *) m_aTasks[i2];
                    if (pTask2 == 0 || pTask2 == pTask)
                        continue;

                    CWbemContext *pCtx = pTask2->GetCtx();
                    if (pCtx == 0)
                        continue;
                    hRes = pCtx->IsChildOf(PrimaryId);
                    if (hRes == S_OK)
                    {
                        pTask2->AddRef();
                        nRes = aCanceled.Add(pTask2);
                        if (nRes)
                            return WBEM_E_OUT_OF_MEMORY;
                    }
                } // for i2
            } // for i
        } // critsec block


        // Now cancel all those.
        // =====================

        for (int i = 0; i < aCanceled.Size(); i++)
        {
            CWmiTask *pTask = (CWmiTask *) aCanceled[i];
            if (pTask)
            {
                // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                // Throttle code
                // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                if ( g_dwThrottlingEnabled )
                {
                    if ( IsTaskArbitrated ( pTask ) )
                    {
                        m_lMultiplierTasks = ( m_uTotalPrimaryTasks / (DOUBLE) 100 ) + 1;

						//
						// What we _were_ doing here was to update the counters with the total amount of memory
						// the task had consumed, since we were cancelling it. Problem with this is that the 
						// finalizer may be in the process of being destructed in which case it called to report
						// negative memory usage and we hit a brk pnt due to total memory usage going below 0.
						//
						/*ULONG uTaskMemUsage;
                        pTask->GetMemoryUsage ( &uTaskMemUsage );
                        LONG lDelta = uTaskMemUsage*-1;
                        UpdateCounters ( lDelta, pTask );*/
                    }

                    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    // When we unregister a task we also have to make sure the task
                    // isnt suspended (throttled). If it is, we need to wake up the
                    // throttled thread.
                    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    if ( pTask->GetTaskStatus ( ) == WMICORE_TASK_STATUS_SUSPENDED )
                    {
                        SetEvent ( pTask->GetTimerHandle ( ) );
                    }
                }

                if ( uFlags == WMIARB_CALL_CANCELLED_CLIENT )
				{
					pTask->Cancel ( WMIARB_CALL_CANCELLED_CLIENT ) ;
				}
				else
				{
					pTask->Cancel (  ) ;
				}
                pTask->Release();
            }
        }
    }    
    catch (...) //untrusted code barrier // Something went wrong up there
    {
        ExceptionCounter c;    
        return WBEM_E_CRITICAL_ERROR;
    }

    return 0;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::CheckTask(
    /*[in]*/ ULONG uFlags,
    /*[in]*/ _IWmiCoreHandle *phTask
    )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::TaskStateChange(
    /*[in]*/ ULONG uNewState,               // Duplicate of the state in the task handle itself
    /*[in]*/ _IWmiCoreHandle *phTask
    )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::CheckThread(
    /*[in]*/ ULONG uFlags
    )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::CheckUser(
    /*[in]*/ ULONG uFlags,
    /*[in]*/ _IWmiUserHandle *phUser
    )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::CheckUser(
    /*[in]*/ ULONG uFlags,
    /*[in]*/ _IWmiCoreHandle *phUser
    )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::CancelTask(
    /*[in]*/ ULONG uFlags,
    /*[in]*/ _IWmiCoreHandle *phTask
    )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    CWmiTask* pTask = (CWmiTask*) phTask;
    if ( !pTask )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    hRes = pTask->SignalCancellation ( ) ;
	
    return hRes;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::RegisterThreadForTask(
    /*[in]*/_IWmiCoreHandle *phTask
    )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::UnregisterThreadForTask(
    /*[in]*/_IWmiCoreHandle *phTask
    )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::Maintenance()
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::RegisterFinalizer(
    /*[in]*/ ULONG uFlags,
    /*[in]*/ _IWmiCoreHandle *phTask,
    /*[in]*/ _IWmiFinalizer *pFinal
    )
{
    // Attach finalizer to task

    CWmiTask *p = (CWmiTask *) phTask;
    if (!p)
        return WBEM_E_INVALID_PARAMETER;

    p->SetFinalizer(pFinal);

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::RegisterNamespace(
    /*[in]*/_IWmiCoreHandle *phNamespace
    )
{
    CWbemNamespace *pNS = (CWbemNamespace *) phNamespace;

    if (pNS == 0 || phNamespace == 0)
        return WBEM_E_INVALID_PARAMETER;

    CInCritSec cs(&m_csNamespace);
    int nRes = m_aNamespaces.Add(pNS);
    if (nRes != CFlexArray::no_error)
        return WBEM_E_OUT_OF_MEMORY;

    pNS->AddRefPrimary();
    return S_OK;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::UnregisterNamespace(
    /*[in]*/_IWmiCoreHandle *phNamespace
    )
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    CWbemNamespace *pNS = (CWbemNamespace *) phNamespace;

    if (pNS == 0 || phNamespace == 0)
        return WBEM_E_INVALID_PARAMETER;

    pNS->AddRefPrimary();

    // create a scope
    {
        CInCritSec cs(&m_csNamespace);

        for (int i = 0; i < m_aNamespaces.Size(); i++)
        {
            CWbemNamespace *phTest = (CWbemNamespace *) m_aNamespaces[i];

            if (phTest == pNS)
            {
                m_aNamespaces.RemoveAt(i);
                hr =  S_OK;
                break;
            }
        }
    }

    pNS->ReleasePrimary();
    
    if (S_OK == hr)  // pointer is found
    {
        pNS->ReleasePrimary();    
    }

    return hr;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::ReportMemoryUsage(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ LONG  lDelta,
        /*[in]*/ _IWmiCoreHandle *phTask
    )
{
    HRESULT hRes = WBEM_S_ARB_NOTHROTTLING;


	CWmiTask* pTsk = (CWmiTask*) phTask;
    if ( !pTsk )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Check to see if we have throttling enabled via registry
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if ( g_dwThrottlingEnabled )
    {
		//
        // We want to throttle against the primary task, so get the
        // primary task now. If this is the primary task it will return
        // itself. No special casing needed.
        //
        _IWmiCoreHandle* pCHTask;
        pTsk->GetPrimaryTask ( &pCHTask );
        if ( pCHTask == NULL )
            return WBEM_E_INVALID_PARAMETER;

        CWmiTask* pTask = (CWmiTask*) pCHTask;
        if ( !pTask )
            return WBEM_E_INVALID_PARAMETER;

		
		// 
		// Since we have a valid task, update the counters. We _need_ to do this
		// even after the task has been cancelled since we outstanding memory
		// consumption
		// 
		UpdateCounters ( lDelta, pTask );


		// 
		// Has the task been cancelled, if so return NO_THROTTLING
		// 
		if ( pTsk->GetTaskStatus ( ) == WMICORE_TASK_STATUS_CANCELLED )
		{
			return WBEM_S_ARB_NOTHROTTLING ;
		}
        

        if ( pTask->GetTaskStatus ( ) == WMICORE_TASK_STATUS_CANCELLED )
        {
            return WBEM_E_CALL_CANCELLED;
        }

        if ( !IsTaskArbitrated ( pTask ) )
        {
            return hRes;
        }

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // First thing we do is check if we're pushed over the limit.
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        
		if ( m_uTotalMemoryUsage > m_uSystemHigh )
        {
            hRes = WBEM_E_ARB_CANCEL;
            pTask->SetCancelState ( TRUE );
        }

        else
        {
            pTask->SetCancelState ( FALSE );
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // Next, we call our internal function with no
            // throttling
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            hRes = Arbitrate ( ARBITRATOR_NO_THROTTLING, lDelta, pTask );
        }
    }
    return hRes;
}



//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::Throttle(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ _IWmiCoreHandle* phTask
    )
{
    HRESULT hRes = WBEM_S_ARB_NOTHROTTLING;

    if ( !phTask )
    {
        return WBEM_E_INVALID_PARAMETER;
    }


    CWmiTask* pTsk = (CWmiTask*) phTask;
    if ( !pTsk )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Has the task been cancelled, if so return NO_THROTTLING
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if ( pTsk->GetTaskStatus ( ) == WMICORE_TASK_STATUS_CANCELLED )
    {
        return WBEM_S_ARB_NOTHROTTLING;
    }


    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Check to see if we have throttling enabled via registry
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if ( g_dwThrottlingEnabled )
    {

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // We want to throttle against the primary task, so get the
        // primary task now. If this is the primary task it will return
        // itself. No special casing needed.
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        _IWmiCoreHandle* pCHTask;
        pTsk->GetPrimaryTask ( &pCHTask );
        if ( pCHTask == NULL )
            return WBEM_E_INVALID_PARAMETER;

        CWmiTask* pTask = (CWmiTask*) pCHTask;
        if ( !pTask )
            return WBEM_E_INVALID_PARAMETER;


        if ( pTask->GetTaskStatus ( ) == WMICORE_TASK_STATUS_CANCELLED )
        {
            return WBEM_E_CALL_CANCELLED;
        }

        if ( !IsTaskArbitrated ( pTask ) )
        {
            return hRes;
        }

        ULONG lCancelState;
        pTask->GetCancelState ( &lCancelState );


        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Check if this task was promised to be cancelled
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if ( ( m_uTotalMemoryUsage > m_uSystemHigh ) && ( lCancelState ) )
        {
            #ifdef __DEBUG_ARBITRATOR_THROTTLING
                WCHAR   wszTemp[128];
                wsprintf( wszTemp, L"Task 0x%x cancelled due to arbitrator throttling (max memory threshold reached).\n", pTask );
                OutputDebugStringW( wszTemp );
            #endif
            DEBUGTRACE((LOG_WBEMCORE, "Task 0x%x cancelled due to arbitrator throttling (max memory threshold reached).\n", pTask ) );

            pTask->Cancel ( );
            hRes = WBEM_E_ARB_CANCEL;
        }
        else
        {
            hRes = Arbitrate ( ARBITRATOR_DO_THROTTLING, 0, (CWmiTask*) phTask );
        }
    }
    return hRes;
}


//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::RegisterArbitratee(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ _IWmiCoreHandle *phTask,
        /*[in]*/ _IWmiArbitratee *pArbitratee
    )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    CWmiTask *p = (CWmiTask *) phTask;
    if (!p || !pArbitratee)
    {
        hRes = WBEM_E_INVALID_PARAMETER;
    }

    CWmiTask* pTask = (CWmiTask*) phTask;
    if ( !pTask )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    if ( pTask->GetTaskStatus ( ) == WMICORE_TASK_STATUS_CANCELLED )
    {
        return WBEM_E_CALL_CANCELLED;
    }

    if ( SUCCEEDED (hRes) )
    {
        hRes = p->AddArbitratee(0, pArbitratee);
    }

    return hRes;
}



//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::UnRegisterArbitratee(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ _IWmiCoreHandle *phTask,
        /*[in]*/ _IWmiArbitratee *pArbitratee
    )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    CWmiTask *p = (CWmiTask *) phTask;
    if (!p || !pArbitratee )
    {
        hRes = WBEM_E_INVALID_PARAMETER;
    }

    if ( SUCCEEDED (hRes) )
    {
        hRes = p->RemoveArbitratee(0, pArbitratee);
    }

	ClearCounters ( 0 ) ;

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
HRESULT CWmiArbitrator::UpdateCounters ( LONG lDelta, CWmiTask* phTask )
{
    CInCritSec cs ( &m_csArbitration );

	//
	// Lets see if we need to update memory counters
	//
	UpdateMemoryCounters ( ) ;

	
#ifdef __DEBUG_ARBITRATOR_THROTTLING	
	_DBG_ASSERT ( m_uTotalMemoryUsage+lDelta <= 0xF0000000 ) ;
#endif

	m_uTotalMemoryUsage += lDelta;
	m_lFloatingLow -= lDelta;

	if ( phTask )
	{
		phTask->UpdateMemoryUsage ( lDelta );
	}

	return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************
HRESULT CWmiArbitrator::Arbitrate ( ULONG uFlags, LONG lDelta, CWmiTask* phTask )
{
    HRESULT hRes = WBEM_S_ARB_NOTHROTTLING;

    ULONG memUsage;
    ULONG sleepTime;

    if ( lDelta > 0 || (uFlags == ARBITRATOR_DO_THROTTLING) )
    {
        LONG lMultiplierHigh = 1;

        phTask->GetMemoryUsage ( &memUsage );
        phTask->GetTotalSleepTime ( &sleepTime );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Did we reach the arbitration point?
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if ( (LONG) memUsage > m_lFloatingLow )
        {
            hRes = WBEM_E_ARB_THROTTLE;
            if ( uFlags == ARBITRATOR_DO_THROTTLING )
            {
                {
                    CInCritSec _cs ( &m_csTask );
                    if ( phTask->GetTaskStatus ( ) != WMICORE_TASK_STATUS_CANCELLED )
                    {
                        ResetEvent ( phTask->GetTimerHandle ( ) );
                    }
                    else
                    {
                        return WBEM_E_CALL_CANCELLED;
                    }
                }

                if ( ( sleepTime < m_lMaxSleepTime ) || ( m_lMaxSleepTime == 0 ) )
                {
                    if ( memUsage >= (m_uSystemHigh * m_dThreshold3) )
                    {
                        lMultiplierHigh = m_lThreshold3Mult;
                    }
                    else if ( memUsage >= (m_uSystemHigh * m_dThreshold2) )
                    {
                        lMultiplierHigh = m_lThreshold2Mult;
                    }
                    else if ( memUsage >= (m_uSystemHigh * m_dThreshold1) )
                    {
                        lMultiplierHigh = m_lThreshold1Mult;
                    }

                    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    // Do an extra check to make sure the task didnt release some
                    // memory
                    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    phTask->GetMemoryUsage ( &memUsage );
                    phTask->GetTotalSleepTime ( &sleepTime );

					//
					// Floating low could have changed after the conditional below which could
					// put us in a situation where we get a negative sleep time (BAD)
					//
					__int64 tmpFloatingLow = m_lFloatingLow ;

                    if ( (LONG) memUsage > tmpFloatingLow )
                    {
						ULONG ulSleepTime = (ULONG) ( ( memUsage - tmpFloatingLow ) * m_lMultiplier * m_lMultiplierTasks * lMultiplierHigh );
                        phTask->SetLastSleepTime ( ulSleepTime );
                        m_uTotalSleepTime += ulSleepTime;

                        phTask->UpdateTotalSleepTime ( ulSleepTime );


                        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        // Delayed creation of event
                        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        HRESULT hEventhRes = WBEM_S_NO_ERROR;
                        {
                            CInCritSec _cs ( &m_csArbitration );
                            if ( !phTask->GetTimerHandle ( ) )
                            {
                                hEventhRes = phTask->CreateTimerEvent ( );
                            }
                        }

                        if ( SUCCEEDED ( hEventhRes ) )
                        {
                            hRes = DoThrottle ( phTask, ulSleepTime, memUsage );
                        }
                        else
                        {
                            hRes = hEventhRes;
                        }
                    }
                }
                else
                {
                    hRes = WBEM_E_ARB_CANCEL;
                    if ( uFlags == ARBITRATOR_DO_THROTTLING )
                    {
                        #ifdef __DEBUG_ARBITRATOR_THROTTLING
                            WCHAR   wszTemp[128];
                            wsprintf( wszTemp, L"Task 0x%x cancelled due to arbitrator throttling (excessive sleep time = 0x%x).\n", phTask, sleepTime );
                            OutputDebugStringW( wszTemp );
                        #endif
						DEBUGTRACE((LOG_WBEMCORE, "Task 0x%x cancelled due to arbitrator throttling (excessive sleep time = 0x%x).\n", phTask, sleepTime ) );

						//
						// The reason we are cancelling is because of throttling. Let the task know about it!
						//
						phTask->SetCancelledState ( TRUE ) ;
                        
						CancelTask ( 0, phTask );
                        UnregisterTask ( phTask );
                    }
                }
            }
        }
    }
    return hRes;
}



//***************************************************************************
//
//***************************************************************************
HRESULT CWmiArbitrator::DoThrottle ( CWmiTask* phTask, ULONG ulSleepTime, ULONG ulMemUsage )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Lets wait for the event....we are expecting to time out this
    // wait, unless we are woken up due to memory usage decrease or
    // cancellation of task has happened
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#ifdef __DEBUG_ARBITRATOR_THROTTLING
    WCHAR   wszTemp[128];
    wsprintf( wszTemp, L"Thread 0x%x throttled in arbitrator for 0x%x ms. Task memory usage is 0x%xb\n", GetCurrentThreadId(), ulSleepTime, ulMemUsage );
    OutputDebugStringW( wszTemp );
#endif

    DEBUGTRACE((LOG_WBEMCORE, "Thread 0x%x throttled in arbitrator for 0x%x ms. Task memory usage is 0x%xb\n", GetCurrentThreadId(), ulSleepTime, ulMemUsage ) );

    DWORD dwRes = CCoreQueue :: QueueWaitForSingleObject ( phTask->GetTimerHandle ( ), ulSleepTime );

    DEBUGTRACE((LOG_WBEMCORE, "Thread 0x%x woken up in arbitrator.\n", GetCurrentThreadId() ) );

#ifdef __DEBUG_ARBITRATOR_THROTTLING
    wsprintf( wszTemp, L"Thread 0x%x woken up in arbitrator.\n", GetCurrentThreadId() );
    OutputDebugStringW( wszTemp );
#endif

    if ( dwRes == WAIT_FAILED )
    {
        hRes = WBEM_E_CRITICAL_ERROR;
    }
    if ( phTask->GetTaskStatus ( ) == WMICORE_TASK_STATUS_CANCELLED )
    {
        hRes = WBEM_E_CALL_CANCELLED;
    }

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
BOOL CWmiArbitrator::IsTaskArbitrated ( CWmiTask* phTask )
{
    ULONG uTaskType = phTask->GetTaskType ( );
    uTaskType = uTaskType & 0xFF;
    return ( ( uTaskType == WMICORE_TASK_ENUM_INSTANCES ) ||  ( uTaskType == WMICORE_TASK_ENUM_CLASSES ) || ( uTaskType == WMICORE_TASK_EXEC_QUERY ) );
}


//***************************************************************************
//
//***************************************************************************
/*STDMETHODIMP CWmiArbitrator::Shutdown()
{
    return E_NOTIMPL;
}
*/
//***************************************************************************
//
//  Returns the commit charge for the process.  Can be called often,
//  but only checks once every 10 seconds or so.
//
//***************************************************************************
//
static DWORD ProcessCommitCharge()
{

    static DWORD dwLastCall = 0;
    static DWORD dwLatestCommitCharge = 0;
    DWORD dwNow = GetCurrentTime();

    if (dwLastCall == 0)
        dwLastCall = dwNow;

    if (dwNow - dwLastCall < MEM_CHECK_INTERVAL)
        return dwLatestCommitCharge;

    dwLastCall = dwNow;


    MEMORY_BASIC_INFORMATION meminf;

    DWORD dwRes;
    LPBYTE pAddr = 0;

    DWORD dwTotalCommit = 0;

    while(1)
    {
        dwRes = VirtualQuery(pAddr, &meminf, sizeof(meminf));
        if (dwRes == 0)
        {
            break;
        }

        if (meminf.State == MEM_COMMIT)
            dwTotalCommit += DWORD(meminf.RegionSize);
        pAddr += meminf.RegionSize;
    }

    dwLatestCommitCharge = dwTotalCommit;
    return dwTotalCommit;

}


/*
    * =====================================================================================================
	|
	| HRESULT CWmiArbitrator::UnregisterTaskForEntryThrottling ( CWmiTask* pTask )
	| ----------------------------------------------------------------------------
	|
	| Used to indicate that a task is still active and part of the arbitrator task list _but_ should not be
	| included in the entry point throttling. This is usefull if you have a task that has finished (i.e.
	| WBEM_STATUS_COMPLETE on the inbound sink), but client is actively retrieving information from the task.
	| 
	|
	* =====================================================================================================
*/

HRESULT CWmiArbitrator::UnregisterTaskForEntryThrottling ( CWmiTask* pTask )
{
	HRESULT hRes = WBEM_S_NO_ERROR ;

	//
 	// Make sure we have a valid task
	//
	if ( pTask == NULL )
	{
		return WBEM_E_FAILED ;
	}
	
	//
	// Cocked, Locked, and ready to Rock
	//
    CInCritSec cs ( &m_csTask ) ;

	if ( pTask->IsAccountedForThrottling ( ) == TRUE )
	{
		pTask->SetAccountedForThrottling ( FALSE ) ;
		m_uTotalThrottledTasks-- ;
	}

	return hRes ;
}



/*
    * =====================================================================================================
	|
	| HRESULT CWmiArbitrator::RegisterTaskForEntryThrottling ( CWmiTask* pTask )
	| --------------------------------------------------------------------------
	|
	| Used to indicate that a task is still active and part of the arbitrator task list _and should_ be
	| included in the entry point throttling. 
	| 
	|
	* =====================================================================================================
*/

HRESULT CWmiArbitrator::RegisterTaskForEntryThrottling ( CWmiTask* pTask )
{
	HRESULT hRes = WBEM_S_NO_ERROR ;

	//
 	// Make sure we have a valid task
	//
	if ( pTask == NULL )
	{
		return WBEM_E_FAILED ;
	}
	
	//
	// Cocked, Locked, and ready to Rock
	//
    CInCritSec cs ( &m_csTask ) ;

	if ( pTask->IsAccountedForThrottling ( ) == FALSE )
	{
		pTask->SetAccountedForThrottling ( TRUE ) ;
		m_uTotalThrottledTasks++ ;
	}

	return hRes ;
}



/*
    * =====================================================================================================
	|
	| HRESULT CWmiArbitrator::ClearCounters ( ULONG lFlags, CWmiTask* phTask )
	| ------------------------------------------------------------------------
	|
	| Clears the TotalMemoryUsage and Floating Low (available memory). This is
	| used when the system reaches a state where there are 0 tasks in the queue
	| in which case we clear the counters to be on the safe side.
	|
	* =====================================================================================================
*/

HRESULT CWmiArbitrator::ClearCounters ( ULONG lFlags )
{
	HRESULT hRes = WBEM_S_NO_ERROR ;

	//
	// Cocked, Locked, and ready to Rock
	//
    CInCritSec cs ( &m_csArbitration );

	//
	// This is as good as any time to check if we need
	// to update the memory counters
	//
	UpdateMemoryCounters ( ) ;

	//
	// Should we in fact clear the counters at this point?
	//
	if ( ( s_Finalizer_ObjectCount == 0 ) && m_aTasks.Size ( ) == 0 )
	{
		//
		// Now we go ahead and clear the counters
		//
		m_uTotalMemoryUsage = 0 ;
		m_lFloatingLow = m_uSystemHigh ;
	}

	return hRes ;
}




/*
    * =====================================================================================================
	|
	| HRESULT CWmiArbitrator::UpdateMemoryCounters ( )
	| ------------------------------------------------
	| Updates the arbitrator memory configuration (such as max memory usage) by
	| calculating the 
	|
	* =====================================================================================================
*/

HRESULT CWmiArbitrator::UpdateMemoryCounters ( BOOL bForceUpdate )
{
	HRESULT hResult = WBEM_S_NO_ERROR ;

	//
	// Cocked, Locked, and ready to Rock
	//
    CInCritSec cs ( &m_csArbitration );

	//
	// Check to see if we need to update, has the timestamp expired?
	// Or is the force update flag specified?
	//
	if ( NeedToUpdateMemoryCounters ( ) || bForceUpdate == TRUE )
	{
		ULONG ulOldSystemHigh = m_uSystemHigh ;
		m_uSystemHigh = GetWMIAvailableMemory ( m_fSystemHighFactor ) ;
		
		//
		// Ensure this isnt the first time we're being called
		//
		if ( m_lFloatingLow != (LONG) ulOldSystemHigh )
		{
			m_lFloatingLow += ( m_uSystemHigh - ulOldSystemHigh ) ;			
		}
		else
		{
			m_lFloatingLow = m_uSystemHigh ;
		}

	    m_lMultiplier = ( ARB_DEFAULT_MAX_SLEEP_TIME / (double) m_uSystemHigh ) ;
	}
	return hResult ;
}



/*
    * =====================================================================================================
	|
	| BOOL CWmiArbitrator::NeedToUpdateMemoryCounters ( )
	| ---------------------------------------------------
	| Returns TRUE if memory counters need to be updates, FALSE otherwise.
	| The decision is based on a timer interval defined by:
	|
	| MEM_CHECK_INTERVAL              3000            //  3 seconds
	|
	| 
	|
	* =====================================================================================================
*/

BOOL CWmiArbitrator::NeedToUpdateMemoryCounters ( )
{
	BOOL bNeedToUpdate = FALSE ;

	ULONG ulNewMemoryTimer = GetTickCount ( ) ;
	ULONG ulTmpTimer = 0 ;
	BOOL bRollOver = FALSE ;

	//
	// Cocked, Locked, and ready to Rock
	//
    CInCritSec cs ( &m_csArbitration );

	if ( ulNewMemoryTimer < m_lMemoryTimer )
	{
		// 
		// Do we have a roll over situation?
		//
		ulTmpTimer = ulNewMemoryTimer ;
		ulNewMemoryTimer = ulNewMemoryTimer + m_lMemoryTimer ;
		bRollOver = TRUE ;
	}
	
	if ( ( ( ulNewMemoryTimer - m_lMemoryTimer ) > MEM_CHECK_INTERVAL ) )
	{
		if ( bRollOver )
		{
			m_lMemoryTimer = ulTmpTimer ;
		}
		else
		{
			m_lMemoryTimer = ulNewMemoryTimer ;
		}

		bNeedToUpdate = TRUE ;
	}
	
	return bNeedToUpdate ;
}

/*
    * =====================================================================================================
	|
	| ULONG CWmiArbitrator::GetWMIAvailableMemory ( )
	| -----------------------------------------------
	| Returns the amount of memory available to WMI. This is calculated according
	| to:
	|		MemoryFactor * ( AvailablePhysicalMemory + AvailablePagingSpace )
	|
	| where MemoryFactor is determined at startup by reading the 
	| ArbSystemHighMaxLimitFactor registry key.
	|
	* =====================================================================================================
*/

__int64  CWmiArbitrator::GetWMIAvailableMemory ( DOUBLE ulFactor )
{

	//
	// Get system wide memory status
	//
	MEMORYSTATUSEX memStatus;
	memStatus.dwLength = sizeof ( MEMORYSTATUSEX );
	__int64 ulMem = 0;

	if ( !GlobalMemoryStatusEx ( &memStatus ) )
	{
		//
		// We need to set the memory to an absolut minimum.
		// We get this from the ConfigMgr since we use this
		// in other places as well
		//
		ulMem = ConfigMgr::GetMinimumMemoryRequirements ( ) ;
	}
	else
	{
		//
		// Use MemoryFactor * ( AvailablePhysicalMemory + AvailablePagingSpace + current mem consumtion )
		// to figure out how much memory we can use. We need to figure in our current memory consumption,
		// or else we run double calculate.
		//
		ulMem = ( ulFactor * ( memStatus.ullAvailPhys + memStatus.ullAvailPageFile + m_uTotalMemoryUsage ) ) ;
	}

	return ulMem ;
}


/*
    * =====================================================================================================
	|
	| BOOL CWmiArbitrator::AcceptsNewTasks ( ) 
	| ----------------------------------------
	| Returns TRUE if the arbitrator is currently accepting new tasks, otherwise
	| FALSE. This is determined by checking if WMIs memory consumption is within
	| a certain percentage of total memory available. The factor is defined in
	| 
	| ARB_DEFAULT_SYSTEM_REQUEST_FACTOR		0.9
	| 
	| By default this value is 90%
	|
	* =====================================================================================================
*/

BOOL CWmiArbitrator::AcceptsNewTasks ( ) 
{
	BOOL bAcceptsNewTasks = TRUE ;

	//
	// Lets check if we need to update memory counters
	//
	UpdateMemoryCounters ( ) ;
	
    CInCritSec cs ( &m_csArbitration );
	
	if ( m_uTotalMemoryUsage > ( ARB_DEFAULT_SYSTEM_REQUEST_FACTOR * m_uSystemHigh ) )
	{
		bAcceptsNewTasks = FALSE ;
	}

	return bAcceptsNewTasks ;
}


//***************************************************************************
//
//***************************************************************************

typedef LONG (WINAPI *PFN_GetObjectCount)();

static PFN_GetObjectCount pObjCountFunc = 0;

DWORD CWmiArbitrator::MaybeDumpInfoGetWait()
{
    Registry r(WBEM_REG_WINMGMT);
    LPTSTR pPath = 0;
    if (r.GetStr(__TEXT("Task Log File"), &pPath))
        return 0xffffffff;
    CVectorDeleteMe<WCHAR> dm(pPath);
    FILE *f = _wfopen(pPath, L"wt");
    if (!f)
    {
        return 0xffffffff;
    }
    CfcloseMe fcm(f);
    {
        CAsyncServiceQueue* pQueue = ConfigMgr::GetAsyncSvcQueue ( ) ;
		
		// dump the tasks
        extern LONG g_nSinkCount, g_nStdSinkCount, g_nSynchronousSinkCount, g_nProviderSinkCount, g_lCoreThreads;

        CInCritSec cs(&m_csTask);

        fprintf(f, "---Global sinks active---\n");
        fprintf(f, "   Total            = %d\n", g_nSinkCount);
        fprintf(f, "   StdSink          = %d\n", g_nStdSinkCount);
        fprintf(f, "   SynchSink        = %d\n", g_nSynchronousSinkCount);
        fprintf(f, "   ProviderSinks    = %d\n", g_nProviderSinkCount);

        CProviderSink::Dump(f);

        fprintf(f, "---Core Objects---\n");

        if (pObjCountFunc)
        {
            fprintf(f, "   Total objects/qualifier sets = %d\n", pObjCountFunc());
        }
        fprintf(f, "   Total queue threads = %d\n", g_lCoreThreads + pQueue->GetEmergThreadCount ( ) );
		fprintf(f, "   Total queue emergency threads = %d\n", pQueue->GetEmergThreadCount ( ) );
		fprintf(f, "   Peak queue thread count = %d\n", pQueue->GetPeakThreadCount ( ) );
		fprintf(f, "   Peak queue emergency thread count = %d\n", pQueue->GetPeakEmergThreadCount ( ) );

        fprintf(f, "---Begin Task List---\n");
        fprintf(f, "Total active tasks = %u\n", m_aTasks.Size());

        CCoreServices::DumpCounters(f);

        fprintf(f, "Total sleep time = %u\n", m_uTotalSleepTime );
        fprintf(f, "Total memory usage = %u\n", m_uTotalMemoryUsage );

        CWmiFinalizer::Dump(f);

        for (int i = 0; i < m_aTasks.Size(); i++)
        {
            CWmiTask *pTask = (CWmiTask *) m_aTasks[i];
            pTask->Dump(f);
        }

        fprintf(f, "---End Task List---\n");
    }
    {
        // Dump the namespaces

        CInCritSec cs(&m_csNamespace);
        fprintf(f, "---Begin Namespace List---\n");
        fprintf(f, "Total Namespaces = %u\n", m_aNamespaces.Size());

        for (int i = 0; i < m_aNamespaces.Size(); i++)
        {
            CWbemNamespace *pNS = (CWbemNamespace *) m_aNamespaces[i];
            pNS->Dump(f);
        }

        fprintf(f, "---End Namespace List---\n");
    }
    return 10000;
}

//***************************************************************************
//
//***************************************************************************
//
void WINAPI CWmiArbitrator::DiagnosticThread()
{
    DWORD dwDelay = MaybeDumpInfoGetWait();

    HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if(hEvent == NULL)
        return;
    CCloseMe cm(hEvent);

    HKEY hKey;
    long lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"SOFTWARE\\MICROSOFT\\WBEM\\CIMOM",
                    0, KEY_NOTIFY, &hKey);
    if(lRet != ERROR_SUCCESS)
        return;
    CRegCloseMe ck(hKey);

    lRet = RegNotifyChangeKeyValue(hKey, FALSE, REG_NOTIFY_CHANGE_LAST_SET,
                    hEvent, TRUE);
    if(lRet != ERROR_SUCCESS)
        return;

    HMODULE hLib = LoadLibrary(L"fastprox.dll");
    if (hLib)
    {
        FARPROC p = GetProcAddress(hLib, "_GetObjectCount@0");
        if (p)
        {
            pObjCountFunc = (PFN_GetObjectCount) p;
        }
    }

    HANDLE hEvents[2];
    hEvents[0] = m_hTerminateEvent;
    hEvents[1] = hEvent;
    for (;;)
    {
        DWORD dwObj = WbemWaitForMultipleObjects(2, hEvents, dwDelay);
        switch (dwObj)
        {
            case 0:     // bail out for terminate event
                return;
            case 1:     // registry key changed
                dwDelay = MaybeDumpInfoGetWait();
                lRet = RegNotifyChangeKeyValue(hKey, FALSE, REG_NOTIFY_CHANGE_LAST_SET,
                                hEvent, TRUE);
                if(lRet != ERROR_SUCCESS)
                    return;
                break;
            case WAIT_TIMEOUT:
                dwDelay = MaybeDumpInfoGetWait();
                break;
            default:
                return;
        }
    }

    FreeLibrary(hLib);  // no real path to this, but it looks cool, huh?
}

//***************************************************************************
//
//  CWmiArbitrator::MapProviderToTask
//
//  As providers are invoked for tasks, they are added to the provider
//  list in the primary task. This allows us to quickly cancel all the providers
//  doing work for a particular task.
//
//***************************************************************************
//
HRESULT CWmiArbitrator::MapProviderToTask(
    ULONG uFlags,
    IWbemContext *pCtx,
    IWbemServices *pProv,
    CProviderSink *pProviderSink
    )
{
    HRESULT hRes;

    if (pCtx == 0 || pProviderSink == 0 || pProv == 0)
        return WBEM_E_INVALID_PARAMETER;


    try
    {
        CWbemRequest* pReq = CWbemQueue::GetCurrentRequest() ;
        if (pReq == NULL)
            return WBEM_E_FAILED;

        CWmiTask *pTask = (CWmiTask *) pReq->m_phTask;
        if (pTask == 0)
            return WBEM_S_NO_ERROR; // An internal request with no user task ID

        // If here, we have a task that will hold the provider.
        // ====================================================

        STaskProvider *pTP = new STaskProvider;
        if (pTP == 0)
            return WBEM_E_OUT_OF_MEMORY;

        pProv->AddRef();
        pTP->m_pProv = pProv;
        pProviderSink->LocalAddRef();
        pTP->m_pProvSink = pProviderSink;

		// Clean up the task provider if the add fails.
        hRes = pTask->AddTaskProv(pTP);

		if ( FAILED( hRes ) )
		{
			delete pTP;
		}
    }
    catch(...)
    {
        ExceptionCounter c;    
        hRes = WBEM_E_CRITICAL_ERROR;
    }

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//
DWORD WINAPI CWmiArbitrator::_DiagnosticThread(CWmiArbitrator *pArb)
{
    pArb->DiagnosticThread();
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//
static DWORD WINAPI TaskDiagnosticThread(CWmiArbitrator *pArb)
{
    static BOOL bThread = FALSE;

	// Check if the diagnostic thread is enabled
    if ( ConfigMgr::GetEnableArbitratorDiagnosticThread() && !bThread )
    {
        bThread = TRUE;
        DWORD dwId;

        HANDLE hThread = CreateThread(
            0,                     // Security
            0,
            LPTHREAD_START_ROUTINE(CWmiArbitrator::_DiagnosticThread),          // Thread proc address
            pArb,                   // Thread parm
            0,                     // Flags
            &dwId
            );

        if (hThread == NULL)
            return 0;
        CloseHandle(hThread);
        return dwId;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\wmiarbitrator.h ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    WmiArbitrator.h

Abstract:
    Implementation of the arbitrator.  The arbitrator is the class which
    watches over everything to make sure it is not using too many resources.
    Big brother is watching over you :-)


History:
    paulall     09-Apr-00       Created.
    raymcc      08-Aug-00       Made it actually do something useful

--*/


class CWmiArbitrator : public _IWmiArbitrator
{
private:
    LONG                m_lRefCount;

    ULONG               m_uTotalTasks;
    ULONG               m_uTotalPrimaryTasks;
	ULONG				m_uTotalThrottledTasks;

    __int64             m_lFloatingLow;                         // Currently available memory (within WMI high)
    __int64             m_uSystemHigh;                          // Maximum memory usable by WMI
    ULONG               m_lMaxSleepTime;                        // Max sleep time in ms for any task
    __int64             m_uTotalMemoryUsage;                    // Total memory consumed by all tasks
    ULONG               m_uTotalSleepTime;                      // Total sleep time for overall system

    DOUBLE              m_lMultiplier;
    DOUBLE              m_lMultiplierTasks;
	
    DOUBLE              m_dThreshold1;
    LONG                m_lThreshold1Mult;

    DOUBLE              m_dThreshold2;
    LONG                m_lThreshold2Mult;

    DOUBLE              m_dThreshold3;
    LONG                m_lThreshold3Mult;

	LONG				m_lUncheckedCount;
	
    CFlexArray          m_aTasks;
    CFlexArray          m_aNamespaces;

    CCritSec            m_csNamespace;
    CCritSec            m_csArbitration;
    CCritSec            m_csTask;

    HANDLE              m_hTerminateEvent;
    BOOL				m_bSetupRunning;

	ULONG				m_lMemoryTimer ;
    DOUBLE				m_fSystemHighFactor;

protected:
    static CWmiArbitrator *m_pArb;

    CWmiArbitrator();
    ~CWmiArbitrator();

    void WINAPI DiagnosticThread();
    DWORD MaybeDumpInfoGetWait();
	BOOL NeedToUpdateMemoryCounters ( ) ;


public:
    static DWORD WINAPI _DiagnosticThread(CWmiArbitrator *);

    static HRESULT Initialize( OUT _IWmiArbitrator ** ppArb);
    static HRESULT Shutdown(BOOL bIsSystemShutdown);
    static _IWmiArbitrator *GetUnrefedArbitrator() { return m_pArb; }
    static _IWmiArbitrator *GetRefedArbitrator() { if (m_pArb) m_pArb->AddRef(); return m_pArb; }

    BOOL IsTaskInList(CWmiTask *);  // test code
    BOOL IsTaskArbitrated ( CWmiTask* phTask ) ;
	HRESULT UnregisterTaskForEntryThrottling ( CWmiTask* pTask ) ;
	HRESULT RegisterTaskForEntryThrottling ( CWmiTask* pTask ) ;

    HRESULT DoThrottle ( CWmiTask* phTask, ULONG ulSleepTime, ULONG ulMemUsage );

	LONG	DecUncheckedCount ( ) { InterlockedDecrement ( &m_lUncheckedCount ); return m_lUncheckedCount; }
	LONG	IncUncheckedCount ( ) { InterlockedIncrement ( &m_lUncheckedCount ); return m_lUncheckedCount; }

	__int64	GetWMIAvailableMemory ( DOUBLE ) ;
	BOOL	AcceptsNewTasks ( ) ;
	HRESULT UpdateMemoryCounters ( BOOL = FALSE ) ;

    HRESULT InitializeRegistryData ( );
    HRESULT UpdateCounters     ( LONG lDelta, CWmiTask* phTask );
    HRESULT Arbitrate          ( ULONG uFlags, LONG lDelta, CWmiTask* phTask );
	HRESULT ClearCounters      ( ULONG lFlags ) ;

	BOOL  CheckSetupSwitch ( void );

    HRESULT MapProviderToTask(
        ULONG uFlags,
        IWbemContext *pCtx,
        IWbemServices *pProv,
        CProviderSink *pSink
        );

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    // Arbitrator-specific.
    // ====================

    STDMETHOD(RegisterTask)(
        /*[in]*/ _IWmiCoreHandle *phTask
        );

    STDMETHOD(UnregisterTask)(
        /*[in]*/ _IWmiCoreHandle *phTask
        );

    STDMETHOD(RegisterUser)(
        /*[in]*/ _IWmiCoreHandle *phUser
        );

    STDMETHOD(UnregisterUser)(
        /*[in]*/ _IWmiCoreHandle *phUser
        );

    STDMETHOD(CancelTasksBySink)(
        ULONG uFlags,
        REFIID riid,
        LPVOID pSink
        );

    STDMETHOD(CheckTask)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ _IWmiCoreHandle *phTask
        );

    STDMETHOD(TaskStateChange)(
        /*[in]*/ ULONG uNewState,               // Duplicate of the state in the task handle itself
        /*[in]*/ _IWmiCoreHandle *phTask
        );

    STDMETHOD(CheckThread)(
        /*[in]*/ ULONG uFlags
        );

    STDMETHOD(CheckUser)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ _IWmiUserHandle *phUser
        );

    STDMETHOD(CheckUser)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ _IWmiCoreHandle *phUser
        );

    STDMETHOD(CancelTask)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ _IWmiCoreHandle *phTtask
        );

    STDMETHOD(RegisterThreadForTask)(
        /*[in]*/_IWmiCoreHandle *phTask
        );
    STDMETHOD(UnregisterThreadForTask)(
        /*[in]*/_IWmiCoreHandle *phTask
        );

    STDMETHOD(Maintenance)();

    STDMETHOD(RegisterFinalizer)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ _IWmiCoreHandle *phTask,
        /*[in]*/ _IWmiFinalizer *pFinal
        );


    STDMETHOD(RegisterNamespace)(
            /* [in] */ _IWmiCoreHandle *phNamespace);

    STDMETHOD(UnregisterNamespace)(
            /* [in] */ _IWmiCoreHandle *phNamespace);

    STDMETHOD(ReportMemoryUsage)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ LONG  lDelta,
        /*[in]*/ _IWmiCoreHandle *phTask
        );

    STDMETHOD(Throttle)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ _IWmiCoreHandle *phTask
        );

    STDMETHOD(RegisterArbitratee)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ _IWmiCoreHandle *phTask,
        /*[in]*/ _IWmiArbitratee *pArbitratee
        );

    STDMETHOD(UnRegisterArbitratee)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ _IWmiCoreHandle *phTask,
        /*[in]*/ _IWmiArbitratee *pArbitratee
        );


//    STDMETHOD(Shutdown)( void);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\wmicache.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WmiCache.h

Abstract:

    WMI cache for _IWmiObject's.  Used within wbemcore only.

History:

    paulall		10-Mar-2000		Created.

--*/

#ifndef __WmiCache_h__
#define __WmiCache_h__

#include "FlexArry.h"


//***************************************************************************
//	CWmiCache
//	
//	This is the main class which handles the caching within WMI.  It
//	is the implementation of the _IWmiCache.
//
//***************************************************************************
class CWmiCache : public _IWmiCache
{
private:
	LONG		m_lRefCount;
	CFlexArray	m_objects;
	CRITICAL_SECTION m_cs;
	ULONG		m_nEnum;
protected:
	HRESULT HashPath(const wchar_t *wszPath, int *pnHash);
	HRESULT HashPath(_IWmiObject *pObj, int *pnHash);
	HRESULT ComparePath(const wchar_t *pPath, _IWmiObject *pObject);

public:
	CWmiCache();
	~CWmiCache();

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);


    STDMETHOD(SetConfigValue)(
		/*[in]*/ ULONG uID,
		/*[in]*/ ULONG uValue
        );

    STDMETHOD(GetConfigValue)(
        /*[in]*/  ULONG uID,
        /*[out]*/ ULONG *puValue
        );

    STDMETHOD(Empty)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ LPCWSTR pszClass
        );

    STDMETHOD(AddObject)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ _IWmiObject *pObj
        );
        // Also subsumes replace functionality
        //
        // __PATH Property is used as a real key

    STDMETHOD(DeleteByPath)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ LPCWSTR pszPath
        );

    STDMETHOD(DeleteByPointer)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ _IWmiObject *pTarget
        );

    /////////////////

    STDMETHOD(GetByPath)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ LPCWSTR pszFullPath,
        /*[out]*/ _IWmiObject **pObj
        );

    STDMETHOD(BeginEnum)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ LPCWSTR pszFilter
        );
        // Filters: uFlags==0==all, uFlags==WMICACHE_CLASS_SHALLOW, WMICACHE_CLASS_DEEP

    STDMETHOD(Next)(
        /*[in]*/ ULONG uBufSize,
        /*[out, size_is(uBufSize), length_is(*puReturned)]*/ _IWmiObject **pObjects,
        /*[out]*/ ULONG *puReturned
        );

};

class CWmiCacheObject
{
public:
	int			 m_nHash;
	_IWmiObject	*m_pObj;

	CWmiCacheObject(int nPathHash, _IWmiObject *pObj) : m_nHash(nPathHash), m_pObj(pObj) {}
	~CWmiCacheObject() {}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\wmimerger.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WMIMERGER.CPP

Abstract:

    Implements the _IWmiMerger interface

History:

    sanjes    16-Nov-00  Created.

--*/

#include "precomp.h"

#pragma warning (disable : 4786)
#include <wbemcore.h>
#include <map>
#include <vector>
#include <perfhelp.h>
#include <genutils.h>
#include <oahelp.inl>
#include <wqllex.h>
#include "wmimerger.h"

static	long	g_lNumMergers = 0L;

//***************************************************************************
//
//***************************************************************************
//
CWmiMerger::CWmiMerger( CWbemNamespace* pNameSpace )
:	m_lRefCount( 0 ),
	m_pTargetSink( NULL ),
	m_pTask( NULL ),
	m_pNamespace( pNameSpace ),
	m_wsTargetClassName(),
	m_dwProviderDeliveryPing( 0L ),
	m_pArbitrator( NULL ),
	m_lNumArbThrottled( 0L ),
	m_lDebugMemUsed( 0L ),
	m_hOperationRes( WBEM_S_NO_ERROR ),
	m_cs(),
	m_dwMaxLevel( 0 ),
	m_pRequestMgr( NULL ),
	m_dwMinReqLevel( 0xFFFFFFFF ),
	m_bMergerThrottlingEnabled( true )
{
	if ( NULL != m_pNamespace )
	{
		m_pNamespace->AddRef();
	}

	InterlockedIncrement( &g_lNumMergers );
}

//***************************************************************************
//
//  CWmiMerger::~CWmiMerger
//
//  Notifies the ESS of namespace closure and frees up all the class providers.
//
//***************************************************************************

CWmiMerger::~CWmiMerger()
{
//	if ( NULL != m_pTargetSink )
//	{
//		m_pTargetSink->Release();
//	}

	_DBG_ASSERT( 0L == m_lNumArbThrottled );
	_DBG_ASSERT( 0L == m_lDebugMemUsed );
	
	if ( NULL != m_pNamespace )
	{
		m_pNamespace->Release();
	}

	if ( NULL != m_pArbitrator )
	{
		m_pArbitrator->Release();
	}

	if ( NULL != m_pTask )
	{
		m_pTask->Release();
	}

	if ( NULL != m_pRequestMgr )
	{
		delete m_pRequestMgr;
		m_pRequestMgr = NULL;
	}

	InterlockedDecrement( &g_lNumMergers );

}

//***************************************************************************
//
//  CWmiMerger::QueryInterface
//
//  Exports _IWmiMerger interface.
//
//***************************************************************************

STDMETHODIMP CWmiMerger::QueryInterface(
    IN REFIID riid,
    OUT LPVOID *ppvObj
    )
{
	if ( riid == IID__IWmiArbitratee )
	{
		*ppvObj = (_IWmiArbitratee*) this;
	}
	else if ( riid == IID__IWmiArbitratedQuery )
	{
		*ppvObj = (_IWmiArbitratedQuery*) this;
	}
	else
	{
	    return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}

//***************************************************************************
//
//***************************************************************************
//

ULONG CWmiMerger::AddRef()
{
    return InterlockedIncrement(&m_lRefCount);
}

//***************************************************************************
//
//***************************************************************************
//
ULONG CWmiMerger::Release()
{
    long lNewCount = InterlockedDecrement(&m_lRefCount);
    if (0 != lNewCount)
        return lNewCount;
    delete this;
    return 0;
}

// Sets initial parameters for merger.  Establishes the target class and sink for the
// query associated with the merger
STDMETHODIMP CWmiMerger::Initialize( _IWmiArbitrator* pArbitrator, _IWmiCoreHandle* pTask, LPCWSTR pwszTargetClass,
									IWbemObjectSink* pTargetSink, CMergerSink** ppFinalSink )
{
	if ( NULL == pwszTargetClass || NULL == pTargetSink )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	// Cannot initialize twice
	if ( NULL != m_pTargetSink )
	{
		return WBEM_E_INVALID_OPERATION;
	}

	HRESULT	hr = WBEM_S_NO_ERROR;

	try
	{
		m_wsTargetClassName = pwszTargetClass;

		// Create the final target sink
		hr = CreateMergingSink( eMergerFinalSink, pTargetSink, NULL, (CMergerSink**) &m_pTargetSink );

		if ( SUCCEEDED( hr ) )
		{
			*ppFinalSink = m_pTargetSink;
			m_pTargetSink->AddRef();

			m_pArbitrator = pArbitrator;
			m_pArbitrator->AddRef();

			// AddRef the Task here
			m_pTask = pTask;

			// Only register for arbitration if we have a task handle
			if ( NULL != pTask )
			{
				m_pTask->AddRef();
				hr = m_pArbitrator->RegisterArbitratee( 0L, m_pTask, this );
			}
			
		}
	}
	catch ( CX_MemoryException )
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
        ExceptionCounter c;	
		hr = WBEM_E_CRITICAL_ERROR;
	}

	return hr;
}

// Called to request a delivery sink for a class in the query chain.  The returned
// sink is determined by the specified flags as well as settings on the parent class
STDMETHODIMP CWmiMerger::RegisterSinkForClass( LPCWSTR pwszClass, _IWmiObject* pClass, IWbemContext* pContext,
											  BOOL fHasChildren, BOOL fHasInstances, BOOL fDerivedFromTarget,
											  bool bStatic, CMergerSink* pDestSink, CMergerSink** ppOwnSink, CMergerSink** ppChildSink )
{
	LPCWSTR	pwszParentClass = NULL;

	DWORD	dwSize = NULL;
	BOOL	fIsNull = NULL;

	// Get the derivation information.  The number of antecedents determines our
	// level in the hierarchy (we're 0 based)

	DWORD	dwLevel = 0L;
	WString	wsSuperClass;

	HRESULT	hr = GetLevelAndSuperClass( pClass, &dwLevel, &wsSuperClass );
	if (FAILED(hr))
	    return hr;

	CCheckedInCritSec	ics( &m_cs );

	// We're dead - take no positive adjustments
	if ( FAILED ( m_hOperationRes ) )
	{
		return m_hOperationRes;
	}

	CWmiMergerRecord*	pRecord = new CWmiMergerRecord( this, fHasInstances, fHasChildren, 
										pwszClass, pDestSink, dwLevel, bStatic );

	if ( NULL != pRecord )
	{
		// Now attach aninternal merger if we have both instances and children
		if ( fHasInstances && fHasChildren )
		{
			// We shouldn't have a NULL task here if this is not a static class.
			// Note that the only case this appears to happen is when ESS calls
			// into us on internal APIs and uses requests on its own queues and
			// not the main Core Queue.

			_DBG_ASSERT( NULL != m_pTask || ( NULL == m_pTask && bStatic ) );
			hr = pRecord->AttachInternalMerger( (CWbemClass*) pClass, m_pNamespace, pContext, fDerivedFromTarget, bStatic );
		}

		// Check that we're still okay
		if ( SUCCEEDED( hr ) )
		{

			// Find the record for the superclass if there is one (unless the array is
			// empty of course).
			if ( wsSuperClass[0] && m_MergerRecord.GetSize() > 0 )
			{
				// There MUST be a record, or something is quite not okay.
				CWmiMergerRecord*	pSuperClassRecord = m_MergerRecord.Find( wsSuperClass );

				_DBG_ASSERT( NULL != pSuperClassRecord );

				// Now add the new record to the child array for the superclass record
				// This will allow us to quickly determine the classes we need to obtain
				// submit requests for if the parent class is throttled.

				if ( NULL != pSuperClassRecord )
				{
					hr = pSuperClassRecord->AddChild( pRecord );
				}
				else
				{
					hr = WBEM_E_FAILED;
				}

			}

			if ( SUCCEEDED( hr ) )
			{
				// Make sure the add is successful
				if ( m_MergerRecord.Insert( pRecord ) >= 0 )
				{

#ifdef __DEBUG_MERGER_THROTTLING
					// Verify the sort order for now
					m_MergerRecord.Verify();
#endif

					// Store the maximum level in the hierarchy
					if ( dwLevel > m_dwMaxLevel )
					{
						m_dwMaxLevel = dwLevel;
					}

					if ( !bStatic && dwLevel < m_dwMinReqLevel )
					{
						m_dwMinReqLevel = dwLevel;
					}

					*ppOwnSink = pRecord->GetOwnSink();
					*ppChildSink = pRecord->GetChildSink();
				}
				else
				{
					delete pRecord;
					hr = WBEM_E_OUT_OF_MEMORY;
				}

			}
			else
			{
				delete pRecord;
			}

		}
		else
		{
			delete pRecord;
		}
	}
	else
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}

	return hr;
}

// Called to request a delivery sink for child classes in the query chain.  This is especially
// important when instances are merged under the covers.
STDMETHODIMP CWmiMerger::GetChildSink( LPCWSTR pwszClass, CBasicObjectSink** ppSink )
{
	HRESULT	hr = WBEM_S_NO_ERROR;
	CInCritSec	ics( &m_cs );

	// Search for a parent class's child sink
	for ( int x = 0; SUCCEEDED( hr ) && x < m_MergerRecord.GetSize(); x++ )
	{
		if ( m_MergerRecord[x]->IsClass( pwszClass ) )
		{
			*ppSink = m_MergerRecord[x]->GetChildSink();
			break;
		}
	}

	// We should never get a failure
	_DBG_ASSERT( x < m_MergerRecord.GetSize() );

	if ( x >= m_MergerRecord.GetSize() )
	{
		hr = WBEM_E_NOT_FOUND;
	}

	return hr;
}

// Can be used to hold off indicates - if we're merging instances from multiple providers, we need
// to ensure that we don't get lopsided in the number of objects we've got queued up for merging.
STDMETHODIMP CWmiMerger::Throttle( void )
{
	// We're dead - take no positive adjustments
	if ( FAILED ( m_hOperationRes ) )
	{
		return m_hOperationRes;
	}

	// Check for NULL m_pTask
	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( NULL != m_pTask )
	{
		hr = m_pArbitrator->Throttle( 0L, m_pTask );
	}

	return hr;
}

// Merger will hold information regarding the total number of objects it has queued up waiting
// for merging and the amount of memory consumed by those objects.
STDMETHODIMP CWmiMerger::GetQueuedObjectInfo( DWORD* pdwNumQueuedObjects, DWORD* pdwQueuedObjectMemSize )
{
	return WBEM_E_NOT_AVAILABLE;
}

// If this is called, all underlying sinks will be cancelled in order to prevent accepting additional
// objects.  This will also automatically free up resources consumed by queued objects.
STDMETHODIMP CWmiMerger::Cancel( void )
{
	return Cancel( WBEM_E_CALL_CANCELLED );
}

// Helper function to control sink creation. The merger is responsible for deletion of
// all internally created sinks.  So this function ensures that the sinks are added into
// the array that will destroy them.
HRESULT CWmiMerger::CreateMergingSink( MergerSinkType eType, IWbemObjectSink* pDestSink, CInternalMerger* pMerger, CMergerSink** ppSink )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( eType == eMergerFinalSink )
	{
		*ppSink = new CMergerTargetSink( this, pDestSink );

		if ( NULL == *ppSink )
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}
	else
	{
		hr = CInternalMerger::CreateMergingSink( eType, pMerger, this, ppSink );
	}

	// If we have a sink, we should now add it to the
	// Sink array.

	if ( SUCCEEDED( hr ) )
	{
		if ( m_MergerSinks.Add( *ppSink ) < 0 )
		{
			delete *ppSink;
			*ppSink = NULL;
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}

	return hr;
}

// Iterates the array of MergerRecords and cancels each of them.
HRESULT CWmiMerger::Cancel( HRESULT hRes )
{
#ifdef __DEBUG_MERGER_THROTTLING
		WCHAR	wszTemp[256];
		wsprintf( wszTemp, L"CANCEL CALLED:  Merger 0x%x Cancelled with hRes: 0x%x on Thread 0x%x\n", (DWORD_PTR) this, hRes, GetCurrentThreadId() );
		OutputDebugStringW( wszTemp );
#endif

	// We shouldn't be called with a success code
	_DBG_ASSERT( FAILED( hRes ) );

	HRESULT	hr = WBEM_S_NO_ERROR;

	// If we're here and this is non-NULL, tell the Arbitrator to tank us.
	if ( NULL != m_pTask )
	{
		m_pArbitrator->CancelTask( 0L, m_pTask );
	}

	CCheckedInCritSec	ics( &m_cs );

	if ( WBEM_S_NO_ERROR == m_hOperationRes )
	{
		m_hOperationRes = hRes;
	}

	// Search for a parent class's child sink
	for ( int x = 0; SUCCEEDED( hr ) && x < m_MergerRecord.GetSize(); x++ )
	{
//		OutputDebugStringW( L"CWmiMerger::Cancel called\n" );
		m_MergerRecord[x]->Cancel( hRes );
	}

	// Copy into a temporary variable, clear the member, exit the critsec
	// THEN call delete.  Requests can have multiple releases, which could call
	// back in here and cause all sorts of problems if we're inside a critsec.
	CWmiMergerRequestMgr*	pReqMgr = m_pRequestMgr;
	m_pRequestMgr = NULL;

	ics.Leave();

	// Tank any and all outstanding requests
	if ( NULL != pReqMgr )
	{
		delete pReqMgr;
	}

	return hr;
}

// Final Shutdown.  Called when the target sink is released.  At this point, we should
// unregister ourselves from the world
HRESULT CWmiMerger::Shutdown( void )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	CCheckedInCritSec	ics( &m_cs );

	_IWmiCoreHandle*	pTask = m_pTask;

	// Done with this, NULL it out - we release and unregister outside the critical section
	if ( NULL != m_pTask )
	{
		m_pTask = NULL;
	}

	ics.Leave();

	if ( NULL != pTask )
	{
		hr = m_pArbitrator->UnRegisterArbitratee( 0L, pTask, this );
		pTask->Release();
	}

	
	return hr;
}

// Pas-thru to arbitrator
HRESULT CWmiMerger::ReportMemoryUsage( long lAdjustment )
{
	// Task can be NULL
	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( NULL != m_pTask )
	{
		hr = m_pArbitrator->ReportMemoryUsage( 0L, lAdjustment, m_pTask );
	}

	// SUCCESS, WBEM_E_ARB_CANCEL or WBEM_E_ARB_THROTTLE means that we need to
	// account for the memory
	if ( ( SUCCEEDED( hr ) || hr == WBEM_E_ARB_CANCEL || hr == WBEM_E_ARB_THROTTLE ) )
	{
		InterlockedExchangeAdd( &m_lDebugMemUsed, lAdjustment );
	}

	return hr;
}

/* _IWmiArbitratee methods. */

STDMETHODIMP CWmiMerger::SetOperationResult( ULONG uFlags, HRESULT hRes )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( FAILED( hRes ) )
	{
		hr = Cancel( hRes );	
	}

	return hr;
}

// Why are we here?
STDMETHODIMP CWmiMerger::SetTaskHandle( _IWmiCoreHandle* pTask )
{
	_DBG_ASSERT( 0 );
	HRESULT	hr = WBEM_S_NO_ERROR;

	return hr;
}

// Noop for now
STDMETHODIMP CWmiMerger::DumpDebugInfo( ULONG uFlags, const BSTR strFile )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	return hr;
}

// Returns SUCCESS for now
STDMETHODIMP CWmiMerger::IsMerger( void )
{
	return WBEM_S_NO_ERROR;
}

HRESULT CWmiMerger::GetLevelAndSuperClass( _IWmiObject* pObj, DWORD* pdwLevel, WString* pwsSuperClass )
{
	// Get the derivation information.  The number of antecedents determines our
	// level in the hierarchy (we're 0 based)
	DWORD	dwTemp = 0L;

	HRESULT	hr = pObj->GetDerivation( 0L, 0L, pdwLevel, &dwTemp, NULL );

	if ( FAILED( hr ) && WBEM_E_BUFFER_TOO_SMALL != hr )
	{
		return hr;
	}

	VARIANT	vSuperClass;
	VariantInit	( &vSuperClass );

	hr = pObj->Get( L"__SUPERCLASS", 0L, &vSuperClass, NULL, NULL );
	CClearMe	cm( &vSuperClass );

	if ( SUCCEEDED( hr ) && V_VT( &vSuperClass ) == VT_BSTR )
	{
		try
		{
			*pwsSuperClass = V_BSTR( &vSuperClass );
		}
		catch(...)
		{
	        ExceptionCounter c;		
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}

	return hr;

}

HRESULT CWmiMerger::RegisterArbitratedInstRequest( CWbemObject* pClassDef, long lFlags, IWbemContext* pCtx,
			CBasicObjectSink* pSink, BOOL bComplexQuery, CWbemNamespace* pNs )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// Allocate a new request then place it in the arbitrator.
	try
	{
		CMergerDynReq_DynAux_GetInstances*	pReq = new CMergerDynReq_DynAux_GetInstances(
													pNs, pClassDef, lFlags, pCtx, pSink );

		if ( NULL != pReq )
		{
			// Make sure a context exists under the
			// covers

			if ( NULL != pReq->GetContext() )
			{

				CCheckedInCritSec	ics( &m_cs );

				if ( SUCCEEDED( m_hOperationRes ) )
				{

					// Allocate a request manager if we need one
					if ( NULL == m_pRequestMgr )
					{
						m_pRequestMgr = new CWmiMergerRequestMgr( this );

						if ( NULL == m_pRequestMgr )
						{
							hr = WBEM_E_OUT_OF_MEMORY;
						}
					}

					if ( SUCCEEDED( hr ) )
					{
						// We need the record to find out what level we need to add
						// the request to
						CWmiMergerRecord* pRecord = m_MergerRecord.Find( pReq->GetName() );
						_DBG_ASSERT( NULL != pRecord );

						if ( NULL != pRecord )
						{

							// Set the task for the request - we'll just use the existing one
							m_pTask->AddRef();
							pReq->m_phTask = m_pTask;

							hr = m_pRequestMgr->AddRequest( pReq, pRecord->GetLevel() );
						}
						else
						{
							// Couldn't find the record
							hr = WBEM_E_FAILED;
						}

					}	// IF allocated request manager

				}	// IF SUCCEEDED( m_hOperationRes )
				else
				{
					hr = m_hOperationRes;
				}

			}	// IF NULL != pReq->GetContext()
			else
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}

			// Cleanup the request if anything went wrong
			if ( FAILED( hr ) )
			{
				delete pReq;
			}

		}
		else
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}
	catch(...)
	{
        ExceptionCounter c;	
		hr = WBEM_E_OUT_OF_MEMORY;
	}

	return hr;
}

HRESULT CWmiMerger::RegisterArbitratedQueryRequest( CWbemObject* pClassDef, long lFlags, LPCWSTR Query,
			LPCWSTR QueryFormat, IWbemContext* pCtx, CBasicObjectSink* pSink, CWbemNamespace* pNs )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// Allocate a new request then place it in the arbitrator.
	try
	{
		CMergerDynReq_DynAux_ExecQueryAsync*	pReq = new CMergerDynReq_DynAux_ExecQueryAsync(
													pNs, pClassDef, lFlags, Query, QueryFormat,
													pCtx, pSink );

		if ( NULL != pReq )
		{
			// Make sure a context was properly allocated
			if ( NULL != pReq->GetContext() )
			{
				// Make sure the request is functional
				hr = pReq->Initialize();

				if ( SUCCEEDED( hr ) )
				{
					CInCritSec	ics( &m_cs );

					if ( SUCCEEDED( m_hOperationRes ) )
					{
						// Allocate a request manager if we need one
						if ( NULL == m_pRequestMgr )
						{
							m_pRequestMgr = new CWmiMergerRequestMgr( this );

							if ( NULL == m_pRequestMgr )
							{
								hr = WBEM_E_OUT_OF_MEMORY;
							}
						}

						if ( SUCCEEDED( hr ) )
						{
							// We need the record to find out what level we need to add
							// the request to
							CWmiMergerRecord* pRecord = m_MergerRecord.Find( pReq->GetName() );
							_DBG_ASSERT( NULL != pRecord );

							if ( NULL != pRecord )
							{

								// Set the task for the request - we'll just use the existing one
								m_pTask->AddRef();
								pReq->m_phTask = m_pTask;

								hr = m_pRequestMgr->AddRequest( pReq, pRecord->GetLevel() );
							}
							else
							{
								// Couldn't find the record
								hr = WBEM_E_FAILED;
							}

						}	// IF we have a request manager

					}
					else
					{
						hr = m_hOperationRes;
					}

				}	// IF initialized

			}	// IF NULL != pReq->GetContext()
			else
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}

			// Delete the request if anything went wrong
			if ( FAILED( hr ) )
			{
				delete pReq;
			}

		}
		else
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}
	catch(...)
	{
        ExceptionCounter c;	
		hr = WBEM_E_OUT_OF_MEMORY;
	}

	return hr;
}

HRESULT CWmiMerger::RegisterArbitratedStaticRequest( CWbemObject* pClassDef, long lFlags, 
						IWbemContext* pCtx, CBasicObjectSink* pSink, CWbemNamespace* pNs,
						QL_LEVEL_1_RPN_EXPRESSION* pParsedQuery )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// Allocate a new request then place it in the arbitrator.
	try
	{
		CMergerDynReq_Static_GetInstances*	pReq = new CMergerDynReq_Static_GetInstances(
													pNs, pClassDef, lFlags, pCtx, pSink,
													pParsedQuery );

		if ( NULL != pReq )
		{
			// Make sure a context was properly allocated
			if ( NULL != pReq->GetContext() )
			{
				CInCritSec	ics( &m_cs );

				if ( SUCCEEDED( m_hOperationRes ) )
				{
					// Allocate a request manager if we need one
					if ( NULL == m_pRequestMgr )
					{
						m_pRequestMgr = new CWmiMergerRequestMgr( this );

						if ( NULL == m_pRequestMgr )
						{
							hr = WBEM_E_OUT_OF_MEMORY;
						}
					}

					if ( SUCCEEDED( hr ) )
					{
						// We need the record to find out what level we need to add
						// the request to
						CWmiMergerRecord* pRecord = m_MergerRecord.Find( pReq->GetName() );
						_DBG_ASSERT( NULL != pRecord );

						if ( NULL != pRecord )
						{

							// Set the task for the request - we'll just use the existing one
							m_pTask->AddRef();
							pReq->m_phTask = m_pTask;

							hr = m_pRequestMgr->AddRequest( pReq, pRecord->GetLevel() );
						}
						else
						{
							// Couldn't find the record
							hr = WBEM_E_FAILED;
						}

					}	// IF we have a request manager

				}
				else
				{
					hr = m_hOperationRes;
				}

			}	// IF NULL != pReq->GetContext()
			else
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}

			// Delete the request if anything went wrong
			if ( FAILED( hr ) )
			{
				delete pReq;
			}

		}
		else
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}
	catch(...)
	{
        ExceptionCounter c;	
		hr = WBEM_E_OUT_OF_MEMORY;
	}

	return hr;
}

//
// Executes the parent request.  In this case, we simply ask the request manager for the
// next top level request and execute that request.  We do this in a loop until something
// goes wrong.
//

HRESULT CWmiMerger::Exec_MergerParentRequest( CWmiMergerRecord* pParentRecord, CBasicObjectSink* pSink )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	CCheckedInCritSec	ics( &m_cs );

	// While we have requests to execute, we should get each next logical one
	while ( SUCCEEDED( hr ) && NULL != m_pRequestMgr && m_pRequestMgr->GetNumRequests() > 0 )
	{
		if ( SUCCEEDED( m_hOperationRes ) )
		{
			CMergerReq* pReq = NULL;

			// Obtain the next topmost parent record if we have to
			if ( NULL == pParentRecord )
			{
				WString	wsClassName;

				hr = m_pRequestMgr->GetTopmostParentReqName( wsClassName );

				_DBG_ASSERT( SUCCEEDED( hr ) );

				if ( SUCCEEDED( hr ) )
				{
					pParentRecord = m_MergerRecord.Find( wsClassName );

					// If there's a request, there better be a record
					_DBG_ASSERT( NULL != pParentRecord );

					if ( NULL == pParentRecord )
					{
						hr = WBEM_E_FAILED;
					}

				}	// IF Got Topmost Parent Request

			}	// IF NULL == pParentRecord

			if ( SUCCEEDED( hr ) )
			{
				// This will remove the request from its array and return it
				// to us - we need to delete it

				hr = m_pRequestMgr->RemoveRequest( pParentRecord->GetLevel(), 
												pParentRecord->GetName(), &pReq );

				if ( SUCCEEDED( hr ) )
				{
					hr = pParentRecord->SetExecutionContext( pReq->GetContext() );

					if ( SUCCEEDED( hr ) )
					{
						// Clearly, we should do this outside the critsec
						ics.Leave();

	#ifdef __DEBUG_MERGER_THROTTLING
						WCHAR	wszTemp[256];
						wsprintf( wszTemp, L"BEGIN: Merger 0x%x querying instances of parent class: %s, Level %d on Thread 0x%x\n", (DWORD_PTR) this, pParentRecord->GetName(), pParentRecord->GetLevel(), GetCurrentThreadId() );
						OutputDebugStringW( wszTemp );
	#endif

						// This will delete the request when it is done with it
						hr = CCoreQueue::ExecSubRequest( pReq );

	#ifdef __DEBUG_MERGER_THROTTLING
						wsprintf( wszTemp, L"END: Merger 0x%x querying instances of parent class: %s, Level %d on Thread 0x%x\n", (DWORD_PTR) this, pParentRecord->GetName(), pParentRecord->GetLevel(), GetCurrentThreadId() );
						OutputDebugStringW( wszTemp );
	#endif

						ics.Enter();

					}	// IF SetExecutionContext

					// We're done with this record, so we need to get the next top level
					// record.

					pParentRecord = NULL;

				}	// IF SUCCEEDED - RemoveRequest

			}	// IF SUCCEEDED(hr)

		}	// IF m_hOperationRes
		else
		{
			hr = m_hOperationRes;
		}

	}

	return pSink->Return( hr );
}

//
// Executes the child request.  In this case, we enumerate the child classes of the parent
// record, and execute the corresponding requests.  We do so in a loop until we either
// finish or something goes wrong.
//

HRESULT CWmiMerger::Exec_MergerChildRequest( CWmiMergerRecord* pParentRecord, CBasicObjectSink* pSink )
{
	HRESULT	hr = WBEM_S_NO_ERROR;
	bool	bLast = false;

	CCheckedInCritSec	ics( &m_cs );

	// While we have child requests to execute, we should get each one
	for (int x = 0; SUCCEEDED( hr ) && NULL != m_pRequestMgr && !bLast; x++ )
	{
		// m_pRequestMgr will be NULL if we were cancelled, in which
		// case m_hOperationRes will be NULL
		if ( SUCCEEDED( m_hOperationRes ) )
		{
			CWmiMergerRecord* pChildRecord = pParentRecord->GetChildRecord( x );

			if ( NULL != pChildRecord )
			{
				CMergerReq* pReq = NULL;

				// This will remove the request from its array and return it
				// to us - we need to delete it

				hr = m_pRequestMgr->RemoveRequest( pChildRecord->GetLevel(), 
												pChildRecord->GetName(), &pReq );

				if ( SUCCEEDED( hr ) )
				{
					hr = pChildRecord->SetExecutionContext( pReq->GetContext() );

					if ( SUCCEEDED( hr ) )
					{
						// Clearly, we should do this outside the critsec
						ics.Leave();

#ifdef __DEBUG_MERGER_THROTTLING
						WCHAR	wszTemp[256];
						wsprintf( wszTemp, L"BEGIN: Merger 0x%x querying instances of child class: %s, Level %d for parent class: %s on Thread 0x%x\n", (DWORD_PTR) this, pChildRecord->GetName(), pChildRecord->GetLevel(), pParentRecord->GetName(), GetCurrentThreadId() );
						OutputDebugStringW( wszTemp );
#endif

						// This will delete the request when it is done with it
						hr = CCoreQueue::ExecSubRequest( pReq );

#ifdef __DEBUG_MERGER_THROTTLING
						wsprintf( wszTemp, L"END: Merger 0x%x querying instances of child class: %s, Level %d for parent class: %s on Thread 0x%x\n",  (DWORD_PTR) this, pChildRecord->GetName(), pChildRecord->GetLevel(), pParentRecord->GetName(), GetCurrentThreadId() );
						OutputDebugStringW( wszTemp );
#endif

						ics.Enter();

					}	// IF SetExecutionContext

				}  // IF remove request
				else if ( WBEM_E_NOT_FOUND == hr )
				{
					// If we don't find the request we're looking for, another thread
					// already processed it.  We should, however, still look for child
					// requests to process before we go away.
					hr = WBEM_S_NO_ERROR;
				}

			}
			else
			{
				bLast = true;
			}


		}	// IF m_hOperationRes
		else
		{
			hr = m_hOperationRes;
		}

	}	// FOR enum child requests

	return pSink->Return( hr );
}

// Schedules the parent class request
HRESULT CWmiMerger::ScheduleMergerParentRequest( IWbemContext* pCtx )
{
	// Check if query arbitration is enabled
	if ( !ConfigMgr::GetEnableQueryArbitration() )
	{
		return WBEM_S_NO_ERROR;
	}

	CCheckedInCritSec	ics( &m_cs );

	HRESULT hr = WBEM_S_NO_ERROR;

	if ( SUCCEEDED( m_hOperationRes ) )
	{
		WString	wsClassName;

		// The request manager will be non-NULL only if we had to add a request.
		if ( NULL != m_pRequestMgr )
		{
#ifdef __DEBUG_MERGER_THROTTLING
					m_pRequestMgr->DumpRequestHierarchy();
#endif

			// Make sure we've got at least one request
			if ( m_pRequestMgr->GetNumRequests() > 0 )
			{
				// If there isn't a task, we've got a BIG problem.

				_DBG_ASSERT( NULL != m_pTask );

				if ( NULL != m_pTask )
				{
					// If we have a single static request in the merger, we'll
					// execute it now.  Otherwise, we'll do normal processing.
					// Note that we *could* theoretically do this for single
					// dynamic requests as well
					if ( IsSingleStaticRequest() )
					{
						// We MUST leave the critical section here, since the parent request
						// could get cancelled or we may end up sleeping and we don't want
						// to own the critical section in that time.
						ics.Leave();
						hr = Exec_MergerParentRequest( NULL, m_pTargetSink );
					}
					else
					{
						// If we've never retrieved the number of processors, do so
						// now.
						static g_dwNumProcessors = 0L;

						if ( 0L == g_dwNumProcessors )
						{
							SYSTEM_INFO	sysInfo;
							ZeroMemory( &sysInfo, sizeof( sysInfo ) );
							GetSystemInfo( &sysInfo );

							_DBG_ASSERT( sysInfo.dwNumberOfProcessors > 0L );

							// Ensure we're always at least 1
							g_dwNumProcessors = ( 0L == sysInfo.dwNumberOfProcessors ?
													1L : sysInfo.dwNumberOfProcessors );
						}

						// We will generate a number of parent requests based on the minimum
						// of the number of requests and the number of actual processors.

						DWORD dwNumToSchedule = min( m_pRequestMgr->GetNumRequests(), g_dwNumProcessors );

						for ( DWORD	dwCtr = 0L; SUCCEEDED( hr ) && dwCtr < dwNumToSchedule; dwCtr++ )
						{
							// Parent request will search for the next available request
							CMergerParentReq*	pReq = new CMergerParentReq (
								this,
								NULL,
								m_pNamespace,
								m_pTargetSink,
								pCtx
							);

							if ( NULL != pReq )
							{
								if ( NULL != pReq->GetContext() )
								{
									// Set the task for the request - we'll just use the existing one
									m_pTask->AddRef();
									pReq->m_phTask = m_pTask;
									
									// This may sleep, so exit the critsec before calling into this
									ics.Leave();

									hr = ConfigMgr::EnqueueRequest( pReq );

									if ( FAILED(hr) )
									{
										delete pReq;
									}
									else
									{
										// reenter the critsec
										ics.Enter();
									}

								}
								else
								{
									delete pReq;
									hr = WBEM_E_OUT_OF_MEMORY;
								}
							}
							else
							{
								hr = WBEM_E_OUT_OF_MEMORY;
							}

						}	// For schedule requests

					}	// IF !SingleStaticRequest

				}	// IF NULL != m_pTask
				else
				{
					hr = WBEM_E_FAILED;
				}
				
			}	// IF there are requests

		}	// IF NULL != m_pRequestMgr

	}
	else
	{
		hr = m_hOperationRes;
	}

	// If we have to cancel, do so OUTSIDE of the critsec
	ics.Leave();

	if ( FAILED( hr ) )
	{
		Cancel( hr );
	}

	return hr;
}

// Schedules a child class request
HRESULT CWmiMerger::ScheduleMergerChildRequest( CWmiMergerRecord* pParentRecord )
{
	// Check if query arbitration is enabled
	if ( !ConfigMgr::GetEnableQueryArbitration() )
	{
		return WBEM_S_NO_ERROR;
	}

	CCheckedInCritSec	ics( &m_cs );

	HRESULT hr = WBEM_S_NO_ERROR;

	// We must be in a success state and not have previously scheduled a child
	// request.

	if ( SUCCEEDED( m_hOperationRes ) && !pParentRecord->ScheduledChildRequest() )
	{

		// If there isn't a task, we've got a BIG problem.

		_DBG_ASSERT( NULL != m_pTask );

		if ( NULL != m_pTask )
		{
			CMergerChildReq*	pReq = new CMergerChildReq (
				this,
				pParentRecord,
				m_pNamespace,
				m_pTargetSink,
				pParentRecord->GetExecutionContext()
			);

			if ( NULL != pReq )
			{
				if ( NULL != pReq->GetContext() )
				{
					// Set the task for the request - we'll just use the existing one
					m_pTask->AddRef();
					pReq->m_phTask = m_pTask;

					// We've basically scheduled one at this point
					pParentRecord->SetScheduledChildRequest();

					// This may sleep, so exit the critsec before calling into this
					ics.Leave();

					hr = ConfigMgr::EnqueueRequest( pReq );

					if (FAILED(hr))
					{
						delete pReq;
					}
				}
				else
				{
					delete pReq;
					hr = WBEM_E_OUT_OF_MEMORY;
				}
			}
			else
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}

		}
		else
		{
			hr = WBEM_E_FAILED;
		}

	}
	else
	{
		hr = m_hOperationRes;
	}

	// If we have to cancel, do so OUTSIDE of the critsec
	ics.Leave();

	if ( FAILED( hr ) )
	{
		Cancel( hr );
	}

	return hr;
}

// Returns whether or not we have a single static class request in the merger
// or not
BOOL CWmiMerger::IsSingleStaticRequest( void )
{
	CCheckedInCritSec	ics( &m_cs );

	BOOL	fRet = FALSE;

	if ( NULL != m_pRequestMgr )
	{
		// Ask if we've got a single request
		fRet = m_pRequestMgr->HasSingleStaticRequest();
	}	// IF NULL != m_pRequestMgr

	return fRet;
}

// 
//	CWmiMergerRecord
//	
//	Support class for CWmiMerger - encapsulates sub-sink functionality for the CWmiMerger
//	class.  The merger calls the records which actually know whether or not they sit on
//	top of sinks or actual mergers.
//

CWmiMergerRecord::CWmiMergerRecord( CWmiMerger* pMerger, BOOL fHasInstances,
				BOOL fHasChildren, LPCWSTR pwszClass, CMergerSink* pDestSink, DWORD dwLevel,
				bool bStatic )
:	m_pMerger( pMerger ),
	m_fHasInstances( fHasInstances ),
	m_fHasChildren( fHasChildren ),
	m_dwLevel( dwLevel ),
	m_wsClass( pwszClass ),
	m_pDestSink( pDestSink ),
	m_pInternalMerger( NULL ),
	m_ChildArray(),
	m_bScheduledChildRequest( false ),
	m_pExecutionContext( NULL ),
	m_bStatic( bStatic )
{
	// No Addrefing internal sinks, since they really AddRef the entire merger
	// and we don't want to create Circular Dependencies
}

CWmiMergerRecord::~CWmiMergerRecord()
{
	if ( NULL != m_pInternalMerger )
	{
		delete m_pInternalMerger;
	}

	if ( NULL != m_pExecutionContext )
	{
		m_pExecutionContext->Release();
	}
}

HRESULT CWmiMergerRecord::AttachInternalMerger( CWbemClass* pClass, CWbemNamespace* pNamespace,
												IWbemContext* pCtx, BOOL fDerivedFromTarget,
												bool bStatic )
{
	if ( NULL != m_pInternalMerger )
	{
		return WBEM_E_INVALID_OPERATION;
	}

	HRESULT	hr = WBEM_S_NO_ERROR;

	m_pInternalMerger = new CInternalMerger( this, m_pDestSink, pClass, pNamespace, pCtx );

	if ( NULL != m_pInternalMerger )
	{
		hr = m_pInternalMerger->Initialize();

		if ( FAILED( hr ) )
		{
			delete m_pInternalMerger;
			m_pInternalMerger = NULL;
		}
		else
		{
			m_pInternalMerger->SetIsDerivedFromTarget( fDerivedFromTarget );
		}
	}
	else
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}

	return hr;
}

CMergerSink* CWmiMergerRecord::GetChildSink( void )
{
	CMergerSink*	pSink = NULL;

	if ( NULL != m_pInternalMerger )
	{
		pSink = m_pInternalMerger->GetChildSink();
	}
	else if ( m_fHasChildren )
	{
		m_pDestSink->AddRef();
		pSink = m_pDestSink;
	}

	return pSink;
}

CMergerSink* CWmiMergerRecord::GetOwnSink( void )
{
	CMergerSink*	pSink = NULL;

	if ( NULL != m_pInternalMerger )
	{
		pSink = m_pInternalMerger->GetOwnSink();
	}
	else if ( !m_fHasChildren )
	{
		m_pDestSink->AddRef();
		pSink = m_pDestSink;
	}


	return pSink;
}

CMergerSink* CWmiMergerRecord::GetDestSink( void )
{
	if ( NULL != m_pDestSink )
	{
		m_pDestSink->AddRef();
	}

	CMergerSink*	pSink = m_pDestSink;

	return pSink;
}

void CWmiMergerRecord::Cancel( HRESULT hRes )
{
	if ( NULL != m_pInternalMerger )
	{
		m_pInternalMerger->Cancel( hRes );
	}

}

HRESULT CWmiMergerRecord::AddChild( CWmiMergerRecord* pRecord )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( m_ChildArray.Add( pRecord ) < 0 )
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}

	return hr;
}

CWmiMergerRecord* CWmiMergerRecord::GetChildRecord( int nIndex )
{
	// Check if the index is a valid record, then return it
	if ( nIndex < m_ChildArray.GetSize() )
	{
		return m_ChildArray[nIndex];
	}

	return NULL;
}

HRESULT CWmiMergerRecord::SetExecutionContext( IWbemContext* pContext )
{
	// We can only do this once

	_DBG_ASSERT( NULL == m_pExecutionContext );

	if ( NULL != m_pExecutionContext )
	{
		return WBEM_E_INVALID_OPERATION;
	}

	if (pContext)
	{
 		pContext->AddRef();
		m_pExecutionContext = pContext;
	}
	else
	{
	    return WBEM_E_INVALID_PARAMETER;
	}

	return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\wmimerger.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WMIMERGER.H

Abstract:

    Implements _IWmiMerger

History:

	16-Nov-00   sanjes    Created.

--*/

#ifndef _WMIMERGER_H_
#define _WMIMERGER_H_

#include "internalmerger.h"
#include "mergerreq.h"

// forward class definitions
class CWmiMerger;

//
//	Support class for CWmiMerger.
//
//	Basically, CWmiMerger holds onto many instances of CWmiMergerRecord
//

class CWmiMergerRecord
{
	BOOL				m_fHasInstances;
	BOOL				m_fHasChildren;
	DWORD				m_dwLevel;
	WString				m_wsClass;
	CWmiMerger*			m_pMerger;
	CInternalMerger*	m_pInternalMerger;
	CMergerSink*		m_pDestSink;
	CPointerArray<CWmiMergerRecord>	m_ChildArray;
	bool				m_bScheduledChildRequest;
	IWbemContext*		m_pExecutionContext;
	bool				m_bStatic;


public:
	CWmiMergerRecord( CWmiMerger* pMerger, BOOL fHasInstances, BOOL fHasChildren,
					LPCWSTR pwszClass, CMergerSink* pDestSink, DWORD dwLevel,
					bool bStatic );
	~CWmiMergerRecord();

	CMergerSink*		GetChildSink( void );
	CMergerSink*		GetOwnSink( void );
	CMergerSink*		GetDestSink( void );
	LPCWSTR				GetClass( void ) { return m_wsClass; }
	LPCWSTR				GetName( void ) { return GetClass(); }
	BOOL				IsClass( LPCWSTR pwszClass ) { return m_wsClass.EqualNoCase( pwszClass ); }
	DWORD				GetLevel( void ) { return m_dwLevel; }
	bool				IsStatic( void ) { return m_bStatic; }

	HRESULT AttachInternalMerger( CWbemClass* pClass, CWbemNamespace* pNamespace, IWbemContext* pCtx,
									BOOL fDerivedFromTarget, bool bStatic );

	HRESULT AddChild( CWmiMergerRecord* pRecord );

	CWmiMerger*	GetWmiMerger( void )	{ return m_pMerger; }

	// If we have an internal merger, we tell it to cancel
	void Cancel( HRESULT hRes );

	bool ScheduledChildRequest( void )	{ return m_bScheduledChildRequest; }
	void SetScheduledChildRequest( void )	{ m_bScheduledChildRequest = true; }

	CWmiMergerRecord* GetChildRecord( int nIndex );

	HRESULT SetExecutionContext( IWbemContext* pContext );

	IWbemContext* GetExecutionContext( void )	{ return m_pExecutionContext; }

	// We can only cancel child sinks if we have an internal merger.
	void CancelChildSink( void ) { if ( NULL != m_pInternalMerger ) m_pInternalMerger->CancelChildSink(); }

	void SetIsStatic( bool b )	{ m_bStatic = b; }


};

// Allows us to locate values quickly by name
template<class TMember>
class CSortedUniquePointerArray :
        public CUniquePointerArray<TMember>
{
public:
	int Insert( TMember* pNewElement );
	TMember* Find( LPCWSTR pwszName, int* pnIndex = NULL );
	int RemoveAtNoDelete( int nIndex );
	BOOL Verify( void );
};

template <class TMember>
int CSortedUniquePointerArray<TMember>::Insert( TMember* pNewElement )
{
    int   nLowIndex = 0,
          nHighIndex = m_Array.Size();

    // Binary search of the ids to find an index at which to insert
    // If we find our element, this is a failure.

	while ( nLowIndex < nHighIndex )
	{
		int   nMid = (nLowIndex + nHighIndex) / 2;

		int nTest = _wcsicmp( ((TMember*) m_Array[nMid])->GetName(), pNewElement->GetName() );

		if ( nTest < 0 )
		{
			nLowIndex = nMid + 1;
		}
		else if ( nTest > 0 )
		{
			nHighIndex = nMid;
		}
		else
		{
			_DBG_ASSERT( 0 );
			// Index already exists
			return -1;
		}
	}   // WHILE looking for index

	// Found the location, if it's at the end, check if we need to do an insert or add
	// We insert if the element at the end is > the element we want to insert
	BOOL	bInsert = true;

	if ( nLowIndex == GetSize() - 1 )
	{
		bInsert = ( _wcsicmp( ((TMember*) m_Array[nLowIndex])->GetName(), pNewElement->GetName() ) > 0 );
	}

    // Stick it in (careful to add to the end if the selected index is the end
	// and the current element is not greater than the new one).

	if ( bInsert )
	{
		return InsertAt( nLowIndex, pNewElement );
	}

	return Add( pNewElement );

}

template <class TMember>
TMember* CSortedUniquePointerArray<TMember>::Find( LPCWSTR pwszName, int* pnIndex )
{

    int   nLowIndex = 0,
          nHighIndex = m_Array.Size();

    // Binary search of the values to find a the requested name.
    while ( nLowIndex < nHighIndex )
    {
        int   nMid = (nLowIndex + nHighIndex) / 2;

		int nTest = _wcsicmp( ((TMember*) m_Array[nMid])->GetName(), pwszName );

        if ( nTest < 0 )
        {
            nLowIndex = nMid + 1;
        }
        else if ( nTest > 0 )
        {
            nHighIndex = nMid;
        }
        else
        {
            // Found it
			if ( NULL != pnIndex )
			{
				*pnIndex = nMid;
			}

            return (TMember*) m_Array[nMid];
        }
    }   // WHILE looking for index

    // Didn't find it
    return NULL;

}

// Removes the element, but does not auto-delete it
template <class TMember>
int CSortedUniquePointerArray<TMember>::RemoveAtNoDelete( int nIndex )
{
	if ( nIndex >= m_Array.Size() )
	{
		return -1;
	}

	m_Array.RemoveAt( nIndex );

	return nIndex;
}

template <class TMember>
BOOL CSortedUniquePointerArray<TMember>::Verify( void )
{
	BOOL	fReturn = TRUE;

	for ( int x = 0; fReturn && x < GetSize() - 1; x++ )
	{
		// Should be in ascending order
		LPCWSTR pwszFirst = GetAt( x )->GetName();
		LPCWSTR pwszSecond = GetAt( x+1 )->GetName();

		fReturn = ( _wcsicmp( GetAt( x )->GetName(), GetAt( x+1 )->GetName() ) < 0 );
		_DBG_ASSERT( fReturn );

		if ( !fReturn )
		{
			CSortedUniquePointerArray<TMember> tempArray;

			for ( int y = 0; y < GetSize(); y++ )
			{
				tempArray.Insert( GetAt( y ) );
			}
		}
	}
	
	return fReturn;
}

//******************************************************************************
//******************************************************************************
//
//  class CWmiMerger
//
//  This class implements the WMI Merger.
//
//******************************************************************************

class CWmiMerger : public _IWmiArbitratee, public _IWmiArbitratedQuery
{
	long		m_lRefCount;
	WString		m_wsTargetClassName;
	CMergerTargetSink*	m_pTargetSink;
	_IWmiCoreHandle*	m_pTask;
	_IWmiArbitrator*	m_pArbitrator;
	CWbemNamespace*		m_pNamespace;
	DWORD		m_dwProviderDeliveryPing;
	DWORD		m_dwMaxLevel;
	DWORD		m_dwMinReqLevel;
	CSortedUniquePointerArray<CWmiMergerRecord>	m_MergerRecord;
	CUniquePointerArray<CMergerSink>		m_MergerSinks;
	long		m_lNumArbThrottled;
	HRESULT		m_hOperationRes;
	bool		m_bMergerThrottlingEnabled;
	CCritSec	m_cs;

	long		m_lDebugMemUsed;

	CWmiMergerRequestMgr* m_pRequestMgr;

public:
    // No access
    CWmiMerger( CWbemNamespace* pNamespace );
   ~CWmiMerger();

protected:

	HRESULT GetLevelAndSuperClass( _IWmiObject* pObj, DWORD* pdwLevel, WString* pwsSuperClass );

public:
    /* IUnknown methods */
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

	/* _IWmiArbitratee methods */
	STDMETHOD(SetOperationResult)( ULONG uFlags, HRESULT hRes );
	STDMETHOD(SetTaskHandle)( _IWmiCoreHandle* pTask );
	STDMETHOD(DumpDebugInfo)( ULONG uFlags, const BSTR strFile );

	/* _IWmiArbitratedQuery methods */
	STDMETHOD(IsMerger)( void );

	// Sets initial parameters for merger.  Establishes the target class and sink for the
	// query associated with the merger
	STDMETHOD(Initialize)( _IWmiArbitrator* pArbitrator, _IWmiCoreHandle* pTask, LPCWSTR pwszTargetClass, IWbemObjectSink* pTargetSink, CMergerSink** ppFinalSink );

	// Called to request a delivery sink for a class in the query chain.  The returned
	// sink is determined by the specified flags as well as settings on the parent class
	STDMETHOD(RegisterSinkForClass)( LPCWSTR pwszClass, _IWmiObject* pClass, IWbemContext* pContext,
									BOOL fHasChildren, BOOL fHasInstances, BOOL fDerivedFromTarget,
									bool bStatic, CMergerSink* pDestSink, CMergerSink** ppOwnSink, CMergerSink** ppChildSink );

	// Called to request a delivery sink for child classes in the query chain.  This is especially
	// important when instances are merged under the covers.
	STDMETHOD(GetChildSink)( LPCWSTR pwszClass, CBasicObjectSink** ppSink );

	// Can be used to holdoff indicates - if we're merging instances from multiple providers, we need
	// to ensure that we don't get lopsided in the number of objects we've got queued up for merging.
	STDMETHOD(Throttle)( void );

	// Merger will hold information regarding the total number of objects it has queued up waiting
	// for merging and the amount of memory consumed by those objects.
	STDMETHOD(GetQueuedObjectInfo)( DWORD* pdwNumQueuedObjects, DWORD* pdwQueuedObjectMemSize );

	// If this is called, all underlying sinks will be cancelled in order to prevent accepting additional
	// objects.  This will also automatically free up resources consumed by queued objects.
	STDMETHOD(Cancel)( void );

	// Helper function for creating our sinks - this will add the sink to our array of
	// sinks which will get destroyed when we are released
	HRESULT CreateMergingSink( MergerSinkType eType, IWbemObjectSink* pDestSink, CInternalMerger* pMerger, CMergerSink** ppSink );

	// If this is called, all underlying sinks will be cancelled in order to prevent accepting additional
	// objects.  This will also automatically free up resources consumed by queued objects.
	HRESULT Cancel( HRESULT hRes );

	// Final Shutdown.  Called when the target sink is released.  At this point, we should
	// unregister ourselves from the world
	HRESULT Shutdown( void );

	// Registers arbitrated requests
	HRESULT RegisterArbitratedInstRequest( CWbemObject* pClassDef, long lFlags, IWbemContext* pCtx,
				CBasicObjectSink* pSink, BOOL bComplexQuery, CWbemNamespace* pNs );

	HRESULT RegisterArbitratedQueryRequest( CWbemObject* pClassDef, long lFlags, LPCWSTR Query,
				LPCWSTR QueryFormat, IWbemContext* pCtx, CBasicObjectSink* pSink,
				CWbemNamespace* pNs );

	HRESULT RegisterArbitratedStaticRequest( CWbemObject* pClassDef, long lFlags, 
				IWbemContext* pCtx, CBasicObjectSink* pSink, CWbemNamespace* pNs,
				QL_LEVEL_1_RPN_EXPRESSION* pParsedQuery );

	// Executes a Merger Parent Request - Cycles through parent object requests and executes
	// them as appropriate
	HRESULT Exec_MergerParentRequest( CWmiMergerRecord* pParentRecord, CBasicObjectSink* pSink );

	// Executes a Merger Child Request - Cycles through child classes of the given parent
	// class, and executes the appropriate requests
	HRESULT Exec_MergerChildRequest( CWmiMergerRecord* pParentRecord, CBasicObjectSink* pSink );

	// Schedules a Merger Parent Request if one is necessary
	HRESULT ScheduleMergerParentRequest( IWbemContext* pCtx );

	// Schedules a Merger Child Request
	HRESULT ScheduleMergerChildRequest( CWmiMergerRecord* pParentRecord );

	// Enables/Disables merger throttling in all records (on by default)
	void EnableMergerThrottling( bool b ) { m_bMergerThrottlingEnabled = b; }

	// Returns whether or not we have a single static request in the merger
	BOOL IsSingleStaticRequest( void );

	bool MergerThrottlingEnabled( void ) { return m_bMergerThrottlingEnabled; }

	_IWmiCoreHandle*	GetTask( void )	{ return m_pTask; }

	// Help us track that *something* is going on
	// We are intentionally not wrapping thread safety around these guys, since assigning and
	// retrieving the value is an atomic operation and realistically, if any contention occurs
	// setting the values, they should all, more or less reflect the same tick (remember, they're
	// all jumping in at the same time, so this shouldn't really be a problem.
	void PingDelivery( DWORD dwLastPing )	{ m_dwProviderDeliveryPing = dwLastPing; }
	DWORD GetLastDeliveryTime( void ) { return m_dwProviderDeliveryPing; }

    HRESULT ReportMemoryUsage( long lAdjustment );

	// Helper functions for tracking the number of threads potentially being throttled by
	// the arbitrator
	long IncrementArbitratorThrottling( void ) { return InterlockedIncrement( &m_lNumArbThrottled ); }
	long DecrementArbitratorThrottling( void ) { return InterlockedDecrement( &m_lNumArbThrottled ); }
	long NumArbitratorThrottling( void ) { return m_lNumArbThrottled ; }

};


#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\wmicache.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WmiCache.cpp

Abstract:

    WMI cache for _IWmiObject's.  Used within wbemcore only.  When memory threshold 
	is hit, objects are stored in disk-based store.  When size of disk-based store
	gets too big, additions to cache fail.

History:

    paulall		10-Mar-2000		Created.


--*/

#include "precomp.h"
#include "wbemint.h"
#include "wbemcli.h"
#include "WmiCache.h"
#include <arrtempl.h>


//***************************************************************************
//
//***************************************************************************
CWmiCache::CWmiCache()
: m_lRefCount(0), m_nEnum(0)
{
	InitializeCriticalSection(&m_cs);
}

//***************************************************************************
//
//***************************************************************************
CWmiCache::~CWmiCache()
{
	Empty(0, NULL);
	DeleteCriticalSection(&m_cs);
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiCache::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = 0;

    if (IID_IUnknown==riid || IID__IWmiCache==riid)
    {
        *ppvObj = (_IWmiCache*)this;
        AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;

}

//***************************************************************************
//
//***************************************************************************
ULONG CWmiCache::AddRef()
{
    return InterlockedIncrement(&m_lRefCount);
}

//***************************************************************************
//
//***************************************************************************
ULONG CWmiCache::Release()
{
    ULONG uNewCount = InterlockedDecrement(&m_lRefCount);
    if (0 == uNewCount)
        delete this;
    return uNewCount;
}


//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiCache::SetConfigValue(
    /*[in]*/ ULONG uID,
    /*[in]*/ ULONG uValue
    )
{
	return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiCache::GetConfigValue(
    /*[in]*/  ULONG uID,
    /*[out]*/ ULONG *puValue
   )
{
	return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiCache::Empty(
    /*[in]*/ ULONG uFlags,
    /*[in]*/ LPCWSTR wszClass
    )
{
	EnterCriticalSection(&m_cs);

	while(m_objects.Size())
	{
		CWmiCacheObject *pObj = (CWmiCacheObject*)m_objects[m_objects.Size()-1];
		pObj->m_pObj->Release();
		delete pObj;
		m_objects.RemoveAt(m_objects.Size()-1);
	}

	LeaveCriticalSection(&m_cs);
	return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
// Also subsumes replace functionality
//
// __PATH Property is used as a real key
//***************************************************************************
STDMETHODIMP CWmiCache::AddObject(
    /*[in]*/ ULONG uFlags,
    /*[in]*/ _IWmiObject *pObj
    )
{
	HRESULT hr = WBEM_S_NO_ERROR;

	int nPathHash = 0;
	hr = HashPath(pObj, &nPathHash);
	if (FAILED(hr))
		return hr;

	CWmiCacheObject *pCacheObj = new CWmiCacheObject(nPathHash, pObj);
	if (pCacheObj == NULL)
		return WBEM_E_OUT_OF_MEMORY;

	EnterCriticalSection(&m_cs);

	pObj->AddRef();

	int nRet = m_objects.Add(pCacheObj);
	if (nRet != CFlexArray::no_error)
	{
		pObj->Release();
		if (nRet == CFlexArray::out_of_memory)
			hr = WBEM_E_OUT_OF_MEMORY;
		else
			hr = WBEM_E_FAILED;
	}

	LeaveCriticalSection(&m_cs);
	return hr;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiCache::DeleteByPath(
    /*[in]*/ ULONG uFlags,
    /*[in]*/ LPCWSTR wszFullPath
    )
{
	HRESULT hr;
	int nPathHash = 0;
	hr = HashPath(wszFullPath, &nPathHash);
	if (FAILED(hr))
		return hr;

	hr = WBEM_E_NOT_FOUND;

	EnterCriticalSection(&m_cs);

	for (int i = 0; i != m_objects.Size(); i++)
	{
		CWmiCacheObject *pObj = (CWmiCacheObject*)m_objects[i];

		if (pObj->m_nHash = nPathHash)
		{
			hr = ComparePath(wszFullPath, pObj->m_pObj);
			if (SUCCEEDED(hr))
			{
				m_objects.RemoveAt(i);
				pObj->m_pObj->Release();
				delete pObj;
				hr = WBEM_S_NO_ERROR;
				break;
			}
			else if (hr != WBEM_E_NOT_FOUND)
				break;
		}
	}

	LeaveCriticalSection(&m_cs);
	return hr;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiCache::DeleteByPointer(
    /*[in]*/ ULONG uFlags,
    /*[in]*/ _IWmiObject *pTarget
    )
{
	HRESULT hr = WBEM_E_NOT_FOUND;
	EnterCriticalSection(&m_cs);

	for (int i = 0; i != m_objects.Size(); i++)
	{
		if (m_objects[i] == pTarget)
		{
			m_objects.RemoveAt(i);
			hr = WBEM_S_NO_ERROR;
			break;
		}
	}

	LeaveCriticalSection(&m_cs);

	return hr;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiCache::GetByPath(
    /*[in]*/ ULONG uFlags,
    /*[in]*/ LPCWSTR wszFullPath,
    /*[out]*/ _IWmiObject **pObj
    )
{
	HRESULT hr;
	int nPathHash = 0;
	hr = HashPath(wszFullPath, &nPathHash);
	if (FAILED(hr))
		return hr;

	hr = WBEM_E_NOT_FOUND;

	EnterCriticalSection(&m_cs);

	for (int i = 0; i != m_objects.Size(); i++)
	{
		CWmiCacheObject *pCacheObj = (CWmiCacheObject*)m_objects[i];

		if (pCacheObj->m_nHash == nPathHash)
		{
			hr = ComparePath(wszFullPath, pCacheObj ->m_pObj);
			if (SUCCEEDED(hr))
			{
				*pObj = pCacheObj->m_pObj;
				(*pObj)->AddRef();
				hr = WBEM_S_NO_ERROR;
				break;
			}
			else if (hr != WBEM_E_NOT_FOUND)
			{
				break;
			}
		}
	}

	LeaveCriticalSection(&m_cs);

	return hr;
}

//***************************************************************************
//
// Filters: uFlags==0==all, uFlags==WMICACHE_CLASS_SHALLOW, WMICACHE_CLASS_DEEP
//***************************************************************************
STDMETHODIMP CWmiCache::BeginEnum(
    /*[in]*/ ULONG uFlags,
    /*[in]*/ LPCWSTR wszFilter
    )
{
	if (uFlags != 0)
		return WBEM_E_INVALID_PARAMETER;

	m_nEnum = 0;
	return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiCache::Next(
    /*[in]*/ ULONG uBufSize,
    /*[out, size_is(uBufSize), length_is(*puReturned)]*/ _IWmiObject **pObjects,
    /*[out]*/ ULONG *puReturned
    )
{
	HRESULT hr = WBEM_S_NO_ERROR;
	EnterCriticalSection(&m_cs);
	
	for (ULONG i = 0; i != uBufSize; i++, m_nEnum++)
	{
		if (m_nEnum == m_objects.Size())
		{
			hr = WBEM_S_NO_MORE_DATA;
			break;
		}
		pObjects[i] = ((CWmiCacheObject*)m_objects[m_nEnum])->m_pObj;
		pObjects[i]->AddRef();
	}

	*puReturned = i;

	LeaveCriticalSection(&m_cs);

	return hr;
}

HRESULT CWmiCache::HashPath(const wchar_t *wszPath, int *pnHash)
{
	DWORD dwHash = 0;

	while (*wszPath)
	{
		dwHash = (dwHash << 4) + *wszPath++;
		DWORD dwTemp = dwHash & 0xF0000000;
		if (dwTemp)
			dwHash ^= dwTemp >> 24;
		dwHash &= ~dwTemp;
	}


	*pnHash = (int)dwHash;
	return WBEM_S_NO_ERROR;;
}

HRESULT CWmiCache::HashPath(_IWmiObject *pObj, int *pnHash)
{
	VARIANT varPath;
	VariantInit(&varPath);
	HRESULT hr = pObj->Get(L"__PATH", 0, &varPath, NULL, NULL);
	if (SUCCEEDED(hr))
	{
		hr = HashPath(V_BSTR(&varPath), pnHash);
		VariantClear(&varPath);
	}
	return hr;
}

HRESULT CWmiCache::ComparePath(const wchar_t *wszPath, _IWmiObject *pObject)
{
	VARIANT varPath;
	VariantInit(&varPath);
	HRESULT hr = pObject->Get(L"__PATH", 0, &varPath, NULL, NULL);
	if (SUCCEEDED(hr))
	{
		if (wcscmp(wszPath, V_BSTR(&varPath)) == 0)
			hr = WBEM_S_NO_ERROR;
		else 
			hr = WBEM_E_NOT_FOUND;
		VariantClear(&varPath);
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\wmifinalizer.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WmiFinalizer2

Abstract:


History:

    paulall		27-Mar-2000		Created.
	marioh		20-Oct-2000		Major updates completed

--*/

#include "precomp.h"
#include <stdio.h>
#include "wbemint.h"
#include "wbemcli.h"
#include "WmiFinalizer.h"
#include "coresvc.h"
#include "coreq.h"
#include <wbemcore.h>
#include <wmiarbitrator.h>

#include <tchar.h>

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif


//
// Added ASSERTS
//
#ifdef DBG
  //#define __DBG_FINALIZER
#endif


#ifdef __DBG_FINALIZER
  CFlexArray g_DbgFinalizers ;
  LONG	g_DbgFinalizerTotalObjCount = 0 ;
  LONG	g_DbgFinalizerTotalObjSize = 0 ;
#endif



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Batching related registry data
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#define	REGKEY_CIMOM		"Software\\Microsoft\\Wbem\\CIMOM"
#define REGVALUE_BATCHSIZE	"FinalizerBatchSize"

ULONG g_ulMaxBatchSize = 0;


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Client callback related registry data
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#define REGVALUE_CLIENTCALLBACKTIMEOUT	"ClientCallbackTimeout"

ULONG g_ulClientCallbackTimeout = 0;


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Queue threshold related registry data
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#define REGVALUE_QUEUETHRESHOLD			"FinalizerQueueThreshold"
#define DEFAULT_QUEUETHRESHOLD			2

ULONG g_ulFinalizerQueueThreshold = 0;



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Static declarations and initialization
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
LONG s_Finalizer_ObjectCount = 0 ;											// Global finalizer count
LONG s_FinalizerCallResult_ObjectCount = 0 ;								// Global CallbackEesult count
LONG s_FinalizerEnum_ObjectCount = 0 ;										// Global Enumerator count
LONG s_FinalizerEnumSink_ObjectCount = 0 ;									// Global Enumerator sink count
LONG s_FinalizerInBoundSink_ObjectCount = 0 ;								// Global InboundSink count


//CThreadPool CWmiFinalizer::m_threadPool;									// Shared thread pool amongst all finalizers



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Assertion code
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//!!! Enable verbose assertions if we are a checked build!
#ifdef DBG
#define FNLZR_ASSERT_ENABLE
#endif


#if (defined FNLZR_ASSERT_ENABLE)
HRESULT _RetFnlzrAssert(TCHAR *msg, HRESULT hres, const char *filename, int line)
{
    TCHAR *buf = new TCHAR[512];
	if (buf == NULL)
	{
		return hres;
	}
    wsprintf(buf, __TEXT("%s\nhres = 0x%X\nFile: %s, Line: %lu\n\nPress Cancel to stop in debugger, OK to continue"), msg, hres, filename, line);
    int mbRet = MessageBox(0, buf, __TEXT("WMI Assert"),  MB_OKCANCEL | MB_ICONSTOP | MB_SYSTEMMODAL | MB_SERVICE_NOTIFICATION);
	delete [] buf;
	if (mbRet == IDCANCEL)
	{
		DebugBreak();
	}
	return hres;
}

#define RET_FNLZR_ASSERT(msg, hres)  return _RetFnlzrAssert(msg, hres, __FILE__, __LINE__)
#define FNLZR_ASSERT(msg, hres) _RetFnlzrAssert(msg, hres, __FILE__, __LINE__)

#else

#define RET_FNLZR_ASSERT(msg, hres)  return hres
#define FNLZR_ASSERT(msg, hres)

#endif

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Autorelease IWbemObjectSink
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
class CAutoRelease
{
private:
	IWbemObjectSink* m_pObj;

public:
	CAutoRelease	(IWbemObjectSink* pObj) : m_pObj(pObj) {;}
	~CAutoRelease	() { if ( m_pObj) m_pObj->Release(); }

	VOID Release ( ) 
	{ 
		if ( m_pObj ) 
		{
			m_pObj->Release ( ) ;
			m_pObj = NULL ;
		}
	}
};


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Autosignal event
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
class CAutoSignal
{
private:
	HANDLE m_hEvent;
	
public:
	CAutoSignal (HANDLE hEvent) : m_hEvent(hEvent) { ; }
	~CAutoSignal() { if ( m_hEvent ) SetEvent(m_hEvent); }
};



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//													CWMIFINALIZER
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// CWmiFinalizer::CWmiFinalizer()
//
// Peforms initialization of the finalizer.
//
// Exceptions thrown:
//	
//	FNLZR_Exception		-> Init. failed
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

CWmiFinalizer::CWmiFinalizer(CCoreServices *pSrvs)

	:	m_lRefCount(0),
		m_lInternalRefCount(0),
		m_phTask(NULL),
		m_pArbitrator(NULL),
		m_pDestSink(NULL),
		m_pDestructSink(NULL),
		m_uForwardingType(forwarding_type_none),
		m_hresFinalResult(-1),
		m_pEnumerator(NULL),
		m_bRestartable(false),
		m_uCurObjectPosition(0),
		m_bSetStatusCalled(false),
		m_bSetStatusConsumed(false),
		m_ulQueueSize (0),
		m_bCancelledCall (FALSE),
		m_bNaughtyClient (FALSE),
		m_ulStatus (WMI_FNLZR_STATE_NO_INPUT),
		m_hCancelEvent (NULL),
		m_hStatus (NoError),
		m_ulOperationType (0),
		m_ulSemisyncWakeupCall (0),
		m_ulAsyncDeliveryCount (0),
		m_apAsyncDeliveryBuffer (NULL),
		m_lCurrentlyDelivering (FALSE),
		m_lCurrentlyCancelling (FALSE),
		m_enumBatchStatus (FinalizerBatch_NoError),
		m_bSetStatusEnqueued ( FALSE ),
		m_bSetStatusWithError ( FALSE ),
		m_lMemoryConsumption ( 0 ),
		m_bTaskInitialized ( FALSE ) ,
		m_bClonedFinalizer ( FALSE ) ,
		m_hWaitForSetStatus ( NULL ) ,
		m_bSetStatusDelivered ( FALSE )
{
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Create m_hResultReceived handle
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	m_hResultReceived = CreateEvent(NULL, TRUE, FALSE, NULL);
	if ( !m_hResultReceived )
		throw FNLZR_Exception();

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Create m_hCancelEvent handle
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	m_hCancelEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if ( !m_hCancelEvent )
		throw FNLZR_Exception();


	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Create new callresult
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	m_pCallResult = new CWmiFinalizerCallResult(this);
	if (m_pCallResult)
		m_pCallResult->InternalAddRef();
	
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// validate CoreServices pointer
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if (!pSrvs)
		throw FNLZR_Exception();
		
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Get arbitrator
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	m_pArbitrator = CWmiArbitrator::GetRefedArbitrator();
	
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Check what the batch size is supposed to be through registry. 
	// If not found, use default size defined in DEFAULT_BATCH_TRANSMIT_BYTES
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if ( !g_ulMaxBatchSize )
	{
		g_ulMaxBatchSize = DEFAULT_BATCH_TRANSMIT_BYTES;

		Registry batchSize (HKEY_LOCAL_MACHINE, KEY_QUERY_VALUE, _T(REGKEY_CIMOM));
		if ( batchSize.GetLastError() == ERROR_SUCCESS )
		{
			DWORD dwTmp;
			batchSize.GetDWORD ( _T(REGVALUE_BATCHSIZE), &dwTmp );
			if ( batchSize.GetLastError() == ERROR_SUCCESS )
				g_ulMaxBatchSize = (LONG) dwTmp;
		}
	}


	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Check what the timeout for client callbacks is supposed to be through registry. 
	// If not found, use default size defined in ABANDON_PROXY_THRESHOLD
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if ( !g_ulClientCallbackTimeout )
	{
		g_ulClientCallbackTimeout = ABANDON_PROXY_THRESHOLD;

		Registry batchSize (HKEY_LOCAL_MACHINE, KEY_QUERY_VALUE, _T(REGKEY_CIMOM));
		if ( batchSize.GetLastError() == ERROR_SUCCESS )
		{
			DWORD dwTmp;
			batchSize.GetDWORD ( _T(REGVALUE_CLIENTCALLBACKTIMEOUT), &dwTmp );
			if ( batchSize.GetLastError() == ERROR_SUCCESS )
				g_ulClientCallbackTimeout = (LONG) dwTmp;
		}
	}

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Check what the timeout for client callbacks is supposed to be through registry. 
	// If not found, use default size defined in ABANDON_PROXY_THRESHOLD
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if ( !g_ulFinalizerQueueThreshold )
	{
		g_ulFinalizerQueueThreshold = DEFAULT_QUEUETHRESHOLD;

		Registry batchSize (HKEY_LOCAL_MACHINE, KEY_QUERY_VALUE, _T(REGKEY_CIMOM));
		if ( batchSize.GetLastError() == ERROR_SUCCESS )
		{
			DWORD dwTmp;
			batchSize.GetDWORD ( _T(REGVALUE_QUEUETHRESHOLD), &dwTmp );
			if ( batchSize.GetLastError() == ERROR_SUCCESS )
				g_ulFinalizerQueueThreshold = (LONG) dwTmp;
		}
	}

	InterlockedIncrement ( & s_Finalizer_ObjectCount ) ;

#ifdef __DBG_FINALIZER
	CInCritSec lock(&m_arbitratorCS);
	g_DbgFinalizers.Add ( this ) ;
#endif
}


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// CWmiFinalizer::~CWmiFinalizer()
//
// Destructor. Decrements global finalizer object count
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CWmiFinalizer::~CWmiFinalizer()
{
//	CInCritSec lock(&m_arbitratorCS);


#ifdef __DBG_FINALIZER	
	if ( !m_bClonedFinalizer )
	{
		_DBG_ASSERT ( m_lMemoryConsumption == 0 ) ;
	}
#endif

	InterlockedDecrement ( & s_Finalizer_ObjectCount ) ;

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Unregister with arbitrator
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if (m_pArbitrator)
	{
		m_pArbitrator->UnRegisterArbitratee (0, m_phTask, this);
	}

	if ( m_phTask )
	{
		m_phTask->Release ( );
		m_phTask = NULL ;
	}

	if (m_pArbitrator)
	{
		m_pArbitrator->Release();
		m_pArbitrator = NULL ;
	}

#ifdef __DBG_FINALIZER
	{
		CInCritSec lock(&m_arbitratorCS);

		for ( int i = 0 ; i < g_DbgFinalizers.Size ( ); i++ )
		{
			if ( this == g_DbgFinalizers[i] )
			{
				g_DbgFinalizers.RemoveAt ( i ) ;
			}
		}
	}
#endif

}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// CWmiFinalizer::CallBackRelease ()
//
//  Called when the external ref count (client ref count) goes to zero.
//  Performs following clean up tasks
//	
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void CWmiFinalizer::CallBackRelease ()
{
	{
		CInCritSec cs ( &m_cs ) ;
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Release the arbitrator and all inbound sinks
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		for (LONG i = 0; i < m_objects.Size(); i++)
		{
			CWmiFinalizerObj *pObj = (CWmiFinalizerObj*)m_objects[i];
			if ( pObj )
			{
				if ( !m_bClonedFinalizer )
				{
					//ADDBACK: ReportMemoryUsage ( 0, -(pObj->m_uSize) );
				}
				delete pObj;
			}
		}
		m_objects.Empty ( ) ;
	}

  
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Release the destruct sink
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if (m_pDestructSink)
	{
		//TODO: Need to call in to say we are dying...
		//Don't know what we are supposed to do with it though!
		//m_pDestructSink->SetStatus(m_hresFinalResult, NULL, NULL);
		m_pDestructSink->Release();
	}

	for (int i = 0; i != m_inboundSinks.Size(); i++)
	{
		((CWmiFinalizerInboundSink*)m_inboundSinks[i])->InternalRelease();
	}
	
    
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Release the destination sink
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	ReleaseDestinationSink ( ) ;

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// If the call hasnt been cancelled already, go ahead and
	// do so now
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if (!m_bCancelledCall)
		CancelTaskInternal();

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Close all handles
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if ( m_hResultReceived )
	{
		SetEvent ( m_hResultReceived ) ;
		CloseHandle ( m_hResultReceived);
		m_hResultReceived = NULL ;
	}

	if ( m_hCancelEvent )
	{
		SetEvent ( m_hCancelEvent );
		CloseHandle ( m_hCancelEvent );
		m_hCancelEvent = NULL ;
	}


    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Release callresult and enumerator
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if (m_pCallResult)
	{
		m_pCallResult->InternalRelease();
		m_pCallResult = NULL ;
	}
	

	//
	// Release all enumerators associated with this finalizer
	//
	{
		CInCritSec cs ( &m_cs ) ;
		for ( i = 0; i < m_enumerators.Size ( ); i++ )
		{
			((CWmiFinalizerEnumerator*)m_enumerators[i])->InternalRelease ( ) ;
		}
		m_enumerators.Empty ( ) ;
	}

	NotifyClientOfCancelledCall ( ) ;
}


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// CWmiFinalizer::CancelTaskInternal()
//
// Calls the arbitrator and unregisters the task
//
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
HRESULT CWmiFinalizer::CancelTaskInternal ( )
{
	CInCritSec lock(&m_arbitratorCS);
	HRESULT hRes = WBEM_E_FAILED;

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Do we have a valid task?
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if (m_phTask)
	{
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
		// Do we have a valid arbitrator?
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		if (m_pArbitrator)
		{
			hRes = m_pArbitrator->UnregisterTask(m_phTask);
		}

		
		//
		// Removed this code due to memory reporting. We _used_ to
		// release the task immediately after completion AND before
		// the finalizer was destructed. This does not work anymore
		// since we need the task around due to potential objects still
		// left in the queue which need to be removed @ the point of
		// destruction
		//
		/*
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Release the task and NULL it
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		if ( m_phTask )
		{
			m_phTask->Release();
			m_phTask = NULL;
		}
		*/
	}
    return hRes;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// CWmiFinalizer::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
//
// Std implementation of QI
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
STDMETHODIMP CWmiFinalizer::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = 0;

    if (IID_IUnknown==riid || IID__IWmiFinalizer==riid)
    {
        *ppvObj = (_IWmiCache*)this;
        AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;

}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// CWmiFinalizer::AddRef()
//
// Std implementation of AddRef.
// Also does internal addref
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ULONG CWmiFinalizer::AddRef()
{
	ULONG uNewCount = InterlockedIncrement(&m_lRefCount);
	if ( uNewCount == 1 )
	{
		InternalAddRef () ;
	}

    return uNewCount;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// CWmiFinalizer::Release()
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ULONG CWmiFinalizer::Release()
{
    ULONG uNewCount = InterlockedDecrement(&m_lRefCount);
    if (0 == uNewCount)
	{
		CallBackRelease () ;

		InternalRelease () ;
	}

    return uNewCount;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// CWmiFinalizer::InternalAddRef()
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ULONG CWmiFinalizer::InternalAddRef()
{
	ULONG uNewCount = InterlockedIncrement(&m_lInternalRefCount);
    return uNewCount;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ULONG CWmiFinalizer::InternalRelease()
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ULONG CWmiFinalizer::InternalRelease()
{
    ULONG uNewCount = InterlockedDecrement(&m_lInternalRefCount);
    if (0 == uNewCount)
	{
		delete this ;
	}

    return uNewCount;
}


/*
    * =====================================================================================================
	|
	| HRESULT CWmiFinalizer::ReportMemoryUsage ( ULONG lFlags, LONG lDelta )
	| ----------------------------------------------------------------------
	| 
	| Common point to report memory consumption to the arbitrator.
	|
	| Uses m_phTask when calling arbitrator.
	|
	| 
	|
	* =====================================================================================================
*/

HRESULT CWmiFinalizer::ReleaseDestinationSink ( )
{
	HRESULT hRes = WBEM_S_NO_ERROR ;
	
	{
		CInCritSec lock(&m_destCS);
		if (m_pDestSink)
		{
			m_pDestSink->Release();
			m_pDestSink = 0;
		}
	}
	NotifyClientOfCancelledCall ( ) ;
	return hRes ;
}


/*
    * =====================================================================================================
	|
	| HRESULT CWmiFinalizer::ReportMemoryUsage ( ULONG lFlags, LONG lDelta )
	| ----------------------------------------------------------------------
	| 
	| Common point to report memory consumption to the arbitrator.
	|
	| Uses m_phTask when calling arbitrator.
	|
	| 
	|
	* =====================================================================================================
*/
HRESULT CWmiFinalizer::ReportMemoryUsage ( ULONG lFlags, LONG lDelta )
{
	HRESULT hRes = WBEM_S_NO_ERROR ;

#ifdef __DBG_FINALIZER
	_DBG_ASSERT ( m_phTask != NULL ) ;
#endif
	
	
	hRes = m_pArbitrator->ReportMemoryUsage ( lFlags, lDelta, m_phTask ) ;

	//
	// Atomic update of MemoryConsumption
	//
	InterlockedExchangeAdd ( &m_lMemoryConsumption, lDelta ) ;

	return hRes ;
}


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// CWmiFinalizer::Configure
// ------------------------
//
// Allows decoupled & fast-track configuration with no thread switches.
// Also will be used to configure cache operations and the likes.
//
// Parameters
// ----------
// uConfigID	- One of the values defined in WMI_FNLZR_CFG_TYPE
// pConfigVal	- Additional information needed

// Return codes
// ------------
// WBEM_E_INVALID_OPERATION - try to do the same thing more than once, or
//								trying to change something already set up
// WBEM_E_INVALID_PARAMETER - Configuration parameter we do not know about
//								was passed in
// WBEM_NO_ERROR			 - Everything went well
//
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
STDMETHODIMP CWmiFinalizer::Configure(
    /*[in]*/ ULONG uConfigID,
    /*[in]*/ ULONG uValue
    )
{
	switch (uConfigID)
	{

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Do they want us to fast track?
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		case WMI_FNLZR_FLAG_FAST_TRACK:
		{
			if (m_uForwardingType != forwarding_type_none)
				RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::Configure called more than once!"), WBEM_E_INVALID_OPERATION);
			m_uForwardingType = forwarding_type_fast;
			break;
		}
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Do they want us to decouple?
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		case WMI_FNLZR_FLAG_DECOUPLED:
		{
			if (m_uForwardingType != forwarding_type_none)
				RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::Configure called more than once!"), WBEM_E_INVALID_OPERATION);
			m_uForwardingType = forwarding_type_decoupled;

			DWORD dwThreadId = 0;

			break;
		}

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Do they want us to do anything else? If so, assert
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		default:
			RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::Configure - invalid parameter uConfigID"), WBEM_E_INVALID_PARAMETER);
	}
	
	return WBEM_NO_ERROR;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// CWmiFinalizer::SetTaskHandle
// ----------------------------
//
// Task handle has user-specific stuff.  Finalizer just
// passes this through to _IWmiArbitrator::CheckTask.  It should only ever
// be called once
//
// Parameters
// ----------
// phTask	- Pointer to the task handle

// Return codes
// ------------
// WBEM_E_INVALID_OPERATION - try to do the same call more than once
// WBEM_E_INVALID_PARAMETER - Passed in parameter is invalid
// WBEM_NO_ERROR			- Everything went well
//
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
STDMETHODIMP CWmiFinalizer::SetTaskHandle(
    _IWmiCoreHandle *phTask
    )
{
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Parameter validation
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if (m_phTask != NULL)
		RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::SetTaskHandle - already have m_phTask"),  WBEM_E_INVALID_OPERATION);
	if (phTask == NULL)
		RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::SetTaskHandle - phTask == NULL"),  WBEM_E_INVALID_PARAMETER);

	m_bTaskInitialized = TRUE ;

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Assign the task and AddRef it
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	{
		CInCritSec lock(&m_arbitratorCS);
		m_phTask = phTask;
		m_phTask->AddRef();
	}

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Register the finalizer with the arbitrator
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	{
		CInCritSec lock(&m_arbitratorCS);
		if (m_pArbitrator)
		{
			m_pArbitrator->RegisterArbitratee(0, m_phTask, this);
		}
	}
	
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// From the task, we can now see exactly what type of operation we are doing.
	// Get the operation type (SYNC/SEMISYNC/ASYNC) to avoid having to get it every time
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	CWmiTask *pTsk = (CWmiTask *) m_phTask;
	ULONG ulTaskType = pTsk->GetTaskType();
	if ( (ulTaskType & WMICORE_TASK_TYPE_SYNC) )
	{
		m_ulOperationType = Operation_Type_Sync;
	}
	else if ( (ulTaskType & WMICORE_TASK_TYPE_SEMISYNC) )
	{
		m_ulOperationType = Operation_Type_Semisync;
	}
	else if ( (ulTaskType & WMICORE_TASK_TYPE_ASYNC) )
	{
		m_ulOperationType = Operation_Type_Async;
	}
	else
		RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::SetTaskHandle - Invalid operation type"),  WBEM_E_FAILED );
		
	return WBEM_NO_ERROR;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// CWmiFinalizer::SetDestinationSink
// ---------------------------------
//
// For async operations, therefore if the forwarding type is not set to
// decoupled, this will fail.  If there are any items outstanding,
// this will also trigger them to be started
//
// Parameters
// ----------
// uFlags	- extra flags - initially has to be 0
// pSink	- pointer to the created destination sink
//
// Return codes
// ------------
// WBEM_E_INVALID_OPERATION - try to do the same call more than once
// WBEM_E_INVALID_PARAMETER - Passed in parameter is invalid
// WBEM_NO_ERROR			- Everything went well
//
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
STDMETHODIMP CWmiFinalizer::SetDestinationSink(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ REFIID riid,
        /*[in], iid_is(riid)]*/ LPVOID pSink
    )
{

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Parameter validation
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if (m_pDestSink != NULL)
		RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::SetDestinationSink - m_pDestSink != NULL"), WBEM_E_INVALID_OPERATION);
	if ((pSink == NULL) || (uFlags != 0))
		RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::SetDestinationSink - ((pSink == NULL) || (uFlags != 0))"), WBEM_E_INVALID_PARAMETER);
	if (m_uForwardingType == forwarding_type_none)
		RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::SetDestinationSink - m_uForwardingType == forwarding_type_none"), WBEM_E_INVALID_OPERATION);

	if ((riid != IID_IWbemObjectSink) && (riid != IID_IWbemObjectSinkEx))
		RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::SetDestinationSink - iid myst be IID_IWbemObjectSink or IID_IWbemObjectSinkEx"), WBEM_E_INVALID_PARAMETER);

	m_iidDestSink = riid;

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Set the destination sink, AddRef it and set the impersonation level
	// to identity
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	{
		CInCritSec lock(&m_destCS);
		m_pDestSink = (IWbemObjectSink*)pSink;
		m_pDestSink->AddRef();
		SetSinkToIdentity (m_pDestSink);
	}

	return WBEM_NO_ERROR;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// The callback called during final Release(); Set() is called with the
// task handle, followed by SetStatus()
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
STDMETHODIMP CWmiFinalizer::SetSelfDestructCallback(
    /*[in]*/ ULONG uFlags,
    /*[in]*/ IWbemObjectSinkEx *pSink
    )
{
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Parameter validation
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if (m_pDestructSink != NULL)
		RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::SetSelfDestructCallback - m_pDestructSink != NULL"), WBEM_E_INVALID_OPERATION);
	if ((pSink == NULL) || (uFlags != 0))
		RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::SetSelfDestructCallback - ((pSink == NULL) || (uFlags != 0))"), WBEM_E_INVALID_PARAMETER);

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Set and AddRef
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	m_pDestructSink = pSink;
	m_pDestructSink->AddRef();

	return WBEM_NO_ERROR;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// STDMETHODIMP CWmiFinalizer::GetStatus(
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
STDMETHODIMP CWmiFinalizer::GetStatus(
    ULONG *pFlags
    )
{
	*pFlags = m_ulStatus;
	return WBEM_NO_ERROR;
}

//***************************************************************************
//
// CWmiFinalizer::NewInboundSink
// -----------------------------
//
// Returns a sink to the caller.  This sink is used to indicate result sets
// back to the client.
//
// Parameters
// ----------
// uFlags	- Additional flags.  Currently 0 is only valid value.
// pSink	- Pointer to variable which will get the returned inbound sink.
//				It is this sink that allows the caller to send result sets.
//
// Return codes
// ------------
// WBEM_E_OUT_OF_MEMORY		- Failed to create the finaliser sink because of an
//								out of memory situation
// WBEM_E_INVALID_PARAMETER	- Invalid parameters passed to method
// WBEM_NO_ERROR			- Everything completed successfully
//***************************************************************************
STDMETHODIMP CWmiFinalizer::NewInboundSink(
    /*[in]*/  ULONG uFlags,
    /*[out]*/ IWbemObjectSinkEx **pSink
    )
{
	if ((pSink == NULL) || (uFlags != 0))
		RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::NewInboundSink - ((pSink == NULL) || (uFlags != 0))!"), WBEM_E_INVALID_PARAMETER);

	if (m_inboundSinks.Size())
		RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::NewInboundSink - Multiple inbound sinks not yet implemented!!"), E_NOTIMPL);

	CWmiFinalizerInboundSink *pNewSink = new CWmiFinalizerInboundSink(this);
	if (pNewSink == NULL)
		return WBEM_E_OUT_OF_MEMORY;

    pNewSink->AddRef(); // Required to return a positive ref count on a new object

	CInCritSec autoLock(&m_cs);

	int nRet = m_inboundSinks.Add(pNewSink);
	if (nRet != CFlexArray::no_error)
	{
		pNewSink->Release();
		if (nRet == CFlexArray::out_of_memory)
			return WBEM_E_OUT_OF_MEMORY;
		else
			RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::NewInboundSink - Failed to add sink to array!"), WBEM_E_FAILED);
	}
	else
	{
		pNewSink->InternalAddRef();
	}

	*pSink = pNewSink;
	
	return WBEM_NO_ERROR;
}

//***************************************************************************
//
// Allows merging another Finalizer, _IWmiCache, etc.
// For sorting, we will create a sorted _IWmiCache and merge it in later when
// the sort is completed.
//
//***************************************************************************
STDMETHODIMP CWmiFinalizer::Merge(
    /*[in]*/ ULONG uFlags,
    /*[in]*/ REFIID riid,
    /*[in]*/ LPVOID pObj
    )
{
	RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::Merge - Not implemented!"), E_NOTIMPL);
}

// For setting, getting objects

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiFinalizer::SetResultObject(
    /*[in]*/ ULONG uFlags,
    /*[in]*/ REFIID riid,
    /*[in]*/ LPVOID pObj
    )
{
	//No one is calling this!  All objects are getting in through a call to Indicate,
	//or Set, which are both just forwards from the InboundSink we pass out.
	RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::Merge - Not implemented!"), E_NOTIMPL);
}


//***************************************************************************
//
// Support _IWmiObject, IWbemClassObject, etc.
// IEnumWbemClassObject
// _IWmiCache
//
//***************************************************************************
STDMETHODIMP CWmiFinalizer::GetResultObject(
    /*[in]*/ ULONG uFlags,
    /*[in]*/ REFIID riid,
    /*[out, iid_is(riid)]*/ LPVOID *ppObj
    )
{
	// uFlags can be non-zero iff the requested interface is an enumerator
	if (uFlags != 0 && riid != IID_IEnumWbemClassObject)
		RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::GetResultObject - uFlags != 0, non enum interface!"), WBEM_E_INVALID_PARAMETER);


	if (riid == IID_IEnumWbemClassObject)
	{
		//They want us to return them an enumerator object!
		//We only allow 1 to be returned!
		//if (m_pEnumerator != NULL)
		/*if ( m_enumerators.Size ( ) > 1 )
			RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::GetResultObject - Asked for more than 1 enumerator!"), WBEM_E_INVALID_OPERATION);
		if (m_pDestSink != NULL)
			RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::GetResultObject - Asked for enumerator when there is a destination sink!"), WBEM_E_INVALID_OPERATION);*/

		//If forward-only is set we should not let the result set be restartable.
		if (!(uFlags & WBEM_FLAG_FORWARD_ONLY))
			m_bRestartable = true;

		//m_uDeliveryType = delivery_type_pull;
        CWmiFinalizerEnumerator* pEnum = NULL ;
		try 
        {
			//
			// I'm using the uFlags as a means of passing the current object position
			//
			pEnum = new CWmiFinalizerEnumerator(this);
		} 
		catch (...) // status_no_memory
		{
	        ExceptionCounter c;		
    		//m_pEnumerator = NULL;
		}
		if (pEnum == NULL)
			return WBEM_E_OUT_OF_MEMORY;
		else
			pEnum->InternalAddRef();


		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Make sure nasty client does not crash us
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		try
		{
			*ppObj = pEnum;
		}
		catch (...) // ppObj is an untrusted param
		{
			ExceptionCounter c;		
			pEnum->InternalRelease();
			return WBEM_E_INVALID_PARAMETER;
		}

		{
			CInCritSec lock( &m_cs ) ;

			//
			// Lets add the enumerator to the list of enumerators
			// associated with this finalizer.
			//
			int nRet = m_enumerators.Add ( pEnum ) ;
			if ( nRet != CFlexArray::no_error )
			{
				pEnum->InternalRelease ( ) ;
				return WBEM_E_OUT_OF_MEMORY;
			}		
		}

		pEnum->AddRef();
		return WBEM_NO_ERROR;
	}

	//Get the next object we have cached.
	if ((riid == IID_IWbemClassObject) || (riid == IID__IWmiObject))
	{
		if (m_pDestSink != NULL)
		{
			RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::GetResultObject - Cannot get an object when there is a destination sink!"), WBEM_E_INVALID_OPERATION);
		}
		if (m_bSetStatusConsumed)
			return WBEM_E_NOT_FOUND;

		CWmiFinalizerObj *pFinalizerObj = NULL;
        bool bFinished = false;
        HRESULT hRes = WBEM_E_NOT_FOUND;
        while (!bFinished)
        {
		    hRes = GetNextObject(&pFinalizerObj);
		    if (FAILED(hRes))
			    return hRes;

		    else if (hRes == WBEM_S_FALSE)
			    return WBEM_E_NOT_FOUND;

		    if (pFinalizerObj->m_objectType == CWmiFinalizerObj::object)
		    {
			    if (ppObj)
			    {
					// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					// Make sure nasty client does not crash us
					// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					try
					{
						*ppObj = pFinalizerObj->m_pObj;
					}
					catch (...) // untrusted param
					{
				        ExceptionCounter c;					
						return WBEM_E_INVALID_PARAMETER;
					}

				    if (pFinalizerObj->m_pObj)
					    pFinalizerObj->m_pObj->AddRef();
			    }
                bFinished = true;
		    }
		    else if ((pFinalizerObj->m_objectType == CWmiFinalizerObj::status) && (pFinalizerObj->m_lFlags == WBEM_STATUS_COMPLETE))
		    {
			    m_bSetStatusConsumed = true;
			    hRes = WBEM_E_NOT_FOUND;
                bFinished = true;
		    }
            else if (pFinalizerObj->m_objectType == CWmiFinalizerObj::status)
            {
                //This is a non-completion status message!  We most certainly have not finished yet!
            }
		    delete pFinalizerObj;
        }

		return hRes;
	}

	if ((riid == IID_IWbemCallResult) || (riid == IID_IWbemCallResultEx))
	{
		if (m_pCallResult == NULL)
		{
			m_pCallResult = new CWmiFinalizerCallResult(this);
			if (m_pCallResult == NULL)
				return WBEM_E_OUT_OF_MEMORY;
			else
				m_pCallResult->InternalAddRef () ;
		}

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Make sure nasty client does not crash us
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		try
		{
			m_pCallResult->AddRef();
			*ppObj = m_pCallResult;
		}
		catch (...) // untrusted param
		{
			ExceptionCounter c;		
			m_pCallResult->Release ();
			m_pCallResult->InternalRelease () ;
			m_pCallResult = NULL;
			return WBEM_E_INVALID_PARAMETER;
		}
	
		return WBEM_S_NO_ERROR;
	}

	RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::GetResultObject - Unknown object IID requested!"), WBEM_E_INVALID_PARAMETER);
}

// For status-only operations

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiFinalizer::SetOperationResult(
    /*[in]*/ ULONG uFlags,
    /*[in]*/ HRESULT hRes
    )
{
	if (uFlags != 0)
		RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::SetOperationResult - uFlags != 0!"), WBEM_E_INVALID_PARAMETER);

	if ( m_hresFinalResult != -1 ) 
	{
		if ( hRes != WBEM_E_CALL_CANCELLED )
		{
			return WBEM_S_NO_ERROR ;
		}
	}

	if ( hRes == WBEM_E_CALL_CANCELLED_CLIENT )
	{
		m_hresFinalResult = hRes = WBEM_E_CALL_CANCELLED ;
	}
	else if ( hRes != WBEM_E_CALL_CANCELLED )
	{
		m_hresFinalResult = hRes ;
	}

	HRESULT hResCancel = WBEM_NO_ERROR ;

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Special case for cancellations. Iff its an async operation. Otherwise,
	// we might mess up for sync/semi sync
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if ( ( hRes == WBEM_E_CALL_CANCELLED ) && ( m_ulOperationType == Operation_Type_Async ) )
	{
		hResCancel = CancelCall();
	}

	SetEvent(m_hResultReceived);

	return hResCancel ;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiFinalizer::GetOperationResult(
    /*[in]*/ ULONG uFlags,
	/*[in]*/ ULONG uTimeout,
    /*[out]*/ HRESULT *phRes
	)
{
	if (uFlags != 0)
		RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::GetOperationResult - uFlags != 0!"), WBEM_E_INVALID_PARAMETER);

	HRESULT hr = WaitForCompletion(uTimeout);

	if (hr == WBEM_S_NO_ERROR)
    {
		*phRes = m_hresFinalResult;
		if ( FAILED ( m_hresFinalResult ) )
		{
			m_pCallResult->SetErrorInfo ( );
		}	
		
		CancelTaskInternal();
		m_hStatus = NoError;
    }
	
	return hr;
}

//***************************************************************************
// STDMETHODIMP CWmiFinalizer::CancelTask(
//***************************************************************************
STDMETHODIMP CWmiFinalizer::CancelTask(
    /*[in]*/ ULONG uFlags
	)
{
	if (uFlags != 0)
		RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::CancelTask - uFlags != 0!"), WBEM_E_INVALID_PARAMETER);

	return CancelTaskInternal ( );
}



//***************************************************************************
//
//***************************************************************************
HRESULT CWmiFinalizer::WaitForCompletion(ULONG uTimeout)
{
	DWORD dwRet =  CCoreQueue :: QueueWaitForSingleObject(m_hResultReceived, uTimeout);
	if (dwRet == WAIT_OBJECT_0)
	{
		return WBEM_S_NO_ERROR;
	}
	else if ((dwRet == WAIT_FAILED) ||
			 (dwRet == WAIT_ABANDONED))
	{
		return WBEM_E_FAILED;
	}
	else
	{
		return WBEM_S_TIMEDOUT;
	}
}

//***************************************************************************
//
//***************************************************************************
HRESULT CWmiFinalizer::Reset(
	)
{
	if (m_bRestartable)
	{
		/*m_uCurObjectPosition = 0;
		m_bSetStatusConsumed = false;*/
		return WBEM_NO_ERROR;
	}
	else
		return WBEM_E_INVALID_OPERATION;
}

//***************************************************************************
//
//***************************************************************************

IWbemObjectSink* CWmiFinalizer::ReturnProtectedDestinationSink ( )
{
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Do we have a valid object sink?
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	IWbemObjectSink* pTmp = NULL;
	{
		CInCritSec lock(&m_destCS);
		if ( m_pDestSink==NULL )
		{
			return NULL;
		}
		else
		{
			pTmp = m_pDestSink;
			pTmp->AddRef();
		}
	}
	return pTmp;
}


//***************************************************************************
//
//***************************************************************************
DWORD WINAPI CWmiFinalizer::ThreadBootstrap( PVOID pParam )
{
//	char buff[100];
//	sprintf(buff, "thread this pointer = 0x%p\n", pParam);
//	OutputDebugString(buff);
	return ((CWmiFinalizer*)pParam)->AsyncDeliveryProcessor();
}


//***************************************************************************
// 
//***************************************************************************
HRESULT CWmiFinalizer::BootstrapDeliveryThread  ( )
{
	BOOL bRes;
	HRESULT hRes = WBEM_S_NO_ERROR;
	
	AddRef();																					// Need to AddRef Finalizer for the delivery thread
	
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Native Win2k thread dispatching
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	bRes = QueueUserWorkItem ( ThreadBootstrap, this, WT_EXECUTEDEFAULT );
	if ( !bRes )
	{
		Release ();
		hRes = WBEM_E_FAILED;
	}
	
	return hRes;
}




//***************************************************************************
//
//***************************************************************************
ULONG CWmiFinalizer::AsyncDeliveryProcessor()
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	BOOL	bKeepDelivering = TRUE;


	m_enumBatchStatus = FinalizerBatch_NoError;

	RevertToSelf ( );

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// First we tell the arbitrator about the delivery thread
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	{
		CInCritSec lock(&m_arbitratorCS);
		if (m_pArbitrator)
		{
			hRes = m_pArbitrator->RegisterThreadForTask(m_phTask);
			if (hRes == WBEM_E_QUOTA_VIOLATION)
			{
				//TODO: WHAT HAPPENS HERE?
			}
		}
	}

	
	while ( bKeepDelivering )
	{

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// First off, have we been cancelled?
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		if ( m_bCancelledCall )
		{
			DeliverSingleObjFromQueue ( );
			bKeepDelivering = FALSE;
			continue;
		}


		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Next, we build the transmit buffer
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		hRes = BuildTransmitBuffer		 ( );

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// BuildTransmitBuffer will return WBEM_S_FALSE if the batch immediately hit a 
		// status message. 
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		if ( hRes != WBEM_E_FAILED )
		{
			// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			// Next, deliver the batch of objects
			// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			DeliverBatch ( );
		}


		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// If we have a status message to deliver do so now
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		if ( m_enumBatchStatus == FinalizerBatch_StatusMsg )
		{
			DeliverSingleObjFromQueue ( );
		}
			

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// If we have a status complete message we should keep building the batch and 
		// delivering until done
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		if ( m_bSetStatusEnqueued && m_objects.Size() )
			continue;

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// We could have another batch to deliver by now. Check
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		else if ( m_ulQueueSize < g_ulMaxBatchSize )
			bKeepDelivering = FALSE;

		
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Make sure we're properly synchronized with the inbound threads
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		CInCritSec cs(&m_cs);
		{
			if ( !m_bSetStatusEnqueued )
			{
				bKeepDelivering = FALSE;
				m_lCurrentlyDelivering = FALSE;
			}
			else
			{
				bKeepDelivering = TRUE;
			}
		}
	}

	
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Tell the arbitrator that the thread is done
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	{
		CInCritSec lock(&m_arbitratorCS);
		if (m_pArbitrator)
		{
			m_pArbitrator->UnregisterThreadForTask(m_phTask);						// Since thread is going away, tell arbitrator about this
		}
	}

	Release();
	return 0;
}




//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizer::GetNextObject(CWmiFinalizerObj **ppObj)
{
	if (m_uCurObjectPosition >= (ULONG)m_objects.Size())
		return WBEM_S_FALSE;

	CInCritSec cs(&m_cs);

	CWmiFinalizerObj *pStorageObject = (CWmiFinalizerObj*)m_objects[m_uCurObjectPosition];

	if (m_bRestartable)
	{
		//We have to hold on to results, so increment cursor position...
		m_uCurObjectPosition++;

		*ppObj = new CWmiFinalizerObj(*pStorageObject);

		if (*ppObj == NULL)
			return WBEM_E_OUT_OF_MEMORY;
		//ReportMemoryUsage ( 0, (*ppObj)->m_uSize ) ;
	}
	else
	{
		//We are not restartable, therefore we need to release everything...
		m_objects.RemoveAt(0);
		*ppObj = pStorageObject;
		//ADDBACK: ReportMemoryUsage ( 0, -((*ppObj)->m_uSize) ) ;
//		printf("Returning object 0x%p from object list\n", pStorageObject);
	}


	return WBEM_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizer::UnregisterInboundSink(CWmiFinalizerInboundSink *pSink)
{
	// Use m_cs lock for this
	CInCritSec lock(&m_cs);
	
	for (int i = 0; i != m_inboundSinks.Size(); i++)
	{
		if (m_inboundSinks[i] == pSink)
		{
			pSink->InternalRelease () ;

			m_inboundSinks.RemoveAt(i);

			if (m_inboundSinks.Size() == 0)
				TriggerShutdown();

			return WBEM_NO_ERROR;
		}
	}

	RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::UnregisterInboundSink - Unregistering Inbound Sink that we could not find!"), WBEM_E_NOT_FOUND);
}




/*
//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizer::SendErrorObject()
{
	if ( m_pErrorObject )
	{
		IWbemObjectSink* pTmp;
		{
			CInCritSec lock(&m_destCS);
			if ( m_pDestSink==NULL )
				return WBEM_NO_ERROR;
			pTmp = m_pDestSink;
			pTmp->AddRef();
		}
		CAutoRelease myReleaseMe(pTmp);
		pTmp->SetStatus(0, this->m_hresFinalResult, L"todo!", m_pErrorObject);
	}

	return WBEM_NO_ERROR;
}
*/


//***************************************************************************
//
//***************************************************************************
HRESULT CWmiFinalizer::Indicate(
    /*[in]*/ long lObjectCount,
    /*[in, size_is(lObjectCount)]*/
        IWbemClassObject** apObjArray
    )
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	
	if ( m_bCancelledCall )
	{
		return WBEM_E_CALL_CANCELLED;
	}

	{
		CInCritSec lock(&m_arbitratorCS);
		if ( m_bSetStatusCalled )
		{
			return WBEM_E_INVALID_OPERATION;
		}
	}

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// First check the array for NULL objects. Return INVALID_OBJECT if
	// array contains a NULL object
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	for (long x = 0; x != lObjectCount; x++)
	{
		if ( apObjArray[x] == NULL )
			return WBEM_E_INVALID_OBJECT;
	}

	
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Are we fast tracking and async request?
	// ESS brutally tells us to deliver on the
	// same thread and do no batching
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if ( (m_uForwardingType == forwarding_type_fast) && (m_ulOperationType == Operation_Type_Async))
	{
		IWbemObjectSink* pTmp = ReturnProtectedDestinationSink  ( );
		if ( !pTmp )
		{
			return WBEM_E_FAILED;
		}
		CAutoRelease myReleaseMe(pTmp);
	
		hRes = DoIndicate ( pTmp, lObjectCount, apObjArray );

		// Client can also tell us to cancel a call by returning WBEM_E_CALL_CANCELLED from Indicate
		// We also want to cancel the call if the client is taking way too long to return
		if ( FAILED (hRes) || m_bCancelledCall == TRUE || m_bNaughtyClient == TRUE )
		{
			if ( hRes == WBEM_E_CALL_CANCELLED || m_bCancelledCall )
			{
				DoSetStatus ( pTmp, WBEM_STATUS_COMPLETE, WBEM_E_CALL_CANCELLED, 0, 0 );
			}
			hRes = WBEM_E_CALL_CANCELLED;

			myReleaseMe.Release ( ) ;

			ReleaseDestinationSink ( ) ;
			CancelCall();
		}
	}
	
	else
	{
		for (long lIndex = 0; lIndex != lObjectCount; lIndex++)
		{
			if ( apObjArray[lIndex] )
			{
				// THIS FIX IS TEMP. REMOVED PENDING DCOM TEAM ANSWERS!!!
				// If we are trying to indicate an object bigger than max size do the following:
				// 1. SetStatus to client WBEM_E_INVALID_OBJECT
				// 2. Return invalid object to caller
				/*if ( pAlias->GetBlockLength() > MAX_SINGLE_OBJECT_SIZE )
				{
					SetStatus ( 0, WBEM_E_INVALID_OBJECT, 0, 0 );
					return WBEM_E_INVALID_OBJECT;
				}*/
				CWmiFinalizerObj *pFinalizerObj = new CWmiFinalizerObj(apObjArray[lIndex], this);
				if (pFinalizerObj == NULL)
					return WBEM_E_OUT_OF_MEMORY;

				HRESULT hr = QueueOperation(pFinalizerObj);
				if (FAILED(hr))
				{
					return hr;
				}
			}
		}
	}
	return hRes;
}

//***************************************************************************
//
//***************************************************************************
HRESULT CWmiFinalizer::Set(
    /*[in]*/ long lFlags,
    /*[in]*/ REFIID riid,
    /*[in, iid_is(riid)]*/ void *pComObject
    )
{
	CWmiFinalizerObj *pFinalizerObj = new CWmiFinalizerObj(lFlags, riid, pComObject);
	if (pFinalizerObj == NULL)
		return WBEM_E_OUT_OF_MEMORY;

	return QueueOperation(pFinalizerObj);
}

//***************************************************************************
//
//***************************************************************************
HRESULT CWmiFinalizer::SetStatus(
    /*[in]*/ long lFlags,
    /*[in]*/ HRESULT hResult,
    /*[in]*/ BSTR strParam,
    /*[in]*/ IWbemClassObject* pObjParam
    )
{

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// If the operation has been cancelled, we should not accept another call
	// WBEM_E_CALL_CANCELLED
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	if ( m_bCancelledCall )
	{
		return WBEM_E_CALL_CANCELLED;
	}	

	{
		CInCritSec lock(&m_arbitratorCS);
		if ( m_bSetStatusCalled && ( lFlags == WBEM_STATUS_COMPLETE ) )
		{
			return WBEM_E_INVALID_OPERATION;
		}
		else if ( lFlags == WBEM_STATUS_COMPLETE )
		{
			m_bSetStatusCalled = true ;
		}
	}
	
	//If this is a final call, we need to record it.
	if (lFlags == WBEM_STATUS_COMPLETE )
	{
		if (m_pCallResult == NULL)
		{
			m_pCallResult = new CWmiFinalizerCallResult(this);
			if (m_pCallResult == NULL)
				return WBEM_E_OUT_OF_MEMORY;

			m_pCallResult->InternalAddRef () ;
		}
		m_pCallResult->SetStatus(lFlags, hResult, strParam, pObjParam);

		//m_pErrorObject = pObjParam;
	}


	HRESULT ourhres = WBEM_E_FAILED;
	// Special case for cancellations
	if ( hResult == WBEM_E_CALL_CANCELLED )
	{
		ourhres = CancelCall() ;
		//CancelTaskInternal ( ) ;
	}

	else
	{
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Once again, we have to special case ESS! Lack of trust????
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		if ( (m_uForwardingType == forwarding_type_fast) && (m_ulOperationType == Operation_Type_Async))
		{
			// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			// Do we have a valid object sink?
			// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			IWbemObjectSink* pTmp = ReturnProtectedDestinationSink  ( );
			CAutoRelease myReleaseMe(pTmp);
			
			if ( pTmp )
			{
				ourhres = DoSetStatus ( pTmp, lFlags, hResult, strParam, pObjParam );
				if (lFlags == WBEM_STATUS_COMPLETE || FAILED ( ourhres ) || m_bCancelledCall == TRUE || m_bNaughtyClient == TRUE ) 
				{
					NotifyAllEnumeratorsOfCompletion ( ) ;
					//SetEvent ( m_hNewThreadRequests );								// Make sure we wake up any potential clients stuck in PullObjects
					SetOperationResult(0, hResult);
					{
						CInCritSec lock(&m_destCS);
						if ( m_pDestSink )
						{
							ReleaseDestinationSink ( ) ;
							m_bSetStatusConsumed = true;
							UpdateStatus ( WMI_FNLZR_STATE_CLIENT_COMPLETE );
						}
					}
					CancelTaskInternal ( );					
					if ( FAILED ( ourhres ) || m_bCancelledCall == TRUE || m_bNaughtyClient == TRUE )
					{
						ourhres = WBEM_E_CALL_CANCELLED ;
					}
				}
			}
		}

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// No special casing needed.
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		else
		{
			//Send the request to the user...
			CWmiFinalizerObj *pObj = new CWmiFinalizerObj(lFlags, hResult, strParam, pObjParam);
			if (pObj == NULL)
			{
				IWbemObjectSink* pTmp = ReturnProtectedDestinationSink  ( );
				CAutoRelease myReleaseMe(pTmp);
				if ( pTmp )
				{
					DoSetStatus ( pTmp, WBEM_STATUS_COMPLETE, WBEM_E_OUT_OF_MEMORY, 0, 0 ) ;
				}
				return WBEM_E_OUT_OF_MEMORY;
			}

			ourhres = QueueOperation(pObj);

			if (lFlags == WBEM_STATUS_COMPLETE)
			{
				SetOperationResult(0, hResult);
				//SetEvent ( m_hNewThreadRequests );								// Make sure we wake up any potential clients stuck in PullObjects
				NotifyAllEnumeratorsOfCompletion ( ) ;

				//
				// Lock the task 
				//
				CWmiTask* pTask = NULL ;
				{
					CInCritSec lock(&m_arbitratorCS);
					if ( m_phTask )
					{
						pTask = (CWmiTask*) m_phTask ;
						pTask->AddRef ( ) ;
					}
				}
				CReleaseMe _r ( pTask ) ;
				if ( pTask )
				{
					pTask->SetTaskResult ( hResult ) ;
				}
				((CWmiArbitrator*) m_pArbitrator)->UnregisterTaskForEntryThrottling ( (CWmiTask*) m_phTask ) ;
				//CancelTaskInternal ( ) ;
			}
		}

	}
	return ourhres;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizer::QueueOperation(CWmiFinalizerObj *pObj)
{
	LONG lDelta = 0;
	HRESULT hRes = WBEM_S_NO_ERROR;

	CCheckedInCritSec cs ( &m_cs ) ;
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Update total object size
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if (pObj->m_objectType == CWmiFinalizerObj::object)		
	{
		CWbemObject* pObjTmp = (CWbemObject*) pObj -> m_pObj;
		m_ulQueueSize += pObjTmp -> GetBlockLength();
	}

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// If we get a WBEM_E_CALL_CANCELLED status message, prioritize
	// the handling of this. Needed for fast shutdown.
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if ( (pObj->m_objectType == CWmiFinalizerObj::status) && FAILED (pObj->m_hRes) )
	{
		m_bSetStatusWithError = TRUE ;
		int nRet = m_objects.InsertAt ( 0, pObj );
		if ( nRet != CFlexArray::no_error )
		{
			return WBEM_E_OUT_OF_MEMORY;
		}
	}

	else
	{
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Normal Add object to queue
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		int nRet = m_objects.Add(pObj);
		if (nRet != CFlexArray::no_error)
		{
			delete pObj;
			if (nRet == CFlexArray::out_of_memory)
				return WBEM_E_OUT_OF_MEMORY;
			else
				RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::QueueOperation - Failed to add object to table!"), WBEM_E_FAILED);
		}
	}
	
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// First we check with the arbitrator what it tells us about
	// current limits. Make sure we call ReportMemoryUsage since
	// we're only interested in what it would potentially have done.
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	HRESULT hArb = WBEM_S_ARB_NOTHROTTLING;
	lDelta = pObj->m_uSize;
	if ( pObj->m_objectType == CWmiFinalizerObj::object )
	{
		//hArb = ReportMemoryUsage ( 0, 0 ) ;
	}
	
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Are we decoupled, if so we need to analyze the current batch
	// and make decisions on delivery. Need to once again special
	// case ESS.
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if ( m_uForwardingType == forwarding_type_decoupled || ( m_uForwardingType == forwarding_type_fast && m_ulOperationType == Operation_Type_Async ) )
	{
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// What did the arbitrator tell us about our situation?
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		if ( pObj->m_hArb != WBEM_S_ARB_NOTHROTTLING )
		{
			// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			// Arbitrator told us that we either were about to be
			// cancelled or throttled. MAYDAY! MAYDAY! Flush our 
			// delivery buffers!!!!
			// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			if ( m_lCurrentlyDelivering == FALSE || m_lCurrentlyCancelling == TRUE )
			{
				m_lCurrentlyDelivering = TRUE;
				BootstrapDeliveryThread  ( );									// Kick of the delivery thread since we're decoupled
			}

			cs.Leave ( ) ;
			hArb = m_pArbitrator->Throttle ( 0, m_phTask );
			if ( hArb == WBEM_E_ARB_CANCEL )
			{
				CancelCall ( ) ;
			}
		}
		
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// If we are decoupled and get a Status message we should deliver
		// the batch and set the status
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		else if ( (pObj->m_objectType == CWmiFinalizerObj::status) )
		{
			if ( pObj->m_lFlags == WBEM_STATUS_COMPLETE )
			{
				m_bSetStatusEnqueued = TRUE;
			}
			
			if ( m_lCurrentlyDelivering == FALSE || m_lCurrentlyCancelling == TRUE )
			{
				m_lCurrentlyDelivering = TRUE;
				BootstrapDeliveryThread  ( );									// Kick of the delivery thread since we're decoupled
			}
		}


		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Delivery needs to be decoupled
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		else if ( (m_ulQueueSize > g_ulMaxBatchSize) )
		{
			if ( m_lCurrentlyDelivering == FALSE )
			{
				m_lCurrentlyDelivering = TRUE;
				BootstrapDeliveryThread  ( );									// Kick of the delivery thread since we're decoupled
			}
		}
	}

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Otherwise, we wake up any potential clients waiting in 
	// PullObjects
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	else if ( m_uForwardingType == forwarding_type_fast )
	{
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// We dont want to wake up the client unless we have the
		// number of objects he/she requested OR a setstatus has
		// come through [CWmiFinalizer::SetStatus]
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		if ( (pObj->m_objectType == CWmiFinalizerObj::object) )
		{
			for ( int i = 0; i < m_enumerators.Size ( ); i++ )
			{
				CWmiFinalizerEnumerator* pEnum = (CWmiFinalizerEnumerator*) m_enumerators[i] ;
				if ( ( pEnum->m_ulSemisyncWakeupCall != 0 ) && ( m_objects.Size() >= ( pEnum->m_ulSemisyncWakeupCall + pEnum->m_uCurObjectPosition ) ) )
				{
					if ( pEnum->m_hWaitOnResultSet )
					{
						SetEvent ( pEnum->m_hWaitOnResultSet );
					}
					pEnum->m_ulSemisyncWakeupCall = 0;
				}
			}
		}
		else if ( (pObj->m_objectType == CWmiFinalizerObj::status) )
		{
			NotifyAllEnumeratorsOfCompletion ( ) ;
		}
		
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Now, lets throttle this thread since we have no control
		// of outbound flow
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		cs.Leave ( ) ;
		HRESULT hArb = m_pArbitrator->Throttle ( 0, m_phTask );

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// If the arbitrator returned CANCEL, we operation has been
		// cancelled and we need to stop:
		// 1. Threads potentially waiting in the enumerator
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		if ( hArb == WBEM_E_ARB_CANCEL )
		{
			cs.Leave ( ) ;
			CancelTaskInternal ( );
			cs.Enter ( ) ;

			m_hStatus = QuotaViolation;
			NotifyAllEnumeratorsOfCompletion ( ) ;
			hRes = WBEM_E_QUOTA_VIOLATION;
		}
	}
	return hRes;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizer::TriggerShutdown()
{
	if (m_uForwardingType == forwarding_type_decoupled)
	{
		//We need to queue up a shutdown request to the thread...
		CWmiFinalizerObj *pObj = new CWmiFinalizerObj(CWmiFinalizerObj::shutdown);
		if (pObj == NULL)
			return WBEM_E_OUT_OF_MEMORY;

		return QueueOperation(pObj);
	}
	else
		ShutdownFinalizer();

	return WBEM_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizer::ShutdownFinalizer()
{
	return WBEM_NO_ERROR;
}



//****************************************************************************
// BuildTransmitBuffer ( )
// ~~~~~~~~~~~~~~~~~~~~~~~
//
// Works in two phases.
// 
// 1. Quickly scans the object queue to get a count of the number of objects
// 2. Actually dequeueus the objects and builds the buffer
//			
//****************************************************************************
HRESULT CWmiFinalizer::BuildTransmitBuffer (  )
{
	HRESULT hRes = WBEM_NO_ERROR;
	ULONG   nBatchSize  = 0;
	ULONG	nBatchBytes = 0;
	ULONG	nTempAdd	= 0;
	m_ulAsyncDeliveryCount = 0;


	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Lock the object queue while building the transmit buffer
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	CInCritSec cs(&m_cs);

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// PHASE 1
	// -------
	// Quickly scan through the object queue to get an object count
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	bool bBuildingBuffer = true;
	while ( bBuildingBuffer && nTempAdd < m_objects.Size() )
	{

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// First, we peek at the object. Dont want to dequeue anything that is not
		// deliverable in this batch
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		CWmiFinalizerObj *pFinObj;
		pFinObj = (CWmiFinalizerObj*) m_objects[m_uCurObjectPosition + nTempAdd];
		
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// If we get a NULL pointer back we should stop the batch count
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		if ( pFinObj == NULL )
		{
			bBuildingBuffer = false;
			m_enumBatchStatus = FinalizerBatch_NoError;
			break;
		}

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Anything else BUT an object will break the batch count
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		if ( pFinObj->m_objectType != CWmiFinalizerObj::object )
		{
			m_enumBatchStatus = FinalizerBatch_StatusMsg;
			break;
		}

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// If we have a NULL IWbemClassObject we should stop the batch count.
		// Actaully we should yell very loudly!
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		CWbemObject* pObj = (CWbemObject*) pFinObj->m_pObj;
		if ( pObj==NULL )
			RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::BuildTransmitBuffer: Queue contains NULL object!"), WBEM_E_INVALID_OPERATION);


		ULONG ulLen = pFinObj->m_uSize;

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		// Check to see if we have reached the max batch size yet.
		// If so, we should break otherwise, update totals and continue
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
		// paulall - added check in case there is no object in queue and the current object
        //           is greater than the max size...
		if ((nBatchBytes != 0) && ((nBatchBytes+ulLen) > g_ulMaxBatchSize ))
		{
			m_enumBatchStatus = FinalizerBatch_BufferOverFlow;
			bBuildingBuffer = false;
			break;
		}

	
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		// No overflow, update the object count
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		nBatchSize++;
		nBatchBytes+=ulLen;

		nTempAdd++;
	}


	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// PHASE 2
	// -------
	// Build the actual transmit buffer
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	m_ulQueueSize -= nBatchBytes;
	m_ulAsyncDeliverySize = nBatchBytes;
	m_ulAsyncDeliveryCount = nBatchSize;


	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// If we have a batch to build, lets do it
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if ( m_ulAsyncDeliveryCount > 0 )
	{
		m_apAsyncDeliveryBuffer = new IWbemClassObject* [ m_ulAsyncDeliveryCount ];
		if ( m_apAsyncDeliveryBuffer )
		{
			// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			// Now, loop through the object queue and store the IWbemClassObject ptr 
			// in the batch
			// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
			for ( ULONG x = 0; x < m_ulAsyncDeliveryCount; x++ )
			{
				CWmiFinalizerObj *pObjTmp = 0;
				hRes = DequeueObject(&pObjTmp, NULL);
				if (FAILED(hRes) )
				{
					RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::BuildTransmitBuffer, failed to dequeue object [heap corruption]!"), WBEM_E_FAILED);
				}
				
				m_apAsyncDeliveryBuffer [ x ] = pObjTmp->m_pObj;
				m_apAsyncDeliveryBuffer [ x ] -> AddRef();
				delete pObjTmp;
			}
		}
		else
			hRes = WBEM_E_OUT_OF_MEMORY;
	}
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Otherwise, we only got a status message.
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	else
		hRes = WBEM_E_FAILED;
	
	return hRes;
}


//***************************************************************************
//
//***************************************************************************
HRESULT CWmiFinalizer::DeliverSingleObjFromQueue ( )
{
	
	HRESULT hRes = WBEM_S_NO_ERROR;
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Ensure destination sink is protected [stress bug]
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	IWbemObjectSink* pTmp = ReturnProtectedDestinationSink  ( );
	if ( !pTmp )
	{
		CancelCall ();
		return WBEM_E_CALL_CANCELLED;
	}
	CAutoRelease myReleaseMe(pTmp);
	

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Retrieve the object from the object queue
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	CWmiFinalizerObj* pObj = NULL;
	hRes = DequeueObject ( &pObj, NULL );
	if ( FAILED(hRes) || !pObj )
		hRes = WBEM_E_FAILED;

	else
	{
		if (pObj->m_objectType == CWmiFinalizerObj::object)
		{
			HANDLE hTimer;
			BOOL bStatus = CreateTimerQueueTimer ( &hTimer, NULL, ProxyThreshold, (PVOID) this, g_ulClientCallbackTimeout, 0,	WT_EXECUTEONLYONCE|WT_EXECUTEINTIMERTHREAD );
			if ( !bStatus )
			{
				DoSetStatus ( pTmp, WBEM_STATUS_COMPLETE, WBEM_E_OUT_OF_MEMORY, 0, 0 );
				delete pObj;
				return CancelCall();
			}
		
			
			if ( HasWriteOnlyProps (pObj->m_pObj) )
				ZapWriteOnlyProps (pObj->m_pObj);
			
			CWbemObject* pWbemObj = (CWbemObject*) pObj->m_pObj;
			m_ulQueueSize-=pWbemObj->GetBlockLength();

		
			IWbemClassObject** apObj = new IWbemClassObject* [1];
			if ( !apObj )
			{
				DoSetStatus ( pTmp, WBEM_STATUS_COMPLETE, WBEM_E_OUT_OF_MEMORY, 0, 0 );
				DeleteTimerQueueTimer (NULL, hTimer, INVALID_HANDLE_VALUE );	
				delete pObj;
				return CancelCall ();
			}

			apObj[0] = pObj->m_pObj;
			hRes = DoIndicate(pTmp, 1, apObj);
			delete [] apObj;
			
			// Client can also tell us to cancel a call by returning WBEM_E_CALL_CANCELLED from Indicate
			// We also want to cancel the call if the client is taking way too long to return
			if ( FAILED (hRes) || m_bCancelledCall == TRUE )
			{
				//if ( hRes == WBEM_E_CALL_CANCELLED || m_bCancelledCall || ( m_bNaughtyClient == TRUE ) )
				//{
					DoSetStatus ( pTmp, WBEM_STATUS_COMPLETE, WBEM_E_CALL_CANCELLED, 0, 0 );
				//}
				
				DeleteTimerQueueTimer (NULL, hTimer, INVALID_HANDLE_VALUE );	
				delete pObj;
				return CancelCall ();
			}

			else
				DeleteTimerQueueTimer (NULL, hTimer, INVALID_HANDLE_VALUE );
		}
		else if (pObj->m_objectType == CWmiFinalizerObj::status)
		{
			// ATTGORA: What about the handle? When do we close it?
			HANDLE hTimer;
			BOOL bStatus = CreateTimerQueueTimer ( &hTimer, NULL, ProxyThreshold, (PVOID) this, g_ulClientCallbackTimeout, 0, WT_EXECUTEONLYONCE|WT_EXECUTEINTIMERTHREAD );
			if ( !bStatus )
			{
				DoSetStatus ( pTmp, WBEM_STATUS_COMPLETE, WBEM_E_OUT_OF_MEMORY, 0, 0 );
				delete pObj;
				return CancelCall();
			}


			hRes = DoSetStatus(pTmp, pObj->m_lFlags, pObj->m_hRes, pObj->m_bStr, pObj->m_pObj);

			// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			// Client can also tell us to cancel a call by returning WBEM_E_CALL_CANCELLED 
			// from Indicate We also want to cancel the call if the client is taking way 
			// too long to return
			// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			if ( FAILED (hRes) || m_bCancelledCall == TRUE )
			{
				hRes = CancelCall ();
			}
			
			DeleteTimerQueueTimer (NULL, hTimer, INVALID_HANDLE_VALUE );
			
			if (pObj->m_lFlags == WBEM_STATUS_COMPLETE)
			{

				{
					CInCritSec lock(&m_destCS);
					if (m_pDestSink)
					{
							ReleaseDestinationSink ( ) ;
							m_bSetStatusConsumed = true;
							UpdateStatus ( WMI_FNLZR_STATE_CLIENT_COMPLETE );
					}
				}
				CancelTaskInternal();
			}
		}
		else if ((pObj->m_objectType == CWmiFinalizerObj::set) && (m_iidDestSink == IID_IWbemObjectSinkEx))
		{
			hRes = ((IWbemObjectSinkEx*)m_pDestSink)->Set(pObj->m_lFlags, pObj->m_iid, pObj->m_pvObj);
		}
		delete pObj;
	}

	return hRes;
}




//***************************************************************************
//
//***************************************************************************
HRESULT CWmiFinalizer::DeliverBatch ( )
{
	HRESULT hRes = WBEM_NO_ERROR;
	

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Ensure destination sink is protected [stress bug]
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	IWbemObjectSink* pTmp = ReturnProtectedDestinationSink  ( );
	if ( !pTmp )
	{
		ZeroAsyncDeliveryBuffer ( );
		CancelCall ();
		return WBEM_E_CALL_CANCELLED;
	}
	CAutoRelease myReleaseMe(pTmp);


	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Create a timer queue in case we need to time out the call to the client
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	HANDLE hTimer;
	BOOL bStatus = CreateTimerQueueTimer ( &hTimer, NULL, ProxyThreshold, (PVOID) this, g_ulClientCallbackTimeout, 0, WT_EXECUTEONLYONCE|WT_EXECUTEINTIMERTHREAD );
	if ( !bStatus )
	{
		DoSetStatus ( pTmp, WBEM_STATUS_COMPLETE, WBEM_E_OUT_OF_MEMORY, 0, 0 );
		ZeroAsyncDeliveryBuffer ( );
		return CancelCall();			
	}

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// If we have sensitive data, zap it.
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	for (int i = 0; i < m_ulAsyncDeliveryCount; i++)
	{
		if ( HasWriteOnlyProps (m_apAsyncDeliveryBuffer[i]) )
			ZapWriteOnlyProps (m_apAsyncDeliveryBuffer[i]);
	}


	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// DoIndicate to the client
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	hRes = DoIndicate ( pTmp, m_ulAsyncDeliveryCount, m_apAsyncDeliveryBuffer );

	
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Client can also tell us to cancel a call by returning WBEM_E_CALL_CANCELLED 
	// from Indicate We also want to cancel the call if the client is taking way 
	// too long to return
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if ( FAILED (hRes) || m_bCancelledCall == TRUE )
	{
		//if ( ( hRes == WBEM_E_CALL_CANCELLED ) || ( m_bCancelledCall == TRUE ) || ( m_bNaughtyClient == TRUE ) )
		//{
			DoSetStatus ( pTmp, WBEM_STATUS_COMPLETE, WBEM_E_CALL_CANCELLED, 0, 0 );
		//}
		hRes = CancelCall ();
		InterlockedCompareExchange ( &m_lCurrentlyCancelling, TRUE, m_lCurrentlyCancelling);
	}
	
	

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Make sure timer queue is deleted
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	DeleteTimerQueueTimer (NULL, hTimer, INVALID_HANDLE_VALUE );
	

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Clean up the async delivery buffer
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	ZeroAsyncDeliveryBuffer ( );
	
	return hRes;
}



/*
    * =====================================================================================================
	|
	| BOOL CWmiFinalizer::IsValidDestinationSink  ( )
	| -----------------------------------------------
	| 
	| Returns TRUE if we have a valid destination sink, FALSE otherwise.
	|
	|
	* =====================================================================================================
*/

BOOL CWmiFinalizer::IsValidDestinationSink  ( )
{
	BOOL bIsValidDestinationSink = FALSE ;

	CInCritSec lock(&m_destCS);
	
	if ( m_pDestSink  != NULL )
	{
		bIsValidDestinationSink = TRUE ;
	}

	return bIsValidDestinationSink  ;
}



/*
    * =====================================================================================================
	|
	| HRESULT CWmiFinalizer::NotifyClientOfCancelledCall ( )
	| ------------------------------------------------------
	| 
	| If Client issued a CancelAsync call he/she is potentially waiting to be woken up once the delivery
	| of WBEM_E_CALL_CANCELLED is completed.
	|
	|
	* =====================================================================================================
*/

HRESULT CWmiFinalizer::NotifyClientOfCancelledCall ( )
{
	HRESULT hRes = WBEM_S_NO_ERROR ;
	
	CInCritSec lock(&m_arbitratorCS);
	if ( m_hWaitForSetStatus  )	
	{
		SetEvent ( m_hWaitForSetStatus ) ;
		m_hWaitForSetStatus = NULL ;
	}
	
	return hRes ;
}



/*
    * =====================================================================================================
	|
	| HRESULT CWmiFinalizer::CancelWaitHandle ( )
	| -------------------------------------------
	| 
	| Cancels the handle the client may be waiting for in a CancelAsynCall. Clients _will_ wait for a final
	| SetStatus to be called before waking up.
	|
	|
	* =====================================================================================================
*/

HRESULT CWmiFinalizer::CancelWaitHandle ( )
{
	HRESULT hRes = WBEM_S_NO_ERROR ;
	
	CInCritSec lock(&m_arbitratorCS);
	if ( m_hWaitForSetStatus  )	
	{
		m_hWaitForSetStatus = NULL ;
	}
	
	return hRes ;
}


/*
    * =====================================================================================================
	|
	| HRESULT CWmiFinalizer::SetClientCancellationHandle ( HANDLE hCancelEvent )
	| --------------------------------------------------------------------------
	| 
	| Sets the handle that the client is waiting for in case of a CancelAsyncCall.
	|
	* =====================================================================================================
*/

HRESULT CWmiFinalizer::SetClientCancellationHandle ( HANDLE hCancelEvent )
{
	HRESULT hRes = WBEM_S_NO_ERROR ;

	CInCritSec lock(&m_arbitratorCS);
	if ( m_hWaitForSetStatus == NULL )
	{
		m_hWaitForSetStatus = hCancelEvent ;	
	}

	return hRes ;
}




//***************************************************************************
// ATTGORA: Do we really need to tell a client that 'setstatus' or 'indicates'
// us for cancellation that we are cancelling?
//***************************************************************************
HRESULT CWmiFinalizer::CancelCall ( )
{
	CAutoSignal CancelCallSignal (m_hCancelEvent);
	
	HRESULT hRes;
	if ( InterlockedCompareExchange ( &m_bCancelledCall, 1, 0 ) == 0 )
	{
		hRes = WBEM_NO_ERROR;
		m_bCancelledCall = TRUE;


		// 
		// Indicate the cancellation to the client, iff we are not cancelling
		// due to a naughty client (i.e a client that didnt return from
		// the indicate or setstatus call in a reasonable amount of time
		// 
		if ( !m_bNaughtyClient )
		{
			// 
			// Ensure destination sink is protected [stress bug]
			// 
			IWbemObjectSink* pTmp = ReturnProtectedDestinationSink  ( );
			if ( !pTmp )
			{
					m_hStatus = CallCancelled;
					//SetEvent (m_hNewThreadRequests);					// Wake up potential threads stuck in delivery
					NotifyAllEnumeratorsOfCompletion ( ) ;
					CancelTaskInternal ( ) ;
					return WBEM_NO_ERROR;
			}
			CAutoRelease myReleaseMe(pTmp);

			// 
			// This is an async operation. Need to call setstatus on delivery thread
			// Hack: What we do is forcfully insert the setstatus message at the beginning
			// of the object queue. Two scenarios:
			//  1. If the async delivery thread is waiting, it will be woken up
			//  2. If the async delivery thread is delivering, the next object delivered
			//	   will be the status msg.
			// 
			CWmiFinalizerObj *pObj = new CWmiFinalizerObj(0, WBEM_E_CALL_CANCELLED, NULL, NULL);
			if (pObj == NULL)
			{
				DoSetStatus ( pTmp, WBEM_STATUS_COMPLETE, WBEM_E_OUT_OF_MEMORY, 0, 0 ) ;
				return WBEM_E_OUT_OF_MEMORY;
			}

			QueueOperation ( pObj );
			m_bSetStatusCalled = true;		
		}
		else
		{
			//
			// We have a client that is not being cooperative (not returning within 60s). BAD
			// BAD CLIENT!
			//
			// Try to push a SetStatus (WBEM_E_CALL_CANCELLED) through. Maybe they're not intentially
			// trying to be bad, perhaps they're just incompentent and not reading the docs !
			//
			IWbemObjectSink* pTmp = ReturnProtectedDestinationSink  ( );
			if ( !pTmp )
			{
					m_hStatus = CallCancelled;
					//SetEvent (m_hNewThreadRequests);					// Wake up potential threads stuck in delivery
					NotifyAllEnumeratorsOfCompletion ( ) ;
					return WBEM_NO_ERROR;
			}
			CAutoRelease myReleaseMe(pTmp);

			//
			// This is the absolutely last attempt to notify the client that something
			// is going wrong. We dont care about the result of this operation since
			// we cant do anything about a failure anyway! More than likey, if this call
			// doesnt return the client has messed up again and we're done.
			//
			DoSetStatus ( pTmp, WBEM_STATUS_COMPLETE, WBEM_E_CALL_CANCELLED, 0, 0 ) ;
		}

		// 
		// If we dont have a destination sink, who cares? Do some cleanup.
		// Tell the arbitrator to do some system wide clean up. This HAS TO
		// finish before we continue cleaning up, otherwise we could be destroying
		// sinks that are still considered active
		// 
		hRes = CancelTaskInternal();
	}
	else
		hRes = WBEM_E_CALL_CANCELLED;

	m_hStatus = CallCancelled;
	//SetEvent (m_hNewThreadRequests);					// Wake up potential threads stuck in delivery
	NotifyAllEnumeratorsOfCompletion ( ) ;
	return hRes;
}




//***************************************************************************
//
//***************************************************************************
VOID WINAPI CWmiFinalizer::ProxyThreshold ( PVOID pvContext, BOOLEAN bTimerOrWait )
{
	((CWmiFinalizer*)pvContext)->ProxyThresholdImp();
}



//***************************************************************************
//
//***************************************************************************
VOID CWmiFinalizer::ProxyThresholdImp ( )
{
	RevertToSelf ( ) ;
	UpdateStatus ( WMI_FNLZR_STATE_CLIENT_DEAD );
    ERRORTRACE((LOG_WBEMCORE, "Client did not return from a SetStatus or Indicate call within %d ms\n",g_ulClientCallbackTimeout));
	m_bNaughtyClient  = TRUE;
	CancelCall();
}


//***************************************************************************
//
//***************************************************************************


HRESULT CWmiFinalizer::PullObjects(long lTimeout, ULONG uCount, IWbemClassObject** apObjects, ULONG* puReturned, CWmiFinalizerEnumerator* pEnum, BOOL bAddToObjQueue, BOOL bSetErrorObj )
{
	HRESULT hr = WBEM_NO_ERROR;
	BOOL bTimeOutExpired = FALSE;


	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Has SetStatus already been consumed?
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if (pEnum->m_bSetStatusConsumed)
	{
		try
		{
			*puReturned = 0;
		}
		catch (...) // untrusted param
		{
		    ExceptionCounter c;		
			return WBEM_E_INVALID_PARAMETER;
		}

		return WBEM_S_FALSE;
	}


	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Now we want to loop until we recieved the number of
	// objects requested
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	ULONG index = 0;
	while (index != uCount)
	{
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Dequeue the object
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		CWmiFinalizerObj *pObj = NULL;
		hr = DequeueObject(&pObj, pEnum);
		if (hr == WBEM_S_FALSE )
		{
			if ( !bTimeOutExpired )
			{
				// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				// If Dequeue returned FALSE it means
				// that there are no objects. We should
				// wait for them, unless we have been
				// told to cancel or we have been
				// released
				// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				if ( m_hStatus == CallCancelled )
				{
					hr = WBEM_E_CALL_CANCELLED;
					break ;
				}
				else if ( m_hStatus == RequestReleased )
				{
					hr = WBEM_E_FAILED;
					break;
				}
				else if ( m_hStatus == QuotaViolation )
				{
					hr = WBEM_E_QUOTA_VIOLATION;
					break;
				}
				// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				//Wait for another object to come in...
				// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				DWORD dwRet = CCoreQueue::QueueWaitForSingleObject(pEnum->m_hWaitOnResultSet, lTimeout);
				if (dwRet == WAIT_TIMEOUT)
				{
					bTimeOutExpired = TRUE;
					continue;
				}
				else if ( m_hStatus == CallCancelled )
				{
					hr = WBEM_E_CALL_CANCELLED;
					break ;
				}
				else if ( m_hStatus == RequestReleased )
				{
					hr = WBEM_E_FAILED;
					break;
				}
				else if ( m_hStatus == QuotaViolation )
				{
					hr = WBEM_E_QUOTA_VIOLATION;
					break;
				}

				else
					continue;
			}
			else
			{
				hr = WBEM_S_TIMEDOUT;
				break;
			}
		}
		if (FAILED(hr))
			break;

		
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// If we recieved a status complete message, simply break out of
		// the loop
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		if ((pObj->m_objectType == CWmiFinalizerObj::status) && (pObj->m_lFlags == WBEM_STATUS_COMPLETE))
		{
			// Fix for: 175856, 143550
			if ( bSetErrorObj && FAILED (pObj->m_hRes) && pObj->m_pObj )
			{
				m_pCallResult->SetErrorInfo ( );
			}

			
			hr = pObj->m_hRes;
			if (SUCCEEDED ( hr ) )
				hr = WBEM_S_FALSE;
			pEnum->m_bSetStatusConsumed = true;
			
			delete pObj;
			break;
		}


        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// If its a status message 
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		else if (pObj->m_objectType == CWmiFinalizerObj::status  )
        {
			delete pObj;
            continue;
        }


		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// If its an object we enqueue it if requested
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		else if (pObj->m_objectType == CWmiFinalizerObj::object)
		{
			if ( bAddToObjQueue )
			{
				// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				// Make sure we dont trip on nasty client supplied buffers
				// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				try
				{
					apObjects[index] = pObj->m_pObj;
					if (apObjects[index])
					{
						pObj->m_pObj->AddRef();
					}
				}
				catch (...) // untrusted args
				{
			        ExceptionCounter c;				
					hr = WBEM_E_INVALID_PARAMETER;
					delete pObj;
					break;
				}
			}
			delete pObj;
		}
		else
		{
			if ( pObj )
			{
				delete pObj;
			}
		}
		index ++;
	}

	if (SUCCEEDED(hr))
	{
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Make sure we dont trip on nasty client supplied buffers
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		try
		{
			*puReturned = index;
		}
		catch (...) // untrusted args
		{
	        ExceptionCounter c;
			// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			// need to release all the objects already in the array otherwise they will be leaked...
			// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			if ( bAddToObjQueue )
			{
				for (DWORD i = 0; i != index; i++)
				{
					if (apObjects[i])
						apObjects[i]->Release();
				}
			}
			return WBEM_E_INVALID_PARAMETER;
		}
	}

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// If we fail, clean up the obj array
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	else
	{
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// need to release all the objects already in the array otherwise they will be leaked...
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		if ( bAddToObjQueue )
		{
			for (DWORD i = 0; i != index; i++)
			{
				if (apObjects[i])
					apObjects[i]->Release();
			}
		}
	}

	return hr;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizer::DequeueObject( CWmiFinalizerObj **ppObj, CWmiFinalizerEnumerator* pEnum )
{
	CInCritSec cs(&m_cs);

	if ( pEnum != NULL )
	{
		if (pEnum->m_uCurObjectPosition >= (ULONG)m_objects.Size())
			return WBEM_S_FALSE;

		ULONG lIndex = pEnum->m_uCurObjectPosition ;

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// If this is a semisync call we should decrement the wake up call 
		// flag
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		if ( m_ulOperationType == Operation_Type_Semisync && pEnum->m_ulSemisyncWakeupCall != 0 )
		{
			pEnum->m_ulSemisyncWakeupCall--;
		}

		if ( m_bSetStatusWithError && m_bRestartable )
		{
			lIndex = 0 ;
		}

		
		CWmiFinalizerObj *pStorageObject = (CWmiFinalizerObj*)m_objects[lIndex];

		if (m_bRestartable)
		{
			//We have to hold on to results, so increment cursor position...
			pEnum->m_uCurObjectPosition++;

			*ppObj = new CWmiFinalizerObj(*pStorageObject);
			if (*ppObj == NULL)
				return WBEM_E_OUT_OF_MEMORY;
		}
		else
		{
			//We are not restartable, therefore we need to release everything...
			CWmiFinalizerObj *pStorageObject = (CWmiFinalizerObj*)m_objects[0];
			m_objects.RemoveAt(0);
			*ppObj = pStorageObject;
		}
	}
	else
	{
		if ( m_uCurObjectPosition >= (ULONG)m_objects.Size() )
			return WBEM_S_FALSE;


		CWmiFinalizerObj *pStorageObject = (CWmiFinalizerObj*)m_objects[0];

		m_objects.RemoveAt(0);
		*ppObj = pStorageObject;
	}
	return WBEM_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizer::Skip(
	/*[in]*/ long lTimeout,
    /*[in]*/ ULONG nCount,
	/*[in]*/ CWmiFinalizerEnumerator* pEnum 
	)
{
	ULONG uReturned = 0;
	return PullObjects(lTimeout, nCount, NULL, &uReturned, pEnum, FALSE);
}



//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizer::NextAsync ( CWmiFinalizerEnumerator* pEnum )
{
	BOOL bRes;
	HRESULT hRes = WBEM_S_NO_ERROR;


	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Native Win2k thread dispatching
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	pEnum->InternalAddRef();
	AddRef();
	bRes = QueueUserWorkItem ( pEnum->ThreadBootstrapNextAsync, pEnum, WT_EXECUTEDEFAULT );
	if ( !bRes )
	{
		pEnum->InternalRelease();
		Release();
		pEnum->SetCompletionSignalEvent ();	
		return WBEM_E_FAILED;
	}
	if ( pEnum->m_bSetStatusConsumed )
		hRes = WBEM_S_FALSE;
	return hRes;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizer::SetSinkToIdentity ( IWbemObjectSink* pSink )
{
	HRESULT sc;

    IClientSecurity * pFromSec = NULL;
    sc = pSink->QueryInterface(IID_IClientSecurity, (void **) &pFromSec);
    if(sc == S_OK)
    {
		OLECHAR * pPrincipal = NULL;
		DWORD dwAuthnSvc, dwAuthzSvc, dwAuthnLevel, dwImpLevel, dwCapabilities;
		sc = pFromSec->QueryBlanket(pSink, &dwAuthnSvc, &dwAuthzSvc,
											&pPrincipal,
											&dwAuthnLevel, &dwImpLevel,
											NULL, &dwCapabilities);
		if ( sc==S_OK )
		{
			sc = pFromSec->SetBlanket(pSink, dwAuthnSvc, dwAuthzSvc,
												pPrincipal,
												dwAuthnLevel, RPC_C_IMP_LEVEL_IDENTIFY,	// We always call back on System and IDENTITY IMP LEVEL!!!
												NULL, dwCapabilities);
			if(pPrincipal)
				CoTaskMemFree(pPrincipal);

		}

		pFromSec->Release();
	}
	return sc;
}



//***************************************************************************
//
//  ZapWriteOnlyProps
//
//  Removes write-only properties from an object.
//  Precondition: Object has been tested for presence of "HasWriteOnlyProps"
//  on the object itself.
//
//***************************************************************************
HRESULT CWmiFinalizer::ZapWriteOnlyProps(IWbemClassObject *pObj)
{
    VARIANT v;
    VariantInit(&v);
    V_VT(&v) = VT_NULL;

    SAFEARRAY *pNames = 0;
    pObj->GetNames(L"WriteOnly", WBEM_FLAG_ONLY_IF_TRUE, 0, &pNames);
    LONG lUpper;
    SafeArrayGetUBound(pNames, 1, &lUpper);

    for (long i = 0; i <= lUpper; i++)
    {
        BSTR strName = 0;
        SafeArrayGetElement(pNames, &i, &strName);
        pObj->Put(strName, 0, &v, 0);
		SysFreeString (strName);
    }
    SafeArrayDestroy(pNames);
	VariantClear (&v);

    return WBEM_S_NO_ERROR;
}



//***************************************************************************
//
//  HasWriteOnlyProps
//
//  Returns TRUE if object contains any Write only props, otherwise FALSE
//
//***************************************************************************
BOOL CWmiFinalizer::HasWriteOnlyProps ( IWbemClassObject* pObj )
{
	BOOL bRes;
	
	IWbemQualifierSet *pQSet = 0;
	HRESULT hRes = pObj->GetQualifierSet(&pQSet);
	if (FAILED(hRes))
		return FALSE;

	hRes = pQSet->Get(L"HasWriteOnlyProps", 0, 0, 0);
	if (SUCCEEDED(hRes))
		bRes = TRUE;
	else
		bRes = FALSE;

	pQSet->Release();
	return bRes;
}





//***************************************************************************
//
//  DoSetStatus
//
//  Using LowerAuthLevel
//
//***************************************************************************
HRESULT CWmiFinalizer::DoSetStatus(IWbemObjectSink * psink, long lFlags, HRESULT lParam, BSTR strParam,
                    IWbemClassObject* pObjParam, BOOL bAllowMultipleCalls )
{
	HRESULT hres = WBEM_E_FAILED;

	//
	// In the case of NextAsync we will in fact allow multiple calls to DoSetStatus
	//
	if ( ( bAllowMultipleCalls == FALSE ) && ( lFlags == WBEM_STATUS_COMPLETE ) )
	{
		//
		// If a setstatus has already been delivered, fail this operation
		// This is a must since we support the CancelAsynCall in which case
		// there is potential for 2 setstatus msg to be enqueued.
		//
		{
			CCheckedInCritSec cs ( &m_cs ) ;
		
			if ( m_bSetStatusDelivered == TRUE )
			{
				//
				// If a SetStatus has already been delivered (in non-error cases, i.e. not via client cancellation)
				// we still may want to try and wake up the client since they may have tried to enter a cancellation
				// wait state.
				//
				cs.Leave ( ) ;
				NotifyClientOfCancelledCall ( ) ;
				return hres ;
			}
			else
			{
				//
				// We assume that the delivery will be successfull. If its not, we dont
				// want to try again anyway.
				//
				m_bSetStatusDelivered = TRUE ;
			}
		}
	}

	
	DWORD	dwLastAuthnLevel = LOWER_AUTH_LEVEL_NOTSET;
    // put this a loop, but use the counter to make sure there is always an exit.
    for(int i = 0; i < 10; i ++)
    {
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Make sure bad client sink does not trip us
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        try
		{
			hres = psink->SetStatus(lFlags, lParam, strParam, pObjParam);
		}
		catch (...) // untrusted sink
		{
	        ExceptionCounter c;		
			hres = WBEM_E_INVALID_PARAMETER;
			break;
		}

        if(!FAILED(hres))
        {
			break ;        // all done, normal exit
		}

		if ( hres != ERROR_ACCESS_DENIED )
			break;

		hres = FinalizerLowerAuthLevel(psink, &dwLastAuthnLevel);
        if(FAILED(hres))
            break;
    }
    if ( FAILED (hres) )
	{
		ERRORTRACE((LOG_WBEMCORE, "Could not SetStatus to remote client, hres =%X\n",hres));
	}

	if ( lParam == WBEM_E_CALL_CANCELLED )
	{
		NotifyClientOfCancelledCall ( ) ;
	}

	if ( lFlags == WBEM_STATUS_COMPLETE && bAllowMultipleCalls == FALSE )
	{
		NotifyClientOfCancelledCall ( ) ;
		CancelTaskInternal ( ) ;
	}

	return hres;
}



//***************************************************************************
//
//  DoSetIndicate
//
//  Using LowerAuthLevel
//
//***************************************************************************
HRESULT CWmiFinalizer::DoIndicate(IWbemObjectSink * psink, int nBatchSize, IWbemClassObject **pBatch)
{
    HRESULT hres = WBEM_E_FAILED;
	DWORD	dwLastAuthnLevel = LOWER_AUTH_LEVEL_NOTSET;

    // put this a loop, but use the counter to make sure there is always an exit.
    for(int i = 0; i < 10; i ++)
    {
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Make sure bad client sink does not trip us
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        try
		{
			hres = psink->Indicate(nBatchSize, pBatch);
		}
		catch (...) // untrusted sink
		{
	        ExceptionCounter c;		
			hres = WBEM_E_INVALID_PARAMETER;
			break;
		}
        if(!FAILED(hres))
		{
			return hres;        // all done, normal exit
		}

		if ( hres != ERROR_ACCESS_DENIED )
			break;
		
		
		hres = FinalizerLowerAuthLevel(psink, &dwLastAuthnLevel);
        if(FAILED(hres))
            break;
    }
    ERRORTRACE((LOG_WBEMCORE, "Could not SetStatus to remote client, hres %X=\n",hres));
    return hres;
}


//***************************************************************************
//
//  LowerAuth.
//
//  Using LowerAuthLevel
//
//***************************************************************************

HRESULT CWmiFinalizer::FinalizerLowerAuthLevel(IWbemObjectSink * psink, DWORD* pdwLastAuthnLevel )
{
    IClientSecurity * pFromSec = NULL;
    SCODE sc = psink->QueryInterface(IID_IClientSecurity, (void **) &pFromSec);
    if(sc == S_OK)
    {
        OLECHAR * pPrincipal = NULL;
        DWORD dwAuthnSvc, dwAuthzSvc, dwAuthnLevel, dwImpLevel, dwCapabilities;
        sc = pFromSec->QueryBlanket(psink, &dwAuthnSvc, &dwAuthzSvc,
                                            &pPrincipal,
                                            &dwAuthnLevel, &dwImpLevel,
                                            NULL, &dwCapabilities);

		// If we have never retrieved the authentication level before, then we
		// should record what it currently is
		if ( LOWER_AUTH_LEVEL_NOTSET == *pdwLastAuthnLevel )
		{
			*pdwLastAuthnLevel = dwAuthnLevel;
		}

        if (FAILED(sc))
            return sc;
        if(*pdwLastAuthnLevel == RPC_C_AUTHN_LEVEL_NONE)
            return WBEM_E_FAILED;
        if(*pdwLastAuthnLevel == RPC_C_AUTHN_LEVEL_DEFAULT)
            *pdwLastAuthnLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
        else
            (*pdwLastAuthnLevel)--;      // normal case is to try one lower

        sc = pFromSec->SetBlanket(psink, dwAuthnSvc, dwAuthzSvc,
                                            pPrincipal,
                                            *pdwLastAuthnLevel, RPC_C_IMP_LEVEL_IDENTIFY,	// We always call back on System and IDENTITY IMP LEVEL!!!
                                            NULL, dwCapabilities);

        if(pPrincipal)
            CoTaskMemFree(pPrincipal);
        pFromSec->Release();

    }
    return sc;
}



//***************************************************************************
//
//  ZeroAsyncDeliveryBuffer 
//
//  Clears out the async delivery buffer
//
//***************************************************************************
VOID CWmiFinalizer::ZeroAsyncDeliveryBuffer ( )
{
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Delete the object array
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	for ( ULONG i = 0; i < m_ulAsyncDeliveryCount; i++ )
	{
		m_apAsyncDeliveryBuffer[i]->Release();
	}
	delete [] m_apAsyncDeliveryBuffer;
	m_ulAsyncDeliveryCount = 0;
	m_ulAsyncDeliverySize = 0;
}


//***************************************************************************
//
//***************************************************************************
HRESULT CWmiFinalizer::DumpDebugInfo (
        /*[in]*/ ULONG uFlags,
		/*[in]*/ const BSTR strFile
        )
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	return hRes;
}



/*
    * ==================================================================================================
	|
	| HRESULT CWmiFinalizer::NotifyAllEnumeratorsOfCompletion ( )
	| -----------------------------------------------------------
	| 
	| 
	|
	* ==================================================================================================
*/
HRESULT CWmiFinalizer::NotifyAllEnumeratorsOfCompletion ( )
{
	//
	// Cocked, Locked, and ready to Rock
	//
	CInCritSec _cs ( &m_cs );
	
	HRESULT hRes = WBEM_S_NO_ERROR ;
	
	for ( int i = 0; i < m_enumerators.Size ( ); i++ )
	{
		CWmiFinalizerEnumerator* pEnum = (CWmiFinalizerEnumerator*) m_enumerators[i] ;
		if ( pEnum )
		{
			if ( pEnum->m_hWaitOnResultSet )
			{
				SetEvent ( pEnum->m_hWaitOnResultSet );
			}
		}
	}

	return hRes ;
}


/*
    * ==================================================================================================
	|
	| HRESULT CWmiFinalizer::UnregisterEnumerator ( CWmiFinalizerEnumerator* pEnum )
	| ------------------------------------------------------------------------------
	| 
	| 
	|
	* ==================================================================================================
*/
HRESULT CWmiFinalizer::UnregisterEnumerator ( CWmiFinalizerEnumerator* pEnum )
{
	//
	// Cocked, Locked, and ready to Rock
	//
	CInCritSec _cs ( &m_cs );
	
	HRESULT hRes = WBEM_S_NO_ERROR ;
	
	for ( int i = 0; i < m_enumerators.Size ( ); i++ )
	{
		CWmiFinalizerEnumerator* pEnumerator = (CWmiFinalizerEnumerator*) m_enumerators[i] ;
		if ( pEnum == pEnumerator )
		{
			pEnumerator->InternalRelease ( ) ;
			m_enumerators.RemoveAt ( i ) ;
			break ;
		}
	}
	return hRes ;
}



// ==========================================================================
// ==========================================================================
//					CWmiFinalizerInboundSink
// ==========================================================================
// ==========================================================================




//***************************************************************************
//
//***************************************************************************
CWmiFinalizerInboundSink::CWmiFinalizerInboundSink(CWmiFinalizer *pFinalizer)
: m_lRefCount(0), m_lInternalRefCount (0),m_pFinalizer(pFinalizer), m_bSetStatusCalled(false)
{
	InterlockedIncrement ( & s_FinalizerInBoundSink_ObjectCount ) ;

	m_pFinalizer->AddRef();
}

//***************************************************************************
//
//***************************************************************************
CWmiFinalizerInboundSink::~CWmiFinalizerInboundSink()
{
	InterlockedDecrement ( & s_FinalizerInBoundSink_ObjectCount ) ;
}

//***************************************************************************
//
//***************************************************************************

void CWmiFinalizerInboundSink::CallBackRelease ()
{
	if (!m_bSetStatusCalled)
	{
		//FNLZR_ASSERT(__TEXT("CWmiFinalizerInboundSink::~CWmiFinalizerInboundSink - Released sink without calling SetStatus!  Sending WBEM_E_FAILED to client!"), WBEM_E_INVALID_OPERATION);
		m_pFinalizer->SetStatus(0, WBEM_E_UNEXPECTED, NULL, NULL);
        ERRORTRACE((LOG_WBEMCORE, "Finalizer: Sink released without SetStatus being called\n"));
	}
	m_pFinalizer->UnregisterInboundSink(this);
	m_pFinalizer->Release();
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiFinalizerInboundSink::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = 0;

    if ((IID_IUnknown==riid) || (IID_IWbemObjectSinkEx==riid) || (IID_IWbemObjectSink == riid))
    {
        *ppvObj = this;
        AddRef();
        return NOERROR;
    }

	return E_NOINTERFACE;
}

//***************************************************************************
//
//***************************************************************************
ULONG CWmiFinalizerInboundSink::AddRef()
{
	ULONG uNewCount = InterlockedIncrement(&m_lRefCount);
	if ( uNewCount == 1 )
	{
		InternalAddRef () ;
	}

//	printf("CWmiFinalizerInboundSink::Release: 0x%p", this);
    return uNewCount;
}

//***************************************************************************
//
//***************************************************************************
ULONG CWmiFinalizerInboundSink::Release()
{
    ULONG uNewCount = InterlockedDecrement(&m_lRefCount);
//	printf("CWmiFinalizerInboundSink::Release: 0x%p", this);
    if (0 == uNewCount)
	{
		CallBackRelease () ;

		InternalRelease () ;
	}

    return uNewCount;
}

//***************************************************************************
//
//***************************************************************************
ULONG CWmiFinalizerInboundSink::InternalAddRef()
{
	ULONG uNewCount = InterlockedIncrement(&m_lInternalRefCount);
//	printf("CWmiFinalizerInboundSink::Release: 0x%p", this);
    return uNewCount;
}

//***************************************************************************
//
//***************************************************************************
ULONG CWmiFinalizerInboundSink::InternalRelease()
{
    ULONG uNewCount = InterlockedDecrement(&m_lInternalRefCount);
//	printf("CWmiFinalizerInboundSink::Release: 0x%p", this);
    if (0 == uNewCount)
	{
		delete this ;
	}

    return uNewCount;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiFinalizerInboundSink::Indicate(
    /*[in]*/ long lObjectCount,
    /*[in, size_is(lObjectCount)]*/
        IWbemClassObject** apObjArray
    )
{
	// If someone is trying to indicate NULL objects, reject and return WBEM_E_INVALID_PARAMETER
	if ( apObjArray == NULL )
		return WBEM_E_INVALID_PARAMETER;
	
	// Update status variable to show that indicate has been called at least once
	m_pFinalizer->UpdateStatus ( WMI_FNLZR_STATE_ACTIVE );
	
	// Special case: Call has been cancelled.
	if ( m_pFinalizer->IsCallCancelled() )
		return WBEM_E_CALL_CANCELLED;

	return m_pFinalizer->Indicate(lObjectCount, apObjArray);
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiFinalizerInboundSink::SetStatus(
    /*[in]*/ long lFlags,
    /*[in]*/ HRESULT hResult,
    /*[in]*/ BSTR strParam,
    /*[in]*/ IWbemClassObject* pObjParam
    )
{
	// Update status variable to show that SetStatus has been called but not yet delivered
	// to client
	m_pFinalizer->UpdateStatus ( WMI_FNLZR_STATE_CORE_COMPLETE );
	
	// Special case: Call has been cancelled.
	if ( m_pFinalizer->IsCallCancelled() )
		return WBEM_E_CALL_CANCELLED;

	if (lFlags == WBEM_STATUS_COMPLETE)
		m_bSetStatusCalled = true;
	return m_pFinalizer->SetStatus(lFlags, hResult, strParam, pObjParam);
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiFinalizerInboundSink::Set(
    /*[in]*/ long lFlags,
    /*[in]*/ REFIID riid,
    /*[in, iid_is(riid)]*/ void *pComObject
    )
{
	if (lFlags != 0)
		RET_FNLZR_ASSERT(__TEXT("CWmiFinalizerInboundSink::Set - lFlags != 0!"), WBEM_E_INVALID_PARAMETER);

	return m_pFinalizer->Set(lFlags, riid, pComObject);
}






//***************************************************************************
//
//***************************************************************************
CWmiFinalizerEnumerator::CWmiFinalizerEnumerator(CWmiFinalizer *pFinalizer )
:
	m_lRefCount(0),
	m_lInternalRefCount(0),
	m_pFinalizer(pFinalizer),
	m_ulCount(0),
	m_pDestSink (NULL),
	m_hSignalCompletion (NULL),
	m_pSec (NULL),
	m_XSmartEnum( this ),
	m_pEnumMarshal (NULL)
{
	InterlockedIncrement ( & s_FinalizerEnum_ObjectCount ) ;

	//
	// Cloning fix. We need to keep the state of the enumerator.
	// This means keeping individual wait event as well as object
	// position
	//
	m_hWaitOnResultSet = CreateEvent(NULL, FALSE, FALSE, NULL);
	m_uCurObjectPosition = 0 ;
	m_ulSemisyncWakeupCall = 0 ;
	m_bSetStatusConsumed = FALSE ;

	m_pFinalizer->AddRef();

}

//***************************************************************************
//
//***************************************************************************
CWmiFinalizerEnumerator::~CWmiFinalizerEnumerator()
{
	InterlockedDecrement ( & s_FinalizerEnum_ObjectCount ) ;
	
	if ( m_hSignalCompletion )
	{
		CloseHandle ( m_hSignalCompletion );
	}

	
	if ( m_hWaitOnResultSet )
	{
		SetEvent ( m_hWaitOnResultSet ) ;
		CloseHandle ( m_hWaitOnResultSet ) ;
		m_hWaitOnResultSet = NULL ;
	}

	// Release the Enum Marshaler
	{
		CInCritSec _cs( &m_EnumCS );
		if ( m_pEnumMarshal )
		{
			m_pEnumMarshal->Release();
		}
	}
}

void CWmiFinalizerEnumerator::CallBackRelease ()
{
	m_pFinalizer->SetInternalStatus ( m_pFinalizer->RequestReleased );
	m_pFinalizer->CancelTaskInternal();
	m_pFinalizer->UnregisterEnumerator ( this ) ;
	m_pFinalizer->Release();
}

//***************************************************************************
//
//***************************************************************************
ULONG CWmiFinalizerEnumerator::AddRef()
{
	ULONG uNewCount = InterlockedIncrement(&m_lRefCount);
	if ( uNewCount == 1 )
	{
		InternalAddRef () ;
	}

//	printf("CWmiFinalizerCallResult::Release: 0x%p", this);
    return uNewCount;
}

//***************************************************************************
//
//***************************************************************************
ULONG CWmiFinalizerEnumerator::Release()
{
    ULONG uNewCount = InterlockedDecrement(&m_lRefCount);
//	printf("CWmiFinalizerCallResult::Release: 0x%p", this);
    if (0 == uNewCount)
	{
		CallBackRelease () ;

		InternalRelease () ;
	}

    return uNewCount;
}

//***************************************************************************
//
//***************************************************************************
ULONG CWmiFinalizerEnumerator::InternalAddRef()
{
	ULONG uNewCount = InterlockedIncrement(&m_lInternalRefCount);
//	printf("CWmiFinalizerCallResult::Release: 0x%p", this);
    return uNewCount;
}

//***************************************************************************
//
//***************************************************************************
ULONG CWmiFinalizerEnumerator::InternalRelease()
{
    ULONG uNewCount = InterlockedDecrement(&m_lInternalRefCount);
//	printf("CWmiFinalizerCallResult::Release: 0x%p", this);
    if (0 == uNewCount)
	{
		delete this ;
	}

    return uNewCount;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiFinalizerEnumerator::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = 0;

	// Added support for IID_IWbemFetchSmartEnum
    if ((IID_IUnknown==riid) || (IID_IEnumWbemClassObject==riid) )
    {
        *ppvObj = this;
        AddRef();
        return NOERROR;
    }
	else if ( IID_IWbemFetchSmartEnum == riid )
	{
		*ppvObj = (IWbemFetchSmartEnum*) this;
		AddRef();
		return NOERROR;
	}


	return E_NOINTERFACE;
}


//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiFinalizerEnumerator::Reset()
{
	if(!m_Security.AccessCheck())
		return WBEM_E_ACCESS_DENIED;

	CInCritSec cs(&m_clientLock);

	if ( m_pFinalizer->IsRestartable ( ) )
	{
		m_uCurObjectPosition = 0;
		m_bSetStatusConsumed = false;
		return WBEM_NO_ERROR;
	}
	else
		return WBEM_E_INVALID_OPERATION;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiFinalizerEnumerator::Next(
    /*[in]*/  long lTimeout,
    /*[in]*/  ULONG uCount,
    /*[out, size_is(uCount), length_is(*puReturned)]*/ IWbemClassObject** apObjects,
    /*[out]*/ ULONG* puReturned
    )
{
	if(!m_Security.AccessCheck())
		return WBEM_E_ACCESS_DENIED;
	CInCritSec cs(&m_clientLock);
	if ( ( puReturned == NULL ) || ( apObjects == NULL ) || (lTimeout < 0 && lTimeout != WBEM_INFINITE) )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}
	if ( uCount == 0 )
	{
		return WBEM_S_NO_ERROR;
	}

	*puReturned = 0 ;
	m_ulSemisyncWakeupCall = uCount ;
	return m_pFinalizer->PullObjects(lTimeout, uCount, apObjects, puReturned, this );
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiFinalizerEnumerator::NextAsync(
    /*[in]*/  ULONG uCount,
    /*[in]*/  IWbemObjectSink* pSink
    )
{
	if(!m_Security.AccessCheck())
		return WBEM_E_ACCESS_DENIED;
	// If delivery sink is NULL
	if ( pSink == NULL )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}

	// If requested count is 0
	if ( uCount == 0 )
	{
		return WBEM_S_FALSE;
	}

	HRESULT hRes;

	{
		CInCritSec cs(&m_EventCreationLock);
		if ( m_hSignalCompletion == NULL )
		{
			m_hSignalCompletion = CreateEvent ( NULL, FALSE, TRUE, NULL );
			if ( !m_hSignalCompletion )
				return WBEM_E_FAILED;
		}
	}

	if ( m_pFinalizer->GetInternalStatus() != m_pFinalizer->NoError )
		return WBEM_E_FAILED;

	CCoreQueue::QueueWaitForSingleObject(m_hSignalCompletion, INFINITE);
	
	if ( m_pFinalizer->GetInternalStatus() != m_pFinalizer->NoError )
	{
		// Dont forget to wake up any other threads waiting! 
		SetCompletionSignalEvent();
		return WBEM_E_FAILED;
	}


	// If we are already done.
	m_pDestSink = pSink;
	m_pDestSink->AddRef();
	m_ulCount = uCount;
	m_pFinalizer->SetSinkToIdentity ( m_pDestSink );

	return m_pFinalizer->NextAsync (this);
}



//***************************************************************************
//
//***************************************************************************
HRESULT CWmiFinalizerEnumerator::_NextAsync ( )
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	DWORD dwRet;

	RevertToSelf ( );
	
	// Grab the client lock. All remainding ::NextAsync calls will be queued up
	CInCritSec cs(&m_clientLock);
	
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Is the operation complete? If so, we should notify the sink
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if ( m_bSetStatusConsumed )
	{
		HRESULT hFinalRes;
		m_pFinalizer->GetOperationResult ( 0, INFINITE, &hFinalRes );
		m_pFinalizer->DoSetStatus ( m_pDestSink, WBEM_STATUS_COMPLETE, hFinalRes, 0, 0 );
		hRes = WBEM_S_FALSE;
	}
	
	else
	{
		// NOTE [marioh] : This is no longer needed since we've decided to go with the Win2k solution
		// for the time being.
		// If we fail to impersonate, we dont continue!!!!
		//CAutoRevert AutoRevert (m_pFinalizer);
		//if ( AutoRevert.IsImpersonated() == FALSE )
		//	return WBEM_E_CRITICAL_ERROR;


		IWbemClassObject **pArray = new IWbemClassObject *[m_ulCount];
		if (pArray == NULL)
		{
			m_pFinalizer->DoSetStatus ( m_pDestSink, WBEM_STATUS_COMPLETE, WBEM_E_OUT_OF_MEMORY, 0, 0 );
		}

		else
		{
			ULONG uReturned = 0;
			
			m_pFinalizer->SetSemisyncWakeupCall (m_ulCount);
			HRESULT hr = m_pFinalizer->PullObjects(INFINITE, m_ulCount, pArray, &uReturned, this, TRUE, FALSE );
			if ( FAILED (hr) )
			{
				if ( hr == WBEM_E_CALL_CANCELLED )
				{
					m_pFinalizer->DoSetStatus (m_pDestSink, WBEM_STATUS_COMPLETE, WBEM_E_CALL_CANCELLED, 0, 0);
				}
			}

			if (SUCCEEDED(hr) && uReturned)
			{
				for (int i=0; i!=uReturned; i++)
				{
					if ( m_pFinalizer->HasWriteOnlyProps (pArray[i]) )
						m_pFinalizer->ZapWriteOnlyProps (pArray[i]);
				}
				
				hr = m_pFinalizer->DoIndicate(m_pDestSink, uReturned, pArray);
				if ( SUCCEEDED (hr) )
				{
					// If number of requested objects == number of objects delivered, SetStatus (WBEM_S_NO_ERROR)
					if ( uReturned == m_ulCount )
					{
						m_pFinalizer->DoSetStatus (m_pDestSink, WBEM_STATUS_COMPLETE, WBEM_S_NO_ERROR, 0, 0, TRUE );

					}
					// If less objects are delivered, SetStatus (WBEM_S_FALSE)
					else 
					{
						m_pFinalizer->DoSetStatus (m_pDestSink, WBEM_STATUS_COMPLETE, WBEM_S_FALSE, 0, 0, TRUE );
					}
				}
			}

		
			// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			// Cleanup the array if we fail to indicate
			// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			for (ULONG i = 0; i != uReturned; i++)
			{
				pArray[i]->Release();
			}
			delete [] pArray;
		}
	}	

	return hRes;
}


//***************************************************************************
//
//***************************************************************************
DWORD WINAPI CWmiFinalizerEnumerator::ThreadBootstrapNextAsync ( PVOID pParam )
{
	HRESULT hRes;
	CWmiFinalizerEnumerator* pEnum;
	try
	{
		pEnum = (CWmiFinalizerEnumerator*) pParam;
		hRes = pEnum->_NextAsync();
	}
	catch (...)
	{
        ExceptionCounter c;
	};

	
	pEnum->GetDestSink()->Release();
	pEnum->NULLDestSink();
	
	pEnum->SetCompletionSignalEvent ();

	pEnum->ReleaseFinalizer();

	pEnum->InternalRelease();

	return hRes;
}



//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiFinalizerEnumerator::Clone(
    /*[out]*/ IEnumWbemClassObject** ppEnum
    )
{
	if(!m_Security.AccessCheck())
		return WBEM_E_ACCESS_DENIED;
	CInCritSec cs(&m_clientLock);
	if ( ppEnum == NULL )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}

	// If the enumerator is not restartable, it is forward only, and hence cannot
	// be cloned.

	if ( !m_pFinalizer->IsRestartable() )
	{
		return WBEM_E_INVALID_OPERATION;
	}

	HRESULT hRes = S_OK ;	

	//Make sure we have all results before we clone...
	/*m_pFinalizer->WaitForCompletion(INFINITE);

    CCoreServices * pSrvs = CCoreServices::CreateInstance();
    CReleaseMe _rm(pSrvs);
	CWmiFinalizer *pFinalizer = new CWmiFinalizer(pSrvs);
	if (pFinalizer == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	pFinalizer->AddRef();

	HRESULT hr = pFinalizer->ImportFinalizer(m_pFinalizer);

	if (FAILED(hr))
	{
		pFinalizer->Release();
		return hr;
	}
	*/

  	//
	// Get the enumerator
	//
	hRes = m_pFinalizer->GetResultObject ( m_uCurObjectPosition, IID_IEnumWbemClassObject, (void**)ppEnum ) ;

   	//
	// Keep state information
	//
	if ( SUCCEEDED ( hRes ) )
	{
		((CWmiFinalizerEnumerator*)(*ppEnum))->m_uCurObjectPosition = m_uCurObjectPosition ;
		((CWmiFinalizerEnumerator*)(*ppEnum))->m_bSetStatusConsumed = m_bSetStatusConsumed ;
	}
	return hRes;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiFinalizerEnumerator::Skip(
    /*[in]*/ long lTimeout,
    /*[in]*/ ULONG nCount
    )
{
	if(!m_Security.AccessCheck())
		return WBEM_E_ACCESS_DENIED;
	if ( (lTimeout < 0 && lTimeout != WBEM_INFINITE) )
	{
		return WBEM_E_INVALID_PARAMETER;
	}
	
	CInCritSec cs(&m_clientLock);
	m_ulSemisyncWakeupCall = nCount ;
	return m_pFinalizer->Skip(lTimeout, nCount, this ) ;
}






//***************************************************************************
// IWbemFetchSmartEnum
//	GetSmartEnum
//***************************************************************************
STDMETHODIMP CWmiFinalizerEnumerator::GetSmartEnum ( IWbemWCOSmartEnum** ppSmartEnum )
{
	HRESULT hRes = WBEM_S_NO_ERROR;
	{
		CInCritSec _cs(&m_EnumCS);
		if ( !m_pEnumMarshal )
			hRes = CoCreateInstance ( CLSID__WbemEnumMarshaling, NULL, CLSCTX_INPROC_SERVER, IID__IWbemEnumMarshaling, (void**) &m_pEnumMarshal );
	}
	return FAILED(hRes) ? hRes : m_XSmartEnum.QueryInterface( IID_IWbemWCOSmartEnum, (void**) ppSmartEnum );
}


//***************************************************************************
// SmartEnum
//	QI
//***************************************************************************
STDMETHODIMP CWmiFinalizerEnumerator::XSmartEnum::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = 0;

    if ( IID_IUnknown==riid || IID_IWbemWCOSmartEnum == riid)
    {
        *ppvObj = (IWbemWCOSmartEnum*)this;
        AddRef();
        return NOERROR;
    }
	else
	{
		return m_pOuter->QueryInterface( riid, ppvObj );
	}
}


//***************************************************************************
// SmartEnum
//	Addref
//***************************************************************************
ULONG CWmiFinalizerEnumerator::XSmartEnum::AddRef( void )
{
	return m_pOuter->AddRef();
}


//***************************************************************************
// SmartEnum
//	Release
//***************************************************************************
ULONG CWmiFinalizerEnumerator::XSmartEnum::Release( void )
{
	return m_pOuter->Release();
}


//***************************************************************************
// SmartEnum
//	Release
//***************************************************************************
STDMETHODIMP CWmiFinalizerEnumerator::XSmartEnum:: Next( REFGUID proxyGUID, long lTimeout, ULONG uCount,
                ULONG* puReturned, ULONG* pdwBuffSize, BYTE** pBuffer)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	IWbemClassObject** apObj = new IWbemClassObject* [uCount];
	if ( !apObj )
		hRes = WBEM_E_OUT_OF_MEMORY;

	else
	{
		// Call next on real enumerator
		hRes = m_pOuter->Next ( lTimeout, uCount, apObj, puReturned );
		if ( SUCCEEDED (hRes) )
		{
			if ( *puReturned > 0 )
			{
				HRESULT hResMarshal = m_pOuter->m_pEnumMarshal->GetMarshalPacket ( proxyGUID, *puReturned, apObj, pdwBuffSize, pBuffer );
				if ( FAILED (hResMarshal) )
					hRes = hResMarshal;
			}
			else
			{
				*pdwBuffSize = 0;
				*pBuffer = NULL;
			}

			for ( ULONG ulIn=0; ulIn < *puReturned; ulIn++ )
			{
				apObj[ulIn]->Release();
			}
		}
		delete [] apObj;
	}
	return hRes;
}




// ===================================================================================================================================================
// ===================================================================================================================================================

//***************************************************************************
//
//***************************************************************************
CWmiFinalizerCallResult::CWmiFinalizerCallResult (

	CWmiFinalizer *pFinalizer

) :	m_lInternalRefCount(0),
	m_pFinalizer(pFinalizer),
	m_lFlags(-1),
    m_hResult(0),
    m_strParam(0),
    m_pObj(0),
	m_pServices(0),
	m_bGotObject(false),
	m_bGotServices(false),
	m_pErrorObj(NULL),
    m_lRefCount(0)
{
	InterlockedIncrement ( & s_FinalizerCallResult_ObjectCount ) ;
}

//***************************************************************************
//
//***************************************************************************
CWmiFinalizerCallResult::~CWmiFinalizerCallResult()
{
	InterlockedDecrement ( & s_FinalizerCallResult_ObjectCount ) ;

	if (m_pObj)
		m_pObj->Release();

	SysFreeString(m_strParam);

	if (m_pServices)
		m_pServices->Release();

	if (m_pErrorObj)
		m_pErrorObj->Release();
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiFinalizerCallResult::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = 0;

    if ((IID_IUnknown==riid) || (IID_IWbemCallResultEx==riid) || (IID_IWbemCallResult == riid))
    {
        *ppvObj = this;
        AddRef();
        return NOERROR;
    }

	return E_NOINTERFACE;
}

//***************************************************************************
//
//***************************************************************************
ULONG CWmiFinalizerCallResult::AddRef()
{
	ULONG uNewCount = InterlockedIncrement(&m_lRefCount);
    if (uNewCount == 1)
	    m_pFinalizer->AddRef () ;
    return uNewCount;
}

//***************************************************************************
//
//***************************************************************************
ULONG CWmiFinalizerCallResult::Release()
{
	ULONG uNewCount = InterlockedDecrement(&m_lRefCount);
    if (uNewCount == 0)
    {
        m_pFinalizer->CancelTaskInternal();
        m_pFinalizer->Release () ;
    }
    return uNewCount;
}

//***************************************************************************
//
//***************************************************************************
ULONG CWmiFinalizerCallResult::InternalAddRef()
{
	ULONG uNewCount = InterlockedIncrement(&m_lInternalRefCount);
    return uNewCount;
}

//***************************************************************************
//
//***************************************************************************
ULONG CWmiFinalizerCallResult::InternalRelease()
{
    ULONG uNewCount = InterlockedDecrement(&m_lInternalRefCount);
    if (0 == uNewCount)
	{
		delete this ;
	}

    return uNewCount;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizerCallResult::GetResultObject(
    /*[in]*/  long lTimeout,
    /*[out]*/ IWbemClassObject** ppResultObject
    )
{
	if(!m_Security.AccessCheck())
		return WBEM_E_ACCESS_DENIED;
	if ( ( ppResultObject==NULL ) || (lTimeout < 0 && lTimeout != WBEM_INFINITE) )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}

	if (!m_bGotObject)
	{
		HRESULT hrResult = WBEM_S_NO_ERROR;
		HRESULT hr = m_pFinalizer->GetOperationResult(0, lTimeout, &hrResult);
		if (FAILED(hr))
		{
		    return WBEM_E_FAILED;
		}
		else if (hr == WBEM_S_TIMEDOUT)
		{
		    return WBEM_S_TIMEDOUT;
		}
		else if(FAILED(hrResult))
		{
		    return hrResult;
		}

		if (FAILED(hrResult))
			SetErrorInfo();

		{
			CWmiFinalizerObj *pFinalizerObj=NULL;
            bool bFinished = false;
            HRESULT hRes = WBEM_E_NOT_FOUND;
            while (!bFinished)
            {
			    hRes = m_pFinalizer->GetNextObject(&pFinalizerObj);
			    if (FAILED(hRes))
			    {
				    return WBEM_E_FAILED;
				}
			    else if (hRes == WBEM_S_FALSE)
			    {
				    return WBEM_S_TIMEDOUT;
				}

			    if (pFinalizerObj->m_objectType == CWmiFinalizerObj::object)
			    {
				    m_bGotObject = true;
				    m_pObj = pFinalizerObj->m_pObj;

				    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					// Catch any nasty attempts to crash WinMgmt through bad
					// pointers.
				    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					try
					{
						*ppResultObject = pFinalizerObj->m_pObj;
					}
					catch (...)
					{
				        ExceptionCounter c;
						delete pFinalizerObj;
						return WBEM_E_INVALID_PARAMETER;
					}

				    if ( pFinalizerObj->m_pObj )
				    {
					    //Need 2 add-refs, one because we hold on to it, the other because we pass it back to the user!
					    pFinalizerObj->m_pObj->AddRef();
					    pFinalizerObj->m_pObj->AddRef();
				    }
                    bFinished = true;
			    }
			    else if ((pFinalizerObj->m_objectType == CWmiFinalizerObj::status) && (pFinalizerObj->m_lFlags == WBEM_STATUS_COMPLETE))
                {
				    hrResult = pFinalizerObj->m_hRes;
                    bFinished = true;
                }
                else if (pFinalizerObj->m_objectType == CWmiFinalizerObj::status)
                {
                    //We have a non-completion status object...
                }

			    delete pFinalizerObj;
            }
		}
		return hrResult;
	}
	else
	{
	    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Catch any nasty attempts to crash WinMgmt through bad
		// pointers.
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		try
		{	
     		m_pObj->AddRef();
			*ppResultObject = m_pObj;			
		}
		catch (...)
		{
            ExceptionCounter c;		
			m_pObj->Release ();
			return WBEM_E_INVALID_PARAMETER;
		}
		return WBEM_S_NO_ERROR;
	}
}


//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizerCallResult::GetResultString(
    /*[in]*/  long lTimeout,
    /*[out]*/ BSTR* pstrResultString
    )
{
	if(!m_Security.AccessCheck())
		return WBEM_E_ACCESS_DENIED;
	if ( ( pstrResultString==NULL ) || (lTimeout < 0 && lTimeout != WBEM_INFINITE) )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}

	
	HRESULT hrResult;
	HRESULT hr = m_pFinalizer->GetOperationResult(0, lTimeout, &hrResult);
	if (hr != WBEM_S_NO_ERROR)
		return hr;
	
	if (FAILED(hrResult))
		SetErrorInfo();

    //
    // BUGBUG duplicated code SysAllocString takes NULL
    //
    if(m_strParam)
    {
		try
		{		    
			*pstrResultString = SysAllocString(m_strParam);
		}
		catch (...)
		{
            ExceptionCounter c;		
			return WBEM_E_INVALID_PARAMETER;
		}

        hr = WBEM_S_NO_ERROR;
    }
    else
    {
		try
		{
			*pstrResultString = NULL;
		}
		catch (...)
		{
	        ExceptionCounter c;		
			return WBEM_E_INVALID_PARAMETER;
		}
		if ( SUCCEEDED (hrResult) )
		{
			hr = WBEM_E_INVALID_OPERATION;
		}
		else
		{
			hr = hrResult;
		}
    }
	return hr;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizerCallResult::GetResultServices(
    /*[in]*/  long lTimeout,
    /*[out]*/ IWbemServices** ppServices
    )
{
	if(!m_Security.AccessCheck())
		return WBEM_E_ACCESS_DENIED;
	if ( ( ppServices==NULL ) || (lTimeout < 0 && lTimeout != WBEM_INFINITE) )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}

	if (!m_bGotServices)
	{
		HRESULT hrResult;
		HRESULT hr = m_pFinalizer->GetOperationResult(0, lTimeout, &hrResult);
		if (hr != WBEM_S_NO_ERROR)
			return hr;

		if (FAILED(hrResult))
			SetErrorInfo();

		if (SUCCEEDED(hrResult))
		{
			CWmiFinalizerObj *pFinalizerObj=NULL;
			HRESULT hRes = m_pFinalizer->GetNextObject(&pFinalizerObj);
			if (FAILED(hRes))
				return hRes;
			if ( hRes==WBEM_S_FALSE )
				return WBEM_E_NOT_FOUND;

			m_bGotServices = true;
			m_pServices = (IWbemServices*)pFinalizerObj->m_pvObj;

			if (ppServices)
			{
				try
				{
					*ppServices = (IWbemServices*)pFinalizerObj->m_pvObj;
				}
				catch (...)
				{
			        ExceptionCounter c;				
					delete pFinalizerObj;
					return WBEM_E_INVALID_PARAMETER;
				}
				if ( pFinalizerObj->m_pvObj )
				{
					//Need 2 add-refs, one because we hold on to it, the other because we pass it back to the user!
					((IWbemServices*)pFinalizerObj->m_pvObj)->AddRef();
					((IWbemServices*)pFinalizerObj->m_pvObj)->AddRef();
				}
			}
			delete pFinalizerObj;
		}
		return hrResult;
	}
	else
	{
		try
		{
			*ppServices = m_pServices;
		}
		catch (...)
		{
	        ExceptionCounter c;		
			return WBEM_E_INVALID_PARAMETER;
		}
		return WBEM_NO_ERROR;
	}
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizerCallResult::GetCallStatus(
    /*[in]*/  long lTimeout,
    /*[out]*/ long* plStatus
    )
{
	if(!m_Security.AccessCheck())
		return WBEM_E_ACCESS_DENIED;
	if ( (plStatus == NULL) || (lTimeout < 0 && lTimeout != WBEM_INFINITE) )
		return WBEM_E_INVALID_PARAMETER;

	
	HRESULT hrResult;
	HRESULT hr = m_pFinalizer->GetOperationResult(0, lTimeout, &hrResult);
	if (hr != WBEM_S_NO_ERROR)
	{
		return hr;
	}
	
	try
	{
		*plStatus = hrResult;
	}
	catch (...)
	{
        ExceptionCounter c;	
		return WBEM_E_INVALID_PARAMETER;
	}

    if(FAILED(hrResult))
    {
        SetErrorInfo();
    }

	return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizerCallResult::GetResult(
    /*[in]*/ long lTimeout,
    /*[in]*/ long lFlags,
    /*[in]*/ REFIID riid,
    /*[out, iid_is(riid)]*/ void **ppvResult
    )
{
	if(!m_Security.AccessCheck())
		return WBEM_E_ACCESS_DENIED;
	if (ppvResult==NULL || (lTimeout < 0 && lTimeout != WBEM_INFINITE) )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}

	HRESULT hrResult;
	HRESULT hr = m_pFinalizer->GetOperationResult(0, lTimeout, &hrResult);
	if (hr != WBEM_S_NO_ERROR)
		return hr;
	
	if (FAILED(hrResult))
		SetErrorInfo();

	if (SUCCEEDED(hrResult))
	{
		CWmiFinalizerObj *pFinalizerObj=NULL;
		HRESULT hRes = m_pFinalizer->GetNextObject(&pFinalizerObj);
		if (FAILED(hRes))
			return hRes;
	
		if ( hRes == WBEM_S_FALSE )
			return WBEM_E_NOT_FOUND;


		if (ppvResult)
		{
			if (pFinalizerObj->m_iid == riid)
			{
				try
				{
					*ppvResult = pFinalizerObj->m_pvObj;
				}
				catch (...)
				{
			        ExceptionCounter c;				
					delete pFinalizerObj;
					return WBEM_E_INVALID_PARAMETER;
				}
			}
			else
				hrResult = WBEM_E_FAILED;

			if ( pFinalizerObj->m_pObj )
			{
				pFinalizerObj->m_pObj->AddRef();
			}
		}
		delete pFinalizerObj;
	}

	return hrResult;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizerCallResult::SetStatus(
    /*[in]*/ long lFlags,
    /*[in]*/ HRESULT hResult,
    /*[in]*/ BSTR strParam,
    /*[in]*/ IWbemClassObject* pObjParam
    )
{
	if (m_lFlags != -1)
	{
		SysFreeString(m_strParam);
		m_strParam = 0;
	}
	if (strParam)
	{
		m_strParam = SysAllocString(strParam);
		if (m_strParam == NULL)
			return WBEM_E_OUT_OF_MEMORY;
	}
	m_lFlags = lFlags;
    m_hResult = hResult;
	
	if ( m_pErrorObj )
	{
		m_pErrorObj->Release ( );
	}
	m_pErrorObj = pObjParam;

	if (m_pErrorObj)
	{
		m_pErrorObj->AddRef();
	}

	return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
void CWmiFinalizer::Dump(FILE* f)
{
    fprintf(f, "--Finalizer Stats---\n");
    fprintf(f, "  s_Finalizer_ObjectCount             = %d\n", s_Finalizer_ObjectCount);
    fprintf(f, "  s_FinalizerCallResult_ObjectCount   = %d\n", s_FinalizerCallResult_ObjectCount);
    fprintf(f, "  s_FinalizerEnum_ObjectCount         = %d\n", s_FinalizerEnum_ObjectCount);
    fprintf(f, "  s_FinalizerEnumSink_ObjectCount     = %d\n", s_FinalizerEnumSink_ObjectCount);
    fprintf(f, "  s_FinalizerInBoundSink_ObjectCount  = %d\n\n", s_FinalizerInBoundSink_ObjectCount);
}


//***************************************************************************
//
//***************************************************************************

void CWmiFinalizerCallResult::SetErrorInfo()
{
    if(m_pErrorObj)
    {
        IErrorInfo* pInfo = NULL;
        m_pErrorObj->QueryInterface(IID_IErrorInfo, (void**)&pInfo);
		::SetErrorInfo(0, pInfo);
		pInfo->Release();
    }
}


//***************************************************************************
//							CWmiFinalizerObj Methods
//***************************************************************************


/*
    * ==================================================================================================
	|
	| CWmiFinalizerObj::CWmiFinalizerObj(IWbemClassObject *pObj, _IWmiFinalizer* pFin ) 
	| ---------------------------------------------------------------------------------
	| 
	|
	| 
	|
	* ==================================================================================================
*/

CWmiFinalizerObj::CWmiFinalizerObj(IWbemClassObject *pObj, _IWmiFinalizer* pFin ) : m_pObj(pObj), 
																					m_objectType(object), 
																					m_lFlags(0), 
																					m_bStr(0), 
																					m_hRes(0) , 
																					m_pvObj(0), 
																					m_pFin ( pFin ),
																					m_hArb ( WBEM_S_ARB_NOTHROTTLING )
{
#ifdef __DBG_FINALIZER
	InterlockedIncrement ( &g_DbgFinalizerTotalObjCount ) ;
#endif

	if (m_pObj) 
	{
		m_pObj->AddRef();
		CWbemObject* pObjTmp = (CWbemObject*) pObj;
		if ( pObjTmp )
		{

#ifdef __DBG_FINALIZER
			if ( m_objectType == CWmiFinalizerObj::object )
			{
				_DBG_ASSERT ( m_pFin ) ;
			}			
#endif

			m_uSize = pObjTmp -> GetBlockLength();
			if ( m_pFin )
			{
				m_hArb = ((CWmiFinalizer*)m_pFin)->ReportMemoryUsage ( 0, m_uSize ) ;

#ifdef __DBG_FINALIZER
				InterlockedExchangeAdd ( &g_DbgFinalizerTotalObjSize, m_uSize ) ;
#endif
			}
		}
		else
		{
			m_uSize = 0;
		}

	}
}



/*
    * ==================================================================================================
	|
	| CWmiFinalizerObj::CWmiFinalizerObj (CWmiFinalizerObj& obj)
	| ----------------------------------------------------------
	| 
	| Copyconstructor for CWmiFinalizerObj. This is ONLY used on restartable enumerators.
	| Since we keep the objects in the queue when someone grabs an object on a restartable
	| enumerator we dont account for this memory to avoid misreporting memory due to 
	| destruction of finalizer.
	| 
	|
	* ==================================================================================================
*/

CWmiFinalizerObj::CWmiFinalizerObj (CWmiFinalizerObj& obj)
{
	m_pvObj = obj.m_pvObj;
	m_iid = obj.m_iid;
	m_uSize = obj.m_uSize;
	m_pFin = NULL ;
	m_hArb = obj.m_hArb ;
	
	if (m_pvObj)
	{
		if (m_iid == IID_IUnknown)
		{
			((IUnknown*)m_pvObj)->AddRef();
		}
		else if (m_iid == IID_IWbemClassObject)
		{
			((IWbemClassObject*)m_pvObj)->AddRef();
		}
		else if (m_iid == IID__IWmiObject)
		{
			((_IWmiObject*)m_pvObj)->AddRef();
		}
		else if (m_iid == IID_IWbemServices)
		{
			((IWbemServices*)m_pvObj)->AddRef();
		}
		else if (m_iid == IID_IWbemServicesEx)
		{
			((IWbemServicesEx*)m_pvObj)->AddRef();
		}
	}
	m_pObj = obj.m_pObj;
	m_objectType = obj.m_objectType;
	m_lFlags = obj.m_lFlags;
	if (obj.m_bStr)
		m_bStr = SysAllocString(obj.m_bStr);
	else
		m_bStr = NULL;
	m_hRes = obj.m_hRes;

	if (m_pObj)
		m_pObj->AddRef();

}


/*
    * ==================================================================================================
	|
	| CWmiFinalizerObj(ULONG lFlags, REFIID riid, void *pvObj) 
	| --------------------------------------------------------
	| 
	| 
	|
	* ==================================================================================================
*/

CWmiFinalizerObj::CWmiFinalizerObj(ULONG lFlags, REFIID riid, void *pvObj) : 	m_pObj(0), 
																				m_objectType(set), 
																				m_lFlags(lFlags), 
																				m_bStr(0), 
																				m_hRes(0), 
																				m_pvObj(pvObj), 
																				m_iid(riid), 
																				m_pFin ( NULL ),
																				m_hArb ( WBEM_S_ARB_NOTHROTTLING )
{
	m_uSize = 0;
	if (m_iid == IID_IUnknown)
	{
		((IUnknown*)m_pvObj)->AddRef();
	}
	else if (m_iid == IID_IWbemClassObject)
	{
		((IWbemClassObject*)m_pvObj)->AddRef();
	}
	else if (m_iid == IID__IWmiObject)
	{
		((_IWmiObject*)m_pvObj)->AddRef();
	}
	else if (m_iid == IID_IWbemServices)
	{
		((IWbemServices*)m_pvObj)->AddRef();
	}
	else if (m_iid == IID_IWbemServicesEx)
	{
		((IWbemServicesEx*)m_pvObj)->AddRef();
	}
	else
	{
		memset(&m_iid, 0, sizeof(IID));
		m_pvObj = 0;
		m_objectType = unknown;
	}
}


/*
    * ==================================================================================================
	|
	| CWmiFinalizerObj(ULONG lFlags, HRESULT hRes, BSTR bStr, IWbemClassObject *pObj) 
	| -------------------------------------------------------------------------------
	| 
	| 
	|
	* ==================================================================================================
*/

CWmiFinalizerObj::CWmiFinalizerObj(ULONG lFlags, HRESULT hRes, BSTR bStr, IWbemClassObject *pObj) : m_pObj(pObj), 
																								    m_objectType(status), 
																								    m_lFlags(lFlags), 
																								    m_hRes(hRes), 
																								    m_pvObj(0), 
																								    m_pFin ( NULL ) ,
																									m_hArb ( WBEM_S_ARB_NOTHROTTLING )
{
	m_uSize = 0;
	if (bStr)
		m_bStr = SysAllocString(bStr);
	else
		m_bStr = NULL;

	if (m_pObj)
		m_pObj->AddRef();
}




/*
    * ==================================================================================================
	|
	| CWmiFinalizerObj::~CWmiFinalizerObj ( )
	| ---------------------------------------
	| 
	|
	* ==================================================================================================
*/

CWmiFinalizerObj::~CWmiFinalizerObj ( )
{
	if (m_bStr) 
	{
		SysFreeString(m_bStr);
	}

	if (m_pObj) 
	{
		m_pObj->Release();
		m_pObj = NULL ;
	}

	if (m_pvObj)
	{
		if (m_iid == IID_IUnknown)
		{
			((IUnknown*)m_pvObj)->Release();
		}
		else if (m_iid == IID_IWbemClassObject)
		{
			((IWbemClassObject*)m_pvObj)->Release();
		}
		else if (m_iid == IID__IWmiObject)
		{
			((_IWmiObject*)m_pvObj)->Release();
		}
		else if (m_iid == IID_IWbemServices)
		{
			((IWbemServices*)m_pvObj)->Release();
		}
		else if (m_iid == IID_IWbemServicesEx)
		{
			((IWbemServicesEx*)m_pvObj)->Release();
		}
		m_pvObj = NULL ;
	}

	if ( m_pFin )
	{
#ifdef __DBG_FINALIZER
		InterlockedDecrement ( &g_DbgFinalizerTotalObjCount ) ;
		InterlockedExchangeAdd ( &g_DbgFinalizerTotalObjSize, -m_uSize ) ;
#endif	

		((CWmiFinalizer*)m_pFin)->ReportMemoryUsage ( 0, -m_uSize ) ;
		m_pFin = NULL ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\wmitask.cpp ===
//***************************************************************************
//
//  WMITASK.CPP
//
//  raymcc  23-Apr-00       First oversimplified draft for Whistler
//
//***************************************************************************
#include "precomp.h"

#include <windows.h>
#include <stdio.h>
#include <wbemcore.h>
#include <wmiarbitrator.h>
#include <wmifinalizer.h>
#include <context.h>

static ULONG g_uNextTaskId = 1;
static LONG  g_uTaskCount = 0;

#ifdef DBG
  #define __DBG_TASK
#endif

extern ULONG g_ulClientCallbackTimeout ;

//#define TASK_DETAIL_TRACKING


//***************************************************************************
//
//***************************************************************************

CCritSec CWmiTask::m_TaskCs;

CWmiTask* CWmiTask::CreateTask ( )
{
	return new CWmiTask ( ) ;
}

//***************************************************************************
//
//***************************************************************************

CWmiTask::CWmiTask ( )
{
	m_hResult = WBEM_E_CALL_CANCELLED ;
	m_uRefCount = 1;
    m_uTaskType = 0;
    m_uTaskStatus = 0;
    m_uStartTime = 0;
    m_uUpdateTime = 0;
    m_uTaskId = InterlockedIncrement((LONG *) &g_uNextTaskId);
    InterlockedIncrement((LONG *)&g_uTaskCount);
    m_pUser = 0;
    m_pNs = 0;
    m_pAsyncClientSink = 0;
    m_pWorkingFnz = 0;
    m_pReqSink = 0;
    m_uMemoryUsage = 0;
    m_uTotalSleepTime = 0;
    m_uCancelState = FALSE;
    m_uLastSleepTime = 0;
    m_hTimer = NULL;
    m_pMainCtx = 0;
	m_hCompletion = NULL ;
	m_bReqSinkInitialized = FALSE ;
	m_bAccountedForThrottling = FALSE ;
	m_bCancelledDueToThrottling = FALSE ;

}

//***************************************************************************
//
//  CWmiTask::~CWmiTask
//
//***************************************************************************
//
CWmiTask::~CWmiTask()
{
    int i;

    CCheckedInCritSec _cs ( &m_csTask );

	if ( m_pUser )
	{
		_cs.Leave ( ) ;
		m_pUser->Release ( ) ;
		_cs.Enter ( ) ;
		m_pUser = NULL ;
	}

	if ( m_pNs )
	{
		_cs.Leave ( ) ;
		m_pNs->Release ( ) ;
		_cs.Enter ( ) ;
		m_pNs = NULL ;
	}

	if ( m_pAsyncClientSink )
	{
		_cs.Leave ( ) ;
		m_pAsyncClientSink->Release ( ) ;
		_cs.Enter ( ) ;
		m_pAsyncClientSink = NULL ;
	}

	if ( m_pReqSink )
	{
		_cs.Leave ( ) ;
		m_pReqSink->Release ( ) ;
		_cs.Enter ( ) ;
		m_pReqSink = NULL ;
	}

	if ( m_pMainCtx )
	{
		_cs.Leave ( ) ;
		m_pMainCtx->Release ( ) ;
		_cs.Enter ( ) ;
		m_pMainCtx = NULL ;
	}

    // Release all provider/sink bindings.
    // ===================================

    for (i = 0; i < m_aTaskProviders.Size(); i++)
    {
        STaskProvider *pTP = (STaskProvider *) m_aTaskProviders[i];
        if (pTP)
            delete pTP;
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Release all Arbitratees
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	ReleaseArbitratees ( ) ;
    
    InterlockedDecrement((LONG *)&g_uTaskCount);

	if ( m_hTimer )
	{
		CloseHandle ( m_hTimer );
		m_hTimer = NULL ;
	}

	if ( m_hCompletion )
	{
		CloseHandle ( m_hCompletion ) ;
		m_hCompletion = NULL ;
	}
}



/*
    * =============================================================================
	|
	| HRESULT CWmiTask::SignalCancellation ( )
	| ----------------------------------------
	| 
	| Signals the task to be cancelled
	|
	|
	* =============================================================================
*/

HRESULT CWmiTask::SignalCancellation ( )
{
	HRESULT hRes = WBEM_S_NO_ERROR ;	

	{
		CInCritSec _cs ( &m_csTask );
	
		if ( ( m_uTaskStatus != WMICORE_TASK_STATUS_CANCELLED ) && ( m_hTimer != NULL ) )
		{
			SetEvent ( m_hTimer ) ;
		}
	}
	return hRes ;
}





/*
    * =============================================================================
	|
	| HRESULT CWmiTask::SetTaskResult ( HRESULT hRes ) 
	| -------------------------------------------------
	| 
	| Sets the task result
	|
	|
	* =============================================================================
*/

HRESULT CWmiTask::SetTaskResult ( HRESULT hResult ) 
{
	HRESULT hRes = WBEM_S_NO_ERROR ;

	m_hResult = hResult ;
	return hRes ;
}


/*
    * =============================================================================
	|
	| HRESULT CWmiTask::UpdateMemoryUsage ( LONG lDelta )
	| ---------------------------------------------------
	| 
	| Updates the task memory usage
	|
	|
	* =============================================================================
*/

HRESULT CWmiTask::UpdateMemoryUsage ( LONG lDelta )
{
	CInCritSec _cs ( &m_csTask );

	m_uMemoryUsage += lDelta ;

	return WBEM_S_NO_ERROR;
}



/*
    * =============================================================================
	|
	| HRESULT CWmiTask::UpdateTotalSleepTime ( ULONG uSleepTime )
	| -----------------------------------------------------------
	| 
	| Updates the tasks sleep time
	|
	|
	* =============================================================================
*/

HRESULT CWmiTask::UpdateTotalSleepTime ( ULONG uSleepTime )
{
	CInCritSec _cs ( &m_csTask );

	m_uTotalSleepTime += uSleepTime ;
	return WBEM_S_NO_ERROR;
}



/*
    * =============================================================================
	|
	| HRESULT CWmiTask::ReleaseArbitratees ( )
	| ----------------------------------------
	| 
	| Releases all the arbitratees (Finalizer, Merger currently)
	|
	| 
	|
	| 
	|
	* =============================================================================
*/

HRESULT CWmiTask::ReleaseArbitratees ( )
{
	HRESULT hRes = WBEM_S_NO_ERROR ;

	CInCritSec _cs ( &m_csTask );

    for (ULONG i = 0; i < m_aArbitratees.Size(); i++)
    {
        _IWmiArbitratee *pArbee = NULL ;
		pArbee = (_IWmiArbitratee*) m_aArbitratees[i];
        if ( pArbee )
        {
            pArbee->Release ( );
        }
    }
	m_aArbitratees.Empty ( ) ;
	
	return hRes ;
}



//***************************************************************************
//
//***************************************************************************
HRESULT CWmiTask::SetRequestSink(CStdSink *pReqSink)
{
    if (pReqSink == 0)
        return WBEM_E_INVALID_PARAMETER;
    if (m_pReqSink != 0)
        return WBEM_E_INVALID_OPERATION;

    CInCritSec _cs ( &m_csTask );
    pReqSink->AddRef ( ) ;
    m_pReqSink = pReqSink;

	m_bReqSinkInitialized = TRUE ;
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
// *
ULONG CWmiTask::AddRef()
{
    InterlockedIncrement((LONG *) &m_uRefCount);
    return m_uRefCount;
}

//***************************************************************************
//
//***************************************************************************
// *
ULONG CWmiTask::Release()
{
    ULONG uNewCount = InterlockedDecrement((LONG *) &m_uRefCount);
    if (0 != uNewCount)
        return uNewCount;
    delete this;
    return 0;
}

//***************************************************************************
//
//***************************************************************************
// *
HRESULT CWmiTask::QueryInterface(
    IN REFIID riid,
    OUT LPVOID *ppvObj
    )
{
    *ppvObj = 0;

    if (IID_IUnknown==riid || IID__IWmiCoreHandle==riid)
    {
        *ppvObj = (_IWmiCoreHandle *)this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//***************************************************************************
//
//***************************************************************************
// *
HRESULT CWmiTask::GetHandleType(
    ULONG *puType
    )
{
    *puType = WMI_HANDLE_TASK;
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
// *
HRESULT CWmiTask::Initialize(
    IN CWbemNamespace *pNs,
    IN ULONG uTaskType,
    IN IWbemContext *pCtx,
    IN IWbemObjectSink *pAsyncClientSinkCopy
    )
{
    HRESULT hRes;

    if (pNs == 0 || pCtx == 0)
        return WBEM_E_INVALID_PARAMETER;

    m_pNs = pNs;
    m_pNs->AddRef();

    m_uTaskType = uTaskType;
    m_uStartTime = GetCurrentTime();

    // See if the task is primary or not.
    // ==================================
/*
    if (pCtx)
    {
        IWbemCausalityAccess* pCA = NULL;
        pCtx->QueryInterface(IID_IWbemCausalityAccess, (void**)&pCA);
        if (pCA)
        {
            REQUESTID id;
            hRes = pCA->GetParentId(&id);
            if (hRes == S_FALSE)
                m_uTaskType |= WMICORE_TASK_TYPE_PRIMARY;
            else
                m_uTaskType |= WMICORE_TASK_TYPE_DEPENDENT;
            pCA->Release();
        }
        else
            m_uTaskType |= WMICORE_TASK_TYPE_PRIMARY;

    }
    else
    {
        m_uTaskType |= WMICORE_TASK_TYPE_PRIMARY;
    }
*/
    if (pCtx)
    {
        CWbemContext *pContext = (CWbemContext *) pCtx;

        GUID ParentId = GUID_NULL, RequestId = GUID_NULL;
        LONG lNumParents = 0;
        LONG lNumChildren = 0;

        pContext->GetParentId(&ParentId);
        pContext->GetRequestId(&RequestId);
        pContext->GetHistoryInfo(&lNumParents, &lNumChildren);

        if (ParentId != GUID_NULL)
        {
            m_uTaskType |= WMICORE_TASK_TYPE_DEPENDENT;
        }
        else
            m_uTaskType |= WMICORE_TASK_TYPE_PRIMARY;

        m_pMainCtx = (CWbemContext *) pCtx;
        m_pMainCtx->AddRef();
    }
    else
    {
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// If we dont have a context check to see if the namespace is an ESS or Provider
		// initialized namespace, if so, set the task type to dependent.
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		if ( pNs->GetIsESS ( ) || pNs->GetIsProvider ( ) )
		{
			m_uTaskType |= WMICORE_TASK_TYPE_DEPENDENT;
		}
		else
		{
			m_uTaskType |= WMICORE_TASK_TYPE_PRIMARY;
		}
    }


    if ((uTaskType & WMICORE_TASK_TYPE_ASYNC) && pAsyncClientSinkCopy)
    {
        m_pAsyncClientSink = pAsyncClientSinkCopy;
        m_pAsyncClientSink->AddRef();
    }
    else
        m_pAsyncClientSink = 0;


    // Register this task with Arbitrator.
    // ====================================

    _IWmiArbitrator *pArb = CWmiArbitrator::GetUnrefedArbitrator();
    if (!pArb)
        return WBEM_E_CRITICAL_ERROR;

    hRes = pArb->RegisterTask(this);
    if (FAILED(hRes))
        return hRes;

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiTask::SetFinalizer(_IWmiFinalizer *pFnz)
{
    if (pFnz == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (m_pWorkingFnz)
        return WBEM_E_INVALID_OPERATION;

    m_pWorkingFnz = pFnz;
    m_pWorkingFnz->AddRef();

    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiTask::GetFinalizer(_IWmiFinalizer **ppFnz)
{

	CInCritSec	ics( &m_csTask );

	for ( int x = 0; x < m_aArbitratees.Size(); x++ )
	{
		_IWmiArbitratee*	pArbitratee = (_IWmiArbitratee*) m_aArbitratees[x];

		if ( SUCCEEDED( pArbitratee->QueryInterface( IID__IWmiFinalizer, (void**) ppFnz ) ) )
		{
			break;
		}
	}

    return ( x < m_aArbitratees.Size() ? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND );
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiTask::AddArbitratee( ULONG uFlags, _IWmiArbitratee* pArbitratee )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    if (pArbitratee == 0)
        return WBEM_E_INVALID_PARAMETER;

    int nRes = CFlexArray::no_error;
    {
        CInCritSec _cs ( &m_csTask );
        nRes = m_aArbitratees.Add (pArbitratee);
    }

    if ( nRes != CFlexArray::no_error )
    {
        hRes = WBEM_E_OUT_OF_MEMORY;
    }
    else
    {
        pArbitratee->AddRef();
    }


    return hRes;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiTask::RemoveArbitratee( ULONG uFlags, _IWmiArbitratee* pArbitratee )
{
    HRESULT hRes = WBEM_E_FAILED;

    if (pArbitratee == 0)
        return WBEM_E_INVALID_PARAMETER;

    CInCritSec _cs ( &m_csTask );
    for (int i = 0; i < m_aArbitratees.Size(); i++)
    {
        _IWmiArbitratee *pArbee = (_IWmiArbitratee*) m_aArbitratees[i];

        if (pArbee == pArbitratee)
        {
            m_aArbitratees.RemoveAt(i);
            pArbee->Release();
            hRes = WBEM_S_NO_ERROR;
            break;
        }
    }
    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiTask::GetArbitratedQuery( ULONG uFlags, _IWmiArbitratedQuery** ppArbitratedQuery )
{
    HRESULT hRes = E_NOINTERFACE;

    if (ppArbitratedQuery == 0)
        return WBEM_E_INVALID_PARAMETER;

    {
        CInCritSec _cs ( &m_csTask );

		for ( int x = 0; FAILED( hRes ) && x < m_aArbitratees.Size(); x++ )
		{
			_IWmiArbitratee* pArb = (_IWmiArbitratee*) m_aArbitratees[x];

			if ( NULL != pArb )
			{
				hRes = pArb->QueryInterface( IID__IWmiArbitratedQuery, (void**) ppArbitratedQuery );
			}
		}

    }

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
HRESULT CWmiTask::GetPrimaryTask ( _IWmiCoreHandle** pPTask )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    if ( pPTask == NULL )
    {
        hRes = WBEM_E_INVALID_PARAMETER;
    }
    else
    {
        *pPTask = (_IWmiCoreHandle*) this;
    }
    return hRes;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiTask::Cancel( HRESULT hResParam )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

	BOOL bCancelled = FALSE ;

	// We'll want one of these in order to track statuses from all plausible locations if
	// we are performing a client originated cancel
	CStatusSink*	pStatusSink = NULL;
	
	if ( hResParam == WMIARB_CALL_CANCELLED_CLIENT )
	{
		pStatusSink = new CStatusSink;

		if ( NULL == pStatusSink )
		{
			return WBEM_E_OUT_OF_MEMORY;
		}

	}	// IF Client originated the call

	// Auto Release
	CReleaseMe	rmStatusSink( pStatusSink );

    {
		CCheckedInCritSec _cs ( &m_csTask );
		if (m_uTaskStatus == WMICORE_TASK_STATUS_CANCELLED)
		{
			return WBEM_S_NO_ERROR; // Prevent reentrancy
		}
		m_uTaskStatus = WMICORE_TASK_STATUS_CANCELLED;
	}

    // Change this to an async scheduled request
    // ==========================================

    if (CORE_TASK_TYPE(m_uTaskType) == WMICORE_TASK_EXEC_NOTIFICATION_QUERY)
    {
        CAsyncReq_RemoveNotifySink *pReq = new
            CAsyncReq_RemoveNotifySink(m_pReqSink, pStatusSink);
        if (!pReq)
		{
			return WBEM_E_OUT_OF_MEMORY;
		}
		else if ( NULL != pReq->GetContext() )
		{

			pReq->SetForceRun ( 1 ) ;

			// If we have a status sink, then we should wait until the operation
			// completes before continuing so we can get the proper status from the
			// sink.
			if ( NULL != pStatusSink )
			{
				hRes = ConfigMgr::EnqueueRequestAndWait(pReq);
			}
			else
			{
				hRes = ConfigMgr::EnqueueRequest(pReq);
			}
			bCancelled = TRUE ;

		}	// ELSEIF NULL != pReq->GetContext()
		else
		{
			delete pReq;
			return WBEM_E_OUT_OF_MEMORY;
		}
    }

    // If here, a normal task.  Loop through any providers and stop them.
    // ==================================================================
	CFlexArray	aTempProviders;

	// This could change while we're accessing, so do this in a critsec
	{
		CInCritSec	ics( &m_csTask );

		for (int i = 0; SUCCEEDED( hRes ) && i < m_aTaskProviders.Size(); i++)
		{
			if ( aTempProviders.Add( m_aTaskProviders[i] ) != CFlexArray::no_error )
			{
				hRes = WBEM_E_OUT_OF_MEMORY;
			}
		}	// FOR i= 0;

	}	// SCOPED critsec

	// Cancel what we've got
	for (int i = 0; i < aTempProviders.Size(); i++)
	{
		STaskProvider *pTP = (STaskProvider *) aTempProviders[i];
		if (pTP)
		{
			pTP->Cancel( pStatusSink );
		}
	}


 	CStdSink* pTempSink = NULL;
    {
        CInCritSec _cs ( &m_csTask );
        if (m_pReqSink)
        {
            pTempSink = m_pReqSink;
            pTempSink->AddRef ( );
            m_pReqSink->Release ( );
            m_pReqSink = 0;
        }
    }

    if ( pTempSink )
    {
        pTempSink->Cancel();
        pTempSink->Release();
    }

    // 
    // Loop through all arbitratees and set the operation result to cancelled
    // 
	if ( SUCCEEDED ( hRes ) )
	{
		if ( bCancelled == FALSE )
		{
			if ( !m_hCompletion && hResParam == WMIARB_CALL_CANCELLED_CLIENT )
			{
				m_hCompletion = CreateEvent ( NULL, TRUE, FALSE, NULL ) ;
				if ( m_hCompletion == NULL )
				{
					hRes = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			_IWmiFinalizer* pFinalizer = NULL ;
			if ( SUCCEEDED ( hRes ) )
			{
				if ( m_hCompletion && hResParam == WMIARB_CALL_CANCELLED_CLIENT )
				{
					//
					// We need the finalizer to set the client wakeup event
					// 
					hRes = GetFinalizer ( &pFinalizer ) ;
					if ( FAILED (hRes) )
					{
						hRes = WBEM_E_FAILED ;
					}
					else
					{
						((CWmiFinalizer*)pFinalizer)->SetClientCancellationHandle ( m_hCompletion ) ;
					}
				}
			}
			CReleaseMe FinalizerRelease ( pFinalizer ) ;

			//
			// only enter wait state if we successfully created and set the client wait event
			//
			if ( SUCCEEDED ( hRes ) )
			{
				if ( hResParam == WMIARB_CALL_CANCELLED_CLIENT || hResParam == WMIARB_CALL_CANCELLED_THROTTLING )
				{
					hRes = SetArbitrateesOperationResult ( 0, WBEM_E_CALL_CANCELLED_CLIENT ) ;
				}
				else
				{
					hRes = SetArbitrateesOperationResult ( 0, m_hResult ) ;
				}
				
				if ( m_hCompletion && hResParam == WMIARB_CALL_CANCELLED_CLIENT )
				{
					if ( ((CWmiFinalizer*)pFinalizer)->IsValidDestinationSink ( ) )
					{
						DWORD dwRet = CCoreQueue::QueueWaitForSingleObject ( m_hCompletion, g_ulClientCallbackTimeout ) ;
						if (dwRet == WAIT_TIMEOUT)
						{
							hRes = WBEM_S_TIMEDOUT ;
						}
					}
					
					((CWmiFinalizer*)pFinalizer)->CancelWaitHandle ( ) ;
			
					if ( m_hCompletion )
					{
						CloseHandle ( m_hCompletion ) ;
						m_hCompletion = NULL ;
					}
				}
			}
		}
	}
	

	//
	// We're done, get the final status from the status sink if we have one.
	//
	if ( NULL != pStatusSink )
	{
		hRes = pStatusSink->GetLastStatus();
	}

	ReleaseArbitratees ( ) ;
	return hRes ;
}


//***************************************************************************
//
//***************************************************************************
//
STaskProvider::~STaskProvider()
{
    if (m_pProvSink)
        m_pProvSink->LocalRelease();
    ReleaseIfNotNULL(m_pProv);
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT STaskProvider::Cancel( CStatusSink* pStatusSink )
{
	HRESULT hRes = WBEM_S_NO_ERROR ;
    IWbemServices   *pTmpProv = 0;
    CProviderSink   *pTmpProvSink = 0;

    EnterCriticalSection(&CWmiTask::m_TaskCs);
        if (m_pProv != 0)
        {
            pTmpProv = m_pProv;
            m_pProv = 0;
        }
        if (m_pProvSink != 0)
        {
            pTmpProvSink = m_pProvSink;
            m_pProvSink = 0;
        }
    LeaveCriticalSection(&CWmiTask::m_TaskCs);

    if (pTmpProvSink)
    {
        pTmpProvSink->Cancel();
    }

    if (pTmpProv)
    {
		hRes = ExecCancelOnNewRequest ( pTmpProv, pTmpProvSink, pStatusSink ) ;
    }

    ReleaseIfNotNULL(pTmpProv);
    ReleaseIfNotNULL(pTmpProvSink);

    return hRes ;
}

// //////////////////////////////////////////////////////////////////////////////////////////
//
// Used when issuing CancelAsyncCall to providers associtated with the task.
// Rather than calling CancelAsynCall directly on the provider, we create a brand
// new request and execute it on a different thread. We do this to avoid hangs, since
// PSS is waiting the Indicate/SetStatus call to return before servicing the CancelCallAsync.
//
// //////////////////////////////////////////////////////////////////////////////////////////
HRESULT STaskProvider::ExecCancelOnNewRequest ( IWbemServices* pProv, CProviderSink* pSink, CStatusSink* pStatusSink )
{
	HRESULT hRes = WBEM_S_NO_ERROR ;

	//
	// Sanity check on params
	//
	if ( pSink == NULL )
	{
		hRes = WBEM_E_INVALID_PARAMETER ;
	}
	else
	{
        //
		// Create new request
		//
		CAsyncReq_CancelProvAsyncCall* pReq = new CAsyncReq_CancelProvAsyncCall ( pProv, pSink, pStatusSink ) ;

        if ( pReq == NULL )
        {
            hRes = WBEM_E_OUT_OF_MEMORY ;
        }
		else if ( NULL != pReq->GetContext() )
		{
			pReq->SetForceRun ( 1 ) ;
			//
			// Enqueue the request
			//

			// If we have a status sink, then we should wait until the operation
			// completes before continuing so we can get the proper status from the
			// sink.
			if ( NULL != pStatusSink )
			{
				hRes = ConfigMgr::EnqueueRequestAndWait(pReq);
			}
			else
			{
				hRes = ConfigMgr::EnqueueRequest(pReq);
			}

			if ( FAILED ( hRes ) )
			{
				delete pReq ;
			}
		}	// ELSEIF pReq->GetContext() == NULL
		else
		{
			delete pReq;
            hRes = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	return hRes ;
}

//***************************************************************************
//
//***************************************************************************
//
BOOL CWmiTask::IsESSNamespace ( )
{
    BOOL bRet = FALSE;

    if ( m_pNs )
    {
        bRet = m_pNs->GetIsESS ( );
    }

    return bRet;
}



//***************************************************************************
//
//***************************************************************************
//
BOOL CWmiTask::IsProviderNamespace ( )
{
    BOOL bRet = FALSE;

    if ( m_pNs )
    {
        bRet = m_pNs->GetIsProvider ( );
    }

    return bRet;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiTask::AddTaskProv(STaskProvider *p)
{
	CInCritSec	ics( &m_csTask );

	// There is a race condition in which the task could get cancelled just as we
	// are executing. In this case, the task status will indicate that it has been
	// cancelled, so we should not add it to the task providers list.

    if (m_uTaskStatus == WMICORE_TASK_STATUS_CANCELLED)
        return WBEM_E_CALL_CANCELLED; // Prevent reentrancy

    int nRes = m_aTaskProviders.Add(p);
    if (nRes)
        return WBEM_E_OUT_OF_MEMORY;
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiTask::HasMatchingSink(void *Test, IN REFIID riid)
{
    if (LPVOID(m_pAsyncClientSink) == LPVOID(Test))
        return WBEM_S_NO_ERROR;
    return WBEM_E_NOT_FOUND;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiTask::CreateTimerEvent ( )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    {
		CCheckedInCritSec _cs ( &m_csTask );
		if ( !m_hTimer )
		{
			m_hTimer = CreateEvent ( NULL, TRUE, FALSE, NULL );
			if ( !m_hTimer )
			{
				hRes = WBEM_E_OUT_OF_MEMORY;
			}
		}
	}
    return hRes;
}


//***************************************************************************
//
//***************************************************************************
HRESULT CWmiTask::SetArbitrateesOperationResult ( ULONG lFlags, HRESULT hResult )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Set the operation result of all Arbitratees
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    CFlexArray aTmp;
    {
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // First grab all the arbitratees and stick them into
        // a temp array
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        CInCritSec _cs ( &m_csTask );
        for (int i = 0; i < m_aArbitratees.Size(); i++)
        {
            _IWmiArbitratee *pArbee = (_IWmiArbitratee*) m_aArbitratees[i];

            if ( pArbee )
            {
                int nRes = aTmp.Add (pArbee);
                if ( nRes != CFlexArray::no_error )
                {
                    hRes = WBEM_E_OUT_OF_MEMORY;
                    break;
                }
                pArbee->AddRef ( );
            }
        }
    }


    if ( SUCCEEDED (hRes) )
    {
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Clear to set the operation result without problems
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        for (int i = 0; i < aTmp.Size(); i++)
        {
            _IWmiArbitratee *pArbee = (_IWmiArbitratee*) aTmp[i];
            if ( pArbee )
            {
                pArbee->SetOperationResult(lFlags, hResult );
            }
        }
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Now clean everything up
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    for (int i = 0; i < aTmp.Size(); i++)
    {
        _IWmiArbitratee *pArbee = (_IWmiArbitratee*) aTmp[i];
        if ( pArbee )
        {
            pArbee->Release ( );
        }
    }
    return hRes;
}



//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiTask::Dump(FILE* f)
{
    fprintf(f, "---Task = 0x%p----------------------------\n", this);
    fprintf(f, "    Refcount        = %d\n", m_uRefCount);
    fprintf(f, "    TaskStatus      = %u\n ", m_uTaskStatus);
    fprintf(f, "    Task ID         = %u\n", m_uTaskId);

    // Task status
    char *p = "<none>";
    switch(m_uTaskStatus)
    {
        case WMICORE_TASK_STATUS_NEW: p = "WMICORE_TASK_STATUS_NEW"; break;
        case WMICORE_TASK_STATUS_VALIDATED: p = "WMICORE_TASK_STATUS_VALIDATED"; break;
        case WMICORE_TASK_STATUS_SUSPENDED: p = "WMICORE_TASK_STATUS_SUSPENDED"; break;
        case WMICORE_TASK_STATUS_EXECUTING: p = "WMICORE_TASK_STATUS_EXECUTING"; break;
        case WMICORE_TASK_STATUS_WAITING_ON_SUBTASKS: p = "WMICORE_TASK_STATUS_WAITING_ON_SUBTASKS"; break;
        case WMICORE_TASK_STATUS_TIMED_OUT: p = "WMICORE_TASK_STATUS_TIMED_OUT"; break;
        case WMICORE_TASK_STATUS_CORE_COMPLETED: p = "WMICORE_TASK_STATUS_CORE_COMPLETED"; break;
        case WMICORE_TASK_STATUS_CLIENT_COMPLETED: p = "WMICORE_TASK_STATUS_CLIENT_COMPLETED"; break;
        case WMICORE_TASK_STATUS_CANCELLED: p = "WMICORE_TASK_STATUS_CANCELLED"; break;
        case WMICORE_TASK_STATUS_FAILED: p = "WMICORE_TASK_STATUS_FAILED"; break;
    };

    fprintf(f, " %s\n", p);

    // Task type
    p = "<none>";
    switch(m_uTaskType & 0xFF)
    {
        case WMICORE_TASK_NULL: p = "WMICORE_TASK_NULL"; break;
        case WMICORE_TASK_GET_OBJECT: p = "WMICORE_TASK_GET_OBJECT"; break;
        case WMICORE_TASK_GET_INSTANCE: p = "WMICORE_TASK_GET_INSTANCE"; break;
        case WMICORE_TASK_PUT_INSTANCE: p = "WMICORE_TASK_PUT_INSTANCE"; break;
        case WMICORE_TASK_DELETE_INSTANCE: p = "WMICORE_TASK_DELETE_INSTANCE"; break;
        case WMICORE_TASK_ENUM_INSTANCES:  p = "WMICORE_TASK_ENUM_INSTANCES"; break;
        case WMICORE_TASK_GET_CLASS:    p = "WMICORE_TASK_GET_CLASS"; break;
        case WMICORE_TASK_PUT_CLASS:    p = "WMICORE_TASK_PUT_CLASS"; break;
        case WMICORE_TASK_DELETE_CLASS: p = "WMICORE_TASK_DELETE_CLASS"; break;
        case WMICORE_TASK_ENUM_CLASSES: p = "WMICORE_TASK_ENUM_CLASSES"; break;
        case WMICORE_TASK_EXEC_QUERY:   p = "WMICORE_TASK_EXEC_QUERY"; break;
        case WMICORE_TASK_EXEC_METHOD:  p = "WMICORE_TASK_EXEC_METHOD"; break;
        case WMICORE_TASK_OPEN:         p = "WMICORE_TASK_OPEN"; break;
        case WMICORE_TASK_OPEN_SCOPE:   p = "WMICORE_TASK_OPEN_SCOPE"; break;
        case WMICORE_TASK_OPEN_NAMESPACE: p = "WMICORE_TASK_OPEN_NAMESPACE"; break;
        case WMICORE_TASK_EXEC_NOTIFICATION_QUERY: p = "WMICORE_TASK_EXEC_NOTIFICATION_QUERY"; break;
    }

    fprintf(f, "    TaskType = [0x%X] %s ", m_uTaskType, p);

    if (m_uTaskType & WMICORE_TASK_TYPE_SYNC)
        fprintf(f,  " WMICORE_TASK_TYPE_SYNC");

    if (m_uTaskType & WMICORE_TASK_TYPE_SEMISYNC)
        fprintf(f, " WMICORE_TASK_TYPE_SEMISYNC");

    if (m_uTaskType & WMICORE_TASK_TYPE_ASYNC)
        fprintf(f, " WMICORE_TASK_TYPE_ASYNC");

    if (m_uTaskType & WMICORE_TASK_TYPE_PRIMARY)
        fprintf(f, " WMICORE_TASK_TYPE_PRIMARY");

    if (m_uTaskType & WMICORE_TASK_TYPE_DEPENDENT)
        fprintf(f, " WMICORE_TASK_TYPE_DEPENDENT");

    fprintf(f, "\n");

    fprintf(f, "    Task Log Info = %S\n", LPWSTR(m_sDebugInfo));
    fprintf(f, "    AsyncClientSink = 0x%p\n", m_pAsyncClientSink);
    fprintf(f, "    Finalizer = 0x%p\n", m_pWorkingFnz);

	CCheckedInCritSec	ics( &m_csTask );

    for (int i = 0; i < m_aTaskProviders.Size(); i++)
    {
        STaskProvider *pTP = (STaskProvider *) m_aTaskProviders[i];
        fprintf(f, "    Task Provider [0x%p] Prov=0x%p Sink=0x%p\n", this, pTP->m_pProv, pTP->m_pProvSink);
    }
	
	ics.Leave();

    DWORD dwAge = GetCurrentTime() - m_uStartTime;

    fprintf(f, "    CWbemNamespace = 0x%p\n", m_pNs);
    fprintf(f, "    Task age = %d milliseconds\n", dwAge);
    fprintf(f, "    Task last sleep time = %d ms\n", m_uLastSleepTime );

    fprintf(f, "\n");
    return 0;
}

/*
int __cdecl CWmiTask::printf(const char *fmt, ...)
{
#ifdef TASK_DETAIL_TRACKING
    static CRITICAL_SECTION csPrintf;
    static BOOL bInit = FALSE;

    if (bInit == FALSE)
    {
        InitializeCriticalSection(&csPrintf);
        bInit = TRUE;
    }

    const int nBufSize = 0x8000;
    static LONG Protect = -1;
    char buffer[nBufSize];

    va_list argptr;
    int cnt;
    va_start(argptr, fmt);
    cnt = _vsnprintf(buffer, nBufSize, fmt, argptr);
    if (cnt == -1)
        buffer[nBufSize] = 0; // Null terminate manually; see _vsnprintf spec
    va_end(argptr);

    EnterCriticalSection(&csPrintf);
    m_sDebugInfo += buffer;
    LeaveCriticalSection(&csPrintf);

    return cnt;
#else
    return 0;
#endif
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\wmifinalizer.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WmiFinalizer2

Abstract:
	Implementation of the finalizer.  The finalizer if the class which
	delivers the resultant objects back to the client.  It could do
	that sychronously or asynchronously.


History:

    paulall		27-Mar-2000		Created.
	marioh		20-Aug-2000		Batching capabilities added
	marioh		17-Oct-2000		Major updates completed


--*/

#include <flexarry.h>
#include <thrpool.h>
#include <wbemcore.h>

#ifndef __FINALIZER__
#define __FINALIZER__

#define DEFAULT_BATCH_TRANSMIT_BYTES		0x40000         // 128K, Max batching size to deliver on one indicate call
#define MAX_SINGLE_OBJECT_SIZE				0x200000		// Max single object size
#define ABANDON_PROXY_THRESHOLD				60000			// Max proxy timeout [60secs]
#define MAX_BUFFER_SIZE_BEFORE_SLOWDOWN		0x400000		// Max size of queue before slowdown of inbound flow

#define	LOWER_AUTH_LEVEL_NOTSET				0xFFFFFFFF

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Finalizer constructor exceptions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

class FNLZR_Exception 
{
    ;
};



class CWmiFinalizerEnumerator;
class CWmiFinalizerInboundSink;
class CWmiFinalizerEnumeratorSink;
class CWmiFinalizerCallResult;
class CWmiFinalizer ;


class CWmiFinalizerObj
{
public:
	IWbemClassObject *m_pObj;
	enum ObjectType {
		unknown,
		object,
		status,
		shutdown,
		set
	} m_objectType;
	
	BSTR			m_bStr;

	HRESULT			m_hRes;
	HRESULT			m_hArb ;

	void*			m_pvObj;
	_IWmiFinalizer* m_pFin ;
	
	IID				m_iid;
	ULONG			m_uSize;
	ULONG			m_lFlags;
	

	CWmiFinalizerObj(ObjectType objType) : m_pObj(NULL), m_objectType(objType), m_lFlags(0), m_bStr(NULL), m_hRes(0), m_pvObj(0), m_uSize(0), m_pFin ( NULL ), m_hArb ( WBEM_S_ARB_NOTHROTTLING ) {}
	CWmiFinalizerObj(IWbemClassObject *pObj, _IWmiFinalizer* pFin ) ;
	CWmiFinalizerObj(ULONG lFlags, REFIID riid, void *pvObj) ;

	CWmiFinalizerObj(ULONG lFlags, HRESULT hRes, BSTR bStr, IWbemClassObject *pObj) ;
	CWmiFinalizerObj(CWmiFinalizerObj& obj);

	~CWmiFinalizerObj();
};




class CWmiFinalizer : public _IWmiFinalizer, public _IWmiArbitratee
{
private:
	LONG				m_lRefCount;						// External/client refcount
	LONG				m_lInternalRefCount;				// Internal refcount
	LONG				m_hStatus;							// Status once thread is woken up from PullObjects
	BOOL				m_bSetStatusEnqueued;				// We've recieved and enqueued the setstatus (COMPLETE)
	BOOL				m_bSetStatusWithError;				// SetStatus called with error
	BOOL				m_bTaskInitialized ;				// Has SetTaskHandle been called?
	BOOL				m_bClonedFinalizer ;				// Is this a cloned finalizer?
	BOOL				m_bSetStatusDelivered ;				// Has the setstatus been delivered?
	
	ULONG				m_ulOperationType;					// Sync/Semisync/Async
	ULONG				m_ulSemisyncWakeupCall;				// For semisync operations, once number of objects on the queue reaches this, wake up client

	IWbemClassObject**	m_apAsyncDeliveryBuffer;			// Used during async deliveries for batching objects together
	ULONG				m_ulAsyncDeliveryCount;				// Used during async deliveries for the number of objects to deliver in one batch
	ULONG				m_ulAsyncDeliverySize;				// Async deliver size
	LONG				m_lCurrentlyDelivering;				// Are we in the process of already delivering the batch
	LONG				m_lCurrentlyCancelling;				// Special case for cancellations

	enum {
		forwarding_type_none = 0,
		forwarding_type_fast = 1,							//Use pass through mechanism
		forwarding_type_decoupled = 2						//Pass off to another thread for delivery
	}					 m_uForwardingType;
	
	enum {
		FinalizerBatch_StatusMsg  = 0,
		FinalizerBatch_BufferOverFlow = 1,
		FinalizerBatch_NoError	  = 2
	}					 m_enumBatchStatus;


	enum {
		PauseInboundDelivery = 0,
		ResumeInboundDelivery = 1,
	};

	enum {
		Operation_Type_Async = 0,
		Operation_Type_Semisync = 1,
		Operation_Type_Sync = 2
	};


	_IWmiCoreHandle		*m_phTask;							// Task associated with this finalizer
	_IWmiArbitrator		*m_pArbitrator;						// Access to arbitrator to help keep control of system

	IID					 m_iidDestSink;						// Client destination sink with async deliveries [IID]
	IWbemObjectSink		*m_pDestSink;						// Client destination sink with async deliveries

	IWbemObjectSinkEx	*m_pDestructSink;					// ????

	CFlexArray			 m_inboundSinks;					// Array of inbound sinks [not sure we need safe array since we only support one inbound sink]
	CFlexArray			 m_objects;							// Object queue. All objects are inserted into this array [except async fasttrack]
	CFlexArray			 m_enumerators ;					// All enumerators associated with this finalizer (cloning)

	HRESULT				 m_hresFinalResult;					// Final result of operation
	CWmiFinalizerCallResult *m_pCallResult;					// CallResult
	bool				 m_bSetStatusCalled;				// Has anyone called setstatus yet?

	CCritSec	 m_destCS;									// Protects the destination sink
	CCritSec	 m_arbitratorCS;							// Protects the arbitrator

	CWmiFinalizerEnumerator *m_pEnumerator;					// Enumerator
	bool				 m_bRestartable;					// Is the enumerator restartable
	bool				 m_bSetStatusConsumed;				// Have we finished the operation?

	LONG				 m_lMemoryConsumption ;				// Control for checking memory consumption
	ULONG				 m_ulStatus;						// Status used to determine what woke a client from PullObjects
	ULONG				 m_uCurObjectPosition;				// Keeps a current object position in object queue for restartable purposes
	HANDLE				 m_hResultReceived;
	HANDLE				 m_hCancelEvent;					// Threads that are waiting on objects will wake up in case of cancelled operation
	HANDLE				 m_hWaitForSetStatus ;
	ULONG				 m_ulQueueSize;						// Total current object queue size

	LONG				 m_bCancelledCall;					// Has the call been cancelled?
	BOOL				 m_bNaughtyClient;					// Did we stop delivering due to client being naughty?

	//static CThreadPool	 m_threadPool;					// Static thread pool shared amongst all finalizers [note: this may go away]
	


protected:
	
	static DWORD WINAPI ThreadBootstrap ( PVOID pvContext );

	static VOID WINAPI ProxyThreshold ( PVOID pvContext, BOOLEAN bTimerOrWait );

	HRESULT	BootstrapDeliveryThread ( );
	
	VOID ProxyThresholdImp ( );
	
	ULONG AsyncDeliveryProcessor();

	HRESULT TriggerShutdown();

	HRESULT ShutdownFinalizer();

	HRESULT DeliverPushObject(bool bDoPassthrough);

	HRESULT QueueOperation(CWmiFinalizerObj *pObj);

	HRESULT DequeueObject(CWmiFinalizerObj **ppObj, CWmiFinalizerEnumerator* pEnum );

	HRESULT	BuildTransmitBuffer ( );

	HRESULT DeliverSingleObjFromQueue ( );
	
	HRESULT DeliverBatch ( );

	HRESULT CancelCall ( );

	VOID	ZeroAsyncDeliveryBuffer ( );

public:
	CWmiFinalizer(CCoreServices *pSrvs);
	~CWmiFinalizer();

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);
    STDMETHOD_(ULONG, InternalAddRef)(THIS);
    STDMETHOD_(ULONG, InternalRelease)(THIS);

	void CallBackRelease () ;

    STDMETHOD(Configure)(
        /*[in]*/ ULONG uConfigID,
        /*[in]*/ ULONG uValue
        );
        // Allows decoupled & fast-track configuration with no thread switches

    STDMETHOD(SetTaskHandle)(
        /*[in]*/ _IWmiCoreHandle *phTask
        );
        // Task handle has user-specific stuff.  Finalizer just
        // passes this through to _IWmiArbitrator::CheckTask

    STDMETHOD(SetDestinationSink)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ REFIID riid,
        /*[in], iid_is(riid)]*/ LPVOID pSink
        );
        // For async operations

    STDMETHOD(SetSelfDestructCallback)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ IWbemObjectSinkEx *pSink
        );
        // The callback called during final Release(); Set() is called with the task handle, followed by SetStatus()
        //

    STDMETHOD(GetStatus)(
        /*[out]*/ ULONG* pFlags
        );

    STDMETHOD(NewInboundSink)(
        /*[in]*/  ULONG uFlags,
        /*[out]*/ IWbemObjectSinkEx **pSink
        );

    STDMETHOD(Merge)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ REFIID riid,
        /*[in]*/ LPVOID pObj
        );
        // Allows merging another Finalizer, _IWmiCache, etc.
        // For sorting, we will create a sorted _IWmiCache and merge it in later when
        // the sort is completed.

    // For setting, getting objects

    STDMETHOD(SetResultObject)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ REFIID riid,
        /*[in]*/ LPVOID pObj
        );

    STDMETHOD(GetResultObject)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ REFIID riid,
        /*[out, iid_is(riid)]*/ LPVOID *pObj
        );
        // Support _IWmiObject, IWbemClassObject, etc.
        // IEnumWbemClassObject
        // _IWmiCache

    // For status-only operations

    STDMETHOD(SetOperationResult)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ HRESULT hRes
        );

    STDMETHOD(GetOperationResult)(
        /*[in]*/ ULONG uFlags,
		/*[in]*/ ULONG uTimeout,
        /*[out]*/ HRESULT *phRes
        );

	//Set status is called from the inbound sink to notify us of the status.
	//We will queue up the request and pass it on to the client if necessary
	HRESULT SetStatus(
		/*[in]*/ long lFlags,
		/*[in]*/ HRESULT hResult,
		/*[in]*/ BSTR strParam,
		/*[in]*/ IWbemClassObject* pObjParam
		);
	
	STDMETHOD(CancelTask) (
        /*[in]*/ ULONG uFlags
        );

	STDMETHOD(DumpDebugInfo) (
        /*[in]*/ ULONG uFlags,
		/*[in]*/ const BSTR fHandle
        );



	//When the sink goes away, in the destructor, it will call back to unregister
	//itself.  That way we know when they are all done.  If they are all gone
	//we can send the status back to the client and we are all done!
	
	HRESULT CancelWaitHandle	( );
	HRESULT	SetClientCancellationHandle ( HANDLE ) ;
	HRESULT NotifyClientOfCancelledCall ( ) ;
	BOOL	IsValidDestinationSink  ( ) ;
	HRESULT ReleaseDestinationSink ( ) ;

	HRESULT ReportMemoryUsage ( ULONG, LONG ) ;
    HRESULT CancelTaskInternal	( );
	HRESULT Reset				( );											// If there is an EnumClassObject calling Reset, it calls back into us...
	HRESULT SetSinkToIdentity	( IWbemObjectSink* );							// Waits until the timeout for a new object to arrive, or a shutdown state
	HRESULT WaitForCompletion	( ULONG uTimeout );								// Wait for the operition to complete.
	HRESULT	NextAsync			( CWmiFinalizerEnumerator* pEnum );
	HRESULT Skip				( long lTimeout, ULONG nCount, CWmiFinalizerEnumerator* pEnum );
	HRESULT PullObjects			( long lTimeout, ULONG uCount, IWbemClassObject** apObjects, ULONG* puReturned, CWmiFinalizerEnumerator* pEnum, BOOL bAddToObjQueue=TRUE, BOOL bSetErrorObj=TRUE );
	HRESULT Set					( long lFlags, REFIID riid, void *pComObject );	
    HRESULT	Indicate			( long lObjectCount, IWbemClassObject** apObjArray );
	HRESULT UnregisterInboundSink( CWmiFinalizerInboundSink *pSink );
	HRESULT GetNextObject		( CWmiFinalizerObj **ppObj );
	HRESULT ZapWriteOnlyProps	( IWbemClassObject *pObj );
	BOOL	HasWriteOnlyProps   ( IWbemClassObject* pObj );

	HRESULT DoSetStatus			( IWbemObjectSink * psink, long lFlags, HRESULT lParam, BSTR strParam,
								  IWbemClassObject* pObjParam, BOOL bAllowMultipleCalls = FALSE );
	HRESULT DoIndicate			( IWbemObjectSink * psink, int nBatchSize, IWbemClassObject **pBatch );
	HRESULT FinalizerLowerAuthLevel ( IWbemObjectSink * psink, DWORD* pdwLastAuthnLevel );
	
	IWbemObjectSink* ReturnProtectedDestinationSink ( );
	
	bool	GetSetStatusConsumed ( )				{ return m_bSetStatusConsumed; }
	bool	IsRestartable ( void )					{ return m_bRestartable; }
	LONG	GetInternalStatus ( )					{ return m_hStatus; }
	HRESULT	SetInternalStatus ( LONG lStatus )		{ m_hStatus = lStatus; return WBEM_S_NO_ERROR; }
	ULONG	GetObjectQueueSize ( )					{ return m_objects.Size(); }
	LONG	IsCallCancelled ( )						{ return m_bCancelledCall; }
	VOID	UpdateStatus ( ULONG ulFlags )			{ m_ulStatus |= ulFlags; }

	VOID	SetSemisyncWakeupCall ( ULONG ulNum )	{ m_ulSemisyncWakeupCall = ulNum; }
	ULONG	GetSemisyncWakeupCall ( )				{ return m_ulSemisyncWakeupCall; }

	HRESULT NotifyAllEnumeratorsOfCompletion ( ) ;
	HRESULT UnregisterEnumerator ( CWmiFinalizerEnumerator* ) ;

	// Other public:
    static void Dump(FILE* f);

	enum {
		NoError = 0,
		RequestReleased = 1,
		CallCancelled = 2,
		QuotaViolation = 3
	};


	CCritSec	 m_cs;										// Protects the object queue

};



//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
//****                                                                     ****
//****                Private WmiFinalizer classes...                      ****
//****                                                                     ****
//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
class CWmiFinalizerInboundSink : public IWbemObjectSinkEx
{
private:
	LONG		   m_lRefCount;
	LONG		   m_lInternalRefCount;
	CWmiFinalizer *m_pFinalizer;
	bool		   m_bSetStatusCalled;

public:
	CWmiFinalizerInboundSink(CWmiFinalizer *pFinalizer);
	~CWmiFinalizerInboundSink();

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);
    STDMETHOD_(ULONG, InternalAddRef)(THIS);
    STDMETHOD_(ULONG, InternalRelease)(THIS);

	void CallBackRelease () ;

    STDMETHOD(Indicate)(
        /*[in]*/ long lObjectCount,
        /*[in, size_is(lObjectCount)]*/
            IWbemClassObject** apObjArray
        );


    STDMETHOD(SetStatus)(
        /*[in]*/ long lFlags,
        /*[in]*/ HRESULT hResult,
        /*[in]*/ BSTR strParam,
        /*[in]*/ IWbemClassObject* pObjParam
        );

    STDMETHOD(Set)(
        /*[in]*/ long lFlags,
        /*[in]*/ REFIID riid,
        /*[in, iid_is(riid)]*/ void *pComObject
        );
};

class CWmiFinalizerEnumerator : public IEnumWbemClassObject, IWbemFetchSmartEnum
{
private:
	LONG	m_lRefCount;
	LONG	m_lInternalRefCount;
	ULONG	m_ulCount;
	HANDLE	m_hSignalCompletion;

	CWmiFinalizer*			m_pFinalizer;
	IServerSecurity*		m_pSec;
	IWbemObjectSink*		m_pDestSink;
	_IWbemEnumMarshaling*	m_pEnumMarshal;


	CCritSec	m_clientLock;
	CCritSec	m_EventCreationLock;
	CCritSec	m_EnumCS;

	CDerivedObjectSecurity m_Security;


protected:
	// ============================    
	// SMART ENUM!!!!!!!!!!!!!
	// ============================
	class XSmartEnum : public IWbemWCOSmartEnum
	{
	  private:
		CWmiFinalizerEnumerator*	m_pOuter;

	  public:

		XSmartEnum( CWmiFinalizerEnumerator* pOuter ) : m_pOuter( pOuter ) {};
		~XSmartEnum(){};

		STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
		STDMETHOD_(ULONG, AddRef)(THIS);
		STDMETHOD_(ULONG, Release)(THIS);

		// IWbemWCOSmartEnum Methods
		STDMETHOD(Next)( REFGUID proxyGUID, LONG lTimeout,
			ULONG uCount, ULONG* puReturned, ULONG* pdwBuffSize,
			BYTE** pBuffer);
	} m_XSmartEnum;

	friend XSmartEnum;


public:
	CWmiFinalizerEnumerator(CWmiFinalizer *pFinalizer);
	~CWmiFinalizerEnumerator();

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);
    STDMETHOD_(ULONG, InternalAddRef)(THIS);
    STDMETHOD_(ULONG, InternalRelease)(THIS);

	
	static DWORD WINAPI ThreadBootstrapNextAsync ( PVOID pvContext );
	void			 CallBackRelease			 ( ) ;
	HRESULT			 _NextAsync				 ( );
	HRESULT			 SetCompletionSignalEvent	 ( )						{ if ( m_hSignalCompletion ) SetEvent (m_hSignalCompletion); return WBEM_S_NO_ERROR; }
	IWbemObjectSink* GetDestSink				 ( )						{ return m_pDestSink; }
	VOID			 NULLDestSink				 ( )						{ m_pDestSink = NULL; }
	HRESULT			 ReleaseFinalizer			 ( )						{ if ( m_pFinalizer ) m_pFinalizer->Release(); return WBEM_S_NO_ERROR; }

	// ============================    
	// IEnumWbemClassObject methods
	// ============================
	STDMETHOD(Reset)();

    STDMETHOD(Next)(
        /*[in]*/  long lTimeout,
        /*[in]*/  ULONG uCount,
        /*[out, size_is(uCount), length_is(*puReturned)]*/ IWbemClassObject** apObjects,
        /*[out]*/ ULONG* puReturned
        );

    STDMETHOD(NextAsync)(
        /*[in]*/  ULONG uCount,
        /*[in]*/  IWbemObjectSink* pSink
        );

    STDMETHOD(Clone)(
        /*[out]*/ IEnumWbemClassObject** ppEnum
        );

    STDMETHOD(Skip)(
        /*[in]*/ long lTimeout,
        /*[in]*/ ULONG nCount
        );


	// ===========================    
	// IWbemFetchSmartEnum methods
	// ===========================
	STDMETHOD (GetSmartEnum) (
		/*[out]*/ IWbemWCOSmartEnum** ppSmartEnum
	);	

	ULONG	m_uCurObjectPosition ;
	HANDLE	m_hWaitOnResultSet ;
	ULONG	m_ulSemisyncWakeupCall;
	BOOL	m_bSetStatusConsumed ;
};


class CWmiFinalizerCallResult : IWbemCallResultEx
{
private:
	LONG		       m_lInternalRefCount;
	LONG		       m_lRefCount;

	CWmiFinalizer     *m_pFinalizer;
    long			   m_lFlags;
    HRESULT			   m_hResult;
    BSTR			   m_strParam;
    IWbemClassObject  *m_pObj;
	IWbemClassObject  *m_pErrorObj;
	IWbemServices	  *m_pServices;
	bool			   m_bGotObject;
	bool			   m_bGotServices;
	CDerivedObjectSecurity m_Security;


public:
	CWmiFinalizerCallResult(CWmiFinalizer *pFinalizer);
	~CWmiFinalizerCallResult();

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);
    STDMETHOD_(ULONG, InternalAddRef)(THIS);
    STDMETHOD_(ULONG, InternalRelease)(THIS);

    STDMETHOD(GetResultObject)(
        /*[in]*/  long lTimeout,
        /*[out]*/ IWbemClassObject** ppResultObject
        );

    STDMETHOD(GetResultString)(
        /*[in]*/  long lTimeout,
        /*[out]*/ BSTR* pstrResultString
        );

    STDMETHOD(GetResultServices)(
        /*[in]*/  long lTimeout,
        /*[out]*/ IWbemServices** ppServices
        );

    STDMETHOD(GetCallStatus)(
        /*[in]*/  long lTimeout,
        /*[out]*/ long* plStatus
        );

    STDMETHOD(GetResult)(
        /*[in]*/ long lTimeout,
        /*[in]*/ long lFlags,
        /*[in]*/ REFIID riid,
        /*[out, iid_is(riid)]*/ void **ppvResult
        );

	HRESULT SetStatus(
		/*[in]*/ long lFlags,
		/*[in]*/ HRESULT hResult,
		/*[in]*/ BSTR strParam,
		/*[in]*/ IWbemClassObject* pObjParam
		);


	void SetErrorInfo();


};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\pcatest\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\pcatest\precomp.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>

#define COREPOL_HEADERFILE_IS_INCLUDED

#define COREPROX_POLARITY __declspec( dllimport )
#define ESSLIB_POLARITY __declspec( dllimport )

#define COREPOL_HEADERFILE_IS_INCLUDED
#define POLARITY_HEADERFILE_IS_INCLUDED
#define POLARITY __declspec( dllimport )

#include "arena.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\pcatest\main.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "precomp.h"
#include "wbemint.h"
#include "wbemcli.h"
#include "WmiCache.h"
#include "WmiFinalizer.h"
#include <arrtempl.h>
#include <cominit.h>

extern bool CreateClass(const wchar_t *wszClassName, _IWmiObject **ppClass);
extern bool AddClassProperty(_IWmiObject *pClass, const wchar_t *wszProperty, bool bKey);
extern bool SetInstanceProperty(_IWmiObject *pInstance, const wchar_t *wszProperty, const wchar_t *wszPropertyValue);
extern bool CreateInstance(_IWmiObject *pClass, const wchar_t *wszKey, _IWmiObject **ppInstance);
extern void TestCache();
extern void TestFinalizer();
extern void TestArbitrator();

void __cdecl main(void)
{
//	TestCache();
	TestFinalizer();
}



bool CreateClass(const wchar_t *wszClassName, _IWmiObject **ppClass)
{
	_IWmiObject*	pObj= NULL;
	HRESULT hr = CoCreateInstance( CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, IID__IWmiObject, (void**) &pObj );

	VARIANT var;
	VariantInit(&var);
	V_VT(&var) = VT_BSTR;
	V_BSTR(&var) = SysAllocString(wszClassName);

	pObj->Put(L"__class", 0, &var, CIM_STRING);

	VariantClear(&var);

	*ppClass = pObj;
	return true;
}

bool AddClassProperty(_IWmiObject *pClass, const wchar_t *wszProperty, bool bKey)
{
	VARIANT var;
	VariantInit(&var);
	V_VT(&var) = VT_NULL;
	pClass->Put(wszProperty, 0, &var, CIM_STRING);

	if (bKey)
	{
		V_VT(&var) = VT_BOOL;
		V_BOOL(&var) = TRUE;
		IWbemQualifierSet *pQualifierSet = 0;
		pClass->GetPropertyQualifierSet(L"key", &pQualifierSet);
		pQualifierSet->Put(L"key", &var, 0);
		pQualifierSet->Release();
	}

	VariantClear(&var);
	return true;
}

bool SetInstanceProperty(_IWmiObject *pInstance, const wchar_t *wszProperty, const wchar_t *wszPropertyValue)
{
	VARIANT var;
	VariantInit(&var);
	V_VT(&var) = VT_BSTR;
	V_BSTR(&var) = SysAllocString(wszPropertyValue);

	pInstance->Put(wszProperty, 0, &var, CIM_STRING);


	VariantClear(&var);
	return true;
}

bool CreateInstance(_IWmiObject *pClass, const wchar_t *wszKey, _IWmiObject **ppInstance)
{
	_IWmiObject *pInstance = NULL;
	IWbemClassObject *pInst2 = NULL;
	pClass->SpawnInstance(0, &pInst2);
	pInst2->QueryInterface(IID__IWmiObject, (void**)&pInstance);
	pInst2->Release();

	SetInstanceProperty(pInstance, L"key", wszKey);

	*ppInstance = pInstance;

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\wmitask.h ===
//***************************************************************************
//
//  TASK.H
//
//  raymcc  23-Apr-00       First oversimplified draft for Whistler
//
//***************************************************************************

#ifndef _WMITASK_H_
#define _WMITASK_H_

#define CORE_TASK_TYPE(x)   (x & 0xFF)
#include <context.h>

struct STaskProvider
{
    IWbemServices   *m_pProv;
    CProviderSink   *m_pProvSink;
    STaskProvider() { m_pProv = 0; m_pProvSink = 0; }
   ~STaskProvider();

    HRESULT Cancel( CStatusSink* pStatusSink );
	HRESULT ExecCancelOnNewRequest ( IWbemServices* pProv, CProviderSink* pSink, CStatusSink* pStatusSink ) ;
};

class CWmiTask : public _IWmiCoreHandle
{
    friend struct STaskProvider;

private:
    ULONG               m_uRefCount;
    ULONG               m_uTaskType;
    ULONG               m_uTaskStatus;
    ULONG               m_uTaskId;
	HRESULT				m_hResult ;

	BOOL				m_bReqSinkInitialized ;
	BOOL				m_bAccountedForThrottling ;
	BOOL				m_bCancelledDueToThrottling ;


    CFlexArray          m_aTaskProviders;    // Array of STaskProvider structs

    WString             m_sDebugInfo;
    IWbemObjectSink     *m_pAsyncClientSink; // Used for cross-ref purposes only
    CStdSink            *m_pReqSink;         // The CStdSink pointer for each request

    LONG                m_uMemoryUsage;
    ULONG               m_uTotalSleepTime;
    ULONG               m_uCancelState;
    ULONG               m_uLastSleepTime;

	HANDLE					m_hCompletion ;
    HANDLE					m_hTimer;
    _IWmiFinalizer*			m_pWorkingFnz;      // Finalizer handling this request
    _IWmiUserHandle*		m_pUser;
    _IWmiThreadSecHandle*	m_pSec;
    CWbemContext*			m_pMainCtx;

    CFlexArray          m_aArbitratees;
    CCritSec            m_csTask;

    CWbemNamespace  *m_pNs;
    DWORD            m_uStartTime;
    DWORD            m_uUpdateTime;

    CWmiTask( );
   ~CWmiTask();
    CWmiTask(CWmiTask &Src) {}  // Not usable

    static CCritSec m_TaskCs;

public:

    static HRESULT Init();
    static HRESULT Shutdown();

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    HRESULT STDMETHODCALLTYPE QueryInterface(
        IN REFIID riid,
        OUT LPVOID *ppvObj
        );
    CWbemContext *GetCtx() { return m_pMainCtx; }

    HRESULT STDMETHODCALLTYPE GetHandleType(ULONG *puType);

    static CWmiTask *CreateTask( ) ;

    ULONG GetTaskType() { return m_uTaskType; }

    ULONG GetTaskStatus() { return m_uTaskStatus; }
    HANDLE GetTimerHandle ( ) { return m_hTimer; }

    void  SetTaskStatus(ULONG uStat) { m_uTaskStatus = uStat; }
    void  MergeTaskStatusBit(ULONG uMask) 
	{
		if ( m_uTaskStatus != WMICORE_TASK_STATUS_CANCELLED )
		{
			m_uTaskStatus |= uMask; 
		}
	}

	
    void  RemoveTaskStatusBit(ULONG uMask) { m_uTaskStatus &= !uMask; }

	VOID	SetCancelledState ( BOOL bState )	{ m_bCancelledDueToThrottling = bState ; }
	BOOL	GetCancelledState ( ) { return m_bCancelledDueToThrottling ; }

	HRESULT	SignalCancellation ( ) ;
	HRESULT ReleaseArbitratees ( ) ;
	HRESULT SetTaskResult ( HRESULT hRes ) ;
    HRESULT AddTaskProv(STaskProvider *);
    BOOL    IsESSNamespace ( );
    BOOL 	IsProviderNamespace ( );
    HRESULT SetFinalizer(_IWmiFinalizer *pFnz);
	HRESULT GetFinalizer( _IWmiFinalizer **ppFnz );
	BOOL	IsAccountedForThrottling ( )					{ return m_bAccountedForThrottling ; }
	VOID	SetAccountedForThrottling ( BOOL bSet )			{ m_bAccountedForThrottling = bSet ; }

    HRESULT HasMatchingSink(void *Test, IN REFIID riid);
    HRESULT Cancel( HRESULT hRes = WBEM_E_CALL_CANCELLED );
    HRESULT GetPrimaryTask ( _IWmiCoreHandle** pPTask );


    HRESULT AddArbitratee(ULONG uFlags, _IWmiArbitratee* pArbitratee);
    HRESULT RemoveArbitratee(ULONG uFlags, _IWmiArbitratee* pArbitratee);

	HRESULT GetArbitratedQuery( ULONG uFlags, _IWmiArbitratedQuery** ppArbitratedQuery );

    HRESULT GetMemoryUsage    ( ULONG* uMemUsage )              { *uMemUsage = m_uMemoryUsage; return WBEM_S_NO_ERROR; }
    HRESULT UpdateMemoryUsage ( LONG lDelta ) ;

    HRESULT GetTotalSleepTime ( ULONG* uSleepTime )             { *uSleepTime = m_uTotalSleepTime; return WBEM_S_NO_ERROR; }
    HRESULT UpdateTotalSleepTime ( ULONG uSleepTime ) ;

    HRESULT GetCancelState ( ULONG* uCancelState )              { *uCancelState = m_uCancelState;  return WBEM_S_NO_ERROR; }
    HRESULT SetCancelState ( ULONG uCancelState )               { m_uCancelState = uCancelState;   return WBEM_S_NO_ERROR; }

    HRESULT SetLastSleepTime ( ULONG uSleep )                   { m_uLastSleepTime = uSleep; return WBEM_S_NO_ERROR; }

    HRESULT CreateTimerEvent ( );

    HRESULT SetArbitrateesOperationResult ( ULONG, HRESULT );

    HRESULT Initialize(
        IN CWbemNamespace *pNs,
        IN ULONG uTaskType,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pClientSinkCopy
        );

    HRESULT AssertProviderRef(IWbemServices *pProv);
    HRESULT RetractProviderRef(IWbemServices *pProv);

    ULONG GetTaskId() { return m_uTaskId; }

    // int __cdecl printf(const char *fmt, ...);

    HRESULT Dump(FILE* f);  // Debug only
    HRESULT SetRequestSink(CStdSink *pSnk);

    CWbemNamespace* GetNamespace ( ) { return m_pNs; }
};

typedef CWmiTask *PCWmiTask;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\wmiuser.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//***************************************************************************
//
//  WMIUSER.H
//
//  raymcc      1-May-00        Created
//
//***************************************************************************

#ifndef _WMIUSER_H_
#define _WMIUSER_H_

typedef enum
{
    WMICORE_CLIENT_STATUS_NULL      = 0,
    WMICORE_CLIENT_STATUS_CONNECTED,
    WMICORE_CLIENT_STATUS_PROCESSING,
    WMICORE_CLIENT_STATUS_INACTIVE

}   WMICORE_CLIENT_STATUS;


class CWmiUser : public _IWmiUserHandle
{
    ULONG   m_uRefCount;
    ULONG   m_uStatus;          // WMICORE_CLIENT_STATUS_ constant

    LPWSTR  m_pszUserName;
    PSID    m_pSid;
    ULONG   m_uSidLength;

    SYSTEMTIME m_stLogonTime;           // Real time
    ULONG      m_uStartTime;            // GetCurrentTime
    ULONG      m_uLastRequestTime;      // GetCurrentTime

    DWORD      m_dwQuota_MaxThreads;
    DWORD      m_dwQuota_MaxRequests;

    unsigned __int64 m_u64AccumulatedTime;     // Milliseconds

    CFlexArray  m_aConnections;                 // IWbemServices(Ex) pointers

    // Master user list.
    // =================

    // Methods.
    // ========
    void Clear();
    void Empty();
    static CFlexArray m_aUserList;

public:
    // COM Methods

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    HRESULT STDMETHODCALLTYPE QueryInterface(
        IN REFIID riid,
        OUT LPVOID *ppvObj
        );

    HRESULT STDMETHODCALLTYPE GetHandleType(ULONG *puType);

public:
    // C++ methods

    CWmiUser();
   ~CWmiUser();
    CWmiUser(CWmiUser &Src);
    CWmiUser & operator = (CWmiUser &Src);

    // Intializes the user based on the calling thread.

    static HRESULT Logon();

    HRESULT AttachUserToScope();
    HRESULT DetachUserFromScope();

    static HRESULT GetCurrentUserList(
        OUT ULONG *puListSize,
        OUT _IWmiUserHandle **pUser
        );

    static  HRESULT Purge();    // Remove all users with no active connections

    static HRESULT FreeMemory(
        _IWmiUserHandle **pList
        );

    static HRESULT DumpToTextFile(LPWSTR pszFileName);

};

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\testlib\coremaintest.cpp ===
#include "..\precomp.h"
#include "mainTest.h"
#include "TestSuite.h"
#include "TestCaller.h"
#include <objbase.h>
//#include <wbemcore.h>
#include <flexarry.h>
#include <coresvc.h>
#include <reposit.h>
#include <dynasty.h>
//#include <SQL_1.h>
//#include <crep.h>

#include <wbemcore.h>
#include <decor.h>
#include "PersistCfg.h"
#include <sleeper.h>
#include <genutils.h>
#include <TCHAR.H>
#include <oahelp.inl>
#include <wmiarbitrator.h>
#include <comdef.h>

CoreTest::CoreTest (std::string name)
: TestCase (name)
{
}


CoreTest::~CoreTest()
{
}

void CoreTest::setUp ()
{
}


void CoreTest::tearDown ()
{
}

void CoreTest::testExec ()
{
  IWbemServices * pSvc;
  CRepository::Init();
  CCoreServices core;

  core.GetServices(L"default",0,IID_IWbemServices,(void**)&pSvc);

}


Test __declspec( dllexport) *CoreTest::suite ()
{
    TestSuite *suite = new TestSuite ("CoreTest Suite");
    suite->addTest (new TestCaller<CoreTest>("testExec",testExec));
    return suite;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\pcatest\testcache.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "precomp.h"
#include "wbemint.h"
#include "wbemcli.h"
#include "WmiCache.h"
#include "WmiFinalizer.h"
#include <arrtempl.h>
#include <cominit.h>

extern bool CreateClass(const wchar_t *wszClassName, _IWmiObject **ppClass);
extern bool AddClassProperty(_IWmiObject *pClass, const wchar_t *wszProperty, bool bKey);
extern bool SetInstanceProperty(_IWmiObject *pInstance, const wchar_t *wszProperty, const wchar_t *wszPropertyValue);
extern bool CreateInstance(_IWmiObject *pClass, const wchar_t *wszKey, _IWmiObject **ppInstance);
extern void TestCache();
extern void TestFinalizer();
extern void TestArbitrator();

#define ITER_COUNT 10000
void TestCache()
{

    InitializeCom();

	CWmiCache *pCache = new CWmiCache;

	_IWmiObject *pClass = NULL;
	CreateClass(L"Class1", &pClass);
	AddClassProperty(pClass, L"key", true);
	pClass->SetDecoration(L"MyMachine", L"root\\foo\\boo\\goo");
	if (FAILED(pCache->AddObject(0, pClass)))
		MessageBox(NULL, "Class1", "Failed to add class", MB_OK);

	_IWmiObject *pInstance = NULL;

	int i;

	for (i = 0; i < ITER_COUNT; i++)
	{
		wchar_t buff[100];
		char buff2[100];
		swprintf(buff, L"Instance %d", i);
		sprintf(buff2, "Instance %d", i);
		CreateInstance(pClass, buff, &pInstance);
		pInstance->SetDecoration(L"MyMachine", L"root\\foo\\boo\\goo");
		if (FAILED(pCache->AddObject(0, pInstance)))
			MessageBox(NULL, buff2, "Failed to add object", MB_OK);
		pInstance->Release();
	}

	pClass->Release();
	

	pClass = NULL;
	if (FAILED(pCache->GetByPath(NULL, L"\\\\MyMachine\\root\\foo\\boo\\goo:Class1", &pClass)))
		MessageBox(NULL, "\\\\MyMachine\\root\\foo\\boo\\goo:Class1", "Failed to add object", MB_OK);
	if (pClass)
		pClass->Release();

	pInstance = NULL;
	for (i = 0; i < ITER_COUNT; i++)
	{
		wchar_t buff[150];
		char buff2[100];
		swprintf(buff, L"\\\\MyMachine\\root\\foo\\boo\\goo:Class1.key=\"Instance %d\"", i);
		sprintf(buff2,  "\\\\MyMachine\\root\\foo\\boo\\goo:Class1.key=\"Instance %d\"", i);
		if (FAILED(pCache->GetByPath(NULL, buff, &pInstance)))
			MessageBox(NULL, buff2, "Failed to GetByPath", MB_OK);
		if (pInstance)
			pInstance->Release();
	}


	pCache->BeginEnum(0, NULL);
	_IWmiObject *pObj = NULL;
	ULONG uRet = 0;
	i = 0;
	while (SUCCEEDED(pCache->Next(1, &pObj, &uRet)) && (uRet == 1))
	{
		if (pObj)
			pObj->Release();
		pObj = NULL;
		i++;	
	}
	if (i != (ITER_COUNT + 1))
		MessageBox(NULL, "Not enough items in cache when iterating through whole list!", "Count Error", MB_OK);

	delete pCache;

	CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\wmiuser.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//***************************************************************************
//
//  WMIUSER.CPP
//
//  raymcc      1-May-00        Created
//
//***************************************************************************

#include "precomp.h"
#include <windows.h>
#include <wbemcore.h>
#include <stdio.h>
#include <stdlib.h>


//***************************************************************************
//
//***************************************************************************
// *
ULONG CWmiUser::AddRef()
{
    ULONG uNewCount = InterlockedIncrement((LONG *) &m_uRefCount);
    return uNewCount;
}

//***************************************************************************
//
//***************************************************************************
// *
ULONG CWmiUser::Release()
{
    ULONG uNewCount = InterlockedDecrement((LONG *) &m_uRefCount);
    if (0 != uNewCount)
        return uNewCount;
    delete this;
    return 0;
}

//***************************************************************************
//
//***************************************************************************
// *
HRESULT CWmiUser::QueryInterface(
    IN REFIID riid,
    OUT LPVOID *ppvObj
    )
{
    *ppvObj = 0;

    if (IID_IUnknown==riid || IID__IWmiCoreHandle==riid || IID__IWmiUserHandle == riid)
    {
        *ppvObj = this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//***************************************************************************
//
//***************************************************************************
// *
HRESULT CWmiUser::GetHandleType(
    ULONG *puType
    )
{
    *puType = WMI_HANDLE_TASK;
    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************
//
CWmiUser::CWmiUser()
{
    Clear();
}

//***************************************************************************
//
//***************************************************************************
//

void CWmiUser::Clear()
{
    m_uRefCount = 0;
    m_uStatus = 0;          // WMICORE_CLIENT_STATUS_ constant
    m_pszUserName = 0;
    m_pSid = 0;
    m_uSidLength = 0;

    memset(&m_stLogonTime, 0, sizeof(SYSTEMTIME));           // Real time

    m_uStartTime = 0;            // GetCurrentTime
    m_uLastRequestTime = 0;      // GetCurrentTime

    m_dwQuota_MaxThreads = 0;
    m_dwQuota_MaxRequests = 0;
    m_u64AccumulatedTime = 0;     // Milliseconds
}

//***************************************************************************
//
//***************************************************************************
//

void CWmiUser::Empty()
{
    delete (BYTE *) m_pSid;
    delete [] m_pszUserName;

    for (int i = 0; i < m_aConnections.Size(); i++)
    {
        CWbemNamespace *pNs = (CWbemNamespace *) m_aConnections[i];
        pNs->Release();
    }
    m_aConnections.Empty();
}

//***************************************************************************
//
//***************************************************************************
//

CWmiUser::~CWmiUser()
{
    Empty();
}


//***************************************************************************
//
//***************************************************************************
//
CWmiUser::CWmiUser(CWmiUser &Src)
{
    Clear();
    *this = Src;
}


//***************************************************************************
//
//***************************************************************************
//

CWmiUser& CWmiUser::operator =(CWmiUser &Src)
{
    return *this;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiUser::Purge()
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiUser::Logon()
{
    return 0;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\pcatest\testfinalizer.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include "wbemint.h"
#include "wbemcli.h"
#include "WmiFinalizer.h"
#include "WmiArbitrator.h"
#include <cominit.h>


extern bool CreateClass(const wchar_t *wszClassName, _IWmiObject **ppClass);
extern bool AddClassProperty(_IWmiObject *pClass, const wchar_t *wszProperty, bool bKey);
extern bool SetInstanceProperty(_IWmiObject *pInstance, const wchar_t *wszProperty, const wchar_t *wszPropertyValue);
extern bool CreateInstance(_IWmiObject *pClass, const wchar_t *wszKey, _IWmiObject **ppInstance);
extern void TestCache();
extern void TestFinalizer();
extern void TestArbitrator();

void TestASync();
void TestEnumerator();

void TestFinalizer()
{
	InitializeCom();

	TestASync();
	TestEnumerator();

	CoUninitialize();
}


class CDestSink : public IWbemObjectSinkEx
{
private:
	LONG m_lRefCount;
	HANDLE m_hEvent;

public:
	CDestSink() : m_lRefCount(0) { m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);}
	~CDestSink() {CloseHandle(m_hEvent);}

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    STDMETHOD (Indicate)(
        long lObjectCount,
        IWbemClassObject** apObjArray
        )
	{
		while (lObjectCount)
		{
			apObjArray[lObjectCount-1]->Release();

			lObjectCount--;
		}

		return WBEM_NO_ERROR;
	}


    STDMETHOD( SetStatus)(
        long lFlags,
        HRESULT hResult,
        BSTR strParam,
        IWbemClassObject* pObjParam
        )
	{
		SetEvent(m_hEvent);
		return WBEM_NO_ERROR;
	}

    STDMETHOD( Set)(
        long lFlags,
        REFIID riid,
        void *pComObject
        )
	{
		return WBEM_NO_ERROR;
	}

	void WaitForCompletion()
	{
		WaitForSingleObject(m_hEvent, INFINITE);
	}

};

STDMETHODIMP CDestSink::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = 0;

    if (IID_IUnknown==riid || IID_IWbemObjectSink==riid)
    {
        *ppvObj = (IWbemObjectSink*)this;
        AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;

}

ULONG CDestSink::AddRef()
{
    return InterlockedIncrement(&m_lRefCount);
}

ULONG CDestSink::Release()
{
    ULONG uNewCount = InterlockedDecrement(&m_lRefCount);
    if (0 == uNewCount)
        delete this;
    return uNewCount;
}


void TestASync()
{
	CWmiFinalizer *pFinalizer = new CWmiFinalizer;
	pFinalizer->AddRef();

	CDestSink *pDestSink = new CDestSink;
//	pDestSink->AddRef();

	pFinalizer->Configure(WMI_FNLZR_FLAG_DECOUPLED, NULL);

	pFinalizer->SetDestinationSink(0, IID_IWbemObjectSinkEx, (void*)pDestSink);

	_IWmiObject *pClass = NULL;
	CreateClass(L"Class1", &pClass);
	AddClassProperty(pClass, L"key", true);
	pClass->SetDecoration(L"MyMachine", L"root\\foo\\boo\\goo");

	
	IWbemObjectSinkEx *pSink = NULL;
	pFinalizer->NewInboundSink(0, &pSink);
	pSink->AddRef();

	IWbemClassObject *pObj = pClass;


	for (int i = 0; i < 100000; i++)
	{
		IWbemClassObject *pObj1;

		pObj->Clone(&pObj1);
//		printf("Indicating pointer 0x%p\n", pObj1);
		pSink->Indicate(1, &pObj1);
		pObj1->Release();
	}

	pSink->SetStatus(0,WBEM_NO_ERROR,L"Boo",pObj);

	pSink->Release();

	pClass->Release();

	Sleep(10000);

	//Finalizer is self destructing!
//	pFinalizer->Release();

}




















void TestEnumerator()
{
	CWmiFinalizer *pFinalizer = new CWmiFinalizer;
	pFinalizer->AddRef();

//	pFinalizer->Configure(WMI_FNLZR_FLAG_FAST_TRACK, NULL);
	pFinalizer->Configure(WMI_FNLZR_FLAG_DECOUPLED, NULL);

	IEnumWbemClassObject *pEnum= NULL;
	pFinalizer->GetResultObject(0, IID_IEnumWbemClassObject, (void**)&pEnum);
	pEnum->AddRef();

	_IWmiObject *pClass = NULL;
	CreateClass(L"Class1", &pClass);
	AddClassProperty(pClass, L"key", true);
	pClass->SetDecoration(L"MyMachine", L"root\\foo\\boo\\goo");

	IWbemObjectSinkEx *pSink = NULL;
	pFinalizer->NewInboundSink(0, &pSink);

	IWbemClassObject *pObj = pClass;

	for (int i = 0; i < 10000; i++)
	{
		IWbemClassObject *pObj1;

		pObj->Clone(&pObj1);
		printf("Indicating object 0x%p into sink\n", pObj1);
		pSink->Indicate(1, &pObj1);
		pObj1->Release();
	}

	printf("Calling SetStatus with object of 0x%p\n", pObj);
	pSink->SetStatus(0,WBEM_NO_ERROR,L"Boo",pObj);
	pSink->Release();

	pClass->Release();


	IWbemClassObject *pEnumedObj = 0;
	do
	{
		ULONG nNum;
		HRESULT hRes = pEnum->Next(INFINITE, 1, &pEnumedObj, &nNum);

		if (hRes == WBEM_S_FALSE)
		{
			printf("Enumerator has no more items to return.\n");
			break;
		}
		if (SUCCEEDED(hRes))
		{
			printf("Enumerator returned 0x%p\n", pEnumedObj);
			pEnumedObj->Release();
		}
		else
			break;

	} while (1);


	pEnum->Release();

	pFinalizer->Release();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\testlib\maindll.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    MAINDLL.CPP

Abstract:

    Contains DLL Entrypoints

History:

--*/

#include "precomp.h"
#include <wbemcli.h>

#include <wmiutils.h>
#include <wbemint.h>



HINSTANCE g_hInstance;
long g_cLock;
long g_cObj;

//***************************************************************************
//
//  BOOL WINAPI DllMain
//
//  DESCRIPTION:
//
//  Entry point for DLL.  Good place for initialization.
//
//  PARAMETERS:
//
//  hInstance           instance handle
//  ulReason            why we are being called
//  pvReserved          reserved
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL WINAPI DllMain(
                        IN HINSTANCE hInstance,
                        IN ULONG ulReason,
                        LPVOID pvReserved)
{
    if (DLL_PROCESS_DETACH == ulReason)
    {
//        CWmiQuery::Shutdown();
    }
    else if (DLL_PROCESS_ATTACH == ulReason)
    {
        g_hInstance = hInstance;
//        CWmiQuery::Startup();
    }

    return TRUE;
}


//***************************************************************************
//
//  STDAPI DllGetClassObject
//
//  DESCRIPTION:
//
//  Called when Ole wants a class factory.  Return one only if it is the sort
//  of class this DLL supports.
//
//  PARAMETERS:
//
//  rclsid              CLSID of the object that is desired.
//  riid                ID of the desired interface.
//  ppv                 Set to the class factory.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  E_FAILED            not something we support
//
//***************************************************************************
/*
STDAPI DllGetClassObject(
                        IN REFCLSID rclsid,
                        IN REFIID riid,
                        OUT PPVOID ppv)
{
    HRESULT hr = WBEM_E_FAILED;

    IClassFactory * pFactory = NULL;
    if (CLSID_WbemDefPath == rclsid)
        pFactory = new CGenFactory<CDefPathParser>();
//postponed till Blackcomb    if (CLSID_UmiDefURL == rclsid)
//postponed till Blackcomb        pFactory = new CGenFactory<CDefPathParser>();
    else if (CLSID_WbemStatusCodeText == rclsid)
        pFactory = new CGenFactory<CWbemError>();

    else if (CLSID_WbemQuery == rclsid)
		pFactory = new CGenFactory<CWmiQuery>();

    if(pFactory == NULL)
        return E_FAIL;
    hr=pFactory->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pFactory;

    return hr;
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coredll\testlib\maintest.h ===
#ifndef __CORETEST_H__
#define __CORETEST_H__

#include <polarity.h>
#include <windows.h>
#include <wbemint.h>
#include <comdef.h>
#include <arena.h>
#ifndef CPPUNIT_TESTCASE_H
#include "TestCase.h"
#endif




class CoreTest: public TestCase
{
  
public:
    void                        setUp ();
    void                        tearDown ();

    void testExec();

public:
    CoreTest (std::string name);
    virtual ~CoreTest();
    static __declspec(dllexport) Test *suite ();
};


#endif //__WQLPARSER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\adaptest\adapelem.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// ADAPELEM.cpp : implementation file
//

#define _WIN32_WINNT 0x0400

#include <windows.h>
#include <stdio.h>
#include "adapelem.h"

CAdapElement::CAdapElement( void )
: m_lRefCount(0)
{
}

CAdapElement::~CAdapElement( void )
{
}

long CAdapElement::AddRef( void )
{
    return InterlockedIncrement( &m_lRefCount );
}

long CAdapElement::Release( void )
{
    long    lRef = InterlockedDecrement( &m_lRefCount );

    if ( 0 == lRef )
    {
        delete this;
    }

    return lRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\adaptest\adapelem.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#ifndef __ADAPELEM_H__
#define __ADAPELEM_H__

class CAdapElement
{
private:

	long	m_lRefCount;

public:

	CAdapElement( void );
	virtual ~CAdapElement(void);

	long AddRef( void );
	long Release( void );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\adaptest\adapperf.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#define _WIN32_WINNT=0x0400

#include <windows.h>
#include <stdio.h>
#include <wbemcli.h>
#include <cominit.h>
#include "ntreg.h"
#include "adapperf.h"
#include "adaptest.h"

#define PL_TIMEOUT  100000      // The timeout value for waiting on a function mutex
#define GUARD_BLOCK "WMIADAP_WMIADAP_WMIADAP_WMIADAP_WMIADAP_WMIADAP_WMIADAP_WMIADAP"

////////////////////////////////////////////////////////////////////////////////////////////
//
//                              CAdapSafeDataBlock
//
////////////////////////////////////////////////////////////////////////////////////////////

CAdapSafeBuffer::CAdapSafeBuffer()
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Constructor
//
////////////////////////////////////////////////////////////////////////////////////////////
:   m_dwGuardSize       ( 0 ),
    m_hPerfLibHeap      ( NULL ),
    m_pRawBuffer        ( NULL ),
    m_pSafeBuffer       ( NULL ),
    m_dwSafeBufferSize  ( 0 ),
    m_pCurrentPtr       ( NULL ),
    m_dwNumObjects      ( 0 )
{
    // Initialize the guard byte pattern
    // =================================

    m_dwGuardSize = sizeof( GUARD_BLOCK );
    m_pGuardBytes = new CHAR[m_dwGuardSize];
    strcpy(m_pGuardBytes, GUARD_BLOCK);

    // Create the private heap
    // =======================

    m_hPerfLibHeap = HeapCreate( HEAP_GENERATE_EXCEPTIONS, 0x100000, 0 );

    // If the private heap could not be created, then use the process heap
    // ===================================================================
    
    if ( NULL == m_hPerfLibHeap )
    {
        m_hPerfLibHeap = GetProcessHeap();
    }
}

CAdapSafeBuffer::~CAdapSafeBuffer()
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Destructor
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    // Delete the guard block
    // ======================

    delete [] m_pGuardBytes;

    // Deallocate the raw buffer 
    // =========================

    if ( NULL != m_pRawBuffer )
    {
         HeapFree( m_hPerfLibHeap, 0, m_pRawBuffer );
    }

    // Destroy the private heap
    // ========================

    if ( ( NULL != m_hPerfLibHeap ) && ( GetProcessHeap() != m_hPerfLibHeap ) )
    {
        HeapDestroy( m_hPerfLibHeap );
    }
}

HRESULT CAdapSafeBuffer::SetSize( DWORD dwNumBytes )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Sets the size of the safe buffer.  Memory is actually allocated for the raw buffer, and
//  the safe buffer just sits in the raw buffer between the set of guard bytes
//
//  Parameters:
//      dwNumBytes  - the number of bytes requested for the safe buffer
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_NO_ERROR;

    DWORD   dwRawBufferSize = 0;

    // Check for roll-over
    // ===================

    if ( dwNumBytes > ( 0xFFFFFFFF - ( 2 * m_dwGuardSize ) ) )
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    if ( SUCCEEDED ( hr ) )
    {
        // Set the total size of the buffer
        // ================================

        m_dwSafeBufferSize = dwNumBytes;
        dwRawBufferSize = dwNumBytes + ( 2 * m_dwGuardSize );

        // Allocate the memory
        // ===================

        try
        {
            if ( NULL == m_pRawBuffer )
            {
            // First time allocation
            // =====================
                m_pRawBuffer = (BYTE*) HeapAlloc( m_hPerfLibHeap, 
                                                  HEAP_ZERO_MEMORY | HEAP_GENERATE_EXCEPTIONS, 
                                                  dwRawBufferSize ); 
            }
            else
            {
                m_pRawBuffer = (BYTE*) HeapReAlloc( m_hPerfLibHeap, 
                                                    HEAP_ZERO_MEMORY | HEAP_GENERATE_EXCEPTIONS, 
                                                    m_pRawBuffer, 
                                                    dwRawBufferSize );
            }
        }
        catch(...)
        {
            m_pRawBuffer = NULL;
            m_pSafeBuffer = NULL;
            m_pCurrentPtr = NULL;
            m_dwSafeBufferSize = 0;
            hr = WBEM_E_OUT_OF_MEMORY;
        }

        if ( NULL != m_pRawBuffer )
        {
            // Set the safe buffer pointer
            // ===========================

            m_pSafeBuffer = m_pRawBuffer + m_dwGuardSize;

            // Set the prefix guard bytes
            // =========================

            memcpy( m_pRawBuffer, m_pGuardBytes, m_dwGuardSize );

            // Set the suffix guard bytes
            // ==========================

            memcpy( m_pSafeBuffer + m_dwSafeBufferSize, m_pGuardBytes, m_dwGuardSize );
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    return hr;
}

HRESULT CAdapSafeBuffer::Validate()
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Validate will compare the size of the pointer displacement matches the byte size 
//  returned from the collection, validates the guard bytes and walks the blob, verifying 
//  that all of the pointers are within the boundary of the blob
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_NO_ERROR;

    PERF_OBJECT_TYPE* pObject = (PERF_OBJECT_TYPE*) m_pSafeBuffer;

    // Validate that that number of bytes returned is the same as the pointer displacement
    // ===================================================================================

    if ( ( m_pCurrentPtr - m_pSafeBuffer ) != m_dwDataBlobSize )
    {
        hr = WBEM_E_FAILED;
    }

    if ( SUCCEEDED ( hr ) )
    {
        // Validate the guard bytes
        // ========================

        if ( 0 != memcmp( m_pRawBuffer, m_pGuardBytes, m_dwGuardSize) )
        {
            hr = WBEM_E_FAILED;
        }
        else
        {
            if ( 0 != memcmp( m_pSafeBuffer + m_dwSafeBufferSize, m_pGuardBytes, m_dwGuardSize) )
            {
                hr = WBEM_E_FAILED;
            }
        }
    }

    // Validate the blob
    // =================

    if ( SUCCEEDED( hr ) )
    {
        for ( int nObject = 0; SUCCEEDED( hr ) && nObject < m_dwNumObjects; nObject++ )
        {
            // Validate the object pointer
            // ===========================

            hr = ValidateSafePointer( (BYTE*) pObject );

            // Validate the counter definitions
            // ================================

            PERF_COUNTER_DEFINITION* pCtr = ( PERF_COUNTER_DEFINITION* ) ( ( ( BYTE* ) pObject ) + pObject->HeaderLength );
            DWORD dwCtrBlockSize = 0;

            for( int nCtr = 0; SUCCEEDED( hr ) && nCtr < pObject->NumCounters; nCtr++) 
            {
                hr = ValidateSafePointer( ( BYTE* ) pCtr );

                if ( SUCCEEDED( hr ) )
                {
                    dwCtrBlockSize += pCtr->CounterSize;

                    if ( nCtr < ( pObject->NumCounters - 1 ) )
                    {
                        pCtr = ( PERF_COUNTER_DEFINITION* ) ( ( ( BYTE* ) pCtr ) + pCtr->ByteLength );
                    }
                }
            }

            // Validate the data
            // =================

            if ( pObject->NumInstances >= 0 )
            {
                // Blob has instances
                // ==================

                PERF_INSTANCE_DEFINITION* pInstance = ( PERF_INSTANCE_DEFINITION* ) ( ( ( BYTE* ) pObject ) + pObject->DefinitionLength );
                
                // Validate the instances
                // ======================

                for ( int nInst = 0; SUCCEEDED( hr ) && nInst < pObject->NumInstances; nInst++ )
                {
                    hr = ValidateSafePointer( ( BYTE* ) pInstance );

                    if ( SUCCEEDED( hr ) )
                    {
                        // Validate the counter blocks
                        // ===========================

                        PERF_COUNTER_BLOCK* pCounterBlock = ( PERF_COUNTER_BLOCK* ) ( ( ( BYTE* ) pInstance ) + pInstance->ByteLength );

                        hr = ValidateSafePointer( ( BYTE* ) pCounterBlock );

                        if ( SUCCEEDED( hr ) )
                        {
                            // Is the counter block the same size as the aggregation of the counter sizes?
                            // ===========================================================================

//                          if ( pCounterBlock->ByteLength != dwCtrBlockSize )
//                          {
//                              hr = WBEM_E_FAILED;
//                          }

                            if ( ( nInst < pObject->NumInstances - 1 ) && SUCCEEDED( hr ) )
                            {
                                pInstance = ( PERF_INSTANCE_DEFINITION* ) ( ( ( BYTE* ) pCounterBlock ) + pCounterBlock->ByteLength );
                            }
                        }
                    }
                }
            }
            else
            {
                // Blob is a singleton. Validate the counter blocks
                // ================================================

                PERF_COUNTER_BLOCK* pCounterBlock = ( PERF_COUNTER_BLOCK* ) ( ( ( BYTE* ) pObject ) + pObject->DefinitionLength );

                hr = ValidateSafePointer( ( BYTE* ) pCounterBlock );

                if ( SUCCEEDED( hr ) )
                {
//                  if ( pCounterBlock->ByteLength != dwCtrBlockSize )
//                  {
//                      hr = WBEM_E_FAILED;
//                  }

                }
            }
        }
    }

    return hr;
}

HRESULT CAdapSafeBuffer::ValidateSafePointer( BYTE* pPtr )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Verifys that the pointer is within the blob.  The blob occupies the memory starting at 
//  the beginning of the safe buffer, and termintes at an offset equal to m_dwDataBlobSize
//
//  Parameters:
//      pPtr    - a pointer to be verified
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_NO_ERROR;

    if ( ( pPtr < m_pSafeBuffer ) && ( pPtr > m_pSafeBuffer + m_dwDataBlobSize ) )
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
}

HRESULT CAdapSafeBuffer::CopyData( BYTE** ppData, DWORD* pdwNumBytes, DWORD* pdwNumObjects )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copies the blob data from the private heap into the process heap.  The method will 
//  allocate memory in the process heap.
//
//  Parameters:
//      ppData  - a pointer to an unallocated byte array
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_NO_ERROR;

    *ppData = new BYTE[m_dwDataBlobSize];

    if ( NULL == *ppData )
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }
    else
    {
        memcpy( *ppData, m_pSafeBuffer, m_dwDataBlobSize );
    }
    
    *pdwNumBytes = m_dwDataBlobSize;
    *pdwNumObjects = m_dwNumObjects;

    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//                              CAdapPerfLib
//
////////////////////////////////////////////////////////////////////////////////////////////

CAdapPerfLib::CAdapPerfLib( LPCWSTR pwcsServiceName )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Constructor
//
//  Initializes all member variables, sets the library and function names, and creates a 
//  private heap to be used with the GetPerfBlock method.
//
//  Parameters:
//      pwcsServiceName - A Unicode string specifying the name of the perflib service.
//
////////////////////////////////////////////////////////////////////////////////////////////
:   m_wstrServiceName( pwcsServiceName ),
    m_pfnOpenProc( NULL ),
    m_pfnCollectProc( NULL ),
    m_pfnCloseProc( NULL ),
    m_pwcsLibrary( NULL ),
    m_pwcsOpenProc( NULL ),
    m_pwcsCollectProc( NULL ),
    m_pwcsCloseProc( NULL ),
    m_hLib( NULL ),
    m_fOpen( FALSE ),
    m_fOk( FALSE ),
    m_dwStatus( 0 )
{
    CNTRegistry reg;    // The registry wrapper class

    if ( FAILED( BeginProcessingStatus() ) )
        return;

    // Build the service path
    // ======================

    WString wstr = L"SYSTEM\\CurrentControlSet\\Services\\";
    wstr += pwcsServiceName;

    // Open the service registry key
    // =============================

    if ( reg.Open( HKEY_LOCAL_MACHINE, wstr ) == CNTRegistry::no_error )
    {
        DWORD   dwLength = 0;
        DWORD   dwVal = 0;

        // Open the Performance subkey
        // ===========================

        if ( reg.MoveToSubkey( L"Performance" ) == CNTRegistry::no_error )
        {
            // Now get the DLL name and the names of the entry-points
            // ======================================================

            reg.GetStr( L"Library", &m_pwcsLibrary );
            reg.GetStr( L"Open", &m_pwcsOpenProc );
            reg.GetStr( L"Collect", &m_pwcsCollectProc );
            reg.GetStr( L"Close", &m_pwcsCloseProc );

            if (    NULL != m_pwcsLibrary &&
                    NULL != m_pwcsOpenProc &&
                    NULL != m_pwcsCollectProc &&
                    NULL != m_pwcsCloseProc )
            {
                m_fOk = SUCCEEDED( Load() );
            }

        }   // IF MoveToSubKey

    }   // IF open key

    // Initialize the named function mutex (see WbemPerf for syntax of Mutex name)
    // ===========================================================================

    WCHAR wcsMutexName[256];

    swprintf( wcsMutexName, L"%S_Perf_Library_Lock_PID_%x", m_wstrServiceName, GetCurrentProcessId() );
    m_hPLMutex = CreateMutexW( 0, FALSE, wcsMutexName);
}

CAdapPerfLib::~CAdapPerfLib( void )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Destructor
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    // Delete the library and entry point names
    // ========================================

    if ( NULL != m_pwcsLibrary )
    {
        delete [] m_pwcsLibrary;
    }

    if ( NULL != m_pwcsOpenProc )
    {
        delete [] m_pwcsOpenProc;
    }

    if ( NULL != m_pwcsCollectProc )
    {
        delete [] m_pwcsCollectProc;
    }

    if ( NULL != m_pwcsCloseProc )
    {
        delete [] m_pwcsCloseProc;
    }

    // Free the library
    // ================

    if ( NULL != m_hLib )
    {
        FreeLibrary( m_hLib );
    }

    EndProcessingStatus();
}

HRESULT CAdapPerfLib::BeginProcessingStatus()
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Opens the registry key, reads the ADAP_PERFLIB_STATUS_KEY, and processes the value as 
//  follows:
//
//      ADAP_PERFLIB_OK:            The perflib has been successfully accessed before. Set 
//                                  the status flag to ADAP_PERFLIB_PROCESSING
//
//      ADAP_PERFLIB_PROCESSING:    The perflib caused the process to fail.  It is corrupt,
//                                  set the status flag to ADAP_PERFLIB_CORRUPT.
//      
//      ADAP_PERFLIB_CORRUPT:       The perflib is known to be corrupt.  Status flag retains
//                                  its value.
//
//      No Value:                   The perflib has not been accessed before. Set the 
//                                  status flag to ADAP_PERFLIB_PROCESSING.
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hr = WBEM_E_FAILED;
    CNTRegistry reg;

    WString wstr = L"SYSTEM\\CurrentControlSet\\Services\\";
    wstr += m_wstrServiceName;

    // Open the services key
    // =====================

    if ( reg.Open( HKEY_LOCAL_MACHINE, wstr ) == CNTRegistry::no_error )
    {
        DWORD dwVal;

        // Check perflib status
        // ====================

        if ( reg.GetDWORD( ADAP_PERFLIB_STATUS_KEY, &dwVal) == CNTRegistry::no_error )
        {
            switch ( dwVal )
            {
            case ADAP_PERFLIB_OK:
                {
                    // So far, perflib has behaved well. Set it to processing state
                    // ============================================================

                    hr = reg.SetDWORD( ADAP_PERFLIB_STATUS_KEY, ADAP_PERFLIB_PROCESSING );

                }break;
            case ADAP_PERFLIB_PROCESSING:
                {
                    // Perflib failed in the last access attempt before processing ended. Set as bad perflib
                    // =====================================================================================

                    reg.SetDWORD( ADAP_PERFLIB_STATUS_KEY, ADAP_PERFLIB_CORRUPT );
                    
                }break;
            case ADAP_PERFLIB_CORRUPT:
                {
                    // Sign of a bad perflib. Do not open
                    // ==================================
                }break;
            default:
                {
                    // Invalid state
                    // =============

                    // TODO: log an error

                }break;
            }
        } 
        else
        {
            // This is the first time that we have touched this perflib. Set it to the processing state
            // ========================================================================================

            hr = reg.SetDWORD( ADAP_PERFLIB_STATUS_KEY, ADAP_PERFLIB_PROCESSING );
        }
    }

    return hr;
}

HRESULT CAdapPerfLib::EndProcessingStatus()
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Opens the service registry key, reads the ADAP_PERFLIB_STATUS_KEY, and processes the 
//  value as follows:
//
//      ADAP_PERFLIB_PROCESSING:    Valid state. Set status flag to ADAP_PERFLIB_OK.
//
//      ADAP_PERFLIB_CORRUPT:       Valid state (may have been set during processing). 
//                                  Leave status flag as is.
//
//      ADAP_PERFLIB_OK:            Invalid state. Return an error and log an event.
//
//      No Value:                   Invalid state. Return an error and log an event.
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hr = WBEM_E_FAILED;
    CNTRegistry reg;

    WString wstr = L"SYSTEM\\CurrentControlSet\\Services\\";
    wstr += m_wstrServiceName;

    // Open the services key
    // =====================

    if ( reg.Open( HKEY_LOCAL_MACHINE, wstr ) == CNTRegistry::no_error )
    {
        DWORD   dwVal = 0;

        // Check perflib status
        // ====================

        if ( reg.GetDWORD( ADAP_PERFLIB_STATUS_KEY, &dwVal) == CNTRegistry::no_error )
        {
            switch ( dwVal )
            {
            case ADAP_PERFLIB_PROCESSING:
                {
                    // Perflib failed in the last access attempt before processing ended.  Set as bad perflib
                    // ======================================================================================

                    hr = reg.SetDWORD( ADAP_PERFLIB_STATUS_KEY, ADAP_PERFLIB_OK );
                }break;

            case ADAP_PERFLIB_CORRUPT:
                {
                    // Valid state.  Leave as is.
                    // ==========================
                }break;

            case ADAP_PERFLIB_OK:
                {
                    // Invalid state
                    // =============

                    // TODO: log an error

                }break;
            
            default:
                {
                    // Really bad state
                    // ================

                    // TODO: log an error
                }
            }
        }
        else 
        {
            // There is no status key. Something wacky has happened
            // ====================================================

            // TODO: log an error

            hr = WBEM_E_FAILED;
        }
    }

    return hr;
}

HRESULT CAdapPerfLib::Load( void )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Loads the library and resolves the addresses for the Open, Collect and Close entry 
//  points.
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_E_FAILED;

    // Free the library if it has been previously loaded
    // =================================================

    if ( NULL != m_hLib )
    {
        FreeLibrary( m_hLib );
    }

    // Load the predefined library
    // ===========================

    m_hLib = LoadLibraryW( m_pwcsLibrary );

    if ( NULL != m_hLib )
    {
        char    szName[256];

        // No Wide version of GetProcAddress?  sigh... Get the entry point addresses
        // =========================================================================

        WideCharToMultiByte( CP_ACP, 0L, m_pwcsOpenProc, lstrlenW( m_pwcsOpenProc ) + 1,
            szName, 256, NULL, NULL );
        m_pfnOpenProc = (PM_OPEN_PROC*) GetProcAddress( m_hLib, szName );

        WideCharToMultiByte( CP_ACP, 0L, m_pwcsCollectProc, lstrlenW( m_pwcsCollectProc ) + 1,
            szName, 256, NULL, NULL );
        m_pfnCollectProc = (PM_COLLECT_PROC*) GetProcAddress( m_hLib, szName );

        WideCharToMultiByte( CP_ACP, 0L, m_pwcsCloseProc, lstrlenW( m_pwcsCloseProc ) + 1,
            szName, 256, NULL, NULL );
        m_pfnCloseProc = (PM_CLOSE_PROC*) GetProcAddress( m_hLib, szName );

        if ( NULL != m_pfnOpenProc &&
             NULL != m_pfnCollectProc &&
             NULL != m_pfnCloseProc )
        {
            hr = WBEM_S_NO_ERROR;
        }
    }
    else
    {
        SetStatus(ADAP_BAD_PROVIDER);
    }

    return hr;
}


HRESULT CAdapPerfLib::Open( void )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Wraps a call to the perflib's open function.  Fetches and passes an exports parameter
//  to the open function if it exists.
//
//  Note: We should use the named mutex to guard around the calls to Open/Collect/Close
//  
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Verify provider status 
    // ======================

    if ( CheckStatus(ADAP_BAD_PROVIDER) )
    {
        hr = WBEM_E_NOT_AVAILABLE;
    }

    // Check to ensure that the library has not yet been opened
    // ========================================================

    if ( ( !m_fOpen ) && SUCCEEDED ( hr ) )
    {
        CNTRegistry reg;    // The registry wrapper class

        // Build the service path
        // ======================

        WString     wstr = L"SYSTEM\\CurrentControlSet\\Services\\";
        wstr += m_wstrServiceName;

        // Open the registry
        // =================

        if ( reg.Open( HKEY_LOCAL_MACHINE, wstr ) == CNTRegistry::no_error )
        {
            WCHAR*  pwcsExports = NULL;

            // Get Exports if they are available.  I think this is correct...
            // ==============================================================

            if ( reg.MoveToSubkey( L"Linkage" ) == CNTRegistry::no_error )
            {
                DWORD   dwNumBytes = 0;

                reg.GetMultiStr( L"Export", &pwcsExports, dwNumBytes );
            }

            // Call the Open function for the perflib
            // ======================================

            switch ( WaitForSingleObject( m_hPLMutex, PL_TIMEOUT ) )
            {
            case WAIT_OBJECT_0:
                {
                    try 
                    {
                        if ( m_pfnOpenProc( pwcsExports ) == ERROR_SUCCESS )
                        {
                            hr = WBEM_S_NO_ERROR;
                            m_fOpen = TRUE;
                        }
                        else
                        {
                            SetStatus( ADAP_INACTIVE_PERFLIB );
                            hr = WBEM_E_NOT_AVAILABLE;
                        }
                    }
                    catch (...)
                    {
                        hr = WBEM_E_FAILED;
                    }
                } break;
            case WAIT_TIMEOUT:
                {
                    hr = WBEM_E_NOT_AVAILABLE;
                }break;
            case WAIT_ABANDONED:
                {
                    hr = WBEM_E_FAILED;
                }break;
            default:
                {
                    hr = WBEM_E_FAILED;
                }
            } // switch

            ReleaseMutex( m_hPLMutex );

        }   // IF reg.Open
        else
        {
            hr = WBEM_E_FAILED;
        }
    }

    return hr;
}

HRESULT CAdapPerfLib::GetPerfBlock( PERF_OBJECT_TYPE** ppData, DWORD* pdwBytes, DWORD* pdwNumObjTypes, BOOL fCostly )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Wraps a call to the perflib's collect function.  Will create progressively larger buffers
//  in a private heap to attempt to fetch the performance data block.
//
//  Parameters:
//      ppData          - a pointer to a buffer pointer for the data blob
//      pdwBytes        - a pointer to the byte-size of the data blob
//      pdwNumObjTypes  - a pointer to the number of objects in the data blob
//      fCostly         - a flag to determine what type of data to collect (costly or global)
//
//  NOTE: This should always return perf object type data, since we cannot specify a 
//  foreign computer, which would cause the collect function to return a PERF_DATA_BLOCK 
//  structure.
//  
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CAdapSafeBuffer SafeBuffer;                 // The safe buffer
    DWORD   dwNumBytes = 0;                     // Byte counter for the buffer size
    DWORD   dwError = ERROR_MORE_DATA;          // The return value for the collect function

    // Verify provider status 
    // ======================

    if ( m_fOpen )
    {
        // Sets the data-to-fetch parameter
        // ================================

        WCHAR*  pwcsValue = ( fCostly ? L"Costly" : L"Global" );
        
        // Start buffer at 64k (the guarded (safe) buffer is 2 * GUARD_BLOCK bytes smaller) 
        // ==================================================================================

        dwNumBytes = 0x10000;

        // Repeatedly attempt to collect the data until successful (buffer is sufficiently 
        // large), or the attempt fails for a reason other than buffer size
        // ===============================================================================

        while  ( (ERROR_MORE_DATA == dwError ) && ( SUCCEEDED( hr ) ) )
        {
            // Allocate a raw buffer of size dwNumBytes
            // ========================================

            hr = SafeBuffer.SetSize( dwNumBytes );

            // Collect the data from the perflib
            // =================================

            switch ( WaitForSingleObject( m_hPLMutex, PL_TIMEOUT ) )
            {
            case WAIT_OBJECT_0:
                {
                    try 
                    {
                        dwError = m_pfnCollectProc( pwcsValue,                                  
                                    SafeBuffer.GetSafeBufferPtrPtr(), 
                                    SafeBuffer.GetDataBlobSizePtr(), 
                                    SafeBuffer.GetNumObjTypesPtr() );
                    }
                    catch (...)
                    {
                        hr = WBEM_E_FAILED;
                    }
                }break;

            default:
                {
                    hr = WBEM_E_NOT_AVAILABLE;
                }
            } // switch

            ReleaseMutex( m_hPLMutex );

            if ( SUCCEEDED( hr ) )
            {
                switch (dwError)
                {
                case ERROR_SUCCESS:
                    {
                        hr = SafeBuffer.Validate();

                        if ( SUCCEEDED( hr ) )
                        {
                            hr = SafeBuffer.CopyData( (BYTE**) ppData, pdwBytes, pdwNumObjTypes );
                        }
                    } break;
                case ERROR_MORE_DATA:
                    {
                        // Grow in 64k chunks
                        // ==================

                        dwNumBytes += 0x10000;
                    } break;
                default:
                    {
                        hr = WBEM_E_FAILED;
                    }
                } // switch
            } // IF SUCCEEDED()
        } // WHILE

        // Clean up the buffer
        // ===================
    } // IF CheckStatus

    return hr;
}

HRESULT CAdapPerfLib::Close( void )
////////////////////////////////////////////////////////////////////////////////////////////
// 
//  Wraps a call to the perflib's close function.
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Verify that the perflib is actually open
    // ========================================

    if ( m_fOpen )
    {
        // Get the mutex
        // =============

        switch ( WaitForSingleObject( m_hPLMutex, PL_TIMEOUT ) )
        {
        case WAIT_OBJECT_0:
            {
                try
                {
                    // And call the function
                    // =====================

                    m_pfnCloseProc();
                }
                catch (...)
                {
                    // Ooops... something blew, return error code
                    // ==========================================

                    hr = WBEM_E_FAILED;
                }
            }break;
        default:
            {
                // Could not get the Mutex
                // =======================

                hr = WBEM_E_NOT_AVAILABLE;
            }
        }

        ReleaseMutex( m_hPLMutex );
    }

    return hr;
}

HRESULT CAdapPerfLib::SetStatus(DWORD dwStatus)
{
    HRESULT hr = WBEM_NO_ERROR;

    // Modify the status field
    // =======================

    m_dwStatus |= dwStatus;

    // Perform any action required as a result of the change in status
    // ===============================================================

    switch ( dwStatus )
    {
    case ADAP_BAD_PROVIDER:
        {
            CNTRegistry reg;
            WString     wstr = L"SYSTEM\\CurrentControlSet\\Services\\";
            wstr += m_wstrServiceName;

            if (reg.Open( HKEY_LOCAL_MACHINE, wstr ) == CNTRegistry::no_error)
            {
                if ( FAILED( reg.SetDWORD( ADAP_PERFLIB_STATUS_KEY, ADAP_PERFLIB_CORRUPT ) ) )
                {
                    hr = WBEM_E_FAILED;
                }
            }
            else
            {
                hr = WBEM_E_FAILED;
            }

        }break;
    }

    return hr;
}

HRESULT CAdapPerfLib::ClearStatus(DWORD dwStatus)
{
    HRESULT hr = WBEM_NO_ERROR;

    m_dwStatus &= ~dwStatus;

    // Perform any action required as a result of the change in status
    // ===============================================================

    switch ( dwStatus )
    {
    case ADAP_BAD_PROVIDER:
        {
            CNTRegistry reg;
            WString     wstr = L"SYSTEM\\CurrentControlSet\\Services\\";
            wstr += m_wstrServiceName;

            if (reg.Open( HKEY_LOCAL_MACHINE, wstr ) == CNTRegistry::no_error)
            {
                if ( FAILED( reg.SetDWORD( ADAP_PERFLIB_STATUS_KEY, ADAP_PERFLIB_PROCESSING ) ) )
                {
                    hr = WBEM_E_FAILED;
                }
            }
            else
            {
                hr = WBEM_E_FAILED;
            }

        }break;
    }

    return hr;
}

BOOL CAdapPerfLib::CheckStatus(DWORD dwStatus)
{
    return ((m_dwStatus & dwStatus) == dwStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\adaptest\adapcls.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// Use this guy to build a list of class objects we can retrieve via
// class name.  At this time, it just brute forces a class and a flex
// array, but could be modified to use an STL map just as easily.

#ifndef __ADAPCLS_H__
#define __ADAPCLS_H__

#include <wbemcomn.h>
#include <fastall.h>
#include "adapelem.h"

#define ADAP_OBJECT_IS_REGISTERED	0x0001L
#define ADAP_OBJECT_IS_INACTIVE		0x0002L

class CAdapClassElem
{
private:

	WString				m_wstrClassName;
	WString				m_wstrServiceName;
	IWbemClassObject*	m_pObj;
	BOOL				m_bOk;
	DWORD				m_dwStatus;

public:

	CAdapClassElem( IWbemClassObject* pObj );
	~CAdapClassElem();

	HRESULT SetStatus( DWORD dwStatus );
	HRESULT ClearStatus( DWORD dwStatus );
	BOOL CheckStatus( DWORD dwStatus );

	HRESULT InactivePerflib( LPCWSTR pwszLibName );

	HRESULT	GetObject( LPCWSTR pwszClassName, IWbemClassObject** ppObj );

	HRESULT GetClassName( WString& wstr )
	{
		try
		{
			wstr = m_wstrClassName;
			return WBEM_S_NO_ERROR;
		}
		catch(...)
		{
			return WBEM_E_OUT_OF_MEMORY;
		}
	}

	HRESULT GetServiceName( WString& wstr )
	{
		try
		{
			wstr = m_wstrServiceName;
			return WBEM_S_NO_ERROR;
		}
		catch(...)
		{
			return WBEM_E_OUT_OF_MEMORY;
		}
	}

	HRESULT GetClassName( BSTR* pbStr )
	{
		*pbStr = SysAllocString( (LPCWSTR) m_wstrClassName );
		return ( NULL == *pbStr ? WBEM_E_OUT_OF_MEMORY : WBEM_S_NO_ERROR );
	}

	BOOL IsClass( LPCWSTR pwcsClassName )
	{
		return ( m_wstrClassName.EqualNoCase( pwcsClassName ) );
	}

	BOOL IsService( LPCWSTR pwcsServiceName )
	{
		return ( m_wstrServiceName.EqualNoCase( pwcsServiceName ) );
	}

	HRESULT GetData( WString& wstr, IWbemClassObject** ppObj )
	{
		try
		{
			wstr = m_wstrClassName;
			m_pObj->AddRef();
			*ppObj = m_pObj;
			return WBEM_S_NO_ERROR;
		}
		catch(...)
		{
			return WBEM_E_OUT_OF_MEMORY;
		}
	}

	HRESULT GetData( WString& wstrClass, WString& wstrServiceName, IWbemClassObject** ppObj )
	{
		try
		{
			wstrClass = m_wstrClassName;
			wstrServiceName = m_wstrServiceName;
			m_pObj->AddRef();
			*ppObj = m_pObj;
			return WBEM_S_NO_ERROR;
		}
		catch(...)
		{
			return WBEM_E_OUT_OF_MEMORY;
		}
	}

	BOOL IsOk( void )
	{
		return m_bOk;
	}


};

class CAdapClassList : public CAdapElement
{
private:
	CFlexArray	m_array;

public:

	CAdapClassList();
	~CAdapClassList();

	// Helper functions to build the list and then access/remove
	// list elements.

	HRESULT AddClassObject( IWbemClassObject* pObj );
	HRESULT	BuildList( IWbemServices* pNameSpace );
	HRESULT GetListElement( LPCWSTR pwcsClassName, CAdapClassElem** ppEl );
	HRESULT GetClassObject( LPCWSTR pwcsClassName, IWbemClassObject** ppObj );
	HRESULT	GetAt( int nIndex, WString& wstrName, WString& wstrServiceName,
						IWbemClassObject** ppObj );
	HRESULT GetAt( int nIndex, CAdapClassElem** ppEl );

	HRESULT	RemoveAt( int nIndex );

	HRESULT	Remove( LPCWSTR pwcsClassName );
	HRESULT	RemoveAll( LPCWSTR pwcsServiceName );

	HRESULT InactivePerflib( LPCWSTR pwszServiceName );

	long GetSize( void )
	{
		return m_array.Size();
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\adaptest\adapcls.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// OBJINTERNALSTESTDlg.cpp : implementation file
//

#define _WIN32_WINNT 0x0400

#include <windows.h>
#include <stdio.h>
#include <wbemcli.h>
#include <cominit.h>
#include "adapcls.h"
#include "ntreg.h"

////////////////////////////////////////////////////////////////////////////////////////////
//
//                              CAdapClassElem
//
////////////////////////////////////////////////////////////////////////////////////////////

CAdapClassElem::CAdapClassElem( IWbemClassObject* pObj ) : m_pObj( pObj ), m_bOk( FALSE ), m_dwStatus( 0 )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Constructor
//
//  Note that we are using direct CWbemObject method calls.
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    // Verify that we were passed an object
    // ====================================

    if ( NULL != m_pObj )
    {
        m_pObj->AddRef();

        // Get the object's name
        // =====================

        CVar    var;
        if ( SUCCEEDED( ((CWbemObject*) m_pObj)->GetClassName( &var ) ) )
        {
            try
            {
                m_wstrClassName = var.GetLPWSTR();

                // Dump this
                var.Empty();

                // Now get the genericperfctr and registrykey values (once again, we are WBEM, we will
                // cheat)

                if ( SUCCEEDED( ((CWbemObject*) m_pObj)->GetQualifier( L"genericperfctr", &var ) ) )
                {
                    // The class must be a genericperfctr class
                    if ( var.GetBool() )
                    {

                        var.Empty();

                        if ( SUCCEEDED( ((CWbemObject*) m_pObj)->GetQualifier( L"registrykey", &var ) ) )
                        {
                            m_wstrServiceName = var.GetLPWSTR();
                            m_bOk = TRUE;
                        }

                    }   // IF generic provider

                }   // IF provider qualifier

            }   // try
            catch (...)
            {
                // No need to do any special error handling here
            }

        }

    }   // IF NULL != m_pObj
}

// Class Destructor
CAdapClassElem::~CAdapClassElem( void )
{
    if ( NULL != m_pObj )
    {
        m_pObj->Release();
    }
}

// Returns object if the classname matches
HRESULT CAdapClassElem::GetObject( LPCWSTR pwszClassName, IWbemClassObject** ppObj )
{
    if ( m_wstrClassName.EqualNoCase( pwszClassName ) )
    {
        *ppObj = m_pObj;
        m_pObj->AddRef();
        return WBEM_S_NO_ERROR;
    }

    return WBEM_E_FAILED;
}

HRESULT CAdapClassElem::SetStatus( DWORD dwStatus )
{
    m_dwStatus |= dwStatus;

    return WBEM_NO_ERROR;
}

HRESULT CAdapClassElem::ClearStatus( DWORD dwStatus )
{
    m_dwStatus &= ~dwStatus;

    return WBEM_NO_ERROR;
}

BOOL CAdapClassElem::CheckStatus( DWORD dwStatus )
{
    return ( ( m_dwStatus & dwStatus ) == dwStatus );
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//                              CAdapClassList
//
////////////////////////////////////////////////////////////////////////////////////////////

CAdapClassList::CAdapClassList( void )
:   CAdapElement(),
    m_array()
{
}

CAdapClassList::~CAdapClassList( void )
{
    // Walk the list and delete all remaining objects
    for ( int x = 0; x < m_array.Size(); x++ )
    {
        CAdapClassElem* pElem = (CAdapClassElem*) m_array[x];
        delete pElem;
    }
}

// Adds an element to the classlist
HRESULT CAdapClassList::AddClassObject( IWbemClassObject* pObj )
{
    HRESULT hr = WBEM_NO_ERROR;

    // Create a new class list element
    // ===============================

    CAdapClassElem* pElem = new CAdapClassElem( pObj );

    if ( NULL != pElem )
    {
        if ( pElem->IsOk() )
        {
            // If everything worked out, add it to the class list
            // ==================================================

            if ( m_array.Add( pElem ) != CFlexArray::no_error )
            {
                // Add failed
                // ==========

                delete pElem;
                pElem = NULL;
                hr = WBEM_E_FAILED;
            }
        }
        else
        {
            // It may not have been a perflib object
            // =====================================

            delete pElem;
            pElem = NULL;
            hr = WBEM_S_FALSE;
        }
    }
    else
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

// Builds a list of class objects that can be located by name
HRESULT CAdapClassList::BuildList( IWbemServices* pNamespace )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Create the class enumerator
    // ===========================

    BSTR    bstrClass = SysAllocString( L"Win32_PerfRawData" );

    if ( NULL != bstrClass )
    {
        IEnumWbemClassObject*   pEnum = NULL;
        hr = pNamespace->CreateClassEnum( bstrClass,
                                        WBEM_FLAG_SHALLOW,
                                        NULL,
                                        &pEnum );
        // Walk the enumerator
        // ===================

        if ( SUCCEEDED( hr ) )
        {
            ULONG   ulTotalReturned = 0;

            // Set Interface security
            // ======================

            WbemSetProxyBlanket( pEnum, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
                RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE );

            // Walk the object list in blocks of 100
            // =====================================

            while ( SUCCEEDED( hr ) && WBEM_S_FALSE != hr)
            {
                ULONG   ulNumReturned = 0;

                IWbemClassObject*   apObjectArray[100];

                ZeroMemory( apObjectArray, sizeof(apObjectArray) );

                // Fetch the objects from the enumerator in blocks of 100
                // ======================================================

                hr = pEnum->Next( WBEM_INFINITE,
                                100,
                                apObjectArray,
                                &ulNumReturned );

                // For each object, add it to the class list array
                // ===============================================

                if ( SUCCEEDED( hr ) && ulNumReturned > 0 )
                {
                    ulTotalReturned += ulNumReturned;

                    // Add the objects
                    // ===============

                    for ( int x = 0; SUCCEEDED( hr ) && x < ulNumReturned; x++ )
                    {
                        hr = AddClassObject( apObjectArray[x] );
                        apObjectArray[x]->Release();
                    }

                    // If an add operation failed, release the rest of the pointers
                    // ============================================================

                    if ( FAILED( hr ) )
                    {
                        for ( ; x < ulNumReturned; x++ )
                        {
                            apObjectArray[x]->Release();
                        }

                    }   // IF FAILED( hr ) )

                }   // IF Next

            }   // WHILE enuming

            if ( WBEM_S_FALSE == hr )
            {
                hr = WBEM_S_NO_ERROR;
            }

            pEnum->Release();

        }   // IF CreateClassEnum

        SysFreeString( bstrClass );

    }
    else
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

// Gets the class object for the specified name
HRESULT CAdapClassList::GetClassObject( LPCWSTR pwcsClassName, IWbemClassObject** ppObj )
{
    HRESULT hr = WBEM_E_FAILED;
    IWbemClassObject* pObj = NULL;
    CAdapClassElem* pTempEl = NULL;

    // Cycle through the list until GetObject() is successful (i.e. found the object)
    // ==============================================================================

    for ( int x = 0; FAILED(hr) && x < m_array.Size(); x++ )
    {
        pTempEl = (CAdapClassElem*) m_array[x];
        hr = pTempEl->GetObject( pwcsClassName, &pObj );
    }

    *ppObj = pObj;

    return hr;
}

HRESULT CAdapClassList::GetListElement( LPCWSTR pwcsClassName, CAdapClassElem** ppEl )
{
    HRESULT hr = WBEM_E_FAILED;
    IWbemClassObject* pObj = NULL;
    CAdapClassElem* pTempEl = NULL;

    // Cycle through the list until GetObject() is successful (i.e. found the object)
    // ==============================================================================

    for ( int x = 0; FAILED(hr) && x < m_array.Size(); x++ )
    {
        pTempEl = (CAdapClassElem*) m_array[x];
        hr = pTempEl->GetObject( pwcsClassName, &pObj );
    }

    *ppEl = pTempEl;

    return hr;
}

// Returns object data at the index
HRESULT CAdapClassList::GetAt( int nIndex, WString& wstrClassName, WString& wstrServiceName,
                              IWbemClassObject** ppObj )
{
    HRESULT hr = WBEM_E_FAILED;

    if ( nIndex < m_array.Size() )
    {
        CAdapClassElem* pEl = (CAdapClassElem*) m_array[nIndex];

        if ( NULL != pEl )
        {
            hr = pEl->GetData( wstrClassName, wstrServiceName, ppObj );
        }
    }

    return hr;
}

HRESULT CAdapClassList::GetAt( int nIndex, CAdapClassElem** ppEl )
{
    HRESULT hr = WBEM_E_FAILED;

    if ( nIndex < m_array.Size() )
    {
        *ppEl = (CAdapClassElem*) m_array[nIndex];
        hr = WBEM_S_NO_ERROR;
    }

    return hr;
}

// Removes the object at the index
HRESULT CAdapClassList::RemoveAt( int nIndex )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CAdapClassElem* pEl = (CAdapClassElem*) m_array[nIndex];

    if ( NULL != pEl )
    {
        delete pEl;
    }

    m_array.RemoveAt( nIndex );

    return hr;
}

// Locates the specified classname and removes the element 
HRESULT CAdapClassList::Remove( LPCWSTR pwcsClassName )
{
    HRESULT hr = WBEM_E_FAILED;

    for ( int x = 0; FAILED(hr) && x < m_array.Size(); x++ )
    {
        CAdapClassElem* pEl = (CAdapClassElem*) m_array[x];

        if ( pEl->IsClass( pwcsClassName ) )
        {
            hr = RemoveAt( x );
        }

    }

    return hr;
}

// Locates classes with the same service name and removes  them
HRESULT CAdapClassList::RemoveAll( LPCWSTR pwcsServiceName )
{
    HRESULT hr = WBEM_E_FAILED;
    int x = 0;

    while ( x < m_array.Size() )
    {
        CAdapClassElem* pEl = (CAdapClassElem*) m_array[x];

        // IF we get a match, remove it, but don't increment x (we removed
        // an element, (duh!)).  Otherwise, go to the next element
        if ( pEl->IsService( pwcsServiceName ) )
        {
            hr = RemoveAt( x );
        }
        else
        {
            x++;
        }
    }

    return hr;
}

// Cycle through all of the objects and set the inactive status for any object
// with an index between the library's counter index range

HRESULT CAdapClassList::InactivePerflib( LPCWSTR pwszServiceName )
{
    HRESULT hr = WBEM_NO_ERROR;

    CNTRegistry reg;
    WCHAR wszRegPath[256];
    DWORD dwFirstCtr, dwLastCtr;

    // Open the service's registry key
    // ===============================

    swprintf( wszRegPath, L"SYSTEM\\CurrentControlSet\\Services\\%S", pwszServiceName);
    if ( CNTRegistry::no_error == reg.Open( HKEY_LOCAL_MACHINE, wszRegPath ) )
    {
        // Go to the perfomance subkey
        // ===========================
    
        reg.MoveToSubkey( L"Performance" );

        // Get the first and last counter values
        // =====================================

        reg.GetDWORD( L"First Counter", &dwFirstCtr );
        reg.GetDWORD( L"Last Counter", &dwLastCtr );

        for(int i = 0; i < GetSize(); i++)
        {
            CWbemObject* pObj = NULL;
            CVar varIndex;
            DWORD dwIndex;
            WString wstrClassName;

            // Get the object's perf index
            // ===========================

            CAdapClassElem* pEl = (CAdapClassElem*) m_array[i];
            hr = pEl->GetData( wstrClassName, (IWbemClassObject**)&pObj );
            pObj->GetProperty( L"perfindex", &varIndex );
            dwIndex = varIndex.GetDWORD();
            pObj->Release();

            if ( ( dwIndex >= dwFirstCtr ) && ( dwIndex <= dwLastCtr ) )
            {
                pEl->SetStatus( ADAP_OBJECT_IS_INACTIVE ); 
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\adaptest\adapperf.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// Use this guy to build a map of index to display name from a localized
// Name Database  At this time, it just brute forces a class and a flex
// array, but could be modified to use an STL map just as easily.

#ifndef __ADAPPERF_H__
#define __ADAPPERF_H__

#include <wbemcomn.h>
#include "ntreg.h"

#define ADAP_PERFLIB_STATUS_KEY	L"WbemAdapStatus"
#define ADAP_PERFLIB_PROCESSING	0L
#define	ADAP_PERFLIB_OK			1L
#define ADAP_PERFLIB_CORRUPT	-1L

#define ADAP_BAD_PROVIDER		0x0001L
#define ADAP_INACTIVE_PERFLIB	0x0002L

class CAdapSafeBuffer
{
	HANDLE	m_hPerfLibHeap;		// A handle to the private heap for the data block

	CHAR*	m_pGuardBytes;
	DWORD	m_dwGuardSize;

	BYTE*	m_pRawBuffer;

	BYTE*	m_pSafeBuffer;
	DWORD	m_dwSafeBufferSize;

	BYTE*	m_pCurrentPtr;
	DWORD	m_dwDataBlobSize;
	DWORD	m_dwNumObjects;

	HRESULT ValidateSafePointer( BYTE* pPtr );

public:
	CAdapSafeBuffer();
	virtual ~CAdapSafeBuffer();

	HRESULT SetSize( DWORD dwNumBytes );
	HRESULT Validate();
	HRESULT CopyData( BYTE** ppData, DWORD* pdwNumBytes, DWORD* pdwNumObjects );

	void** GetSafeBufferPtrPtr() { m_pCurrentPtr = m_pSafeBuffer; return (void**) &m_pCurrentPtr; }
	DWORD* GetDataBlobSizePtr() { m_dwDataBlobSize = m_dwSafeBufferSize; return &m_dwDataBlobSize; }
	DWORD* GetNumObjTypesPtr() {m_dwNumObjects = 0; return &m_dwNumObjects; }
};

class CAdapPerfLib
{
private:

	WString				m_wstrServiceName;	// The service name of the perflib
	WCHAR*				m_pwcsLibrary;		// The file name of the perflib
	WCHAR*				m_pwcsOpenProc;		// The name of the perflib's open function
	WCHAR*				m_pwcsCollectProc;	// The name of the perflib's collect function
	WCHAR*				m_pwcsCloseProc;	// The name of the perflib's close function

	PM_OPEN_PROC*		m_pfnOpenProc;		// The function pointer to the perflib's open function
	PM_COLLECT_PROC*	m_pfnCollectProc;	// The function pointer to the perflib's collect function
	PM_CLOSE_PROC*		m_pfnCloseProc;		// The function pointer to the perflib's close function
	HANDLE				m_hPLMutex;			// Used for serializing the calls to open/collect/close

	BOOL				m_fOk;
	BOOL				m_fOpen;			// Flags whether the perflib's open function has been called

	DWORD				m_dwStatus;			// The status of the perflib

	HINSTANCE			m_hLib;				// The handle to the perflib

	HRESULT	Load( void );

protected:
	HRESULT BeginProcessingStatus();
	HRESULT EndProcessingStatus();

public:

	CAdapPerfLib( LPCWSTR pwcsServiceName );
	~CAdapPerfLib();

	HRESULT Open( void );
	HRESULT	GetPerfBlock( PERF_OBJECT_TYPE** ppData, DWORD* pdwBytes, DWORD* pdwNumObjTypes, BOOL fCostly );
	HRESULT	Close( void );

	BOOL IsOk( void )
	{
		return m_fOk;
	}

	LPCWSTR GetServiceName( void )
	{
		return m_wstrServiceName;
	}

	LPCWSTR GetLibraryName( void )
	{
		return m_pwcsLibrary;
	}

	HRESULT SetStatus( DWORD dwStatus );
	HRESULT ClearStatus( DWORD dwStatus );
	BOOL CheckStatus( DWORD dwStatus );
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\adaptest\adapreg.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// Use this guy to build a list of class objects we can retrieve via
// class name.  At this time, it just brute forces a class and a flex
// array, but could be modified to use an STL map just as easily.

#ifndef __ADAPREG_H__
#define __ADAPREG_H__

#include <wbemcomn.h>
#include <fastall.h>
#include "perfthrd.h"
#include "locallist.h"
#include "ntreg.h"

// Forward classes
class CAdapSync;

class CAdapRegPerf : public CNTRegistry
{
private:
	CPerfThread	m_PerfThread;

protected:
	HRESULT ProcessLibrary( CAdapSync* pAdapSync, CAdapPerfLib* pPerfLib,
					CLocalizationSyncList* plocalizationList );

public:

	CAdapRegPerf();
	~CAdapRegPerf();

	// This will need to be modified to handle localization namespaces as
	// well
	HRESULT EnumPerfDlls( CAdapSync* pAdapSync, CLocalizationSyncList* plocalizationList );

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\adaptest\adapreg.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// OBJINTERNALSTESTDlg.cpp : implementation file
//

#define _WIN32_WINNT 0x0400

#include <windows.h>
#include <stdio.h>
#include <wbemcli.h>
#include <cominit.h>
#include "ntreg.h"
#include "adapperf.h"
#include "adapsync.h"
#include "adapreg.h"
#include "adaptest.h"

//	IMPORTANT!!!!

//	This code MUST be revisited to do the following:
//	A>>>>>	Exception Handling around the outside calls
//	B>>>>>	Use a named mutex around the calls
//	C>>>>>	Make the calls on another thread
//	D>>>>>	Place and handle registry entries that indicate a bad DLL!

CAdapRegPerf::CAdapRegPerf()
{
}

CAdapRegPerf::~CAdapRegPerf()
{
}

// Calls for global and costly data in each library
HRESULT CAdapRegPerf::ProcessLibrary( CAdapSync* pAdapSync, CAdapPerfLib* pPerfLib,
									 CLocalizationSyncList* pLocalizationList )
{
	// Call into the perflib and enumerate all of the classes within the perflib
	// =========================================================================

	// DEVNOTE:TODO - Perform Open, both GetPerfBlocks, and Close before registering in case
	// anything bad happens, to keep us from half registering anything

	HRESULT	hr = m_PerfThread.Open( pPerfLib );

	if ( SUCCEEDED( hr ) )
	{
		PERF_OBJECT_TYPE*	pPerfObjType = NULL;
		DWORD				dwNumBytes = 0,
							dwNumObjectTypes = 0;

		// Get the "Global" objects
		// ========================

		hr = m_PerfThread.GetPerfBlock( pPerfLib, &pPerfObjType, &dwNumBytes, &dwNumObjectTypes, FALSE );

		if ( SUCCEEDED( hr ) )
		{
			// Now walk the BLOB and verify the WMI class definitions
			// ======================================================

			hr = pAdapSync->ProcessObjectBlob( pPerfLib->GetServiceName(), pPerfObjType, dwNumObjectTypes, FALSE );

			// Now let the localization code do its dirty work
			if ( SUCCEEDED( hr ) )
			{
				hr = pLocalizationList->ProcessObjectBlob( pPerfLib->GetServiceName(), pPerfObjType, dwNumObjectTypes, FALSE );
			}

			if ( NULL != pPerfObjType )
			{
				delete [] pPerfObjType;
				pPerfObjType = NULL;
				dwNumBytes = 0;
				dwNumObjectTypes = 0;
			}
		}

		// Get the "Costly" objects
		// ========================

		hr = m_PerfThread.GetPerfBlock( pPerfLib, &pPerfObjType, &dwNumBytes, &dwNumObjectTypes, TRUE );

		if ( SUCCEEDED( hr ) )
		{
			// Now walk the BLOB and verify the WMI class definitions
			// ======================================================

			hr = pAdapSync->ProcessObjectBlob( pPerfLib->GetServiceName(), pPerfObjType, dwNumObjectTypes, TRUE );

			// Now let the localization code do its dirty work
			if ( SUCCEEDED( hr ) )
			{
				hr = pLocalizationList->ProcessObjectBlob( pPerfLib->GetServiceName(), pPerfObjType, dwNumObjectTypes, FALSE );
			}

			if ( NULL != pPerfObjType )
			{
				delete [] pPerfObjType;
				pPerfObjType = NULL;
				dwNumBytes = 0;
				dwNumObjectTypes = 0;
			}
		}

		// Close and get out
		m_PerfThread.Close( pPerfLib );
	}
	else 
	{
		// If the perflib is inactive, mark all of the objects as inactive
		if ( pPerfLib->CheckStatus( ADAP_INACTIVE_PERFLIB ) )
		{
			// Do this in all namespaces
			pAdapSync->MarkInactivePerflib( pPerfLib->GetServiceName() );
			pLocalizationList->MarkInactivePerflib( pPerfLib->GetServiceName() );
		}
	}

	return hr;
}

HRESULT CAdapRegPerf::EnumPerfDlls( CAdapSync* pAdapSync, CLocalizationSyncList* pLocalizationList )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	WString	wstrServiceKey, wstrPerformanceKey;
	HKEY	hServicesKey = NULL;

	// Open the services key
	// =====================

	long	lError = Open( HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services" );

	if ( CNTRegistry::no_error == lError )
	{
		DWORD	dwIndex = 0;

		// Iterate through the services list
		// =================================

		DWORD	dwBuffSize = 0;
		WCHAR*	pwcsServiceName = NULL;

		while ( CNTRegistry::no_error == lError )
		{

			// For each service name, we will check for a performance 
			// key and if it exists, we will process the library
			// ======================================================

			lError = Enum( dwIndex, &pwcsServiceName , dwBuffSize );

			if ( CNTRegistry::no_error == lError )
			{
				try
				{
					// Create the perfomance key path
					// ==============================

					wstrServiceKey = L"SYSTEM\\CurrentControlSet\\Services\\";
					wstrServiceKey += pwcsServiceName;

					wstrPerformanceKey = wstrServiceKey;
					wstrPerformanceKey += L"\\Performance";
				}
				catch( ... )
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}

				if ( SUCCEEDED( hr ) )
				{
					CNTRegistry	reg;

					// Atempt to open the performance registry key for the service
					// ===========================================================

					if ( CNTRegistry::no_error == reg.Open( HKEY_LOCAL_MACHINE, wstrPerformanceKey ) )
					{
						// It exists, so instantiate the library
						// =====================================

#ifdef DEBUGDUMP
						printf( "\tProcessing %S...\n", pwcsServiceName );
#endif
						CAdapPerfLib	perfLib( pwcsServiceName );

						if ( perfLib.IsOk() )
						{
							hr = ProcessLibrary( pAdapSync, &perfLib, pLocalizationList );
						}
					}
					else
					{
						// Otherwise, it is not a perflib service
						// ======================================
					}

				}	// IF OK


			}	// IF got key
			else if ( CNTRegistry::no_more_items != lError )
			{
				if ( CNTRegistry::out_of_memory == lError )
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}
				else
				{
					hr = WBEM_E_FAILED;
				}
			}

			dwIndex++;
		}	// WHILE successful

		// Cleanup the buffer
		if ( NULL != pwcsServiceName )
		{
			delete [] pwcsServiceName;
			pwcsServiceName = NULL;
		}


	}	// If open services key
	else
	{
		hr = WBEM_E_FAILED;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\adaptest\adaptest.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#ifndef _ADAPTEST_H_
#define _ADAPTEST_H_

#define DEBUGDUMP

#endif //_ADAPTEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\adaptest\adapthrd.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// OBJINTERNALSTESTDlg.cpp : implementation file
//

#define _WIN32_WINNT 0x0400

#include <windows.h>
#include <stdio.h>
#include <process.h>
#include <wbemcli.h>
#include <cominit.h>
#include "ntreg.h"
#include "adapthrd.h"

//	IMPORTANT!!!!

//	This code MUST be revisited to do the following:
//	A>>>>>	Exception Handling around the outside calls
//	B>>>>>	Use a named mutex around the calls
//	C>>>>>	Make the calls on another thread
//	D>>>>>	Place and handle registry entries that indicate a bad DLL!

////////////////////////////////////////////////////////////////////////////////////////////
//
//								CAdapThreadRequest
//
////////////////////////////////////////////////////////////////////////////////////////////

CAdapThreadRequest::CAdapThreadRequest( void )
:	m_hWhenDone( NULL ),
	m_lRefCount( 1 ),
	m_hrReturn( WBEM_S_NO_ERROR )
////////////////////////////////////////////////////////////////////////////////////////////
//
//	Constructor
//
////////////////////////////////////////////////////////////////////////////////////////////
{
}

CAdapThreadRequest::~CAdapThreadRequest( void )
////////////////////////////////////////////////////////////////////////////////////////////
//
//	Destructor
//
////////////////////////////////////////////////////////////////////////////////////////////
{
	if ( NULL != m_hWhenDone )
	{
		CloseHandle( m_hWhenDone );
	}
}

long CAdapThreadRequest::AddRef( void )
////////////////////////////////////////////////////////////////////////////////////////////
//
//	Basic AddRef
//
////////////////////////////////////////////////////////////////////////////////////////////
{
	return InterlockedIncrement( &m_lRefCount );
}

long CAdapThreadRequest::Release( void )
////////////////////////////////////////////////////////////////////////////////////////////
//
//	Basic Release
//
////////////////////////////////////////////////////////////////////////////////////////////
{
	long lRef = InterlockedDecrement( &m_lRefCount );

	if ( 0 == lRef )
	{
		delete this;
	}

	return lRef;
}

HRESULT CAdapThreadRequest::EventLogError( void )
{
	return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//								CAdapThread
//
////////////////////////////////////////////////////////////////////////////////////////////

CAdapThread::CAdapThread()
:	m_hEventQuit( NULL ),
	m_hSemReqPending( NULL ),
	m_hThread( NULL ),
	m_fOk( FALSE )
////////////////////////////////////////////////////////////////////////////////////////////
//
//	Constructor
//
////////////////////////////////////////////////////////////////////////////////////////////
{
	// Initialize the control members
	// ==============================

	Init();
}

CAdapThread::~CAdapThread()
////////////////////////////////////////////////////////////////////////////////////////////
//
//	Destructor
//
////////////////////////////////////////////////////////////////////////////////////////////
{

	if ( Shutdown() != WBEM_S_NO_ERROR )
	{
		Terminate();
	}

	Clear();

	// Clean up the queue
	// ==================

	while ( m_RequestQueue.Size() > 0 )
	{
		CAdapThreadRequest*	pRequest = (CAdapThreadRequest*) m_RequestQueue.GetAt( 0 );

		if ( NULL != pRequest )
		{
			pRequest->Release();
		}

		m_RequestQueue.RemoveAt( 0 );		
	}
}

BOOL CAdapThread::Init( void )
////////////////////////////////////////////////////////////////////////////////////////////
//
//	Initializes the control variables
//
////////////////////////////////////////////////////////////////////////////////////////////
{
	if ( !m_fOk )
	{
		if ( ( m_hEventQuit = CreateEvent( NULL, TRUE, FALSE, NULL ) ) != NULL )
		{
			if ( ( m_hSemReqPending = CreateSemaphore( NULL, 0, 0x7FFFFFFF, NULL ) ) != NULL )
			{
				m_fOk = TRUE;
			}
		}
	}

	return m_fOk;
}

BOOL CAdapThread::Clear( void )
////////////////////////////////////////////////////////////////////////////////////////////
//
//	Clears the control variables and thread variables
//
////////////////////////////////////////////////////////////////////////////////////////////
{
	m_fOk = FALSE;
	
	if ( NULL != m_hEventQuit )
	{
		CloseHandle( m_hEventQuit );
		m_hEventQuit = NULL;
	}

	if ( NULL != m_hSemReqPending )
	{
		CloseHandle( m_hSemReqPending );
		m_hSemReqPending = NULL;
	}

	if ( NULL != m_hThread )
	{
		CloseHandle( m_hThread );
		m_hThread = NULL;
	}

	m_dwThreadId = 0;

	return TRUE;
}

HRESULT CAdapThread::Enqueue( CAdapThreadRequest* pRequest )
////////////////////////////////////////////////////////////////////////////////////////////
//
//	Add a request to the request queue
//
////////////////////////////////////////////////////////////////////////////////////////////
{
	HRESULT	hr = WBEM_NO_ERROR;
	
	// Ensure that the thread has started
	// ==================================

	hr = Begin();
	
	if ( SUCCEEDED( hr ) )
	{
		// We will use a new one for EVERY operation
		HANDLE	hEventDone = CreateEvent( NULL, TRUE, FALSE, NULL );

		if ( NULL != hEventDone )
		{
			// Let the request know about the new event handle
			// ===========================================

			pRequest->SetWhenDoneHandle( hEventDone );

			// Auto-lock the queue
			// ===================

			CInCritSec	ics( &m_cs );

			try
			{
				// Add the request to the queue 
				// ============================
		
				m_RequestQueue.Add( (void*) pRequest );
				pRequest->AddRef();
				
				ReleaseSemaphore( m_hSemReqPending, 1, NULL );
			}
			catch(...)
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}

		}
		else
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}

	return TRUE;
}

HRESULT CAdapThread::Begin( void )
////////////////////////////////////////////////////////////////////////////////////////////
//
//	If the thread has not already started, then intializes the control variables, and starts 
//	the thread.
//
////////////////////////////////////////////////////////////////////////////////////////////
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// Verify that the thread does not already exist
	// =============================================

	if ( NULL == m_hThread )
	{
		// Initialize the control variables
		// ================================

		if ( Init() )
		{
			// Makes sure the pending event semaphore is signalled once for each entry in the queue
			// ====================================================================================

			if ( m_RequestQueue.Size() > 0 )
			{
				ReleaseSemaphore( m_hSemReqPending, m_RequestQueue.Size(), NULL );
			}

			// Start the thread
			// ================

			m_hThread = (HANDLE) _beginthreadex( NULL, 0, CAdapThread::ThreadProc, (void*) this,
									0, (unsigned int *) &m_dwThreadId );

			if ( NULL != m_hThread )
			{
				hr = WBEM_S_NO_ERROR;
			}
		}	
		else
		{
			hr = WBEM_E_FAILED;
		}

	}

	return hr;
}

unsigned CAdapThread::RealEntry( void )
////////////////////////////////////////////////////////////////////////////////////////////
//
//	This is the method that contains the loop that processes the requests.  While there
//	are requests in the queue and the thread has not been instructed to terminate, then
//	grab a request and execute it.  When the request has completed, then signal the completion
//	event to tell the originating thread that the request has been satisfied.
//
////////////////////////////////////////////////////////////////////////////////////////////
{
	HANDLE	ahEvents[2];

	ahEvents[0] = m_hSemReqPending;
	ahEvents[1] = m_hEventQuit;

	DWORD	dwWait = 0;
	DWORD	dwReturn = 0;

	// If the m_hEventQuit event is signaled, or if it runs into a bizarre error,
	// exit loop, otherwise continue as long as there is requests in the queue
	// ==========================================================================

	while ( ( dwWait = WaitForMultipleObjects( 2, ahEvents, FALSE,  INFINITE ) ) == WAIT_OBJECT_0 )
	{
		// Check for the quit event, since if both events are signalled, we'll let this
		// guy take precedence
		if ( WaitForSingleObject( m_hEventQuit, 0 ) == WAIT_OBJECT_0 )
		{
			break;
		}

		// Get the next request from of the FIFO queue
		// ===========================================

		m_cs.Enter();
		CAdapThreadRequest*	pRequest = (CAdapThreadRequest*) m_RequestQueue.GetAt( 0 );
		m_RequestQueue.RemoveAt( 0 );
		m_cs.Leave();

		// Execute it
		// ==========

		pRequest->Execute();

		// Fire the completion event
		// ==========================

		if ( NULL != pRequest->GetWhenDoneHandle() )
		{
			SetEvent( pRequest->GetWhenDoneHandle() );
		}

		// Release the request 
		// ===================

		pRequest->Release();

	}

	// If the exit condition is not due to a signaled m_hEventQuit, then evaluate error
	// ================================================================================

	if ( WAIT_FAILED == dwWait )
	{
		dwReturn = GetLastError();
	}

	return dwReturn;
}

HRESULT CAdapThread::Shutdown( DWORD dwTimeout )
////////////////////////////////////////////////////////////////////////////////////////////
//
//	Performs a gentle shutdown of the thread by signaling the exit event.
//
////////////////////////////////////////////////////////////////////////////////////////////
{
	SetEvent( m_hEventQuit );
	DWORD	dwWait = WaitForSingleObject( m_hThread, dwTimeout );

	return ( dwWait == WAIT_OBJECT_0 ? WBEM_S_NO_ERROR : WBEM_E_FAILED );
}

HRESULT CAdapThread::Terminate( void )
////////////////////////////////////////////////////////////////////////////////////////////
//
//	Used when a gentle termination will not work (i.e. when a thread is hung).  Only use
//	in extreme circumstances.
//
////////////////////////////////////////////////////////////////////////////////////////////
{
	TerminateThread( m_hThread, 0 );
	Clear();

	return WBEM_S_NO_ERROR;
}

HRESULT CAdapThread::Reset( void )
////////////////////////////////////////////////////////////////////////////////////////////
//
//	Does a brute force restart of the thread using the Terminate method.  It kills the 
//	thread, re-initializes the control variables, and calls Begin to restart the thread.
//
////////////////////////////////////////////////////////////////////////////////////////////
{
	HRESULT	hr = Terminate();

	if ( SUCCEEDED( hr ) )
	{
		if ( Init() )
		{
			hr = Begin();
		}
		else
		{
			hr = WBEM_E_FAILED;
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\adaptest\adapsync.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#ifndef __ADAPSYNC_H__
#define __ADAPSYNC_H__

#include "perfndb.h"
#include "adapcls.h"

#define ADAP_ROOT_NAMESPACE L"\\\\.\\root\\default"
#define PERFDATA_BASE_CLASS	L"Win32_PerfRawData"

class CAdapSync : public CAdapElement
{
protected:

	IWbemServices*		m_pNameSpace;
	IWbemClassObject*	m_pBaseClass;
	CAdapClassList*		m_pClassList;
	CPerfNameDb*		m_pDefaultNameDb;

	virtual HRESULT SetClassQualifiers( PERF_OBJECT_TYPE* pPerfObj, LPCWSTR pwcsServiceName,
								CWbemObject* pClass );

	virtual HRESULT SetPropertyQualifiers( PERF_COUNTER_DEFINITION* pCtrDefinition, BOOL fIsDefault,
									LPCWSTR pwcsPropertyName, CWbemObject* pClass );

	virtual HRESULT GenPerfClass( PERF_OBJECT_TYPE* pPerfObj, PCWSTR pwcsServiceName,
								IWbemClassObject** ppClassObject );

	virtual HRESULT AddDefaultProperties( PERF_OBJECT_TYPE* pPerfObj, CWbemObject* pClass );

	virtual HRESULT AddProperty( PERF_COUNTER_DEFINITION* pCtrDefinition, BOOL fIsDefault,
								CWbemObject* pClass );


	virtual HRESULT SetAsCostly( CWbemObject* pClass );

	// WString based helpers
	HRESULT RemoveWhitespace( WString& wstr );
	HRESULT RemoveSlashes( WString& wstr );
	HRESULT RemoveNonAlphaNum( WString& wstr );

	BOOL	IsSingleton( PERF_OBJECT_TYPE* pPerfObj )
	{
		return ( PERF_NO_INSTANCES == pPerfObj->NumInstances );
	}

	// WMI Helpers
	HRESULT AddWMIObject( CWbemObject* pClassObject, CVar varClassName );
	HRESULT OverwriteWMIObject( CWbemObject* pClassObject, CVar varClassName );

	// I think these will be the same for localized and base definitions
	HRESULT SetClassName( PERF_OBJECT_TYPE* pPerfObj, LPCWSTR pwcsServiceName, CWbemObject* pClass );
	HRESULT EnumProperties( PERF_OBJECT_TYPE* pPerfObj, CWbemObject* pClass );

	// Initialzies the default name db
	HRESULT SetupDefaultNameDb( CPerfNameDb* pDefaultNameDb );

	// Initializes WMI Data
	HRESULT SetupWMIData( void );

public:

	CAdapSync( void );
	~CAdapSync(void);

	// Sets us up
	HRESULT Connect( LPCWSTR pwszNamespace = ADAP_ROOT_NAMESPACE, CPerfNameDb* pDefaultNameDb = NULL );

	// For each PERF_OBJECT_TYPE blob we encounter, use this function  sync up our class
	// list with the WMI database
	HRESULT ProcessObjectBlob( LPCWSTR pwcsServiceName, PERF_OBJECT_TYPE* pPerfObjType,
								DWORD dwNumObjects, BOOL bCostly );

	// This is called once all object blobs have been processed to perform appropriate
	// cleanup.

	HRESULT ProcessLeftoverClasses( void );

	// Marks inactive perflibs locally
	HRESULT MarkInactivePerflib( LPCWSTR pwszServiceName );

	// Retrieves a default name database (AddRefs it)
	HRESULT GetDefaultNameDb( CPerfNameDb** ppDefaultNameDb );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\adaptest\adapsync.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// ADAPSYNC.cpp : implementation file
//

#define _WIN32_WINNT 0x0400

#include <windows.h>
#include <stdio.h>
#include <wbemcli.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include <fastall.h>
#include <cominit.h>
#include "perfndb.h"
#include "adapreg.h"
#include "adapcls.h"
#include "adapsync.h"

// This is the base class for doing all the synchronization operations.  We should be able to derive
// a localized synchronization class which sets up minimal data, but basically follows the same
// logic

CAdapSync::CAdapSync( void )
:	CAdapElement(),
	m_pNameSpace( NULL ),
	m_pBaseClass( NULL ),
	m_pClassList( NULL ),
	m_pDefaultNameDb( NULL )
{
}

CAdapSync::~CAdapSync( void )
{
	if ( NULL != m_pNameSpace )
	{
		m_pNameSpace->Release();
	}

	if ( NULL != m_pBaseClass )
	{
		m_pBaseClass->Release();
	}

	if ( NULL != m_pClassList )
	{
		m_pClassList->Release();
	}

	if ( NULL != m_pDefaultNameDb )
	{
		m_pDefaultNameDb->Release();
	}
}

// Stores the default names database (initializes one if necessary)
HRESULT CAdapSync::SetupDefaultNameDb( CPerfNameDb* pDefaultNameDb )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// Setup the default name db using the supplied pointer
	if ( NULL != pDefaultNameDb )
	{
		m_pDefaultNameDb = pDefaultNameDb;
		m_pDefaultNameDb->AddRef();
	}
	else
	{
		// Allocate a new one, check that it initialized, and then AddRef it
		try
		{
			// The default language is english
			CPerfNameDb*	pNameDb = new CPerfNameDb( DEFAULT_NAME_ID );

			if ( pNameDb->IsOk() )
			{
				m_pDefaultNameDb = pNameDb;
				m_pDefaultNameDb->AddRef();
			}
			else
			{
				// DEVNOTE:TODO - We should log an error here
				hr = WBEM_E_FAILED;
				delete pNameDb;
			}
		}
		catch( ... )
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}

	return hr;

}

// This function is used to setup WMI Data.  The NameSpace must have been successfully
// initialized first

HRESULT CAdapSync::SetupWMIData( void )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	try
	{
		// Allocate and build a class list

		CAdapClassList*	pClassList = new CAdapClassList;

		hr = pClassList->BuildList( m_pNameSpace );

		if ( SUCCEEDED( hr ) )
		{
			// Store the class list pointer
			m_pClassList = pClassList;
			m_pClassList->AddRef();

			// Now get the base class from winmgmt
			BSTR				bstrBaseClass = SysAllocString( PERFDATA_BASE_CLASS );

			if ( NULL != bstrBaseClass )
			{
				hr = m_pNameSpace->GetObject( bstrBaseClass, 0L, NULL, &m_pBaseClass, NULL );
			}
			else
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}
		}
		else
		{
			delete pClassList;
		}

	}
	catch(...)
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}

	return hr;
}

// This function is used to hook us up to Winmgmt and registry data
HRESULT CAdapSync::Connect( LPCWSTR pwszNamespace, CPerfNameDb* pDefaultNameDb )
{
	IWbemLocator*		pWbemLocator = NULL;

	HRESULT hr = CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (void**) &pWbemLocator );

	if ( SUCCEEDED(hr) )
	{

		// Name space to connect to
		BSTR	bstrNameSpace = SysAllocString( pwszNamespace );

		if ( NULL != bstrNameSpace )
		{
			IWbemServices*	pNameSpace = NULL;

			hr = pWbemLocator->ConnectServer(	bstrNameSpace,	// NameSpace Name
												NULL,			// UserName
												NULL,			// Password
												NULL,			// Locale
												0L,				// Security Flags
												NULL,			// Authority
												NULL,			// Wbem Context
												&m_pNameSpace		// Namespace
												);
			if ( SUCCEEDED( hr ) )
			{
				// Set Interface security
				hr = WbemSetProxyBlanket( m_pNameSpace, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
					RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE );

				if ( SUCCEEDED( hr ) )
				{
					// Now get the WMI Data
					hr = SetupWMIData();

					// Now get the registry data
					if ( SUCCEEDED( hr ) )
					{
						hr = SetupDefaultNameDb( pDefaultNameDb );
					}

				}	// IF Set NameSpace security

			}	// IF ConnectServer

			SysFreeString( bstrNameSpace );
		}
		else
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}

		pWbemLocator->Release();
	}

	return hr;
}

HRESULT CAdapSync::ProcessObjectBlob( LPCWSTR pwcsServiceName, PERF_OBJECT_TYPE* pPerfObjType,
										DWORD dwNumObjects, BOOL bCostly )
////////////////////////////////////////////////////////////////////////////////////////////
//
//	Iterates through the performance BLOB, generating classes for each performance object 
//	and determining if the object has to be added or updated to Winmgmt.
//
////////////////////////////////////////////////////////////////////////////////////////////
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// Now walk the BLOB and check the class definitions
	// =================================================

	PERF_OBJECT_TYPE*	pCurrentObject = pPerfObjType;

	for ( DWORD	dwCtr = 0; dwCtr < dwNumObjects; dwCtr++ )
	{
		// TODO:
		// We will want to do the following operation for the default namespace as well 
		// as localized namespaces and such.  For right now, just do the default
		// ============================================================================

		// Create a performance class object
		// =================================

		IWbemClassObject*	pClassObject = NULL;

		hr = GenPerfClass( pCurrentObject, pwcsServiceName, &pClassObject );

		if ( SUCCEEDED( hr ) )
		{
			CVar	varClassName;

			// Get the Class Name from the object
			// ==================================

			hr = ((CWbemObject*) pClassObject)->GetProperty( L"__CLASS", &varClassName );

			if ( SUCCEEDED( hr ) )
			{
				// Check to see if we already have a class of the same name
				// ========================================================

				IWbemClassObject*	pOldClass = NULL;

				hr = m_pClassList->GetClassObject( varClassName.GetLPWSTR(), &pOldClass );

				if ( SUCCEEDED( hr ) )
				{
					// Same Name - compare the IDs
					// ===========================

					CVar varIndex, varOldIndex;

					// DEVNOTE:TODO - Check the return codes here
					hr = ((CWbemObject*)pClassObject)->GetQualifier( L"perfindex", &varIndex, NULL );
					hr = ((CWbemObject*)pOldClass)->GetQualifier( L"perfindex", &varOldIndex, NULL );

					if ( varIndex == varOldIndex )
					{
						// Same Name : Same ID - check current for costly
						// ==============================================

						if ( bCostly )
						{
							// Same Name : Same ID : Current Costly - check old for costly
							// ===========================================================

							CVar varCostly;

							if ( SUCCEEDED(((CWbemObject*)pOldClass)->GetQualifier( L"costly", &varCostly, NULL ) ) )
							{
								// Same Name : Same ID : Current Costly : Old Costly - overwrite the old object
								// ============================================================================

								hr = SetAsCostly( (CWbemObject*)pClassObject );

								if ( SUCCEEDED( hr ) )
								{
									hr = OverwriteWMIObject( (CWbemObject*)pClassObject, varClassName );
								}
							}
							else 
							{
								// Same Name : Same ID : Current Costly : Old Global - current is duplicate so ignore
								// ==================================================================================
							}
						}
						else 
						{
							// Same Name : Same ID : Current is global - overwrite
							// ===================================================

							hr = OverwriteWMIObject( (CWbemObject*)pClassObject, varClassName );
						}
					}
					else
					{
						// Same Name : Different ID - This should only happen in a Global / Costly conflict
						// ================================================================================

						if ( bCostly )
						{
							// Same Name : Different ID : Current Costly - legal name clash, modify name and add
							// =================================================================================
							WCHAR wcsNewName[1024];

							SetAsCostly( (CWbemObject*)pClassObject );
							swprintf( wcsNewName, L"%S_costly", varClassName.GetLPWSTR() );
							varClassName.SetLPWSTR( wcsNewName, FALSE );
							hr = ((CWbemObject*)pClassObject)->SetPropValue( L"__CLASS", &varClassName, CIM_STRING );

							if ( SUCCEEDED( m_pClassList->GetClassObject( wcsNewName, &pOldClass ) ) )
							{
								hr = OverwriteWMIObject( (CWbemObject*)pClassObject, varClassName );
							}
							else
							{
								hr = AddWMIObject( (CWbemObject*)pClassObject, varClassName );
							}
						}
						else
						{
							// Same Name : Different ID : Current Global - illegal name clash, error
							// =====================================================================

							hr = WBEM_E_FAILED;
						}
					}
				}
				else
				{
					// Not found - add to WMI
					// ======================

					if ( bCostly )
					{
						hr = SetAsCostly( (CWbemObject*)pClassObject );
					}

					hr = AddWMIObject( (CWbemObject*)pClassObject, varClassName );
				}
			}

			pClassObject->Release();
		}

		// Get the next object
		// ===================

		LPBYTE	pbData = (LPBYTE) pCurrentObject;
		pbData += pCurrentObject->TotalByteLength;
		pCurrentObject = (PERF_OBJECT_TYPE*) pbData;

	} // FOR

	return hr;
}

// This function walks the class list and for each class in it, checks if
// the class has a corresponding service entry in the registry.  If not, we
// will remove the class.  If so, we will remove it and all classes for
// that service.

HRESULT CAdapSync::ProcessLeftoverClasses( void )
{
	// DEVNOTE:TODO - This function needs to be tested in an environment
	// in which it actually gets exercised.

	HRESULT	hr = WBEM_S_NO_ERROR;

	for ( int i = 0; i < m_pClassList->GetSize() && SUCCEEDED( hr ); i++ )
	{
		CAdapClassElem* pEl = NULL;

		hr = m_pClassList->GetAt( i, &pEl );

		if ( !( pEl->CheckStatus ( ADAP_OBJECT_IS_REGISTERED ) || 
				pEl->CheckStatus( ADAP_OBJECT_IS_INACTIVE ) ) ) 
		{
			WString	strClassName;
			WString	strServiceName;
			WString	wstrServiceKey;
			IWbemClassObject*	pClass = NULL;

			hr = m_pClassList->GetAt( i, strClassName, strServiceName, &pClass );

			if ( SUCCEEDED( hr ) )
			{
				BSTR	bstrClassName = SysAllocString( (LPCWSTR) strClassName );

				if ( NULL != bstrClassName )
				{
					hr = m_pNameSpace->DeleteClass( bstrClassName, 0L, NULL, NULL );
				}
				else
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}
			}
		}
	}

	return hr;
}
// Generates a class based on an object BLOB
HRESULT CAdapSync::GenPerfClass( PERF_OBJECT_TYPE* pPerfObj, LPCWSTR pwcsServiceName,
									IWbemClassObject** ppClassObject )
{
	// Using this pointer gives us direct access to the object methods.
	// If necessary, this could even be a CWbemClass*.
	CWbemObject*	pNewClass = NULL;

	HRESULT	hr = m_pBaseClass->SpawnDerivedClass( 0L, (IWbemClassObject**) &pNewClass );

	if ( SUCCEEDED( hr ) )
	{

		// Now we'll put in all the lovely stuff that makes this a class
		hr = SetClassName( pPerfObj, pwcsServiceName, pNewClass );

		if ( SUCCEEDED( hr ) )
		{
			hr = SetClassQualifiers( pPerfObj, pwcsServiceName, pNewClass );

			if ( SUCCEEDED( hr ) )
			{
				hr = AddDefaultProperties( pPerfObj, pNewClass );

				if ( SUCCEEDED( hr ) )
				{
					// Now define all of the properties
					hr = EnumProperties( pPerfObj, pNewClass );

					if ( SUCCEEDED( hr ) )
					{
						// Addref and store the object
						hr = pNewClass->QueryInterface( IID_IWbemClassObject, (void**) ppClassObject );
					}

				}	// Add Default Properties

			}	// Set Class qualifiers

		}	// Set Class Name

		// Cleanup this addref
		pNewClass->Release();
	}

	return hr;
}

HRESULT CAdapSync::SetClassName( PERF_OBJECT_TYPE* pPerfObj, LPCWSTR pwcsServiceName, CWbemObject* pClass )
////////////////////////////////////////////////////////////////////////////////////////////
//
//	Sets the name of the new WMI class. The syntax is: 
//
//		Win32Perf_<servicename>_<displayname>
//
//	where the service name is the name of the namespace and the display name is the name of
//	the object located in the perf name database
//
////////////////////////////////////////////////////////////////////////////////////////////
{
	HRESULT	hr = WBEM_E_FAILED;

	WString	wstrClassName( L"Win32Perf_" );
	WString	wstrObjectName;

	// Get the class display name, then remove the whitespace.  For class and property
	// names, we will always use the default name db
	hr = m_pDefaultNameDb->GetDisplayName( pPerfObj->ObjectNameTitleIndex, wstrObjectName );

	if ( SUCCEEDED( hr ) )
	{
		hr = RemoveWhitespace( wstrObjectName );

		try
		{
			// Now we can build the rest of the name and try
			// setting it in the object
			wstrClassName += pwcsServiceName;
			wstrClassName += L"_";
			wstrClassName += wstrObjectName;

			// Tricky.  This makes the CVar a BSTR
			CVar	var( 0, (LPWSTR) wstrClassName );

			// Now set the name
			hr = pClass->SetPropValue( L"__CLASS", &var, CIM_STRING );
		}
		catch( ... )
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}

	return hr;
}

// Sets all the class qualifiers
HRESULT CAdapSync::SetClassQualifiers( PERF_OBJECT_TYPE* pPerfObj, LPCWSTR pwcsServiceName,
										CWbemObject* pClass )
////////////////////////////////////////////////////////////////////////////////////////////
//
//	Sets the class' qualifiers.  Note that the operations are performed directly on the 
//	CWbemObject.
//
////////////////////////////////////////////////////////////////////////////////////////////
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	//	The following qualifiers will be added:
	//	1 >	dynamic
	//	2 >	provider("NT5_GenericPerfProvider_V1")
	//	3 >	registrykey
	//	4 >	locale(0x0409)
	//	5 >	display
	//	6 >	perfindex
	//	7 >	helpindex
	//	8 >	perfdetail
	//	9 > genericperfctr (signals that this is a generic counter)
	//	10>	singleton (if applicable)
	//	11>	costly (if applicable)	

	CVar	var;

	// We may get an OOM exception
	try
	{
		// Dynamic
		var.SetBool( VARIANT_TRUE );
		hr = pClass->SetQualifier( L"dynamic", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );

		// provider
		if ( SUCCEEDED( hr ) )
		{
			var.Empty();
			var.SetBSTR( L"Nt5_GenericPerfProvider_V1" );
			hr = pClass->SetQualifier( L"provider", &var, 0L );
		}

		// registrykey
		if ( SUCCEEDED( hr ) )
		{
			var.Empty();
			var.SetBSTR( (LPWSTR) pwcsServiceName );
			hr = pClass->SetQualifier( L"registrykey", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
		}

		// DEVNOTE:Modify for localization
		// locale
		if ( SUCCEEDED( hr ) )
		{
			var.Empty();
			var.SetLong( 0x0409 );
			hr = pClass->SetQualifier( L"locale", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
		}

		// display
		if ( SUCCEEDED( hr ) )
		{
			LPCWSTR	pwcsDisplayName = NULL;

			var.Empty();

			hr = m_pDefaultNameDb->GetDisplayName( pPerfObj->ObjectNameTitleIndex, &pwcsDisplayName );

			// If this is a localized Db, this could be a benign error
			if ( SUCCEEDED( hr ) )
			{
				var.SetBSTR( (LPWSTR) pwcsDisplayName );
				hr = pClass->SetQualifier( L"DisplayName", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
			}
		}

		// perfindex
		if ( SUCCEEDED( hr ) )
		{
			var.Empty();
			var.SetLong( pPerfObj->ObjectNameTitleIndex );
			hr = pClass->SetQualifier( L"perfindex", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
		}

		// helpindex
		if ( SUCCEEDED( hr ) )
		{
			var.Empty();
			var.SetLong( pPerfObj->ObjectHelpTitleIndex );
			hr = pClass->SetQualifier( L"helpindex", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
		}

		// perfdetail
		if ( SUCCEEDED( hr ) )
		{
			var.Empty();
			var.SetLong( pPerfObj->DetailLevel );
			hr = pClass->SetQualifier( L"perfdetail", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
		}

		// genericperfctr
		if ( SUCCEEDED(hr) )
		{
			var.Empty();
			var.SetBool( VARIANT_TRUE );
			hr = pClass->SetQualifier( L"genericperfctr", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
		}

		// singleton (set if the numinstances is PERF_NO_INSTANCES)
		if ( SUCCEEDED(hr) && IsSingleton( pPerfObj ) )
		{
			var.Empty();
			var.SetBool( VARIANT_TRUE );
			// This will have default flavors
			hr = pClass->SetQualifier( L"singleton", &var, 0L );
		}

	}
	catch(...)
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}

	return hr;
}

// Adds appropriate default properties (like Name as a key and any other ones
// that I may have missed).
HRESULT CAdapSync::AddDefaultProperties( PERF_OBJECT_TYPE* pPerfObj, CWbemObject* pClass )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// If we are not a singleton class, then we will
	// need a name property that is marked as a key

	if ( !IsSingleton( pPerfObj ) )
	{
		CVar	var;

		var.SetAsNull();
		hr = pClass->SetPropValue( L"Name", &var, CIM_STRING );

		if ( SUCCEEDED( hr ) )
		{
			// Dynamic
			var.SetBool( VARIANT_TRUE );
			hr = pClass->SetPropQualifier( L"Name", L"key", 0L, &var );
		}
	}

	return hr;
}

// Walks the counter definitions and generates corresponding properties
HRESULT CAdapSync::EnumProperties( PERF_OBJECT_TYPE* pPerfObj, CWbemObject* pClass )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// Points at first counter definition
	LPBYTE	pbData = ((LPBYTE) pPerfObj) + pPerfObj->HeaderLength;

	// Now cast this the right way
	PERF_COUNTER_DEFINITION*	pCounterDefinition = (PERF_COUNTER_DEFINITION*) pbData;

	for ( DWORD dwCtr = 0; SUCCEEDED( hr ) && dwCtr < pPerfObj->NumCounters; dwCtr++ )
	{
		hr = AddProperty( pCounterDefinition, ( dwCtr == (DWORD) pPerfObj->DefaultCounter), pClass );

		// Now go to the next counter definition
		pbData = ((LPBYTE) pCounterDefinition) + pCounterDefinition->ByteLength;
		pCounterDefinition = (PERF_COUNTER_DEFINITION*) pbData;
	}

	return hr;
}

// Adds a property defined by the counter definition
HRESULT CAdapSync::AddProperty( PERF_COUNTER_DEFINITION* pCtrDefinition, BOOL fIsDefault,
									CWbemObject* pClass )
{
	// Use the display index in the counter definition to get us the property name (we will
	// use the default database for this)
	WString	wstrPropertyName;

	// What happens if this fails?
	HRESULT	hr = m_pDefaultNameDb->GetDisplayName( pCtrDefinition->CounterNameTitleIndex, wstrPropertyName );

	// It's the last one
	DWORD	dwCounterTypeMask = PERF_SIZE_VARIABLE_LEN;

	if ( SUCCEEDED( hr ) )
	{
		// Remove whitespace and slash characters
		hr = RemoveWhitespace( wstrPropertyName );

		if ( SUCCEEDED( hr ) )
		{
			hr = RemoveSlashes( wstrPropertyName );

			if ( SUCCEEDED( hr ) )
			{
				// Gotta lose these too.
				hr = RemoveNonAlphaNum( wstrPropertyName );
			}
		}

		if ( SUCCEEDED( hr ) )
		{
			CVar	varTest;

			// Check if the property already exists.  If so, we will fail
			if ( FAILED( pClass->GetProperty( wstrPropertyName, &varTest ) ) )
			{
				// Now check the perf counter type to see if it's a DWORD or LARGE.  If it's anything
				// else, we will NOT support this object

				DWORD	dwCtrType = pCtrDefinition->CounterType & dwCounterTypeMask;

				if (	PERF_SIZE_DWORD	== dwCtrType ||
						PERF_SIZE_LARGE	== dwCtrType )
				{
					CVar	var;
					CIMTYPE	ct = ( PERF_SIZE_DWORD == dwCtrType ? CIM_UINT32 : CIM_UINT64 );

					// We don't do default properties
					var.SetAsNull();
					hr = pClass->SetPropValue( wstrPropertyName, &var, ct );

					if ( SUCCEEDED( hr ) )
					{
						hr = SetPropertyQualifiers( pCtrDefinition, fIsDefault, wstrPropertyName, pClass );
					}
				}
				else
				{
					hr = WBEM_E_FAILED;
				}

			}	// Check if property already exists
			else
			{
				hr = WBEM_E_FAILED;
			}

		}	// IF removed whitespace

	}	// IF Got Display Name

	return hr;
}

// Adds property qualifiers defined by the counter definition
HRESULT CAdapSync::SetPropertyQualifiers( PERF_COUNTER_DEFINITION* pCtrDefinition, BOOL fIsDefault,
									LPCWSTR pwcsPropertyName, CWbemObject* pClass )
////////////////////////////////////////////////////////////////////////////////////////////
//
//	Sets the values of the properties.
//
////////////////////////////////////////////////////////////////////////////////////////////
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	//	The following qualifiers will be added:
	//	1>	perfdefault
	//	2>	display
	//	3>	countertype
	//	3>	perfindex
	//	4>	helpindex
	//	5>	defaultscale
	//	6>	perfdetail

	CVar	var;

	// We may get an OOM exception
	try
	{
		// perfdefault
		if ( fIsDefault )
		{
			// Dynamic
			var.SetBool( VARIANT_TRUE );
			hr = pClass->SetPropQualifier( pwcsPropertyName, L"perfdefault",
							WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE,	&var );
		}

		// display
		if ( SUCCEEDED( hr ) )
		{
			LPCWSTR	pwcsDisplayName = NULL;

			var.Empty();

			hr = m_pDefaultNameDb->GetDisplayName( pCtrDefinition->CounterNameTitleIndex, &pwcsDisplayName );

			// If this is a localized Db, this could be a benign error
			if ( SUCCEEDED( hr ) )
			{
				var.SetBSTR( (LPWSTR) pwcsDisplayName );
				hr = pClass->SetPropQualifier( pwcsPropertyName, L"DisplayName",
								WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE,	&var );
			}
		}

		// countertype
		if ( SUCCEEDED( hr ) )
		{
			var.Empty();
			var.SetLong( pCtrDefinition->CounterType );
			hr = pClass->SetPropQualifier( pwcsPropertyName, L"countertype",
							WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE,	&var );
		}

		// perfindex
		if ( SUCCEEDED( hr ) )
		{
			var.Empty();
			var.SetLong( pCtrDefinition->CounterNameTitleIndex );
			hr = pClass->SetPropQualifier( pwcsPropertyName, L"perfindex",
							WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE,	&var );
		}

		// helpindex
		if ( SUCCEEDED( hr ) )
		{
			var.Empty();
			var.SetLong( pCtrDefinition->CounterHelpTitleIndex );
			hr = pClass->SetPropQualifier( pwcsPropertyName, L"helpindex",
							WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE,	&var );
		}

		// defaultscale
		if ( SUCCEEDED( hr ) )
		{
			var.Empty();
			var.SetLong( pCtrDefinition->DefaultScale );
			hr = pClass->SetPropQualifier( pwcsPropertyName, L"defaultscale",
							WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE,	&var );
		}

		// perfdetail
		if ( SUCCEEDED( hr ) )
		{
			var.Empty();
			var.SetLong( pCtrDefinition->DetailLevel );
			hr = pClass->SetPropQualifier( pwcsPropertyName, L"perfdetail",
							WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE,	&var );
		}

	}
	catch(...)
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}

	return hr;
}

HRESULT CAdapSync::SetAsCostly( CWbemObject* pClass )
{
	HRESULT hr = WBEM_NO_ERROR;

	CVar var;

	var.Empty();
	var.SetBool( VARIANT_TRUE );
	hr = pClass->SetQualifier( L"costly", &var, 0L );

	return hr;
}

// Adds a WMI object and sets the staus of the object in the class list
HRESULT CAdapSync::AddWMIObject( CWbemObject* pClassObject, CVar varClassName )
{ 
	HRESULT hr = WBEM_NO_ERROR;

	hr = m_pNameSpace->PutClass( pClassObject, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL );

	if ( SUCCEEDED( hr ) )
	{
		// And mark object as registered
		// =============================

		hr = m_pClassList->AddClassObject( pClassObject );

		if ( SUCCEEDED( hr ) )
		{
			CAdapClassElem *pEl = NULL;
			m_pClassList->GetListElement( varClassName.GetLPWSTR(), &pEl );

			if (NULL != pEl)
			{
				pEl->SetStatus( ADAP_OBJECT_IS_REGISTERED );
			}
			else 
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}
		}
	}

	return hr;
}

// Updates a WMI object and sets the staus of the object in the class list
HRESULT CAdapSync::OverwriteWMIObject( CWbemObject* pClassObject, CVar varClassName )
{
	HRESULT hr = WBEM_NO_ERROR;

	// If they are not the same, overwrite the old object
	// ==================================================

	hr = m_pNameSpace->PutClass( pClassObject, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL );

	if ( SUCCEEDED( hr ) )
	{
		// And mark object as registered
		// =============================

		CAdapClassElem *pEl = NULL;
		hr = m_pClassList->GetListElement( varClassName.GetLPWSTR(), &pEl );

		if (NULL != pEl)
		{
			pEl->SetStatus( ADAP_OBJECT_IS_REGISTERED );
		}
		else 
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}

	return hr;
}

// WString helper functions
HRESULT CAdapSync::RemoveWhitespace( WString& wstr )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// Get the data, so we can reset it without any whitespace
	wchar_t*	pWstr = wstr.UnbindPtr();

	if ( NULL != pWstr )
	{

		try
		{
			WCHAR*	pNewWstr = new WCHAR[lstrlenW(pWstr) + 1];

			int	x = 0,
				y = 0;

			// Dump all whitespace, leading, trailing and internal
			for ( ; NULL != pWstr[x]; x++ )
			{
				if ( !iswspace( pWstr[x] ) )
				{
					pNewWstr[y] = pWstr[x];
					y++;
				}
			}

			pNewWstr[y] = NULL;

			// This will cause the string to acquire the pointer.
			wstr.BindPtr( pNewWstr );

			delete [] pWstr;
		}
		catch(...)
		{
			HRESULT hr = WBEM_E_OUT_OF_MEMORY;
		}
	}

	return hr;
}

HRESULT CAdapSync::RemoveNonAlphaNum( WString& wstr )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// Get the data, so we can reset it without any non-alpha num characters
	WCHAR*	pWstr = wstr.UnbindPtr();

	if ( NULL != pWstr )
	{

		try
		{
			WCHAR*	pNewWstr = new WCHAR[lstrlenW(pWstr) + 1];

			int	x = 0,
				y = 0;

			// Dump all non-alphanumeric characters
			for ( ; NULL != pWstr[x]; x++ )
			{
				if ( isunialphanum( pWstr[x] ) )
				{
					pNewWstr[y] = pWstr[x];
					y++;
				}
			}

			pNewWstr[y] = NULL;

			// This will cause the string to acquire the pointer.
			wstr.BindPtr( pNewWstr );

			delete [] pWstr;
		}
		catch(...)
		{
			HRESULT hr = WBEM_E_OUT_OF_MEMORY;
		}
	}

	return hr;
}

// Replaces slashes with "Per"
HRESULT CAdapSync::RemoveSlashes( WString& wstr )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// First, check for slashes
	int	x = 0,
		y = 0;

	// Get the data, so we can reset it without any non-alpha num characters
	WCHAR*	pWstr = wstr.UnbindPtr();

	if ( NULL != pWstr )
	{

		DWORD	dwNumSlashes = 0;

		for ( ; NULL != pWstr[x]; x++ )
		{
			if ( L'/' == pWstr[x] )
			{
				dwNumSlashes++;
			}
		}

		// No need to continue if no slashes
		if ( 0 == dwNumSlashes )
		{
			wstr.BindPtr( pWstr );
			return WBEM_S_NO_ERROR;
		}

		try
		{
			// Each slash will be replaced by "Per"
			WCHAR*	pNewWstr = new WCHAR[lstrlenW(pWstr) + 1 + ( 3 * dwNumSlashes )];

			// Dump all non-alphanumeric characters
			for ( x = 0; NULL != pWstr[x]; x++ )
			{
				if ( L'/' == pWstr[x] )
				{
					lstrcpyW( &pNewWstr[y], L"Per" );
					y+=3;
				}
				else
				{
					pNewWstr[y] = pWstr[x];
					y++;
				}
			}

			pNewWstr[y] = NULL;

			// This will cause the string to acquire the pointer.
			wstr.BindPtr( pNewWstr );

			delete [] pWstr;
		}
		catch(...)
		{
			HRESULT hr = WBEM_E_OUT_OF_MEMORY;
		}
	}

	return hr;
}

HRESULT CAdapSync::MarkInactivePerflib( LPCWSTR pwszServiceName )
{
	return m_pClassList->InactivePerflib( pwszServiceName );
}

HRESULT CAdapSync::GetDefaultNameDb( CPerfNameDb** ppDefaultNameDb )
{
	// Make sure this operation makes sense
	if ( NULL == ppDefaultNameDb )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	if ( NULL == m_pDefaultNameDb )
	{
		return WBEM_E_FAILED;
	}

	// Go ahead and do it
	m_pDefaultNameDb->AddRef();
	*ppDefaultNameDb = m_pDefaultNameDb;

	return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\adaptest\adaptest.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#define _WIN32_WINNT 0x0400

#include <windows.h>
#include <stdio.h>
#include <wbemcli.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include <fastall.h>
#include <cominit.h>
#include "adapsync.h"
#include "adapreg.h"
#include "locallist.h"
#include "adaptest.h"

HRESULT ADAPEntry( void )
{
	// Note that for localized namespaces, we will need to open the subnamespaces and
	// build a class list for those namespaces.  For now, we're just doing the main
	// namespace

	// DEVNOTE:TODO - What about localization namespaces?  The base classes for WBEMPERF currently are
	// not being localized, so maybe we can build this stuff ourselves??  We'll probably need a map that
	// maps a namedb to a namespace.  Also, a routine to enumerate the localization name databases
	// and map that name to a database (basically 009 becomes MS_0409).

	CAdapSync		defaultAdapSync;

	HRESULT	hr = defaultAdapSync.Connect();

	if ( SUCCEEDED( hr ) )
	{
		// We will need this for all the other db's
		CPerfNameDb*	pDefaultNameDb = NULL;
		defaultAdapSync.GetDefaultNameDb( &pDefaultNameDb );

		// Now instantiate our localized namespace list
		CLocalizationSyncList	localizationList;

		// Well, it either works or it don't
		hr = localizationList.MakeItSo( pDefaultNameDb );

		if ( SUCCEEDED( hr ) )
		{
			CAdapRegPerf	regPerf;

			// Process each perflib that is registered on the system
			// =====================================================

	#ifdef DEBUGDUMP
	printf( "\nEnumerating Performance Libraries...\n" );
	#endif

			hr = regPerf.EnumPerfDlls( &defaultAdapSync, &localizationList );

			// Once we have added and updated all the perflib objects
			// in WMI, we want to remove unreferenced classes.
			// ======================================================

			if ( SUCCEEDED( hr ) )
			{
	#ifdef DEBUGDUMP
	printf( "\nRemoving Old WMI Classes...\n" );
	#endif
				defaultAdapSync.ProcessLeftoverClasses();
				localizationList.ProcessLeftoverClasses();
			}

		}	// IF Localization list initialized

		// Clean up the default name database
		if ( NULL != pDefaultNameDb )
		{
			pDefaultNameDb->Release();
		}

	}	// IF we connected

#ifdef DEBUGDUMP
	printf( "\nDone.\n" );
#endif

	return hr;
}


///////////////////////////////////////////////////////////////////
//
//	Function:	main
//
//	Entry point function to exercise IWbemObjectInternals interface.
//
///////////////////////////////////////////////////////////////////

int main( int argc, char *argv[] )
{
	char	szMachineName[256];

	InitializeCom();
	CoInitializeSecurity( NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
			EOAC_NONE, NULL );

	HRESULT hr = ADAPEntry();

	if ( FAILED ( hr ) )
	{
		printf("Adap Failed\n");
	}

	CoUninitialize();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\adaptest\adapthrd.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// Base thread class for calling into the perflibs safely.

#ifndef __ADAPTHRD_H__
#define __ADAPTHRD_H__

#include <wbemcomn.h>
#include <sync.h>
#include <execq.h>
#include <fastall.h>

class CAdapThreadRequest
{
private:
	long	m_lRefCount;

protected:
	HANDLE	m_hWhenDone;
	HRESULT	m_hrReturn;

public:
    void SetWhenDoneHandle(HANDLE h) {m_hWhenDone = h;}
    HANDLE GetWhenDoneHandle() {return m_hWhenDone;}

	HRESULT GetHRESULT( void )
	{
		return m_hrReturn;
	}

	long AddRef( void );
	long Release();

public:
    CAdapThreadRequest();
    virtual ~CAdapThreadRequest();

    virtual HRESULT Execute() = 0;
	virtual HRESULT EventLogError();
};

class CAdapThread
{
private:

	HANDLE		m_hThread;			// The thread handle	
	DWORD		m_dwThreadId;		// The thread ID
	HANDLE		m_hEventQuit;		// Thread termination event

	CFlexArray	m_RequestQueue;		// The queue
	HANDLE		m_hSemReqPending;	// The queue counter

	BOOL		m_fOk;				// Initialization flag
	CCritSec	m_cs;

	static unsigned __stdcall ThreadProc( void * pThis )
	{
		return ((CAdapThread*) pThis)->RealEntry();
	}

	unsigned RealEntry( void );

protected:

	BOOL Init( void );
	virtual BOOL Clear( void );

public:
	CAdapThread();
	virtual ~CAdapThread();

	HRESULT Begin( void );
	HRESULT Shutdown( DWORD dwTimeout = 5000 );
	HRESULT Terminate( void );
	HRESULT Reset( void );

	// Assigns us work to do.
	HRESULT Enqueue( CAdapThreadRequest* pRequest );

	BOOL IsOk( void )
	{
		return m_fOk;
	}

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\adaptest\locallist.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// OBJINTERNALSTESTDlg.cpp : implementation file
//

#define _WIN32_WINNT 0x0400

#include <windows.h>
#include <stdio.h>
#include <wbemcli.h>
#include <cominit.h>
#include "locallist.h"


////////////////////////////////////////////////////////////////////////////////////////////
//
//								CLocalizationSyncList
//
////////////////////////////////////////////////////////////////////////////////////////////

CLocalizationSyncList::CLocalizationSyncList( void )
:	CNTRegistry(),
	m_array()
{
}

CLocalizationSyncList::~CLocalizationSyncList( void )
{
}

HRESULT CLocalizationSyncList::Find( LPCWSTR pwszLangId, CLocalizationSync** ppSync )
{
	HRESULT	hr = WBEM_E_FAILED;

	for ( DWORD dwCtr = 0; dwCtr < m_array.GetSize(); dwCtr++ )
	{
		CLocalizationSync* pLocalSync = m_array[dwCtr];

		if ( NULL != pLocalSync )
		{
			if ( wbem_wcsicmp( pwszLangId, pLocalSync->GetLangId() ) == 0 )
			{
				*ppSync = pLocalSync;
				pLocalSync->AddRef();\
				hr = WBEM_S_NO_ERROR;
				break;
			}

		}	// IF NULL != pLocalSync

	}	// FOR Enum array

	return hr;
}

HRESULT CLocalizationSyncList::GetAt( DWORD dwIndex, CLocalizationSync** ppSync )
{
	HRESULT	hr = WBEM_E_FAILED;

	if ( dwIndex < m_array.GetSize() )
	{
		CLocalizationSync* pLocalSync = m_array[dwIndex];

		// Copy the data.  AddRef a non-NULL element
		*ppSync = pLocalSync;
		hr = WBEM_S_NO_ERROR;

		if ( NULL != pLocalSync )
		{
			pLocalSync->AddRef();\
		}
	}

	return hr;
}

HRESULT CLocalizationSyncList::RemoveAt( DWORD dwIndex )
{
	HRESULT	hr = WBEM_E_FAILED;

	if ( dwIndex < m_array.GetSize() )
	{
		m_array.RemoveAt( dwIndex );
		hr = WBEM_S_NO_ERROR;
	}

	return hr;
}

// This walks the registry for perflib name database subkeys and builds 
// localized synchronization elements as needed
HRESULT CLocalizationSyncList::MakeItSo( CPerfNameDb* pDefaultNameDb )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// Open the Perflib key
	// =====================

	long	lError = Open( HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\PerfLib" );

	if ( CNTRegistry::no_error == lError )
	{
		DWORD	dwIndex = 0;

		// Iterate through the PerfLib Key
		// =================================

		DWORD	dwBuffSize = 0;
		WCHAR*	pwcsLangId = NULL;

		while ( CNTRegistry::no_error == lError )
		{

			// For each service name, we will check for a performance 
			// key and if it exists, we will process the library
			// ======================================================

			lError = Enum( dwIndex, &pwcsLangId , dwBuffSize );

			if ( CNTRegistry::no_error == lError )
			{
				CLocalizationSync*	pLocaleSync = NULL;

				try
				{
					pLocaleSync = new CLocalizationSync( pwcsLangId );
					pLocaleSync->AddRef();

					// Hook it up
					hr = pLocaleSync->Connect( pDefaultNameDb );

					// DEVNOTE:TODO - If this fails, make sure an event was logged somewhere
					if ( SUCCEEDED( hr ) )
					{
						// This will AddRef it
						m_array.Add( pLocaleSync );
					}
					else
					{
						// Continue
						hr = WBEM_S_NO_ERROR;
					}

				}
				catch( ... )
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}

				if ( NULL != pLocaleSync )
				{
					pLocaleSync->Release();
				}

			}	// IF got key
			else if ( CNTRegistry::no_more_items != lError )
			{
				if ( CNTRegistry::out_of_memory == lError )
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}
				else
				{
					hr = WBEM_E_FAILED;
				}
			}

			dwIndex++;
		}	// WHILE successful

		// Cleanup the buffer
		if ( NULL != pwcsLangId )
		{
			delete [] pwcsLangId;
			pwcsLangId = NULL;
		}


	}	// If open perflib key
	else
	{
		hr = WBEM_E_FAILED;
	}

	return hr;
}

// Calls down into each localizable synchronization object
HRESULT CLocalizationSyncList::ProcessObjectBlob( LPCWSTR pwcsServiceName, PERF_OBJECT_TYPE* pPerfObjType,
												DWORD dwNumObjects, BOOL bCostly )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	for ( DWORD dwCtr = 0; dwCtr < m_array.GetSize(); dwCtr++ )
	{
		CLocalizationSync* pLocalSync = m_array[dwCtr];

		if ( NULL != pLocalSync )
		{
			hr = pLocalSync->ProcessObjectBlob( pwcsServiceName, pPerfObjType, dwNumObjects, bCostly );

			// Event logging should handle any traumatic errors
			if ( FAILED( hr ) )
			{
				hr = WBEM_S_NO_ERROR;
			}

		}	// IF NULL != pLocalSynce

	}	// FOR Enum syncs

	return hr;
}

HRESULT CLocalizationSyncList::ProcessLeftoverClasses( void )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	for ( DWORD dwCtr = 0; dwCtr < m_array.GetSize(); dwCtr++ )
	{
		CLocalizationSync* pLocalSync = m_array[dwCtr];

		if ( NULL != pLocalSync )
		{
			// Process each leftover class
			hr = pLocalSync->ProcessLeftoverClasses();

			// Event logging should handle any traumatic errors
			if ( FAILED( hr ) )
			{
				hr = WBEM_S_NO_ERROR;
			}

		}	// IF NULL != pLocalSynce

	}	// FOR Enum syncs

	return hr;
}

HRESULT CLocalizationSyncList::MarkInactivePerflib( LPCWSTR pwszServiceName )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	for ( DWORD dwCtr = 0; dwCtr < m_array.GetSize(); dwCtr++ )
	{
		CLocalizationSync* pLocalSync = m_array[dwCtr];

		if ( NULL != pLocalSync )
		{
			// Process each leftover class
			hr = pLocalSync->MarkInactivePerflib( pwszServiceName );

			// Event logging should handle any traumatic errors
			if ( FAILED( hr ) )
			{
				hr = WBEM_S_NO_ERROR;
			}

		}	// IF NULL != pLocalSynce

	}	// FOR Enum syncs

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\adaptest\locallist.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// Use this guy to build a list Localized perfdata synchronization
// objects.

#ifndef __LOCALLIST_H__
#define __LOCALLIST_H__

#include <wbemcomn.h>
#include <fastall.h>
#include "ntreg.h"
#include "localsync.h"

class CLocalizationSyncList : public CNTRegistry
{
private:
	CRefedPointerArray<CLocalizationSync>	m_array;

public:

	CLocalizationSyncList();
	~CLocalizationSyncList();

	// Helper functions to build the list and then access/remove
	// list elements.

	HRESULT	MakeItSo( CPerfNameDb* pDefaultNameDb );

	// Calls down into each localizable synchronization object
	HRESULT ProcessObjectBlob( LPCWSTR pwcsServiceName, PERF_OBJECT_TYPE* pPerfObjType,
								DWORD dwNumObjects, BOOL bCostly );
	HRESULT ProcessLeftoverClasses( void );
	HRESULT MarkInactivePerflib( LPCWSTR pwszServiceName );

	HRESULT Find( LPCWSTR pwszLangId, CLocalizationSync** ppSync );
	HRESULT GetAt( DWORD dwIndex, CLocalizationSync** ppSync );
	HRESULT RemoveAt( DWORD dwIndex );

	long GetSize( void )
	{
		return m_array.GetSize();
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\adaptest\perfndb.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// Use this guy to build a map of index to display name from a localized
// Name Database  At this time, it just brute forces a class and a flex
// array, but could be modified to use an STL map just as easily.

#ifndef __PERFNDB_H__
#define __PERFNDB_H__

#include <wbemcomn.h>
#include "adapelem.h"
#include "ntreg.h"

#define	DEFAULT_NAME_ID	L"009"

class CPerfNameDbEl
{
private:

	DWORD	m_dwIndex;
	LPCWSTR	m_pwcsName;

public:

	CPerfNameDbEl( LPCWSTR	pwcsEntry )
	{
		// Index is the first string, display
		// name is the next string
		m_dwIndex = wcstoul( pwcsEntry, NULL, 10 );
		m_pwcsName = pwcsEntry + ( lstrlenW( pwcsEntry ) + 1 );
	}

	~CPerfNameDbEl()
	{
	};

	BOOL IsIndex( DWORD dwIndex )
	{
		return m_dwIndex == dwIndex;
	}

	DWORD GetIndex( void )
	{
		return m_dwIndex;
	}

	LPCWSTR GetDisplayName( void )
	{
		return m_pwcsName;
	}
	
};

class CPerfNameDb : public CAdapElement
{
private:
	WString		m_wstrLangId;
	CFlexArray	m_array;
	BOOL		m_fOk;
	WCHAR*		m_pwcsNameDb;

public:

	CPerfNameDb( LPCWSTR pwcsLangId );
	~CPerfNameDb();

	BOOL IsOk( void )
	{
		return m_fOk;
	}

	HRESULT GetDisplayName( DWORD dwIndex, WString& wstrDisplayName );
	HRESULT GetDisplayName( DWORD dwIndex, LPCWSTR* ppwcsDisplayName );

	void Empty( void )
	{
		while ( m_array.Size() > 0 )
		{
			CPerfNameDbEl*	pEl = (CPerfNameDbEl*) m_array[0];

			if ( NULL != pEl )
			{
				delete pEl;
			}

			m_array.RemoveAt(0);
		}
	}

	long GetSize( void )
	{
		return m_array.Size();
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\adaptest\ntreg.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//***************************************************************************
//
//  REG.H
//
//  Utility registry classes.
//
//  a-raymcc    30-May-96   Created.
//
//***************************************************************************

#ifndef _NTREG_H_
#define _NTREG_H_
#include "corepol.h"

class CNTRegistry
{
    HKEY    m_hPrimaryKey;
    HKEY    m_hSubkey;
    int     m_nStatus;
    LONG    m_nLastError;
   
public:
    enum { no_error, failed, out_of_memory, no_more_items };
    
    CNTRegistry();
   ~CNTRegistry();

    int Open(HKEY hStart, WCHAR *pszStartKey);

    int MoveToSubkey(WCHAR *pszNewSubkey);

    int GetDWORD(WCHAR *pwszValueName, DWORD *pdwValue);
    int GetStr(WCHAR *pwszValueName, WCHAR **pwszValue);

    //Returns a pointer to a string buffer containing the null-terminated string.
    //The last entry is a double null terminator (i.e. the registry format for
    //a REG_MULTI_SZ).  Caller has do "delete []" the returned pointer.
    //dwSize is the size of the buffer returned.
    int GetMultiStr(WCHAR *pwszValueName, WCHAR** pwszValue, DWORD &dwSize);

    // Allows key enumneration
    int Enum( DWORD dwIndex, WCHAR** pwszValue, DWORD& dwSize );

    int SetDWORD(WCHAR *pwszValueName, DWORD dwValue);
    int SetStr(WCHAR *pwszValueName, WCHAR *wszValue);

    LONG GetLastError() { return m_nLastError; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\adaptest\localsync.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#ifndef __LOCALSYNC_H__
#define __LOCALSYNC_H__

#include "adapsync.h"

class CLocalizationSync : public CAdapSync
{
protected:

	WString				m_wstrLangId;
	WString				m_wstrSubNameSpace;
	WString				m_wstrLocaleId;
	CPerfNameDb*		m_pLocalizedNameDb;
	LANGID				m_LangId;
	LCID				m_LocaleId;

	void BuildLocaleInfo( void );

	// Overrides
	virtual HRESULT SetClassQualifiers( PERF_OBJECT_TYPE* pPerfObj, LPCWSTR pwcsServiceName,
								CWbemObject* pClass );

	virtual HRESULT SetPropertyQualifiers( PERF_COUNTER_DEFINITION* pCtrDefinition, BOOL fIsDefault,
									LPCWSTR pwcsPropertyName, CWbemObject* pClass );

	// For the localized classes, we don't do jack here
	virtual HRESULT SetAsCostly( CWbemObject* pClass );


public:

	CLocalizationSync( LPCWSTR pwszLangId );
	~CLocalizationSync(void);

	HRESULT Connect( CPerfNameDb* pDefaultNameDb );

	LPCWSTR	GetLangId( void )
	{
		return m_wstrLangId;
	}

	LPCWSTR	GetLocaleId( void )
	{
		return m_wstrLocaleId;
	}

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\adaptest\localsync.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// ADAPSYNC.cpp : implementation file
//

#define _WIN32_WINNT 0x0400

#include <windows.h>
#include <stdio.h>
#include <wbemcli.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include <fastall.h>
#include <cominit.h>
#include "perfndb.h"
#include "adapreg.h"
#include "adapcls.h"
#include "localsync.h"

// This is the base class for doing all the synchronization operations.  We should be able to derive
// a localized synchronization class which sets up minimal data, but basically follows the same
// logic

CLocalizationSync::CLocalizationSync( LPCWSTR pwszLangId )
:	CAdapSync(),
	m_wstrLangId( pwszLangId ),
	m_wstrSubNameSpace(),
	m_pLocalizedNameDb( NULL )
{
	BuildLocaleInfo();
}

CLocalizationSync::~CLocalizationSync( void )
{
	if ( NULL != m_pLocalizedNameDb )
	{
		m_pLocalizedNameDb->Release();
	}
}

void CLocalizationSync::BuildLocaleInfo( void )
{

	LPCWSTR	pwstrLangId = (LPWSTR) m_wstrLangId;
	DWORD	dwLangIdLen = m_wstrLangId.Length();

	// First check that all characters are numeric
	for ( DWORD	dwCtr = 0; dwCtr < dwLangIdLen && iswdigit( pwstrLangId[dwCtr] ); dwCtr++ );

	// Now look for the first non-zero character
	if ( dwCtr >= dwLangIdLen )
	{
		LPCWSTR	pwcsNumStart = pwstrLangId;

		for ( dwCtr = 0; dwCtr < dwLangIdLen && *pwcsNumStart == L'0'; dwCtr++, pwcsNumStart++ );

		// DEVNOTE:TODO - Is the 3 character assumption valid???
		if ( dwCtr < dwLangIdLen && wcslen( pwcsNumStart ) <= 3 )
		{
			// DEVNOTE:TODO - Verify this is hex
			// This value will be in hex
			WORD	wPrimaryLangId = (WORD) wcstoul( pwcsNumStart, NULL, 16 );

			m_LangId = MAKELANGID( wPrimaryLangId, SUBLANG_DEFAULT );
			m_LocaleId = MAKELCID( m_LangId, SORT_DEFAULT );

			// Now build the locale and namespace strings
			WCHAR	wcsTemp[32];

			swprintf( wcsTemp, L"0x%.4X", m_LangId );
			m_wstrLocaleId = wcsTemp;

			swprintf( wcsTemp, L"MS_%hX", m_LangId );
			m_wstrSubNameSpace = wcsTemp;

		}

	}

}

HRESULT CLocalizationSync::Connect( CPerfNameDb* pDefaultNameDb )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// If we don't have thess, we don't have jack
	if (	m_wstrSubNameSpace.Length() > 0	&&
			m_wstrLocaleId.Length()		> 0 &&
			m_wstrLangId.Length()		> 0 )
	{
		// Instantiate a localized name database for the language id.

		try
		{
			// If the default language id is what we found, use the
			// default name db
			if ( m_wstrLangId.EqualNoCase( DEFAULT_NAME_ID ) )
			{
				m_pLocalizedNameDb = pDefaultNameDb;
				m_pLocalizedNameDb->AddRef();
			}
			else
			{
				m_pLocalizedNameDb = new CPerfNameDb( m_wstrLangId );

				if ( m_pLocalizedNameDb->IsOk() )
				{
					m_pLocalizedNameDb->AddRef();
				}
				else
				{
					// DEVNOTE:TODO - We should log a failure event here
					delete m_pLocalizedNameDb;
					m_pLocalizedNameDb = NULL;
					hr = WBEM_E_FAILED;
				}
			}

			// Now build the full namespace and do a full hookup
			if ( SUCCEEDED( hr ) )
			{
				WCHAR	wcsFullNameSpace[256];

				swprintf( wcsFullNameSpace, L"%s\\%s", ADAP_ROOT_NAMESPACE, (LPCWSTR) m_wstrSubNameSpace );

				// Call down to the base class to hook us up
				hr = CAdapSync::Connect( wcsFullNameSpace, pDefaultNameDb );
			}

		}
		catch(...)
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}

	}
	else
	{
		hr = WBEM_E_FAILED;
	}

	return hr;
}

// Overrides of default namespace functions.  The following functions will create localized classes for
// Perf Counter localization

// Sets all the class qualifiers
HRESULT CLocalizationSync::SetClassQualifiers( PERF_OBJECT_TYPE* pPerfObj, LPCWSTR pwcsServiceName,
										CWbemObject* pClass )
////////////////////////////////////////////////////////////////////////////////////////////
//
//	Sets the class' qualifiers.  Note that the operations are performed directly on the 
//	CWbemObject.
//
////////////////////////////////////////////////////////////////////////////////////////////
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	//	The following qualifiers will be added:
	//	1 >	Amendment
	//	2 >	Abstract
	//	3 >	locale(0x0409)
	//	4 >	DisplayAs (Amended flavor)
	//	5 > genericperfctr (signals that this is a generic counter)

	CVar	var;

	// We may get an OOM exception
	try
	{
		// Amendment
		var.SetBool( VARIANT_TRUE );
		hr = pClass->SetQualifier( L"Amendment", &var, 0L );

		// Abstract
		if ( SUCCEEDED( hr ) )
		{
			var.Empty();
			var.SetBool( VARIANT_TRUE );
			hr = pClass->SetQualifier( L"Abstract", &var, 0L );
		}

		// locale
		if ( SUCCEEDED( hr ) )
		{
			var.Empty();
			var.SetLong( m_LangId );
			hr = pClass->SetQualifier( L"locale", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
		}

		// display
		if ( SUCCEEDED( hr ) )
		{
			LPCWSTR	pwcsDisplayName = NULL;

			var.Empty();

			hr = m_pLocalizedNameDb->GetDisplayName( pPerfObj->ObjectNameTitleIndex, &pwcsDisplayName );

			// If this is a localized Db, this could be a benign error.  We could just pull the
			// value from the default db
			if ( SUCCEEDED( hr ) )
			{
				var.SetBSTR( (LPWSTR) pwcsDisplayName );
				hr = pClass->SetQualifier( L"DisplayName", &var,
						WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | WBEM_FLAVOR_AMENDED );
			}
		}

		// genericperfctr
		if ( SUCCEEDED(hr) )
		{
			var.Empty();
			var.SetBool( VARIANT_TRUE );
			hr = pClass->SetQualifier( L"genericperfctr", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
		}

	}
	catch(...)
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}

	return hr;
}

// Adds localization property qualifiers defined by the counter definition
HRESULT CLocalizationSync::SetPropertyQualifiers( PERF_COUNTER_DEFINITION* pCtrDefinition, BOOL fIsDefault,
									LPCWSTR pwcsPropertyName, CWbemObject* pClass )
////////////////////////////////////////////////////////////////////////////////////////////
//
//	Sets the values of the properties.
//
////////////////////////////////////////////////////////////////////////////////////////////
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	//	The following qualifiers will be added:
	//	1>	DisplayAs (Amended flavor)

	CVar	var;

	// We may get an OOM exception
	try
	{
		// DisplayAs
		if ( SUCCEEDED( hr ) )
		{
			LPCWSTR	pwcsDisplayName = NULL;

			var.Empty();

			hr = m_pLocalizedNameDb->GetDisplayName( pCtrDefinition->CounterNameTitleIndex, &pwcsDisplayName );

			// If this is a localized Db, this could be a benign error.  We could just pull the
			// value from the default db
			if ( SUCCEEDED( hr ) )
			{
				var.SetBSTR( (LPWSTR) pwcsDisplayName );
				hr = pClass->SetPropQualifier( pwcsPropertyName, L"DisplayName",
								WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | WBEM_FLAVOR_AMENDED,	&var );
			}
		}

	}
	catch(...)
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}

	return hr;
}

HRESULT CLocalizationSync::SetAsCostly( CWbemObject* pClass )
{
	// This qualifier is not necessary for the localized definitions
	return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\adaptest\ntreg.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//***************************************************************************
//
//  REG.CPP
//
//  Utility CNTRegistry classes.
//
//  a-raymcc    30-May-96   Created.
//
//***************************************************************************

#include <windows.h>

#include <stdio.h>
#include "ntreg.h"
#include <dbgalloc.h>

CNTRegistry::CNTRegistry() : m_hPrimaryKey(0), 
							 m_hSubkey(0),
							 m_nStatus(0),
							 m_nLastError(no_error)
{}

CNTRegistry::~CNTRegistry()
{
    if (m_hSubkey)
        RegCloseKey(m_hSubkey);
    if (m_hPrimaryKey != m_hSubkey)
        RegCloseKey(m_hPrimaryKey);
}

int CNTRegistry::Open(HKEY hStart, WCHAR *pszStartKey)
{
    int nStatus = no_error;

 	m_nLastError = RegOpenKeyExW(hStart, pszStartKey,
									0, KEY_ALL_ACCESS, &m_hPrimaryKey );

    if (m_nLastError != 0)
            nStatus = failed;

	m_hSubkey = m_hPrimaryKey;

    return nStatus;
}

int CNTRegistry::MoveToSubkey(WCHAR *pszNewSubkey)
{
    int nStatus = no_error;

	m_nLastError = RegOpenKeyExW(m_hPrimaryKey, pszNewSubkey, 0, KEY_ALL_ACCESS, &m_hSubkey );

    if (m_nLastError != 0)
            nStatus = failed;

    return nStatus;
}

int CNTRegistry::GetDWORD(WCHAR *pwszValueName, DWORD *pdwValue)
{
	int nStatus = no_error;

    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = 0;

	m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType,
								LPBYTE(pdwValue), &dwSize);
    if (m_nLastError != 0)
		nStatus = failed;

    if (dwType != REG_DWORD)
        nStatus = failed;

    return nStatus;
}

int CNTRegistry::GetStr(WCHAR *pwszValueName, WCHAR **pwszValue)
{
    *pwszValue = 0;
    DWORD dwSize = 0;
    DWORD dwType = 0;

	m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType,
									0, &dwSize);
    if (m_nLastError != 0)
            return failed;

    if (dwType != REG_SZ)
        return failed;

    WCHAR *p = _new WCHAR[dwSize];

	m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType,
									LPBYTE(p), &dwSize);
    if (m_nLastError != 0)
    {
        delete [] p;
		return failed;
    }

    *pwszValue = p;
    return no_error;
}

int CNTRegistry::Enum( DWORD dwIndex, WCHAR **pwszValue, DWORD& dwSize )
{
	DWORD	dwBuffSize = dwSize;

	m_nLastError = RegEnumKeyExW(m_hSubkey, dwIndex, *pwszValue, &dwBuffSize,
									NULL, NULL, NULL, NULL );

	while ( m_nLastError == ERROR_MORE_DATA )
	{
		// Grow in 256 byte chunks
		dwBuffSize += 256;

		try
		{
			// Reallocate the buffer and retry
			WCHAR*	p = _new WCHAR[dwBuffSize];

			if ( NULL != *pwszValue )
			{
				delete *pwszValue;
			}

			*pwszValue = p;
			dwSize = dwBuffSize;

			m_nLastError = RegEnumKeyExW(m_hSubkey, dwIndex, *pwszValue, &dwBuffSize,
											NULL, NULL, NULL, NULL );

		}
		catch (...)
		{
			return out_of_memory;
		}

	}

	if ( ERROR_SUCCESS != m_nLastError )
	{
		if ( ERROR_NO_MORE_ITEMS == m_nLastError )
		{
			return no_more_items;
		}
		else
		{
			return failed;
		}
	}

    return no_error;
}

int CNTRegistry::GetMultiStr(WCHAR *pwszValueName, WCHAR** pwszValue, DWORD &dwSize)
{
	//Find out the size of the buffer required
	DWORD dwType;
	m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType, NULL, &dwSize);

	//If the error is an unexpected one bail out
	if ((m_nLastError != ERROR_SUCCESS) || (dwType != REG_MULTI_SZ))
	{
		dwSize = 0;
		return failed;
	}

	if (dwSize == 0)
	{
		dwSize = 0;
		return failed;
	}

	//allocate the buffer required
	WCHAR *pData = new WCHAR[dwSize];
	
	//get the values
	m_nLastError = RegQueryValueExW(m_hSubkey, 
								   pwszValueName, 
								   0, 
								   &dwType, 
								   LPBYTE(pData), 
								   &dwSize);

	//if an error bail out
	if (m_nLastError != 0)
	{
		delete [] pData;
		dwSize = 0;
		return failed;
	}

	*pwszValue = pData;
	return no_error;
}

int CNTRegistry::SetDWORD(WCHAR *pwszValueName, DWORD dwValue)
{
	int nStatus = no_error;

	m_nLastError = RegSetValueExW( m_hSubkey, 
								   pwszValueName,
								   0,
								   REG_DWORD,
								   (BYTE*)&dwValue,
								   sizeof( dwValue ) );

	if ( m_nLastError != ERROR_SUCCESS )
	{
		nStatus = failed;
	}

	return nStatus;
}

int CNTRegistry::SetStr(WCHAR *pwszValueName, WCHAR *wszValue)
{
	int nStatus = no_error;

	m_nLastError = RegSetValueExW( m_hSubkey, 
								   pwszValueName,
								   0,
								   REG_SZ,
								   (BYTE*)wszValue,
								   sizeof(WCHAR) * (wcslen(wszValue) + 1) );

	if ( m_nLastError != ERROR_SUCCESS )
	{
		nStatus = failed;
	}

	return nStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\adaptest\perfthrd.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// OBJINTERNALSTESTDlg.cpp : implementation file
//

#define _WIN32_WINNT 0x0400

#include <windows.h>
//#include <objbase.h>
#include <stdio.h>
#include <process.h>
#include <wbemcli.h>
#include <cominit.h>
#include "ntreg.h"
#include "perfthrd.h"
#include "adaptest.h"

//	IMPORTANT!!!!

//	This code MUST be revisited to do the following:
//	A>>>>>	Exception Handling around the outside calls
//	B>>>>>	Use a named mutex around the calls
//	C>>>>>	Make the calls on another thread
//	D>>>>>	Place and handle registry entries that indicate a bad DLL!

CPerfThread::CPerfThread()
////////////////////////////////////////////////////////////////////////////////////////////
//
//	Constructor
//
////////////////////////////////////////////////////////////////////////////////////////////
{}

CPerfThread::~CPerfThread()
////////////////////////////////////////////////////////////////////////////////////////////
//
//	Destructor
//
////////////////////////////////////////////////////////////////////////////////////////////
{}

HRESULT CPerfThread::Open( CAdapPerfLib* pLib )
////////////////////////////////////////////////////////////////////////////////////////////
//
//	Open creates a new open request object using the CAdapPerfLib parameter.  It then queues
//	it up and waits for PERFTHREAD_TIMEOUT milliseconds.  If the operation has not returned 
//	in time, then ...
//
////////////////////////////////////////////////////////////////////////////////////////////
{
	HRESULT	hr = WBEM_E_FAILED;

	HANDLE	hWhenDone = NULL;	// The event handle which signals the completion of the request

	// Create new request object
	// =========================

	CPerfOpenRequest*	pOpenRequest = new CPerfOpenRequest( pLib );

	try
	{
		if ( NULL == pOpenRequest )
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
		else
		{
			// Queue the request and return
			// ============================

			Enqueue( pOpenRequest );

			// Wait for the call to return
			// ===========================

			switch ( WaitForSingleObject( pOpenRequest->GetWhenDoneHandle(), PERFTHREAD_TIMEOUT ) )
			{
			case WAIT_OBJECT_0:
				{
					// SUCCESS: Call returned before it timed-out
					// ==========================================

					hr = pOpenRequest->GetHRESULT();
				}break;

			case WAIT_TIMEOUT:
				{
#ifdef DEBUGDUMP
				printf( "\t\tOpen timed-out.\n" );
#endif
					pLib->SetStatus( ADAP_BAD_PROVIDER );
					hr = Reset();
				}
			}

			// Release the request
			pOpenRequest->Release();
		}
	}
	catch(...)
	{
		// Clean up 
		if (NULL != pOpenRequest)
		{
			delete pOpenRequest;
		}

		hr = WBEM_E_FAILED;
	}

	return hr;
}

HRESULT	CPerfThread::GetPerfBlock( CAdapPerfLib* pLib, PERF_OBJECT_TYPE** ppData,
									   DWORD* pdwBytes, DWORD* pdwNumObjTypes, BOOL fCostly )
{
	HRESULT	hr = WBEM_E_FAILED;

	try
	{
		CPerfCollectRequest*	pRequest = new CPerfCollectRequest( pLib, fCostly );

		Enqueue( pRequest );

		switch ( WaitForSingleObject( pRequest->GetWhenDoneHandle(), PERFTHREAD_TIMEOUT ) )
		{
		case WAIT_OBJECT_0:
			{
				hr = pRequest->GetHRESULT();
				pRequest->GetData( ppData, pdwBytes, pdwNumObjTypes );
			}break;

		case WAIT_TIMEOUT:
			{
#ifdef DEBUGDUMP
				printf( "\t\tCollection timed-out.\n" );
#endif
				pLib->SetStatus( ADAP_BAD_PROVIDER );
				hr = Reset();
			}break;
		}

		pRequest->Release();
	}
	catch(...)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}

	return hr;
}

HRESULT CPerfThread::Close( CAdapPerfLib* pLib )
{
	HRESULT	hr = WBEM_E_FAILED;

	try
	{
		CPerfCloseRequest*	pRequest = new CPerfCloseRequest( pLib );

		Enqueue( pRequest );

		switch ( WaitForSingleObject( pRequest->GetWhenDoneHandle(), PERFTHREAD_TIMEOUT ) )
		{
		case WAIT_OBJECT_0:
			{
				hr = pRequest->GetHRESULT();
			}break;
		case WAIT_TIMEOUT:
			{
#ifdef DEBUGDUMP
				printf( "\t\tClose timed-out.\n" );
#endif
				pLib->SetStatus( ADAP_BAD_PROVIDER );
				hr = Reset();
			}break;
		}

		pRequest->Release();
	}
	catch(...)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}

	return hr;
}

CPerfOpenRequest::~CPerfOpenRequest()
{}

HRESULT CPerfOpenRequest::Execute( void )
{
	// Call the open function in the perflib
	// =====================================

	m_hrReturn = m_pLib->Open();
	return m_hrReturn;
}

CPerfCollectRequest::~CPerfCollectRequest()
{}

HRESULT CPerfCollectRequest::Execute( void )
{
	// Call the collect function in the perflib
	// ========================================

	m_hrReturn = m_pLib->GetPerfBlock( &m_pData, &m_dwBytes, &m_dwNumObjTypes, m_fCostly );
	return m_hrReturn;
}

CPerfCloseRequest::~CPerfCloseRequest()
{}

HRESULT CPerfCloseRequest::Execute( void )
{
	// Call the open function in the perflib
	// =====================================

	m_hrReturn = m_pLib->Close();
	return m_hrReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\adaptest\perfndb.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// OBJINTERNALSTESTDlg.cpp : implementation file
//

#define _WIN32_WINNT 0x0400

#include <windows.h>
//#include <objbase.h>
#include <stdio.h>
#include <wbemcli.h>
#include <cominit.h>
#include "perfndb.h"

//	This code MUST be revisited to do the following:
//	A>>>>>	Exception Handling around the outside calls
//	B>>>>>	Use a named mutex around the calls
//	C>>>>>	Make the calls on another thread
//	D>>>>>	Place and handle registry entries that indicate a bad DLL!

// Class constructor
CPerfNameDb::CPerfNameDb( LPCWSTR pwcsLangId )
:	CAdapElement(),
	m_wstrLangId( pwcsLangId ),
	m_fOk( FALSE )
{
	CNTRegistry	reg;
	WString		wstr = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\PerfLib";

	if ( reg.Open( HKEY_LOCAL_MACHINE, wstr ) == CNTRegistry::no_error )
	{
		DWORD	dwLength = 0;

		if ( reg.MoveToSubkey( (LPWSTR) pwcsLangId ) == CNTRegistry::no_error )
		{
			if ( reg.GetMultiStr( L"Counter", &m_pwcsNameDb, dwLength ) == CNTRegistry::no_error )
			{
				WCHAR*	pwcsCounter = m_pwcsNameDb;

				try
				{
					while ( NULL != *pwcsCounter )
					{
						CPerfNameDbEl*	pEl = new CPerfNameDbEl( pwcsCounter );

						if ( m_array.Add( (void*) pEl ) == CFlexArray::no_error )
						{
							// Skip index and name
							pwcsCounter += ( lstrlenW( pwcsCounter ) + 1 );
							pwcsCounter += ( lstrlenW( pwcsCounter ) + 1 );
						}

					}	// WHILE ( NULL != *pwcsCounter );

				}
				catch(...)
				{
				}

				if ( NULL == *pwcsCounter )
				{
					m_fOk = TRUE;
				}

			}	// IF Get Counter

		}	// IF MoveToSubKey

	}	// IF open key

}
// Class Destructor
CPerfNameDb::~CPerfNameDb( void )
{
	Empty();
	delete [] m_pwcsNameDb;
}

// Returns object if the classname matches
HRESULT	CPerfNameDb::GetDisplayName( DWORD dwIndex, WString& wstrDisplayName )
{
	HRESULT	hr = WBEM_E_FAILED;

	for ( int x = 0; x < m_array.Size(); x++ )
	{
		CPerfNameDbEl*	pEl = (CPerfNameDbEl*) m_array[x];

		if ( pEl->IsIndex( dwIndex ) )
		{
			try
			{
				wstrDisplayName = pEl->GetDisplayName();
				hr = WBEM_S_NO_ERROR;
			}
			catch (...)
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}

			break;
		}
	}

	return hr;

}

// Returns pointer if the classname matches
HRESULT	CPerfNameDb::GetDisplayName( DWORD dwIndex, LPCWSTR* ppwcsDisplayName )
{
	HRESULT	hr = WBEM_E_FAILED;

	for ( int x = 0; x < m_array.Size(); x++ )
	{
		CPerfNameDbEl*	pEl = (CPerfNameDbEl*) m_array[x];

		if ( pEl->IsIndex( dwIndex ) )
		{
			try
			{
				*ppwcsDisplayName = pEl->GetDisplayName();
				hr = WBEM_S_NO_ERROR;
			}
			catch (...)
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}

			break;
		}
	}

	return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\adaptest\perfthrd.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// Base thread class for calling into the perflibs safely.

#ifndef __PERFTHRD_H__
#define __PERFTHRD_H__

#include <wbemcomn.h>
#include <fastall.h>
#include "adapperf.h"
#include "adapthrd.h"

// DEVNOTE:TODO - Probably should use the ExecQueue and a request to do this.
// However, we will need a way to terminate the execqueue and restart it, and
// that may require more hacking that is mandated, so let's use our own
// queuing mechanism for now.

// One minute timeout
#define	PERFTHREAD_TIMEOUT	6000000

class CPerfOpenRequest : public CAdapThreadRequest
{
private:

	CAdapPerfLib*	m_pLib;

public:

	CPerfOpenRequest( CAdapPerfLib* pLib ) : m_pLib( pLib ){};
	~CPerfOpenRequest();

	HRESULT Execute();

};

class CPerfCollectRequest : public CAdapThreadRequest
{
private:

	CAdapPerfLib*				m_pLib;
	// Return data holders
	PERF_OBJECT_TYPE* m_pData;
	DWORD			m_dwBytes;
	DWORD			m_dwNumObjTypes;
	BOOL			m_fCostly;


public:

	CPerfCollectRequest( CAdapPerfLib* pLib, BOOL fCostly )
		: m_pLib( pLib ), m_pData( NULL ), m_dwBytes( 0 ), m_dwNumObjTypes( 0 ), m_fCostly( fCostly ){};
	~CPerfCollectRequest();

	HRESULT Execute();

	void GetData( PERF_OBJECT_TYPE** ppData, DWORD* pdwBytes, DWORD* pdwNumObjTypes )
	{
		*ppData = m_pData;
		*pdwBytes = m_dwBytes;
		*pdwNumObjTypes = m_dwNumObjTypes;
	}
};

class CPerfCloseRequest : public CAdapThreadRequest
{
private:

	CAdapPerfLib*	m_pLib;

public:

	CPerfCloseRequest( CAdapPerfLib* pLib ) : m_pLib( pLib ){};
	~CPerfCloseRequest();

	HRESULT Execute();

};


class CPerfThread : public CAdapThread
{
private:
	// Holds parameters for GetPerfBlock() call
	// Note this isn't exactly thread-safe, so doing
	// all of this via a request may not be a
	// bad idea.

	PERF_OBJECT_TYPE**	m_ppData;
	DWORD*				m_dwBytes;
	DWORD*				m_dwNumObjTypes;
	BOOL				m_fCostly;

public:
	CPerfThread();
	virtual ~CPerfThread();

	HRESULT Open( CAdapPerfLib* pLib );
	HRESULT	GetPerfBlock( CAdapPerfLib* pLib, PERF_OBJECT_TYPE** ppData, DWORD* pdwBytes, DWORD* pdwNumObjTypes, BOOL fCostly );
	HRESULT	Close( CAdapPerfLib* pLib );

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\arbitrator\arbitratormain.cpp ===
// Arbitrator.cpp : Defines the entry point for the DLL application.
//

#include "precomp.h"
#include "Arbitrator.h"
#include <objbase.h>
#include <windows.h>


#include "classfac.h"
#include "arbitrator_i.c"


LONG	g_cObj = 0;
LONG	g_cLock = 0;
HMODULE ghModule;


// {67429ED7-F52F-4773-B9BB-30302B0270DE}
static const GUID CLSID_Arbitrator = 
{ 0x67429ed7, 0xf52f, 0x4773, { 0xb9, 0xbb, 0x30, 0x30, 0x2b, 0x2, 0x70, 0xde } };


BOOL APIENTRY DllMain( HINSTANCE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		case DLL_PROCESS_DETACH:
			break;
    }
    
	ghModule = hModule;
	return TRUE;
}





//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void** ppv)
{
    HRESULT hr;
    CFactory *pObj;

    if (CLSID_Arbitrator != rclsid)
        return E_FAIL;

    pObj=new CFactory();

    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    sc=(0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;
    return sc;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    char       szID[128];
    WCHAR      wcID[128];
    char       szCLSID[128];
    char       szModule[MAX_PATH];
    char * pName = "WMI Arbitrator Test Simulation";
    char * pModel = "Both";
    HKEY hKey1, hKey2;

    // Create the path.

    StringFromGUID2(CLSID_Arbitrator, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("Software\\classes\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, lstrlen(pName)+1);
    RegCreateKey(hKey1,"InprocServer32",&hKey2);

    GetModuleFileName(ghModule, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        lstrlen(szModule)+1);
    RegSetValueEx(hKey2, "ThreadingModel", 0, REG_SZ, 
                                        (BYTE *)pModel, lstrlen(pModel)+1);
    RegCloseKey(hKey1);
    RegCloseKey(hKey2);
    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    char       szID[128];
    WCHAR      wcID[128];
    char  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

    StringFromGUID2(CLSID_Arbitrator, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("Software\\classes\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, "InProcServer32");
        RegCloseKey(hKey);
    }

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, "Software\\classes\\CLSID", &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        RegCloseKey(hKey);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\arbitrator\arbitrator.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Wed Nov 29 20:38:43 2000
 */
/* Compiler settings for E:\WorkZone\Code\Arbitrator\arbitrator.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __arbitrator_h__
#define __arbitrator_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef ___IWmiCoreHandle_FWD_DEFINED__
#define ___IWmiCoreHandle_FWD_DEFINED__
typedef interface _IWmiCoreHandle _IWmiCoreHandle;
#endif 	/* ___IWmiCoreHandle_FWD_DEFINED__ */


#ifndef ___IWmiUserHandle_FWD_DEFINED__
#define ___IWmiUserHandle_FWD_DEFINED__
typedef interface _IWmiUserHandle _IWmiUserHandle;
#endif 	/* ___IWmiUserHandle_FWD_DEFINED__ */


#ifndef ___IWmiArbitrator_FWD_DEFINED__
#define ___IWmiArbitrator_FWD_DEFINED__
typedef interface _IWmiArbitrator _IWmiArbitrator;
#endif 	/* ___IWmiArbitrator_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef ___IWmiCoreHandle_INTERFACE_DEFINED__
#define ___IWmiCoreHandle_INTERFACE_DEFINED__

/* interface _IWmiCoreHandle */
/* [uuid][local][object] */ 


EXTERN_C const IID IID__IWmiCoreHandle;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ac062f20-9935-4aae-98eb-0532fb17147a")
    _IWmiCoreHandle : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetHandleType( 
            /* [out] */ ULONG __RPC_FAR *puType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateMemoryUsage( 
            LONG ulMemUsage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMemoryUsage( 
            ULONG __RPC_FAR *__MIDL_0015) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalSleepTime( 
            ULONG __RPC_FAR *__MIDL_0016) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTaskStatus( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStartTime( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEndTime( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateTotalSleepTime( 
            ULONG ulSlpTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateTaskStatus( 
            ULONG ulStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct _IWmiCoreHandleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _IWmiCoreHandle __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _IWmiCoreHandle __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _IWmiCoreHandle __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHandleType )( 
            _IWmiCoreHandle __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateMemoryUsage )( 
            _IWmiCoreHandle __RPC_FAR * This,
            LONG ulMemUsage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMemoryUsage )( 
            _IWmiCoreHandle __RPC_FAR * This,
            ULONG __RPC_FAR *__MIDL_0015);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTotalSleepTime )( 
            _IWmiCoreHandle __RPC_FAR * This,
            ULONG __RPC_FAR *__MIDL_0016);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTaskStatus )( 
            _IWmiCoreHandle __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStartTime )( 
            _IWmiCoreHandle __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEndTime )( 
            _IWmiCoreHandle __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateTotalSleepTime )( 
            _IWmiCoreHandle __RPC_FAR * This,
            ULONG ulSlpTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateTaskStatus )( 
            _IWmiCoreHandle __RPC_FAR * This,
            ULONG ulStatus);
        
        END_INTERFACE
    } _IWmiCoreHandleVtbl;

    interface _IWmiCoreHandle
    {
        CONST_VTBL struct _IWmiCoreHandleVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _IWmiCoreHandle_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _IWmiCoreHandle_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _IWmiCoreHandle_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _IWmiCoreHandle_GetHandleType(This,puType)	\
    (This)->lpVtbl -> GetHandleType(This,puType)

#define _IWmiCoreHandle_UpdateMemoryUsage(This,ulMemUsage)	\
    (This)->lpVtbl -> UpdateMemoryUsage(This,ulMemUsage)

#define _IWmiCoreHandle_GetMemoryUsage(This,__MIDL_0015)	\
    (This)->lpVtbl -> GetMemoryUsage(This,__MIDL_0015)

#define _IWmiCoreHandle_GetTotalSleepTime(This,__MIDL_0016)	\
    (This)->lpVtbl -> GetTotalSleepTime(This,__MIDL_0016)

#define _IWmiCoreHandle_GetTaskStatus(This)	\
    (This)->lpVtbl -> GetTaskStatus(This)

#define _IWmiCoreHandle_GetStartTime(This)	\
    (This)->lpVtbl -> GetStartTime(This)

#define _IWmiCoreHandle_GetEndTime(This)	\
    (This)->lpVtbl -> GetEndTime(This)

#define _IWmiCoreHandle_UpdateTotalSleepTime(This,ulSlpTime)	\
    (This)->lpVtbl -> UpdateTotalSleepTime(This,ulSlpTime)

#define _IWmiCoreHandle_UpdateTaskStatus(This,ulStatus)	\
    (This)->lpVtbl -> UpdateTaskStatus(This,ulStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE _IWmiCoreHandle_GetHandleType_Proxy( 
    _IWmiCoreHandle __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *puType);


void __RPC_STUB _IWmiCoreHandle_GetHandleType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE _IWmiCoreHandle_UpdateMemoryUsage_Proxy( 
    _IWmiCoreHandle __RPC_FAR * This,
    LONG ulMemUsage);


void __RPC_STUB _IWmiCoreHandle_UpdateMemoryUsage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE _IWmiCoreHandle_GetMemoryUsage_Proxy( 
    _IWmiCoreHandle __RPC_FAR * This,
    ULONG __RPC_FAR *__MIDL_0015);


void __RPC_STUB _IWmiCoreHandle_GetMemoryUsage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE _IWmiCoreHandle_GetTotalSleepTime_Proxy( 
    _IWmiCoreHandle __RPC_FAR * This,
    ULONG __RPC_FAR *__MIDL_0016);


void __RPC_STUB _IWmiCoreHandle_GetTotalSleepTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE _IWmiCoreHandle_GetTaskStatus_Proxy( 
    _IWmiCoreHandle __RPC_FAR * This);


void __RPC_STUB _IWmiCoreHandle_GetTaskStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE _IWmiCoreHandle_GetStartTime_Proxy( 
    _IWmiCoreHandle __RPC_FAR * This);


void __RPC_STUB _IWmiCoreHandle_GetStartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE _IWmiCoreHandle_GetEndTime_Proxy( 
    _IWmiCoreHandle __RPC_FAR * This);


void __RPC_STUB _IWmiCoreHandle_GetEndTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE _IWmiCoreHandle_UpdateTotalSleepTime_Proxy( 
    _IWmiCoreHandle __RPC_FAR * This,
    ULONG ulSlpTime);


void __RPC_STUB _IWmiCoreHandle_UpdateTotalSleepTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE _IWmiCoreHandle_UpdateTaskStatus_Proxy( 
    _IWmiCoreHandle __RPC_FAR * This,
    ULONG ulStatus);


void __RPC_STUB _IWmiCoreHandle_UpdateTaskStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* ___IWmiCoreHandle_INTERFACE_DEFINED__ */


#ifndef ___IWmiUserHandle_INTERFACE_DEFINED__
#define ___IWmiUserHandle_INTERFACE_DEFINED__

/* interface _IWmiUserHandle */
/* [uuid][local][object] */ 


EXTERN_C const IID IID__IWmiUserHandle;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d8d984b-9965-4023-921a-610b348ee54e")
    _IWmiUserHandle : public _IWmiCoreHandle
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct _IWmiUserHandleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _IWmiUserHandle __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _IWmiUserHandle __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _IWmiUserHandle __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHandleType )( 
            _IWmiUserHandle __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateMemoryUsage )( 
            _IWmiUserHandle __RPC_FAR * This,
            LONG ulMemUsage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMemoryUsage )( 
            _IWmiUserHandle __RPC_FAR * This,
            ULONG __RPC_FAR *__MIDL_0015);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTotalSleepTime )( 
            _IWmiUserHandle __RPC_FAR * This,
            ULONG __RPC_FAR *__MIDL_0016);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTaskStatus )( 
            _IWmiUserHandle __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStartTime )( 
            _IWmiUserHandle __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEndTime )( 
            _IWmiUserHandle __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateTotalSleepTime )( 
            _IWmiUserHandle __RPC_FAR * This,
            ULONG ulSlpTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateTaskStatus )( 
            _IWmiUserHandle __RPC_FAR * This,
            ULONG ulStatus);
        
        END_INTERFACE
    } _IWmiUserHandleVtbl;

    interface _IWmiUserHandle
    {
        CONST_VTBL struct _IWmiUserHandleVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _IWmiUserHandle_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _IWmiUserHandle_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _IWmiUserHandle_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _IWmiUserHandle_GetHandleType(This,puType)	\
    (This)->lpVtbl -> GetHandleType(This,puType)

#define _IWmiUserHandle_UpdateMemoryUsage(This,ulMemUsage)	\
    (This)->lpVtbl -> UpdateMemoryUsage(This,ulMemUsage)

#define _IWmiUserHandle_GetMemoryUsage(This,__MIDL_0015)	\
    (This)->lpVtbl -> GetMemoryUsage(This,__MIDL_0015)

#define _IWmiUserHandle_GetTotalSleepTime(This,__MIDL_0016)	\
    (This)->lpVtbl -> GetTotalSleepTime(This,__MIDL_0016)

#define _IWmiUserHandle_GetTaskStatus(This)	\
    (This)->lpVtbl -> GetTaskStatus(This)

#define _IWmiUserHandle_GetStartTime(This)	\
    (This)->lpVtbl -> GetStartTime(This)

#define _IWmiUserHandle_GetEndTime(This)	\
    (This)->lpVtbl -> GetEndTime(This)

#define _IWmiUserHandle_UpdateTotalSleepTime(This,ulSlpTime)	\
    (This)->lpVtbl -> UpdateTotalSleepTime(This,ulSlpTime)

#define _IWmiUserHandle_UpdateTaskStatus(This,ulStatus)	\
    (This)->lpVtbl -> UpdateTaskStatus(This,ulStatus)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* ___IWmiUserHandle_INTERFACE_DEFINED__ */


#ifndef ___IWmiArbitrator_INTERFACE_DEFINED__
#define ___IWmiArbitrator_INTERFACE_DEFINED__

/* interface _IWmiArbitrator */
/* [uuid][local][object] */ 


EXTERN_C const IID IID__IWmiArbitrator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("67429ED7-F52F-4773-B9BB-30302B0270DE")
    _IWmiArbitrator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterTask( 
            /* [in] */ _IWmiCoreHandle __RPC_FAR *__RPC_FAR *phTask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterTask( 
            /* [in] */ _IWmiCoreHandle __RPC_FAR *phTask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterUser( 
            /* [in] */ _IWmiCoreHandle __RPC_FAR *phUser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterUser( 
            /* [in] */ _IWmiCoreHandle __RPC_FAR *phUser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CheckTask( 
            /* [in] */ ULONG uFlags,
            /* [in] */ _IWmiCoreHandle __RPC_FAR *phTask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TaskStateChange( 
            /* [in] */ ULONG uNewState,
            /* [in] */ _IWmiCoreHandle __RPC_FAR *phTask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelTasksBySink( 
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ LPVOID pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CheckThread( 
            /* [in] */ ULONG uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CheckUser( 
            /* [in] */ ULONG uFlags,
            /* [in] */ _IWmiUserHandle __RPC_FAR *phUser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelTask( 
            /* [in] */ ULONG uFlags,
            /* [in] */ _IWmiCoreHandle __RPC_FAR *phTtask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterThreadForTask( 
            /* [in] */ _IWmiCoreHandle __RPC_FAR *phTask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterThreadForTask( 
            /* [in] */ _IWmiCoreHandle __RPC_FAR *phTask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Maintenance( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterNamespace( 
            /* [in] */ _IWmiCoreHandle __RPC_FAR *phNamespace) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterNamespace( 
            /* [in] */ _IWmiCoreHandle __RPC_FAR *phNamespace) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReportMemoryUsage( 
            /* [in] */ LONG uBackLog,
            /* [in] */ _IWmiCoreHandle __RPC_FAR *phTask) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct _IWmiArbitratorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _IWmiArbitrator __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _IWmiArbitrator __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _IWmiArbitrator __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterTask )( 
            _IWmiArbitrator __RPC_FAR * This,
            /* [in] */ _IWmiCoreHandle __RPC_FAR *__RPC_FAR *phTask);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnregisterTask )( 
            _IWmiArbitrator __RPC_FAR * This,
            /* [in] */ _IWmiCoreHandle __RPC_FAR *phTask);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterUser )( 
            _IWmiArbitrator __RPC_FAR * This,
            /* [in] */ _IWmiCoreHandle __RPC_FAR *phUser);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnregisterUser )( 
            _IWmiArbitrator __RPC_FAR * This,
            /* [in] */ _IWmiCoreHandle __RPC_FAR *phUser);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CheckTask )( 
            _IWmiArbitrator __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ _IWmiCoreHandle __RPC_FAR *phTask);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TaskStateChange )( 
            _IWmiArbitrator __RPC_FAR * This,
            /* [in] */ ULONG uNewState,
            /* [in] */ _IWmiCoreHandle __RPC_FAR *phTask);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelTasksBySink )( 
            _IWmiArbitrator __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ LPVOID pSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CheckThread )( 
            _IWmiArbitrator __RPC_FAR * This,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CheckUser )( 
            _IWmiArbitrator __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ _IWmiUserHandle __RPC_FAR *phUser);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelTask )( 
            _IWmiArbitrator __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ _IWmiCoreHandle __RPC_FAR *phTtask);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterThreadForTask )( 
            _IWmiArbitrator __RPC_FAR * This,
            /* [in] */ _IWmiCoreHandle __RPC_FAR *phTask);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnregisterThreadForTask )( 
            _IWmiArbitrator __RPC_FAR * This,
            /* [in] */ _IWmiCoreHandle __RPC_FAR *phTask);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Maintenance )( 
            _IWmiArbitrator __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterNamespace )( 
            _IWmiArbitrator __RPC_FAR * This,
            /* [in] */ _IWmiCoreHandle __RPC_FAR *phNamespace);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnregisterNamespace )( 
            _IWmiArbitrator __RPC_FAR * This,
            /* [in] */ _IWmiCoreHandle __RPC_FAR *phNamespace);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReportMemoryUsage )( 
            _IWmiArbitrator __RPC_FAR * This,
            /* [in] */ LONG uBackLog,
            /* [in] */ _IWmiCoreHandle __RPC_FAR *phTask);
        
        END_INTERFACE
    } _IWmiArbitratorVtbl;

    interface _IWmiArbitrator
    {
        CONST_VTBL struct _IWmiArbitratorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _IWmiArbitrator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _IWmiArbitrator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _IWmiArbitrator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _IWmiArbitrator_RegisterTask(This,phTask)	\
    (This)->lpVtbl -> RegisterTask(This,phTask)

#define _IWmiArbitrator_UnregisterTask(This,phTask)	\
    (This)->lpVtbl -> UnregisterTask(This,phTask)

#define _IWmiArbitrator_RegisterUser(This,phUser)	\
    (This)->lpVtbl -> RegisterUser(This,phUser)

#define _IWmiArbitrator_UnregisterUser(This,phUser)	\
    (This)->lpVtbl -> UnregisterUser(This,phUser)

#define _IWmiArbitrator_CheckTask(This,uFlags,phTask)	\
    (This)->lpVtbl -> CheckTask(This,uFlags,phTask)

#define _IWmiArbitrator_TaskStateChange(This,uNewState,phTask)	\
    (This)->lpVtbl -> TaskStateChange(This,uNewState,phTask)

#define _IWmiArbitrator_CancelTasksBySink(This,uFlags,riid,pSink)	\
    (This)->lpVtbl -> CancelTasksBySink(This,uFlags,riid,pSink)

#define _IWmiArbitrator_CheckThread(This,uFlags)	\
    (This)->lpVtbl -> CheckThread(This,uFlags)

#define _IWmiArbitrator_CheckUser(This,uFlags,phUser)	\
    (This)->lpVtbl -> CheckUser(This,uFlags,phUser)

#define _IWmiArbitrator_CancelTask(This,uFlags,phTtask)	\
    (This)->lpVtbl -> CancelTask(This,uFlags,phTtask)

#define _IWmiArbitrator_RegisterThreadForTask(This,phTask)	\
    (This)->lpVtbl -> RegisterThreadForTask(This,phTask)

#define _IWmiArbitrator_UnregisterThreadForTask(This,phTask)	\
    (This)->lpVtbl -> UnregisterThreadForTask(This,phTask)

#define _IWmiArbitrator_Maintenance(This)	\
    (This)->lpVtbl -> Maintenance(This)

#define _IWmiArbitrator_RegisterNamespace(This,phNamespace)	\
    (This)->lpVtbl -> RegisterNamespace(This,phNamespace)

#define _IWmiArbitrator_UnregisterNamespace(This,phNamespace)	\
    (This)->lpVtbl -> UnregisterNamespace(This,phNamespace)

#define _IWmiArbitrator_ReportMemoryUsage(This,uBackLog,phTask)	\
    (This)->lpVtbl -> ReportMemoryUsage(This,uBackLog,phTask)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE _IWmiArbitrator_RegisterTask_Proxy( 
    _IWmiArbitrator __RPC_FAR * This,
    /* [in] */ _IWmiCoreHandle __RPC_FAR *__RPC_FAR *phTask);


void __RPC_STUB _IWmiArbitrator_RegisterTask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE _IWmiArbitrator_UnregisterTask_Proxy( 
    _IWmiArbitrator __RPC_FAR * This,
    /* [in] */ _IWmiCoreHandle __RPC_FAR *phTask);


void __RPC_STUB _IWmiArbitrator_UnregisterTask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE _IWmiArbitrator_RegisterUser_Proxy( 
    _IWmiArbitrator __RPC_FAR * This,
    /* [in] */ _IWmiCoreHandle __RPC_FAR *phUser);


void __RPC_STUB _IWmiArbitrator_RegisterUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE _IWmiArbitrator_UnregisterUser_Proxy( 
    _IWmiArbitrator __RPC_FAR * This,
    /* [in] */ _IWmiCoreHandle __RPC_FAR *phUser);


void __RPC_STUB _IWmiArbitrator_UnregisterUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE _IWmiArbitrator_CheckTask_Proxy( 
    _IWmiArbitrator __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [in] */ _IWmiCoreHandle __RPC_FAR *phTask);


void __RPC_STUB _IWmiArbitrator_CheckTask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE _IWmiArbitrator_TaskStateChange_Proxy( 
    _IWmiArbitrator __RPC_FAR * This,
    /* [in] */ ULONG uNewState,
    /* [in] */ _IWmiCoreHandle __RPC_FAR *phTask);


void __RPC_STUB _IWmiArbitrator_TaskStateChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE _IWmiArbitrator_CancelTasksBySink_Proxy( 
    _IWmiArbitrator __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [in] */ REFIID riid,
    /* [iid_is][in] */ LPVOID pSink);


void __RPC_STUB _IWmiArbitrator_CancelTasksBySink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE _IWmiArbitrator_CheckThread_Proxy( 
    _IWmiArbitrator __RPC_FAR * This,
    /* [in] */ ULONG uFlags);


void __RPC_STUB _IWmiArbitrator_CheckThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE _IWmiArbitrator_CheckUser_Proxy( 
    _IWmiArbitrator __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [in] */ _IWmiUserHandle __RPC_FAR *phUser);


void __RPC_STUB _IWmiArbitrator_CheckUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE _IWmiArbitrator_CancelTask_Proxy( 
    _IWmiArbitrator __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [in] */ _IWmiCoreHandle __RPC_FAR *phTtask);


void __RPC_STUB _IWmiArbitrator_CancelTask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE _IWmiArbitrator_RegisterThreadForTask_Proxy( 
    _IWmiArbitrator __RPC_FAR * This,
    /* [in] */ _IWmiCoreHandle __RPC_FAR *phTask);


void __RPC_STUB _IWmiArbitrator_RegisterThreadForTask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE _IWmiArbitrator_UnregisterThreadForTask_Proxy( 
    _IWmiArbitrator __RPC_FAR * This,
    /* [in] */ _IWmiCoreHandle __RPC_FAR *phTask);


void __RPC_STUB _IWmiArbitrator_UnregisterThreadForTask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE _IWmiArbitrator_Maintenance_Proxy( 
    _IWmiArbitrator __RPC_FAR * This);


void __RPC_STUB _IWmiArbitrator_Maintenance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE _IWmiArbitrator_RegisterNamespace_Proxy( 
    _IWmiArbitrator __RPC_FAR * This,
    /* [in] */ _IWmiCoreHandle __RPC_FAR *phNamespace);


void __RPC_STUB _IWmiArbitrator_RegisterNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE _IWmiArbitrator_UnregisterNamespace_Proxy( 
    _IWmiArbitrator __RPC_FAR * This,
    /* [in] */ _IWmiCoreHandle __RPC_FAR *phNamespace);


void __RPC_STUB _IWmiArbitrator_UnregisterNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE _IWmiArbitrator_ReportMemoryUsage_Proxy( 
    _IWmiArbitrator __RPC_FAR * This,
    /* [in] */ LONG uBackLog,
    /* [in] */ _IWmiCoreHandle __RPC_FAR *phTask);


void __RPC_STUB _IWmiArbitrator_ReportMemoryUsage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* ___IWmiArbitrator_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_arbitrator_0211 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum tag_ARBSTATUS
    {	ARB_NO_ERROR	= 0,
	ARB_S_NO_ERROR	= 0,
	ARB_E_FAILED	= 0x80041001,
	ARB_E_CANCELLED_TASK	= 0x80041002,
	ARB_E_CANCELLED_TASK_MAX_SLEEP	= 0x80041003
    }	ARBSTATUS;

typedef /* [v1_enum] */ 
enum tag_TASKSTATUS
    {	TASK_RUNNING	= 0,
	TASK_SLEEPING	= 1,
	TASK_COMPLETED	= 2,
	TASK_CANCELLED	= 3
    }	TASKSTATUS;



extern RPC_IF_HANDLE __MIDL_itf_arbitrator_0211_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_arbitrator_0211_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\arbitrator\arbitrate.cpp ===
// Arbitrate.cpp: implementation of the CArbitrate class.
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "Arbitrate.h"
#include "reg.h"

#include "Arbitrator.h"




//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CArbitrate::CArbitrate() : m_lCount ( 0 )
{

    m_uTotalTasks = 0;
	m_uTotalMemoryUsage = 0;
	m_lMultiplierTasks = 0;

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Initialize the task array
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	for ( LONG x = 0; x<MAX_TASK_THRESHOLD; x++ )
	{
		m_taskArray[x] = NULL;
	}

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Initialize critical sections
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    InitializeCriticalSection(&m_csTask);
    InitializeCriticalSection(&m_csNamespace);
    InitializeCriticalSection(&m_fileCS);

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// For the time being, read the high from registry
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	m_uSystemHigh = ARB_DEFAULT_SYSTEM_HIGH;

	Registry batchSize (HKEY_LOCAL_MACHINE, KEY_QUERY_VALUE, REGKEY_CIMOM);
	if ( batchSize.GetLastError() == ERROR_SUCCESS )
	{
		DWORD dwTmp;
		batchSize.GetDWORD ( REGVALUE_SYSHIGH, &dwTmp );
		if ( batchSize.GetLastError() == ERROR_SUCCESS )
			m_uSystemHigh = (LONG) dwTmp;
	}
	m_uFloatingLow = m_uSystemHigh;


	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Get the max sleep time from the registry
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	m_lMaxSleepTime = ARB_DEFAULT_MAX_SLEEP_TIME;
	Registry batchSize2 (HKEY_LOCAL_MACHINE, KEY_QUERY_VALUE, REGKEY_CIMOM);
	if ( batchSize.GetLastError() == ERROR_SUCCESS )
	{
		DWORD dwTmp;
		batchSize.GetDWORD ( REGVALUE_MAXSLEEP, &dwTmp );
		if ( batchSize.GetLastError() == ERROR_SUCCESS )
			m_lMaxSleepTime = (LONG) dwTmp;
	}

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Get the high threshold 1
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	m_dThreshold1 = ARB_DEFAULT_HIGH_THRESHOLD1 /(double)  100;
	Registry batchSize3 (HKEY_LOCAL_MACHINE, KEY_QUERY_VALUE, REGKEY_CIMOM);
	if ( batchSize.GetLastError() == ERROR_SUCCESS )
	{
		DWORD dwTmp;
		batchSize.GetDWORD ( REGVALUE_HT1, &dwTmp );
		if ( batchSize.GetLastError() == ERROR_SUCCESS )
			m_dThreshold1 = dwTmp / (double) 100;
	}

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Get the high threshold 1 multiplier
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	m_lThreshold1Mult = ARB_DEFAULT_HIGH_THRESHOLD1MULT;
	Registry batchSize4 (HKEY_LOCAL_MACHINE, KEY_QUERY_VALUE, REGKEY_CIMOM);
	if ( batchSize.GetLastError() == ERROR_SUCCESS )
	{
		DWORD dwTmp;
		batchSize.GetDWORD ( REGVALUE_HT1M, &dwTmp );
		if ( batchSize.GetLastError() == ERROR_SUCCESS )
			m_lThreshold1Mult = dwTmp;
	}
	
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Get the high threshold 2
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	m_dThreshold2 = ARB_DEFAULT_HIGH_THRESHOLD2 /(double)  100;
	Registry batchSize5 (HKEY_LOCAL_MACHINE, KEY_QUERY_VALUE, REGKEY_CIMOM);
	if ( batchSize.GetLastError() == ERROR_SUCCESS )
	{
		DWORD dwTmp;
		batchSize.GetDWORD ( REGVALUE_HT2, &dwTmp );
		if ( batchSize.GetLastError() == ERROR_SUCCESS )
			m_dThreshold2 = dwTmp / (double) 100;
	}

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Get the high threshold 2 multiplier
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	m_lThreshold2Mult = ARB_DEFAULT_HIGH_THRESHOLD2MULT ;
	Registry batchSize6 (HKEY_LOCAL_MACHINE, KEY_QUERY_VALUE, REGKEY_CIMOM);
	if ( batchSize.GetLastError() == ERROR_SUCCESS )
	{
		DWORD dwTmp;
		batchSize.GetDWORD ( REGVALUE_HT2M, &dwTmp );
		if ( batchSize.GetLastError() == ERROR_SUCCESS )
			m_lThreshold2Mult = dwTmp;
	}

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Get the high threshold 3
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	m_dThreshold3 = ARB_DEFAULT_HIGH_THRESHOLD3 /(double)  100;
	Registry batchSize7 (HKEY_LOCAL_MACHINE, KEY_QUERY_VALUE, REGKEY_CIMOM);
	if ( batchSize.GetLastError() == ERROR_SUCCESS )
	{
		DWORD dwTmp;
		batchSize.GetDWORD ( REGVALUE_HT3, &dwTmp );
		if ( batchSize.GetLastError() == ERROR_SUCCESS )
			m_dThreshold3 = dwTmp / (double) 100;
	}


	
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Get the high threshold 3 multiplier
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	m_lThreshold3Mult = ARB_DEFAULT_HIGH_THRESHOLD3MULT;
	Registry batchSize8 (HKEY_LOCAL_MACHINE, KEY_QUERY_VALUE, REGKEY_CIMOM);
	if ( batchSize.GetLastError() == ERROR_SUCCESS )
	{
		DWORD dwTmp;
		batchSize.GetDWORD ( REGVALUE_HT3M, &dwTmp );
		if ( batchSize.GetLastError() == ERROR_SUCCESS )
			m_lThreshold3Mult = dwTmp;
	}

	
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Calculate the base multiplier
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	m_lMultiplier = ( ARB_DEFAULT_MAX_SLEEP_TIME / (double) m_uSystemHigh ) ;

}

CArbitrate::~CArbitrate()
{
    DeleteCriticalSection(&m_csTask);
    DeleteCriticalSection(&m_csNamespace);
	DeleteCriticalSection(&m_fileCS);
}




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
HRESULT STDMETHODCALLTYPE CArbitrate::QueryInterface ( REFIID refiid, LPVOID* pObj )
{
	HRESULT hRes = NOERROR;

	if ( refiid == IID_IUnknown )
	{
		*pObj = (IUnknown*) this;
	}
	else if ( refiid == IID__IWmiArbitrator )
	{
		*pObj = (_IWmiArbitrator*) this;
	}
	else
	{
		*pObj = NULL;
		hRes = E_NOINTERFACE;
	}

	if ( pObj )
	{
		AddRef ( );
	}

	return hRes;
}



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ULONG STDMETHODCALLTYPE CArbitrate::AddRef ( )
{
	return InterlockedIncrement ( &m_lCount );
}



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ULONG STDMETHODCALLTYPE CArbitrate::Release ( )
{
	ULONG tmpCount = InterlockedDecrement ( &m_lCount );
	if ( tmpCount == 0 )
	{
		delete this;
	}
	return tmpCount;
}


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
HRESULT STDMETHODCALLTYPE CArbitrate::RegisterTask( _IWmiCoreHandle **phTask )
{
	HRESULT hRes = NOERROR;

	*phTask = NULL;

	EnterCriticalSection ( &m_csTask );
	for ( LONG x = 0; x<MAX_TASK_THRESHOLD; x++ )
	{
		if ( m_taskArray [ x ] == NULL )
		{
			m_taskArray [ x ] = new CTask;
			m_taskArray [ x ] -> AddRef ( );
			*phTask = m_taskArray [ x ];
			(*phTask)->AddRef ();
			m_uTotalTasks++;
			
			EnterCriticalSection ( &m_fileCS );
			m_lMultiplierTasks = ( m_uTotalTasks / (DOUBLE) 100 ) + 1;
			FILE* logFile = fopen ( "arb.log", "a" );
			fprintf (logFile, "New task registration success: %X\n", phTask );
			fclose (logFile);
			LeaveCriticalSection( &m_fileCS );

			(*phTask)->UpdateTaskStatus ( TASK_RUNNING );
			break;
		}
	}
	LeaveCriticalSection ( &m_csTask );

	if ( phTask == NULL )
	{
		hRes = E_FAIL;
		EnterCriticalSection ( &m_fileCS );
		FILE* logFile = fopen ( "arb.log", "a" );
		fprintf (logFile, "New task registration fail. Reached limit: %X\n", MAX_TASK_THRESHOLD );
		fclose (logFile);
		LeaveCriticalSection( &m_fileCS );
	}
	return hRes;
}


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
HRESULT STDMETHODCALLTYPE CArbitrate::UnregisterTask ( _IWmiCoreHandle *phTask )
{
	HRESULT hRes = NOERROR;

	EnterCriticalSection ( &m_csTask );
	for ( LONG x = 0; x<MAX_TASK_THRESHOLD; x++ )
	{
		if ( m_taskArray [ x ] == phTask )
		{
			ULONG memUsage;
			m_taskArray [ x ] -> GetMemoryUsage ( &memUsage );
			m_uTotalMemoryUsage -= memUsage;
			m_uFloatingLow += memUsage;

			EnterCriticalSection ( &m_fileCS );
			FILE* logFile = fopen ( "arb.log", "a" );
			fprintf (logFile, "New task unregistered successfully: %X\n", phTask );
			fclose (logFile);
			LeaveCriticalSection( &m_fileCS );

			m_taskArray [ x ] -> UpdateTaskStatus ( TASK_COMPLETED );
			m_taskArray [ x ] -> Release ( );
			m_taskArray [ x ] = NULL;
			
			m_uTotalTasks--;
			
			m_lMultiplierTasks = m_uTotalTasks / (DOUBLE) 100;

			break;
		}
	}
	LeaveCriticalSection ( &m_csTask );

	return hRes;
}



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
HRESULT STDMETHODCALLTYPE CArbitrate::CancelTask ( ULONG uFlags, _IWmiCoreHandle *phTask )								
{
	HRESULT hRes = NOERROR;
		
	EnterCriticalSection ( &m_csTask );
	for ( LONG x = 0; x<MAX_TASK_THRESHOLD; x++ )
	{
		if ( m_taskArray [ x ] == phTask )
		{
			ULONG memUsage;
			m_taskArray [ x ] -> GetMemoryUsage ( &memUsage );
			m_uTotalMemoryUsage -= memUsage;
			m_uFloatingLow += memUsage;

			m_taskArray [ x ] -> UpdateTaskStatus ( TASK_CANCELLED );

			m_taskArray [ x ] -> Release ( );
			m_taskArray [ x ] = NULL;

			m_uTotalTasks--;
			m_lMultiplierTasks = ( m_uTotalTasks / (DOUBLE) 100 ) + 1;
			break;

		}
	}
	LeaveCriticalSection ( &m_csTask );
	
	return hRes;
}


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
HRESULT STDMETHODCALLTYPE CArbitrate::ReportMemoryUsage ( LONG lDelta, _IWmiCoreHandle *phTask )
{
	HRESULT hRes = NOERROR;

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// First thing we do is check if we're pushed over the limit.
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if ( ( m_uTotalMemoryUsage + lDelta ) > m_uSystemHigh )
	{
		CancelTask ( 0, phTask );
		hRes = ARB_E_CANCELLED_TASK;

		EnterCriticalSection ( &m_fileCS );
		FILE* logFile = fopen ( "arb.log", "a" );
		fprintf ( logFile, "Task %X was cancelled due to reaching system high\n", phTask );
		fclose (logFile);
		LeaveCriticalSection( &m_fileCS );
	}

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Next, we update all applicable counters
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	else
	{
		m_uTotalMemoryUsage += lDelta;
		phTask->UpdateMemoryUsage ( lDelta );
		if ( ( m_uFloatingLow - lDelta ) >= 0 )
			m_uFloatingLow -= lDelta;
	}
	

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// If the delta is > 0, we need to consider to arbitrate
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if ( lDelta > 0 )
	{
		LONG lMultiplierHigh = 1;
		ULONG memUsage;
		ULONG sleepTime;
		phTask->GetMemoryUsage ( &memUsage );
		phTask->GetTotalSleepTime ( &sleepTime );
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Did we reach the arbitration point?
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		if ( memUsage > m_uFloatingLow )
		{
			if ( ( sleepTime < m_lMaxSleepTime ) || ( m_lMaxSleepTime == 0 ) )
			{
				if ( memUsage >= (m_uSystemHigh * m_dThreshold3) )
				{
					lMultiplierHigh = m_lThreshold3Mult;
				}
				else if ( memUsage >= (m_uSystemHigh * m_dThreshold2) )
				{
					lMultiplierHigh = m_lThreshold2Mult;
				}
				else if ( memUsage >= (m_uSystemHigh * m_dThreshold1) )
				{
					lMultiplierHigh = m_lThreshold1Mult;
				}

					
				ULONG ulSleepTime = (ULONG) ( ( memUsage - m_uFloatingLow ) * m_lMultiplier * m_lMultiplierTasks * lMultiplierHigh );
						
				EnterCriticalSection ( &m_fileCS );
				FILE* logFile = fopen ( "arb.log", "a" );
				fprintf ( logFile, "Task %X reported memory usage [%X] and was arbitrated %X ms\n", phTask, lDelta, ulSleepTime );
				fclose (logFile);
				LeaveCriticalSection( &m_fileCS );

				phTask->UpdateTotalSleepTime ( ulSleepTime );
				phTask->UpdateTaskStatus ( TASK_SLEEPING );
				Sleep ( ulSleepTime );
				phTask->UpdateTaskStatus ( TASK_RUNNING );
			}
			else
			{
				CancelTask ( 0, phTask );
				hRes = ARB_E_CANCELLED_TASK_MAX_SLEEP;

				EnterCriticalSection ( &m_fileCS );
				FILE* logFile = fopen ( "arb.log", "a" );
				fprintf ( logFile, "Task %X was cancelled due to sleeping too much: %d\n", phTask, sleepTime );
				fclose (logFile);
				LeaveCriticalSection( &m_fileCS );
			}
		}
		else
		{
			EnterCriticalSection ( &m_fileCS );
			FILE* logFile = fopen ( "arb.log", "a" );
			fprintf ( logFile, "Task %X reported memory usage [%X] but was not arbitrated\n", phTask, lDelta );
			fclose (logFile);
			LeaveCriticalSection( &m_fileCS );

		}
	}
	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\arbitrator\arbitrator_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Wed Nov 29 20:38:43 2000
 */
/* Compiler settings for E:\WorkZone\Code\Arbitrator\arbitrator.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID__IWmiCoreHandle = {0xac062f20,0x9935,0x4aae,{0x98,0xeb,0x05,0x32,0xfb,0x17,0x14,0x7a}};


const IID IID__IWmiUserHandle = {0x6d8d984b,0x9965,0x4023,{0x92,0x1a,0x61,0x0b,0x34,0x8e,0xe5,0x4e}};


const IID IID__IWmiArbitrator = {0x67429ED7,0xF52F,0x4773,{0xB9,0xBB,0x30,0x30,0x2B,0x02,0x70,0xDE}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\arbitrator\arbitrate.h ===
#include "arbitrator.h"
#include <stdio.h>
#include <windows.h>

#include "task.h"


#define MAX_TASK_THRESHOLD			500


// REGISTRY SETTABLE DEFAULTS
#define ARB_DEFAULT_SYSTEM_HIGH			0x4c4b400			// System limits [80megs]
#define ARB_DEFAULT_MAX_SLEEP_TIME		300000				// Default max sleep time for each task
#define ARB_DEFAULT_HIGH_THRESHOLD1		90					// High threshold 1
#define ARB_DEFAULT_HIGH_THRESHOLD1MULT 2					// High threshold 1 multiplier
#define ARB_DEFAULT_HIGH_THRESHOLD2		95					// High threshold 1
#define ARB_DEFAULT_HIGH_THRESHOLD2MULT 3					// High threshold 1 multiplier
#define ARB_DEFAULT_HIGH_THRESHOLD3		98					// High threshold 1
#define ARB_DEFAULT_HIGH_THRESHOLD3MULT 4					// High threshold 1 multiplier



#define	REGKEY_CIMOM		"Software\\Microsoft\\Wbem\\CIMOM"
#define REGVALUE_SYSHIGH	"ArbSystemHighMaxLimit"
#define REGVALUE_MAXSLEEP	"ArbTaskMaxSleep"
#define REGVALUE_HT1		"ArbSystemHighThreshold1"
#define REGVALUE_HT1M		"ArbSystemHighThreshold1Mult"
#define REGVALUE_HT2		"ArbSystemHighThreshold2"
#define REGVALUE_HT2M		"ArbSystemHighThreshold2Mult"
#define REGVALUE_HT3		"ArbSystemHighThreshold3"
#define REGVALUE_HT3M		"ArbSystemHighThreshold3Mult"





class CArbitrate : public _IWmiArbitrator
{
public:
	CArbitrate();
	virtual ~CArbitrate();

public:
	HRESULT STDMETHODCALLTYPE QueryInterface ( REFIID, LPVOID* );
	ULONG STDMETHODCALLTYPE AddRef ( );
	ULONG STDMETHODCALLTYPE Release ( );
    
	
	HRESULT STDMETHODCALLTYPE RegisterTask(
        _IWmiCoreHandle **phTask
        ); 

    HRESULT STDMETHODCALLTYPE UnregisterTask(
        _IWmiCoreHandle *phTask
        );

    HRESULT STDMETHODCALLTYPE RegisterUser(
        _IWmiCoreHandle *phUser
        )								{ return 1; }

    HRESULT STDMETHODCALLTYPE UnregisterUser(
        _IWmiCoreHandle *phUser
        )								{ return 1; }

    HRESULT STDMETHODCALLTYPE CheckTask(
        ULONG uFlags,
        _IWmiCoreHandle *phTask
        )								{ return 1; }

    HRESULT STDMETHODCALLTYPE TaskStateChange(
        ULONG uNewState,               // Duplicate of the state in the task handle itself
        _IWmiCoreHandle *phTask
        )								{ return 1; }

    HRESULT STDMETHODCALLTYPE CancelTasksBySink(
        ULONG uFlags,
        REFIID riid,
        LPVOID pSink        // IWbemObjectSink or IWbemObjectSinkEx
        )								{ return 1; }

    HRESULT STDMETHODCALLTYPE CheckThread(
        ULONG uFlags
        )								{ return 1; }

    HRESULT STDMETHODCALLTYPE CheckUser(
        ULONG uFlags,
        _IWmiUserHandle *phUser
        )								{ return 1; }

    HRESULT STDMETHODCALLTYPE CancelTask(
        ULONG uFlags,
        _IWmiCoreHandle *phTtask
        );

    HRESULT STDMETHODCALLTYPE RegisterThreadForTask(
        _IWmiCoreHandle *phTask
        )								{ return 1; }

    HRESULT STDMETHODCALLTYPE UnregisterThreadForTask(
        _IWmiCoreHandle *phTask
        )								{ return 1; }

    HRESULT STDMETHODCALLTYPE Maintenance()				{ return 1; }

    //HRESULT RegisterFinalizer(
    //    [in] ULONG uFlags,
    //    [in] _IWmiCoreHandle *phTask,
    //    [in] _IWmiFinalizer *pFinal
    //    );

    HRESULT STDMETHODCALLTYPE RegisterNamespace(
        _IWmiCoreHandle *phNamespace
        )	{ return 1;}

    HRESULT STDMETHODCALLTYPE UnregisterNamespace(
        _IWmiCoreHandle *phNamespace
        )   {return 1;}

    HRESULT STDMETHODCALLTYPE ReportMemoryUsage (
        LONG lDelta,
        _IWmiCoreHandle *phTask
        );


private:
	LONG	m_lCount;
    ULONG	m_uTotalTasks;
	ULONG	m_uTotalMemoryUsage;
	ULONG	m_uFloatingLow;

	ULONG	m_uSystemHigh;
	DOUBLE	m_lMultiplier;
	DOUBLE	m_lMultiplierTasks;
	ULONG	m_lMaxSleepTime;

	DOUBLE	m_dThreshold1;
	LONG    m_lThreshold1Mult;

	DOUBLE	m_dThreshold2;
	LONG    m_lThreshold2Mult;

	DOUBLE	m_dThreshold3;
	LONG    m_lThreshold3Mult;

    CRITICAL_SECTION m_csTask;
	CRITICAL_SECTION m_csNamespace;
	CRITICAL_SECTION m_fileCS;
	
	CTask*				m_taskArray [MAX_TASK_THRESHOLD];

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\arbitrator\arbitrator_p.c ===
/* this ALWAYS GENERATED file contains the proxy stub code */


/* File created by MIDL compiler version 5.01.0164 */
/* at Wed Nov 29 20:38:43 2000
 */
/* Compiler settings for E:\WorkZone\Code\Arbitrator\arbitrator.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "arbitrator.h"

#define TYPE_FORMAT_STRING_SIZE   3                                 
#define PROC_FORMAT_STRING_SIZE   1                                 

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: _IWmiCoreHandle, ver. 0.0,
   GUID={0xac062f20,0x9935,0x4aae,{0x98,0xeb,0x05,0x32,0xfb,0x17,0x14,0x7a}} */


/* Object interface: _IWmiUserHandle, ver. 0.0,
   GUID={0x6d8d984b,0x9965,0x4023,{0x92,0x1a,0x61,0x0b,0x34,0x8e,0xe5,0x4e}} */


/* Object interface: _IWmiArbitrator, ver. 0.0,
   GUID={0x67429ED7,0xF52F,0x4773,{0xB9,0xBB,0x30,0x30,0x2B,0x02,0x70,0xDE}} */


/* Standard interface: __MIDL_itf_arbitrator_0211, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */

#pragma data_seg(".rdata")

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */

			0x0
        }
    };

const CInterfaceProxyVtbl * _arbitrator_ProxyVtblList[] = 
{
    0
};

const CInterfaceStubVtbl * _arbitrator_StubVtblList[] = 
{
    0
};

PCInterfaceName const _arbitrator_InterfaceNamesList[] = 
{
    0
};


#define _arbitrator_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _arbitrator, pIID, n)

int __stdcall _arbitrator_IID_Lookup( const IID * pIID, int * pIndex )
{
    return 0;
}

const ExtendedProxyFileInfo arbitrator_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _arbitrator_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _arbitrator_StubVtblList,
    (const PCInterfaceName * ) & _arbitrator_InterfaceNamesList,
    0, // no delegation
    & _arbitrator_IID_Lookup, 
    0,
    1,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\arbitrator\classfac.h ===
class CFactory : public IClassFactory
    {
    protected:
        ULONG           m_cRef;

    public:
        CFactory(void);
        ~CFactory(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, void**);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID
                                 , void**);
        STDMETHODIMP         LockServer(BOOL);
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\arbitrator\classfac.cpp ===
//***************************************************************************
//
//  CLASSFAC.CPP
//
//  Module: WMI Instance provider sample code
//
//  Purpose: Contains the class factory.  This creates objects when
//           connections are requested.
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//***************************************************************************

#include "precomp.h"
#include <objbase.h>
#include "classfac.h"
#include "arbitrate.h"

extern LONG g_cLock;

//***************************************************************************
//
// CFactory::CFactory
// CFactory::~CFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CFactory::CFactory()
{
    m_cRef=0L;
    return;
}

CFactory::~CFactory(void)
{
    return;
}

//***************************************************************************
//
// CFactory::QueryInterface
// CFactory::AddRef
// CFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CFactory::QueryInterface(REFIID riid, void** ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CFactory::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CFactory::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

//***************************************************************************
//
// CFactory::CreateInstance
//
// Purpose: Instantiates a Locator object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj)
{
    CArbitrate *   pObj;
    HRESULT hr;

    *ppvObj=NULL;

    // This object doesnt support aggregation.

    if (NULL!=pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    // Create the locator object.
    
    pObj=new CArbitrate();
    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.

    if (FAILED(hr))
        delete pObj;
    return hr;
}

//***************************************************************************
//
// CFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\arbitrator\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>

#define COREPOL_HEADERFILE_IS_INCLUDED

#define COREPROX_POLARITY __declspec( dllimport )
#define ESSLIB_POLARITY __declspec( dllimport )

#define COREPOL_HEADERFILE_IS_INCLUDED
#define POLARITY_HEADERFILE_IS_INCLUDED
#define POLARITY __declspec( dllimport )

#include "arena.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\arbsim\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>

#define COREPOL_HEADERFILE_IS_INCLUDED

#define COREPROX_POLARITY __declspec( dllimport )
#define ESSLIB_POLARITY __declspec( dllimport )

#define COREPOL_HEADERFILE_IS_INCLUDED
#define POLARITY_HEADERFILE_IS_INCLUDED
#define POLARITY __declspec( dllimport )

#include "arena.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\arbitrator\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/


#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( arbitrator )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( arbitrator ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\arbitrator\reg.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    REG.CPP

Abstract:

  Utility Registry classes

History:

  raymcc    30-May-96   Created.
  raymcc    26-Jul-99   Updated for TCHAR.

--*/

#include "precomp.h"
#include <stdio.h>
#include "reg.h"
#include <tchar.h>
#include <malloc.h>

//***************************************************************************
//
//***************************************************************************
// ok
int Registry::Open(HKEY hStart, TCHAR *pszStartKey)
{
    int nStatus = no_error;
    DWORD dwDisp = 0;

    m_nLastError = RegCreateKeyEx(hStart, pszStartKey,
                                    0, 0, 0,
                                    KEY_ALL_ACCESS, 0, &hPrimaryKey, &dwDisp);

    if (m_nLastError != 0)
            nStatus = failed;

    return nStatus;
}

//***************************************************************************
//
//***************************************************************************
// ok
Registry::Registry(HKEY hRoot, REGSAM flags, TCHAR *pszStartKey)
{
    hPrimaryKey = 0;
    hSubkey = 0;
    nStatus = RegOpenKeyEx(hRoot, pszStartKey,
                        0, flags, &hPrimaryKey
                        );
    hSubkey = hPrimaryKey;
    m_nLastError = nStatus;
}

//***************************************************************************
//
//***************************************************************************
// ok
Registry::Registry(HKEY hRoot, DWORD dwOptions, REGSAM flags, TCHAR *pszStartKey)
{
    hPrimaryKey = 0;
    hSubkey = 0;

    int nStatus = no_error;
    DWORD dwDisp = 0;

    m_nLastError = RegCreateKeyEx(hRoot, pszStartKey,
                                    0, 0, dwOptions,
                                    flags, 0, &hPrimaryKey, &dwDisp
                                    );

    hSubkey = hPrimaryKey;
}


//***************************************************************************
//
//***************************************************************************
// ok
Registry::Registry(TCHAR *pszLocalMachineStartKey)
{
    hPrimaryKey = 0;
    hSubkey = 0;
    nStatus = Open(HKEY_LOCAL_MACHINE, pszLocalMachineStartKey);
    hSubkey = hPrimaryKey;
}

//***************************************************************************
//
//***************************************************************************
// ok
Registry::Registry()
{
    hPrimaryKey = 0;
    hSubkey = 0;
    nStatus = 0;
    hSubkey = 0;
}

//***************************************************************************
//
//***************************************************************************
// ok
Registry::~Registry()
{
    if (hSubkey)
        RegCloseKey(hSubkey);
    if (hPrimaryKey != hSubkey)
        RegCloseKey(hPrimaryKey);
}

//***************************************************************************
//
//***************************************************************************
// ok
int Registry::MoveToSubkey(TCHAR *pszNewSubkey)
{
    DWORD dwDisp = 0;
    m_nLastError = RegCreateKeyEx(hPrimaryKey, pszNewSubkey, 0, 0, 0, KEY_ALL_ACCESS,
                                    0, &hSubkey, &dwDisp);
    if (m_nLastError != 0)
            return failed;
    return no_error;
}

//***************************************************************************
//
//***************************************************************************
// ok
int Registry::GetDWORD(TCHAR *pszValueName, DWORD *pdwValue)
{
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = 0;

    if(hSubkey == NULL)
        return failed;

    m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, &dwType,
                                LPBYTE(pdwValue), &dwSize);
    if (m_nLastError != 0)
            return failed;

    if (dwType != REG_DWORD)
        return failed;

    return no_error;
}

//***************************************************************************
//
//***************************************************************************
// ok
int Registry::GetType(TCHAR *pszValueName, DWORD *pdwType)
{
    if(hSubkey == NULL)
        return failed;

    m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, pdwType,
                                NULL, NULL);
    if (m_nLastError != 0)
            return failed;
    return no_error;
}
//***************************************************************************
//
//***************************************************************************
// ok
int Registry::GetDWORDStr(TCHAR *pszValueName, DWORD *pdwValue)
{
    TCHAR cTemp[25];
    DWORD dwSize = 25;
    DWORD dwType = 0;

    if(hSubkey == NULL)
        return failed;

    m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, &dwType,
        (LPBYTE)cTemp, &dwSize);

    if (m_nLastError != 0)
            return failed;

    if (dwType != REG_SZ)
        return failed;

    if(1 == _stscanf(cTemp, __TEXT("%d"), pdwValue))
        return no_error;
    else
        return failed;

}


//***************************************************************************
//
//  Use operator delete on the returned pointer!!
//
//***************************************************************************
// ok

int Registry::GetBinary(TCHAR *pszValue, byte ** pData, DWORD * pdwSize)
{
    *pData = 0;
    DWORD dwSize = 0;
    DWORD dwType = 0;
    if(m_nLastError)
        return failed;

    m_nLastError = RegQueryValueEx(hSubkey, pszValue, 0, &dwType,
                                    0, &dwSize);
    if (m_nLastError != 0)
            return failed;

    if (dwType != REG_BINARY)
        return failed;

    byte *p = new byte[dwSize];
    if (p == NULL)
        return failed;

    m_nLastError = RegQueryValueEx(hSubkey, pszValue, 0, &dwType,
                                    LPBYTE(p), &dwSize);
    if (m_nLastError != 0)
    {
        delete [] p;
        return failed;
    }

    *pdwSize = dwSize;
    *pData = p;
    return no_error;
}

//***************************************************************************
//
//***************************************************************************
// ok
int Registry::SetBinary(TCHAR *pszValue, byte * pData, DWORD dwSize)
{
    if(m_nLastError)
        return failed;
    m_nLastError = RegSetValueEx(hSubkey, pszValue, 0, REG_BINARY, pData, dwSize);

    if (m_nLastError != 0)
        return failed;
    return no_error;
}

//***************************************************************************
//
//***************************************************************************
// ok
int Registry::SetDWORD(TCHAR *pszValueName, DWORD dwValue)
{
    if(hSubkey == NULL)
        return failed;

    m_nLastError = RegSetValueEx(hSubkey, pszValueName, 0, REG_DWORD, LPBYTE(&dwValue),
                                    sizeof(DWORD));
    if (m_nLastError != 0)
        return failed;
    return no_error;
}

//***************************************************************************
//
//***************************************************************************
// ok

int Registry::SetDWORDStr(TCHAR *pszValueName, DWORD dwVal)
{
    TCHAR cTemp[30];
    _stprintf(cTemp,__TEXT("%d"),dwVal);

    if(hSubkey == NULL)
        return failed;

    m_nLastError = RegSetValueEx(hSubkey, pszValueName, 0, REG_SZ, LPBYTE(cTemp),
        (_tcslen(cTemp)+1) * sizeof(TCHAR));

    if (m_nLastError != 0)
        return failed;

    return no_error;
}

//***************************************************************************
//
//***************************************************************************
// ok

int Registry::DeleteValue(TCHAR *pszValueName)
{
    if(hSubkey == NULL)
        return failed;

    return RegDeleteValue(hSubkey, pszValueName);
}

//***************************************************************************
//
//***************************************************************************
// ok
int Registry::SetMultiStr(TCHAR *pszValueName, TCHAR * pszValue, DWORD dwSize)
{
    if(hSubkey == NULL)
        return failed;

    m_nLastError = RegSetValueEx(hSubkey,
                                 pszValueName,
                                 0,
                                 REG_MULTI_SZ,
                                 LPBYTE(pszValue),
                                 dwSize);

    if (m_nLastError != 0)
        return failed;
    return no_error;
}


//***************************************************************************
//
//***************************************************************************
// ok

int Registry::SetStr(TCHAR *pszValueName, TCHAR *pszValue)
{

    int nSize = (_tcslen(pszValue)+1) * sizeof(TCHAR);

    if(hSubkey == NULL)
        return failed;

    m_nLastError = RegSetValueEx(hSubkey, pszValueName, 0, REG_SZ, LPBYTE(pszValue), nSize);

    if (m_nLastError != 0)
        return failed;

    return no_error;
}


//***************************************************************************
//
//***************************************************************************
// ok

int Registry::SetExpandStr(TCHAR *pszValueName, TCHAR *pszValue)
{
    int nSize = (_tcslen(pszValue)+1) * sizeof(TCHAR);

    if(hSubkey == NULL)
        return failed;

    m_nLastError = RegSetValueEx(hSubkey, pszValueName, 0, REG_EXPAND_SZ, LPBYTE(pszValue), nSize);

    if (m_nLastError != 0)
        return failed;

    return no_error;
}

//***************************************************************************
//
//***************************************************************************
//  ok

TCHAR* Registry::GetMultiStr(TCHAR *pszValueName, DWORD &dwSize)
{
    //Find out the size of the buffer required
    DWORD dwType;
    if(hSubkey == NULL)
        return NULL;

    m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, &dwType, NULL, &dwSize);

    if ((m_nLastError == ERROR_SUCCESS) && (dwType != REG_MULTI_SZ))
    {
        m_nLastError = -1;
        dwSize = 0;
        return NULL;
    }

    //If the error is an unexpected one bail out
    if ((m_nLastError != ERROR_SUCCESS) || (dwType != REG_MULTI_SZ))
    {
        dwSize = 0;
        return NULL;
    }

    if (dwSize == 0)
    {
        dwSize = 0;
        return NULL;
    }

    // Allocate the buffer required. Will be twice as big as required
    // in _UNICODE versions.
    // ===============================================================
    TCHAR *pData = new TCHAR[dwSize];
    if (pData == 0)
        return NULL;
    
    //get the values
    m_nLastError = RegQueryValueEx(hSubkey,
                                   pszValueName,
                                   0,
                                   &dwType,
                                   LPBYTE(pData),
                                   &dwSize);

    //if an error bail out
    if (m_nLastError != 0)
    {
        delete [] pData;
        dwSize = 0;
        return NULL;
    }

    return pData;
}


//***************************************************************************
//
/// Use operator delete on returned value.
//
//***************************************************************************
// ok

int Registry::GetStr(TCHAR *pszValueName, TCHAR **pValue)
{
    *pValue = 0;
    DWORD dwSize = 0;
    DWORD dwType = 0;

    if(hSubkey == NULL)
        return failed;

    m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, &dwType,
                                    0, &dwSize);
    if (m_nLastError != 0)
            return failed;

    if (dwType != REG_SZ && dwType != REG_EXPAND_SZ)
        return failed;

    //
    // length will not include the null terminated character when you don't 
    // pass the buffer and the reg value was not already null terminated, 
    // so make up for it.  If you give RegQueryValueEx enough room in the buff
    // it will add the null terminator for you.
    // 
    dwSize += sizeof(TCHAR);

    TCHAR *p = new TCHAR[dwSize];  // May be twice as big as required when _UNICODE
                                    // is defined, but harmless nonetheless.
    if (p == 0)
        return failed;

    m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, &dwType,
                                    LPBYTE(p), &dwSize);
    if (m_nLastError != 0)
    {
        delete [] p;
        return failed;
    }

    if(dwType == REG_EXPAND_SZ)
    {
        TCHAR tTemp;

        // Get the initial length

        DWORD nSize = ExpandEnvironmentStrings((TCHAR *)p,&tTemp,1) + 1;
        TCHAR * pTemp = new TCHAR[nSize+1];
        if (pTemp == 0)
        {
            delete [] p;
            return failed;
        }
        ExpandEnvironmentStrings((TCHAR *)p,pTemp,nSize+1);
        delete [] p;
        *pValue = pTemp;
    }
    else
        *pValue = p;
    return no_error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\arbitrator\task.h ===
#include "arbitrator.h"
#include <windows.h>


class CTask : public _IWmiCoreHandle 
{
public:
	CTask();
	virtual ~CTask();

	HRESULT STDMETHODCALLTYPE QueryInterface ( REFIID, LPVOID* );
	ULONG STDMETHODCALLTYPE AddRef ( );
	ULONG STDMETHODCALLTYPE Release ( );
	
	
	HRESULT STDMETHODCALLTYPE GetHandleType		( ULONG *puType   )	{ *puType = 0; return NOERROR;}
	HRESULT STDMETHODCALLTYPE UpdateMemoryUsage	( LONG ulMemUsage ) { m_memoryUsage += ulMemUsage; return NOERROR; }
	HRESULT STDMETHODCALLTYPE GetMemoryUsage	( ULONG *pMem )		{ *pMem = m_memoryUsage; return NOERROR; }
	HRESULT STDMETHODCALLTYPE GetTotalSleepTime	( ULONG* pSleep)	{ *pSleep = m_totalSleepTime; return NOERROR; }
	HRESULT STDMETHODCALLTYPE GetTaskStatus		( )					{ return m_taskStatus; }
	HRESULT STDMETHODCALLTYPE GetStartTime		( )					{ return m_startTime; }
	HRESULT STDMETHODCALLTYPE GetEndTime		( )					{ return m_endTime; }

	HRESULT STDMETHODCALLTYPE UpdateTotalSleepTime	( ULONG ulSlpTime )  { m_totalSleepTime += ulSlpTime; return NOERROR; }
	HRESULT STDMETHODCALLTYPE UpdateTaskStatus		( ULONG ulStatus )	 { m_taskStatus = ulStatus; return NOERROR;}

private:
	ULONG	m_memoryUsage;
	ULONG	m_totalSleepTime;
	ULONG	m_taskStatus;
	ULONG	m_startTime;
	ULONG	m_endTime;
	LONG	m_lCount;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\arbitrator\reg.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    REG.H

Abstract:

  Utility Registry classes

History:

  a-raymcc    30-May-96   Created.

--*/

#ifndef _REG_H_
#define _REG_H_

#include <windows.h>

#define WBEM_REG_WBEM __TEXT("Software\\Microsoft\\WBEM")
#define WBEM_REG_WINMGMT __TEXT("Software\\Microsoft\\WBEM\\CIMOM")

class Registry
{
    HKEY hPrimaryKey;
    HKEY hSubkey;
    int nStatus;
    LONG m_nLastError;


public:
    enum { no_error, failed };

    int Open(HKEY hStart, TCHAR *pszStartKey);
    Registry(TCHAR *pszLocalMachineStartKey);

    // This create a special read only version which is usefull for marshalling
    // clients which are running with a lower priviledge set.

    Registry();
    Registry(HKEY hRoot, REGSAM flags, TCHAR *pszStartKey);
    Registry(HKEY hRoot, DWORD dwOptions, REGSAM flags, TCHAR *pszStartKey);
   ~Registry();

    int MoveToSubkey(TCHAR *pszNewSubkey);
    int GetDWORD(TCHAR *pszValueName, DWORD *pdwValue);
    int GetDWORDStr(TCHAR *pszValueName, DWORD *pdwValue);
    int GetStr(TCHAR *pszValue, TCHAR **pValue);

    // It is the callers responsibility to delete pData

    int GetBinary(TCHAR *pszValue, byte ** pData, DWORD * pdwSize);
    int SetBinary(TCHAR *pszValue, byte * pData, DWORD dwSize);

    //Returns a pointer to a string buffer containing the null-terminated string.
    //The last entry is a double null terminator (i.e. the registry format for
    //a REG_MULTI_SZ).  Caller has do "delete []" the returned pointer.
    //dwSize is the size of the buffer returned.
    TCHAR* GetMultiStr(TCHAR *pszValueName, DWORD &dwSize);

    int SetDWORD(TCHAR *pszValueName, DWORD dwValue);
    int SetDWORDStr(TCHAR *pszValueName, DWORD dwValue);
    int SetStr(TCHAR *pszValueName, TCHAR *psvValue);
    int SetExpandStr(TCHAR *pszValueName, TCHAR *psvValue);

    //pData should be passed in with the last entry double null terminated.
    //(i.e. the registry format for a REG_MULTI_SZ).
    int SetMultiStr(TCHAR *pszValueName, TCHAR* pData, DWORD dwSize);

    LONG GetLastError() { return m_nLastError; }
    int DeleteValue(TCHAR *pszValueName);
    int GetType(TCHAR *pszValueName, DWORD *pdwType);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\arbitrator\task.cpp ===
// Task.cpp: implementation of the CTask class.
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "Task.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CTask::CTask() : m_lCount ( 0 )
{
	m_memoryUsage		= 0;
	m_totalSleepTime	= 0;
	m_taskStatus		= 0;
	m_startTime			= 0;
	m_endTime			= 0;
}

CTask::~CTask()
{

}


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
HRESULT STDMETHODCALLTYPE CTask::QueryInterface ( REFIID refiid, LPVOID* pObj )
{
	HRESULT hRes = NOERROR;

	if ( refiid == IID_IUnknown )
	{
		*pObj = (IUnknown*) this;
	}
	else if ( refiid == IID__IWmiCoreHandle )
	{
		*pObj = (_IWmiCoreHandle*) this;
	}
	else
	{
		*pObj = NULL;
		hRes = E_NOINTERFACE;
	}

	if ( pObj )
	{
		AddRef ( );
	}

	return hRes;
}



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ULONG STDMETHODCALLTYPE CTask::AddRef ( )
{
	return InterlockedIncrement ( &m_lCount );
}



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ULONG STDMETHODCALLTYPE CTask::Release ( )
{
	ULONG tmpCount = InterlockedDecrement ( &m_lCount );
	if ( tmpCount == 0 )
	{
		delete this;
	}
	return tmpCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\asyncenumtest\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>

#define COREPOL_HEADERFILE_IS_INCLUDED

#define COREPROX_POLARITY __declspec( dllimport )
#define ESSLIB_POLARITY __declspec( dllimport )

#define COREPOL_HEADERFILE_IS_INCLUDED
#define POLARITY_HEADERFILE_IS_INCLUDED
#define POLARITY __declspec( dllimport )

#include "arena.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\asyncenumtest\asyncsink.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include <fastall.h>
#include <wbemcli.h>
#include "asyncsink.h"

extern BOOL	g_fPrintIndicates;

SCODE CAsyncSink::QueryInterface(
    REFIID riid,
    LPVOID * ppvObj
    )
{
    if (riid == IID_IUnknown)
    {
        *ppvObj = this;
    }
    else if (riid == IID_IWbemObjectSink)
        *ppvObj = this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}


ULONG CAsyncSink::AddRef()
{
    InterlockedIncrement(&m_lRefCount);
    return (ULONG) m_lRefCount;
}

ULONG CAsyncSink::Release()
{
    InterlockedDecrement(&m_lRefCount);

    if (0 != m_lRefCount)
    {
        return 1;
    }

    delete this;
    return 0;
}


SCODE CAsyncSink::Indicate(
    long lObjectCount,
    IWbemClassObject ** pObjArray
    )
{
	EnterCriticalSection( &m_cs );

	m_dwNumObjectsReceived += lObjectCount;

	if ( g_fPrintIndicates )
	{
		printf( "Received Indicate of %d objects, Total objects received: %d\n", lObjectCount, m_dwNumObjectsReceived );
	}

	LeaveCriticalSection( &m_cs );

    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CAsyncSink::SetStatus(long lFlags, long lParam, BSTR strParam, 
                         IWbemClassObject* pObjParam)
{ 
	printf( "SetStatus Called: lFlags = %d, lParam = %d\n", lFlags, lParam );

	EnterCriticalSection( &m_cs );
		
	// Store the final Tick Count and set the done event
	m_dwEndTickCount = GetTickCount();

	LeaveCriticalSection( &m_cs );

	// We're done!
	SetEvent( m_hEventDone );

	return WBEM_NO_ERROR;

}

CAsyncSink::CAsyncSink( HANDLE hDoneEvent )
:	m_hEventDone( hDoneEvent ),
	m_lRefCount( 1 ),
	m_dwNumObjectsReceived( 0 ),
	m_dwStartTickCount( 0 ),
	m_dwEndTickCount( 0 )
{
	InitializeCriticalSection( &m_cs );

	m_dwStartTickCount = GetTickCount();

}

CAsyncSink::~CAsyncSink()
{
    DeleteCriticalSection(&m_cs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\asyncenumtest\asyncsink.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#ifndef __ASYNCSINK_H__
#define __ASYNCSINK_H__

class CAsyncSink : public IWbemObjectSink
{
private:
    long				m_lRefCount;
	HANDLE				m_hEventDone;
	DWORD				m_dwNumObjectsReceived;
	DWORD				m_dwStartTickCount;
	DWORD				m_dwEndTickCount;
    CRITICAL_SECTION	m_cs;
    
public:
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam, 
                         IWbemClassObject* pObjPAram);

    // Private to implementation.
    // ==========================

    CAsyncSink( HANDLE hDoneEvent );
    ~CAsyncSink();

	DWORD	GetNumObjects();
	DWORD	GetStartTime();
	DWORD	GetEndTime();
	DWORD	GetTotalTime();
};

inline DWORD CAsyncSink::GetNumObjects( void )
{
	return m_dwNumObjectsReceived;
}

inline DWORD CAsyncSink::GetStartTime( void )
{
	return m_dwStartTickCount;
}
inline DWORD CAsyncSink::GetEndTime( void )
{
	return m_dwEndTickCount;
}
inline DWORD CAsyncSink::GetTotalTime( void )
{
	return m_dwEndTickCount - m_dwStartTickCount;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\asyncenumtest\asyncenumtest.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// SemiSychTest.cpp : implementation file
//

#include "precomp.h"
#include <stdio.h>
#include <wbemcli.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include <fastall.h>
#include <cominit.h>
#include "asyncsink.h"

//#define TEST_CLASS	L"Win32_BIOS"
//#define TEST_CLASS	L"Win32_DiskPartition"
//#define TEST_CLASS	L"Win32_IRQResource"
//#define TEST_CLASS	L"Win32_Directory"
#define TEST_CLASS		L"Win32_Process"
#define TEST_NAMESPACE	L"ROOT\\CIMV2"

#define	OBJECT_INTERVAL	10

#define	DEFAULT_SVR_ATHENT_LEVEL RPC_C_AUTHN_LEVEL_NONE
#define	DEFAULT_CLT_ATHENT_LEVEL RPC_C_AUTHN_LEVEL_CONNECT

DWORD	g_dwClientAuthentLevel = RPC_C_AUTHN_LEVEL_CONNECT;
BOOL	g_fDeepEnum = FALSE;
DWORD	g_dwNumReps = 1;

DWORD	g_dwCompletionTimeout=0xFFFFFFFF;	

BOOL	g_fPrintIndicates = FALSE;

void SinkTest( WCHAR* pwcsComputerName, WCHAR* pwcsNamespace, WCHAR* pwcsClass )
{
	IWbemLocator*		pWbemLocator = NULL;

	HRESULT hr = CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (void**) &pWbemLocator );

	if ( SUCCEEDED(hr) )
	{
		WCHAR	wszNameSpace[255];

		swprintf( wszNameSpace, L"\\\\%s\\%s", pwcsComputerName, pwcsNamespace );

		// Name space to connect to
		BSTR	bstrNameSpace = SysAllocString( wszNameSpace );

		BSTR	bstrObjectPath = NULL;

		bstrObjectPath = SysAllocString( pwcsClass );

		IWbemServices*	pNameSpace = NULL;

		hr = pWbemLocator->ConnectServer(	bstrNameSpace,	// NameSpace Name
											NULL,			// UserName
											NULL,			// Password
											NULL,			// Locale
											0L,				// Security Flags
											NULL,			// Authority
											NULL,			// Wbem Context
											&pNameSpace		// Namespace
											);

		if ( SUCCEEDED(hr) )
		{

            hr = CoSetProxyBlanket( pNameSpace,
									RPC_C_AUTHN_WINNT,
                                   RPC_C_AUTHZ_NONE,
                                   NULL,
                                   g_dwClientAuthentLevel,
                                   RPC_C_IMP_LEVEL_IMPERSONATE,
                                   NULL,
                                   0);


			DWORD	dwGrandTotal = 0L;

			for ( DWORD	x = 0; SUCCEEDED( hr ) && x < g_dwNumReps; x++ )
			{

				HANDLE	hDoneEvent = CreateEvent( NULL, TRUE, FALSE, NULL );

				CAsyncSink*	pNotSink = new CAsyncSink( hDoneEvent );

				BSTR	bstrClass = SysAllocString( pwcsClass );

				IEnumWbemClassObject*	pEnum;

				printf( "Querying WINMGMT for instances of class: %S\n", pwcsClass );

				hr = pNameSpace->CreateInstanceEnumAsync( bstrClass,
													( g_fDeepEnum ? WBEM_FLAG_DEEP : 0L ),
													NULL,
													pNotSink );

				// Walk the enumerator
				if ( SUCCEEDED( hr ) )
				{
					printf( "\nCreateInstanceEnumAsync() repetition #%d Successful.  Waiting for objects.\n", x);

					DWORD	dwWait = WaitForSingleObject( hDoneEvent, g_dwCompletionTimeout );

					if ( WAIT_TIMEOUT == dwWait )
					{
						printf( "CreateInstanceEnumAsync() timed out.  Cancelling operation\n" );

						hr = pNameSpace->CancelAsyncCall( pNotSink );

						printf( "CancelAsyncCall() returned: 0x%x\n", hr );
					}
					else
					{
						printf( "CreateInstanceEnumAsync() delivered %d Objects.\n", pNotSink->GetNumObjects() );
						printf( "Start Time: %d\n", pNotSink->GetStartTime() );
						printf( "End Time: %d\n", pNotSink->GetEndTime() );
						printf( "Total Time: %d\n", pNotSink->GetTotalTime() );
					}

					// Keep the running total
					dwGrandTotal += pNotSink->GetTotalTime();

					// Clean up the sink
					pNotSink->Release();

					CloseHandle( hDoneEvent );

				}
				else
				{
					printf( "CreateInstanceEnumAsync() failed: hr = %X\n", hr );
				}

			}	// For enum 

			if ( SUCCEEDED( hr ) )
			{
				DWORD	dwAverageTime = dwGrandTotal / g_dwNumReps;
				printf("\n\n Average Time to Completion: %d\n", dwAverageTime );
			}

			// Done with it.
			pNameSpace->Release();

		}	// IF Got NameSpace
		else
		{
			printf( "ConnectServer() failed: hr = %X\n", hr );
		}

		// Done with it.
		pWbemLocator->Release();

		// Cleanup BEASTERS
		SysFreeString( bstrObjectPath );
		SysFreeString( bstrNameSpace );

	}	// IF Got WbemLocator
}

BOOL CheckStr( char* str, char* find )
{
	BOOL	fReturn = FALSE;
	if ( strlen( str ) >= strlen( find ) )
	{
		char*	szVal = new char[strlen(find)+1];

		strncpy( szVal, str, strlen(find) );
		szVal[strlen(find)] = NULL;
		fReturn = ( lstrcmpi( szVal, find ) == 0);
		delete szVal;
	}

	return fReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	main
//
//	Entry point function to exercise IWbemObjectInternals interface.
//
///////////////////////////////////////////////////////////////////

int __cdecl main( int argc, char *argv[] )
{
	WCHAR	wcsComputerName[256],
			wcsClass[256],
			wcsNameSpace[256];
	DWORD	dwNumChars = 256;

	GetComputerNameW( wcsComputerName, &dwNumChars );
	wcscpy( wcsNameSpace, TEST_NAMESPACE );
	wcscpy( wcsClass, TEST_CLASS );

	DWORD	dwSvrAuthentLevel = RPC_C_AUTHN_LEVEL_NONE;

	if ( argc > 1 )
	{
		char*	pVal = NULL;
		for ( int x = 1; x < argc; x++ )
		{
			if ( CheckStr( argv[x], "/Machine=" ) )
			{
				pVal = argv[x] + strlen("/Machine=");
				mbstowcs( wcsComputerName, pVal, strlen( pVal ) + 1 );
			}

			if ( CheckStr( argv[x], "/NameSpace=" ) )
			{
				pVal = argv[x] + strlen("/NameSpace=");
				mbstowcs( wcsNameSpace, pVal, strlen( pVal ) + 1 );
			}

			if ( CheckStr( argv[x], "/Class=" ) )
			{
				pVal = argv[x] + strlen("/Class=");
				mbstowcs( wcsClass, pVal, strlen( pVal ) + 1 );
			}

			if ( CheckStr( argv[x], "/SvrAuthent=" ) )
			{
				pVal = argv[x] + strlen("/SvrAuthent=");
				dwSvrAuthentLevel = strtoul( pVal, NULL, 10 );
			}

			if ( CheckStr( argv[x], "/CltAuthent=" ) )
			{
				pVal = argv[x] + strlen("/CltAuthent=");
				g_dwClientAuthentLevel = strtoul( pVal, NULL, 10 );
			}


			if ( CheckStr( argv[x], "/DeepEnum=" ) )
			{
				pVal = argv[x] + strlen("/DeepEnum=");
				g_fDeepEnum = strtoul( pVal, NULL, 10 );
			}

			if ( CheckStr( argv[x], "/NumReps=" ) )
			{
				pVal = argv[x] + strlen("/NumReps=");
				g_dwNumReps = strtoul( pVal, NULL, 10 );
			}

			if ( CheckStr( argv[x], "/PrintIndicates=" ) )
			{
				pVal = argv[x] + strlen("/PrintIndicates=");
				g_fPrintIndicates = strtoul( pVal, NULL, 10 );
			}

			if ( CheckStr( argv[x], "/CompletionTimeout=" ) )
			{
				pVal = argv[x] + strlen("/CompletionTimeout=");
				g_dwCompletionTimeout = strtoul( pVal, NULL, 10 );
			}

		}

	}

	HRESULT	hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );

	hr = CoInitializeSecurity( NULL, -1, NULL, NULL, dwSvrAuthentLevel, RPC_C_IMP_LEVEL_IMPERSONATE,
										NULL, EOAC_NONE, NULL );

	SinkTest( wcsComputerName, wcsNameSpace, wcsClass );

	CoUninitialize();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\arbsim\arbsim.cpp ===
// ArbSim.cpp : Defines the entry point for the console application.
//


//#define _WIN32_DCOM
//#include <objbase.h>
#include "precomp.h"
#include <windows.h>
#include <stdio.h>
#include <time.h>

#include "..\Arbitrator\arbitrator.h"
#include "..\Arbitrator\Arbitrator_i.c"


#define MAX_TASKS				1000

#define	RANDOM_SLOW_MEMORY_HIGH		500000					// Upper memory for random tasks [SLOW]
#define RANDOM_SLOW_EXECTIME_HIGH	500						// Upper Execution time for random tasks [SLOW]

#define	RANDOM_FAST_MEMORY_HIGH		100000					// Upper memory for random tasks [FAST]
#define RANDOM_FAST_EXECTIME_HIGH	100						// Upper Execution time for random tasks [FAST]

#define RANDOM_WORK_SLEEP_HIGH		500
#define RANDOM_WORK_SLEEP_LOW		100

#define REPORT_INTERVAL				50

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// GLOBALS
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// {67429ED7-F52F-4773-B9BB-30302B0270DE}
static const GUID CLSID_Arbitrator = 
{ 0x67429ed7, 0xf52f, 0x4773, { 0xb9, 0xbb, 0x30, 0x30, 0x2b, 0x2, 0x70, 0xde } };

_IWmiArbitrator* pArb = NULL;


HRESULT InitializeArbitrator ( VOID );
BOOL	GetParameters		 ( char* );
VOID	DumpTaskList		 ( );
BOOL	StartSimulation		 ( );

DWORD WINAPI TaskThread ( PVOID lpParameter );


CRITICAL_SECTION cs;


LONG	lNumRandomThreads = 0;
LONG	lNumManualThreads = 0;

struct _taskList
{
	LONG Decency;
	LONG ExecutionTime;
	LONG WorkSleep;
	LONG InboundDelta;
	LONG Type;
} taskList [ MAX_TASKS ];


typedef struct _task
{
	_taskList	sTask;
	_IWmiCoreHandle* pTask;
	LONG	ID;
} Task;

enum {
	Task_Denency_Bad = 0,
	Task_Denency_Average = 1,
	Task_Denency_Good = 2
};



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// StartMe
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int __cdecl main(int argc, char* argv[])
{

	if ( argc != 2 )
	{
		printf ("Usage: ArbSim <control-file>\n");
		return 1;
	}
	
	if ( !GetParameters ( argv[1] ) )
		return 1;


	if ( FAILED (InitializeArbitrator()) )
	{
		printf ("Failed to initialize the arbitrator\n");
		return 1;
	}

	DumpTaskList ( );
	DWORD dwStartTime = GetTickCount ();
	StartSimulation ( );
	DWORD dwEndTime = GetTickCount ();
	printf ("Total elapsed time: %d s\n", (dwEndTime - dwStartTime)/1000 );
	DeleteCriticalSection ( &cs );
	return 1;
}


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Initialize the Arbitrator
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
HRESULT InitializeArbitrator ( VOID )
{
	HRESULT hRes = NOERROR;
	
	InitializeCriticalSection ( &cs );
	
	hRes = CoInitializeEx ( NULL, COINIT_MULTITHREADED );
	hRes = CoCreateInstance ( CLSID_Arbitrator, NULL, CLSCTX_INPROC_SERVER, IID__IWmiArbitrator, (void**) &pArb );
	return hRes;
}



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Gets simulation data from user
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
BOOL GetParameters ( char* szFileName )
{
	BOOL bRet = TRUE;

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// First get manual tasks
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	FILE* fPtr = fopen ( szFileName, "r" );
	if ( fPtr == NULL )
	{
		bRet = FALSE;
	}
	else
	{
		// Get number of random tasks
		char szLine[2000];
		if ( fgets ( szLine, 2000, fPtr ) == NULL )
		{
			bRet = FALSE;
			return bRet;
		}
		lNumRandomThreads = atoi ( szLine );

		// Get number of manual tasks
		szLine[0] = 0;
		if ( fgets ( szLine, 2000, fPtr ) == NULL )
		{
			bRet = FALSE;
			return bRet;
		}
		lNumManualThreads = atoi ( szLine );

		if ( ( lNumManualThreads + lNumRandomThreads ) > MAX_TASKS )
		{
			printf ( "Number of manual tasks and random tasks exceed max [%d]\n", MAX_TASKS );
			bRet = FALSE;
			return bRet;
		}
			
		char seps[]   = ",";
		// Loop through manual task control data
		for ( int x = 0; x < lNumManualThreads; x++ )
		{
			szLine [ 0 ] = 0;
			if ( fgets ( szLine, 2000, fPtr ) == NULL )
			{
				bRet = FALSE;
				break;
			}
				
			// Get decency	
			char* token = strtok( szLine, seps );
			taskList [ x ].Decency = atoi ( token );

			// Get inbound delta time
			token = strtok( NULL, seps );
			taskList [ x ].InboundDelta = atoi ( token );

			// Get execution time
			token = strtok( NULL, seps );
			taskList [ x ].ExecutionTime = atoi ( token );
			
			// Get Worksleep time
			token = strtok( NULL, seps );
			taskList [ x ].WorkSleep = atoi ( token );
		}
	}
	
	
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Now we populate random tasks
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	srand( (unsigned)time( NULL ) );
	LONG lExecFactor;
	LONG lMemFactor;
	LONG lWorkSleep;
	
	
	for ( int x = lNumManualThreads; x < ( lNumManualThreads + lNumRandomThreads ); x++ )
	{
		// First get the decency
		DOUBLE lTmp = ( rand ( ) / (double) RAND_MAX );
		if ( lTmp < 0.33 )
		{
			taskList [ x ].Decency =  Task_Denency_Bad;		// BAD
		}
		else if ( lTmp < 0.66 )
		{
			taskList [ x ].Decency = Task_Denency_Average;		// AVERAGE
		}
		else
		{
			taskList [ x ].Decency = Task_Denency_Good;		// GOOD
		}
			

		// Get the type, delta, and exec time
		lTmp = ( rand ( ) / (double) RAND_MAX );
		LONG lType = ( lTmp > 0.5 ) ? 1 : 0;

		if ( lType == 0 )
		{
			lExecFactor = RANDOM_SLOW_EXECTIME_HIGH;
			lMemFactor = RANDOM_SLOW_MEMORY_HIGH;
			lWorkSleep = RANDOM_WORK_SLEEP_HIGH;
		}
		else
		{
			lExecFactor = RANDOM_FAST_EXECTIME_HIGH;
			lMemFactor = RANDOM_FAST_MEMORY_HIGH;
			lWorkSleep = RANDOM_WORK_SLEEP_LOW;
		}
		
		
		LONG lExecTime = (LONG) ( rand ( ) / (double) RAND_MAX ) * lExecFactor;
		LONG lMemHigh  = (LONG) ( rand ( ) / (double) RAND_MAX ) * lMemFactor;
		LONG lWorkSl   = (LONG) ( rand ( ) / (double) RAND_MAX ) * lWorkSleep;

		taskList [ x ].ExecutionTime = lExecTime;
		taskList [ x ].InboundDelta = lMemHigh;
		taskList [ x ].Type  = lType;
		taskList [ x ].WorkSleep = lWorkSl;

	}

	return bRet;
}


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Dumps the task list
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
VOID DumpTaskList ( )
{
	for ( int x=0; x < ( lNumManualThreads + lNumRandomThreads ); x++ )
	{
		printf ("Task %d:	", x+1 );
		printf ("Execution time: %d steps, ", taskList [ x ] . ExecutionTime );
		printf ("Inbound Delta: %dKb, ", taskList [ x ] . InboundDelta / 1000);
		printf ("Work sleep time: %d ms ", taskList [ x ].WorkSleep );
		printf ("Decency: ");
		if ( taskList [ x ].Decency == Task_Denency_Bad )
			printf ("BAD\n");
		else if ( taskList [ x ].Decency == Task_Denency_Average )
			printf ("AVERAGE\n");
		else 
			printf ("GOOD\n");
	}
	printf("\n\n");
}


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Runs the simulation.
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
BOOL StartSimulation ( )
{
	BOOL bRet = TRUE;
	HRESULT hRes = NOERROR;
	
	HANDLE*	aTaskHandle = new HANDLE [ lNumManualThreads + lNumRandomThreads ];

	for ( int x = 0; x < ( lNumManualThreads + lNumRandomThreads ); x++ )
	{
		_IWmiCoreHandle* pTask = NULL;
		hRes = pArb->RegisterTask ( &pTask );
		if ( SUCCEEDED (hRes) )
		{
			Task* pT = new Task;
			pT->sTask = taskList [ x ];
			pT->pTask = pTask;
			pT->ID = x+1;
			
			aTaskHandle [x] = CreateThread ( NULL, 0, &TaskThread, (LPVOID) pT, 0, NULL );
		}
	}

	WaitForMultipleObjects ( ( lNumManualThreads + lNumRandomThreads ), aTaskHandle, TRUE, INFINITE );

	delete [] aTaskHandle;
	return bRet;
}
		


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Thread for each task.
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
DWORD WINAPI TaskThread ( void* pParam )
{

	Task* pTask = (Task*) pParam;
	
	LONG lReportDelta = ( pTask->sTask.InboundDelta );
	LONG lRunningCount = 0;


	HRESULT hRes;
	for ( int x = 0; x < pTask->sTask.ExecutionTime; x++ )
	{
		hRes = pArb->ReportMemoryUsage ( lReportDelta, pTask->pTask );
		if ( FAILED (hRes) )
		{
			ULONG sleepTime;
			pTask->pTask->GetTotalSleepTime (&sleepTime);

			if ( hRes == ARB_E_CANCELLED_TASK )
			{
				EnterCriticalSection ( &cs );
				ULONG memUsage;
				pTask->pTask->GetMemoryUsage (&memUsage);
				printf ("Task %d cancelled due to system high, total sleep time: %d ms, total memory consumption: %dKb\n", pTask->ID, sleepTime, (memUsage/1000) );
				LeaveCriticalSection ( &cs );			
				break;
			}
			else if ( hRes == ARB_E_CANCELLED_TASK_MAX_SLEEP )
			{
				EnterCriticalSection ( &cs );
				ULONG memUsage;
				pTask->pTask->GetMemoryUsage (&memUsage);
				printf ("Task %d cancelled due to sleeping too much, total sleep time: %d ms, total memory consumption: %dKb\n", pTask->ID, sleepTime, (memUsage/1000) );
				LeaveCriticalSection ( &cs );			
				break;
			}
		}

		lRunningCount += lReportDelta;
		Sleep ( pTask->sTask.WorkSleep );

		switch ( pTask->sTask.Decency )
		{
			double d;
			case Task_Denency_Bad:
				d = rand () / (double) RAND_MAX;
				if ( d < 0.05 )
				{
					LONG lOutRate = (LONG) ( ( rand () / (double) RAND_MAX ) * 0.05 ) * -1 * lRunningCount;
					pArb->ReportMemoryUsage ( lOutRate, pTask->pTask );
					lRunningCount += lOutRate;
				}
				break;

			case Task_Denency_Average:
				d = rand () / (double) RAND_MAX;
				if ( d < 0.50 )
				{
					LONG lOutRate = (LONG) ( ( rand () / (double) RAND_MAX ) * 0.25 + 0.25 ) * -1 * lRunningCount;
					pArb->ReportMemoryUsage ( lOutRate, pTask->pTask );
					lRunningCount += lOutRate;
				}
				break;

			case Task_Denency_Good:
				d = rand () / (double) RAND_MAX;
				if ( d < 0.90 )
				{
					LONG lOutRate = (LONG) ( ( rand () / (double) RAND_MAX ) * 0.1 + 0.9 ) * -1 * lRunningCount;
					pArb->ReportMemoryUsage ( lOutRate, pTask->pTask );
					lRunningCount += lOutRate;
				}
				break;
		}
	}

	if ( SUCCEEDED (hRes) )
	{
		EnterCriticalSection ( &cs );
		ULONG memUsage;
		ULONG sleepTime;
		pTask->pTask->GetMemoryUsage (&memUsage);
		pTask->pTask->GetTotalSleepTime (&sleepTime);

		printf ("Task %d completed, total sleep time: %d ms, total memory consumption: %dKb\n", pTask->ID, sleepTime, ((pTask->sTask.InboundDelta * pTask->sTask.ExecutionTime )/1000) );
		LeaveCriticalSection ( &cs );
		pArb->CancelTask ( 0, pTask->pTask );
	}
	delete pTask;

	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\ctrtest\ctrtest.c ===
/*++

Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    ctrtest.c

Abstract:

    Program to test the extensible counter dll's

Author:

    Bob Watson (bobw) 8 Feb 99

Revision History:

--*/
#include <windows.h>
#include <process.h>
#include <winperf.h>
#include <stdio.h>
#include <stdlib.h>
#include <pdhmsg.h>
#include "strings.h"
#include "ctrtest.h"

#define MAX_BUF_SIZE ((DWORD)(1024 * 1024))

typedef struct _LOCAL_THREAD_DATA {
    LPWSTR  szServiceName;
    LPWSTR  szQueryString;
    DWORD   dwThreadID;
    DWORD   dwCycleCount;
    DWORD   dwLoopCount;
    BOOL    bDisplay;
} LOCAL_THREAD_DATA, *PLOCAL_THREAD_DATA;

LOCAL_THREAD_DATA*   g_pLTData = NULL;
DWORD				g_dwNumObjects = 0;
DWORD				g_dwCycleCount = 0;
DWORD				g_dwLoopCount = 0;
BOOL				g_fRand = FALSE;

HANDLE  hEventLog = NULL;
HANDLE  hProcessHeap = NULL;

LONG    lEventLogLevel = LOG_DEBUG;
LONG    lExtCounterTestLevel = EXT_TEST_ALL;

DWORD
OpenLibrary (
    LPCWSTR szRegistryKey,      // service key in registry
    EXT_OBJECT  **pCreatedObj   // structure allocated, init'd and returned by this structure
)
{
    DWORD   Status = ERROR_SUCCESS;
    DWORD   dwOpenEvent;
    DWORD   dwType;
    DWORD   dwSize;

    // variables used for event logging
    DWORD   dwDataIndex;
    WORD    wStringIndex;
    DWORD   dwRawDataDwords[8];
    LPWSTR  szMessageArray[8];

    HANDLE  hTimeOutEvent = NULL;
    HANDLE  hThreadDataSemaphore = NULL;
    HANDLE  hPerflibFuncTimer = NULL;

    UINT    nErrorMode;

    // check to see if the library has already been opened

    HKEY    hServicesKey = NULL;
    HKEY    hPerfKey = NULL;
    LPWSTR  szServiceName;

    HKEY    hKeyLinkage;

    BOOL    bUseQueryFn = FALSE;

    EXT_OBJECT  *pReturnObject = NULL;
    EXT_OBJECT  *pObj = NULL;

    DWORD   dwFlags = 0;
    DWORD   dwKeep;
    DWORD   dwObjectArray[MAX_PERF_OBJECTS_IN_QUERY_FUNCTION];
    DWORD   dwObjIndex = 0;
    DWORD   dwMemBlockSize = sizeof(EXT_OBJECT);
    DWORD   dwLinkageStringLen = 0;

    CHAR    szOpenProcName[MAX_PATH];
    CHAR    szCollectProcName[MAX_PATH];
    CHAR    szCloseProcName[MAX_PATH];
    WCHAR   szLibraryString[MAX_PATH];
    WCHAR   szLibraryExpPath[MAX_PATH];
    WCHAR   mszObjectList[MAX_PATH];
    WCHAR   szLinkageKeyPath[MAX_PATH];
    WCHAR   szLinkageString[MAX_PATH];

    DWORD   dwOpenTimeout;
    DWORD   dwCollectTimeout;

    LPWSTR  szThisObject;
    LPWSTR  szThisChar;

    LPSTR   pNextStringA;
    LPWSTR  pNextStringW;

    WCHAR   szServicePath[MAX_PATH];
	WCHAR	szMutexName[MAX_PATH];
	WCHAR	szPID[32];

    if (szRegistryKey != NULL) {

        lstrcpyW (szServicePath, cszHklmServicesKey);

        Status = RegOpenKeyExW (HKEY_LOCAL_MACHINE, szServicePath, 
            0, KEY_READ, &hServicesKey);

        lstrcpyW (szServicePath, szRegistryKey);
        lstrcatW (szServicePath, cszPerformance);
        Status = RegOpenKeyExW (hServicesKey, szServicePath, 
            0, KEY_READ, &hPerfKey);
        szServiceName = (LPWSTR)szRegistryKey;

        // read the performance DLL name

        dwType = 0;
        dwSize = sizeof(szLibraryString);
        memset (szLibraryString, 0, sizeof(szLibraryString));
        memset (szLibraryString, 0, sizeof(szLibraryExpPath));

        Status = RegQueryValueExW (hPerfKey,
                                cszDLLValue,
                                NULL,
                                &dwType,
                                (LPBYTE)szLibraryString,
                                &dwSize);

        if (Status == ERROR_SUCCESS) {
            if (dwType == REG_EXPAND_SZ) {
                // expand any environment vars
                dwSize = ExpandEnvironmentStringsW(
                    szLibraryString,
                    szLibraryExpPath,
                    MAX_PATH);

                if ((dwSize > MAX_PATH) || (dwSize == 0)) {
                    Status = ERROR_INVALID_DLL;
                } else {
                    dwSize += 1;
                    dwSize *= sizeof(WCHAR);
                    dwMemBlockSize += DWORD_MULTIPLE(dwSize);
                }
            } else if (dwType == REG_SZ) {
                // look for dll and save full file Path
                dwSize = SearchPathW (
                    NULL,   // use standard system search path
                    szLibraryString,
                    NULL,
                    MAX_PATH,
                    szLibraryExpPath,
                    NULL);

                if ((dwSize > MAX_PATH) || (dwSize == 0)) {
                    Status = ERROR_INVALID_DLL;
                } else {
                    dwSize += 1;
                    dwSize *= sizeof(WCHAR);
                    dwMemBlockSize += DWORD_MULTIPLE(dwSize);
                }
            } else {
                Status = ERROR_INVALID_DLL;
            }

            if (Status == ERROR_SUCCESS) {
                // we have the DLL name so get the procedure names
                dwType = 0;
                dwSize = sizeof(szOpenProcName);
                memset (szOpenProcName, 0, sizeof(szOpenProcName));
                Status = RegQueryValueExA (hPerfKey,
                                        caszOpenValue,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)szOpenProcName,
                                        &dwSize);
            }

            if (Status == ERROR_SUCCESS) {
                // add in size of previous string
                // the size value includes the Term. NULL
                dwMemBlockSize += DWORD_MULTIPLE(dwSize);

                // we have the procedure name so get the timeout value
                dwType = 0;
                dwSize = sizeof(dwOpenTimeout);
                Status = RegQueryValueExW (hPerfKey,
                                        cszOpenTimeout,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)&dwOpenTimeout,
                                        &dwSize);

                // if error, then apply default
                if ((Status != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
                    dwOpenTimeout = 1000;
                    Status = ERROR_SUCCESS;
                }

            }

            if (Status == ERROR_SUCCESS) {
                // get next string

                dwType = 0;
                dwSize = sizeof(szCloseProcName);
                memset (szCloseProcName, 0, sizeof(szCloseProcName));
                Status = RegQueryValueExA (hPerfKey,
                                        caszCloseValue,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)szCloseProcName,
                                        &dwSize);
            }

            if (Status == ERROR_SUCCESS) {
                // add in size of previous string
                // the size value includes the Term. NULL
                dwMemBlockSize += DWORD_MULTIPLE(dwSize);

                // try to look up the query function which is the
                // preferred interface if it's not found, then
                // try the collect function name. If that's not found,
                // then bail
                dwType = 0;
                dwSize = sizeof(szCollectProcName);
                memset (szCollectProcName, 0, sizeof(szCollectProcName));
                Status = RegQueryValueExA (hPerfKey,
                                        caszQueryValue,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)szCollectProcName,
                                        &dwSize);

                if (Status == ERROR_SUCCESS) {
                    // add in size of the Query Function Name
                    // the size value includes the Term. NULL
                    dwMemBlockSize += DWORD_MULTIPLE(dwSize);
                    // get next string

                    bUseQueryFn = TRUE;
                    // the query function can support a static object list
                    // so look it up

                } else {
                    // the QueryFunction wasn't found so look up the
                    // Collect Function name instead
                    dwType = 0;
                    dwSize = sizeof(szCollectProcName);
                    memset (szCollectProcName, 0, sizeof(szCollectProcName));
                    Status = RegQueryValueExA (hPerfKey,
                                            caszCollectValue,
                                            NULL,
                                            &dwType,
                                            (LPBYTE)szCollectProcName,
                                            &dwSize);

                    if (Status == ERROR_SUCCESS) {
                        // add in size of Collect Function Name
                        // the size value includes the Term. NULL
                        dwMemBlockSize += DWORD_MULTIPLE(dwSize);
                    }
                }

                if (Status == ERROR_SUCCESS) {
                    // we have the procedure name so get the timeout value
                    dwType = 0;
                    dwSize = sizeof(dwCollectTimeout);
                    Status = RegQueryValueExW (hPerfKey,
                                            cszCollectTimeout,
                                            NULL,
                                            &dwType,
                                            (LPBYTE)&dwCollectTimeout,
                                            &dwSize);

                    // if error, then apply default
                    if ((Status != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
                        dwCollectTimeout = 1000;
                        Status = ERROR_SUCCESS;
                    }

                }
                // get the list of supported objects if provided by the registry

                dwType = 0;
                dwSize = sizeof(mszObjectList);
                memset (mszObjectList, 0, sizeof(mszObjectList));
                Status = RegQueryValueExW (hPerfKey,
                                        cszObjListValue,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)mszObjectList,
                                        &dwSize);

                if (Status == ERROR_SUCCESS) {
                    if (dwType != REG_MULTI_SZ) {
                        // convert space delimited list to msz
                        for (szThisChar = mszObjectList; *szThisChar != 0; szThisChar++) {
                            if (*szThisChar == L' ') *szThisChar = L'\0';
                        }
                        ++szThisChar;
                        *szThisChar = 0; // add MSZ term Null
                    }
                    for (szThisObject = mszObjectList, dwObjIndex = 0;
                        (*szThisObject != 0) && (dwObjIndex < MAX_PERF_OBJECTS_IN_QUERY_FUNCTION);
                        szThisObject += lstrlenW(szThisObject) + 1) {
                        dwObjectArray[dwObjIndex] = wcstoul(szThisObject, NULL, 10);
                        dwObjIndex++;
                    }
                    if (*szThisObject != 0) {
                        // DEVNOTE: log error idicating too many object ID's are
                        // in the list.
                    }
                } else {
                    // reset status since not having this is
                    //  not a showstopper
                    Status = ERROR_SUCCESS;
                }

                if (Status == ERROR_SUCCESS) {
                    dwType = 0;
                    dwKeep = 0;
                    dwSize = sizeof(dwKeep);
                    Status = RegQueryValueExW (hPerfKey,
                                            cszKeepResident,
                                            NULL,
                                            &dwType,
                                            (LPBYTE)&dwKeep,
                                            &dwSize);

                    if ((Status == ERROR_SUCCESS) && (dwType == REG_DWORD)) {
                        if (dwKeep == 1) {
                            dwFlags |= PERF_EO_KEEP_RESIDENT;
                        } else {
                            // no change.
                        }
                    } else {
                        // not fatal, just use the defaults.
                        Status = ERROR_SUCCESS;
                    }

                }
            }
        }

        if (Status == ERROR_SUCCESS) {
            memset (szLinkageString, 0, sizeof(szLinkageString));

            lstrcpyW (szLinkageKeyPath, szServiceName);
            lstrcatW (szLinkageKeyPath, cszLinkageKey);

            Status = RegOpenKeyExW (
                hServicesKey,
                szLinkageKeyPath,
                0L,
                KEY_READ,
                &hKeyLinkage);

            if (Status == ERROR_SUCCESS) {
                // look up export value string
                dwSize = sizeof(szLinkageString);
                dwType = 0;
                Status = RegQueryValueExW (
                    hKeyLinkage,
                    cszExportValue,
                    NULL,
                    &dwType,
                    (LPBYTE)&szLinkageString,
                    &dwSize);

                if ((Status != ERROR_SUCCESS) ||
                    ((dwType != REG_SZ) && (dwType != REG_MULTI_SZ))) {
                    // clear buffer
                    memset (szLinkageString, 0, sizeof(szLinkageString));
                    dwLinkageStringLen = 0;

                    // not finding a linkage key is not fatal so correct
                    // status
                    Status = ERROR_SUCCESS;
                } else {
                    // add size of linkage string to buffer
                    // the size value includes the Term. NULL
                    dwLinkageStringLen = dwSize;
                    dwMemBlockSize += DWORD_MULTIPLE(dwSize);
                }

                RegCloseKey (hKeyLinkage);
            } else {
                // not finding a linkage key is not fatal so correct
                // status
                Status = ERROR_SUCCESS;
            }
        }

        if (Status == ERROR_SUCCESS) {
            // add in size of service name
            dwSize = lstrlenW (szServiceName);
            dwSize += 1;
            dwSize *= sizeof(WCHAR);
            dwMemBlockSize += DWORD_MULTIPLE(dwSize);

            // allocate and initialize a new ext. object block
            pReturnObject = (EXT_OBJECT *)HeapAlloc(hProcessHeap,
                HEAP_ZERO_MEMORY, dwMemBlockSize);

            if (pReturnObject != NULL) {
                // copy values to new buffer (all others are NULL)
                pNextStringA = (LPSTR)&pReturnObject[1];

                // copy Open Procedure Name
                pReturnObject->szOpenProcName = pNextStringA;
                lstrcpyA (pNextStringA, szOpenProcName);

                pNextStringA += lstrlenA (pNextStringA) + 1;
                pNextStringA = (LPSTR)ALIGN_ON_DWORD(pNextStringA);

                pReturnObject->dwOpenTimeout = dwOpenTimeout;

                // copy collect function or query function, depending
                pReturnObject->szCollectProcName = pNextStringA;
                lstrcpyA (pNextStringA, szCollectProcName);

                pNextStringA += lstrlenA (pNextStringA) + 1;
                pNextStringA = (LPSTR)ALIGN_ON_DWORD(pNextStringA);

                pReturnObject->dwCollectTimeout = dwCollectTimeout;

                // copy Close Procedure Name
                pReturnObject->szCloseProcName = pNextStringA;
                lstrcpyA (pNextStringA, szCloseProcName);

                pNextStringA += lstrlenA (pNextStringA) + 1;
                pNextStringA = (LPSTR)ALIGN_ON_DWORD(pNextStringA);

                // copy Library path
                pNextStringW = (LPWSTR)pNextStringA;
                pReturnObject->szLibraryName = pNextStringW;
                lstrcpyW (pNextStringW, szLibraryExpPath);

                pNextStringW += lstrlenW (pNextStringW) + 1;
                pNextStringW = (LPWSTR)ALIGN_ON_DWORD(pNextStringW);

                // copy Linkage String if there is one
                if (*szLinkageString != 0) {
                    pReturnObject->szLinkageString = pNextStringW;
                    memcpy (pNextStringW, szLinkageString, dwLinkageStringLen);

                    // length includes extra NULL char and is in BYTES
                    pNextStringW += (dwLinkageStringLen / sizeof (WCHAR));
                    pNextStringW = (LPWSTR)ALIGN_ON_DWORD(pNextStringW);
                }

                // copy Service name
                pReturnObject->szServiceName = pNextStringW;
                lstrcpyW (pNextStringW, szServiceName);

                pNextStringW += lstrlenW (pNextStringW) + 1;
                pNextStringW = (LPWSTR)ALIGN_ON_DWORD(pNextStringW);

                // load flags
                if (bUseQueryFn) {
                    dwFlags |= PERF_EO_QUERY_FUNC;
                }
                pReturnObject->dwFlags =  dwFlags;

                pReturnObject->hPerfKey = hPerfKey;

                // load Object array
                if (dwObjIndex > 0) {
                    pReturnObject->dwNumObjects = dwObjIndex;
                    memcpy (pReturnObject->dwObjList,
                        dwObjectArray, (dwObjIndex * sizeof(dwObjectArray[0])));
                }

                pReturnObject->llLastUsedTime = 0;

				// create Mutex name
				lstrcpyW (szMutexName, szRegistryKey);
				lstrcatW (szMutexName, (LPCWSTR)L"_Perf_Library_Lock_PID_");
				_ultow ((ULONG)GetCurrentProcessId(), szPID, 16);
				lstrcatW (szMutexName, szPID);

                pReturnObject->hMutex = CreateMutexW (NULL, FALSE, szMutexName);
            } else {
                Status = ERROR_OUTOFMEMORY;
            }
        }

        if (Status != ERROR_SUCCESS) {
            SetLastError (Status);
            if (pReturnObject != NULL) {
                // release the new block
                HeapFree (hProcessHeap, 0, pReturnObject);
            }
        } else {
            if (pReturnObject != NULL) {
                pObj = pReturnObject;
                // then load library & look up functions
                nErrorMode = SetErrorMode (SEM_FAILCRITICALERRORS);
                pObj->hLibrary = LoadLibraryExW (pObj->szLibraryName,
                    NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

                if (pObj->hLibrary != NULL) {
                    // lookup function names
                    pObj->OpenProc = (OPENPROC)GetProcAddress(
                        pObj->hLibrary, pObj->szOpenProcName);
                    if (pObj->OpenProc == NULL) {
                        wprintf ((LPCWSTR)L"\nOpen Procedure \"%s\" not found in \"%s\"",
                            pObj->szOpenProcName, pObj->szLibraryName);
                    }
                } else {
                    // unable to load library
                    Status = GetLastError();
                }

                if (Status == ERROR_SUCCESS) {
                    if (pObj->dwFlags & PERF_EO_QUERY_FUNC) {
                        pObj->QueryProc = (QUERYPROC)GetProcAddress (
                            pObj->hLibrary, pObj->szCollectProcName);
                        pObj->CollectProc = (COLLECTPROC)pObj->QueryProc;
                    } else {
                        pObj->CollectProc = (COLLECTPROC)GetProcAddress (
                            pObj->hLibrary, pObj->szCollectProcName);
                        pObj->QueryProc = (QUERYPROC)pObj->CollectProc;
                    }

                    if (pObj->CollectProc == NULL) {
                        wprintf ((LPCWSTR)L"\nCollect Procedure \"%s\" not found in \"%s\"",
                            pObj->szCollectProcName, pObj->szLibraryName);
                    }
                }

                if (Status == ERROR_SUCCESS) {
                    pObj->CloseProc = (CLOSEPROC)GetProcAddress (
                        pObj->hLibrary, pObj->szCloseProcName);

                    if (pObj->CloseProc == NULL) {
                        wprintf ((LPCWSTR)L"\nClose Procedure \"%s\" not found in \"%s\"",
                            pObj->szCloseProcName, pObj->szLibraryName);
                    }
                }

                if (Status == ERROR_SUCCESS) {
                    __try {
                        // start timer
                        WAIT_FOR_AND_LOCK_MUTEX (pObj->hMutex);
                        // call open procedure to initialize DLL
                        Status = (*pObj->OpenProc)(pObj->szLinkageString);

                        // release the lock
                        RELEASE_MUTEX (pObj->hMutex);

                        // check the result.
                        if (Status != ERROR_SUCCESS) {
                            dwOpenEvent = WBEMPERF_OPEN_PROC_FAILURE;
                        } else {
                            InterlockedIncrement((LONG *)&pObj->dwOpenCount);
                        }
                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                        Status = GetExceptionCode();
                        dwOpenEvent = WBEMPERF_OPEN_PROC_EXCEPTION;
                    }

                }

                if (Status != ERROR_SUCCESS) {
                    // clear fields
                    pObj->OpenProc = NULL;
                    pObj->CollectProc = NULL;
                    pObj->QueryProc = NULL;
                    pObj->CloseProc = NULL;
                    if (pObj->hLibrary != NULL) {
                        FreeLibrary (pObj->hLibrary);
                        pObj->hLibrary = NULL;
                    }
                } else {
                    GetSystemTimeAsFileTime ((FILETIME *)&pObj->llLastUsedTime);
                }
            } // else no buffer returned
            *pCreatedObj = pObj;
        }

        if (hServicesKey != NULL) RegCloseKey (hServicesKey);
    } else {
        Status = ERROR_INVALID_PARAMETER;
    }

    return Status;
}

//***************************************************************************
//
//  CollectData (LPBYTE pBuffer, 
//              LPDWORD pdwBufferSize, 
//              LPWSTR pszItemList)
//
//  Collects data from the perf objects and libraries added to the access 
//  object
//
//      Inputs:
//
//          pBuffer              -   pointer to start of data block
//                                  where data is being collected
//
//          pdwBufferSize        -   pointer to size of data buffer
//
//          pszItemList        -    string to pass to ext DLL
//
//      Outputs:
//
//          *lppDataDefinition  -   set to location for next Type
//                                  Definition if successful
//
//      Returns:
//
//          0 if successful, else Win 32 error code of failure
//
//
//***************************************************************************
//
DWORD   
CollectData (EXT_OBJECT *pThisExtObj,
             LPBYTE pBuffer, 
             LPDWORD pdwBufferSize, 
             LPCWSTR pszItemList
)
{
    LPWSTR  lpValueName = NULL;
    LPBYTE  lpData = pBuffer;
    LPDWORD lpcbData = pdwBufferSize;
    LPVOID  lpDataDefinition = pBuffer;

    DWORD Win32Error=ERROR_SUCCESS;          //  Failure code
    DWORD BytesLeft;
    DWORD NumObjectTypes;

    LPVOID  lpExtDataBuffer = NULL;
    LPVOID  lpCallBuffer = NULL;
    LPVOID  lpLowGuardPage = NULL;
    LPVOID  lpHiGuardPage = NULL;
    LPVOID  lpEndPointer = NULL;
    LPVOID  lpBufferBefore = NULL;
    LPVOID  lpBufferAfter = NULL;
    LPDWORD lpCheckPointer;
    LARGE_INTEGER   liStartTime, liEndTime, liFreq;

    BOOL    bGuardPageOK;
    BOOL    bBufferOK;
    BOOL    bException;
    BOOL    bUseSafeBuffer = TRUE;
    BOOL    bUnlockObjData;

    LONG    lReturnValue = ERROR_SUCCESS;

    LONG                lInstIndex;
    PERF_OBJECT_TYPE    *pObject, *pNextObject;
    PERF_INSTANCE_DEFINITION    *pInstance;
    PERF_DATA_BLOCK     *pPerfData;
    BOOL                bForeignDataBuffer;

    DWORD           dwItemsInArray = 0;
    DWORD           dwItemsInList = 0;

    DWORD           dwIndex;

    // use the one passed by the caller
    lpValueName = (LPWSTR)pszItemList;

    // initialize values to pass to the extensible counter function
    NumObjectTypes = 0;
    BytesLeft = (DWORD) (*lpcbData - ((LPBYTE)lpDataDefinition - lpData));
    bException = FALSE;

    // allocate a local block of memory to pass to the
    // extensible counter function.

    if (bUseSafeBuffer) {
        lpExtDataBuffer = HeapAlloc (hProcessHeap,
            HEAP_ZERO_MEMORY, BytesLeft + (2*GUARD_PAGE_SIZE));
    } else {
        lpExtDataBuffer =
            lpCallBuffer = lpDataDefinition;
    }

    if (lpExtDataBuffer != NULL) {
        if (bUseSafeBuffer) {
            // set buffer pointers
            lpLowGuardPage = lpExtDataBuffer;
            lpCallBuffer = (LPBYTE)lpExtDataBuffer + GUARD_PAGE_SIZE;
            lpHiGuardPage = (LPBYTE)lpCallBuffer + BytesLeft;
            lpEndPointer = (LPBYTE)lpHiGuardPage + GUARD_PAGE_SIZE;
            lpBufferBefore = lpCallBuffer;
            lpBufferAfter = NULL;

            // initialize GuardPage Data

            memset (lpLowGuardPage, GUARD_PAGE_CHAR, GUARD_PAGE_SIZE);
            memset (lpHiGuardPage, GUARD_PAGE_CHAR, GUARD_PAGE_SIZE);
        }

        __try {
            //
            //  Collect data from extesible objects
            //

            bUnlockObjData = FALSE;
            if (pThisExtObj->hMutex != NULL) {
                Win32Error =  WaitForSingleObject (
                    pThisExtObj->hMutex,
                    pThisExtObj->dwCollectTimeout);
                if ((Win32Error != WAIT_TIMEOUT)  &&
                    (pThisExtObj->CollectProc != NULL)) {

                    bUnlockObjData = TRUE;

                    QueryPerformanceCounter (&liStartTime);

                        Win32Error =  (*pThisExtObj->CollectProc) (
                            lpValueName,
                        &lpCallBuffer,
                            &BytesLeft,
                            &NumObjectTypes);

                    QueryPerformanceCounter (&liEndTime);

                    GetSystemTimeAsFileTime(
                        (FILETIME*)&pThisExtObj->llLastUsedTime);

                    ReleaseMutex (pThisExtObj->hMutex);
                    bUnlockObjData = FALSE;
                } else {
                    pThisExtObj->dwLockoutCount++;
                }
            } else {
                Win32Error = ERROR_LOCK_FAILED;
            }

            if ((Win32Error == ERROR_SUCCESS) && (BytesLeft > 0)) {
                // increment perf counters
                InterlockedIncrement ((LONG *)&pThisExtObj->dwCollectCount);
                liFreq.QuadPart = 0;
                QueryPerformanceFrequency (&liFreq);
                pThisExtObj->llTimeBase = liFreq.QuadPart;
                pThisExtObj->llFunctionTime = liEndTime.QuadPart - liStartTime.QuadPart;
                pThisExtObj->llElapsedTime += pThisExtObj->llFunctionTime;
                pThisExtObj->dwNumObjectsRet = NumObjectTypes;
                pThisExtObj->dwRetBufSize = BytesLeft;

                if (BytesLeft & 0x00000007) {
                    pThisExtObj->dwAlignmentErrors++;
                }

                if (bUseSafeBuffer) {
                    // a data buffer was returned and
                    // the function returned OK so see how things
                    // turned out...
                    //
                    lpBufferAfter = lpCallBuffer;
                    //
                    // check for buffer corruption here
                    //
                    bBufferOK = TRUE; // assume it's ok until a check fails
                    //
                    if (lExtCounterTestLevel <= EXT_TEST_BASIC) {
                        //
                        //  check 1: bytes left should be the same as
                        //      new data buffer ptr - orig data buffer ptr
                        //
                        if (BytesLeft != (DWORD)((LPBYTE)lpBufferAfter - (LPBYTE)lpBufferBefore)) {
                            pThisExtObj->dwBadPointers++;
                            // we'll keep the buffer, since the returned bytes left
                            // value is ignored anyway, in order to make the
                            // rest of this function work, we'll fix it here
                            BytesLeft = (DWORD)((LPBYTE)lpBufferAfter - (LPBYTE)lpBufferBefore);
                        }
                        //
                        //  check 2: buffer after ptr should be < hi Guard page ptr
                        //
                        if (((LPBYTE)lpBufferAfter >= (LPBYTE)lpHiGuardPage) && bBufferOK) {
                            // see if they exceeded the allocated memory
                            if ((LPBYTE)lpBufferAfter >= (LPBYTE)lpEndPointer) {
                                pThisExtObj->dwBufferSizeErrors++;
                                bBufferOK = FALSE;
                                // since the DLL overran the buffer, the buffer
                                // must be too small (no comments about the DLL
                                // will be made here) so the status will be
                                // changed to ERROR_MORE_DATA and the function
                                // will return.
                                Win32Error = ERROR_MORE_DATA;
                            }
                        }
                        //
                        //  check 3: check lo guard page for corruption
                        //
                        if (bBufferOK) {
                            bGuardPageOK = TRUE;
                            for (lpCheckPointer = (LPDWORD)lpLowGuardPage;
                                    lpCheckPointer < (LPDWORD)lpBufferBefore;
                                lpCheckPointer++) {
                                if (*lpCheckPointer != GUARD_PAGE_DWORD) {
                                    bGuardPageOK = FALSE;
                                        break;
                                }
                            }
                            if (!bGuardPageOK) {
                                pThisExtObj->dwLowerGPViolations++;

                                bBufferOK = FALSE;
                            }
                        }
                        //
                        //  check 4: check hi guard page for corruption
                        //
                        if (bBufferOK) {
                            bGuardPageOK = TRUE;
                            for (lpCheckPointer = (LPDWORD)lpHiGuardPage;
                                lpCheckPointer < (LPDWORD)lpEndPointer;
                                lpCheckPointer++) {
                                    if (*lpCheckPointer != GUARD_PAGE_DWORD) {
                                        bGuardPageOK = FALSE;
                                    break;
                                }
                            }
                            if (!bGuardPageOK) {
                                pThisExtObj->dwUpperGPViolations++;
                                bBufferOK = FALSE;
                            }
                        }
                       
                        //
                        if ((lExtCounterTestLevel <= EXT_TEST_ALL) && bBufferOK) {
                            //
                            //  Internal consistency checks
                            //
                            //
                            //  Check 5: Check object length field values
                            //
                            // first test to see if this is a foreign
                            // computer data block or not
                            //
                            pPerfData = (PERF_DATA_BLOCK *)lpBufferBefore;
                            if ((pPerfData->Signature[0] == (WCHAR)'P') &&
                                (pPerfData->Signature[1] == (WCHAR)'E') &&
                                (pPerfData->Signature[2] == (WCHAR)'R') &&
                                (pPerfData->Signature[3] == (WCHAR)'F')) {
                                // if this is a foreign computer data block, then the
                                // first object is after the header
                                pObject = (PERF_OBJECT_TYPE *) (
                                    (LPBYTE)pPerfData + pPerfData->HeaderLength);
                                bForeignDataBuffer = TRUE;
                            } else {
                                // otherwise, if this is just a buffer from
                                // an extensible counter, the object starts
                                // at the beginning of the buffer
                                pObject = (PERF_OBJECT_TYPE *)lpBufferBefore;
                                bForeignDataBuffer = FALSE;
                            }
                            // go to where the pointers say the end of the
                            // buffer is and then see if it's where it
                            // should be
                            for (dwIndex = 0; dwIndex < NumObjectTypes; dwIndex++) {
                                pObject = (PERF_OBJECT_TYPE *)((LPBYTE)pObject +
                                    pObject->TotalByteLength);
                            }
                            if ((LPBYTE)pObject != (LPBYTE)lpCallBuffer) {
                                // then a length field is incorrect. This is FATAL
                                // since it can corrupt the rest of the buffer
                                // and render the buffer unusable.
                                pThisExtObj->dwObjectSizeErrors++;
                                bBufferOK = FALSE;
                            }
                            //
                            //  Test 6: Test instance field size values
                            //
                            if (bBufferOK) {
                                // set object pointer
                                if (bForeignDataBuffer) {
                                    pObject = (PERF_OBJECT_TYPE *) (
                                        (LPBYTE)pPerfData + pPerfData->HeaderLength);
                                } else {
                                    // otherwise, if this is just a buffer from
                                    // an extensible counter, the object starts
                                    // at the beginning of the buffer
                                    pObject = (PERF_OBJECT_TYPE *)lpBufferBefore;
                                }

                                for (dwIndex = 0; dwIndex < NumObjectTypes; dwIndex++) {
                                    pNextObject = (PERF_OBJECT_TYPE *)((LPBYTE)pObject +
                                        pObject->TotalByteLength);

                                    if (pObject->NumInstances != PERF_NO_INSTANCES) {
                                        pInstance = (PERF_INSTANCE_DEFINITION *)
                                            ((LPBYTE)pObject + pObject->DefinitionLength);
                                        lInstIndex = 0;
                                        while (lInstIndex < pObject->NumInstances) {
                                            PERF_COUNTER_BLOCK *pCounterBlock;

                                            pCounterBlock = (PERF_COUNTER_BLOCK *)
                                                ((PCHAR) pInstance + pInstance->ByteLength);

                                            pInstance = (PERF_INSTANCE_DEFINITION *)
                                                ((PCHAR) pCounterBlock + pCounterBlock->ByteLength);

                                            lInstIndex++;
                                        }
                                        if ((LPBYTE)pInstance > (LPBYTE)pNextObject) {
                                            bBufferOK = FALSE;
                                        }
                                    }

                                    if (!bBufferOK) {
                                        break;
                                    } else {
                                        pObject = pNextObject;
                                    }
                                }

                                if (!bBufferOK) {
                                    pThisExtObj->dwInstanceSizeErrors++;
                                }
                            }
                        }
                    }
                    //
                    // if all the tests pass,then copy the data to the
                    // original buffer and update the pointers
                    if (bBufferOK) {
                        RtlMoveMemory (lpDataDefinition,
                            lpBufferBefore,
                            BytesLeft); // returned buffer size
                    } else {
                        NumObjectTypes = 0; // since this buffer was tossed
                    }
                } else {
                    // function already copied data to caller's buffer
                    // so no further action is necessary
                }
                lpDataDefinition = (LPVOID)((LPBYTE)(lpDataDefinition) + BytesLeft);    // update data pointer
            } else {
                if (Win32Error != ERROR_SUCCESS) {
                    if (Win32Error != WAIT_TIMEOUT) {
                        // don't count timeouts as function errors
                        InterlockedIncrement ((LONG *)&pThisExtObj->dwErrorCount);
                    }
                }
                if (bUnlockObjData) {
                    ReleaseMutex (pThisExtObj->hMutex);
                }

                NumObjectTypes = 0; // clear counter
            }// end if function returned successfully

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            Win32Error = GetExceptionCode();
            InterlockedIncrement ((LONG *)&pThisExtObj->dwExceptionCount);
            bException = TRUE;
            if (bUnlockObjData) {
                ReleaseMutex (pThisExtObj->hMutex);
                bUnlockObjData = FALSE;
            }
        }
        if (bUseSafeBuffer) {
            HeapFree (hProcessHeap, 0, lpExtDataBuffer);
        }
    } else {
        // unable to allocate memory so set error value
        Win32Error = ERROR_OUTOFMEMORY;
    } // end if temp buffer allocated successfully
    RELEASE_MUTEX (pThisExtObj->hMutex);

    lReturnValue = Win32Error;

    return lReturnValue;
}

DWORD
CloseLibrary (
    EXT_OBJECT  *pInfo
)
{
    DWORD   lStatus;

    if (pInfo != NULL) {
	    // if there's a close proc to call, then 
	    // call close procedure to close anything that may have
	    // been allocated by the library
        WAIT_FOR_AND_LOCK_MUTEX (pInfo->hMutex);
	    if (pInfo->CloseProc != NULL) {
		    lStatus = (*pInfo->CloseProc) ();
	    }
        RELEASE_MUTEX (pInfo->hMutex);

        // then close everything
        if (pInfo->hMutex != NULL) {
            CloseHandle (pInfo->hMutex);
            pInfo->hMutex = NULL;
        }
    
        if (pInfo->hLibrary != NULL) {
            FreeLibrary (pInfo->hLibrary);
            pInfo->hLibrary = NULL;
        }

        if (pInfo->hPerfKey != NULL) {
            RegCloseKey (pInfo->hPerfKey);
            pInfo->hPerfKey = NULL;
        }

        HeapFree (hProcessHeap, 0, pInfo);
    }

    return ERROR_SUCCESS;
}

DWORD 
CycleTest (
    DWORD   dwThreadId,
    PLOCAL_THREAD_DATA  pData
)
{
    DWORD   dwStatus;
    EXT_OBJECT *pObj = NULL;
    LPWSTR  szValueString = pData->szQueryString;
    LPCWSTR szServiceName = pData->szServiceName;
    DWORD   dwLoopCount = pData->dwLoopCount;
    BOOL    bPrintData = pData->bDisplay;
    LPBYTE  pBuffer = NULL;
    LPBYTE  pThisBuffer;
    DWORD   dwBufSize = 0;
    DWORD   dwThisBufSize;
    DWORD   dwWaitTime;
    DWORD   dwMemorySizeIncrement = 0x100;

    dwStatus = OpenLibrary (szServiceName, &pObj);

    if (dwStatus == ERROR_SUCCESS) {
        // get the buffer size
        // get the buffer size
        dwStatus = ERROR_MORE_DATA;
        do {
            if (pBuffer != NULL) HeapFree (hProcessHeap, 0, pBuffer);

            dwBufSize += dwMemorySizeIncrement;
            dwMemorySizeIncrement *= 2;
            pBuffer = (LPBYTE) HeapAlloc (hProcessHeap, HEAP_ZERO_MEMORY, dwBufSize);

            if (pBuffer != NULL) {
                // init the args
                pThisBuffer = pBuffer;
                dwThisBufSize = dwBufSize;
        
                dwStatus = CollectData (pObj, 
                    pThisBuffer,
                    &dwThisBufSize,
                    szValueString);

            }
        } while ((dwStatus == ERROR_MORE_DATA) && (dwBufSize < MAX_BUF_SIZE));

        if (dwBufSize >= MAX_BUF_SIZE) {
            wprintf ((LPCWSTR)L"\nCollectFunction requires a buffer > %d bytes", MAX_BUF_SIZE);
            if (pBuffer != NULL) HeapFree (hProcessHeap, 0, pBuffer);
            dwStatus = ERROR_INVALID_PARAMETER;
        } else if (pBuffer == NULL) {
            dwStatus = ERROR_OUTOFMEMORY;
        } else {

            // call collect function
            do {
                // wait some random time for the next sample
                dwWaitTime = (DWORD)rand(); // returns some number between 0 & 32K
                dwWaitTime /= 4; // scale it so the range is from 0 to about 8 seconds
//                Sleep (dwWaitTime);                

                // init the args
                pThisBuffer = pBuffer;
                dwThisBufSize = dwBufSize;

                // get the data
                dwStatus = CollectData (pObj, 
                            pThisBuffer,
                            &dwThisBufSize,
                            szValueString);

                while ((dwStatus == ERROR_MORE_DATA) && (dwBufSize < MAX_BUF_SIZE)) {
                    if (pBuffer != NULL) HeapFree (hProcessHeap, 0, pBuffer);

                    dwBufSize += dwMemorySizeIncrement;
                    dwMemorySizeIncrement *= 2;
                    pBuffer = (LPBYTE) HeapAlloc (hProcessHeap, HEAP_ZERO_MEMORY, dwBufSize);

                    if (pBuffer != NULL) {
                        // init the args
                        pThisBuffer = pBuffer;
                        dwThisBufSize = dwBufSize;
       
                        // get the data again
                        dwStatus = CollectData (pObj, 
                                    pThisBuffer,
                                    &dwThisBufSize,
                                    szValueString);
                    }
                } 

                if (bPrintData) {
                    WCHAR   szBuffer[512];
                    swprintf (szBuffer, (LPCWSTR)L"%d\t%I64u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t%u\t",
                        dwThreadId,
                        pObj->llElapsedTime,
                        pObj->dwCollectCount,
                        pObj->dwOpenCount,
                        pObj->dwCloseCount,
                        pObj->dwLockoutCount,
                        pObj->dwErrorCount,
                        pObj->dwExceptionCount,
                        pObj->dwLowerGPViolations,
                        pObj->dwUpperGPViolations,
                        pObj->dwBadPointers,
                        pObj->dwBufferSizeErrors,
                        pObj->dwAlignmentErrors,
                        pObj->dwObjectSizeErrors,
                        pObj->dwInstanceSizeErrors);
                    wprintf (szBuffer);

                    swprintf (szBuffer, (LPCWSTR)L"%I64u\t%I64u\t%u\t%u\n",
                        pObj->llTimeBase,
                        pObj->llFunctionTime,
                        pObj->dwNumObjectsRet,
                        pObj->dwRetBufSize);

                    wprintf (szBuffer);
                }
            } while (--dwLoopCount > 0);

            HeapFree (hProcessHeap, 0, pBuffer);
        }
    }

    // close
    CloseLibrary (pObj);

    return dwStatus;
}


unsigned __stdcall CycleThreadProc( void * lpThreadArg )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    PLOCAL_THREAD_DATA  pData= (PLOCAL_THREAD_DATA)lpThreadArg;
    DWORD dwCycleCount = g_dwCycleCount;
    
    DWORD   dwThisThread = GetCurrentThreadId();

	srand( GetTickCount() );

    do {
		// If the rand flag is set, randomly choose an object to hit
		if ( g_fRand )
		{
			pData= &g_pLTData[rand()%g_dwNumObjects];
		}

        dwStatus = CycleTest(dwThisThread, pData);
    } while (--dwCycleCount > 0);

    return dwStatus;
}


LOCAL_THREAD_DATA* GetLTData( WCHAR* szIniFileName, DWORD* pdwThreadCount )
{
	LOCAL_THREAD_DATA*	pLTRet = NULL;
	WCHAR				wcsReturnBuff[256];
	WCHAR				wcsKeyName[256];
	DWORD				dwCtr = 0;

	GetPrivateProfileStringW( L"Main", L"NumObjects", L"0", wcsReturnBuff, 256, szIniFileName );
	g_dwNumObjects = wcstoul(wcsReturnBuff, NULL, 10);

	GetPrivateProfileStringW( L"Main", L"NumThreads", L"0", wcsReturnBuff, 256, szIniFileName );
	*pdwThreadCount = wcstoul(wcsReturnBuff, NULL, 10);
	if ( *pdwThreadCount < g_dwNumObjects )
	{
		*pdwThreadCount = g_dwNumObjects;
	}

	GetPrivateProfileStringW( L"Main", L"CycleCount", L"0", wcsReturnBuff, 256, szIniFileName );
	g_dwCycleCount = wcstoul(wcsReturnBuff, NULL, 10);

	GetPrivateProfileStringW( L"Main", L"LoopCount", L"0", wcsReturnBuff, 256, szIniFileName );
	g_dwLoopCount = wcstoul(wcsReturnBuff, NULL, 10);

	GetPrivateProfileStringW( L"Main", L"Random", L"0", wcsReturnBuff, 256, szIniFileName );
	g_fRand = wcstoul(wcsReturnBuff, NULL, 10);

	pLTRet = (LOCAL_THREAD_DATA*) HeapAlloc( GetProcessHeap(), 0, g_dwNumObjects * sizeof(LOCAL_THREAD_DATA) );

	if ( NULL != pLTRet )
	{
		for( dwCtr = 0; dwCtr < g_dwNumObjects; dwCtr++ )
		{
			swprintf( wcsKeyName, L"Object%d", dwCtr );
			GetPrivateProfileStringW( L"Main", wcsKeyName, L"PerfProc", wcsReturnBuff, 256, szIniFileName );
			pLTRet[dwCtr].szServiceName = (WCHAR*) HeapAlloc( GetProcessHeap(), 0,
											( wcslen( wcsReturnBuff ) + 1 ) * sizeof(WCHAR) );
			wcscpy( pLTRet[dwCtr].szServiceName, wcsReturnBuff );

			swprintf( wcsKeyName, L"Counter%d", dwCtr );
			GetPrivateProfileStringW( L"Main", wcsKeyName, L"Global", wcsReturnBuff, 256, szIniFileName );
			pLTRet[dwCtr].szQueryString = (WCHAR*) HeapAlloc( GetProcessHeap(), 0,
											( wcslen( wcsReturnBuff ) + 1 ) * sizeof(WCHAR) );
			wcscpy( pLTRet[dwCtr].szQueryString, wcsReturnBuff );

			pLTRet[dwCtr].dwCycleCount = g_dwCycleCount;
			pLTRet[dwCtr].dwLoopCount = g_dwLoopCount;
			pLTRet[dwCtr].bDisplay = TRUE;

		}

	}

	return pLTRet;
}

int
__cdecl 
wmain(
    int argc,
    WCHAR *argv[]
)
{
    DWORD   dwStatus;
    DWORD   dwLoopCount = 0;
    DWORD   dwCycleCount = 0;
    DWORD   dwThreadCount = 0;
	LOCAL_THREAD_DATA*	pCurLTData = NULL;
    HANDLE  hThreads[MAXIMUM_WAIT_OBJECTS];
    DWORD   dwThisThread;
    DWORD   dwTimeout;
    DWORD   dwId;
	WCHAR*	pwcsINIFile = L".\\ctrtest.ini";
	BOOL	fRand = FALSE;
	int		nIndex = 0;

    hProcessHeap = GetProcessHeap();

	if ( argc > 1 )
	{
		pwcsINIFile = argv[1];
	}

	// Load up object/ctr data
	g_pLTData = GetLTData( pwcsINIFile, &dwThreadCount );

	if ( NULL != g_pLTData )
	{
		srand( GetTickCount() );

		// create threads
		for (dwThisThread = 0; dwThisThread < dwThreadCount; dwThisThread++) {

			// If we are randomizing, each thread will randomly bang on a dll
			// so just send NULL.
			if ( g_fRand )
			{
				pCurLTData = NULL;
			}
			else if ( dwThreadCount > g_dwNumObjects )
			{
				pCurLTData = &g_pLTData[dwThisThread % g_dwNumObjects];
			}
			else
			{
				pCurLTData = &g_pLTData[dwThisThread];
			}

			hThreads[dwThisThread] = (HANDLE) _beginthreadex( NULL, 0,
									CycleThreadProc, (void*) pCurLTData, 0, NULL );
		}

//		dwTimeout = 60000 * dwCycleCount;   // allow 1 minute per cycle

		// Let these all run through
		dwStatus = WaitForMultipleObjects (dwThreadCount, hThreads, TRUE, INFINITE);
		if (dwStatus != WAIT_TIMEOUT) dwStatus = ERROR_SUCCESS;
		for (dwThisThread = 0; dwThisThread < dwThreadCount; dwThisThread++) {
			CloseHandle (hThreads[dwThisThread]);
		}

	}

    return (int)dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\ctrtest\ctrtest.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#ifndef _CTRTEST_H_
#define _CTRTEST_H_

#define WBEMPERF_OPEN_PROC_NOT_FOUND    0xC0100002
#define WBEMPERF_COLLECT_PROC_NOT_FOUND 0xC0100003
#define WBEMPERF_CLOSE_PROC_NOT_FOUND   0xC0100004
#define WBEMPERF_OPEN_PROC_FAILURE      0xC0100005
#define WBEMPERF_OPEN_PROC_EXCEPTION    0xC0100006

#define DWORD_PTR	DWORD

//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//

#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))

//    (assumes dword is 4 bytes)
#define ALIGN_ON_DWORD(x) ((VOID *)(((DWORD_PTR)x & 3) ? (((DWORD_PTR)x & ~3) + 4) : ((DWORD_PTR)x)))

#define QWORD_MULTIPLE(x) (((x+sizeof(LONGLONG)-1)/sizeof(LONGLONG))*sizeof(LONGLONG))

//    (assumes quadword is 8 bytes)
#define ALIGN_ON_QWORD(x) ((VOID *)(((DWORD_PTR)x & 7) ? (((DWORD_PTR)x & ~7) + 8) : ((DWORD_PTR)x)))

//
//      constants used by guard page testing
//
#define GUARD_PAGE_SIZE 1024
#define GUARD_PAGE_CHAR 0xA5
#define GUARD_PAGE_DWORD 0xA5A5A5A5

#define  LOG_UNDEFINED  ((LONG)-1)
#define  LOG_NONE       0
#define  LOG_USER       1
#define  LOG_DEBUG      2
#define  LOG_VERBOSE    3

#define     EXT_TEST_UNDEFINED  0
#define     EXT_TEST_ALL        1
#define     EXT_TEST_BASIC      2
#define     EXT_TEST_NONE       3
#define     EXT_TEST_NOMEMALLOC 4



#define WAIT_FOR_AND_LOCK_MUTEX(h) (h != NULL ? WaitForSingleObject(h, 10000) : WAIT_TIMEOUT)
#define RELEASE_MUTEX(h)  (h != NULL ? ReleaseMutex(h) : FALSE)

//
//  Definition of handle table for extensible objects
//
typedef PM_OPEN_PROC    *OPENPROC;
typedef PM_COLLECT_PROC *COLLECTPROC;
typedef PM_QUERY_PROC   *QUERYPROC;
typedef PM_CLOSE_PROC   *CLOSEPROC;

#define EXT_OBJ_INFO_NAME_LENGTH    32

typedef struct _EXT_OBJECT {
        LPVOID      pNext;   // not used
        HANDLE      hMutex;         // sync mutex for this function
        OPENPROC    OpenProc;       // address of the open routine
        LPSTR       szOpenProcName; // open procedure name
        LPWSTR      szLinkageString; // param for open proc
        DWORD       dwOpenTimeout;  // wait time in MS for open proc
        COLLECTPROC CollectProc;    // address of the collect routine
        QUERYPROC   QueryProc;      // address of query proc
        LPSTR       szCollectProcName;  // collect procedure name
        DWORD       dwCollectTimeout;   // wait time in MS for collect proc
        CLOSEPROC   CloseProc;     // address of the close routine
        LPSTR       szCloseProcName;    // close procedure name
        HMODULE     hLibrary ;     // handle returned by LoadLibraryW
        LPWSTR      szLibraryName;  // full path of library
        HKEY        hPerfKey;       // handle to performance sub key fo this service
        DWORD       dwNumObjects;  // number of supported objects
        DWORD       dwObjList[MAX_PERF_OBJECTS_IN_QUERY_FUNCTION];    // address of array of supported objects
        DWORD       dwFlags;        // flags
        LPWSTR      szServiceName;  // service name
        LONGLONG    llLastUsedTime; // FILETIME of last access
// Performance statistics
        LONGLONG    llElapsedTime;  // time spent in call in 100Ns Units
        DWORD       dwCollectCount; // number of times Collect successfully called
        DWORD       dwOpenCount;    // number of Loads & opens
        DWORD       dwCloseCount;   // number of Unloads & closes
        DWORD       dwLockoutCount; // count of lock timeouts
        DWORD       dwErrorCount;   // count of errors (other than timeouts)
        DWORD       dwExceptionCount; // exceptions
        DWORD       dwLowerGPViolations;
        DWORD       dwUpperGPViolations;
        DWORD       dwBadPointers;
        DWORD       dwBufferSizeErrors;
        DWORD       dwAlignmentErrors;
        DWORD       dwObjectSizeErrors;
        DWORD       dwInstanceSizeErrors;
        // last function call values
        LONGLONG    llTimeBase;     // time base frequency
        LONGLONG    llFunctionTime; // time spent in call in 100Ns Units
        DWORD       dwNumObjectsRet; // number of objects returned by collect function
        DWORD       dwRetBufSize;   // buffer size returned by function
} EXT_OBJECT , *PEXT_OBJECT ;


// ext object flags
#define PERF_EO_QUERY_FUNC  ((DWORD)0x00000001)     // use query proc
#define PERF_EO_BAD_DLL     ((DWORD)0x00000002)     // true when DLL ret. error
#define PERF_EO_KEEP_RESIDENT ((DWORD)0x00000004)    // true if lib should not be trimmed
#define PERF_EO_OBJ_IN_QUERY ((DWORD)0x80000000)    // true when in query list


typedef struct _EXT_CTR_PERF_DATA {
        // accumulating functions
        LONGLONG    llElapsedTime;  // cumulative time spent in call in 100Ns Units
        DWORD       dwCollectCount; // number of times Collect successfully called
        DWORD       dwOpenCount;    // number of Loads & opens
        DWORD       dwCloseCount;   // number of Unloads & closes
        DWORD       dwLockoutCount; // count of lock timeouts
        DWORD       dwErrorCount;   // count of errors (other than timeouts)
        DWORD       dwExceptionCount; // exceptions
        DWORD       dwLowerGPViolations;
        DWORD       dwUpperGPViolations;
        DWORD       dwBadPointers;
        DWORD       dwBufferSizeErrors;
        DWORD       dwAlignmentErrors;
        DWORD       dwObjectSizeErrors;
        DWORD       dwInstanceSizeErrors;
        DWORD       dwReserved1;
        // last function call values
        LONGLONG    llTimeBase;     // time base frequency
        LONGLONG    llFunctionTime; // time spent in call in 100Ns Units
        DWORD       dwNumObjects;   // number of objects returned by collect function
        DWORD       dwRetBufSize;   // buffer size returned by function
} EXT_CTR_PERF_DATA, *PEXT_CTR_PERF_DATA;


#endif //_CTRTEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\ctrtest\strings.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/
// strings.cpp
//
// central definition file of common static strings
// these strings SHOULD NOT be localized as they are internal
// to the program and not intended for any display to the user
//
#include "strings.h"

// OLE and  Registry strings
LPCWSTR cszOleRegistryComment   = L"WBEM NT5 Base Perf Provider";
LPCWSTR cszClsidFormatString    = L"Software\\Classes\\CLSID\\\\%s";
LPCWSTR cszThreadingModel       = L"ThreadingModel";
LPCWSTR cszInprocServer         = L"InprocServer32";
LPCWSTR cszClsidKey             = L"Software\\Classes\\CLSID";
LPCWSTR cszPerflibKey           = L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
LPCWSTR cszDLLValue             = L"Library";
LPCWSTR cszObjListValue         = L"Object List";
LPCWSTR cszLinkageKey           = L"\\Linkage";
LPCWSTR cszExportValue          = L"Export";
LPCWSTR cszOpenTimeout          = L"Open Timeout";
LPCWSTR cszCollectTimeout       = L"Collect Timeout";
LPCWSTR cszExtCounterTestLevel  = L"ExtCounterTestLevel";
LPCWSTR cszOpenProcedureWaitTime = L"OpenProcedureWaitTime";
LPCWSTR cszLibraryUnloadTime    = L"Library Unload Time";
LPCWSTR cszKeepResident         = L"Keep Library Resident";
LPCWSTR cszDisablePerformanceCounters = L"Disable Performance Counters";
LPCWSTR cszProviderName         = L"NT5_GenericPerfProvider_V1";
LPCWSTR cszHklmServicesKey      = L"SYSTEM\\CurrentControlSet\\Services";
LPCWSTR cszPerformance          = L"\\Performance";
LPCWSTR cszGlobal               = L"Global";
LPCWSTR cszForeign              = L"FOREIGN";
LPCWSTR cszCostly               = L"COSTLY";
LPCWSTR cszCounter              = L"COUNTER";
LPCWSTR cszExplain              = L"EXPLAIN";
LPCWSTR cszHelp                 = L"HELP";
LPCWSTR cszAddCounter           = L"ADDCOUNTER";
LPCWSTR cszAddHelp              = L"ADDEXPLAIN";
LPCWSTR cszOnly                 = L"ONLY";
LPCWSTR cszBoth                 = L"Both";

LPCSTR  caszOpenValue           = "Open";
LPCSTR  caszCloseValue          = "Close";
LPCSTR  caszCollectValue        = "Collect";
LPCSTR  caszQueryValue          = "Query";

// "well known" property names
LPCWSTR cszPropertyCount        = L"__PROPERTY_COUNT";
LPCWSTR cszClassName            = L"__CLASS";
LPCWSTR cszName                 = L"Name";
LPCWSTR cszTimestampPerfTime    = L"Timestamp_PerfTime";
LPCWSTR cszFrequencyPerfTime    = L"Frequency_PerfTime";
LPCWSTR cszTimestampSys100Ns    = L"Timestamp_Sys100NS";
LPCWSTR cszFrequencySys100Ns    = L"Frequency_Sys100NS";
LPCWSTR cszTimestampObject      = L"Timestamp_Object";
LPCWSTR cszFrequencyObject      = L"Frequency_Object";

// "well known" qualifier names
LPCWSTR cszPerfIndex            = L"PerfIndex";
LPCWSTR cszSingleton            = L"Singleton";
LPCWSTR cszCountertype          = L"countertype";
LPCWSTR cszProvider             = L"Provider";
LPCWSTR cszRegistryKey          = L"registrykey";

// other random strings
LPCWSTR cszSpace                = L" ";
LPCWSTR cszSlash                = L"/";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\datapackets\common\bstrpacket.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#ifndef __BSTRPACKET_H__
#define __BSTRPACKET_H__

// Store the current packing value, then set our own value
#pragma pack( push )
#pragma pack( 1 )

// BSTR Packet.  Packet for marshalling BSTRs
typedef struct tagWBEM_DATAPACKET_BSTR_HEADER
{
	DWORD	dwSizeOfHeader;	// Size of the header struct.  Data immediately follows header.
	DWORD	dwDataSize;		// Size of Data following header.
} WBEM_DATAPACKET_BSTR_HEADER;

typedef WBEM_DATAPACKET_BSTR_HEADER* PWBEM_DATAPACKET_BSTR_HEADER;

// restore packing
#pragma pack( pop )

//
//	Class: CWbemBSTRPacket
//
//	This class is designed to wrapper a data packet that describes a
//	BSTR.  The data structure of this packet is described above.  It
//	is designed to be a helper class for anyone needing to marshal
//	BSTRs into and out of streams.
//

class CWbemBSTRPacket
{
private:
protected:

	PWBEM_DATAPACKET_BSTR_HEADER	m_pBSTRHeader;

public:

	CWbemBSTRPacket( PWBEM_DATAPACKET_BSTR_HEADER pDataPacket = NULL, DWORD dwPacketLength = 0 );
	~CWbemBSTRPacket();

	HRESULT CalculateLength( BSTR bstrValue, DWORD* pdwLength );
	HRESULT MarshalPacket( LPBYTE pbData, DWORD dwLength, BSTR bstrValue, DWORD* pdwLengthUsed );
	HRESULT UnmarshalPacket( BSTR& bstrValue );

	DWORD	GetDataSize( void );
	DWORD	GetTotalSize( void );
	LPBYTE	EndOf( void );

};

inline DWORD CWbemBSTRPacket::GetDataSize( void )
{
	return ( NULL == m_pBSTRHeader ? 0 : m_pBSTRHeader->dwDataSize );
}

inline DWORD CWbemBSTRPacket::GetTotalSize( void )
{
	return ( sizeof(WBEM_DATAPACKET_BSTR_HEADER) + GetDataSize() );
}

inline LPBYTE CWbemBSTRPacket::EndOf( void )
{
	if ( NULL != m_pBSTRHeader )
	{
		return ( (LPBYTE) m_pBSTRHeader + sizeof(WBEM_DATAPACKET_BSTR_HEADER) + GetDataSize() );
	}
	else
	{
		return NULL;
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\datapackets\common\verifyobj.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#ifndef __VERIFYOBJ_H__
#define __VERIFYOBJ_H__

void VerifyObject( IWbemClassObject* pObj1, IWbemClassObject* pObj2 );
void VerifyObject( IWbemClassObject* pObj );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\datapackets\common\objsetstatpacket.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#ifndef __OBJSETSTATPACKET_H__
#define __OBJSETSTATPACKET_H__

#include "wbemdatapacket.h"
#include "bstrpacket.h"
#include "wbemobjpacket.h"

// Store the current packing value, then set our own value
#pragma pack( push )
#pragma pack( 1 )

// BSTR Packet.  Packet for marshalling BSTRs
typedef struct tagWBEM_DATAPACKET_OBJECTSINK_SETSTATUS
{
	DWORD	dwSizeOfHeader;	// Size of the header struct.  Data immediately follows header.
	DWORD	dwDataSize;		// Size of Data following header.
	LONG	lFlags;			// Flags parameter
	HRESULT	hResult;		// HRESULT parameter
} WBEM_DATAPACKET_OBJECTSINK_SETSTATUS;

typedef WBEM_DATAPACKET_OBJECTSINK_SETSTATUS* PWBEM_DATAPACKET_OBJECTSINK_SETSTATUS;

// restore packing
#pragma pack( pop )

//
//	Class: CWbemObjSinkSetStatusPacket
//
//	This class is designed to wrapper a data packet that describes an
//	IWbemObjectSink::SetStatus() operation.  The data structure of this
//	packet is described above.  It makes use of CWbemObjectPacket,
//	CWbemInstancePacket, CWbemClassPacket and CWbemBSTRPacket
//	to walk and analyze data for each of the call parameters.
//

class CWbemObjSinkSetStatusPacket : public CWbemDataPacket
{
private:
protected:

	PWBEM_DATAPACKET_OBJECTSINK_SETSTATUS	m_pObjSinkSetStatus;

public:

	CWbemObjSinkSetStatusPacket( PWBEM_DATAPACKET_HEADER pDataPacket = NULL, DWORD dwPacketLength = 0 );
	~CWbemObjSinkSetStatusPacket();

	HRESULT CalculateLength( BSTR strParam, IWbemClassObject* pObjParam, DWORD* pdwLength );
	HRESULT MarshalPacket( LPBYTE pbData, DWORD dwLength, LONG lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject* pObjParam );
	HRESULT UnmarshalPacket( LONG& lFlags, HRESULT& hResult, BSTR& strParam, IWbemClassObject*& pObjParam );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\datapackets\common\objsetstatpacket.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <wbemcomn.h>
#include <fastall.h>
#include "objsetstatpacket.h"

///////////////////////////////////////////////////////////////////
//
//	Function:	CWbemObjSinkSetStatusPacket::CWbemObjSinkSetStatusPacket
//	
//	Class Constructor
//
//	Inputs:
//				PWBEM_DATAPACKET_HEADER		pDataPacket - Memory block.
//				DWORD						dwPacketLength - Block Length.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:	Data must be supplied to this class for Unmarshaling
//				to succeed.
//
///////////////////////////////////////////////////////////////////

CWbemObjSinkSetStatusPacket::CWbemObjSinkSetStatusPacket( PWBEM_DATAPACKET_HEADER pDataPacket /* = NULL */, DWORD dwPacketLength /* = 0 */ )
:	CWbemDataPacket( pDataPacket, dwPacketLength ),
	m_pObjSinkSetStatus( NULL )
{
	if ( NULL != pDataPacket )
	{
		m_pObjSinkSetStatus = (PWBEM_DATAPACKET_OBJECTSINK_SETSTATUS) ((LPBYTE) pDataPacket + sizeof(WBEM_DATAPACKET_HEADER) );
	}
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CWbemObjSinkSetStatusPacket::~CWbemObjSinkSetStatusPacket
//	
//	Class Destructor
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:	None.
//
///////////////////////////////////////////////////////////////////

CWbemObjSinkSetStatusPacket::~CWbemObjSinkSetStatusPacket()
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CWbemObjSinkSetStatusPacket::CalculateLength
//	
//	Calculates the length needed to packetize the supplied data.
//
//	Inputs:
//				BSTR				strParam - BSTR Parameter.
//				IWbemClassObject*	pObjParam - Object parameter.
//
//	Outputs:
//				DWORD*				pdwLength - Calculated Length
//
//	Returns:
//				WBEM_S_NO_ERROR	if success.
//
//	Comments:	This function calculates the size of a buffer required
//				to marshal this packet.  The parameters can be NULL.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemObjSinkSetStatusPacket::CalculateLength( BSTR strParam, IWbemClassObject* pObjParam, DWORD* pdwLength )
{
	HRESULT	hr = WBEM_S_NO_ERROR;
	DWORD	dwLength = sizeof( WBEM_DATAPACKET_HEADER ) + sizeof( WBEM_DATAPACKET_OBJECTSINK_SETSTATUS );
	DWORD	dwRequiredLength = 0;

	// Do the BSTR first
	CWbemBSTRPacket	BSTRPacket;

	hr = BSTRPacket.CalculateLength( strParam, &dwRequiredLength );

	if ( SUCCEEDED( hr ) )
	{
		dwLength += dwRequiredLength;

		// Now handle the object packet
		CWbemObjectPacket	objectPacket;

		hr = objectPacket.CalculatePacketLength( pObjParam, &dwRequiredLength );

		if ( SUCCEEDED( hr ) )
		{
			dwLength += dwRequiredLength;
		}
	}

	if ( SUCCEEDED( hr ) )
	{
		*pdwLength = dwLength;
	}
	
	return hr;

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CWbemObjSinkSetStatusPacket::MarshalPacket
//	
//	Marshals the supplied data into a buffer.
//
//	Inputs:
//				LPBYTE				pbData - Buffer to write packet into.
//				DWORD				dwLength - Length of buffer
//				LONG				lFlags - Flags Parameter
//				HRESULT				hResult - HRESULT parameter.
//				BSTR				strParam - BSTR parameter
//				IWbemClassObject*	pObjParam - Object parameter.
//
//	Outputs:
//				None.
//
//	Returns:
//				WBEM_S_NO_ERROR	if success.
//
//	Comments:	The supplied parameters are marshaled into the supplied
//				buffer.  Note that the buffer MUST be large enough for
//				the parameters to do their dance.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemObjSinkSetStatusPacket::MarshalPacket( LPBYTE pbData, DWORD dwLength, LONG lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject* pObjParam )
{
	HRESULT	hr = WBEM_E_FAILED;

	// Setup the main header first
	hr = SetupDataPacketHeader( pbData, dwLength, dwLength - sizeof(WBEM_DATAPACKET_HEADER), WBEM_DATAPACKETTYPE_OBJECTSINK_SETSTATUS, 0 );

	if ( SUCCEEDED( hr ) )
	{
		// Account for the main header
		pbData += sizeof(WBEM_DATAPACKET_HEADER);
		dwLength -= sizeof(WBEM_DATAPACKET_HEADER);

		// Fill out the SetStatus Header
		PWBEM_DATAPACKET_OBJECTSINK_SETSTATUS pSetStatusHeader = (PWBEM_DATAPACKET_OBJECTSINK_SETSTATUS) pbData;

		pSetStatusHeader->dwSizeOfHeader = sizeof(WBEM_DATAPACKET_OBJECTSINK_SETSTATUS);
		pSetStatusHeader->dwDataSize = dwLength - sizeof(WBEM_DATAPACKET_OBJECTSINK_SETSTATUS);
		pSetStatusHeader->lFlags = lFlags;
		pSetStatusHeader->hResult = hResult;

		// Go past the header
		pbData += sizeof(WBEM_DATAPACKET_OBJECTSINK_SETSTATUS);
		dwLength -= sizeof(WBEM_DATAPACKET_OBJECTSINK_SETSTATUS);

		CWbemBSTRPacket	bstrPacket;
		DWORD			dwLengthUsed = 0;

		hr = bstrPacket.MarshalPacket( pbData, dwLength, strParam, &dwLengthUsed );

		if ( SUCCEEDED( hr ) )
		{
			// Account for the BSTR
			pbData += dwLengthUsed;
			dwLength -= dwLengthUsed;

			CWbemObjectPacket	objectPacket;

			// Write out empty instance if we have no objct, otherwise, let the appropriate
			// class do this for us.
			if ( NULL != pObjParam )
			{
				CWbemObject*	pWbemObject = (CWbemObject*) pObjParam;

				// Ask if it's an instance
				if ( pWbemObject->IsInstance() )
				{
					// Write out an instance
					CWbemInstancePacket	instancePacket;
					GUID				guid;

					ZeroMemory( &guid, sizeof(GUID) );
					hr = instancePacket.WriteToPacket( pbData, dwLength, pObjParam, guid, &dwLengthUsed );
				}
				else
				{
					// Write out a class
					CWbemClassPacket	classPacket;
					hr = classPacket.WriteToPacket( pbData, dwLength, pObjParam, &dwLengthUsed );
				}
			}
			else
			{
				// The empty packet HACK
				hr = objectPacket.WriteEmptyHeader( pbData, dwLength );
				dwLengthUsed = sizeof(WBEM_DATAPACKET_OBJECT_HEADER);
			}

			// Increment and decrement (although it's probably a non-isssue since this
			// was the last parameter).
			if ( SUCCEEDED( hr ) )
			{
				pbData += dwLengthUsed;
				dwLength -= dwLengthUsed;
			}

		}	// IF BSTRPacket succeeded

	}	// IF SetupDataPacketHeader

	return hr;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CWbemObjSinkSetStatusPacket::UnmarshalPacket
//	
//	Unmarshals data from a buffer into the supplied parameters.
//
//	Inputs:
//				None.
//	Outputs:
//				LONG&				lFlags - Flags Parameter
//				HRESULT&			hResult - HRESULT parameter.
//				BSTR&				strParam - BSTR parameter
//				IWbemClassObject*&	pObjParam - Object parameter.
//
//	Returns:
//				WBEM_S_NO_ERROR	if success.
//
//	Comments:	If function succeeds, the caller is responsible for cleaning
//				up and freeing the string parameter and te object parameter.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemObjSinkSetStatusPacket::UnmarshalPacket( LONG& lFlags, HRESULT& hResult, BSTR& strParam, IWbemClassObject*& pObjParam )
{
	HRESULT	hr = WBEM_E_FAILED;
	LPBYTE	pbData = (LPBYTE) m_pObjSinkSetStatus;

	// Check that the underlying BLOB is OK
	hr = IsValid();

	if ( SUCCEEDED( hr ) )
	{
		lFlags = m_pObjSinkSetStatus->lFlags;
		hResult = m_pObjSinkSetStatus->hResult;

		// Now, read in the bstr and then the object
		pbData += sizeof(WBEM_DATAPACKET_OBJECTSINK_SETSTATUS);

		CWbemBSTRPacket	bstrPacket( (PWBEM_DATAPACKET_BSTR_HEADER) pbData );

		hr = bstrPacket.UnmarshalPacket( strParam );

		if ( SUCCEEDED( hr ) )
		{
			// Go to the end of the packet, and then handle the object
			pbData = bstrPacket.EndOf();

			CWbemObjectPacket	objectPacket( (PWBEM_DATAPACKET_OBJECT_HEADER) pbData );

			switch ( objectPacket.GetObjectType() )
			{
				case WBEMOBJECT_NONE:
				{
					// No object, so the parameter should be set to NULL.
					hr = WBEM_S_NO_ERROR;
					pObjParam = NULL;
				}
				break;

				case WBEMOBJECT_CLASS_FULL:
				{
					CWbemClassPacket	classPacket( objectPacket );
					CWbemClass*			pClass = NULL;

					hr = classPacket.GetWbemClassObject( &pClass );
					
					if ( SUCCEEDED( hr ) )
					{
						pObjParam = (IWbemClassObject*) pClass;
					}
				}
				break;

				case WBEMOBJECT_INSTANCE_FULL:
				{
					CWbemInstancePacket	instancePacket( objectPacket );
					CWbemInstance*		pInstance = NULL;
					GUID				guidClassId;

					hr = instancePacket.GetWbemInstanceObject( &pInstance, guidClassId );
					
					if ( SUCCEEDED( hr ) )
					{
						pObjParam = (IWbemClassObject*) pInstance;
					}
				}
				break;

				default:
				{
					// What is this?
					hr = WBEM_E_FAILED;
				}

			}	// SWITCH

		}	// IF BSTRPacket.Unmarshal

	}	// IF IsValid

	return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\datapackets\client\packetclient.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// OBJINTERNALSTESTDlg.cpp : implementation file
//

#define _WIN32_WINNT 0x0400

#include <windows.h>
//#include <objbase.h>
#include <stdio.h>
#include <wbemcli.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include <cominit.h>
#include <fastall.h>
#include "objindpacket.h"
#include "verifyobj.h"

//#define TEST_CLASS	L"Win32_BIOS"
#define TEST_CLASS	L"Win32_DiskPartition"
//#define TEST_CLASS	L"Win32_IRQResource"
//#define TEST_CLASS	L"Win32_Directory"

BOOL SendDataLength( HANDLE hPipe, DWORD dwLength )
{
	BOOL	fReturn = FALSE;
	
	DWORD	dwBytesRead = 0,
			dwServerLength = 0;

	printf ( "Sending Data Length of %d bytes\n", dwLength );

	fReturn = TransactNamedPipe( hPipe,
				&dwLength,
				sizeof(DWORD),
				&dwServerLength,
				sizeof(DWORD),
				&dwBytesRead,
				NULL );

	if ( dwBytesRead == sizeof(DWORD) )
	{
		fReturn = ( dwServerLength == sizeof(DWORD) );
		printf ( "Successfully sent data Length\n" );
	}
	else
	{
		fReturn = FALSE;
		printf ( "Unable to send data Length\n" );
	}

	return fReturn;
}

BOOL SendDataPacket( HANDLE hPipe, DWORD dwLength, LPBYTE pbData )
{
	BOOL	fReturn = FALSE;
	
	DWORD	dwBytesRead = 0,
			dwServerLength = 0;

	printf ( "Sending %d byte Data Packet\n", dwLength );

	fReturn = TransactNamedPipe( hPipe,
				pbData,
				dwLength,
				&dwServerLength,
				sizeof(DWORD),
				&dwBytesRead,
				NULL );

	if ( dwBytesRead == sizeof(DWORD) )
	{
		fReturn = ( dwLength == dwServerLength );
		printf ( "Successfully sent data packet\n" );
	}
	else
	{
		fReturn = FALSE;
		printf ( "Unable to send data packet\n" );
	}

	return fReturn;
}

BOOL SendPacket( HANDLE hPipe, DWORD dwLength, LPBYTE pbData )
{
	BOOL fSuccess = SendDataLength( hPipe, dwLength );

	if ( fSuccess )
	{
		fSuccess = SendDataPacket( hPipe, dwLength, pbData );
	}

	return fSuccess;
}

BOOL ConnectNamedPipe( LPHANDLE	phPipe, LPCTSTR pszMachineName )
{
   BOOL fSuccess = FALSE;
   HANDLE hPipe;
   char szPipeName[256];

   sprintf( szPipeName, "\\\\%s\\pipe\\wbemdatapacket", pszMachineName );

   printf( "Connecting to named pipe server: %s\n", pszMachineName );

     hPipe = CreateFile( 
         szPipeName,   // pipe name 
         GENERIC_READ |  // read and write access 
         GENERIC_WRITE, 
         0,              // no sharing 
         NULL,           // no security attributes
         OPEN_EXISTING,  // opens existing pipe 
         0,              // default attributes 
         NULL);          // no template file 
 
   // Break if the pipe handle is valid. 
 
      if (hPipe != INVALID_HANDLE_VALUE) 
	  {

		  printf( "Successfuly connected to named pipe server\n" );

		// The pipe connected; change to message-read mode. 
 
		DWORD	dwMode = PIPE_READMODE_MESSAGE; 

		fSuccess = SetNamedPipeHandleState( 
						  hPipe,    // pipe handle 
						  &dwMode,  // new pipe mode 
						  NULL,     // don't set maximum bytes 
						  NULL);    // don't set maximum time 
		if ( fSuccess ) 
		{
			*phPipe = hPipe;
		}

	  }
	  else
	  {
		  printf( "Unable to connect to named pipe server\n" );
	  }

	  return fSuccess;
}

void SinkTest( BOOL fRemote, LPCTSTR pszMachineName )
{
	IWbemLocator*		pWbemLocator = NULL;

	HRESULT hr = CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (void**) &pWbemLocator );

	if ( SUCCEEDED(hr) )
	{
		LPWSTR	lpwcsMachineName = L"SANJNECK";
		LPWSTR	lpwcsNameSpace = L"ROOT\\CIMV2";
		WCHAR	wszNameSpace[255];

		swprintf( wszNameSpace, L"\\\\%s\\%s", lpwcsMachineName, lpwcsNameSpace );

		// Name space to connect to
		BSTR	bstrNameSpace = SysAllocString( wszNameSpace );

		LPWSTR	lpwcsObjectPath = L"Win32_SerialPort.DeviceID=\"COM1\"";
		BSTR	bstrObjectPath = NULL;

		bstrObjectPath = SysAllocString( lpwcsObjectPath );

		IWbemServices*	pNameSpace = NULL;

		hr = pWbemLocator->ConnectServer(	bstrNameSpace,	// NameSpace Name
											NULL,			// UserName
											NULL,			// Password
											NULL,			// Locale
											0L,				// Security Flags
											NULL,			// Authority
											NULL,			// Wbem Context
											&pNameSpace		// Namespace
											);

		if ( SUCCEEDED(hr) )
		{
			SetInterfaceSecurity(pNameSpace, NULL, NULL, NULL, 
 								RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE);

			BSTR	bstrClass = SysAllocString( TEST_CLASS );

			IEnumWbemClassObject*	pEnum = NULL;

			printf( "Querying WINMGMT for instances of class: %S\n", TEST_CLASS );

			hr = pNameSpace->CreateInstanceEnum( bstrClass,
												WBEM_FLAG_FORWARD_ONLY,
												NULL,
												&pEnum );

			// Walk the enumerator
			if ( SUCCEEDED( hr ) )
			{

				printf( "Successfully received instances.\n" );

				LPBYTE				pbDataPacket = NULL;
				DWORD				dwDataBlockSize = 0;
				DWORD				dwActualSizeOfPacket = 0;

				// Map and cache objects for marshalling and unmarshalling
				// class objects successfully
				CWbemClassToIdMap	classtoidmap;
				CWbemClassCache		classCache;

				// GUID and flag required for Marshalling packet successfuly
				// For multiple class objects, we will need arrays of these
				GUID				aguidClassId[100];
				BOOL				afSendFullInstance[100];

				IWbemClassObject*	apObjectArray[100];

				BOOL				fConnected = FALSE;
				HANDLE				hPipe = NULL;

				// Get each object and try to get a data packet out of it
				while ( SUCCEEDED( hr ) )
				{
					ULONG	ulNumReturned = 0;

					ZeroMemory( apObjectArray, sizeof(apObjectArray) );

					// Go through the object 100 at a time
					hr = pEnum->Next( WBEM_INFINITE,
									100,
									apObjectArray,
									&ulNumReturned );

					// Calculate our packet size and attempt to marshal and
					// unmarshal the packet.

					if ( SUCCEEDED( hr ) && ulNumReturned > 0 )
					{
						CWbemObjSinkIndicatePacket	marshalPacket;
						DWORD	dwLength = 0;

						hr = marshalPacket.CalculateLength( ulNumReturned, apObjectArray, &dwLength, classtoidmap, aguidClassId, afSendFullInstance );
				
						if ( SUCCEEDED( hr ) )
						{
							BYTE* pbData = new BYTE[dwLength];

							hr = marshalPacket.MarshalPacket( pbData, dwLength, ulNumReturned, apObjectArray, aguidClassId, afSendFullInstance );
				
							if ( SUCCEEDED( hr ) )
							{

								// Send packets to remote server if flag is set
								if ( fRemote )
								{

									if ( !fConnected )
									{
										fConnected = ConnectNamedPipe( &hPipe, pszMachineName );

										if ( !fConnected )
										{
											break;
										}
									}

									if ( fConnected )
									{
										printf( "Sending %d objects to server\n", ulNumReturned );
										SendPacket( hPipe, dwLength, pbData );
									}

								}
								else
								{
									// Unmarshal locally

									// Unmarshal the packet and free up the newly allocated
									// object when we are done.

									LONG				lCount;
									IWbemClassObject**	apUnmarshaledObjects = NULL;

									CWbemObjSinkIndicatePacket	unmarshalPacket( pbData, dwLength );

									hr = unmarshalPacket.UnmarshalPacket( lCount, apUnmarshaledObjects, classCache );

									if ( SUCCEEDED( hr ) )
									{
										for ( int x = 0; x < lCount; x++ )
										{
											// Compare objects for like values
											VerifyObject( apObjectArray[x], apUnmarshaledObjects[x] );
										}

										// Traverse the array and release all the objects
										for ( long lCtr = 0; lCtr < lCount; lCtr++ )
										{
											apUnmarshaledObjects[lCtr]->Release();
										}

										delete [] apUnmarshaledObjects;

									}	// IF UnmarshalPacket

								}

							}	// IF MarshalPacket

							delete [] pbData;

						}	// IF CalculateLength

						// We are done with the main object.

						// Clean up the objects
						for ( int x = 0; x < ulNumReturned; x++ )
						{
							apObjectArray[x]->Release();
						}

					}
					else if ( SUCCEEDED( hr ) )
					{
						hr = WBEM_E_FAILED;						
					}

				}	// WHILE SUCCEEDED( hr )

				// Close the named pipe
				CloseHandle( hPipe );

				pEnum->Release();

			}

			// Done with it.
			pNameSpace->Release();

		}	// IF Got NameSpace

		// Done with it.
		pWbemLocator->Release();

		// Cleanup BEASTERS
		SysFreeString( bstrObjectPath );
		SysFreeString( bstrNameSpace );

	}	// IF Got WbemLocator
}


///////////////////////////////////////////////////////////////////
//
//	Function:	main
//
//	Entry point function to exercise IWbemObjectInternals interface.
//
///////////////////////////////////////////////////////////////////

int main( int argc, char *argv[] )
{
	char	szMachineName[256];
	CoInitializeEx( 0, COINIT_MULTITHREADED );
	LPSTR	pszMachineName = szMachineName;
	DWORD	dwSizeBuffer = sizeof(szMachineName);

	InitializeSecurity(RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE );

	GetComputerName( szMachineName, &dwSizeBuffer );

	BOOL	fRemote = FALSE;

	// See if we were told to go remote or not.
	if ( argc > 1 && _stricmp( argv[1], "/Remote" ) == 0 )
	{
		fRemote = TRUE;

		if ( argc > 2 )
		{
			pszMachineName = argv[2];
		}
	}

	SinkTest( fRemote, pszMachineName );

	CoUninitialize();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\datapackets\common\verifyobj.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <wbemcomn.h>
#include <fastall.h>
#include "verifyobj.h"

void VerifyObject( IWbemClassObject* pObj1, IWbemClassObject* pObj2 )
{
	printf( "VerifyObject() Begin\n");

	HRESULT	hr1 = pObj1->BeginEnumeration( 0 );
	HRESULT hr2 = pObj2->BeginEnumeration( 0 );

	if ( SUCCEEDED( hr2 ) && SUCCEEDED( hr2 ) )
	{
		printf( "VerifyObject() Starting Enumeration\n");
	}

	while ( SUCCEEDED( hr1) && SUCCEEDED( hr2) )
	{
		BSTR	bstrPropertyName1 = NULL,
				bstrPropertyName2 = NULL;
		VARIANT	v1, v2;
		CIMTYPE	type1, type2;

		hr1 = pObj1->Next( 0, &bstrPropertyName1, &v1, &type1, NULL );
		hr2 = pObj2->Next( 0, &bstrPropertyName2, &v2, &type2, NULL );

		if ( SUCCEEDED( hr1 ) && SUCCEEDED( hr2 ) && WBEM_S_NO_MORE_DATA != hr1 ) 
		{
			if ( v1.vt == v2.vt )
			{
				if ( v1.vt == VT_BSTR && v2.vt == VT_BSTR )
				{
					if ( wcscmp( v1.bstrVal, v2.bstrVal ) == 0 )
					{
						wprintf( L"Property Match: %s = %s\n", bstrPropertyName1, v1.bstrVal );
					}
					else
					{
						wprintf( L"Property Mismatch: %s = %s\n", bstrPropertyName1, v1.bstrVal );
					}
				}
			}
			else
			{
				wprintf( L"Property Mismatch: %s Non-string property.\n", bstrPropertyName1 );
			}


			VariantClear( &v1 );
			VariantClear( &v2 );
			SysFreeString( bstrPropertyName1 );
			SysFreeString( bstrPropertyName2 );

		}
		else if ( hr1 == WBEM_S_NO_MORE_DATA )
		{
			printf( "VerifyObject() Enumeration Complete\n");

			hr1 = WBEM_E_FAILED;
		}

	}

	pObj1->EndEnumeration();
	pObj2->EndEnumeration();

	printf( "VerifyObject() Over\n\n" );

}

void VerifyObject( IWbemClassObject* pObj )
{
	printf( "VerifyObject() Begin\n");

	HRESULT	hr = pObj->BeginEnumeration( 0 );

	if ( SUCCEEDED( hr ) )
	{
		printf( "VerifyObject() Starting Enumeration\n");
	}

	while ( SUCCEEDED( hr) )
	{
		BSTR	bstrPropertyName = NULL;
		VARIANT	v;
		CIMTYPE	type;

		hr = pObj->Next( 0, &bstrPropertyName, &v, &type, NULL );

		if ( SUCCEEDED( hr ) && WBEM_S_NO_MORE_DATA != hr ) 
		{
			if ( v.vt == VT_BSTR )
			{
				wprintf( L"Property: %s = %s\n", bstrPropertyName, v.bstrVal );
			}


			VariantClear( &v );
			SysFreeString( bstrPropertyName );

		}
		else if ( hr == WBEM_S_NO_MORE_DATA )
		{
			printf( "VerifyObject() Enumeration Complete\n");

			hr = WBEM_E_FAILED;
		}

	}

	pObj->EndEnumeration();

	printf( "VerifyObject() Over\n\n" );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\ctrtest\strings.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// strings.h
//
// central definition file of common static strings
// these strings SHOULD NOT be localized as they are internal
// to the program and not intended for any display to the user
//
#include "windows.h"

#ifdef __cplusplus
extern "C" {
#endif

// single character constants
#define wcSpace     L' '
#define wcSlash     L'/'
#define wcPoundSign L'#'
#define wc_0        L'0'
#define wc_a        L'a'
#define wc_A        L'A'
#define wc_E        L'E'
#define wc_F        L'F'
#define wc_P        L'P'
#define wc_R        L'R'
#define wc_z        L'z'
   
// OLE and  Registry strings
extern LPCWSTR cszOleRegistryComment;
extern LPCWSTR cszClsidFormatString;
extern LPCWSTR cszThreadingModel;
extern LPCWSTR cszInprocServer;
extern LPCWSTR cszClsidKey;
extern LPCWSTR cszPerflibKey;
extern LPCWSTR cszDLLValue;
extern LPCWSTR cszObjListValue;
extern LPCWSTR cszLinkageKey;
extern LPCWSTR cszExportValue;
extern LPCWSTR cszOpenTimeout;
extern LPCWSTR cszCollectTimeout;
extern LPCWSTR cszExtCounterTestLevel;
extern LPCWSTR cszOpenProcedureWaitTime;
extern LPCWSTR cszLibraryUnloadTime;
extern LPCWSTR cszKeepResident;
extern LPCWSTR cszDisablePerformanceCounters;
extern LPCWSTR cszProviderName;
extern LPCWSTR cszHklmServicesKey;
extern LPCWSTR cszPerformance;
extern LPCWSTR cszGlobal;
extern LPCWSTR cszForeign;
extern LPCWSTR cszCostly;
extern LPCWSTR cszCounter;
extern LPCWSTR cszExplain;
extern LPCWSTR cszHelp;
extern LPCWSTR cszAddCounter;
extern LPCWSTR cszAddHelp;
extern LPCWSTR cszOnly;
extern LPCWSTR cszBoth;

extern LPCSTR  caszOpenValue;
extern LPCSTR  caszCloseValue;
extern LPCSTR  caszCollectValue;
extern LPCSTR  caszQueryValue;

// "well known" property names
extern LPCWSTR cszPropertyCount;
extern LPCWSTR cszClassName;
extern LPCWSTR cszName;
extern LPCWSTR cszTimestampPerfTime;
extern LPCWSTR cszFrequencyPerfTime;
extern LPCWSTR cszTimestampSys100Ns;
extern LPCWSTR cszFrequencySys100Ns;
extern LPCWSTR cszTimestampObject;
extern LPCWSTR cszFrequencyObject;

// "well known" qualifier names
extern LPCWSTR cszPerfIndex;
extern LPCWSTR cszSingleton;
extern LPCWSTR cszCountertype;
extern LPCWSTR cszProvider;
extern LPCWSTR cszRegistryKey;

// other random strings
extern LPCWSTR cszSpace;
extern LPCWSTR cszSlash;

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\datapackets\common\bstrpacket.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <wbemcomn.h>
#include <fastall.h>
#include "bstrpacket.h"

///////////////////////////////////////////////////////////////////
//
//	Function:	CWbemBSTRPacket::CWbemBSTRPacket
//	
//	Class Constructor
//
//	Inputs:
//				PWBEM_DATAPACKET_BSTR_HEADER	pDataPacket - Memory block.
//				DWORD							dwPacketLength - Block Length.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:	Data must be supplied to this class for Unmarshaling
//				to succeed.
//
///////////////////////////////////////////////////////////////////

CWbemBSTRPacket::CWbemBSTRPacket( PWBEM_DATAPACKET_BSTR_HEADER pDataPacket, DWORD dwPacketLength )
:	m_pBSTRHeader( pDataPacket )
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CWbemBSTRPacket::~CWbemBSTRPacket
//	
//	Class Destructor
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:	None.
//
///////////////////////////////////////////////////////////////////

CWbemBSTRPacket::~CWbemBSTRPacket()
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CWbemObjSinkIndicatePacket::CalculateLength
//	
//	Calculates the length needed to packetize the supplied data.
//
//	Inputs:
//				BSTR				bstrValue - BSTR Parameter.
//
//	Outputs:
//				DWORD*				pdwLength - Calculated Length
//
//	Returns:
//				WBEM_S_NO_ERROR	if success.
//
//	Comments:	This function calculates the size of a buffer required
//				to marshal this packet.  bstrValue can be NULL.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemBSTRPacket::CalculateLength( BSTR bstrValue, DWORD* pdwLength )
{
	HRESULT hr = WBEM_S_NO_ERROR;

	// Minimum size is the header
	*pdwLength = sizeof(WBEM_DATAPACKET_BSTR_HEADER);

	// NULL is NOT an error
	if ( bstrValue != NULL )
	{
		// Account for the string data, remembering that the NULL terminator
		// should be accounted for, and that we are handling WCHARs
		DWORD	dwStrLength = ( wcslen( bstrValue ) + 1 ) * sizeof(WCHAR);
		*pdwLength += dwStrLength;
	}

	return hr;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CWbemObjSinkIndicatePacket::MarshalPacket
//	
//	Marshals the supplied data into a buffer.
//
//	Inputs:
//				LPBYTE				pbData - Buffer to write packet into.
//				DWORD				dwLength - Length of buffer
//				BSTR				bstrValue - BSTR parameter
//
//	Outputs:
//				DWORD*				pdwLengthUsed - Length of data actually
//													used.
//
//	Returns:
//				WBEM_S_NO_ERROR	if success.
//
//	Comments:	The supplied parameters are marshaled into the supplied
//				buffer.  Note that the buffer MUST be large enough for
//				the parameters to go into.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemBSTRPacket::MarshalPacket( LPBYTE pbData, DWORD dwLength, BSTR bstrValue, DWORD* pdwLengthUsed )
{
	HRESULT hr = WBEM_S_NO_ERROR;
	DWORD	dwStrLength = 0;

	if ( NULL != bstrValue )
	{
		dwStrLength = ( wcslen( bstrValue ) + 1 ) * sizeof(WCHAR);
	}

	// Ensure the buffer will be big enough
	if ( dwLength >= ( dwStrLength + sizeof(WBEM_DATAPACKET_BSTR_HEADER) ) )
	{
		PWBEM_DATAPACKET_BSTR_HEADER	pBSTRHeader = (PWBEM_DATAPACKET_BSTR_HEADER) pbData;

		// This is the header
		pBSTRHeader->dwSizeOfHeader = sizeof(WBEM_DATAPACKET_BSTR_HEADER);
		pBSTRHeader->dwDataSize = dwStrLength;

		// Jump pbData and then set the string as applicable
		pbData += sizeof(WBEM_DATAPACKET_BSTR_HEADER);

		if ( NULL != bstrValue )
		{
			wcscpy( (WCHAR*) pbData, bstrValue );
		}
		
	}
	else
	{
		hr = WBEM_E_BUFFER_TOO_SMALL;
	}

	// How much space did we use?
	if ( SUCCEEDED( hr ) )
	{
		*pdwLengthUsed = dwStrLength + sizeof(WBEM_DATAPACKET_BSTR_HEADER);
	}

	return hr;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CWbemBSTRPacket::UnmarshalPacket
//	
//	Unmarshals data from a buffer into the supplied parameters.
//
//	Inputs:
//				None.
//	Outputs:
//				BSTR&				bstrValue - BSTR parameter
//
//	Returns:
//				WBEM_S_NO_ERROR	if success.
//
//	Comments:	If function succeeds, the caller is responsible for cleaning
//				up and freeing the string parameter.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemBSTRPacket::UnmarshalPacket( BSTR& bstrValue )
{
	HRESULT hr = WBEM_S_NO_ERROR;

	if ( NULL != m_pBSTRHeader )
	{
		if ( m_pBSTRHeader->dwDataSize > 0 )
		{
			LPBYTE	pbData = (LPBYTE) m_pBSTRHeader;
			pbData += sizeof(WBEM_DATAPACKET_BSTR_HEADER);
			bstrValue = SysAllocString( (WCHAR*) pbData );

			// Record whether or not this call failed.
			if ( NULL == bstrValue )
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}
		}
		else
		{
			bstrValue = NULL;
		}
	}
	else
	{
		hr = WBEM_E_FAILED;
	}
	return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\evilperf\datagen.h ===
/*++ 

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

      DATAGEN.h

Abstract:

    Header file for the signal generator performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Jul-1995

Revision History:


--*/

#ifndef _DATAGEN_H_
#define _DATAGEN_H_
 
//
//  insure packing is done to the 8 byte align longlong data values. This
//  will eliminate alignment faults on RISC platforms. The fields can be 
//  manually arranged to minimize or eliminate wasted space if necessary.
//
#pragma pack (8)

//
//  Extensible Object definitions
//

//  Update the following sort of define when adding an object type.

#define EVILPERF_NUM_PERF_OBJECT_TYPES 1

//----------------------------------------------------------------------------

//
//  Perf Gen Resource object type counter definitions.
//
//  This is the counter structure presently returned by the generator
//

typedef struct _EVILPERF_DATA_DEFINITION {
    PERF_OBJECT_TYPE		ObjectType;		
    PERF_COUNTER_DEFINITION	Counter1Def;	
    PERF_COUNTER_DEFINITION	Counter2Def;	
    PERF_COUNTER_DEFINITION	Counter3Def;	
    PERF_COUNTER_DEFINITION Counter4Def;	
} EVILPERF_DATA_DEFINITION;

//
// This is the block of data that corresponds to each instance of the 
// object. This structure will immediately follow the instance definition
// data structure
//

typedef struct _EVILPERF_COUNTER_BLOCK {
    PERF_COUNTER_BLOCK      CounterBlock;
    DWORD                   dwCounter1;		//SineWaveValue;
    DWORD                   dwCounter2;		//TriangleWaveValue;
    DWORD                   dwCounter3;		//SquareWaveValue;
    DWORD                   dwCounter4;		//ConstantValue;
} EVILPERF_COUNTER_BLOCK;

#pragma pack ()

#endif //_DATAGEN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\eventprov\precomp.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>

#define COREPROX_POLARITY __declspec( dllexport )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\eventprov\server.cpp ===
//***************************************************************************
//
//  Copyright (c) 1996-2001, Microsoft Corporation, All rights reserved
//
//  SERVER.CPP
//
//***************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <time.h>
#include <locale.h>
#include <initguid.h>


/////////////////////////////////////////////////////////////////////////////
//
//  BEGIN CLSID SPECIFIC SECTION
//
//

#include <wbemidl.h>

#include <evprov.h>


// {4916157A-FBE7-11d1-AEC4-00C04FB68820}
DEFINE_GUID(CLSID_MyEventProvider, 
0x4916157a, 0xfbe7, 0x11d1, 0xae, 0xc4, 0x0, 0xc0, 0x4f, 0xb6, 0x88, 0x20);


#define IMPLEMENTED_CLSID           CLSID_MyEventProvider
#define SERVER_REGISTRY_COMMENT     L"WBEM Test Provider"
#define CPP_CLASS_NAME              CMyEventProvider
#define INTERFACE_CAST              (IWbemProviderInit *)

//
//  END CLSID SPECIFIC SECTION
//
/////////////////////////////////////////////////////////////////////////////




HINSTANCE g_hInstance;
static ULONG g_cLock = 0;

void ObjectCreated()    { g_cLock++; }
void ObjectDestroyed() { g_cLock--; }


//***************************************************************************
//
//  class CFactory
//
//  Generic implementation of IClassFactory for CWbemLocator.
//
//***************************************************************************

class CFactory : public IClassFactory
{
    ULONG           m_cRef;
    CLSID           m_ClsId;

public:
    CFactory(const CLSID & ClsId);
    ~CFactory();

    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IClassFactory members
    //
    STDMETHODIMP     CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP     LockServer(BOOL);
};




//***************************************************************************
//
//  DllMain
//
//  Dll entry point.
//
//  PARAMETERS:
//
//      HINSTANCE hinstDLL      The handle to our DLL.
//      DWORD dwReason          DLL_PROCESS_ATTACH on load,
//                              DLL_PROCESS_DETACH on shutdown,
//                              DLL_THREAD_ATTACH/DLL_THREAD_DETACH otherwise.
//      LPVOID lpReserved       Reserved
//
//  RETURN VALUES:
//
//      TRUE is successful, FALSE if a fatal error occured.
//      NT behaves very ugly if FALSE is returned.
//
//***************************************************************************
BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        setlocale(LC_ALL, "");      // Set to the 'current' locale
        g_hInstance = hinstDLL;
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
    }

    return TRUE;
}



//***************************************************************************
//
//  DllGetClassObject
//
//  Standard OLE In-Process Server entry point to return an class factory
//  instance.
//
//  PARAMETERS:
//
//  RETURNS:
//
//      S_OK                Success
//      E_NOINTERFACE       An interface other that IClassFactory was asked for
//      E_OUTOFMEMORY
//      E_FAILED            Initialization failed, or an unsupported clsid was
//                          asked for.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID * ppv
    )
{
    CFactory *pFactory;

    //
    //  Verify the caller is asking for our type of object.
    //
    if (IMPLEMENTED_CLSID != rclsid) 
            return ResultFromScode(E_FAIL);

    //
    // Check that we can provide the interface.
    //
    if (IID_IUnknown != riid && IID_IClassFactory != riid)
        return ResultFromScode(E_NOINTERFACE);

    //
    // Get a new class factory.
    //
    pFactory = new CFactory(rclsid);

    if (!pFactory)
        return ResultFromScode(E_OUTOFMEMORY);

    //
    // Verify we can get an instance.
    //
    HRESULT hRes = pFactory->QueryInterface(riid, ppv);

    if (FAILED(hRes))
        delete pFactory;

    return hRes;
}

//***************************************************************************
//
//  DllCanUnloadNow
//
//  Standard OLE entry point for server shutdown request. Allows shutdown
//  only if no outstanding objects or locks are present.
//
//  RETURN VALUES:
//
//      S_OK        May unload now.
//      S_FALSE     May not.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllCanUnloadNow(void)
{
    SCODE sc = TRUE;

    if (g_cLock)
        sc = S_FALSE;

    return sc;
}

//***************************************************************************
//
//  DllRegisterServer
//
//  Standard OLE entry point for registering the server.
//
//  RETURN VALUES:
//
//      S_OK        Registration was successful
//      E_FAIL      Registration failed.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllRegisterServer(void)
{
    wchar_t Path[1024];
    wchar_t *pGuidStr = 0;
    wchar_t KeyPath[1024];

    // Where are we?
    // =============
    GetModuleFileNameW(g_hInstance, Path, 1024);

    // Convert CLSID to string.
    // ========================

    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    // Place it in registry.
    // CLSID\\CLSID_Nt5PerProvider_v1 : <no_name> : "name"
    //      \\CLSID_Nt5PerProvider_v1\\InProcServer32 : <no_name> : "path to DLL"
    //                                    : ThreadingModel : "both"
    // ==============================================================

    HKEY hKey;
    LONG lRes = RegCreateKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    wchar_t *pName = SERVER_REGISTRY_COMMENT; 
    RegSetValueExW(hKey, 0, 0, REG_SZ, (const BYTE *) pName, wcslen(pName) * 2 + 2);

    HKEY hSubkey;
    lRes = RegCreateKey(hKey, "InprocServer32", &hSubkey);

    RegSetValueExW(hSubkey, 0, 0, REG_SZ, (const BYTE *) Path, wcslen(Path) * 2 + 2);
    RegSetValueExW(hSubkey, L"ThreadingModel", 0, REG_SZ, (const BYTE *) L"Both", wcslen(L"Both") * 2 + 2);

    RegCloseKey(hSubkey);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}

//***************************************************************************
//
//  DllUnregisterServer
//
//  Standard OLE entry point for unregistering the server.
//
//  RETURN VALUES:
//
//      S_OK        Unregistration was successful
//      E_FAIL      Unregistration failed.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllUnregisterServer(void)
{
    wchar_t *pGuidStr = 0;
    HKEY hKey;
    wchar_t KeyPath[256];

    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    // Delete InProcServer32 subkey.
    // =============================
    LONG lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, L"InprocServer32");
    RegCloseKey(hKey);

    // Delete CLSID GUID key.
    // ======================

    lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, L"Software\\Classes\\CLSID", &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, pGuidStr);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}




//***************************************************************************
//
//  CFactory::CFactory
//
//  Constructs the class factory given the CLSID of the objects it is supposed
//  to create.
//
//  PARAMETERS:
//
//      const CLSID & ClsId     The CLSID. 
//
//***************************************************************************
CFactory::CFactory(const CLSID & ClsId)
{
    m_cRef = 0;
    ObjectCreated();
    m_ClsId = ClsId;
}

//***************************************************************************
//
//  CFactory::~CFactory
//
//  Destructor.
//
//***************************************************************************
CFactory::~CFactory()
{
    ObjectDestroyed();
}

//***************************************************************************
//
//  CFactory::QueryInterface, AddRef and Release
//
//  Standard IUnknown methods.
//
//***************************************************************************
STDMETHODIMP CFactory::QueryInterface(REFIID riid, LPVOID * ppv)
{
    *ppv = 0;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
    {
        *ppv = this;
        AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


ULONG CFactory::AddRef()
{
    return ++m_cRef;
}


ULONG CFactory::Release()
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
//
//  CFactory::CreateInstance
//
//  PARAMETERS:
//
//      LPUNKNOWN pUnkOuter     IUnknown of the aggregator. Must be NULL.
//      REFIID riid             Interface ID required.
//      LPVOID * ppvObj         Destination for the interface pointer.
//
//  RETURN VALUES:
//
//      S_OK                        Success
//      CLASS_E_NOAGGREGATION       pUnkOuter must be NULL
//      E_NOINTERFACE               No such interface supported.
//      
//***************************************************************************

STDMETHODIMP CFactory::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID * ppvObj)
{
    IUnknown* pObj;
    HRESULT  hr;

    //
    //  Defaults
    //
    *ppvObj=NULL;
    hr = ResultFromScode(E_OUTOFMEMORY);

    //
    // We aren't supporting aggregation.
    //
    if (pUnkOuter)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    if (m_ClsId == IMPLEMENTED_CLSID)
    {
        pObj = INTERFACE_CAST new CPP_CLASS_NAME;
    }

    if (!pObj)
        return hr;

    //
    //  Initialize the object and verify that it can return the
    //  interface in question.
    //
    hr = pObj->QueryInterface(riid, ppvObj);

    //
    // Kill the object if initial creation or Init failed.
    //
    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
//  CFactory::LockServer
//
//  Increments or decrements the lock count of the server. The DLL will not
//  unload while the lock count is positive.
//
//  PARAMETERS:
//
//      BOOL fLock      If TRUE, locks; otherwise, unlocks.
//
//  RETURN VALUES:
//
//      S_OK
//
//***************************************************************************
STDMETHODIMP CFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *) &g_cLock);
    else
        InterlockedDecrement((LONG *) &g_cLock);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\eventprov\evprov.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//***************************************************************************
//
//  EVPROV.H
//
//  Sample event provider.
//
//***************************************************************************

#ifndef _EVPROV_H_
#define _EVPROV_H_


class CMyEventProvider : public IWbemEventProvider, public IWbemProviderInit
{
    ULONG               m_cRef;
    IWbemServices       *m_pNs;
    IWbemObjectSink     *m_pSink;
    IWbemClassObject    *m_pEventClassDef;
    int                 m_eStatus;
    HANDLE              m_hThread;
            
    static DWORD WINAPI EventThread(LPVOID pArg);
    void InstanceThread();

public:
    enum { Pending, Running, PendingStop, Stopped };

    CMyEventProvider();
   ~CMyEventProvider();

    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // Inherited from IWbemEventProvider
    // =================================

    HRESULT STDMETHODCALLTYPE ProvideEvents( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink,
            /* [in] */ long lFlags
            );

    // Inherited from IWbemProviderInit
    // ================================

    HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPWSTR pszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR pszNamespace,
            /* [in] */ LPWSTR pszLocale,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink
            );
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\eventprov\evprov.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//***************************************************************************
//
//  EVPROV
//
//  Sample event provider.
//
//***************************************************************************

#include "precomp.h"
#include <stdio.h>

#include <wbemidl.h>

#include "evprov.h"


//***************************************************************************
//
//***************************************************************************
// ok

CMyEventProvider::CMyEventProvider()
{
    m_pNs = 0;
    m_pSink = 0;
    m_cRef = 0;
    m_pEventClassDef = 0;
    m_eStatus = Pending;
    m_hThread = 0;
}


//***************************************************************************
//
//***************************************************************************
// ok

CMyEventProvider::~CMyEventProvider()
{
    if (m_hThread)
        CloseHandle(m_hThread);

    if (m_pNs)
        m_pNs->Release();

    if (m_pSink)
        m_pSink->Release();

    if (m_pEventClassDef)
        m_pEventClassDef->Release();        
}


//***************************************************************************
//
//***************************************************************************
// ok

STDMETHODIMP CMyEventProvider::QueryInterface(REFIID riid, LPVOID * ppv)
{
    *ppv = 0;

    if (IID_IUnknown==riid || IID_IWbemEventProvider==riid)
    {
        *ppv = (IWbemEventProvider *) this;
        AddRef();
        return NOERROR;
    }

    if (IID_IWbemProviderInit==riid)
    {
        *ppv = (IWbemProviderInit *) this;
        AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}



//***************************************************************************
//
//***************************************************************************
// ok

ULONG CMyEventProvider::AddRef()
{
    return ++m_cRef;
}



//***************************************************************************
//
//***************************************************************************
// ok

ULONG CMyEventProvider::Release()
{
    if (0 != --m_cRef)
        return m_cRef;

    // If here, we are shutting down.
    // ==============================

    m_eStatus = PendingStop;

    // No 'delete this' statement

    return 0;
}


//***************************************************************************
//
//***************************************************************************
// ok

HRESULT CMyEventProvider::ProvideEvents( 
    /* [in] */ IWbemObjectSink __RPC_FAR *pSink,
    /* [in] */ long lFlags
    )
{
    // Copy the sink.
    // ==============
    
    m_pSink = pSink;
    m_pSink->AddRef();

    // Create the event thread.
    // ========================
    
    DWORD dwTID;
    
    m_hThread = CreateThread(
        0,
        0,
        CMyEventProvider::EventThread,
        this,
        0,
        &dwTID
        );


    // Wait for provider to be 'ready'.
    // ================================
    
    while (m_eStatus != Running)
        Sleep(100);

    return WBEM_NO_ERROR;
}


//***************************************************************************
//
//  This particular provider, being in a DLL operates via its own thread.  
//
//  In practice, such a provider would probably be implemented within a 
//  separate EXE.
//
//***************************************************************************
// ok

DWORD WINAPI CMyEventProvider::EventThread(LPVOID pArg)
{
    // Make transition to the per-instance method.
    // ===========================================
    
    ((CMyEventProvider *)pArg)->InstanceThread();
    return 0;
}

//***************************************************************************
//
//  Events are generated from here
//
//***************************************************************************
// ok

void CMyEventProvider::InstanceThread()
{
	CoInitializeEx( NULL, COINIT_MULTITHREADED );

    int nIteration = 0;

    m_eStatus = Running;
        
    while (m_eStatus == Running)
    {
        Sleep(2000);    // Provide an event every two seconds
        
        
        // Generate a new event object.
        // ============================
        
        IWbemClassObject *pEvt = 0;

        HRESULT hRes = m_pEventClassDef->SpawnInstance(0, &pEvt);
        if (hRes != 0)
            continue;   // Failed
            
        // Generate some values to put in the event.
        // =========================================
                
        wchar_t Buf[128];
        swprintf(Buf, L"Test Event <%d>", nIteration);

        // Write the properties into the event.
        // =====================================
    
        BSTR strProp;
        VARIANT vName;
        VariantInit(&vName);

        V_VT(&vName) = VT_BSTR;        
        V_BSTR(&vName) = SysAllocString(Buf);

        strProp = SysAllocString(L"Name");
        
        pEvt->Put(strProp, 0, &vName, 0);        

        VariantClear(&vName);
        SysFreeString(strProp);
        
        
        VARIANT vCount;
        VariantInit(&vCount);
        V_VT(&vCount) = VT_I4;
        V_I4(&vCount) = nIteration;

        strProp = SysAllocString(L"Value");
        
        pEvt->Put(strProp, 0, &vCount, 0);        

        VariantClear(&vCount);
        SysFreeString(strProp);

        // Deliver the event to CIMOM.
        // ============================
        
        hRes = m_pSink->Indicate(1, &pEvt);
        
        if (hRes)
        {
            // If here, delivery failed.  Do something to report it.
        }

        pEvt->Release();                    
        nIteration++;
    }

    // When we get to here, we are no longer interested in the
    // provider and Release() has long since returned.
    
    m_eStatus = Stopped;
    delete this;

	CoUninitialize();

}





//***************************************************************************
//
//***************************************************************************

    // Inherited from IWbemProviderInit
    // ================================

HRESULT CMyEventProvider::Initialize( 
            /* [in] */ LPWSTR pszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR pszNamespace,
            /* [in] */ LPWSTR pszLocale,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink
            )
{
    // We don't care about most of the incoming parameters in this
    // simple sample.  However, we will save the namespace pointer
    // and get our event class definition.
    // ===========================================================

    m_pNs = pNamespace;
    m_pNs->AddRef();    

    // Grab the class definition for the event.
    // ======================================
    
    IWbemClassObject *pObj = 0;
    BSTR strClass = SysAllocString(L"MyEvent");

    HRESULT hRes = m_pNs->GetObject(
        strClass,
        0,                          
        pCtx,  
        &pObj,
        0
        );

    SysFreeString(strClass);

    if (hRes != 0)
        return WBEM_E_FAILED;

    m_pEventClassDef = pObj;

    // Tell CIMOM that we're up and running.
    // =====================================

    pInitSink->SetStatus(0, WBEM_S_INITIALIZED);
    
    return WBEM_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\evilperf\datagen.cpp ===
/*++ 

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    datagen.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Signal Generator Perf DLL

    This file contains a set of constant data structures which are
    currently defined for the Signal Generator Perf DLL.

Created:

    Bob Watson  28-Jul-1995

Revision History:

    None.

--*/
//
//  Include Files
//

#include "precomp.h"
#include <winperf.h>
#include "genctrnm.h"
#include "datagen.h"

// dummy variable for field sizing.
static EVILPERF_COUNTER_BLOCK   CtrBlock;

//
//  Constant structure initializations 
//      defined in datagen.h
//

EVILPERF_DATA_DEFINITION EvilPerfDataDefinition = {

    {
	0,	// Set in Collect											//PERF_OBJECT_TYPE::TotalByteLength
    sizeof(EVILPERF_DATA_DEFINITION),								//PERF_OBJECT_TYPE::DefinitionLength
    sizeof(PERF_OBJECT_TYPE),										//PERF_OBJECT_TYPE::HeaderLength
    EVIL_OBJ1,														//PERF_OBJECT_TYPE::ObjectNameTitleIndex
    0,																//PERF_OBJECT_TYPE::ObjectNameTitle
    EVIL_OBJ1,														//PERF_OBJECT_TYPE::ObjectHelpTitleIndex
    0,																//PERF_OBJECT_TYPE::ObjectHelpTitle
    PERF_DETAIL_NOVICE,												//PERF_OBJECT_TYPE::DetailLevel
    (sizeof(EVILPERF_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/	//PERF_OBJECT_TYPE::NumCounters
        sizeof(PERF_COUNTER_DEFINITION),
    0   // assigned in Open Procedure								//PERF_OBJECT_TYPE::DefaultCounter
    PERF_NO_INSTANCES,												//PERF_OBJECT_TYPE::NumInstances
    0																//PERF_OBJECT_TYPE::CodePage
    },
    {   sizeof(PERF_COUNTER_DEFINITION),							//PERF_COUNTER_DEFINITION::ByteLength
    EVIL_COUNTER1,													//PERF_COUNTER_DEFINITION::CounterNameTitleIndex
    0,																//PERF_COUNTER_DEFINITION::CounterNameTitle
    EVIL_COUNTER1,													//PERF_COUNTER_DEFINITION::CounterHelpTitleIndex
    0,																//PERF_COUNTER_DEFINITION::CounterHelpTitle
    0,																//PERF_COUNTER_DEFINITION::DefaultScale
    PERF_DETAIL_NOVICE,												//PERF_COUNTER_DEFINITION::DetailLevel
    PERF_COUNTER_RAWCOUNT,											//PERF_COUNTER_DEFINITION::CounterType
    sizeof(CtrBlock.dwCounter1),									//PERF_COUNTER_DEFINITION::CounterSize
    (DWORD)&(((EVILPERF_COUNTER_BLOCK*)0)->dwCounter1)				//PERF_COUNTER_DEFINITION::CounterOffset
    },
    {   sizeof(PERF_COUNTER_DEFINITION),							//PERF_COUNTER_DEFINITION::ByteLength
    EVIL_COUNTER2,													//PERF_COUNTER_DEFINITION::CounterNameTitleIndex
    0,																//PERF_COUNTER_DEFINITION::CounterNameTitle
    EVIL_COUNTER2,													//PERF_COUNTER_DEFINITION::CounterHelpTitleIndex
    0,																//PERF_COUNTER_DEFINITION::CounterHelpTitle
    0,																//PERF_COUNTER_DEFINITION::DefaultScale
    PERF_DETAIL_NOVICE,												//PERF_COUNTER_DEFINITION::DetailLevel
    PERF_COUNTER_RAWCOUNT,											//PERF_COUNTER_DEFINITION::CounterType
    sizeof(CtrBlock.dwCounter2),									//PERF_COUNTER_DEFINITION::CounterSize
    (DWORD)&(((EVILPERF_COUNTER_BLOCK*)0)->dwCounter2)				//PERF_COUNTER_DEFINITION::CounterOffset
    },
    {   sizeof(PERF_COUNTER_DEFINITION),							//PERF_COUNTER_DEFINITION::ByteLength
    EVIL_COUNTER3,													//PERF_COUNTER_DEFINITION::CounterNameTitleIndex
    0,																//PERF_COUNTER_DEFINITION::CounterNameTitle
    EVIL_COUNTER3,													//PERF_COUNTER_DEFINITION::CounterHelpTitleIndex
    0,																//PERF_COUNTER_DEFINITION::CounterHelpTitle
    0,																//PERF_COUNTER_DEFINITION::DefaultScale
    PERF_DETAIL_NOVICE,												//PERF_COUNTER_DEFINITION::DetailLevel
    PERF_COUNTER_RAWCOUNT,											//PERF_COUNTER_DEFINITION::CounterType
    sizeof(CtrBlock.dwCounter3),									//PERF_COUNTER_DEFINITION::CounterSize
    (DWORD)&(((EVILPERF_COUNTER_BLOCK*)0)->dwCounter3)				//PERF_COUNTER_DEFINITION::CounterOffset
    },
    {   sizeof(PERF_COUNTER_DEFINITION),							//PERF_COUNTER_DEFINITION::ByteLength
    EVIL_COUNTER4,													//PERF_COUNTER_DEFINITION::CounterNameTitleIndex
    0,																//PERF_COUNTER_DEFINITION::CounterNameTitle
    EVIL_COUNTER4,													//PERF_COUNTER_DEFINITION::CounterHelpTitleIndex
    0,																//PERF_COUNTER_DEFINITION::CounterHelpTitle
    0,																//PERF_COUNTER_DEFINITION::DefaultScale
    PERF_DETAIL_NOVICE,												//PERF_COUNTER_DEFINITION::DetailLevel
    PERF_COUNTER_RAWCOUNT,											//PERF_COUNTER_DEFINITION::CounterType
    sizeof(CtrBlock.dwCounter4),									//PERF_COUNTER_DEFINITION::CounterSize
    (DWORD)&(((EVILPERF_COUNTER_BLOCK*)0)->dwCounter4)				//PERF_COUNTER_DEFINITION::CounterOffset
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\datapackets\server\packetserver.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// OBJINTERNALSTESTDlg.cpp : implementation file
//

#define _WIN32_WINNT 0x0400

#include <windows.h>
//#include <objbase.h>
#include <stdio.h>
#include <wbemcli.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include <fastall.h>
#include <wbemdatapacket.h>
#include <objindpacket.h>
#include <verifyobj.h>

VOID ServicePipe( HANDLE hPipe );
BOOL GetDataPacketLength( HANDLE hPipe, LPDWORD dwLength );
BOOL GetDataPacket( HANDLE hPipe, DWORD dwLength, CWbemClassCache& classCache );
 
void ListenForClient(VOID) 
{ 
   BOOL fConnected; 
   HANDLE hPipe;
   LPTSTR lpszPipename = "\\\\.\\pipe\\wbemdatapacket"; 
 
   // We want no security on the pipe
   SECURITY_DESCRIPTOR	sd;
   SECURITY_ATTRIBUTES	sa;

   InitializeSecurityDescriptor( &sd, SECURITY_DESCRIPTOR_REVISION );
   SetSecurityDescriptorDacl( &sd, TRUE, NULL, FALSE );
   sa.nLength = sizeof(SECURITY_ATTRIBUTES);
   sa.bInheritHandle = FALSE;
   sa.lpSecurityDescriptor = &sd;

  hPipe = CreateNamedPipe( 
      lpszPipename,             // pipe name 
      PIPE_ACCESS_DUPLEX,       // read/write access 
      PIPE_TYPE_MESSAGE |       // message type pipe 
      PIPE_READMODE_MESSAGE |	   // message-read mode 
      PIPE_WAIT,                // blocking mode 
      1, // max. instances  
      200000,                  // output buffer size 
      200000,                  // input buffer size 
      60000,             // client time-out 
      &sa);                    // no security

  if (hPipe == INVALID_HANDLE_VALUE)
  {
	  printf( "Failed to create named pipe\n" );
	  return;
  }

  // Wait for the client to connect; if it succeeds, 
  // the function returns a nonzero value. If the function returns 
  // zero, GetLastError returns ERROR_PIPE_CONNECTED. 

  printf( "Waiting for client connection\n" );

  fConnected = ConnectNamedPipe(hPipe, NULL) ? 
     TRUE : (GetLastError() == ERROR_PIPE_CONNECTED); 

  if (fConnected) 
  { 
	  printf( "Successfuly connected\n" );
	  ServicePipe( hPipe );
  } 
  else 
  {
	  printf( "Connection failed, dropping out\n" );
    // The client could not connect, so close the pipe. 
     CloseHandle(hPipe); 
  }

} 

#define BUFSIZE	4

VOID ServicePipe( HANDLE hPipe ) 
{ 
   BOOL fSuccess = TRUE; 
 
   printf( "Servicing Named Pipe\n" );

   CWbemClassCache	classCache;

   while (fSuccess) 
   {
	   DWORD	dwPacketLength = 0;

	   fSuccess = GetDataPacketLength( hPipe, &dwPacketLength );

	   if ( fSuccess )
	   {
		   fSuccess = GetDataPacket( hPipe, dwPacketLength, classCache );
	   }
  } 

   printf( "Pipe Dead\n" );

   
// Flush the pipe to allow the client to read the pipe's contents 
// before disconnecting. Then disconnect the pipe, and close the 
// handle to this pipe instance. 
 
   FlushFileBuffers(hPipe); 
   DisconnectNamedPipe(hPipe); 
   CloseHandle(hPipe); 
} 

BOOL TransactPipe( HANDLE hPipe, LPBYTE pbData, DWORD dwSizeOfData )
{
	BOOL	fSuccess = FALSE;
	DWORD	cbBytesRead = 0,
			cbBytesWritten = 0;

   // Read client requests from the pipe. 
      fSuccess = ReadFile( 
         hPipe,			// handle to pipe 
         pbData,		// buffer to receive data 
         dwSizeOfData, // size of buffer 
         &cbBytesRead, // number of bytes read 
         NULL);        // not overlapped I/O 

      if ( fSuccess && cbBytesRead > 0) 
	  {

		  printf( "Received %d Bytes\n", cbBytesRead );

	   // Write the number of bytes read to the pipe. 
		  fSuccess = WriteFile( 
			 hPipe,        // handle to pipe 
			 &cbBytesRead,      // buffer to write from 
			 sizeof(DWORD), // number of bytes to write 
			 &cbBytesWritten,   // number of bytes written 
			 NULL);        // not overlapped I/O 
		
		  if ( fSuccess && cbBytesWritten != sizeof(DWORD) )
		  {
			  fSuccess = FALSE;
		  }
	  }
	  else
	  {
		  fSuccess = FALSE;
	  }

	  return fSuccess;

}

BOOL GetDataPacketLength( HANDLE hPipe, LPDWORD pdwLength )
{
	BOOL fReturn = TransactPipe( hPipe, (LPBYTE) pdwLength, sizeof( DWORD ) );

	if ( fReturn )
	{
		printf( "Received Incoming DataPacket Length of %d bytes\n", *pdwLength );
	}
	else
	{
		printf( "Failed to read Data Packet Length -- Closing Pipe.\n" );
	}

	return fReturn;
}

BOOL GetDataPacket( HANDLE hPipe, DWORD dwLength, CWbemClassCache& classCache )
{

	BOOL fReturn = FALSE;
	
	// Allocate a buffer to receive the data
	LPBYTE	pbData = new BYTE[dwLength+10];

	if ( NULL != pbData )
	{
		fReturn = TransactPipe( hPipe, pbData, dwLength );

		if ( fReturn )
		{
			printf( "Received Incoming DataPacket Length of %d bytes\n", dwLength );
			printf( "Unmarshaling data!\n" );

			// Unmarshal the packet and free up the newly allocated
			// object when we are done.

			LONG				lCount;
			IWbemClassObject**	apUnmarshaledObjects = NULL;

			CWbemObjSinkIndicatePacket	unmarshalPacket( pbData, dwLength );

			HRESULT hr = unmarshalPacket.UnmarshalPacket( lCount, apUnmarshaledObjects, classCache );

			if ( SUCCEEDED( hr ) )
			{
				printf( "Successfuly Unmarshaled %d Objects\n", lCount );

				// Traverse the array, verifying and releasing all the objects
				for ( long lCtr = 0; lCtr < lCount; lCtr++ )
				{
					VerifyObject( apUnmarshaledObjects[lCtr] );
					apUnmarshaledObjects[lCtr]->Release();
				}

				// Free the array of objects
				delete [] apUnmarshaledObjects;

			}	// IF UnmarshalPacket
			else
			{
				printf( "Unable to unmarshal packets, error: %d\n", hr );
			}


		}
		else
		{
			printf( "Failed to read Data Packet Length -- Closing Pipe.\n" );
		}

		delete [] pbData;

	}

	return fReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	main
//
//	Entry point function to exercise IWbemObjectInternals interface.
//
///////////////////////////////////////////////////////////////////

void main( void )
{
	CoInitializeEx( 0, COINIT_MULTITHREADED );

	ListenForClient();

	CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\evilperf\ntreg.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//***************************************************************************
//
//  REG.H
//
//  Utility registry classes.
//
//  a-raymcc    30-May-96   Created.
//
//***************************************************************************

#ifndef _NTREG_H_
#define _NTREG_H_
//#include "corepol.h"

class CNTRegistry
{
    HKEY    m_hPrimaryKey;
    HKEY    m_hSubkey;
    int     m_nStatus;
    LONG    m_nLastError;
   
public:
    enum { no_error, failed, out_of_memory, no_more_items };
    
    CNTRegistry();
   ~CNTRegistry();

    int Open(HKEY hStart, WCHAR *pszStartKey);

    int MoveToSubkey(WCHAR *pszNewSubkey);

    int GetDWORD(WCHAR *pwszValueName, DWORD *pdwValue);
    int GetStr(WCHAR *pwszValueName, WCHAR **pwszValue);

    //Returns a pointer to a string buffer containing the null-terminated string.
    //The last entry is a double null terminator (i.e. the registry format for
    //a REG_MULTI_SZ).  Caller has do "delete []" the returned pointer.
    //dwSize is the size of the buffer returned.
    int GetMultiStr(WCHAR *pwszValueName, WCHAR** pwszValue, DWORD &dwSize);

    // Allows key enumneration
    int Enum( DWORD dwIndex, WCHAR** pwszValue, DWORD& dwSize );

    int SetDWORD(WCHAR *pwszValueName, DWORD dwValue);
    int SetStr(WCHAR *pwszValueName, WCHAR *wszValue);

    LONG GetLastError() { return m_nLastError; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\evilperf\ntreg.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//***************************************************************************
//
//  REG.CPP
//
//  Utility CNTRegistry classes.
//
//  a-raymcc    30-May-96   Created.
//
//***************************************************************************

#include "precomp.h"
#include <stdio.h>
#include "ntreg.h"

CNTRegistry::CNTRegistry() : m_hPrimaryKey(0), 
							 m_hSubkey(0),
							 m_nStatus(0),
							 m_nLastError(no_error)
{}

CNTRegistry::~CNTRegistry()
{
    if (m_hSubkey)
        RegCloseKey(m_hSubkey);
    if (m_hPrimaryKey != m_hSubkey)
        RegCloseKey(m_hPrimaryKey);
}

int CNTRegistry::Open(HKEY hStart, WCHAR *pszStartKey)
{
    int nStatus = no_error;

 	m_nLastError = RegOpenKeyExW(hStart, pszStartKey,
									0, KEY_ALL_ACCESS, &m_hPrimaryKey );

    if (m_nLastError != 0)
            nStatus = failed;

	m_hSubkey = m_hPrimaryKey;

    return nStatus;
}

int CNTRegistry::MoveToSubkey(WCHAR *pszNewSubkey)
{
    int nStatus = no_error;

	m_nLastError = RegOpenKeyExW(m_hPrimaryKey, pszNewSubkey, 0, KEY_ALL_ACCESS, &m_hSubkey );

    if (m_nLastError != 0)
            nStatus = failed;

    return nStatus;
}

int CNTRegistry::GetDWORD(WCHAR *pwszValueName, DWORD *pdwValue)
{
	int nStatus = no_error;

    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = 0;

	m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType,
								LPBYTE(pdwValue), &dwSize);
    if (m_nLastError != 0)
		nStatus = failed;

    if (dwType != REG_DWORD)
        nStatus = failed;

    return nStatus;
}

int CNTRegistry::GetStr(WCHAR *pwszValueName, WCHAR **pwszValue)
{
    *pwszValue = 0;
    DWORD dwSize = 0;
    DWORD dwType = 0;

	m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType,
									0, &dwSize);
    if (m_nLastError != 0)
		return failed;

    if ( ( dwType != REG_SZ ) && ( dwType != REG_EXPAND_SZ ) )
        return failed;

    WCHAR *p = new WCHAR[dwSize];

	m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType,
									LPBYTE(p), &dwSize);
    if (m_nLastError != 0)
    {
        delete [] p;
		return failed;
    }

    if(dwType == REG_EXPAND_SZ)
    {
		WCHAR* wszTemp = NULL;

		// Get the initial length

        DWORD nSize = ExpandEnvironmentStringsW( (WCHAR *)p, wszTemp, 0 ) + 10;
        wszTemp = new WCHAR[ nSize ];
        ExpandEnvironmentStringsW( (WCHAR *)p, wszTemp, nSize - 1 );
        delete [] p;
        *pwszValue = wszTemp;
    }
	else
		*pwszValue = p;

    return no_error;
}

int CNTRegistry::Enum( DWORD dwIndex, WCHAR **pwszValue, DWORD& dwSize )
{
	DWORD	dwBuffSize = dwSize;

	m_nLastError = RegEnumKeyExW(m_hSubkey, dwIndex, *pwszValue, &dwBuffSize,
									NULL, NULL, NULL, NULL );

	while ( m_nLastError == ERROR_MORE_DATA )
	{
		// Grow in 256 byte chunks
		dwBuffSize += 256;

		try
		{
			// Reallocate the buffer and retry
			WCHAR*	p = new WCHAR[dwBuffSize];

			if ( NULL != *pwszValue )
			{
				delete *pwszValue;
			}

			*pwszValue = p;
			dwSize = dwBuffSize;

			m_nLastError = RegEnumKeyExW(m_hSubkey, dwIndex, *pwszValue, &dwBuffSize,
											NULL, NULL, NULL, NULL );

		}
		catch (...)
		{
			return out_of_memory;
		}

	}

	if ( ERROR_SUCCESS != m_nLastError )
	{
		if ( ERROR_NO_MORE_ITEMS == m_nLastError )
			return no_more_items;
		else
			return failed;
	}

    return no_error;
}

int CNTRegistry::GetMultiStr(WCHAR *pwszValueName, WCHAR** pwszValue, DWORD &dwSize)
{
	//Find out the size of the buffer required
	DWORD dwType;
	m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType, NULL, &dwSize);

	//If the error is an unexpected one bail out
	if ((m_nLastError != ERROR_SUCCESS) || (dwType != REG_MULTI_SZ))
	{
		dwSize = 0;
		return failed;
	}

	if (dwSize == 0)
	{
		dwSize = 0;
		return failed;
	}

	//allocate the buffer required
	WCHAR *pData = new WCHAR[dwSize];
	
	//get the values
	m_nLastError = RegQueryValueExW(m_hSubkey, 
								   pwszValueName, 
								   0, 
								   &dwType, 
								   LPBYTE(pData), 
								   &dwSize);

	//if an error bail out
	if (m_nLastError != 0)
	{
		delete [] pData;
		dwSize = 0;
		return failed;
	}

	*pwszValue = pData;

	return no_error;
}

int CNTRegistry::SetDWORD(WCHAR *pwszValueName, DWORD dwValue)
{
	int nStatus = no_error;

	m_nLastError = RegSetValueExW( m_hSubkey, 
								   pwszValueName,
								   0,
								   REG_DWORD,
								   (BYTE*)&dwValue,
								   sizeof( dwValue ) );

	if ( m_nLastError != ERROR_SUCCESS )
	{
		nStatus = failed;
	}

	return nStatus;
}

int CNTRegistry::SetStr(WCHAR *pwszValueName, WCHAR *wszValue)
{
	int nStatus = no_error;

	m_nLastError = RegSetValueExW( m_hSubkey, 
								   pwszValueName,
								   0,
								   REG_SZ,
								   (BYTE*)wszValue,
								   sizeof(WCHAR) * (wcslen(wszValue) + 1) );

	if ( m_nLastError != ERROR_SUCCESS )
	{
		nStatus = failed;
	}

	return nStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\evilperf\genctrnm.h ===
//
//  genctrnm.h
//
//  Offset definition file for exensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the 
//  "First Counter" and "First Help" values fo the device they belong to, 
//  in order to determine the  absolute location of the counter and 
//  object names and corresponding help text in the registry.
//
//  this file is used by the extensible counter DLL code as well as the 
//  counter name and help text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//
#define EVIL_OBJ1		0
#define EVIL_OBJ2		2
#define EVIL_OBJ3		4
#define EVIL_OBJ4		6
#define EVIL_OBJ5		8

#define EVIL_COUNTER1	10
#define EVIL_COUNTER2	12
#define EVIL_COUNTER3	14
#define EVIL_COUNTER4	16
#define GOOD_COUNTER1	18
#define GOOD_COUNTER2	20
#define GOOD_COUNTER3	22
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\evilperf\perfmsg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright 1995 - 2001 Microsoft Corporation

Module Name:

    perfmsg.h  

Abstract:

    This file provides the macros and definitions used by the extensible
    counters for reporting events to the event logging facility

Author:

    Bob Watson  28-Jul-1995

Revision History:


--*/
#ifndef  _PERFMSG_H_
#define  _PERFMSG_H_
//
// Report error message ID's for Counters
//

#define APP_NAME  "perfgen"

//
// The constant below defines how many (if any) messages will be reported
// to the event logger. As the number goes up in value more and more events
// will be reported. The purpose of this is to allow lots of messages during
// development and debugging (e.g. a message level of 3) to a minimum of
// messages (e.g. operational messages with a level of 1) or no messages if
// message logging inflicts too much of a performance penalty. Right now
// this is a compile time constant, but could later become a registry entry.
//
//    Levels:  LOG_NONE = No event log messages ever
//             LOG_USER = User event log messages (e.g. errors)
//             LOG_DEBUG = Minimum Debugging 
//             LOG_VERBOSE = Maximum Debugging 
//

#define  LOG_NONE     0
#define  LOG_USER     1
#define  LOG_DEBUG    2
#define  LOG_VERBOSE  3

#define  MESSAGE_LEVEL_DEFAULT  LOG_USER

// define macros
//
// Format for event log calls without corresponding insertion strings is:
//    REPORT_xxx (message_value, message_level)
//       where:   
//          xxx is the severity to be displayed in the event log
//          message_value is the numeric ID from above
//          message_level is the "filtering" level of error reporting
//             using the error levels above.
//
// if the message has a corresponding insertion string whose symbol conforms
// to the format CONSTANT = numeric value and CONSTANT_S = string constant for
// that message, then the 
// 
//    REPORT_xxx_STRING (message_value, message_level)
//
// macro may be used.
//

//
// REPORT_SUCCESS was intended to show Success in the error log, rather it
// shows "N/A" so for now it's the same as information, though it could 
// (should) be changed  in the future
//


#define REPORT_SUCCESS(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_WARNING(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_ERROR(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_WARNING_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_ERROR_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

// External Variables

extern HANDLE hEventLog;   // handle to event log
extern DWORD  dwLogUsers;  // counter of event log using routines
extern DWORD  MESSAGE_LEVEL; // event logging detail level

#endif //_PERFMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\evilperf\perfutil.cpp ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    perfutil.c

Abstract:

    This file implements the utility routines used to construct the
    common parts of a PERF_INSTANCE_DEFINITION (see winperf.h) and
    perform event logging functions.
                 
Created:    

    Bob Watson  28-Jul-1995

Revision History:

--*/
//
//  include files
//        
#include "precomp.h"
#include <string.h>
#include <winperf.h>
#include "genctrs.h"     // error message definition
#include "perfmsg.h"
#include "perfutil.h"

//
// Global data definitions.
//

ULONG ulInfoBufferSize = 0;

HANDLE hEventLog = NULL;      // event log handle for reporting events
                              // initialized in Open... routines
DWORD  dwLogUsers = 0;        // count of functions using event log

DWORD MESSAGE_LEVEL = 0;

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

WCHAR NULL_STRING[] = L"\0";    // pointer to null string 

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)


HANDLE
MonOpenEventLog (
)
/*++

Routine Description:

    Reads the level of event logging from the registry and opens the
        channel to the event logger for subsequent event log entries.

Arguments:

      None

Return Value:

    Handle to the event log for reporting events.
    NULL if open not successful.

--*/
{
    HKEY hAppKey;
    TCHAR LogLevelKeyName[] = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
    TCHAR LogLevelValueName[] = "EventLogLevel";

    LONG lStatus;

    DWORD dwLogLevel;
    DWORD dwValueType;
    DWORD dwValueSize;
   
    // if global value of the logging level not initialized or is disabled, 
    //  check the registry to see if it should be updated.

    if (!MESSAGE_LEVEL) {

       lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                               LogLevelKeyName,
                               0,                         
                               KEY_READ,
                               &hAppKey);

       dwValueSize = sizeof (dwLogLevel);

       if (lStatus == ERROR_SUCCESS) {
            lStatus = RegQueryValueEx (hAppKey,
                               LogLevelValueName,
                               (LPDWORD)NULL,           
                               &dwValueType,
                               (LPBYTE)&dwLogLevel,
                               &dwValueSize);

            if (lStatus == ERROR_SUCCESS) {
               MESSAGE_LEVEL = dwLogLevel;
            } else {
               MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
            }
            RegCloseKey (hAppKey);
       } else {
         MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
       }
    }
       
    if (hEventLog == NULL){
         hEventLog = RegisterEventSource (
            (LPTSTR)NULL,            // Use Local Machine
            APP_NAME);               // event log app name to find in registry

         if (hEventLog != NULL) {
            REPORT_INFORMATION (UTIL_LOG_OPEN, LOG_DEBUG);
         }
    }
    
    if (hEventLog != NULL) {
         dwLogUsers++;           // increment count of perfctr log users
    }
    return (hEventLog);
}


VOID
MonCloseEventLog (
)
/*++

Routine Description:

      Closes the handle to the event logger if this is the last caller
      
Arguments:

      None

Return Value:

      None

--*/
{
    if (hEventLog != NULL) {
        dwLogUsers--;         // decrement usage
        if (dwLogUsers <= 0) {    // and if we're the last, then close up log
            REPORT_INFORMATION (UTIL_CLOSING_LOG, LOG_DEBUG);
            DeregisterEventSource (hEventLog);
        }
    }
}



DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request
    
    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request
    
    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly, 
    // then it must be an item list
    
    return QUERY_ITEMS;

}

	

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:
        
    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;
    
    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then 
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;
            
            case DELIMITER:
                // a delimter is either the delimiter character or the 
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }
    return FALSE;
}   // IsNumberInUnicodeList


BOOL
MonBuildInstanceDefinition(
    PERF_INSTANCE_DEFINITION *pBuffer,
    PVOID	*pBufferNext,
    DWORD	ParentObjectTitleIndex,
    DWORD	ParentObjectInstance,
    DWORD	UniqueID,
    LPWSTR	Name
    )
/*++

    MonBuildInstanceDefinition  -   Build an instance of an object

        Inputs:

            pBuffer         -   pointer to buffer where instance is to
                                be constructed

            pBufferNext     -   pointer to a pointer which will contain
                                next available location, DWORD aligned

            ParentObjectTitleIndex
                            -   Title Index of parent object type; 0 if
                                no parent object

            ParentObjectInstance
                            -   Index into instances of parent object
                                type, starting at 0, for this instances
                                parent object instance

            UniqueID        -   a unique identifier which should be used
                                instead of the Name for identifying
                                this instance

            Name            -   Name of this instance
--*/
{
    DWORD NameLength;
    LPWSTR pName;
    //
    //  Include trailing null in name size
    //

    NameLength = (lstrlenW(Name) + 1) * sizeof(WCHAR);

    pBuffer->ByteLength = sizeof(PERF_INSTANCE_DEFINITION) +
                          DWORD_MULTIPLE(NameLength);

    pBuffer->ParentObjectTitleIndex = ParentObjectTitleIndex;
    pBuffer->ParentObjectInstance = ParentObjectInstance;
    pBuffer->UniqueID = UniqueID;
    pBuffer->NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
    pBuffer->NameLength = NameLength;

    // copy name to name buffer
    pName = (LPWSTR)&pBuffer[1];
    RtlMoveMemory(pName,Name,NameLength);

    // update "next byte" pointer
    *pBufferNext = (PVOID) ((PCHAR) pBuffer + pBuffer->ByteLength);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\evilperf\genctrs.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    genctrs.h
       (derived from genctrs.mc by the message compiler  )

Abstract:

   Event message definititions used by routines in PerfGen.DLL

Created:

   Bob Watson  28-Jul-1995

Revision History:

--*/
//
#ifndef _GENSTRS_H_
#define _GENSTRS_H_
//
//
//     Perfutil messages
//
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: UTIL_LOG_OPEN
//
// MessageText:
//
//  An extensible counter has opened the Event Log for PerfGen.DLL
//
#define UTIL_LOG_OPEN                    ((DWORD)0x4000076CL)

//
//
// MessageId: UTIL_CLOSING_LOG
//
// MessageText:
//
//  An extensible counter has closed the Event Log for PerfGen.DLL
//
#define UTIL_CLOSING_LOG                 ((DWORD)0x400007CFL)

//
//
// MessageId: GENPERF_UNABLE_OPEN_DRIVER_KEY
//
// MessageText:
//
//  Unable open "Performance" key of PerfGen driver in registy. Status code is returned in data.
//
#define GENPERF_UNABLE_OPEN_DRIVER_KEY   ((DWORD)0xC00007D0L)

//
//
// MessageId: GENPERF_UNABLE_READ_FIRST_COUNTER
//
// MessageText:
//
//  Unable to read the "First Counter" value under the PerfGen\Performance Key. Status codes retuened in data.
//
#define GENPERF_UNABLE_READ_FIRST_COUNTER ((DWORD)0xC00007D1L)

//
//
// MessageId: GENPERF_UNABLE_READ_FIRST_HELP
//
// MessageText:
//
//  Unable to read the "First Help" value under the PerfGen\Performance Key. Status codes retuened in data.
//
#define GENPERF_UNABLE_READ_FIRST_HELP   ((DWORD)0xC00007D2L)

//
#endif // _GENSTRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\evilperf\perfgen.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// Perfgen.h

#ifndef _PERFGEN_H_
#define _PERFGEN_H_

//
//	Definition macros
//

#define TIMEOUTVAL	600000	// 10 minutes

#define EVILPERF_FUNCTION_FAIL					0x00000001
#define EVILPERF_OVERWRITE_PREFIX_GUARDBYTES	0x00000002
#define EVILPERF_OVERWRITE_SUFFIX_GUARDBYTES	0x00000004
#define EVILPERF_RETURN_EMPTY_BLOB				0x00000008
#define EVILPERF_BAD_OBJECT_TOTAL_LENGTH		0x00000010
#define EVILPERF_BAD_OBJECT_DEFINITION_LENGTH	0x00000020
#define EVILPERF_BAD_OBJECT_HEADER_LENGTH		0x00000040
#define EVILPERF_BAD_INSTANCE_DEF_LENGTH		0x00000080
#define EVILPERF_BAD_COUNTER_DEF_LENGTH			0x00000100
#define EVILPERF_THROW_EXCEPTION				0x00000200
#define	EVILPERF_DUPLICATE_PROP_INDEX_NON_BASE	0x00000400
#define EVILPERF_DUPLICATE_PROP_INDEX_BASE		0x00000800
#define EVILPERF_MULTIBASE						0x00001000
#define EVILPERF_FIRST_COUNTER_IS_BASE			0x00002000 
#define EVILPERF_SECOND_COUNTER_IS_BASE			0x00004000 
#define EVILPERF_DUPLICATE_SPACE_OBJECTS		0x00008000
#define EVILPERF_TIMEOUT						0x00010000
#define EVILPERF_OBJECTS_WITH_ZERO_LEN_BLOB		0x00020000

//
//  Function Prototypes
//
//      these are used to insure that the data collection functions
//      accessed by Perflib will have the correct calling format.
//

PM_OPEN_PROC    OpenEvilPerformanceData;
PM_COLLECT_PROC CollectEvilPerformanceData;
PM_CLOSE_PROC   CloseEvilPerformanceData;


#endif	//_PERFGEN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\evilperf\perfgen.cpp ===
/*++ 

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    perfgen.c

Abstract:

    This file implements an Extensible Performance Object that displays
    generated signals

Created:    

    Bob Watson  28-Jul-1995

Revision History


--*/

//
//  Include Files
//

#include "precomp.h"
#include <string.h>
#include <winperf.h>
#include <math.h>
#include "genctrs.h" // error message definition
#include "perfmsg.h"
#include "perfutil.h"
#include "datagen.h"
#include "ntreg.h"
#include "perfgen.h"

//  define constant value counter's value here, any number will do.

#define CONSTANT_VALUE_VALUE    49

//
//  References to constants which initialize the Object type definitions
//

extern EVILPERF_DATA_DEFINITION EvilPerfDataDefinition;	// Declared in datagen.cpp
    
DWORD   dwOpenCount = 0;        // count of "Open" threads
BOOL    bInitOK = FALSE;        // true = DLL initialized OK


// Create instance data

typedef struct _WAVE_DATA {
    LPWSTR  szInstanceName;
} WAVE_DATA, *PWAVE_DATA;

static WAVE_DATA wdInstance[]  =
{
    {L"Instance 1"},
    {L"Instance 2"},
    {L"Instance 3"},
    {L"Instance 4"},
    {L"Instance 5"}
};

static const DWORD    NUM_INSTANCES = 
    (sizeof(wdInstance)/sizeof(wdInstance[0]));


DWORD APIENTRY OpenEvilPerformanceData( LPWSTR lpDeviceNames )
/*++

Routine Description:

    This routine will initialize the data structures used to pass
    data back to the registry

Arguments:

    Pointer to object ID of each device to be opened (PerfGen)

Return Value:

    None.

--*/
{
    LONG		status;
    DWORD		dwFirstCounter;
    DWORD		dwFirstHelp;
	DWORD		dwBehavior;
	CNTRegistry	Reg;

    //
    //  Since WINLOGON is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). the registry routines will
    //  limit access to the initialization routine to only one thread 
    //  at a time so synchronization (i.e. reentrancy) should not be 
    //  a problem
    //

    if (!dwOpenCount) 
	{
        // open Eventlog interface

        hEventLog = MonOpenEventLog();

        // get counter and help index base values from registry
        //      Open key to registry entry
        //      read First Counter and First Help values
        //      update static data strucutures by adding base to 
        //          offset value in structure.

        status = Reg.Open( HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\EvilPerf\\Performance" );

        if (status != ERROR_SUCCESS) 
		{
            REPORT_ERROR_DATA (GENPERF_UNABLE_OPEN_DRIVER_KEY, LOG_USER,
                &status, sizeof(status));
            goto OpenExitPoint;
        }

		status = Reg.GetDWORD( L"OpenBehavior", &dwBehavior );

		if (status != ERROR_SUCCESS) 
		{
            REPORT_ERROR_DATA (GENPERF_UNABLE_READ_FIRST_COUNTER, LOG_USER,
                &status, sizeof(status));
            goto OpenExitPoint;
        }
	
		switch (dwBehavior)
		{
		case EVILPERF_FUNCTION_FAIL:
			{
				status = ERROR_GEN_FAILURE;
				goto OpenExitPoint;
			}break;
		case EVILPERF_THROW_EXCEPTION:
			{
				throw NULL;
			}break;
		case EVILPERF_TIMEOUT:
			{
				Sleep( TIMEOUTVAL );
			}break;
		}

		status = Reg.GetDWORD( L"First Counter", &dwFirstCounter );

        if (status != ERROR_SUCCESS) 
		{
            REPORT_ERROR_DATA (GENPERF_UNABLE_READ_FIRST_COUNTER, LOG_USER,
                &status, sizeof(status));
            goto OpenExitPoint;
        }

        status = Reg.GetDWORD( L"First Help", &dwFirstHelp );

        if (status != ERROR_SUCCESS) {
            REPORT_ERROR_DATA (GENPERF_UNABLE_READ_FIRST_HELP, LOG_USER,
                &status, sizeof(status));
            // this is fatal, if we can't get the base values of the 
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
            goto OpenExitPoint;
        }
 
        //
        //  NOTE: the initialization program could also retrieve
        //      LastCounter and LastHelp if they wanted to do 
        //      bounds checking on the new number. e.g.
        //
        //      counter->CounterNameTitleIndex += dwFirstCounter;
        //      if (counter->CounterNameTitleIndex > dwLastCounter) {
        //          LogErrorToEventLog (INDEX_OUT_OF_BOUNDS);
        //      }

        EvilPerfDataDefinition.ObjectType.ObjectNameTitleIndex += dwFirstCounter;
        EvilPerfDataDefinition.ObjectType.ObjectHelpTitleIndex += dwFirstHelp;

        EvilPerfDataDefinition.Counter1Def.CounterNameTitleIndex += dwFirstCounter;
        EvilPerfDataDefinition.Counter1Def.CounterHelpTitleIndex += dwFirstHelp;

        EvilPerfDataDefinition.Counter2Def.CounterNameTitleIndex += dwFirstCounter;
        EvilPerfDataDefinition.Counter2Def.CounterHelpTitleIndex += dwFirstHelp;

		EvilPerfDataDefinition.Counter3Def.CounterNameTitleIndex += dwFirstCounter;
        EvilPerfDataDefinition.Counter3Def.CounterHelpTitleIndex += dwFirstHelp;

        EvilPerfDataDefinition.Counter4Def.CounterNameTitleIndex += dwFirstCounter;
        EvilPerfDataDefinition.Counter4Def.CounterHelpTitleIndex += dwFirstHelp;

		EvilPerfDataDefinition.ObjectType.DefaultCounter = EvilPerfDataDefinition.Counter1Def.CounterNameTitleIndex;
 
        bInitOK = TRUE; // ok to use this function
    }

    dwOpenCount++;  // increment OPEN counter

    status = ERROR_SUCCESS; // for successful exit

OpenExitPoint:

    return status;
}


DWORD APIENTRY CollectEvilPerformanceData( IN      LPWSTR  lpValueName,
										   IN OUT  LPVOID  *lppData,
										   IN OUT  LPDWORD lpcbTotalBytes,
										   IN OUT  LPDWORD lpNumObjectTypes )
/*++

Routine Description:

    This routine will return the data for the Signal Generator counters.

Arguments:

   IN       LPWSTR   lpValueName
         pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed 
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the 
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the 
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added 
            by this routine 
         OUT: the number of objects added by this routine is writted to the 
            DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
         any error conditions encountered are reported to the event log if
         event logging is enabled.

      ERROR_SUCCESS  if success or any other error. Errors, however are
         also reported to the event log.

--*/
{
    //  Variables for reformating the data

	EVILPERF_COUNTER_BLOCK		*pCounterBlock;					// Counter data

	CNTRegistry	Reg;
    LONG		status;
    DWORD		dwThisInstance;
    DWORD		dwSizeDataDefinition,
				dwSizeInstanceBlock,
				dwSizeClassBlock,
				dwTotalSize;
	DWORD		dwBehavior;
	DWORD		dwClass,
				dwNumClasses = 2;
	BYTE*		pCurrentBufferPtr = NULL;

    //
    // before doing anything else, see if Open went OK
    //
    if (!bInitOK) 
	{
	    *lpcbTotalBytes = (DWORD) 0;
	    *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS; // yes, this is a successful exit
	}

	status = Reg.Open( HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\EvilPerf\\Performance" );

	if (status != ERROR_SUCCESS) 
	    return ERROR_GEN_FAILURE;

	status = Reg.GetDWORD( L"CollectBehavior", &dwBehavior );

	if (status != ERROR_SUCCESS) 
        return ERROR_GEN_FAILURE;

	switch (dwBehavior)
	{
	case EVILPERF_FUNCTION_FAIL:
		{
		    return ERROR_GEN_FAILURE;
		}break;
	case EVILPERF_THROW_EXCEPTION:
		{
			throw NULL;
		}break;
	case EVILPERF_TIMEOUT:
		{
			Sleep( TIMEOUTVAL );
		}break;
	}

	// Verify that buffer is large enough
	// ==================================

	dwSizeDataDefinition	= sizeof(EVILPERF_DATA_DEFINITION);
	dwSizeInstanceBlock		= NUM_INSTANCES * (sizeof(PERF_INSTANCE_DEFINITION) + (24) + sizeof (EVILPERF_COUNTER_BLOCK));
	dwSizeClassBlock		= dwSizeDataDefinition + dwSizeInstanceBlock;
	dwTotalSize				= dwNumClasses * dwSizeClassBlock; 
	
    if ( *lpcbTotalBytes < dwTotalSize ) 
	{
	    *lpcbTotalBytes = (DWORD) 0;
	    *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

	// Finish initializing the definition block
	// ========================================

	EvilPerfDataDefinition.ObjectType.NumInstances = NUM_INSTANCES;
	EvilPerfDataDefinition.ObjectType.TotalByteLength =	dwSizeClassBlock;

	if ( EVILPERF_BAD_OBJECT_TOTAL_LENGTH & dwBehavior )
		EvilPerfDataDefinition.ObjectType.TotalByteLength += 2;

	if ( EVILPERF_BAD_OBJECT_DEFINITION_LENGTH & dwBehavior )
		EvilPerfDataDefinition.ObjectType.DefinitionLength += 2;

	if ( EVILPERF_BAD_OBJECT_HEADER_LENGTH & dwBehavior )
		EvilPerfDataDefinition.ObjectType.HeaderLength += 2;

	if ( EVILPERF_BAD_COUNTER_DEF_LENGTH & dwBehavior )
		EvilPerfDataDefinition.Counter1Def.ByteLength += 2;
    
	if ( EVILPERF_DUPLICATE_PROP_INDEX_NON_BASE & dwBehavior )
		EvilPerfDataDefinition.Counter2Def.CounterNameTitleIndex = EvilPerfDataDefinition.Counter1Def.CounterNameTitleIndex;

	if ( EVILPERF_DUPLICATE_PROP_INDEX_BASE & dwBehavior )
	{
		EvilPerfDataDefinition.Counter4Def.CounterNameTitleIndex = EvilPerfDataDefinition.Counter2Def.CounterNameTitleIndex;
		EvilPerfDataDefinition.Counter2Def.CounterType = PERF_RAW_BASE;
		EvilPerfDataDefinition.Counter4Def.CounterType = PERF_RAW_BASE;
	}

	if ( EVILPERF_MULTIBASE & dwBehavior )
	{
		EvilPerfDataDefinition.Counter2Def.CounterType = PERF_RAW_BASE;
		EvilPerfDataDefinition.Counter3Def.CounterType = PERF_RAW_BASE;
	}

	if ( EVILPERF_FIRST_COUNTER_IS_BASE & dwBehavior )
		EvilPerfDataDefinition.Counter1Def.CounterType = PERF_RAW_BASE;

	if ( EVILPERF_SECOND_COUNTER_IS_BASE & dwBehavior )
		EvilPerfDataDefinition.Counter2Def.CounterType = PERF_RAW_BASE;

	// Create the Instance Block
	// =========================

	BYTE* pInstanceBlock = new BYTE[dwSizeInstanceBlock];
	PERF_INSTANCE_DEFINITION* pCurrentInstance = (PERF_INSTANCE_DEFINITION*)pInstanceBlock;

    for ( dwThisInstance = 0; dwThisInstance < NUM_INSTANCES; dwThisInstance++ ) 
	{
        MonBuildInstanceDefinition( pCurrentInstance, 
									(PVOID *)&pCounterBlock, 
									0, 0, 
									(DWORD)-1, // use name
									wdInstance[dwThisInstance].szInstanceName );

		if ( EVILPERF_BAD_INSTANCE_DEF_LENGTH & dwBehavior )
			pCurrentInstance->ByteLength += 2;

        pCounterBlock->CounterBlock.ByteLength = sizeof (EVILPERF_COUNTER_BLOCK);

        // update instance pointer for next instance
        pCurrentInstance = (PERF_INSTANCE_DEFINITION *)&pCounterBlock[1];
    }

	pCurrentBufferPtr = (PBYTE)*lppData;

	for ( dwClass = 0; dwClass < dwNumClasses; dwClass++ )
	{
		memmove( pCurrentBufferPtr, &EvilPerfDataDefinition, dwSizeDataDefinition );

		if ( 0 == ( EVILPERF_DUPLICATE_SPACE_OBJECTS & dwBehavior ) )
			((EVILPERF_DATA_DEFINITION*)pCurrentBufferPtr)->ObjectType.ObjectNameTitleIndex += dwClass * 2;

		pCurrentBufferPtr += dwSizeDataDefinition;

		memmove( pCurrentBufferPtr, pInstanceBlock, dwSizeInstanceBlock );
		pCurrentBufferPtr += dwSizeInstanceBlock;
	}

	delete [] pInstanceBlock;

	// Generate "Error conditions"

    if ( EVILPERF_OVERWRITE_PREFIX_GUARDBYTES & dwBehavior )
		strcpy(((char*)((char*)*lppData)[-8]), "EVIL");

    if ( EVILPERF_OVERWRITE_SUFFIX_GUARDBYTES & dwBehavior )
		strcpy(((char*)((char*)*lppData)[*lpcbTotalBytes + 8]), "EVIL");

	// update arguments for return

	if ( EVILPERF_RETURN_EMPTY_BLOB & dwBehavior )
	{
		// Don't change the *lppData pointer
		*lpNumObjectTypes = 0;
		*lpcbTotalBytes = 0;
	}
	else
	{
		*lpNumObjectTypes = dwNumClasses;
	    *lpcbTotalBytes = (PBYTE)pCurrentBufferPtr - (PBYTE)*lppData;
		*lppData = (PVOID)pCurrentBufferPtr;
	}

	if ( EVILPERF_OBJECTS_WITH_ZERO_LEN_BLOB & dwBehavior )
	{
		*lpcbTotalBytes = 0;
	}

    return ERROR_SUCCESS;
}


DWORD APIENTRY CloseEvilPerformanceData()
/*++

Routine Description:

    This routine closes the open handles to the Signal Gen counters.

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    LONG		status;
	DWORD		dwBehavior;
	CNTRegistry	Reg;

    if (!(--dwOpenCount)) { // when this is the last thread...

        MonCloseEventLog();
    }

	status = Reg.Open( HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\EvilPerf\\Performance" );

	if (status != ERROR_SUCCESS) 
	{
        REPORT_ERROR_DATA (GENPERF_UNABLE_READ_FIRST_COUNTER, LOG_USER,
            &status, sizeof(status));
	    return ERROR_GEN_FAILURE;
    }

	status = Reg.GetDWORD( L"CloseBehavior", &dwBehavior );

	if (status != ERROR_SUCCESS) 
	{
        REPORT_ERROR_DATA (GENPERF_UNABLE_READ_FIRST_COUNTER, LOG_USER,
            &status, sizeof(status));
        return ERROR_GEN_FAILURE;
    }

	switch (dwBehavior)
	{
	case EVILPERF_FUNCTION_FAIL:
		{
		    return ERROR_GEN_FAILURE;
		}break;
	case EVILPERF_THROW_EXCEPTION:
		{
			throw NULL;
		}break;
	case EVILPERF_TIMEOUT:
		{
			Sleep( TIMEOUTVAL );
		}break;
	}

    return ERROR_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\evilperf\showperflib\ntreg.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//***************************************************************************
//
//  REG.H
//
//  Utility registry classes.
//
//  a-raymcc    30-May-96   Created.
//
//***************************************************************************

#ifndef _NTREG_H_
#define _NTREG_H_
//#include "corepol.h"

class CNTRegistry
{
    HKEY    m_hPrimaryKey;
    HKEY    m_hSubkey;
    int     m_nStatus;
    LONG    m_nLastError;
   
public:
    enum { no_error, failed, out_of_memory, no_more_items };
    
    CNTRegistry();
   ~CNTRegistry();

    int Open(HKEY hStart, WCHAR *pszStartKey);

    int MoveToSubkey(WCHAR *pszNewSubkey);

    int GetDWORD(WCHAR *pwszValueName, DWORD *pdwValue);
    int GetStr(WCHAR *pwszValueName, WCHAR **pwszValue);

    //Returns a pointer to a string buffer containing the null-terminated string.
    //The last entry is a double null terminator (i.e. the registry format for
    //a REG_MULTI_SZ).  Caller has do "delete []" the returned pointer.
    //dwSize is the size of the buffer returned.
    int GetMultiStr(WCHAR *pwszValueName, WCHAR** pwszValue, DWORD &dwSize);

    // Allows key enumneration
    int Enum( DWORD dwIndex, WCHAR** pwszValue, DWORD& dwSize );

    int SetDWORD(WCHAR *pwszValueName, DWORD dwValue);
    int SetStr(WCHAR *pwszValueName, WCHAR *wszValue);

    LONG GetLastError() { return m_nLastError; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\evilperf\perfutil.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright 1995 - 2001 Microsoft Corporation

Module Name:

    perfutil.h  

Abstract:

    This file supports routines used to parse and
    create Performance Monitor Data Structures.
    It actually supports Performance Object types with
    multiple instances

Author:

    Bob Watson  28-Jul-1995

Revision History:


--*/
#ifndef _PERFUTIL_H_
#define _PERFUTIL_H_

// enable this define to log process heap data to the event log
#ifdef PROBE_HEAP_USAGE
#undef PROBE_HEAP_USAGE
#endif
//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//
#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))

//    (assumes dword is 4 bytes long and pointer is a dword in size)
#define ALIGN_ON_DWORD(x) ((VOID *)( ((DWORD) x & 0x00000003) ? ( ((DWORD) x & 0xFFFFFFFC) + 4 ) : ( (DWORD) x ) ))

extern WCHAR  GLOBAL_STRING[];      // Global command (get all local ctrs)
extern WCHAR  FOREIGN_STRING[];           // get data from foreign computers
extern WCHAR  COSTLY_STRING[];      
extern WCHAR  NULL_STRING[];

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

//
// The definition of the only routine of perfutil.c, It builds part of a 
// performance data instance (PERF_INSTANCE_DEFINITION) as described in 
// winperf.h
//

HANDLE MonOpenEventLog ();
VOID MonCloseEventLog ();
DWORD GetQueryType (IN LPWSTR);
BOOL IsNumberInUnicodeList (DWORD, LPWSTR);

BOOL
MonBuildInstanceDefinition(
    PERF_INSTANCE_DEFINITION *pBuffer,
    PVOID	*pBufferNext,
    DWORD	ParentObjectTitleIndex,
    DWORD	ParentObjectInstance,
    DWORD	UniqueID,
    LPWSTR	Name
    );

typedef struct _LOCAL_HEAP_INFO_BLOCK {
    DWORD   AllocatedEntries;
    DWORD   AllocatedBytes;
    DWORD   FreeEntries;
    DWORD   FreeBytes;
} LOCAL_HEAP_INFO, *PLOCAL_HEAP_INFO;


//
//  Memory Probe macro
//
#ifdef PROBE_HEAP_USAGE

#define HEAP_PROBE()    { \
    DWORD   dwHeapStatus[5]; \
    NTSTATUS CallStatus; \
    dwHeapStatus[4] = __LINE__; \
    if (!(CallStatus = memprobe (dwHeapStatus, 16L, NULL))) { \
        REPORT_INFORMATION_DATA (TCP_HEAP_STATUS, LOG_DEBUG,    \
            &dwHeapStatus, sizeof(dwHeapStatus));  \
    } else {  \
        REPORT_ERROR_DATA (TCP_HEAP_STATUS_ERROR, LOG_DEBUG, \
            &CallStatus, sizeof (DWORD)); \
    } \
}

#else

#define HEAP_PROBE()    ;

#endif

#endif  //_PERFUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\evilperf\showperflib\listperf.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// ListPerf.cpp : implementation file
//

#include "stdafx.h"
#include "ShowPerfLib.h"
#include "ListPerf.h"
#include "ntreg.h"
#include "Showperflibdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CListPerfDlg dialog


CListPerfDlg::CListPerfDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CListPerfDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CListPerfDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CListPerfDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CListPerfDlg)
	DDX_Control(pDX, IDOK, m_wndOK);
	DDX_Control(pDX, IDC_PERFLIBS, m_wndPerfLibs);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CListPerfDlg, CDialog)
	//{{AFX_MSG_MAP(CListPerfDlg)
	ON_BN_CLICKED(IDC_RESETSTATUS, OnResetstatus)
	ON_NOTIFY(NM_DBLCLK, IDC_PERFLIBS, OnDblclkPerflibs)
	ON_BN_CLICKED(IDC_REFRESH, OnRefresh)
	ON_BN_CLICKED(IDC_HIDEPERFS, OnHideperfs)
	ON_BN_CLICKED(IDC_UNHIDEPERFS, OnUnhideperfs)
	ON_NOTIFY(NM_CLICK, IDC_PERFLIBS, OnClickPerflibs)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CListPerfDlg message handlers

BOOL CListPerfDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here

	m_wndPerfLibs.InsertColumn( 0, "PerfLib", LVCFMT_LEFT, 100 );
	m_wndPerfLibs.InsertColumn( 1, "Status", LVCFMT_LEFT, 100 );	
	m_wndPerfLibs.InsertColumn( 2, "Active", LVCFMT_LEFT, 100 );	

	AddPerfLibs();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CListPerfDlg::GetCurrentSelection()
{
	POSITION pos = m_wndPerfLibs.GetFirstSelectedItemPosition();

	if ( NULL != pos )
	{
		int nItem = m_wndPerfLibs.GetNextSelectedItem( pos );
		m_strPerfName = m_wndPerfLibs.GetItemText( nItem, 0 );
	}
}

BOOL CListPerfDlg::AddPerfLibs()
{
	BOOL bRet = TRUE;

	CNTRegistry	reg;
	long lError;
	
	lError = reg.Open( HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services" );

	DWORD	dwIndex = 0;
	DWORD	dwBuffSize = 0;
	WCHAR*	wszServiceName = NULL;
	WCHAR	wszServiceKey[512];
	WCHAR	wszPerformanceKey[512];

	while ( CNTRegistry::no_error == lError )
	{

		// For each service name, we will check for a performance 
		// key and if it exists, we will process the library
		// ======================================================

		lError = reg.Enum( dwIndex, &wszServiceName , dwBuffSize );

		if ( CNTRegistry::no_error == lError )
		{
			// Create the perfomance key path
			// ==============================
			wcscpy( wszServiceKey, L"SYSTEM\\CurrentControlSet\\Services\\" );
			wcscat( wszServiceKey, wszServiceName );

			wcscpy( wszPerformanceKey, wszServiceKey );
			wcscat( wszPerformanceKey, L"\\Performance" );

			CNTRegistry	subreg;

			// Atempt to open the performance registry key for the service
			// ===========================================================

			if ( CNTRegistry::no_error == subreg.Open( HKEY_LOCAL_MACHINE, wszPerformanceKey ) )
			{
				DWORD dwVal = 0;
				subreg.GetDWORD(L"WbemAdapStatus", &dwVal );
				CHAR szStatus[64];
				sprintf(szStatus, "0x%0.4x", dwVal );

				int nNumItems = m_wndPerfLibs.GetItemCount();

				CHAR szServiceName[512];
				wcstombs( szServiceName, wszServiceName, 512 );

				m_wndPerfLibs.InsertItem( nNumItems, szServiceName );
				m_wndPerfLibs.SetItemText( nNumItems, 1, szStatus );
				m_wndPerfLibs.SetItemText( nNumItems, 2, "active" );
			}
			else
			{
				// Check the xPerfomance key path
				// ==============================

				wcscpy( wszPerformanceKey, wszServiceKey );
				wcscat( wszPerformanceKey, L"\\xPerformance" );

				CNTRegistry	subreg;

				// Atempt to open the performance registry key for the service
				// ===========================================================

				if ( CNTRegistry::no_error == subreg.Open( HKEY_LOCAL_MACHINE, wszPerformanceKey ) )
				{
					DWORD dwVal = 0;
					subreg.GetDWORD(L"WbemAdapStatus", &dwVal );
					CHAR szStatus[64];
					sprintf(szStatus, "0x%0.4x", dwVal );

					int nNumItems = m_wndPerfLibs.GetItemCount();

					CHAR szServiceName[512];
					wcstombs( szServiceName, wszServiceName, 512 );

					m_wndPerfLibs.InsertItem( nNumItems, szServiceName );
					m_wndPerfLibs.SetItemText( nNumItems, 1, szStatus );
					m_wndPerfLibs.SetItemText( nNumItems, 2, "inactive" );
				}
			}	
		}	
		dwIndex++;
	}

	return bRet;
}

void CListPerfDlg::OnResetstatus() 
{
	CNTRegistry	reg;
	long lError;
	
	lError = reg.Open( HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services" );

	DWORD	dwIndex = 0;
	DWORD	dwBuffSize = 0;
	WCHAR*	wszServiceName = NULL;
	WCHAR	wszServiceKey[512];
	WCHAR	wszPerformanceKey[512];

	while ( CNTRegistry::no_error == lError )
	{

		// For each service name, we will check for a performance 
		// key and if it exists, we will process the library
		// ======================================================

		lError = reg.Enum( dwIndex, &wszServiceName , dwBuffSize );

		if ( CNTRegistry::no_error == lError )
		{
			// Create the perfomance key path
			// ==============================
			wcscpy( wszServiceKey, L"SYSTEM\\CurrentControlSet\\Services\\" );
			wcscat( wszServiceKey, wszServiceName );

			wcscpy( wszPerformanceKey, wszServiceKey );
			wcscat( wszPerformanceKey, L"\\Performance" );

			CNTRegistry	subreg;

			// Atempt to open the performance registry key for the service
			// ===========================================================

			if ( CNTRegistry::no_error == subreg.Open( HKEY_LOCAL_MACHINE, wszPerformanceKey ) )
			{
				subreg.SetDWORD( L"WbemAdapStatus", 0 );
			}
		}	
		dwIndex++;
	}

	OnRefresh();
}

void CListPerfDlg::OnClickPerflibs(NMHDR* pNMHDR, LRESULT* pResult) 
{
	m_wndOK.EnableWindow();	
	*pResult = 0;
}

void CListPerfDlg::OnDblclkPerflibs(NMHDR* pNMHDR, LRESULT* pResult) 
{
	GetCurrentSelection();

	CShowPerfLibDlg	dlg(m_strPerfName);

	dlg.DoModal();

	*pResult = 0;
}

void CListPerfDlg::OnOK() 
{
	CDialog::OnOK();
}


void CListPerfDlg::OnRefresh() 
{
	m_wndPerfLibs.DeleteAllItems();
	AddPerfLibs();	
}

void CListPerfDlg::OnHideperfs() 
{
	WCHAR	wszServiceName[512];
	char	szServiceName[512];
	WCHAR	wszServiceKey[512];
	WCHAR	wszPerformanceKey[512];

	UINT	uIndex = 0,
			uSelectedCount = m_wndPerfLibs.GetSelectedCount();

	int		nItem = -1;

	for ( uIndex = 0; uIndex < uSelectedCount; uIndex++ )
	{
		nItem = m_wndPerfLibs.GetNextItem( nItem, LVNI_SELECTED );
		m_wndPerfLibs.GetItemText( nItem, 0, szServiceName, 256 );
		mbstowcs( wszServiceName, szServiceName, 512 );

		// Create the perfomance key path
		// ==============================
		wcscpy( wszServiceKey, L"SYSTEM\\CurrentControlSet\\Services\\" );
		wcscat( wszServiceKey, wszServiceName );

		wcscpy( wszPerformanceKey, wszServiceKey );
		wcscat( wszPerformanceKey, L"\\Performance" );

		CNTRegistry	subreg;

		// Atempt to open the performance registry key for the service
		// ===========================================================

		if ( CNTRegistry::no_error == subreg.Open( HKEY_LOCAL_MACHINE, wszPerformanceKey ) )
		{
			Swap( wszServiceName, L"Performance", L"xPerformance" );
		}

	}

	OnRefresh();
}

void CListPerfDlg::OnUnhideperfs() 
{
	WCHAR	wszServiceName[512];
	char	szServiceName[512];
	WCHAR	wszServiceKey[512];
	WCHAR	wszPerformanceKey[512];

	UINT	uIndex = 0,
			uSelectedCount = m_wndPerfLibs.GetSelectedCount();

	int		nItem = -1;

	for ( uIndex = 0; uIndex < uSelectedCount; uIndex++ )
	{
		nItem = m_wndPerfLibs.GetNextItem( nItem, LVNI_SELECTED );
		m_wndPerfLibs.GetItemText( nItem, 0, szServiceName, 256 );
		mbstowcs( wszServiceName, szServiceName, 512 );

		// Create the perfomance key path
		// ==============================
		wcscpy( wszServiceKey, L"SYSTEM\\CurrentControlSet\\Services\\" );
		wcscat( wszServiceKey, wszServiceName );

		wcscpy( wszPerformanceKey, wszServiceKey );
		wcscat( wszPerformanceKey, L"\\xPerformance" );

		CNTRegistry	subreg;

		// Atempt to open the performance registry key for the service
		// ===========================================================

		if ( CNTRegistry::no_error == subreg.Open( HKEY_LOCAL_MACHINE, wszPerformanceKey ) )
		{
			Swap( wszServiceName, L"xPerformance", L"Performance" );
		}
	}

	OnRefresh();
}

void CListPerfDlg::Swap( WCHAR* wszPerformanceKey, WCHAR* wszFrom, WCHAR* wszTo )
{
	long	lRet = ERROR_SUCCESS;

	WCHAR	wszPath[512];
	DWORD	dwDisp = 0;
	HKEY	hSvcKey = NULL;
	HKEY	hFromKey = NULL;
	HKEY	hToKey = NULL;

	swprintf( wszPath, L"SYSTEM\\CurrentControlSet\\Services\\%s", wszPerformanceKey );
	lRet = RegOpenKeyExW( HKEY_LOCAL_MACHINE, wszPath, 0, KEY_ALL_ACCESS, &hSvcKey );

	if ( ERROR_SUCCESS == lRet )
	{
		lRet = RegOpenKeyExW( hSvcKey, wszFrom, 0, KEY_ALL_ACCESS, &hFromKey );
	}

	if ( ERROR_SUCCESS == lRet )
	{
		lRet = RegCreateKeyExW( hSvcKey, wszTo, 0, NULL, NULL, KEY_ALL_ACCESS, NULL, &hToKey, &dwDisp );
	}

	// Enumerate and copy
	
	DWORD	dwIndex = 0;
	WCHAR	wszName[256];
	DWORD	dwNameSize = 256;
	DWORD	dwType = 0;
	BYTE	pBuffer[2048];
	DWORD	dwBufferSize = 2048;

	while ( ERROR_SUCCESS == lRet )
	{
		dwBufferSize = 2048;
		dwNameSize = 256;

		lRet = RegEnumValueW( hFromKey, dwIndex, wszName, &dwNameSize, 0, &dwType, pBuffer, &dwBufferSize );
		if ( ERROR_SUCCESS == lRet )
		{
			RegSetValueExW( hToKey, wszName, 0, dwType, pBuffer, dwBufferSize );
		}

		dwIndex++;
	}

	lRet = RegCloseKey( hFromKey );
	lRet = RegCloseKey( hToKey );

	lRet = RegDeleteKeyW( hSvcKey, wszFrom );
	lRet = RegCloseKey( hSvcKey );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\evilperf\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>

#define COREPROX_POLARITY __declspec( dllexport )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\evilperf\showperflib\listperf.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#if !defined(AFX_LISTPERF_H__B6F3F82D_2245_11D3_B360_00105A1469B7__INCLUDED_)
#define AFX_LISTPERF_H__B6F3F82D_2245_11D3_B360_00105A1469B7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ListPerf.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CListPerfDlg dialog

class CListPerfDlg : public CDialog
{
// Construction
public:
	CListPerfDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CListPerfDlg)
	enum { IDD = IDD_LISTPERF };
	CButton	m_wndOK;
	CListCtrl	m_wndPerfLibs;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CListPerfDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CListPerfDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnResetstatus();
	afx_msg void OnDblclkPerflibs(NMHDR* pNMHDR, LRESULT* pResult);
	virtual void OnOK();
	afx_msg void OnRefresh();
	afx_msg void OnHideperfs();
	afx_msg void OnUnhideperfs();
	afx_msg void OnClickPerflibs(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CString m_strPerfName;

	BOOL AddPerfLibs();
	void GetCurrentSelection();
	void Swap( WCHAR* wszPerformanceKey, WCHAR* wszFrom, WCHAR* wszTo );
public:
	CString GetPerfName(){ return m_strPerfName; }
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LISTPERF_H__B6F3F82D_2245_11D3_B360_00105A1469B7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\evilperf\showperflib\ntreg.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//***************************************************************************
//
//  REG.CPP
//
//  Utility CNTRegistry classes.
//
//  a-raymcc    30-May-96   Created.
//
//***************************************************************************

#include <windows.h>

#include <stdio.h>
#include "ntreg.h"
//#include <dbgalloc.h>

//#include "adaputil.h"

CNTRegistry::CNTRegistry() : m_hPrimaryKey(0), 
							 m_hSubkey(0),
							 m_nStatus(0),
							 m_nLastError(no_error)
{}

CNTRegistry::~CNTRegistry()
{
    if (m_hSubkey)
        RegCloseKey(m_hSubkey);
    if (m_hPrimaryKey != m_hSubkey)
        RegCloseKey(m_hPrimaryKey);
}

int CNTRegistry::Open(HKEY hStart, WCHAR *pszStartKey)
{
    int nStatus = no_error;

 	m_nLastError = RegOpenKeyExW(hStart, pszStartKey,
									0, KEY_ALL_ACCESS, &m_hPrimaryKey );

    if (m_nLastError != 0)
            nStatus = failed;

	m_hSubkey = m_hPrimaryKey;

    return nStatus;
}

int CNTRegistry::MoveToSubkey(WCHAR *pszNewSubkey)
{
    int nStatus = no_error;

	m_nLastError = RegOpenKeyExW(m_hPrimaryKey, pszNewSubkey, 0, KEY_ALL_ACCESS, &m_hSubkey );

    if (m_nLastError != 0)
            nStatus = failed;

    return nStatus;
}

int CNTRegistry::GetDWORD(WCHAR *pwszValueName, DWORD *pdwValue)
{
	int nStatus = no_error;

    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = 0;

	m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType,
								LPBYTE(pdwValue), &dwSize);
    if (m_nLastError != 0)
		nStatus = failed;

    if (dwType != REG_DWORD)
        nStatus = failed;

    return nStatus;
}

int CNTRegistry::GetStr(WCHAR *pwszValueName, WCHAR **pwszValue)
{
    *pwszValue = 0;
    DWORD dwSize = 0;
    DWORD dwType = 0;

	m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType,
									0, &dwSize);
    if (m_nLastError != 0)
		return failed;

    if ( ( dwType != REG_SZ ) && ( dwType != REG_EXPAND_SZ ) )
        return failed;

    WCHAR *p = new WCHAR[dwSize];

	m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType,
									LPBYTE(p), &dwSize);
    if (m_nLastError != 0)
    {
        delete [] p;
		return failed;
    }

    if(dwType == REG_EXPAND_SZ)
    {
		WCHAR* wszTemp = NULL;

		// Get the initial length

        DWORD nSize = ExpandEnvironmentStringsW( (WCHAR *)p, wszTemp, 0 ) + 10;
        wszTemp = new WCHAR[ nSize ];
        ExpandEnvironmentStringsW( (WCHAR *)p, wszTemp, nSize - 1 );
        delete [] p;
        *pwszValue = wszTemp;
    }
	else
		*pwszValue = p;

    return no_error;
}

int CNTRegistry::Enum( DWORD dwIndex, WCHAR **pwszValue, DWORD& dwSize )
{
	DWORD	dwBuffSize = dwSize;

	m_nLastError = RegEnumKeyExW(m_hSubkey, dwIndex, *pwszValue, &dwBuffSize,
									NULL, NULL, NULL, NULL );

	while ( m_nLastError == ERROR_MORE_DATA )
	{
		// Grow in 256 byte chunks
		dwBuffSize += 256;

		try
		{
			// Reallocate the buffer and retry
			WCHAR*	p = new WCHAR[dwBuffSize];

			if ( NULL != *pwszValue )
			{
				delete *pwszValue;
			}

			*pwszValue = p;
			dwSize = dwBuffSize;

			m_nLastError = RegEnumKeyExW(m_hSubkey, dwIndex, *pwszValue, &dwBuffSize,
											NULL, NULL, NULL, NULL );

		}
		catch (...)
		{
			return out_of_memory;
		}

	}

	if ( ERROR_SUCCESS != m_nLastError )
	{
		if ( ERROR_NO_MORE_ITEMS == m_nLastError )
			return no_more_items;
		else
			return failed;
	}

    return no_error;
}

int CNTRegistry::GetMultiStr(WCHAR *pwszValueName, WCHAR** pwszValue, DWORD &dwSize)
{
	//Find out the size of the buffer required
	DWORD dwType;
	m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType, NULL, &dwSize);

	//If the error is an unexpected one bail out
	if ((m_nLastError != ERROR_SUCCESS) || (dwType != REG_MULTI_SZ))
	{
		dwSize = 0;
		return failed;
	}

	if (dwSize == 0)
	{
		dwSize = 0;
		return failed;
	}

	//allocate the buffer required
	WCHAR *pData = new WCHAR[dwSize];
	
	//get the values
	m_nLastError = RegQueryValueExW(m_hSubkey, 
								   pwszValueName, 
								   0, 
								   &dwType, 
								   LPBYTE(pData), 
								   &dwSize);

	//if an error bail out
	if (m_nLastError != 0)
	{
		delete [] pData;
		dwSize = 0;
		return failed;
	}

	*pwszValue = pData;

	return no_error;
}

int CNTRegistry::SetDWORD(WCHAR *pwszValueName, DWORD dwValue)
{
	int nStatus = no_error;

	m_nLastError = RegSetValueExW( m_hSubkey, 
								   pwszValueName,
								   0,
								   REG_DWORD,
								   (BYTE*)&dwValue,
								   sizeof( dwValue ) );

	if ( m_nLastError != ERROR_SUCCESS )
	{
		nStatus = failed;
	}

	return nStatus;
}

int CNTRegistry::SetStr(WCHAR *pwszValueName, WCHAR *wszValue)
{
	int nStatus = no_error;

	m_nLastError = RegSetValueExW( m_hSubkey, 
								   pwszValueName,
								   0,
								   REG_SZ,
								   (BYTE*)wszValue,
								   sizeof(WCHAR) * (wcslen(wszValue) + 1) );

	if ( m_nLastError != ERROR_SUCCESS )
	{
		nStatus = failed;
	}

	return nStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\evilperf\showperflib\perfselection.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// PerfSelection.cpp : implementation file
//

#include "stdafx.h"
#include "ShowPerfLib.h"
#include "PerfSelection.h"
#include "ntreg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPerfSelection dialog


CPerfSelection::CPerfSelection(CWnd* pParent /*=NULL*/)
	: CDialog(CPerfSelection::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPerfSelection)
	m_strService = _T("");
	//}}AFX_DATA_INIT
}


void CPerfSelection::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPerfSelection)
	DDX_Control(pDX, IDC_SERVICE, m_wndService);
//	DDX_Control(pDX, IDC_PERFLIST, m_wndPerfList);
	DDX_Text(pDX, IDC_SERVICE, m_strService);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPerfSelection, CDialog)
	//{{AFX_MSG_MAP(CPerfSelection)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPerfSelection message handlers

BOOL CPerfSelection::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here

	InitList();

	m_wndService.SetFocus();

	return FALSE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPerfSelection::InitList()
{
	CNTRegistry Reg;
	WCHAR	wszServiceKey[512], 
			wszPerformanceKey[512];

	if ( CNTRegistry::no_error == Reg.Open( HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services" ) )
	{
		DWORD	dwIndex = 0;

		// Iterate through the services list
		// =================================

		DWORD	dwBuffSize = 0;
		WCHAR*	wcsServiceName = NULL;
		long lError = CNTRegistry::no_error;

		while ( CNTRegistry::no_error == lError )
		{
			// For each service name, we will check for a performance 
			// key and if it exists, we will process the library
			// ======================================================

			lError = Reg.Enum( dwIndex, &wcsServiceName , dwBuffSize );
			if ( CNTRegistry::no_error ==  lError )
			{
				// Create the perfomance key path
				// ==============================

				swprintf(wszServiceKey, L"SYSTEM\\CurrentControlSet\\Services\\%s", wcsServiceName);
				swprintf(wszPerformanceKey, L"%s\\Performance", wszServiceKey);

				CNTRegistry	RegSubKey;

				// Atempt to open the performance registry key for the service
				// ===========================================================

				if ( CNTRegistry::no_error == RegSubKey.Open( HKEY_LOCAL_MACHINE, wszPerformanceKey ) )
				{
					CString str(wcsServiceName);
					m_wndPerfList.InsertItem( 1, str );
				}
				dwIndex++;
			}
		}
	}
}


void CPerfSelection::OnOK() 
{
	// TODO: Add extra validation here

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\evilperf\showperflib\perfselection.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#if !defined(AFX_PERFSELECTION_H__5547DA35_0860_11D3_B35C_00105A1469B7__INCLUDED_)
#define AFX_PERFSELECTION_H__5547DA35_0860_11D3_B35C_00105A1469B7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// PerfSelection.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPerfSelection dialog

class CPerfSelection : public CDialog
{
// Construction
public:
	CPerfSelection(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CPerfSelection)
	enum { IDD = IDD_PERFSELECTION };
	CEdit	m_wndService;
	CListCtrl	m_wndPerfList;
	CString	m_strService;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPerfSelection)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

public:
	CString GetServiceName() {return m_strService;}

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CPerfSelection)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void InitList();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PERFSELECTION_H__5547DA35_0860_11D3_B35C_00105A1469B7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\evilperf\showperflib\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ShowPerfLib.rc
//
#define IDD_SHOWPERFLIB_DIALOG          102
#define IDR_MAINFRAME                   128
#define IDD_PERFSELECTION               129
#define IDD_LISTPERF                    130
#define IDC_PERFTREE                    1000
#define IDC_SERVICE                     1003
#define IDC_RESETSTATUS                 1005
#define IDC_PERFLIBS                    1006
#define IDC_REFRESH                     1007
#define IDC_HIDEPERFS                   1008
#define IDC_UNHIDEPERFS                 1009
#define IDC_ERRORS                      1011

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        131
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1012
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\evilperf\showperflib\showperflib.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// ShowPerfLib.h : main header file for the SHOWPERFLIB application
//

#if !defined(AFX_SHOWPERFLIB_H__3FF01277_0700_11D3_B35B_00105A1469B7__INCLUDED_)
#define AFX_SHOWPERFLIB_H__3FF01277_0700_11D3_B35B_00105A1469B7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CShowPerfLibApp:
// See ShowPerfLib.cpp for the implementation of this class
//

class CShowPerfLibApp : public CWinApp
{
public:
	CShowPerfLibApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CShowPerfLibApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CShowPerfLibApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SHOWPERFLIB_H__3FF01277_0700_11D3_B35B_00105A1469B7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\evilperf\showperflib\showperflib.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// ShowPerfLib.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "ShowPerfLib.h"
//#include "ShowPerfLibDlg.h"
#include "ListPerf.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CShowPerfLibApp

BEGIN_MESSAGE_MAP(CShowPerfLibApp, CWinApp)
	//{{AFX_MSG_MAP(CShowPerfLibApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CShowPerfLibApp construction

CShowPerfLibApp::CShowPerfLibApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CShowPerfLibApp object

CShowPerfLibApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CShowPerfLibApp initialization

BOOL CShowPerfLibApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CListPerfDlg	dlg;

	m_pMainWnd = &dlg;

	int nResponse = dlg.DoModal();

	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\evilperf\showperflib\showperflibdlg.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// ShowPerfLibDlg.cpp : implementation file
//

#include "stdafx.h"
#include "ShowPerfLib.h"
#include "ShowPerfLibDlg.h"
#include "PerfSelection.h"
#include "ntreg.h"
#include "listperf.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CShowPerfLibDlg dialog

CShowPerfLibDlg::CShowPerfLibDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CShowPerfLibDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CShowPerfLibDlg)
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
	m_strService = _T("");
}

CShowPerfLibDlg::CShowPerfLibDlg(CString strService, CWnd* pParent /*=NULL*/)
	: m_strService( strService ), CDialog(CShowPerfLibDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CShowPerfLibDlg)
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CShowPerfLibDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CShowPerfLibDlg)
	DDX_Control(pDX, IDC_PERFTREE, m_wndPerfTree);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CShowPerfLibDlg, CDialog)
	//{{AFX_MSG_MAP(CShowPerfLibDlg)
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////	////////////////////////////////////////////////////////////////
// CShowPerfLibDlg message handlers

BOOL CShowPerfLibDlg::OnInitDialog()
{
	CDialog::OnInitDialog();
	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
//	SetIcon(m_hIcon, TRUE);			// Set big icon
//	SetIcon(m_hIcon, FALSE);		// Set small icon

	SetWindowText( m_strService );

	InitPerfLibTree();

	return TRUE;  // return TRUE  unless you set the focus to a control
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CShowPerfLibDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CShowPerfLibDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

BOOL CShowPerfLibDlg::InitPerfLibTree()
{				
	BOOL bRet = TRUE;

	CWaitCursor	wc;

	if (InitService())
	{
		if ( OpenLibrary() )
		{
			if ( GetData() )
			{
				if ( !CloseLibrary() )
					m_wndPerfTree.DeleteAllItems();
			}
			FreeLibrary( m_hLib );
		}
	}


	return bRet;
}

BOOL CShowPerfLibDlg::InitService()
{
	BOOL bRet = TRUE;

	CNTRegistry Reg;
	WCHAR	wszKey[128];

	swprintf(wszKey, L"SYSTEM\\CurrentControlSet\\Services\\%S\\Performance", m_strService);

	if ( CNTRegistry::no_error == Reg.Open( HKEY_LOCAL_MACHINE, wszKey ) )
	{
		WCHAR*	wszTemp;
		Reg.GetStr(L"Library", &wszTemp);
		m_strPerfLib = wszTemp;
		delete [] wszTemp;

		Reg.GetStr(L"Open", &wszTemp);
		m_strOpen = wszTemp;
		delete [] wszTemp;

		Reg.GetStr(L"Collect", &wszTemp);
		m_strCollect = wszTemp;
		delete [] wszTemp;

		Reg.GetStr(L"Close", &wszTemp);
		m_strClose = wszTemp;
		delete [] wszTemp;
	}
	else
		bRet = FALSE;

	return bRet;
}

BOOL CShowPerfLibDlg::OpenLibrary()
{
	BOOL bRet = TRUE;

	m_hLib = LoadLibrary( (LPCSTR)m_strPerfLib );

	m_pfnOpenProc = (PM_OPEN_PROC*) GetProcAddress( m_hLib, m_strOpen );
	m_pfnCollectProc = (PM_COLLECT_PROC*) GetProcAddress( m_hLib, m_strCollect );
	m_pfnCloseProc = (PM_CLOSE_PROC*) GetProcAddress( m_hLib, m_strClose );

	if ( m_pfnOpenProc( NULL ) != ERROR_SUCCESS )
		bRet = FALSE;

	return bRet;
}

BOOL CShowPerfLibDlg::GetData()
{
	BOOL bRet = TRUE;

	DWORD	dwGuardSize  = 1024;
	DWORD	dwSize = 64000;
	BYTE*	pSafeBuffer = new BYTE[dwSize + ( 2 * dwGuardSize )];

	memset( pSafeBuffer, 0xFFFFFFFF, dwSize + ( 2 * dwGuardSize ) );
	BYTE*	pBuffer = pSafeBuffer + dwGuardSize;
	BYTE*	pBufferPtr = NULL;

	DWORD	dwNumClasses = 0;
	DWORD	dwBufferSize = 0;

	char	szSpace[16];
	WCHAR	wszSpace[16];

	for ( int i = 0; i < 2; i++ )
	{
		int nRet = ERROR_MORE_DATA;

		if ( 0 == i )
		{
			strcpy (szSpace, "Global");
			wcscpy (wszSpace, L"Global");
		}
		else
		{
			strcpy (szSpace, "Costly");
			wcscpy (wszSpace, L"Costly");
		}

		while (ERROR_MORE_DATA == nRet)
		{
			pBufferPtr = pBuffer;

			dwBufferSize = dwSize;

			nRet = m_pfnCollectProc( wszSpace, (LPVOID*)(&pBufferPtr), &dwBufferSize, &dwNumClasses );

			if (ERROR_SUCCESS == nRet)
			{
				BuildSubTree( szSpace, pBuffer, dwNumClasses );
			}
			else if ( ERROR_MORE_DATA == nRet )
			{
				dwSize += 8000;

				if ( NULL != pSafeBuffer )
				{
					delete [] pSafeBuffer;
				}

				pSafeBuffer = new BYTE[dwSize + ( 2 * dwGuardSize )];
				memset( pSafeBuffer, 0xFFFFFFFF, dwSize + ( 2 * dwGuardSize ) );

			}
			else
			{
				bRet = FALSE;
			}
		}

		memset((void*) pBuffer, 0, dwSize);
	}

	if ( NULL != pBuffer )
	{
		delete [] pSafeBuffer;
	}

	return bRet;
}

BOOL CShowPerfLibDlg::BuildSubTree( CString strSpace, BYTE* pBlob, DWORD dwNumObjects)
{
	BOOL bRet = TRUE;

	HTREEITEM hSpace = m_wndPerfTree.InsertItem( strSpace );

// Object

	PERF_OBJECT_TYPE* pObj = (PERF_OBJECT_TYPE*)pBlob;

	for ( DWORD dwObj = 0; dwObj < dwNumObjects; dwObj++ )
	{
		CString str;

		char* szName;
		m_TitleLibrary.GetName(pObj->ObjectNameTitleIndex, &szName);

		char szClassName[256];
		sprintf(szClassName, "%s Class", szName );
		HTREEITEM hClass = m_wndPerfTree.InsertItem( szClassName, hSpace );

		str.Format("TotalByteLength: %d", pObj->TotalByteLength);
		m_wndPerfTree.InsertItem( str, hClass );
		str.Format("DefinitionLength: %d", pObj->DefinitionLength);
		m_wndPerfTree.InsertItem( str, hClass );
		str.Format("HeaderLength: %d", pObj->HeaderLength);
		m_wndPerfTree.InsertItem( str, hClass );
		str.Format("ObjectNameTitleIndex: %d", pObj->ObjectNameTitleIndex);
		m_wndPerfTree.InsertItem( str, hClass );
		str.Format("ObjectHelpTitleIndex: %d", pObj->ObjectHelpTitleIndex);
		m_wndPerfTree.InsertItem( str, hClass );
		str.Format("DetailLevel: %d", pObj->DetailLevel);
		m_wndPerfTree.InsertItem( str, hClass );
		str.Format("NumCounters: %d", pObj->NumCounters);
		m_wndPerfTree.InsertItem( str, hClass );
		str.Format("DefaultCounter: %d", pObj->DefaultCounter);
		m_wndPerfTree.InsertItem( str, hClass );
		str.Format("NumInstances: %d", pObj->NumInstances);
		m_wndPerfTree.InsertItem( str, hClass );
		str.Format("CodePage: %d", pObj->CodePage);
		m_wndPerfTree.InsertItem( str, hClass );
		str.Format("PerfTime: %d", pObj->PerfTime);
		m_wndPerfTree.InsertItem( str, hClass );
		str.Format("PerfFreq: %d", pObj->PerfFreq);
		m_wndPerfTree.InsertItem( str, hClass );

// Counters

		PERF_COUNTER_DEFINITION* pCtrDef = (PERF_COUNTER_DEFINITION*)((DWORD)pObj + pObj->HeaderLength);

		for ( DWORD dwCtr = 0; dwCtr < pObj->NumCounters; dwCtr++ )
		{
			char szCounterName[256];

			m_TitleLibrary.GetName( pCtrDef->CounterNameTitleIndex, &szName );
			sprintf(szCounterName, "%s Counter", szName);

			HTREEITEM hCtr = m_wndPerfTree.InsertItem( szCounterName, hClass );

			str.Format("ByteLength: %d", pCtrDef->ByteLength);
			m_wndPerfTree.InsertItem( str, hCtr );
			str.Format("CounterNameTitleIndex: %d", pCtrDef->CounterNameTitleIndex);
			m_wndPerfTree.InsertItem( str, hCtr );
			str.Format("CounterHelpTitleIndex: %d", pCtrDef->CounterHelpTitleIndex);
			m_wndPerfTree.InsertItem( str, hCtr );
			str.Format("DefaultScale: %d", pCtrDef->DefaultScale);
			m_wndPerfTree.InsertItem( str, hCtr );
			str.Format("DetailLevel: %d", pCtrDef->DetailLevel);
			m_wndPerfTree.InsertItem( str, hCtr );
			str.Format("CounterType: 0x%X (%s Base)", pCtrDef->CounterType, ( PERF_COUNTER_BASE == (pCtrDef->CounterType & 0x00070000))?"Is a ":"Is not a ");
			m_wndPerfTree.InsertItem( str, hCtr );
			str.Format("CounterSize: %d", pCtrDef->CounterSize);
			m_wndPerfTree.InsertItem( str, hCtr );
			str.Format("CounterOffset: %d", pCtrDef->CounterOffset);
			m_wndPerfTree.InsertItem( str, hCtr );

			pCtrDef = (PERF_COUNTER_DEFINITION*)((DWORD)pCtrDef + pCtrDef->ByteLength);
		}

// Instances

		PERF_INSTANCE_DEFINITION* pInstDef = (PERF_INSTANCE_DEFINITION*)((DWORD)pObj + pObj->DefinitionLength);

		for ( LONG lInstance = 0; lInstance < pObj->NumInstances; lInstance++ )
		{
			char szInstanceName[256];
			sprintf(szInstanceName, "%S Instance", (WCHAR*)((DWORD)pInstDef + pInstDef->NameOffset));
			HTREEITEM hInst = m_wndPerfTree.InsertItem( szInstanceName, hClass );

			str.Format("ByteLength: %d", pInstDef->ByteLength);
			m_wndPerfTree.InsertItem( str, hInst );
			str.Format("ParentObjectTitleIndex: %d", pInstDef->ParentObjectTitleIndex);
			m_wndPerfTree.InsertItem( str, hInst );
			str.Format("ParentObjectInstance: %d", pInstDef->ParentObjectInstance);
			m_wndPerfTree.InsertItem( str, hInst );
			str.Format("UniqueID: %d", pInstDef->UniqueID);
			m_wndPerfTree.InsertItem( str, hInst );
			str.Format("NameOffset: %d", pInstDef->NameOffset);
			m_wndPerfTree.InsertItem( str, hInst );
			str.Format("NameLength: %d", pInstDef->NameLength);
			m_wndPerfTree.InsertItem( str, hInst );

// Instance Counter Data

			PERF_COUNTER_BLOCK* pCtrBlock = (PERF_COUNTER_BLOCK*)((DWORD)pInstDef + pInstDef->ByteLength);
			BYTE* pCurrCtr = (BYTE*)pCtrBlock;

			PERF_COUNTER_DEFINITION* pCtrDef = (PERF_COUNTER_DEFINITION*)((DWORD)pObj + pObj->HeaderLength);

			for ( DWORD dwCtr = 0; dwCtr < pObj->NumCounters; dwCtr++ )
			{
				char*	szName;
				m_TitleLibrary.GetName( pCtrDef->CounterNameTitleIndex, &szName );

				switch (pCtrDef->CounterSize)
				{
				case 0:
					{
						str.Format("%s data: <zero length>", szName );
						m_wndPerfTree.InsertItem( str, hInst );
					}break;
				case 4:
					{
						str.Format("%s data: %d", szName, (DWORD)(*(pCurrCtr + pCtrDef->CounterOffset)));
						m_wndPerfTree.InsertItem( str, hInst );
					}break;
				case 8:
					{
						str.Format("%s data: %I64d", szName, (__int64)(*(pCurrCtr + pCtrDef->CounterOffset)));
						m_wndPerfTree.InsertItem( str, hInst );
					}break;

				default:
					{
						str.Format("%s data: <unhandled>", szName );
						m_wndPerfTree.InsertItem( str, hInst );
					}break;
				}

				pCtrDef = (PERF_COUNTER_DEFINITION*)((DWORD)pCtrDef + pCtrDef->ByteLength);
			}


			pInstDef = (PERF_INSTANCE_DEFINITION*)((DWORD)pCtrBlock + pCtrBlock->ByteLength);
		}

		pObj = (PERF_OBJECT_TYPE*)((DWORD)pObj + pObj->TotalByteLength);
	}

	return bRet;
}

BOOL CShowPerfLibDlg::CloseLibrary()
{
	BOOL bRet = TRUE;

	if ( ERROR_SUCCESS != m_pfnCloseProc() )
		bRet = FALSE;

	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\evilperf\showperflib\showperflibdlg.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// ShowPerfLibDlg.h : header file
//

#if !defined(AFX_SHOWPERFLIBDLG_H__3FF01279_0700_11D3_B35B_00105A1469B7__INCLUDED_)
#define AFX_SHOWPERFLIBDLG_H__3FF01279_0700_11D3_B35B_00105A1469B7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <winperf.h>
#include "TitleDB.h"
#include "PerfSelection.h"

/////////////////////////////////////////////////////////////////////////////
// CShowPerfLibDlg dialog

class CShowPerfLibDlg : public CDialog
{
// Construction
public:
	CShowPerfLibDlg(CWnd* pParent = NULL);	// standard constructor
	CShowPerfLibDlg(CString strService, CWnd* pParent =NULL );

// Dialog Data
	//{{AFX_DATA(CShowPerfLibDlg)
	enum { IDD = IDD_SHOWPERFLIB_DIALOG };
	CTreeCtrl	m_wndPerfTree;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CShowPerfLibDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CShowPerfLibDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	HINSTANCE			m_hLib;				// The handle to the perflib
	PM_OPEN_PROC*		m_pfnOpenProc;		// The function pointer to the perflib's open function
	PM_COLLECT_PROC*	m_pfnCollectProc;	// The function pointer to the perflib's collect function
	PM_CLOSE_PROC*		m_pfnCloseProc;		// The function pointer to the perflib's close function

	CTitleLibrary		m_TitleLibrary;
	CPerfSelection		m_wndPerfSelection;

	CString				m_strPerfLib;
	CString				m_strOpen;
	CString				m_strCollect;
	CString				m_strClose;
	CString				m_strService;

	BOOL InitPerfLibTree();
	BOOL InitService();
	BOOL OpenLibrary();
	BOOL GetData();
	BOOL BuildSubTree( CString strSpace, BYTE* pBlob, DWORD dwNumObjects);
	BOOL CloseLibrary();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SHOWPERFLIBDLG_H__3FF01279_0700_11D3_B35B_00105A1469B7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\evilperf\showperflib\stdafx.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// stdafx.cpp : source file that includes just the standard includes
//	ShowPerfLib.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\evilperf\showperflib\stdafx.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__3FF0127B_0700_11D3_B35B_00105A1469B7__INCLUDED_)
#define AFX_STDAFX_H__3FF0127B_0700_11D3_B35B_00105A1469B7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3FF0127B_0700_11D3_B35B_00105A1469B7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\filerepository\dumptree\stdafx.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// stdafx.cpp : source file that includes just the standard includes
//	DumpTree.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\filerepository\dumptree\dumptree.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// DumpTree.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "BTree.h"
#include <conio.h>

int main(int argc, char* argv[])
{
	CFlatFile file;
	file.CreateFile(_TEXT("..\\FileRepository\\file.dbf"));

	CBTree tree(file);
	tree.Initialise();

	tree.DumpAllNodes();

	tree.Deinitialise();

	file.CloseFile();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\evilperf\showperflib\titledb.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// TitleDB.h

#ifndef _TITLEDB_H_
#define _TITLEDB_H_

#include <windows.h>
#include <tchar.h>

class CTitleLibrary
{
protected:
	TCHAR*	m_tcsDataBlock;		// The title / index data block
	TCHAR**	m_atcsNames;		// The lookup table w/ pointers indexed into the data block
	long	m_lMaxIndex;		// The upper index limit

	HRESULT Initialize();

public:
	CTitleLibrary();
	~CTitleLibrary();

	HRESULT GetName (long lID, TCHAR** ptcsName);
};

#endif //_TITLEDB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\evilperf\showperflib\titledb.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//TitleDB.cpp

#include "TitleDB.h"

#define PERFLIB	TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\PerfLib")

///////////////////////////////////////////////////////////////////////////////
//
//	CTitleLibrary
//
//	The CCtrLibrary object is an object that evaluates object and counter
//	titles based on their IDs.  The object uses a lookup table, where the 
//	elements reference strings in a block of ID / title pairs and the index
//	is the ID values of the object and counters.
//
///////////////////////////////////////////////////////////////////////////////

CTitleLibrary::CTitleLibrary()
///////////////////////////////////////////////////////////////////////////////
//
//	Constructor
//
///////////////////////////////////////////////////////////////////////////////
{
	Initialize();
}

CTitleLibrary::~CTitleLibrary()
///////////////////////////////////////////////////////////////////////////////
//
//	Destructor
//
///////////////////////////////////////////////////////////////////////////////
{
	if (m_tcsDataBlock)
		delete []m_tcsDataBlock;

	if (m_atcsNames)
		delete []m_atcsNames;
}

HRESULT CTitleLibrary::Initialize()
///////////////////////////////////////////////////////////////////////////////
//
//	Initialize
//
//	Sets up the lookup table for the library.  The titles are indexed by their
//	key ID values.
//
//	Determine the maximum index value of the titles.  Attempt to query the 
//	title/index pairs to determine how large of a block must be allocated to
//	accept the structure.  Create the block, and then query the title\index
//	pairs.  Create a lookup table the size of the maximum index, and populate 
//	it with the retrieved title data.
//
///////////////////////////////////////////////////////////////////////////////
{
	HKEY hKey = 0;

	// Get the upper index limit
	// =========================

	DWORD dwSize;

    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, PERFLIB,
									  0, KEY_READ, &hKey))
	{
        return E_FAIL;
	}

	dwSize = 4;

    if (ERROR_SUCCESS != RegQueryValueEx(hKey, "Last Counter", 
										 0, 0, (PBYTE)&m_lMaxIndex, &dwSize))
    {
        RegCloseKey(hKey);
        return E_FAIL;
    }

    RegCloseKey(hKey);

	// Get the size of block required to retrieve the title / index pairs
	// ==================================================================

	if (ERROR_SUCCESS != RegQueryValueEx(HKEY_PERFORMANCE_DATA, TEXT("Counter009"), 
										 0, 0, 0, &dwSize))
		return E_FAIL;

	// Allocate the block, and retrieve the title / index pairs
	// ========================================================

	m_tcsDataBlock = new TCHAR[dwSize];

	if (ERROR_SUCCESS != RegQueryValueEx(HKEY_PERFORMANCE_DATA, TEXT("Counter009"), 
										 0, 0, (PBYTE)m_tcsDataBlock,	&dwSize))
	{
		delete []m_tcsDataBlock;
		return E_FAIL;
	}

	// Allocate and clear the memory for the lookup table
	// ==================================================

	m_atcsNames = new TCHAR*[m_lMaxIndex + 1];
    memset(m_atcsNames, 0, (sizeof(TCHAR*) * (m_lMaxIndex + 1)));

	// Populate the lookup table
	// =========================



    TCHAR* tcsTemp = m_tcsDataBlock;
    int nLen, nIndex;

    while ( 0 != (nLen = lstrlen(tcsTemp)))
    {
		// Get the index
		// =============

        nIndex = _ttoi(tcsTemp);
        tcsTemp += nLen + 1;

		// Set the table element at the index value to the string pointer 
		// ==============================================================

        m_atcsNames[nIndex] = tcsTemp;
        tcsTemp += lstrlen(tcsTemp) + 1;
    }

	return S_OK;
}

HRESULT CTitleLibrary::GetName(long lID, TCHAR** ptcsName)
///////////////////////////////////////////////////////////////////////////////
//
//	GetName
//
//	Evaluates the title given an object's or counter's ID.
//
//	Parameters:
//		lID			- the Index into the library
//		pstrName	- the Name
//
///////////////////////////////////////////////////////////////////////////////
{
	// Is it a valid index?
	// ====================

	if (lID > m_lMaxIndex)
		return E_INVALIDARG;
	
	// Assign the pointer
	// ==================

	*ptcsName = m_atcsNames[lID];

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\filerepository\dumptree\stdafx.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__14EAFE64_77CD_46E5_8480_C08DCF200C47__INCLUDED_)
#define AFX_STDAFX_H__14EAFE64_77CD_46E5_8480_C08DCF200C47__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <windows.h>
#include <tchar.h>
#include <stdio.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__14EAFE64_77CD_46E5_8480_C08DCF200C47__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\filerepository\filerepository\btreestack.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// BtreeStack.cpp: implementation of the CBtreeStack class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "BtreeStack.h"
#include "FlatFile.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


CBTreeStack::CBTreeStack()
: m_dwNumEntries(0), m_dwSize(0), m_pBuffer(NULL), m_dwGrowBy(10)
{
}

CBTreeStack::~CBTreeStack()
{
	HeapFree(GetProcessHeap(), 0, m_pBuffer);
}

int CBTreeStack::PushPage(const CFlatFilePage &page)
{
	if (m_pBuffer == NULL)
	{
		//Need to allocate the stack...
		m_pBuffer = (DWORD*)HeapAlloc(GetProcessHeap(), 0, m_dwGrowBy * sizeof(DWORD));
		if (m_pBuffer == NULL)
			return OutOfMemory;
		m_dwSize += m_dwGrowBy;
	}
	else if (m_dwSize == m_dwNumEntries)
	{
		//Need to grow the stack...
		DWORD *pBuff = (DWORD*)HeapReAlloc(GetProcessHeap(), 0, m_pBuffer, (m_dwSize + m_dwGrowBy) * sizeof(DWORD));
		if (pBuff == NULL)
			return OutOfMemory;
		m_pBuffer = pBuff;		
		m_dwSize += m_dwGrowBy;
	}
	m_pBuffer[m_dwNumEntries++] = page.GetPageNumber();
	m_pBuffer[m_dwNumEntries++] = (DWORD)page.GetPagePointer();

	return NoError;
}

int CBTreeStack::PopPage(CFlatFilePage &page)
{
	if ((m_pBuffer == 0) || (m_dwNumEntries == 0) || (m_dwNumEntries & 1))
		return Failed;

	page.SetPagePointer((void*)m_pBuffer[--m_dwNumEntries]);
	page.SetPageNumber(m_pBuffer[--m_dwNumEntries]);

	return NoError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\filerepository\filerepository\btree.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// BTree.h: interface for the CBTree class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_BTREE_H__06005BE0_1016_43AB_AD0B_D0E599AB0894__INCLUDED_)
#define AFX_BTREE_H__06005BE0_1016_43AB_AD0B_D0E599AB0894__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "FlatFile.h"

class CBTreeStack;

//#define BTREE_ORDER ((CFlatFile::DefaultPageSize - (sizeof(DWORD) * 2))/(sizeof(DWORD) * 2))
#define BTREE_ORDER 2

struct BTreeNode
{
	//Flag to specify the type of tree node item...
	//Bit 1..31	Number of entries in the node
	//Bit 32	Must be set to 1
	DWORD m_dwFlags;

	struct _BTreeNodeEntry
	{
		//Pointer to child tree or leaf
		DWORD m_dwPtr;
		//Pointer/actual key
		DWORD m_dwKeyPtr;
	} m_entry[BTREE_ORDER];

	//Pointer to child tree or leaf
	DWORD m_dwPtr;
};

struct BTreeLeaf
{
	//Flag to specify the type of tree node item...
	//Bit 1..31	Number of entries in the node
	//Bit 32	Must be set to 0
	DWORD m_dwFlags;

	struct _BTreeLeafEntry
	{
		//Pointer/actual key
		DWORD m_dwKeyPtr;
		//Pointer/actual data
		DWORD m_dwPtr;
	} m_entry[BTREE_ORDER];


	//Pointer to next leaf in tree
	DWORD m_dwPtrToNextLeaf;
};

class CBTree  
{
	CFlatFile m_file;
	CFlatFilePage m_rootPage;

protected:
	int FlatFileToBTreeError(int nError);
	int FindKeyInLeaf(BTreeLeaf *pCurLeaf, DWORD dwKey, DWORD &dwData, DWORD &dwPosition);
	int FindChildNode(BTreeNode *pCurNode, DWORD dwKey, DWORD &dwPage);
	int InsertEntryIntoLeaf(BTreeLeaf *pCurLeaf, DWORD dwMaxEntries, DWORD dwKey, DWORD dwData);
	int InsertEntryIntoNode(BTreeNode *pCurNode, DWORD dwMaxEntries, DWORD dwKey, DWORD dwData);
	int CopyLeafEntries(BTreeLeaf *pFromLeaf, DWORD dwStart, DWORD dwEnd, BTreeLeaf *pToLeaf);
	int CopyNodeEntries(BTreeNode *pFromNode, DWORD dwStart, DWORD dwEnd, BTreeNode *pToNode);
	int CreateNewRoot(CFlatFilePage &rootNode, CFlatFilePage &firstNode, DWORD dwKeySecondNode, CFlatFilePage &secondNode);
	int DumpTreeNode(BTreeNode *pNode, DWORD dwPageNumber, const char *szPadding);
	int DumpTreeLeaf(BTreeLeaf *pLeaf, DWORD dwPageNumber, const char *szPadding);

	int  ReleaseStack(CBTreeStack &stack);



public:
	enum {NoError = 0,				//Everything worked
		  NotImplemented = 1,		//Operation is not implemented
		  Failed = 2,				//Something went bad
		  OutOfMemory = 3,			//We ran out of memory
		  InvalidPageNumber = 4,	//Accessed an invalid page
		  NotFound = 5,				//Tried to find something and failed
		  TreeFull = 6,				//Tried to add an item and failed because it was full?
		  AlreadyExists = 7,		//Tried to add an item to the tree but it already exists!
		  UnknownErrorMapping = 9999//Tried to may a lower level error to one of ours and failed
	};

	CBTree(CFlatFile &file);
	virtual ~CBTree();

	//Initialise the BTree structure...
	int Initialise();

	//Deinitialise the BTree structure, tidying up any memory we cached...
	int Deinitialise();

	//Search for a single key value, returning the data pointer
	int Search(DWORD dwKey, DWORD &dwData);

	//Inserts the key and data into the correct place in the tree...
	int Insert(DWORD dwKey, DWORD dwData);

	//Deletes the specified entry from the tree...
	int Delete(DWORD dwKey);

	int DumpAllLeafNodes();

	int DumpAllNodes();
};

#endif // !defined(AFX_BTREE_H__06005BE0_1016_43AB_AD0B_D0E599AB0894__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\filerepository\filerepository\btree.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// BTree.cpp: implementation of the CBTree class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "BTree.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CBTree::CBTree(CFlatFile &file)
: m_file(file)
{

}

CBTree::~CBTree()
{
	Deinitialise();
}

//********************************************************
//
// Initialise will read in the root node/leaf.  If it does
// not exist because this is a new tree, we need to create 
// it.
//
//********************************************************
int CBTree::Initialise()
{
	DWORD dwRoot = m_file.GetRootPointer();

	if (dwRoot == 0)
	{
		//We have to create a new root...
		int nRet = m_file.AllocatePage(m_rootPage);
		if (nRet != CFlatFile::NoError)
			return FlatFileToBTreeError(nRet);

		DWORD *pLeaf = (DWORD*)m_rootPage.GetPagePointer();

		DWORD dwPageSize = m_file.GetPageSize() / sizeof(DWORD);
		for (DWORD dw = 0; dw != dwPageSize; dw++)
		{
			pLeaf[dw] = 0;
		}
		nRet = FlatFileToBTreeError(m_file.PutPage(m_rootPage));
		if (nRet != NoError)
			return nRet;
		return FlatFileToBTreeError(m_file.SetRootPointer(m_rootPage.GetPageNumber()));
	}
	else
	{
		//We just need to get the new root...
		return FlatFileToBTreeError(m_file.GetPage(dwRoot, m_rootPage));
	}
}

int CBTree::Deinitialise()
{
	if (m_rootPage.GetPageNumber())
	{
		return m_file.ReleasePage(m_rootPage);
	}
	return NoError;
}

int CBTree::FlatFileToBTreeError(int nFileError)
{
	int nError = UnknownErrorMapping;
	
	switch(nFileError)
	{
	case NoError:
		nError = NoError;
		break;
	case NotImplemented:
		nError = NotImplemented;
		break;
	case Failed:
		nError = Failed;
		break;
	case OutOfMemory:
		nError = OutOfMemory;
		break;
	case InvalidPageNumber:
		nError = Failed;
		break;
	}
	return nError;
}

int CBTree::Search(DWORD dwKey, DWORD &dwData)
{
	DWORD dwCurrentPageNumber = m_file.GetRootPointer();
	CFlatFilePage currentPage;
	int nRet;
	
	nRet = m_file.GetPage(dwCurrentPageNumber, currentPage);

	BTreeNode *pCurrentNode = (BTreeNode *)currentPage.GetPagePointer();

	//While we are still a node...
	while (pCurrentNode->m_dwFlags & 0x80000000)
	{
		DWORD dwNextNode = 0;
		BinarySearchNode(dwKey, pCurrentNode, dwNextNode);

		m_file.ReleasePage(currentPage);
		nRet = m_file.GetPage(dwNextNode, currentPage);
		if (nRet != CFlatFile::NoError)
			return FlatFileToBTreeError(nRet);

		pCurrentNode = (BTreeNode *)currentPage.GetPagePointer();
	}

	//pCurrentNode is now actually an leaf...
	BTreeLeaf *pCurrentLeaf = (BTreeLeaf *)pCurrentNode;

	return BinarySearchLeaf(dwKey, pCurrentLeaf, dwData);
}

int CBTree::BinarySearchNode(DWORD dwKey, BTreeNode *pCurrentNode, DWORD &dwData)
{
	for (DWORD dwIndex = 0; dwIndex != (pCurrentNode->m_dwFlags  & 0x7FFFFFFF); dwIndex++)
	{
		if (dwKey <= pCurrentNode->m_entry[dwIndex].m_dwKeyPtr)
		{
			dwData = pCurrentNode->m_entry[dwIndex].m_dwPtr;
			return NoError;
		}
	}
	dwData = pCurrentNode->m_dwPtr;
	return NoError;
}

int CBTree::BinarySearchLeaf(DWORD dwKey, BTreeLeaf *pCurrentLeaf, DWORD &dwData)
{
	for (DWORD dwIndex = 0; dwIndex != pCurrentLeaf->m_dwFlags; dwIndex++)
	{
		if (dwKey == pCurrentLeaf->m_entry[dwIndex].m_dwKeyPtr)
		{
			dwData = pCurrentLeaf->m_entry[dwIndex].m_dwPtr;
			return NoError;
		}
	}
	return NotFound;
}

int CBTree::Insert(DWORD dwKey, DWORD dwData)
{
	DWORD dwCurrentPageNumber = m_file.GetRootPointer();
	CFlatFilePage currentPage;
	int nRet;
	CBTreeStack pageStack;
	
	nRet = m_file.GetPage(dwCurrentPageNumber, currentPage);
	if (nRet != CFlatFile::NoError)
		return FlatFileToBTreeError(nRet);

	BTreeNode *pCurrentNode = (BTreeNode *)currentPage.GetPagePointer();

	//While we are still a node...
	while (pCurrentNode->m_dwFlags & 0x80000000)
	{
		DWORD dwNextNode = 0;
		BinarySearchNode(dwKey, pCurrentNode, dwNextNode);

		m_file.ReleasePage(currentPage);
		nRet = m_file.GetPage(dwNextNode, currentPage);
		if (nRet != CFlatFile::NoError)
		{
			ReleaseStack(pageStack);
			return FlatFileToBTreeError(nRet);
		}

		pageStack.PushPage(currentPage);

		pCurrentNode = (BTreeNode *)currentPage.GetPagePointer();
	}

	//pCurrentNode is now actually an leaf...
	BTreeLeaf *pCurrentLeaf = (BTreeLeaf *)pCurrentNode;

	if (pCurrentLeaf->m_dwFlags == BTREE_ORDER)
	{
		nRet = InsertIntoFullLeaf(currentPage, pageStack, dwKey, dwData);
		if (nRet != NoError)
			return nRet;

		m_file.ReleasePage(currentPage);
		ReleaseStack(pageStack);
		return NoError;
	}
	ReleaseStack(pageStack);

	nRet = InsertIntoLeaf(dwKey, dwData, pCurrentLeaf);
	if (nRet != NoError)
	{
		m_file.ReleasePage(currentPage);
		return nRet;
	}

	nRet = FlatFileToBTreeError(m_file.PutPage(currentPage));

	m_file.ReleasePage(currentPage);

	return nRet;
}

int CBTree::InsertIntoLeaf(DWORD dwKey, DWORD dwData, BTreeLeaf *pCurrentLeaf)
{
	for (DWORD dwIndex = 0; dwIndex != pCurrentLeaf->m_dwFlags; dwIndex++)
	{
		if (dwKey < pCurrentLeaf->m_entry[dwIndex].m_dwKeyPtr)
		{
			//We have found where we need to go, so we need to shuffle the
			//rest along one place...
			DWORD dwNumEntries = pCurrentLeaf->m_dwFlags - dwIndex;
			while (dwNumEntries)
			{
				pCurrentLeaf->m_entry[dwIndex +dwNumEntries] = pCurrentLeaf->m_entry[dwIndex + dwNumEntries - 1];
				dwNumEntries--;
			}

			pCurrentLeaf->m_entry[dwIndex].m_dwPtr = dwData;
			pCurrentLeaf->m_entry[dwIndex].m_dwKeyPtr = dwKey;
			pCurrentLeaf->m_dwFlags ++;
			return NoError;
		}
		else if (dwKey == pCurrentLeaf->m_entry[dwIndex].m_dwKeyPtr)
		{
			return AlreadyExists;
		}
	}

	//Guess it just goes on the end!
	pCurrentLeaf->m_entry[dwIndex].m_dwPtr = dwData;
	pCurrentLeaf->m_entry[dwIndex].m_dwKeyPtr = dwKey;
	pCurrentLeaf->m_dwFlags ++;
	return NoError;
}

int CBTree::InsertIntoFullLeaf(CFlatFilePage &currentLeaf, CBTreeStack &pageStack, DWORD dwKey, DWORD dwData)
{
	BTreeLeaf *pCurrentLeaf = (BTreeLeaf*) currentLeaf.GetPagePointer();

	//Create a new buffer big enough to take all the current items, plus one more
	BTreeLeaf::_BTreeLeafEntry *pNewEntry = (BTreeLeaf::_BTreeLeafEntry *)HeapAlloc(GetProcessHeap(), 0, sizeof(BTreeLeaf::_BTreeLeafEntry) * (BTREE_ORDER + 1));
	if (pNewEntry == NULL)
		return OutOfMemory;

	//Now make a copy of the existing items and insert the new item into the correct place...
	for (DWORD dwSourceIndex = 0, dwDestIndex = 0; dwSourceIndex < BTREE_ORDER; dwSourceIndex++, dwDestIndex++)
	{
		if (dwSourceIndex == 0)
		{
			if (dwKey < pCurrentLeaf->m_entry[dwSourceIndex].m_dwKeyPtr)
			{
				pNewEntry[dwDestIndex].m_dwKeyPtr = dwKey;
				pNewEntry[dwDestIndex].m_dwPtr = dwData;
				dwDestIndex++;
			}

		}
		else
		{
			if ((dwKey > pCurrentLeaf->m_entry[dwSourceIndex - 1].m_dwKeyPtr) &&
				(dwKey < pCurrentLeaf->m_entry[dwSourceIndex].m_dwKeyPtr))
			{
				//The new item goes in here!
				pNewEntry[dwDestIndex].m_dwKeyPtr = dwKey;
				pNewEntry[dwDestIndex].m_dwPtr = dwData;
				dwDestIndex++;
			}
		}
		pNewEntry[dwDestIndex] = pCurrentLeaf->m_entry[dwSourceIndex];
	}

	//We may have had to insert at the end, so lets just check...
	if (dwDestIndex == dwSourceIndex)
	{
		pNewEntry[dwDestIndex].m_dwKeyPtr = dwKey;
		pNewEntry[dwDestIndex].m_dwPtr = dwData;
		dwDestIndex++;
	}

	//Now we have a new leaf, however it is too big by one item!  Now we need to split it
	//into two leaves...  For this, we need to allocate a new leaf node!
	CFlatFilePage newLeaf;
	int nRet = FlatFileToBTreeError(m_file.AllocatePage(newLeaf));
	if (nRet != NoError)
		return nRet;

	BTreeLeaf *pNewLeaf = (BTreeLeaf*) newLeaf.GetPagePointer();

	//The cut-off point for the current page is going to be BTREE_ORDER/2...
	for (dwSourceIndex = BTREE_ORDER - (BTREE_ORDER/2), dwDestIndex = 0; dwSourceIndex < (BTREE_ORDER + 2); dwSourceIndex++, dwDestIndex++)
	{
		pNewLeaf->m_entry[dwDestIndex] = pNewEntry[dwSourceIndex];
	}

	//Copy the new start to the original page...
	for (dwSourceIndex = 0; dwSourceIndex < (BTREE_ORDER - (BTREE_ORDER/2) + 1); dwSourceIndex++)
	{
		pCurrentLeaf->m_entry[dwSourceIndex] = pNewEntry[dwSourceIndex];
	}
	

	//Set up the entry counts...
	pCurrentLeaf->m_dwFlags = BTREE_ORDER - (BTREE_ORDER/2) + 1;
	pNewLeaf->m_dwFlags = BTREE_ORDER/2 + 1;

	//Fix up the pointers...
	pNewLeaf->m_dwPtrToNextLeaf = pCurrentLeaf->m_dwPtrToNextLeaf;
	pCurrentLeaf->m_dwPtrToNextLeaf = newLeaf.GetPageNumber();

	if (pageStack.GetCount() == 0)
	{
		nRet = CreateNewRoot(currentLeaf.GetPageNumber(), newLeaf.GetPageNumber(), pNewLeaf->m_entry[0].m_dwKeyPtr);
		if (nRet != NoError)
		{
			printf("CreateNewRoot failed... database is inconsistent!\n");
			return nRet;
		}
		nRet = FlatFileToBTreeError(m_file.PutPage(currentLeaf));
		if (nRet != NoError)
		{
			printf("CreateNewRoot failed... database is inconsistent!\n");
			return nRet;
		}

		nRet = FlatFileToBTreeError(m_file.PutPage(newLeaf));
		if (nRet != NoError)
		{
			printf("CreateNewRoot failed... database is inconsistent!\n");
			return nRet;
		}
	}
	else
	{
		printf("NOT IMPLEMENTED PROPAGATION OF SPLIT UP NODE TREE YET!!!\n");
		return NotImplemented;
	}

	return NoError;

}

int CBTree::CreateNewRoot(DWORD dwPageLeaf1, DWORD dwPageLeaf2, DWORD dwFirstKeyLeaf2)
{
	CFlatFilePage root;
	int nRet = FlatFileToBTreeError(m_file.AllocatePage(root));
	if (nRet != NoError)
		return nRet;

	BTreeNode *pRootNode = (BTreeNode*)root.GetPagePointer();

	pRootNode->m_dwFlags = (0x80000000 + 1);
	pRootNode->m_entry[0].m_dwKeyPtr = dwFirstKeyLeaf2;
	pRootNode->m_entry[0].m_dwPtr = dwPageLeaf1;
	pRootNode->m_dwPtr = dwPageLeaf2;

	nRet = FlatFileToBTreeError(m_file.PutPage(root));
	if (nRet != NoError)
		return nRet;

	nRet = FlatFileToBTreeError(m_file.SetRootPointer(root.GetPageNumber()));
	if (nRet != NoError)
		return nRet;

	return NoError;
}


int CBTree::Delete(DWORD dwKey)
{
	DWORD dwCurrentPageNumber = m_file.GetRootPointer();
	CFlatFilePage currentPage;
	int nRet;
	
	nRet = m_file.GetPage(dwCurrentPageNumber, currentPage);
	if (nRet != CFlatFile::NoError)
		return FlatFileToBTreeError(nRet);

	BTreeNode *pCurrentNode = (BTreeNode *)currentPage.GetPagePointer();

	bool bRootPointsToLeaf = true;

	//While we are still a node...
	while (pCurrentNode->m_dwFlags & 0x80000000)
	{
		bRootPointsToLeaf = false;
		DWORD dwNextNode = 0;
		BinarySearchNode(dwKey, pCurrentNode, dwNextNode);

		m_file.ReleasePage(currentPage);
		nRet = m_file.GetPage(dwNextNode, currentPage);
		if (nRet != CFlatFile::NoError)
			return FlatFileToBTreeError(nRet);

		pCurrentNode = (BTreeNode *)currentPage.GetPagePointer();
	}

	//pCurrentNode is now actually an leaf...
	BTreeLeaf *pCurrentLeaf = (BTreeLeaf *)pCurrentNode;

	if (!bRootPointsToLeaf && (pCurrentLeaf->m_dwFlags < BTREE_ORDER/2))
	{
		//This leaf needs to grab an item from a neighbouring node,
		//or we need to merge with the neighbouring node if
		//it does not have one space...
		printf("Deletion from a leaf caused less than the allowed items."
			   "Merging is not yet implemented!!!!!\n");
	}

	nRet = DeleteFromLeaf(dwKey, pCurrentLeaf);
	if (nRet != NoError)
	{
		m_file.ReleasePage(currentPage);
		return nRet;
	}

	nRet = FlatFileToBTreeError(m_file.PutPage(currentPage));

	m_file.ReleasePage(currentPage);

	return nRet;
}

int CBTree::DeleteFromLeaf(DWORD dwKey, BTreeLeaf *pCurrentLeaf)
{
	for (DWORD dwIndex = 0; dwIndex != pCurrentLeaf->m_dwFlags; dwIndex++)
	{
		if (pCurrentLeaf->m_entry[dwIndex].m_dwKeyPtr > dwKey)
		{
			return NotFound;
		}
		else if (dwKey == pCurrentLeaf->m_entry[dwIndex].m_dwKeyPtr)
		{
			//We have found where we need to go, so we need to shuffle the
			//rest along one place...
			for (; dwIndex < (pCurrentLeaf->m_dwFlags - 1); dwIndex++)
			{
				pCurrentLeaf->m_entry[dwIndex] = pCurrentLeaf->m_entry[dwIndex + 1];
			}
			pCurrentLeaf->m_entry[dwIndex].m_dwKeyPtr = 0;
			pCurrentLeaf->m_entry[dwIndex].m_dwPtr = 0;
			pCurrentLeaf->m_dwFlags --;
			return NoError;
		}
	}

	return NotFound;
}

int CBTree::ReleaseStack(CBTreeStack &stack)
{
	CFlatFilePage page;
	while (stack.PopPage(page) == CBTreeStack::NoError)
	{
		m_file.ReleasePage(page);
	}
	return NoError;
}


CBTreeStack::CBTreeStack()
: m_dwNumEntries(0), m_dwSize(0), m_pBuffer(NULL), m_dwGrowBy(10)
{
}

CBTreeStack::~CBTreeStack()
{
	HeapFree(GetProcessHeap(), 0, m_pBuffer);
}

int CBTreeStack::PushPage(const CFlatFilePage &page)
{
	if (m_pBuffer == NULL)
	{
		//Need to allocate the stack...
		m_pBuffer = (DWORD*)HeapAlloc(GetProcessHeap(), 0, m_dwGrowBy * sizeof(DWORD));
		if (m_pBuffer == NULL)
			return OutOfMemory;
		m_dwSize += m_dwGrowBy;
	}
	else if (m_dwSize == m_dwNumEntries)
	{
		//Need to grow the stack...
		DWORD *pBuff = (DWORD*)HeapReAlloc(GetProcessHeap(), 0, m_pBuffer, (m_dwSize + m_dwGrowBy) * sizeof(DWORD));
		if (pBuff == NULL)
			return OutOfMemory;
		m_pBuffer = pBuff;		
		m_dwSize += m_dwGrowBy;
	}
	m_pBuffer[m_dwNumEntries++] = page.GetPageNumber();
	m_pBuffer[m_dwNumEntries++] = (DWORD)page.GetPagePointer();

	return NoError;
}

int CBTreeStack::PopPage(CFlatFilePage &page)
{
	if ((m_pBuffer == 0) || (m_dwNumEntries == 0) || (m_dwNumEntries & 1))
		return Failed;

	page.SetPagePointer((void*)m_pBuffer[--m_dwNumEntries]);
	page.SetPageNumber(m_pBuffer[--m_dwNumEntries]);

	return NoError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\filerepository\filerepository\btree2.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "stdafx.h"
#include "BTree.h"
#include "BTreeStack.h"

static const char *g_szSpacer = "    ";

CBTree::CBTree(CFlatFile &file)
: m_file(file)
{

}

CBTree::~CBTree()
{
	Deinitialise();
}

//********************************************************
//
// Initialise will read in the root node/leaf.  If it does
// not exist because this is a new tree, we need to create 
// it.
//
//********************************************************
int CBTree::Initialise()
{
	DWORD dwRoot = m_file.GetRootPointer();

	if (dwRoot == 0)
	{
		//We have to create a new root...
		int nRet = m_file.AllocatePage(m_rootPage);
		if (nRet != CFlatFile::NoError)
			return FlatFileToBTreeError(nRet);

		DWORD *pLeaf = (DWORD*)m_rootPage.GetPagePointer();

		DWORD dwPageSize = m_file.GetPageSize() / sizeof(DWORD);
		for (DWORD dw = 0; dw != dwPageSize; dw++)
		{
			pLeaf[dw] = 0;
		}
		nRet = FlatFileToBTreeError(m_file.PutPage(m_rootPage));
		if (nRet != NoError)
			return nRet;
		return FlatFileToBTreeError(m_file.SetRootPointer(m_rootPage.GetPageNumber()));
	}
	else
	{
		//We just need to get the new root...
		return FlatFileToBTreeError(m_file.GetPage(dwRoot, m_rootPage));
	}
}

int CBTree::Deinitialise()
{
	if (m_rootPage.GetPageNumber())
	{
		return m_file.ReleasePage(m_rootPage);
	}
	return NoError;
}

int CBTree::FlatFileToBTreeError(int nFileError)
{
	int nError = UnknownErrorMapping;
	
	switch(nFileError)
	{
	case NoError:
		nError = NoError;
		break;
	case NotImplemented:
		nError = NotImplemented;
		break;
	case Failed:
		nError = Failed;
		break;
	case OutOfMemory:
		nError = OutOfMemory;
		break;
	case InvalidPageNumber:
		nError = Failed;
		break;
	}
	return nError;
}


int CBTree::Insert(DWORD dwKey, DWORD dwData)
{
	//Page stack holds a list of all parent nodes we may have to
	//split.  We have to do a ReleasePage on all entries in here!
	CBTreeStack pageStack;

	//Get the root node...
	DWORD dwRootPage = m_file.GetRootPointer();
	CFlatFilePage curNode;
	int nRet = m_file.GetPage(dwRootPage, curNode);
	if (nRet != CFlatFile::NoError)
		return FlatFileToBTreeError(nRet);

	//Get a real node pointer to the root page
	BTreeNode *pCurNode = (BTreeNode *)curNode.GetPagePointer();

	//Search for a leaf...
	while (pCurNode->m_dwFlags & 0x80000000)
	{
		//We need to save off the node in case we later need to split it
		pageStack.PushPage(curNode);

		//Find the child node we next need
		DWORD dwNextNode = 0;
		FindChildNode(pCurNode, dwKey, dwNextNode);

		//Retrieve this next page
		nRet = m_file.GetPage(dwNextNode, curNode);
		if (nRet != CFlatFile::NoError)
		{
			ReleaseStack(pageStack);
			return FlatFileToBTreeError(nRet);
		}

		//Convert this next page to a pointer
		pCurNode = (BTreeNode *)curNode.GetPagePointer();
	}

	//pCurNode is now actually an leaf... so lets start using it as such
	BTreeLeaf *pCurLeaf = (BTreeLeaf *)pCurNode;

	//At this point we have the leaf which needs to have the item inserted into.
	//We need to make sure the item is not already in the leaf!
	DWORD dwSearchData = 0, dwSearchPosition = 0;
	if (FindKeyInLeaf(pCurLeaf, dwKey, dwSearchData, dwSearchPosition) == NoError)
	{
		//Release the stack of pages
		ReleaseStack(pageStack);
		
		//Our leaf is not stored in the stack, so we need to release it
		m_file.ReleasePage(curNode);

		//Return an error
		return AlreadyExists;
	}
	else
	{
		//If the current leaf is not full, we can just add it easily
		if (pCurLeaf->m_dwFlags != BTREE_ORDER)
		{
			//Insert out new item into curNode
			InsertEntryIntoLeaf(pCurLeaf, BTREE_ORDER, dwKey, dwData);

			//Store the page with the updates
			m_file.PutPage(curNode);

			//We are now done with the page, so release it
			m_file.ReleasePage(curNode);
		}
		else
		{
			//***copy curNode into tempNode which is big enough to take 1 too many items
			//Allocate a leaf node which is 1 entry bigger than normal
			BTreeLeaf *pTempNode = (BTreeLeaf *)HeapAlloc(GetProcessHeap(), 0, sizeof(BTreeLeaf) + sizeof(BTreeLeaf::_BTreeLeafEntry));
			if (pTempNode == NULL)
			{
				m_file.ReleasePage(curNode);
				ReleaseStack(pageStack);
				return OutOfMemory;
			}
			//Copy the current contents to the tempNode...
			CopyMemory(pTempNode, pCurLeaf, sizeof(BTreeLeaf));

			//Insert new entry into correct position in tempNode
			InsertEntryIntoLeaf(pTempNode, BTREE_ORDER+1, dwKey, dwData);

			//Allocate a new leaf in the tree...
			CFlatFilePage newLeaf;
			m_file.AllocatePage(newLeaf);
			if (nRet != CFlatFile::NoError)
			{
				HeapFree(GetProcessHeap(), 0, pTempNode);
				ReleaseStack(pageStack);
				m_file.ReleasePage(curNode);
				return FlatFileToBTreeError(nRet);
			}
			//Get a pointer to this new page
			BTreeLeaf *pNewLeaf = (BTreeLeaf *)newLeaf.GetPagePointer();

			pNewLeaf->m_dwPtrToNextLeaf = pCurLeaf->m_dwPtrToNextLeaf;
			pCurLeaf->m_dwPtrToNextLeaf = newLeaf.GetPageNumber();

			//Get an index value for the middle where we are to split the leaf
			DWORD dwMiddleEntry = (BTREE_ORDER + 1)/2;

			//Get the current search key for when we recurse up the tree node
			DWORD dwCurSearchKey = pCurLeaf->m_entry[dwMiddleEntry - 1].m_dwKeyPtr;

			if (dwKey <= dwCurSearchKey)
			{
				//Copy the first dwNumEntries from pTempNode into pNewLeaf
				CopyLeafEntries(pTempNode, 0, dwMiddleEntry, pNewLeaf);

				//Copy the remaining entries from pTempNode into pCurLeaf
				CopyLeafEntries(pTempNode, dwMiddleEntry, BTREE_ORDER +1, pCurLeaf);
			}
			else
			{
				//Copy the first dwNumEntries from pTempNode into pCurLeaf
				CopyLeafEntries(pTempNode, 0, dwMiddleEntry, pCurLeaf);

				//Copy the remaining entries from pTempNode into pNewLeaf
				CopyLeafEntries(pTempNode, dwMiddleEntry, BTREE_ORDER +1, pNewLeaf);
			}

			dwCurSearchKey = pNewLeaf->m_entry[pNewLeaf->m_dwFlags - 1].m_dwKeyPtr;

			//Delete the pTempNode pointer as we no longer need it
			HeapFree(GetProcessHeap(), 0, pTempNode);

			//We probably need to write the curNode and newNode back to disk now!!!
			m_file.PutPage(curNode);
			m_file.PutPage(newLeaf);


			//Now we need to insert (curSearchKey, newNode) into the parent node!
			//This could of course be full and need to propagate the split!
			bool bFinished = false;
			do
			{
				//Check to see if we have a parent node....
				if (pageStack.GetCount() == 0)
				{
					//There is no parent node.  we need to create a new parent root
					CFlatFilePage rootNode;
					m_file.AllocatePage(rootNode);
					if (nRet != CFlatFile::NoError)
					{
						m_file.ReleasePage(curNode);
						m_file.ReleasePage(newLeaf);
						return FlatFileToBTreeError(nRet);
					}
					
					//add to rootNode <curNode (old node), curSearchKey (new node first key), newNode>
					pCurNode = (BTreeNode *)curNode.GetPagePointer();
					CreateNewRoot(rootNode, curNode, pCurNode->m_entry[pCurNode->m_dwFlags -1].m_dwKeyPtr, newLeaf);
					
					//Set the root pointer to point to this new root
					m_file.SetRootPointer(rootNode.GetPageNumber());

					//We probably need to re-write back root now!
					m_file.PutPage(rootNode);

					//Release the root node, curNode and newLeaf
					m_file.ReleasePage(rootNode);
					m_file.ReleasePage(curNode);
					m_file.ReleasePage(newLeaf);

					//We're finished now, so we will terminate the loop
					bFinished = true;
				}
				else
				{
					//Release the current curNode as we now have no more
					//need for that version
					m_file.ReleasePage(curNode);

					//Now get the next parent node...
					pageStack.PopPage(curNode);
					pCurNode = (BTreeNode *)curNode.GetPagePointer();

					//Check to see if this node is full...
					if ((pCurNode->m_dwFlags & 0x7FFFFFFF) != BTREE_ORDER)
					{
						//No, the node is not full, therefore we only have to do a
						//simple insert of item

						//Insert the newLeaf (this may be a node!) into the
						//current node...
						//add to curNode <curSearchKey, newNode>
						InsertEntryIntoNode(pCurNode, BTREE_ORDER, dwCurSearchKey, newLeaf.GetPageNumber());
						
						//We probably need to re-write back curNode now!
						m_file.PutPage(curNode);

						//Release curNode and newNode
						m_file.ReleasePage(curNode);
						m_file.ReleasePage(newLeaf);

						//We're finished now, so we will terminate the loop
						bFinished = true;
					}
					else
					{
						//***Current node is full, so we have to split it!
						//copy curNode into tempNode which is big enough to take 1 too many items
						BTreeNode *pTempNode = (BTreeNode *)HeapAlloc(GetProcessHeap(), 0, sizeof(BTreeNode) + sizeof(BTreeNode::_BTreeNodeEntry));
						if (pTempNode == NULL)
						{
							m_file.ReleasePage(curNode);
							m_file.ReleasePage(newLeaf);
							ReleaseStack(pageStack);
							return OutOfMemory;
						}
						//Copy the current contents to the tempNode...
						CopyMemory(pTempNode, pCurNode, sizeof(BTreeNode));
						pTempNode->m_dwPtr = pCurNode->m_dwPtr;

						//Insert <curSearchKey, newNode> entry into correct position in tempNode
						InsertEntryIntoNode(pTempNode, BTREE_ORDER+1, dwCurSearchKey, newLeaf.GetPageNumber());
						
						//We can release old newLeaf as we have finished with it
						m_file.ReleasePage(newLeaf);

						//ALLOCATE newNode in the tree
						nRet = m_file.AllocatePage(newLeaf);
						if (nRet != CFlatFile::NoError)
						{
							HeapFree(GetProcessHeap(), 0, pTempNode);
							ReleaseStack(pageStack);
							m_file.ReleasePage(curNode);
							return FlatFileToBTreeError(nRet);
						}

						//Find the middle point so we can split the node...
						DWORD dwMiddleEntry = (BTREE_ORDER + 1)/2;

						//curNode = first jIndex entries in tempNode
						CopyNodeEntries(pTempNode, 0, dwMiddleEntry, pCurNode);
						
						//newNode = rest of entries from jIndex+1 in tempNode
						CopyNodeEntries(pTempNode, dwMiddleEntry + 1, BTREE_ORDER +1, pCurNode);

						//Set up the search for the next round of iterations...
						dwCurSearchKey = pCurNode->m_entry[0].m_dwKeyPtr;

						//Delete the temp object...
						HeapFree(GetProcessHeap(), 0, pTempNode);

						//We probably need to write the newNode
						m_file.PutPage(curNode);
						m_file.PutPage(newLeaf);
					}

				}
			} while (!bFinished);
		}
	}

	//Release the stack of pages
	ReleaseStack(pageStack);

	return NoError;
}

int CBTree::FindKeyInLeaf(BTreeLeaf *pCurLeaf, DWORD dwKey, DWORD &dwData, DWORD &dwPosition)
{
	if (pCurLeaf->m_dwFlags == 0)
		return NotFound;

	dwPosition = 0;
    int l = 0;
	int u = pCurLeaf->m_dwFlags - 1;

    while (l <= u)
    {
        int m = (l + u) / 2;

        if (dwKey < pCurLeaf->m_entry[m].m_dwKeyPtr)
        {
            u = m - 1;
            dwPosition = u + 1;
        }
        else if (dwKey > pCurLeaf->m_entry[m].m_dwKeyPtr)
        {
            l = m + 1;
            dwPosition = l;
        }
        else
        {
            dwPosition = m;
			dwData = pCurLeaf->m_entry[m].m_dwKeyPtr;
            return NoError;
        }
    }
	return NotFound;
}

int CBTree::FindChildNode(BTreeNode *pCurNode, DWORD dwKey, DWORD &dwPage)
{
	if (dwKey < pCurNode->m_entry[0].m_dwKeyPtr)
	{
		dwPage = pCurNode->m_entry[0].m_dwPtr;
		return NoError;
	}
	else if (dwKey > pCurNode->m_entry[(pCurNode->m_dwFlags & 0x7FFFFFFF) - 1].m_dwKeyPtr)
	{
		dwPage = pCurNode->m_dwPtr;
		return NoError;
	}
	else /* We can now do a binary search! */
	{
		DWORD l = 0;
		DWORD u = (pCurNode->m_dwFlags & 0x7FFFFFFF) - 1;

		while (l <= u)
		{
			DWORD m = (l + u) / 2;

			if (dwKey < pCurNode->m_entry[m - 1].m_dwKeyPtr)
			{
				u = m - 1;
			}
			else if (dwKey > pCurNode->m_entry[m + 1].m_dwKeyPtr)
			{
				l = m + 1;
			}
			else
			{
				dwPage = pCurNode->m_entry[m].m_dwKeyPtr;
				return NoError;
			}
		}
	}
	return NoError;
}

int CBTree::InsertEntryIntoLeaf(BTreeLeaf *pCurLeaf, DWORD dwMaxEntries, DWORD dwKey, DWORD dwData)
{
	bool bFound = false;
	DWORD dwIndex = pCurLeaf->m_dwFlags;
	while (dwIndex)
	{
		if (pCurLeaf->m_entry[dwIndex-1].m_dwKeyPtr > dwKey)
		{
			pCurLeaf->m_entry[dwIndex] = pCurLeaf->m_entry[dwIndex-1];
		}
		else
		{
			pCurLeaf->m_entry[dwIndex].m_dwKeyPtr = dwKey;
			pCurLeaf->m_entry[dwIndex].m_dwPtr = dwData;
			bFound = true;
			break;
		}
		dwIndex--;
	}
	if (!bFound)
	{
		pCurLeaf->m_entry[0].m_dwKeyPtr = dwKey;
		pCurLeaf->m_entry[0].m_dwPtr = dwData;
	}
	pCurLeaf->m_dwFlags++;
	return NoError;
}

int CBTree::InsertEntryIntoNode(BTreeNode *pCurNode, DWORD dwMaxEntries, DWORD dwKey, DWORD dwData)
{
	bool bFound = false;
	DWORD dwNumEntries = pCurNode->m_dwFlags & 0x7FFFFFFF;
	DWORD dwIndex = 0;

	//Find the insertion location...
	while ((dwIndex != dwNumEntries) && (dwKey > pCurNode->m_entry[dwIndex].m_dwKeyPtr))
	{
		dwIndex++;
	}

	DWORD dwInsertionLocation = dwIndex;

	dwIndex = dwNumEntries - 1;

	//Shift everything from this location onwards one place to the right
	while (dwIndex >= dwInsertionLocation)
	{
		pCurNode->m_entry[dwIndex+1] = pCurNode->m_entry[dwIndex];
		if (dwIndex == 0)
			break;
		dwIndex--;
	}
	if ((dwInsertionLocation == dwNumEntries) && (dwKey > pCurNode->m_entry[dwNumEntries-1].m_dwKeyPtr))
	{
		//We need to be the new last item...
		pCurNode->m_entry[dwInsertionLocation].m_dwPtr = pCurNode->m_dwPtr;
		pCurNode->m_entry[dwInsertionLocation].m_dwKeyPtr = dwKey;
		pCurNode->m_dwPtr = dwData;
	}
	else
	{
		//Just plain ordinary insertion
		pCurNode->m_entry[dwInsertionLocation].m_dwKeyPtr = dwKey;
		pCurNode->m_entry[dwInsertionLocation].m_dwPtr = dwData;
	}
	pCurNode->m_dwFlags++;
	return NoError;
}

int CBTree::CopyLeafEntries(BTreeLeaf *pFromLeaf, DWORD dwStart, DWORD dwEnd, BTreeLeaf *pToLeaf)
{
	for (DWORD dwIndex = 0;dwStart != dwEnd; dwStart++, dwIndex++)
	{
		pToLeaf->m_entry[dwIndex] = pFromLeaf->m_entry[dwStart];
	}
	pToLeaf->m_dwFlags = dwIndex;
	return NoError;
}

int CBTree::CopyNodeEntries(BTreeNode *pFromNode, DWORD dwStart, DWORD dwEnd, BTreeNode *pToNode)
{
	printf("Not implemented!\n");
	_asm int 3;
	return NotImplemented;
}

int CBTree::CreateNewRoot(CFlatFilePage &rootNode, CFlatFilePage &firstNode, DWORD dwKey, CFlatFilePage &secondNode)
{	
	BTreeNode *pNode = (BTreeNode *)rootNode.GetPagePointer();	
	pNode->m_dwFlags = 0x80000001;	//Node with 1 entry in it!
	pNode->m_entry[0].m_dwKeyPtr = dwKey;
	pNode->m_entry[0].m_dwPtr = firstNode.GetPageNumber();
	pNode->m_dwPtr = secondNode.GetPageNumber();
	
	return NoError;
}

int CBTree::ReleaseStack(CBTreeStack &stack)
{
	CFlatFilePage page;
	while (stack.PopPage(page) == CBTreeStack::NoError)
	{
		m_file.ReleasePage(page);
	}
	return NoError;
}

int CBTree::DumpAllNodes()
{
	printf("************************* TREE DUMP START **************************\n");
	DWORD dwNextPage = m_file.GetRootPointer();
	CFlatFilePage curNode;
	int nRet = m_file.GetPage(dwNextPage, curNode);
	if (nRet != CFlatFile::NoError)
		return FlatFileToBTreeError(nRet);

	BTreeNode *pCurNode = (BTreeNode *)curNode.GetPagePointer();

	//Search for a leaf...
	if (pCurNode->m_dwFlags & 0x80000000)
		return DumpTreeNode(pCurNode, dwNextPage, "");
	else
		return DumpTreeLeaf((BTreeLeaf*)pCurNode, dwNextPage, "");
}

int CBTree::DumpTreeNode(BTreeNode *pNode, DWORD dwPageNumber, const char *szPadding)
{
	//Dump this node...
	printf("%sNode Page %lu: ", szPadding, dwPageNumber);
	for (DWORD dwIndex = 0; dwIndex != (pNode->m_dwFlags & 0x7FFFFFFF); dwIndex++)
	{
		printf("<key=%lu, page=%lu> ", pNode->m_entry[dwIndex].m_dwKeyPtr, pNode->m_entry[dwIndex].m_dwPtr);
	}
	printf("<Last Page=%lu>\n", pNode->m_dwPtr);

	//Now we need to iterate through the child pages!
	char *szChildPadding = new char[strlen(szPadding) + strlen(g_szSpacer) + 1];
	if (szChildPadding == NULL)
		return OutOfMemory;
	strcpy(szChildPadding, g_szSpacer);
	strcat(szChildPadding, szPadding);

	for (dwIndex = 0; dwIndex != (pNode->m_dwFlags & 0x7FFFFFFF); dwIndex++)
	{
		CFlatFilePage curNode;
		int nRet = m_file.GetPage(pNode->m_entry[dwIndex].m_dwPtr, curNode);
		if (nRet != CFlatFile::NoError)
		{
			delete [] szChildPadding;
			return FlatFileToBTreeError(nRet);
		}

		BTreeNode *pCurNode = (BTreeNode *)curNode.GetPagePointer();

		//Search for a leaf...
		if (pCurNode->m_dwFlags & 0x80000000)
			nRet = DumpTreeNode(pCurNode, pNode->m_entry[dwIndex].m_dwPtr, szChildPadding);
		else
			nRet = DumpTreeLeaf((BTreeLeaf*)pCurNode, pNode->m_entry[dwIndex].m_dwPtr, szChildPadding);

		m_file.ReleasePage(curNode);
		if (nRet != NoError)
		{
			return nRet;
		}
	}
	CFlatFilePage curNode;
	int nRet = m_file.GetPage(pNode->m_dwPtr, curNode);
	if (nRet != CFlatFile::NoError)
	{
		delete [] szChildPadding;
		return FlatFileToBTreeError(nRet);
	}

	BTreeNode *pCurNode = (BTreeNode *)curNode.GetPagePointer();

	//Search for a leaf...
	if (pCurNode->m_dwFlags & 0x80000000)
		nRet = DumpTreeNode(pCurNode, pNode->m_dwPtr, szChildPadding);
	else
		nRet = DumpTreeLeaf((BTreeLeaf*)pCurNode, pNode->m_dwPtr, szChildPadding);

	m_file.ReleasePage(curNode);
	delete [] szChildPadding;
	if (nRet != NoError)
		return nRet;

	return NoError;
}

int CBTree::DumpTreeLeaf(BTreeLeaf *pLeaf, DWORD dwPageNumber, const char *szPadding)
{
	printf("%sLeaf Page %lu: ", szPadding, dwPageNumber);

	for (DWORD dwIndex = 0; dwIndex != pLeaf->m_dwFlags; dwIndex++)
	{
		printf("<key=%lu" /*" data=%lu"*/ "> ", pLeaf->m_entry[dwIndex].m_dwKeyPtr/*, pLeaf->m_entry[dwIndex].m_dwPtr*/);
	}
	printf("<Next Leaf Page %lu>\n", pLeaf->m_dwPtrToNextLeaf);

	return NoError;
}

int CBTree::DumpAllLeafNodes()
{
	//We need to iterate down to the left-most node...
	DWORD dwNextPage = m_file.GetRootPointer();
	CFlatFilePage curNode;
	int nRet = m_file.GetPage(dwNextPage, curNode);
	if (nRet != CFlatFile::NoError)
		return FlatFileToBTreeError(nRet);

	//Get a real node pointer to the root page
	BTreeNode *pCurNode = (BTreeNode *)curNode.GetPagePointer();

	//Search for a leaf...
	while (pCurNode->m_dwFlags & 0x80000000)
	{
		dwNextPage = pCurNode->m_entry[0].m_dwPtr;
		m_file.ReleasePage(curNode);
		m_file.GetPage(dwNextPage, curNode);
	}

	do
	{
		BTreeLeaf *pCurLeaf = (BTreeLeaf *)pCurNode;

		printf("Page %lu\n", dwNextPage);

		for (DWORD dwIndex = 0; dwIndex != pCurLeaf->m_dwFlags; dwIndex++)
		{
			printf("<key=%lu, data=%lu> ", pCurLeaf->m_entry[dwIndex].m_dwKeyPtr, pCurLeaf->m_entry[dwIndex].m_dwPtr);
		}
		printf("\n");

		dwNextPage = pCurLeaf->m_dwPtrToNextLeaf;
		m_file.ReleasePage(curNode);
		if (dwNextPage)
			m_file.GetPage(dwNextPage, curNode);

	} while (dwNextPage);

	return NoError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\filerepository\filerepository\btreestack.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// BtreeStack.h: interface for the CBtreeStack class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_BTREESTACK_H__C54473C8_2911_4EE5_9063_BFF4AE0DB307__INCLUDED_)
#define AFX_BTREESTACK_H__C54473C8_2911_4EE5_9063_BFF4AE0DB307__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
class CFlatFilePage;

class CBTreeStack
{
	DWORD  m_dwNumEntries;			//Number of entries in the stack
	DWORD  m_dwSize;				//Size of the current stack buffer
	DWORD  m_dwGrowBy;				//How many DWORD's will we grow it by when needed
	DWORD *m_pBuffer;				//Buffer for entries to be pushed on stack

public:
	enum {NoError = 0,				//Everything worked
		  Failed = 1,				//Something went really wrong!
		  OutOfMemory = 2			//We ran out of memory
	};

	CBTreeStack();
	~CBTreeStack();
	int   PushPage(const CFlatFilePage &page);
	int   PopPage(CFlatFilePage &page);
	DWORD GetCount() { return m_dwNumEntries; }
};

#endif // !defined(AFX_BTREESTACK_H__C54473C8_2911_4EE5_9063_BFF4AE0DB307__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\filerepository\filerepository\filerepository.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// FileRepository.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <conio.h>
#include "FlatFile.h"
#include "BTree.h"

void TestFileOperations(CFlatFile &file);
void TestTreeOperations(CFlatFile &file);

int main(int argc, char* argv[])
{
	DeleteFile(_TEXT("file.dbf"));

	CFlatFile file;

	file.CreateFile(_TEXT("file.dbf"));

//	TestFileOperations(file);

	TestTreeOperations(file);

	file.CloseFile();

	printf("Press any key to continue...\n");
	_getch();
	return 0;
}

void TestTreeOperations(CFlatFile &file)
{
	int nErr;
	CBTree tree(file);
	tree.Initialise();

	for (DWORD i = 0; i != 8; i++)
	{
		nErr = tree.Insert(i, i);
		if (nErr != CBTree::NoError)
		{
			printf("Failed to insert item %d, error %lu\n", i, nErr);
		}
		nErr = tree.DumpAllNodes();
		if (nErr != CBTree::NoError)
		{
			printf("Failed to dump tree, error %lu\n", nErr);
			break;
		}
	}
	tree.Deinitialise();
}


void TestFileOperations(CFlatFile &file)
{
	CFlatFilePage page;
	file.GetPage(1, page);

	file.PutPage(page);

	file.ReleasePage(page);

	CFlatFilePage fileArray[10];
	for (int i = 0; i != 10; i++)
	{
		file.AllocatePage(fileArray[i]);
	}

	char strPageMessage[200];
	for (i = 0; i != 10; i++)
	{
		sprintf(strPageMessage, "Allocated page %d", i);
		strcpy((char*)fileArray[i].GetPagePointer(), strPageMessage);
		file.PutPage(fileArray[i]);
	}

	for (i = 0; i != 10; i++)
	{
		file.DeallocatePage(fileArray[i].GetPageNumber());
	}

	for (i = 0; i != 10; i++)
	{
		file.ReleasePage(fileArray[i]);
	}

	for (i = 0; i != 10000; i++)
	{
		file.AllocatePage(page);
		file.ReleasePage(page);
	}

	for (i = 2; i != 1002; i++)
	{
		file.GetPage(i, page);
		file.ReleasePage(page);
	}

	for (i = 2; i != 10002; i++)
	{
		file.DeallocatePage(i);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\filerepository\filerepository\flatfile.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// FlatFile.cpp: implementation of the CFlatFile class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "FlatFile.h"

#ifndef INVALID_SET_FILE_POINTER
#define INVALID_SET_FILE_POINTER ((DWORD)-1)
#endif

struct CFF_FILEHEADER
{
	enum { CurrentFileFormat = 1 };

	DWORD m_dwFileFormat;
	DWORD m_dwPageSize;
	DWORD m_dwNumberPages;
	DWORD m_dwGrowPageCount;
	DWORD m_dwFirstDeletedPage;
	DWORD m_dwRootPointer;
};

struct CFF_DELETEDPAGEHEADER
{
	DWORD m_dwNextDeletedPage;
};


CFlatFile::CFlatFile()
: m_hFile(INVALID_HANDLE_VALUE)
{

}

CFlatFile::~CFlatFile()
{

}

//******************************************************************
//
// CreateFile will take the filename specified and open it as one of
// our files.  If the file already exists it will use the current
// parameters, otherwise it will create it with the parameters
// specified.
//
// tszFilename:	Full path and filename of file to open/create
// swPageSize:	Size of each page.  We have to be aware that
//				this has to be a multiple of the sector size!
// dwInitialNumberPages:	Number of pages to create in the 
//				file if the file does not exist.
// dwGrowPageCount:	When we need to grow the file, how many pages
//				do we create, the spare ones are marked as deleted.
//
//******************************************************************
int CFlatFile::CreateFile(const TCHAR *tszFilename, 
			   DWORD dwPageSize, 
			   DWORD dwInitialNumberPages,
			   DWORD dwGrowPageCount)
{
	m_hFile = ::CreateFile(tszFilename, 
						   GENERIC_READ | GENERIC_WRITE, 
						   0, 
						   NULL, 
						   OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING, 
						   NULL);
	if (m_hFile == INVALID_HANDLE_VALUE)
		return Failed;
	if (GetLastError() == ERROR_ALREADY_EXISTS)
	{
		return OpenExistingFile();
	}
	else
	{
		return CreateNewFile(dwPageSize, dwInitialNumberPages, dwGrowPageCount);
	}
}

//******************************************************************
//
// CloseFile will close the current file.  Once closed all operations
// will fail until the file is opened again with OpenFile.
//
//******************************************************************
int CFlatFile::CloseFile()
{
	ReleasePage(m_headerPage);
	CloseHandle(m_hFile);
	m_hFile = INVALID_HANDLE_VALUE;
	return NoError;
}

//******************************************************************
//
// AllocatePage either hands out a currently deleted page and updates
// the delete chain to reflect the allocation of the page, or it
// will grow the file and pass back a new page.  If the GrowPage
// number is greater than one then it allocates more pages and
// adds the spare to the delete chain.
//
// page:	on return, will contain the new page and page number
//			associated with page.  We do not clear out the current
//			contents of this class before adding the new page details.
//			If it already holds page details this will cause a leak!
//
//******************************************************************
int CFlatFile::AllocatePage(CFlatFilePage &page)
{
	int nRet;

	if (m_pHeader->m_dwFirstDeletedPage != 0)
	{
		//We have a page to use, so update the delete list
		CFlatFilePage newPage;
		nRet = GetPage(m_pHeader->m_dwFirstDeletedPage, newPage);
		if (nRet == NoError)
		{
			//Now mark the page as in use... by removing it from the delete list
			CFF_DELETEDPAGEHEADER *pDelHeader = (CFF_DELETEDPAGEHEADER *)newPage.m_pPage;
			m_pHeader->m_dwFirstDeletedPage = pDelHeader->m_dwNextDeletedPage;
			nRet = PutPage(m_headerPage);

			if (nRet == NoError)
			{
				page = newPage;
			}
		}
		
		return nRet;
	}
	else
	{
		DWORD dwCurNumbPages = m_pHeader->m_dwNumberPages;

		m_pHeader->m_dwNumberPages += m_pHeader->m_dwGrowPageCount;

		//The first of these new pages we will return to the user, the rest we need to mark for deletion...
		for (DWORD dwCurPage = dwCurNumbPages + 2; dwCurPage <= (dwCurNumbPages + m_pHeader->m_dwGrowPageCount); dwCurPage++)
		{
			if (DeallocatePage(dwCurPage, true) != NoError)
			{
				//Bad news!
				printf("Failed to write one of the new deleted pages created while doing an AllocatePage\n");
				return Failed;
			}
		}
		nRet = PutPage(m_headerPage);
		if (nRet != NoError)
		{
			return nRet;
		}

		void *pPage = HeapAlloc(GetProcessHeap(), 0, m_pHeader->m_dwPageSize);
		if (pPage == NULL)
		{
			printf("Failed to allocate memory in AllocatePage\n");
			return OutOfMemory;
		}
		page.m_dwPageNumber = dwCurNumbPages + 1;
		page.m_pPage = pPage;
	}

	return NoError;
}


//******************************************************************
//
// DeallocatePage adds the page to the free list.  The page must not 
// be referenced after this point, and definately should not have 
// the page written back otherwise it will corrupt the delete chain.
//
// dwPageNumber:	The page number of the page to delete.
// bDontPutHeader:	If you do not want the parent to be written
//					back on the deletion, set this to true.  It
//					is defaulted to false as this is normal behavour.
//
//******************************************************************
int CFlatFile::DeallocatePage(DWORD dwPageNumber, bool bDontPutHeader)
{
	if ((dwPageNumber == 0) || (dwPageNumber > m_pHeader->m_dwNumberPages))
	{
		printf("Page number %lu is either zero or greater than the number of actual pages!\n", dwPageNumber);
		return InvalidPageNumber;
	}

	CFlatFilePage deletePage;
	deletePage.m_pPage = HeapAlloc(GetProcessHeap(), 0, m_pHeader->m_dwPageSize);
	if (deletePage.m_pPage == NULL)
	{
		return OutOfMemory;
	}
	deletePage.m_dwPageNumber = dwPageNumber;

	CFF_DELETEDPAGEHEADER *pDeletePageHeader = (CFF_DELETEDPAGEHEADER*) deletePage.m_pPage;
	pDeletePageHeader->m_dwNextDeletedPage = m_pHeader->m_dwFirstDeletedPage;
	m_pHeader->m_dwFirstDeletedPage = dwPageNumber;

	int nRet = PutPage(deletePage);

	if (nRet != NoError)
	{
		ReleasePage(deletePage);
		return nRet;
	}

	if (!bDontPutHeader)
	{
		nRet = PutPage(m_headerPage);

		if (nRet != NoError)
		{
			//This needs to be able to roll back!
			printf("FAILURE!  We have written the deleted item, however we were not able to write the updated header!\n");
		}
	}

	ReleasePage(deletePage);

	return nRet;
}

//******************************************************************
//
// GetPage gets an actual page from the file.  This loads the page into
// memory and makes a copy of it.  There is no concurency control.
// Therefore if one GetPage gets it, changes it, then another GetPage
// is done somewhere else, changes it, then the first page is put, then
// the second, the first change will be lost!  This functionality may
// change!
//
//******************************************************************
int CFlatFile::GetPage(DWORD dwPageNumber, CFlatFilePage &page)
{
	if ((dwPageNumber == 0) || (dwPageNumber > m_pHeader->m_dwNumberPages))
	{
		printf("Page number %lu is either zero or greater than the number of actual pages!\n", dwPageNumber);
		return InvalidPageNumber;
	}

	dwPageNumber--;

	void *pPage = HeapAlloc(GetProcessHeap(), 0, m_pHeader->m_dwPageSize);
	if (pPage == NULL)
		return OutOfMemory;

	LARGE_INTEGER liFilePosition;
	liFilePosition.QuadPart = dwPageNumber * m_pHeader->m_dwPageSize;
	LONG dwHigh = liFilePosition.HighPart;
	if ((SetFilePointer(m_hFile, liFilePosition.LowPart, &dwHigh, FILE_BEGIN) == INVALID_SET_FILE_POINTER) && (GetLastError() != NO_ERROR))
	{
		printf("Failed to seek to the page requested in GetPage\n");
		HeapFree(GetProcessHeap(), 0, pPage);
		return Failed;
	}

	DWORD dwNumBytesRead = 0;
	if (ReadFile(m_hFile, pPage, m_pHeader->m_dwPageSize, &dwNumBytesRead, NULL) == 0)
	{
		printf("Failed to read the page while doing a GetPage\n");
		HeapFree(GetProcessHeap(), 0, pPage);
		return Failed;
	}

	if (dwNumBytesRead == 0)
	{
		printf("Warning: Retrieving a page with GetPage before writing it!\n");
	}
	else if (dwNumBytesRead != m_pHeader->m_dwPageSize)
	{
		printf("Size of page read does not match that of the pre-defined page size\n");
		HeapFree(GetProcessHeap(), 0, pPage);
		return Failed;
	}

	page.m_pPage = pPage;
	page.m_dwPageNumber = dwPageNumber + 1;

	return NoError;
}

//******************************************************************
//
// PutPage stores an actual page from the file.  There is no 
// concurency control.  Therefore if one GetPage gets it, changes it, 
// then another GetPage is done somewhere else, changes it, then the 
// first page is put, then the second, the first change will be lost!  
// This functionality may change!
//
// page:	This is the page that has been retrieved with a GetPage
//			and the contents of the page has been changed by the
//			caller.
//
//******************************************************************
int CFlatFile::PutPage(const CFlatFilePage &page)
{
	if ((page.m_dwPageNumber == 0) || (page.m_dwPageNumber > m_pHeader->m_dwNumberPages))
	{
		printf("Page number %lu is either zero or greater than the number of actual pages!\n", page.m_dwPageNumber);
		return InvalidPageNumber;
	}

	LARGE_INTEGER liFilePosition;
	liFilePosition.QuadPart = (page.m_dwPageNumber - 1) * m_pHeader->m_dwPageSize;

	LONG dwHigh = liFilePosition.HighPart;
	if ((SetFilePointer(m_hFile, liFilePosition.LowPart, &dwHigh, FILE_BEGIN) == INVALID_SET_FILE_POINTER) && (GetLastError() != NO_ERROR))
	{
		printf("Failed to seek to the page requested in PutPage\n");
		return Failed;
	}

	DWORD dwNumBytesWritten = 0;
	if ((WriteFile(m_hFile, page.m_pPage, m_pHeader->m_dwPageSize, &dwNumBytesWritten, NULL) == 0) || (dwNumBytesWritten != m_pHeader->m_dwPageSize))
	{
		printf("Failed to wr8te the page while doing a PutPage\n");
		return Failed;
	}

	return NoError;
}

//******************************************************************
//
// RelesaePage frees up the resources that are put in a page when 
// the caller gets or allocates a page.  All calls to GetPage or
// AllocatePage need to call ReleasePage on the returned page other
// wise a memory leak will be generated.
//
// page:	the page that needs to be freed up.
//
//******************************************************************
int CFlatFile::ReleasePage(CFlatFilePage &page)
{
	page.m_dwPageNumber = 0;
	HeapFree(GetProcessHeap(), 0, page.m_pPage);
	page.m_pPage = NULL;
	return NoError;
}

//******************************************************************
//
// OpenExistingFile continues the CreateFile process, now the file 
// is opened this method reads in the header of the file.
//
//******************************************************************
int CFlatFile::OpenExistingFile()
{
	DWORD dwSectorsPerCluster, dwBytesPerSector, dwNumberOfFreeClusters, dwTotalNumberOfClusters;
	if (GetDiskFreeSpace(__TEXT("d:\\"), &dwSectorsPerCluster, &dwBytesPerSector, &dwNumberOfFreeClusters, &dwTotalNumberOfClusters) == 0)
	{
		printf("Failed to get the number of bytes per sector.\n");
		return Failed;
	}

	m_headerPage.m_pPage = HeapAlloc(GetProcessHeap(), 0, dwBytesPerSector);
	if (m_headerPage.m_pPage == 0)
		return OutOfMemory;

	m_headerPage.m_dwPageNumber = 1;


	DWORD dwNumBytesRead = 0;
	if ((ReadFile(m_hFile, m_headerPage.m_pPage, dwBytesPerSector, &dwNumBytesRead, NULL) == 0) || (dwNumBytesRead != dwBytesPerSector))
	{
		printf("Failed to read file header...\n");
		HeapFree(GetProcessHeap(), 0, m_headerPage.m_pPage);
		m_headerPage.m_dwPageNumber = 0;
		return Failed;
	}

	m_pHeader = (CFF_FILEHEADER*)m_headerPage.m_pPage;

	return NoError;
}

//******************************************************************
//
// CreateNewFile continue the CreateFile process, now the file has been
// created, we need to initialise the file and the system.
//
// dwPageSize:	Size of each page
// dwInitialNumberPages:	number of pages to pre-create
// dwGrowPageCount:	The number of pages that are pre-created when
//				an allocation needs to grow the file.
//
//******************************************************************
int CFlatFile::CreateNewFile(DWORD dwPageSize, 
				  DWORD dwInitialNumberPages,
				  DWORD dwGrowPageCount)
{
	m_headerPage.m_pPage = HeapAlloc(GetProcessHeap(), 0, dwPageSize);
	if (m_headerPage.m_pPage == NULL)
		return OutOfMemory;
	m_headerPage.m_dwPageNumber = 1;

	m_pHeader = (CFF_FILEHEADER *)m_headerPage.m_pPage;

	m_pHeader->m_dwFileFormat = CFF_FILEHEADER::CurrentFileFormat;
	m_pHeader->m_dwNumberPages = 1;
	m_pHeader->m_dwPageSize = dwPageSize;
	m_pHeader->m_dwGrowPageCount = dwGrowPageCount;
	m_pHeader->m_dwFirstDeletedPage = 0;
	m_pHeader->m_dwRootPointer = 0;


	DWORD dwBytesWritten = 0;
	if ((WriteFile(m_hFile, m_headerPage.m_pPage, dwPageSize, &dwBytesWritten, NULL) == 0) || (dwBytesWritten != m_pHeader->m_dwPageSize))
	{
		HeapFree(GetProcessHeap(), 0, m_headerPage.m_pPage);
		m_headerPage.m_dwPageNumber = 0;
		printf("Failed to write the start page of the file...\n");
		return Failed;
	}

	return NoError;
}

//******************************************************************
//
//
//******************************************************************
DWORD CFlatFile::GetRootPointer()
{
	return ((CFF_FILEHEADER*)(m_headerPage.m_pPage))->m_dwRootPointer;
}

//******************************************************************
//
//
//******************************************************************
int CFlatFile::SetRootPointer(DWORD dwRootPointer)
{
	m_pHeader->m_dwRootPointer = dwRootPointer;
	return PutPage(m_headerPage);
}

//******************************************************************
//
//
//******************************************************************
DWORD CFlatFile::GetPageSize()
{
	return m_pHeader->m_dwPageSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\filerepository\filerepository\stdafx.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__DA14F0FB_8BF0_11D3_8610_00105A1F8304__INCLUDED_)
#define AFX_STDAFX_H__DA14F0FB_8BF0_11D3_8610_00105A1F8304__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <windows.h>
#include <tchar.h>
#include <stdio.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__DA14F0FB_8BF0_11D3_8610_00105A1F8304__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\hiperprov\common.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#ifndef _COMMON_H_
#define _COMMON_H_

#include <stdio.h>

// Logging macros

#define _LOGGING

#ifdef _LOGGING

#define LOGFILE "LOG.TXT"

#define INITLOG \
{\
DeleteFile(LOGFILE);\
}

#define LOG(msg) \
{\
FILE *f = fopen(LOGFILE, "a");\
SYSTEMTIME st;\
GetLocalTime(&st);\
fprintf(f, "%u\\%u\\%u %u:%u %s\n", st.wDay, st.wMonth, st.wYear, st.wHour, st.wMinute, msg);\
fclose(f);\
}

#define LOGERROR(msg) \
{\
FILE *f = fopen(LOGFILE, "a");\
SYSTEMTIME st;\
GetLocalTime(&st);\
fprintf(f, "%u\\%u\\%u %u:%u **ERROR**: %s\n", st.wDay, st.wMonth, st.wYear, st.wHour, st.wMinute, msg);\
fclose(f);\
}

#else

#define INITLOG
#define LOG(msg)
#define ERROR(msg)

#endif // _LOGGING

#endif // _COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\filerepository\filerepository\stdafx.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// stdafx.cpp : source file that includes just the standard includes
//	FileRepository.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\instprov\precomp.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>

#define COREPROX_POLARITY __declspec( dllexport )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\hiperprov\cooltemp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//////////////////////////////////////////////////////////////////////
//
//	CoolTemp.h
//
//	A collection of cool templates
//
//	Jan 16, 1999, Created by a-dcrews
//	
//////////////////////////////////////////////////////////////////////

#ifndef _COOLTEMP_H_
#define _COOLTEMP_H_

//////////////////////////////////////////////////////////////////////
//
//						CComObjectPtr
//						=============
//
//	This is a smart pointer object.  Once an object is declared, it 
//	is treated the same as any other interface pointer except that 
//	the smart pointer is responsible for managing the refrence 
//	counting.
//
//	Note that derived classes must implement the operator= methods
//	since the methods are a special case of non-inheritable 
//	overloaded operators
//
//////////////////////////////////////////////////////////////////////
/*
template <class TInterface>
class CComObjectPtr
{
protected:
public:
	TInterface *m_pObject;

	CComObjectPtr() : m_pObject(0){}
	CComObjectPtr(TInterface* pObject) : m_pObject(pObject) {m_pObject->AddRef();}
	CComObjectPtr(const CComObjectPtr<TInterface>& x) : m_pObject(x.m_pObject){m_pObject->AddRef();}
	virtual ~CComObjectPtr(){if (m_pObject) m_pObject->Release(); m_pObject = (TInterface*)0xDDDDDDDD;}

	operator TInterface*() {return m_pObject;}		// (TInterface*)
	TInterface& operator*() {return *m_pObject;}	// *pObj
	TInterface* operator->() {return m_pObject;}	// pObj->
	TInterface** operator&() {return &m_pObject;}	// &pObj

	CComObjectPtr& operator=(const int ptr) {return operator=((TInterface*)ptr);}
	CComObjectPtr& operator=(TInterface* pObject) {if (m_pObject) m_pObject->Release(); m_pObject = pObject; if (m_pObject) m_pObject->AddRef(); return *this;}
	CComObjectPtr& operator=(CComObjectPtr& x){operator=(x.m_pObject); return *this;}

	friend int operator==(CComObjectPtr<TInterface> &x, TInterface* pObject){return (x.m_pObject == pObject);}
	friend int operator!=(CComObjectPtr<TInterface> &x, TInterface* pObject){return (x.m_pObject != pObject);}
	friend int operator==(TInterface* pObject, CComObjectPtr<TInterface> &x){return (x.m_pObject == pObject);}
	friend int operator!=(TInterface* pObject, CComObjectPtr<TInterface> &x){return (operator!=(x, pObject));}
};
*/
//////////////////////////////////////////////////////////////////////
//
//						CSparseArray
//						============
//
//
//////////////////////////////////////////////////////////////////////

#define NULL_ELEMENT	0xFFFFFFFF

template <class TInterface, long lSize>
class CSparseArray
{
protected:
	TInterface*	m_apElement[lSize];

public:
	CSparseArray() : m_lHead(NULL_ELEMENT), m_lTail(NULL_ELEMENT)
	{
		for (long lIndex = 0; lIndex < lSize; lIndex++)
			m_apElement[lIndex] = 0;
	}
	~CSparseArray() 
	{
		for (long lIndex = 0; lIndex < lSize; lIndex++)
			if (m_apElement[lIndex])
				m_apElement->Release();
	}

	HRESULT Set(TInterface* pElement, long lIndex);
	HRESULT Reset(TInterface* pElement, long lIndex);
	HRESULT Clear(long lIndex);
	TInterface* operator[](const long lIndex) 
	{
		if (lIndex >= lSize || (0 == m_apArray[lIndex]))
			return NULL;

		return m_apArray[lIndex]->m_pElement;
	}

	HRESULT BeginEnum() {m_lEnum = m_lHead; return S_OK;}
	HRESULT Next(TInterface **ppObject, long *plIndex);
	HRESULT EndEnum() {return S_OK;}
};

template <class TInterface, long lSize> 
HRESULT CSparseArray<TInterface, lSize>::Set(TInterface *pElement, long lIndex)
{
	if (lIndex >= lSize)
		return E_FAIL;

	// Element must be empty
	// =====================

	if (m_apArray[lIndex])
		return E_FAIL;

	// Set the element
	// ===============

	return Reset(pElement, lIndex);
}

template <class TInterface, long lSize> 
HRESULT CSparseArray<TInterface, lSize>::Reset(TInterface *pElement, long lIndex)
{
	if (lIndex >= lSize)
		return E_FAIL;

	// If the element is unintialized, then set it up
	// ==============================================

	if (!m_apArray[lIndex])
	{
		// Allocate some memory
		// ====================

		m_apArray[lIndex] = new CSparseArrayEl; 

		// Update the tail pointer (and head pointer if this is the first element)
		// =======================================================================

		if (NULL_ELEMENT == m_lHead)
			m_lHead = m_lTail = lIndex;
		else
		{
			m_apArray[m_lTail]->m_lNext = lIndex;
			m_apArray[lIndex]->m_lPrev = m_lTail;
			m_lTail = lIndex;
		}
	}

	// Set the element to the interface pointer (interface pointer is a smart pointer)
	// ===============================================================================

	m_apArray[lIndex]->m_pElement = pElement;

	return S_OK;
}

template <class TInterface, long lSize>
HRESULT CSparseArray<TInterface, lSize>::Clear(long lIndex)
{
	if (lIndex >= lSize)
		return E_FAIL;

	// If the element is uninitialized, then we may have a problem
	// ===========================================================

	if (!m_apArray[lIndex])
		return E_FAIL;

	long lPrev = m_apArray[lIndex]->m_lPrev,
		 lNext = m_apArray[lIndex]->m_lNext;

	// Set the previous element's next property
	// ========================================

	if (NULL_ELEMENT != lPrev)
		m_apArray[lPrev]->m_lNext = lNext;

	// Set the next element's prev property
	// ====================================

	if (NULL_ELEMENT != lNext)
		m_apArray[lNext]->m_lPrev = lPrev;

	// Zap the element
	// ===============

	delete m_apArray[lIndex];
	m_apArray[lIndex] = 0;

	return S_OK;
}

template <class TInterface, long lSize>
HRESULT CSparseArray<TInterface, lSize>::Next(TInterface **ppObject, long *plIndex) 
{
	if (NULL_ELEMENT == m_lEnum)
		return S_FALSE;

	TInterface *pI = m_apArray[m_lEnum]->m_pElement; 
	*ppObject = pI;
	pI->AddRef();

	*plIndex = m_lEnum;

	m_lEnum = m_apArray[m_lEnum]->m_lNext;
	return S_OK;
}

#endif	// _COOLTEMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\filerepository\filerepository\flatfile.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// FlatFile.h: interface for the CFlatFile class.
//
// This file defines the interface for the flat file.  It implement the 
// page allocator/deallocator, and page retriever.
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FLATFILE_H__DA14F0FF_8BF0_11D3_8610_00105A1F8304__INCLUDED_)
#define AFX_FLATFILE_H__DA14F0FF_8BF0_11D3_8610_00105A1F8304__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CFlatFile;
struct CFF_FILEHEADER;

class CFlatFilePage
{
	friend CFlatFile;

	DWORD m_dwPageNumber;
	void *m_pPage;

public:
	CFlatFilePage() : m_dwPageNumber(0), m_pPage(NULL) {}
	CFlatFilePage(DWORD dwPageNumber, void *pPage) {m_dwPageNumber = dwPageNumber; m_pPage = pPage; }
	CFlatFilePage(const CFlatFilePage& page) {m_dwPageNumber = page.m_dwPageNumber; m_pPage = page.m_pPage; }
	~CFlatFilePage() {}
	DWORD GetPageNumber() const { return m_dwPageNumber; } 
	void *GetPagePointer() const { return m_pPage; } ;
	void  SetPageNumber(DWORD  dwPageNumber) { m_dwPageNumber = dwPageNumber; }
	void  SetPagePointer(void* pPage) { m_pPage = pPage; }
};


//========================================================================
//
// Class: CFlatFile
//
// Description: 
//	Implements the low level file page management.  It allows a page to
//	be allocated, freed, retrieved and written.
//	
class CFlatFile  
{
private:
	HANDLE          m_hFile;
	CFlatFilePage   m_headerPage;
	CFF_FILEHEADER *m_pHeader;

protected:
	//Continues the CreateFile process, now the file is opened
	//we need to initialise the system
	int OpenExistingFile();

	//Continue the CreateFile process, now the file has been
	//created, we need to initialise the file and the system.
	int CreateNewFile(DWORD dwPageSize, 
				      DWORD dwInitialNumberPages,
				      DWORD dwGrowPageCount);

public:
	//This is the default, and recommended default page size
	enum {DefaultPageSize = 512};

	//This is the default number of pages we create when we create
	//a new file.
	enum {DefaultInitialNumberPages = 1};

	enum {NoError = 0,
		  NotImplemented = 1,
		  Failed = 2,
		  OutOfMemory = 3,
		  InvalidPageNumber = 4
	};

	//This is the number of pages we allocate every time we need to 
	//grow the file
	enum {DefaultGrowPageCount = 1};

	CFlatFile();
	virtual ~CFlatFile();

	//CreateFile will take the filename specified and open it as one of
	//our files.  If the file already exists it will use the current
	//parameters, otherwise it will create it with the parameters
	//specified.
	int CreateFile(const TCHAR *tszFilename, 
				   DWORD dwPageSize = DefaultPageSize, 
				   DWORD dwInitialNumberPages = DefaultInitialNumberPages,
				   DWORD dwGrowPageCount = DefaultGrowPageCount);

	//Close file will close the current file.  Once closed all operations
	//will fail until the file is opened again with OpenFile.
	int CloseFile();

	//Allocates a new page within the file. It will allocate it from the
	//free list if any space is available, otherwise it will grow the 
	//file by the specified GrowPageCount amount and give you the page
	//number back.
	int AllocatePage(CFlatFilePage &page);

	//Adds the page to the free list.  The page must not be referenced 
	//after this point.  If you specify not to put the header page
	//back to disk, the caller has to do this otherwise the pages
	//will not be put into the delete change and what is in the
	//cached header will not be what is in the file.
	int DeallocatePage(DWORD dwPageNumber, bool bDontPutHeaderPage = false);

	//Gets an actual page from the file.  This loads the page into
	//memory at this point, so ReleasePage must be called when 
	//finished with the page.
	int GetPage(DWORD dwPageNumber, CFlatFilePage &page);

	//If a page has changed and needs to be written back, this
	//method will do that.
	int PutPage(const CFlatFilePage &page);

	//Once a page has been finished with, the page has to be released.
	//At this point the page will not be usable until it is re-loaded.
	int ReleasePage(CFlatFilePage &page);

	DWORD GetRootPointer();
	int   SetRootPointer(DWORD dwRootPointer);
	DWORD GetPageSize();
};


#endif // !defined(AFX_FLATFILE_H__DA14F0FF_8BF0_11D3_8610_00105A1F8304__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\mergertest\precomp.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>

#define COREPROX_POLARITY __declspec( dllexport )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\hpenumtest\hpenumtest.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// OBJINTERNALSTESTDlg.cpp : implementation file
//

#define _WIN32_WINNT 0x0400

#include <windows.h>
#include <process.h>
//#include <objbase.h>
#include <stdio.h>
#include <wbemcli.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include <fastall.h>
#include <cominit.h>
#include "hiperfenum.h"
#include "cloadhpenum.h"
#include "refrenum.h"

#define	SEED				5000
#define	NUMTHREADS			2
#define	NUMREPS				1000
#define DEFAULT_NUMPROPS	5

// Global counters

DWORD					g_dwNumObjects = SEED;
DWORD					g_dwNumReps = NUMREPS;
DWORD					g_dwNumProperties = DEFAULT_NUMPROPS;
long*					g_pPropHandles = NULL;

/*
unsigned SinkTest( void* pvData )
{
	long				alIds1[SEED],
						alIds2[SEED];

	IWbemClassObject*	apObj1[SEED];

	IWbemClassObject*	apObj2[SEED];
	IWbemClassObject*	apGetObj[SEED*2];

	long	lVal1 = 0, lVal2 = 1;

	// Initialize the arrays
	for ( DWORD	dwCtr = 0; dwCtr < SEED; dwCtr++, lVal1 += 2, lVal2 += 2 )
	{
		alIds1[dwCtr] = lVal1;
		alIds2[dwCtr] = lVal2;

		apObj1[dwCtr] = new CWbemInstance;
		apObj2[dwCtr] = new CWbemInstance;
	}

	CHiPerfEnum	hpEnum;

	// Add First set
	HRESULT	hr = hpEnum.AddObjects( SEED, alIds1, apObj1 );

	// Add Second set
	hr = hpEnum.AddObjects( SEED, alIds2, apObj2 );

	// Get Objects

	DWORD	dwReturned = 0;
	hr = hpEnum.GetObjects( SEED*2, apGetObj, &dwReturned );

	for ( dwCtr = 0; dwCtr < dwReturned; dwCtr++ )
	{
		apGetObj[dwCtr]->Release();
		apGetObj[dwCtr] = NULL;
	}

	// Remove the second set

	hr = hpEnum.RemoveObjects( SEED, alIds2 );

	hr = hpEnum.GetObjects( SEED*2, apGetObj, &dwReturned );

	for ( dwCtr = 0; dwCtr < dwReturned; dwCtr++ )
	{
		apGetObj[dwCtr]->Release();
		apGetObj[dwCtr] = NULL;
	}

	for ( dwCtr = 0; dwCtr < SEED; dwCtr++ )
	{
		apObj1[dwCtr]->Release();
		apObj2[dwCtr]->Release();
	}

}
*/

CClientLoadableHiPerfEnum*	gpHPEnum = NULL;

HANDLE	g_hReadyEvent;
HANDLE	g_hGoEvent;

CRITICAL_SECTION g_cs;

void ConsoleLock( void )
{
	EnterCriticalSection( &g_cs );
}

void ConsoleUnlock( void )
{
	LeaveCriticalSection( &g_cs );
}

CHiPerfLock	TestLock;

/*
unsigned __stdcall ThreadEntry( void * pvData )
{
	long				alIds[g_dwNumObjects];
	IWbemClassObject*	apObj[g_dwNumObjects];
	IWbemClassObject*	apGetObj[g_dwNumObjects*NUMTHREADS];

	long	lVal = (long) pvData;
	long	lSeed = (long) pvData;

	// Initialize the arrays
	for ( DWORD	dwCtr = 0; dwCtr < g_dwNumObjects; dwCtr++, lVal += NUMTHREADS )
	{
		alIds[dwCtr] = lVal;
		apObj[dwCtr] = new CWbemInstance;
	}

	// Seed the random numbers
	srand( GetTickCount() );

	printf ( "Thread %d Initialized!\n", lSeed );

	SetEvent( g_hReadyEvent );
	WaitForSingleObject( g_hGoEvent, INFINITE );
*/
/*
	for ( int y = 0; y < g_dwNumReps; y++ )
	{
		if ( TestLock.Lock() )
		{
			printf( "Thread %d GotIt!\n", lSeed);
			Sleep( rand() % 100 );
			TestLock.Unlock();
		}
	}

	return 0;
*/
/*
	HRESULT	hr = WBEM_S_NO_ERROR;

	for ( int x = 0; x < g_dwNumReps; x++ )
	{
		switch ( ( GetTickCount() + lSeed ) % 2 )
		{
			case 0:
			{
				hr = gpHPEnum->AddObjects( g_dwNumObjects, alIds, apObj );

				ConsoleLock();
				printf( "Thread %d Add Objects returned: 0x%x, Repetition: %d\n", lSeed, hr , x);
				ConsoleUnlock();

				break;
			}
*/
/*
			case 1:
			{
				hr = gpHPEnum->RemoveObjects( g_dwNumObjects, alIds );

				ConsoleLock();
				printf( "Thread %d Remove Objects returned: 0x%x, Repetition: %d\n", lSeed, hr, x );
				ConsoleUnlock();

				break;
			}
*/
/*
			case 1:
			{
				DWORD	dwReturned = 0;
				hr = gpHPEnum->GetObjects( NUMTHREADS * g_dwNumObjects, apGetObj, &dwReturned );

				ConsoleLock();
				printf( "Thread %d Get Objects returned: 0x%x, returned %d objects, Repetition: %d\n", lSeed, hr, dwReturned, x );
				ConsoleUnlock();

				if ( SUCCEEDED( hr ) )
				{
					for ( int n = 0; n < dwReturned; n++ )
					{
						apGetObj[n]->Release();
						apGetObj[n] = NULL;
					}
				}
				break;
			}
			
		}	// SWITCH

		Sleep( 100 );

	}	// FOR add objects

	// Cleanup objects
	for ( dwCtr = 0; dwCtr < g_dwNumObjects; dwCtr++ )
	{
		apObj[dwCtr]->Release();
	}

	ConsoleLock();
	printf ( "Thread %d exiting!\n", lSeed );
	ConsoleUnlock();

	return 0;
}
*/

CWbemInstance*	gpInst = NULL;

void InitTemplate( void )
{
	// Creates a sample class
	CWbemClass*			pClass = new CWbemClass;
	VARIANT				vTemp;

	pClass->InitEmpty();

	VariantInit( &vTemp );

	V_VT( &vTemp ) = VT_BSTR;
	V_BSTR( &vTemp ) = SysAllocString( L"TestClass" );

	pClass->Put( L"__CLASS", 0, &vTemp, CIM_STRING );

	VariantClear( &vTemp );

	// Allocate the property handle array
	g_pPropHandles = new long[g_dwNumProperties];

	WCHAR	wcsProperty[32];

	for ( DWORD dwCtr = 0; dwCtr < g_dwNumProperties; dwCtr++ )
	{
		swprintf( wcsProperty, L"Property%d", dwCtr );
		pClass->Put( wcsProperty, 0, NULL, CIM_UINT32 );
	}

	pClass->SpawnInstance( 0, (IWbemClassObject**) &gpInst );

	IWbemObjectAccess*	pObjAccess = NULL;

	gpInst->QueryInterface( IID_IWbemObjectAccess, (void**) &pObjAccess );

	CIMTYPE	ct;
	for ( dwCtr = 0; dwCtr < g_dwNumProperties; dwCtr++ )
	{
		swprintf( wcsProperty, L"Property%d", dwCtr );
		pObjAccess->GetPropertyHandle( wcsProperty, &ct, &g_pPropHandles[dwCtr] );
	}

	pObjAccess->Release();

	pClass->Release();
}

HANDLE	g_hRefreshEvent;
HANDLE	g_hRefreshDoneEvent;

unsigned __stdcall WriteThread( void * pvData )
{
	long*				alIds = new long[g_dwNumObjects];
	IWbemClassObject**	apObj = new IWbemClassObject*[g_dwNumObjects];
	IWbemObjectAccess**	apObjAccess = new IWbemObjectAccess*[g_dwNumObjects];
	BYTE*				abUsed = new BYTE[g_dwNumObjects];
	IWbemClassObject**	apGetObj = new IWbemClassObject*[g_dwNumObjects];

	DWORD				dwNumObjects = g_dwNumObjects;

	InitTemplate();

	// We will need a template for copying objects
	gpHPEnum->SetInstanceTemplate( gpInst );

	long	lVal = (long) pvData;
	long	lSeed = (long) pvData;

	// Initialize the arrays
	for ( DWORD	dwCtr = 0; dwCtr < g_dwNumObjects; dwCtr++, lVal++ )
	{
		alIds[dwCtr] = lVal;
		gpInst->Clone( &apObj[dwCtr] );
		apObj[dwCtr]->QueryInterface( IID_IWbemObjectAccess, (void**) &apObjAccess[dwCtr] );
	}

	// Add the entire set of objects to the enumerator
	HRESULT hr = gpHPEnum->AddObjects( g_dwNumObjects, alIds, apObj );
	FillMemory( abUsed, sizeof(abUsed), 1 );

	// Seed the random numbers
	srand( GetTickCount() );

	printf ( "Thread %d Initialized!\n", lSeed );

	SetEvent( g_hReadyEvent );
	WaitForSingleObject( g_hGoEvent, INFINITE );

	for ( int x = 0; x < g_dwNumReps; x++ )
	{
//		WaitForSingleObject( g_hRefreshEvent, INFINITE );

		// We will Modify/Add/Remove 10 percent of the objects
		DWORD	dwNumOps = dwNumObjects * 0.10;

		// Start at a random location
		int	y = rand() % g_dwNumObjects;

		DWORD	dwVal = 0;

		while ( dwNumOps )
		{
			dwVal++;

			// Add the object if it does not exist
			if ( abUsed[y] )
			{
				// 50% of the time modify the object, other 50% remove
				if ( rand() % 2 )
				{
					// Modify object here
					for ( DWORD dwPropCtr = 0; dwPropCtr < g_dwNumProperties; dwPropCtr++ )
					{
						apObjAccess[y]->WriteDWORD( g_pPropHandles[dwPropCtr], dwVal );
					}
				}
				else
				{
					hr = gpHPEnum->RemoveObjects( 1, &alIds[y] );
					abUsed[y] = 0;
					dwNumObjects--;
				}
			}
			else
			{
				hr = gpHPEnum->AddObjects( 1, &alIds[y], &apObj[y] );
				abUsed[y] = 1;
				dwNumObjects++;
			}

			// Wrap to beginning
			if ( ++y == g_dwNumObjects )
			{
				y = 0;
			}

			--dwNumOps;
		}

		// Were Done
//		SetEvent( g_hRefreshDoneEvent );

		Sleep(1000);

	}	// FOR add objects

	// Cleanup objects
	for ( dwCtr = 0; dwCtr < g_dwNumObjects; dwCtr++ )
	{
		apObj[dwCtr]->Release();
		apObjAccess[dwCtr]->Release();
	}

	ConsoleLock();
	printf ( "Write Thread exiting!\n" );
	ConsoleUnlock();

	delete [] alIds;
	delete [] apObj;
	delete [] apObjAccess;
	delete [] abUsed;
	delete [] apGetObj;

	return 0;
}

unsigned __stdcall ReadThread( void * pvData )
{
	IWbemClassObject**		apGetObj = new IWbemClassObject*[g_dwNumObjects];
	DWORD					dwNumReturned = g_dwNumObjects;
	HRESULT					hr = WBEM_S_NO_ERROR;

	CRefresherEnumerator	refrEnum;

	SetEvent( g_hReadyEvent );
	WaitForSingleObject( g_hGoEvent, INFINITE );

	for ( int x = 0; x < g_dwNumReps; x++ )
	{
//		SetEvent( g_hRefreshEvent );
//		WaitForSingleObject( g_hRefreshDoneEvent, INFINITE );

//		hr = gpHPEnum->GetObjects( g_dwNumObjects, apGetObj, &dwNumReturned );

		hr = refrEnum.Reset( gpHPEnum );

		if ( SUCCEEDED( hr ) )
		{
			IWbemClassObject*	pObj = NULL;
			DWORD				dwCtr = 0,
								dwReturned = 0,
								dwValue;

			while ( SUCCEEDED(hr) && hr != WBEM_S_FALSE )
			{
				hr = refrEnum.Next( INFINITE, 1, &pObj, &dwReturned );

				if ( SUCCEEDED( hr ) && hr != WBEM_S_FALSE )
				{
					// Use object access
					IWbemObjectAccess*	pObjAccess;

					pObj->QueryInterface( IID_IWbemObjectAccess, (VOID**) &pObjAccess );

					// Retrieve values here
					for ( DWORD dwPropCtr = 0; dwPropCtr < g_dwNumProperties; dwPropCtr++ )
					{
						pObjAccess->ReadDWORD( g_pPropHandles[dwPropCtr], &dwValue );
					}

					pObjAccess->Release();
					dwCtr++;
				}
			}

			ConsoleLock();
			printf( "Read Thread: Enumerator returned: 0x%x, returned %d objects, Repetition: %d\n", hr, dwCtr, x );
			ConsoleUnlock();

		}

/*
		if ( SUCCEEDED( hr ) )
		{
			for ( int n = 0; n < dwNumReturned; n++ )
			{
				apGetObj[n]->Release();
				apGetObj[n] = NULL;
			}
		}
*/

		Sleep(1000);
	}

	ConsoleLock();
	printf ( "Read Thread exiting!\n" );
	ConsoleUnlock();

	delete [] apGetObj;

	return 0;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	main
//
//	Entry point function to exercise IWbemObjectInternals interface.
//
///////////////////////////////////////////////////////////////////

int main( int argc, char *argv[] )
{
	char	szMachineName[256];

	// Set the global config counters
	if ( argc > 1 )
	{
		g_dwNumObjects = strtoul( argv[1], NULL, 10 );

		if ( argc > 2 )
		{
			g_dwNumReps = strtoul( argv[2], NULL, 10 );

			if ( argc > 3 )
			{
				g_dwNumProperties = strtoul( argv[3], NULL, 10 );
			}

		}
	}

	InitializeCom();
	InitializeSecurity(RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE );

	InitializeCriticalSection( &g_cs );

	HANDLE	ahThreads[NUMTHREADS];
	
	gpHPEnum = new CClientLoadableHiPerfEnum( NULL );

	g_hReadyEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
	g_hGoEvent = CreateEvent( NULL, TRUE, FALSE, NULL );

	g_hRefreshEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
	g_hRefreshDoneEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

	// Spinlock test code

/*
	for ( DWORD dwCtr = 0; dwCtr < NUMTHREADS; dwCtr++ )
	{
		ahThreads[dwCtr] = (HANDLE) _beginthreadex( NULL, 0, ThreadEntry, (void*) dwCtr, 0, NULL );

		// Wait for thread to initialize
		WaitForSingleObject( g_hReadyEvent, INFINITE );
	}

	// Start your engines!
	SetEvent( g_hGoEvent );

	WaitForMultipleObjects( NUMTHREADS, ahThreads, TRUE, INFINITE );

	for ( dwCtr = 0; dwCtr < NUMTHREADS; dwCtr++ )
	{
		CloseHandle( ahThreads[dwCtr] );
	}
*/

	// Read/Write Test Code

	ahThreads[0] = (HANDLE) _beginthreadex( NULL, 0, WriteThread, NULL, 0, NULL );
	// Wait for thread to initialize
	WaitForSingleObject( g_hReadyEvent, INFINITE );

	ahThreads[1] =  (HANDLE) _beginthreadex( NULL, 0, ReadThread, NULL, 0, NULL );
	// Wait for thread to initialize
	WaitForSingleObject( g_hReadyEvent, INFINITE );

	// Start your engines!
	SetEvent( g_hGoEvent );

	WaitForMultipleObjects( 2, ahThreads, TRUE, INFINITE );

	// Cleanup the events
	CloseHandle( g_hReadyEvent );
	CloseHandle( g_hGoEvent );
	CloseHandle( g_hRefreshEvent );
	CloseHandle( g_hRefreshDoneEvent );

	delete gpHPEnum;
	delete g_pPropHandles;

//	SinkTest();

	CoUninitialize();

	DeleteCriticalSection( &g_cs );

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\instprov\stdprov.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//***************************************************************************
//
//  STDPROV.CPP
//
//  Sample provider for LogicalDisk
//
//***************************************************************************

#include "precomp.h"
#include <stdio.h>

#include <wbemidl.h>

#include <stdprov.h>



//***************************************************************************
//
//  CStdProvider constructor
//
//***************************************************************************
// ok

CStdProvider::CStdProvider()
{
    m_lRef = 0;
    m_pClassDef = 0;
}

//***************************************************************************
//
//  CStdProvider destructor
//
//***************************************************************************
// ok

CStdProvider::~CStdProvider()
{
    if (m_pClassDef)
        m_pClassDef->Release();
}


//***************************************************************************
//
//  CStdProvider::AddRef
//
//***************************************************************************
// ok

ULONG CStdProvider::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

//***************************************************************************
//
//  CStdProvider::Release
//
//***************************************************************************
// ok

ULONG CStdProvider::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

//***************************************************************************
//
//  CNt5Refresher::QueryInterface
//
//  Standard COM QueryInterface().  We have to support two interfaces,
//  the IWbemServices interface itself to provide the objects and
//  the IWbemProviderInit interface to initialize the provider.
//
//***************************************************************************
// ok

HRESULT CStdProvider::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemServices)
    {
        *ppv = (IWbemServices *) this;
        AddRef();
        return S_OK;
    }
    else if (riid == IID_IWbemProviderInit)
    {
        *ppv = (IWbemProviderInit *) this;
        AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}


//***************************************************************************
//
//  CNt5Refresher::Initialize
//
//  Called once during startup.  Insdicates to the provider which
//  namespace it is being invoked for and which User.  It also supplies
//  a back pointer to CIMOM so that class definitions can be retrieved.
//
//  We perform any one-time initialization in this routine. The
//  final call to Release() is for any cleanup.
//
//  <wszUser>           The current user.
//  <lFlags>            Reserved.
//  <wszNamespace>      The namespace for which we are being activated.
//  <wszLocale>         The locale under which we are to be running.
//  <pNamespace>        An active pointer back into the current namespace
//                      from which we can retrieve schema objects.
//  <pCtx>              The user's context object.  We simply reuse this
//                      during any reentrant operations into CIMOM.
//  <pInitSink>         The sink to which we indicate our readiness.
//
//***************************************************************************
// ok

HRESULT CStdProvider::Initialize( 
    /* [unique][in] */  LPWSTR wszUser,
    /* [in] */          LONG lFlags,
    /* [in] */          LPWSTR wszNamespace,
    /* [unique][in] */  LPWSTR wszLocale,
    /* [in] */          IWbemServices __RPC_FAR *pNamespace,
    /* [in] */          IWbemContext __RPC_FAR *pCtx,
    /* [in] */          IWbemProviderInitSink __RPC_FAR *pInitSink
    )
{
    // Get the class definition.
    // =========================

    BSTR strClass = SysAllocString(L"LogicalDrive");
    
    HRESULT hRes = pNamespace->GetObject(
        strClass,
        0, 
        pCtx, 
        &m_pClassDef, 
        0
        );

    SysFreeString(strClass);

    if (hRes)
        return hRes;

    pInitSink->SetStatus(0, WBEM_S_INITIALIZED);
    return NO_ERROR;
}
    

//*****************************************************************************
//
//*****************************************************************************        


HRESULT CStdProvider::OpenNamespace( 
            /* [in] */ BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        

HRESULT CStdProvider::GetObject( 
            /* [in] */ BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::GetObjectAsync( 
            /* [in] */ BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{

    // Parse the object path.
    // ======================

    wchar_t Class[128], Key[128];
    *Class = 0;
    *Key = 0;

    swscanf(strObjectPath, L"%[^=]=\"%[^\"]", Class, Key);

    if (_wcsicmp(Class, L"LogicalDrive") != 0)
        return WBEM_E_INVALID_PARAMETER;

    if (wcslen(Key) == 0)
        return WBEM_E_INVALID_PARAMETER;


    // Set up an empty instance.
    // =========================

    IWbemClassObject *pInst = 0;
    
    HRESULT hRes = m_pClassDef->SpawnInstance(0, &pInst);
    if (hRes)
        return hRes;

    BOOL bRes = GetInstance(
        Key,
        pInst
        );


    // If we succeeded, send the instance back to CIMOM.
    // =================================================

    if (bRes)
    {
        pResponseHandler->Indicate(1, &pInst);
        pResponseHandler->SetStatus(0, WBEM_NO_ERROR, 0, 0);
        pInst->Release();
        return WBEM_S_NO_ERROR;
    }


    // Indicate that the instance couldn't be found.
    // ==============================================

    pResponseHandler->SetStatus(0, WBEM_E_NOT_FOUND, 0, 0);
    pInst->Release();

    return WBEM_NO_ERROR;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::DeleteClass( 
            /* [in] */ BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::DeleteClassAsync( 
            /* [in] */ BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::CreateClassEnum( 
            /* [in] */ BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::CreateClassEnumAsync( 
            /* [in] */ BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::DeleteInstance( 
            /* [in] */ BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::DeleteInstanceAsync( 
            /* [in] */ BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::CreateInstanceEnum( 
            /* [in] */ BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::CreateInstanceEnumAsync( 
            /* [in] */ BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    if (_wcsicmp(strClass, L"LogicalDrive") != 0)
        return WBEM_E_FAILED;

    BOOL bRes = GetInstances(pResponseHandler);

    // Finished delivering instances.
    // ==============================

    if (bRes == TRUE)
        pResponseHandler->SetStatus(0, WBEM_NO_ERROR, 0, 0);
    else
        pResponseHandler->SetStatus(0, WBEM_E_FAILED, 0, 0);
    
    return WBEM_NO_ERROR;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::ExecQuery( 
            /* [in] */ BSTR strQueryLanguage,
            /* [in] */ BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::ExecQueryAsync( 
            /* [in] */ BSTR strQueryLanguage,
            /* [in] */ BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
//    pResponseHandler->Indicate(1, &pInst);
    pResponseHandler->SetStatus(0, WBEM_NO_ERROR, 0, 0);
    return WBEM_NO_ERROR;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::ExecNotificationQuery( 
            /* [in] */ BSTR strQueryLanguage,
            /* [in] */ BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::ExecNotificationQueryAsync( 
            /* [in] */ BSTR strQueryLanguage,
            /* [in] */ BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::ExecMethod( 
            /* [in] */ BSTR strObjectPath,
            /* [in] */ BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::ExecMethodAsync( 
            /* [in] */ BSTR strObjectPath,
            /* [in] */ BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//  GetInstances
//  
//*****************************************************************************

BOOL CStdProvider::GetInstances(
    IWbemObjectSink *pSink
    )
{
    wchar_t szDrive[8];

    // Loop through all the drives.
    // ============================

    for (int i = 'C'; i <= 'Z'; i++)
    {
        swprintf(szDrive, L"%c:", i);

        // Create an empty instance.
        // =========================

        IWbemClassObject *pInst = 0;
    
        HRESULT hRes = m_pClassDef->SpawnInstance(0, &pInst);
        if (hRes)
            return FALSE;


        // Fill in the instance.
        // =====================

        BOOL bRes = GetInstance(szDrive, pInst);

        if (!bRes)
        {
            pInst->Release();
            continue;
        }
        
        // If here, the instance is good, so deliver it to CIMOM.
        // ======================================================

        pSink->Indicate(1, &pInst);

        pInst->Release();
    }

    return TRUE;
}


//*****************************************************************************
//
//  GetInstance
//
//  Gets drive info for the requested drive and populates the IWbemClassObject.
//
//  Returns FALSE on fail (non-existent drive)
//  Returns TRUE on success
//
//*****************************************************************************        

BOOL CStdProvider::GetInstance(
    IN  wchar_t *pszDrive,
    OUT IWbemClassObject *pObj    
    )
{
    wchar_t Volume[256];
    wchar_t FileSystem[256];    
    DWORD dwMaxFileNameLen;
    DWORD dwFileSysFlags;
    DWORD dwVolSerial;
    DWORD dwTotalCap;
    DWORD dwSectorsPerCluster, dwBytesPerSector, dwNumFreeClusters, dwTotalClusters;
    wchar_t *pszType;
            
    // Get information on file system.
    // ===============================
        
    BOOL bRes = GetVolumeInformationW(
        pszDrive,

        Volume,
        256,

        &dwVolSerial,
        &dwMaxFileNameLen,
        &dwFileSysFlags,            

        FileSystem,
        256
        );

    if (!bRes)
        return FALSE;       // Drive doesn't exist


    // Get the drive type.
    // ===================

    pszType = L"<unknown drive type>";
            
    UINT uRes = GetDriveTypeW(pszDrive);
    
    if (uRes == DRIVE_FIXED)
        pszType = L"Fixed Drive";
    else if (uRes == DRIVE_CDROM)
        pszType = L"CD-ROM";
    else if (uRes == DRIVE_REMOTE)
        pszType = L"Remote Drive";                                

    // Get drive capacity information.
    // ===============================

    bRes = GetDiskFreeSpaceW(
        pszDrive,
        &dwSectorsPerCluster,
        &dwBytesPerSector,
        &dwNumFreeClusters,
        &dwTotalClusters
        );


    dwTotalCap = dwSectorsPerCluster * dwTotalClusters * dwBytesPerSector;

    printf("Root=%S  Vol=%S  FileSys=%S TotalCap=%u DriveType= %S\n",
        pszDrive,
        Volume,
        FileSystem,
        dwTotalCap,
        pszType
        );


    // Populate the IWbemClassObject.
    // ==============================
    
    VARIANT v;
    VariantInit(&v);

    BSTR strProp;

    // Put the Drive (key)
    // ===================
        
    strProp = SysAllocString(L"Drive");
    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(pszDrive);

    pObj->Put(strProp, 0, &v, 0);
    VariantClear(&v);
    SysFreeString(strProp);

    // Put the Drive Type.
    // ===================

    strProp = SysAllocString(L"DriveType");
    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(pszType);

    pObj->Put(strProp, 0, &v, 0);
    VariantClear(&v);
    SysFreeString(strProp);


    // Put the File System.
    // ====================

    strProp = SysAllocString(L"FileSystem");
    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(FileSystem);

    pObj->Put(strProp, 0, &v, 0);
    VariantClear(&v);
    SysFreeString(strProp);


    // Volume label.
    // =============

    strProp = SysAllocString(L"VolumeLabel");
    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(Volume);

    pObj->Put(strProp, 0, &v, 0);
    VariantClear(&v);
    SysFreeString(strProp);


    // Total capacity.
    // ===============

    strProp = SysAllocString(L"TotalCapacity");
    V_VT(&v) = VT_I4;
    V_I4(&v) = (LONG) dwTotalCap;

    pObj->Put(strProp, 0, &v, 0);
    VariantClear(&v);
    SysFreeString(strProp);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\hiperprov\hiperprov.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//////////////////////////////////////////////////////////////////////
//
//	HiPerfProv.h
//
//	Based on NTPerf by raymcc.
//
//	Oct 15, 1998, Created by a-dcrews
//	Dec 07, 1998, Added shared memory feature
//	
//////////////////////////////////////////////////////////////////////

#ifndef _HIPERFPROV_H_
#define _HIPERFPROV_H_

#define UNICODE
#define _UNICODE

#define NUM_INSTANCES	1000
#define NUM_OBJECT_TYPES	10
#define NUM_OBJECTS			NUM_INSTANCES / NUM_OBJECT_TYPES

#define MAX_REFRESHERS		25

const enum CounterHandles
{
	ctrS8,	
	ctrS16,
	ctrS32,
	ctrS64,
	ctrU8,
	ctrU16,
	ctrU32,
	ctrU64,
	ctrR32,
	ctrR64,
	ctrStr,
	NumCtrs
};

const enum CounterTypes
{
	PROP_DWORD	= 0x0001L,
	PROP_QWORD	= 0x0002L,
	PROP_VALUE	= 0x0004L
};

extern IID IID_IHiPerfProvider;

HRESULT CloneObjAccess( IWbemObjectAccess* pObj, IWbemObjectAccess** ppClonedObj );

class CRefresher;

class CReleaseMe
{
	IUnknown**	m_ppObj;
public:
	CReleaseMe(IUnknown** ppObj) : m_ppObj(ppObj) {}
	~CReleaseMe(){ if (*m_ppObj) (*m_ppObj)->Release();}
};

class CAutoCS
{
	CRITICAL_SECTION* m_pCS;
public:
	CAutoCS(CRITICAL_SECTION* pCS) : m_pCS(pCS) {EnterCriticalSection(m_pCS);}
	~CAutoCS() {if (m_pCS) LeaveCriticalSection(m_pCS);}
};

//////////////////////////////////////////////////////////////
//
//	CHiPerClassFactory
//
//////////////////////////////////////////////////////////////

class CHiPerClassFactory : public IClassFactory
{
protected:
	long	m_lRef;

public:
	CHiPerClassFactory() : m_lRef(0) {}

	// Standard COM methods
	// ====================

	STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
	STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// IClassFactory COM interfaces
	// ============================

	STDMETHODIMP CreateInstance(
		/* [in] */ IUnknown* pUnknownOuter, 
		/* [in] */ REFIID iid, 
		/* [out] */ LPVOID *ppv);	

	STDMETHODIMP LockServer(
		/* [in] */ BOOL bLock);
};

//////////////////////////////////////////////////////////////////////
//
//						CHiPerfProvider
//						===============
//
//	From a pool of 1000 possible instances in shared memory,
//	define how many different object class types are required.  
//	There will be 1000 / OBJECT_TYPES instances of each object.
//	Each object class type inherits from PARENT_CLASS.
//	
//	There are as many enumerators as there are object types
//
//////////////////////////////////////////////////////////////////////

class CHiPerfProvider : public IWbemProviderInit, public IWbemHiPerfProvider
{
	friend CRefresher;

protected:

	long m_lRef;				// Reference count

	// Property handles
	// ================

	long m_aPropHandle[NumCtrs];
	long m_hID;
	long m_hType;

	// Object Instance members
	// =======================

	CRITICAL_SECTION	m_csInst;
	IWbemObjectAccess*	m_apInstance[NUM_OBJECT_TYPES][NUM_OBJECTS];

	HRESULT SetHandles(IWbemClassObject* pSampleClass);
	HRESULT InitInstances(WCHAR* wcsClass, IWbemServices *pNamespace);
	HRESULT UpdateInstanceCtrs(IWbemObjectAccess* pAccess, long lVal, WCHAR* wcsStr = NULL, int* pnLastNum = NULL );


public:
	CHiPerfProvider();
	~CHiPerfProvider();

// =======================================================================
//
//						COM methods
//
// =======================================================================

	// Standard COM methods
	// ====================

	STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
	STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// IWbemProviderInit COM interface
	// ===============================
	
	STDMETHODIMP Initialize( 
		/* [unique][in] */ LPWSTR wszUser,
		/* [in] */ LONG lFlags,
		/* [in] */ LPWSTR wszNamespace,
		/* [unique][in] */ LPWSTR wszLocale,
		/* [in] */ IWbemServices __RPC_FAR *pNamespace,
		/* [in] */ IWbemContext __RPC_FAR *pCtx,
		/* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink );


	// IWbemHiPerfProvider COM interfaces
	// ==================================

	STDMETHODIMP QueryInstances( 
		/* [in] */ IWbemServices __RPC_FAR *pNamespace,
		/* [string][in] */ WCHAR __RPC_FAR *wszClass,
		/* [in] */ long lFlags,
		/* [in] */ IWbemContext __RPC_FAR *pCtx,
		/* [in] */ IWbemObjectSink __RPC_FAR *pSink );
    
	STDMETHODIMP CreateRefresher( 
		/* [in] */ IWbemServices __RPC_FAR *pNamespace,
		/* [in] */ long lFlags,
		/* [out] */ IWbemRefresher __RPC_FAR *__RPC_FAR *ppRefresher );
    
	STDMETHODIMP CreateRefreshableObject( 
		/* [in] */ IWbemServices __RPC_FAR *pNamespace,
		/* [in] */ IWbemObjectAccess __RPC_FAR *pTemplate,
		/* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
		/* [in] */ long lFlags,
		/* [in] */ IWbemContext __RPC_FAR *pContext,
		/* [out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
		/* [out] */ long __RPC_FAR *plId );
    
	STDMETHODIMP StopRefreshing( 
		/* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
		/* [in] */ long lId,
		/* [in] */ long lFlags );

	STDMETHODIMP CreateRefreshableEnum(
		/* [in] */ IWbemServices* pNamespace,
		/* [in, string] */ LPCWSTR wszClass,
		/* [in] */ IWbemRefresher* pRefresher,
		/* [in] */ long lFlags,
		/* [in] */ IWbemContext* pContext,
		/* [in] */ IWbemHiPerfEnum* pHiPerfEnum,
		/* [out] */ long* plId);

	STDMETHODIMP GetObjects(
        /* [in] */ IWbemServices* pNamespace,
		/* [in] */ long lNumObjects,
		/* [in,size_is(lNumObjects)] */ IWbemObjectAccess** apObj,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext* pContext);
};

//////////////////////////////////////////////////////////////////////
//
//						CRefresher
//						==========
//
//
//////////////////////////////////////////////////////////////////////

class CRefresher : public IWbemRefresher 
{
	CHiPerfProvider* m_pProvider;
	long m_lRef;

protected:
	IWbemObjectAccess*	m_aObject[NUM_INSTANCES];
	IWbemHiPerfEnum*	m_aEnumerator[NUM_OBJECT_TYPES];

	// The counter data members
	// ========================

	long	m_lCount;
	WCHAR*	m_pwcsTestString;

public:
	CRefresher(CHiPerfProvider *pObject);
	virtual ~CRefresher();

	// Enumerator management functions
	// ===============================

	HRESULT AddEnumerator(IWbemHiPerfEnum *pHiPerfEnum, long lID);
	HRESULT RemoveEnumerator(long lID);

	// Instance management functions
	// =============================

	HRESULT AddObject(IWbemObjectAccess *pObj, long* plID, IWbemObjectAccess** ppObj);
	HRESULT RemoveObject(long lID);

// =======================================================================
//
//						COM methods
//
// =======================================================================

	// Standard COM methods
	// ====================

	STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
	STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// IWbemRefresher COM method
	// =========================

	STDMETHODIMP Refresh(/* [in] */ long lFlags);
};

#endif // _HIPERFPROV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\hiperprov\server.cpp ===
////////////////////////////////////////////////////////////////////////
//
//  Server.cpp
//
//	Module:	WMI high performance provider sample code
//
//  Generic COM server framework, adapted for the BasicHiPerf provider 
//	sample.  This module contains nothing specific to the BasicHiPerf 
//	provider except what is defined in the section bracketed by the 
//	CLSID SPECIFIC comments below.
//
//  History:
//  raymcc        25-Nov-97     Created.
//  raymcc        18-Feb-98     Updated for NT5 Beta 2 version.
//	a-dcrews      12-Jan-99		Adapted for BasicHiPerf.dll
//
//
//  Copyright (c) 1999-2001, Microsoft Corporation, All rights reserved
//
////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdio.h>
#include <time.h>
#include <locale.h>
#include <initguid.h>


/////////////////////////////////////////////////////////////////////////////
//
//  BEGIN CLSID SPECIFIC SECTION
//
//

#include "wbemprov.h"
#include "HiPerProv.h"

// {33F5CBF8-6519-11d2-B722-00104B703E46}
DEFINE_GUID(CLSID_HiPerfCounter_v1,
0x33f5cbf8, 0x6519, 0x11d2, 0xb7, 0x22, 0x0, 0x10, 0x4b, 0x70, 0x3e, 0x46);

#define IMPLEMENTED_CLSID           CLSID_HiPerfCounter_v1
#define SERVER_REGISTRY_COMMENT     L"WBEM HiPerf Provider"
#define CPP_CLASS_NAME              CHiPerfProvider
#define INTERFACE_CAST              (IWbemHiPerfProvider*)

//
//  END CLSID SPECIFIC SECTION
//
/////////////////////////////////////////////////////////////////////////////


HINSTANCE g_hInstance;
long g_lLocks = 0;
long g_lObjects = 0;

//***************************************************************************
//
//  DllMain
//
//  Dll entry point.
//
//  PARAMETERS:
//
//      HINSTANCE hinstDLL      The handle to our DLL.
//      DWORD dwReason          DLL_PROCESS_ATTACH on load,
//                              DLL_PROCESS_DETACH on shutdown,
//                              DLL_THREAD_ATTACH/DLL_THREAD_DETACH otherwise.
//      LPVOID lpReserved       Reserved
//
//  RETURN VALUES:
//
//      TRUE is successful, FALSE if a fatal error occured.
//      NT behaves very ugly if FALSE is returned.
//
//***************************************************************************
BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
//        setlocale(LC_ALL, "");      // Set to the 'current' locale
        g_hInstance = hinstDLL;
    }

    return TRUE;
}



//***************************************************************************
//
//  DllGetClassObject
//
//  Standard OLE In-Process Server entry point to return an class factory
//  instance.
//
//  PARAMETERS:
//
//  RETURNS:
//
//      S_OK                Success
//      E_NOINTERFACE       An interface other that IClassFactory was asked for
//      E_OUTOFMEMORY
//      E_FAILED            Initialization failed, or an unsupported clsid was
//                          asked for.
//
//***************************************************************************

STDAPI DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID * ppv
    )
{
    CHiPerClassFactory *pClassFactory = NULL;
	HRESULT hRes;

    //  Verify the caller is asking for our type of object
	// ===================================================

    if (IMPLEMENTED_CLSID == rclsid) 
	{
		// Create the class factory
		// ========================

		pClassFactory = new CHiPerClassFactory;

		if (!pClassFactory)
			return E_OUTOFMEMORY;
		
		hRes = pClassFactory->QueryInterface(riid, ppv);
		if (FAILED(hRes))
		{
			delete pClassFactory;
			return hRes;
		}
		hRes = S_OK;
	}
	else 
		hRes = CLASS_E_CLASSNOTAVAILABLE;

    return hRes;
}

//***************************************************************************
//
//  DllCanUnloadNow
//
//  Standard OLE entry point for server shutdown request. Allows shutdown
//  only if no outstanding objects or locks are present.
//
//  RETURN VALUES:
//
//      S_OK        May unload now.
//      S_FALSE     May not.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    HRESULT hRes = S_FALSE;

    if (0 == g_lLocks && 0 == g_lObjects)
        hRes = S_OK;

    return hRes;
}

//***************************************************************************
//
//  DllRegisterServer
//
//  Standard OLE entry point for registering the server.
//
//  RETURN VALUES:
//
//      S_OK        Registration was successful
//      E_FAIL      Registration failed.
//
//***************************************************************************

STDAPI DllRegisterServer(void)
{
    wchar_t Path[1024];
    wchar_t *pGuidStr = 0;
    wchar_t KeyPath[1024];

    // Get the dll's filename
    // ======================

    GetModuleFileNameW(g_hInstance, Path, 1024);

    // Convert CLSID to string.
    // ========================

    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    // Place it in registry.
    // CLSID\\CLSID_Nt5PerProvider_v1 : <no_name> : "name"
    //      \\CLSID_Nt5PerProvider_v1\\InProcServer32 : <no_name> : "path to DLL"
    //                                    : ThreadingModel : "both"
    // ==============================================================

    HKEY hKey;
    LONG lRes = RegCreateKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    wchar_t *pName = SERVER_REGISTRY_COMMENT; 
    RegSetValueExW(hKey, 0, 0, REG_SZ, (const BYTE *) pName, wcslen(pName) * 2 + 2);

    HKEY hSubkey;
    lRes = RegCreateKey(hKey, "InprocServer32", &hSubkey);

    RegSetValueExW(hSubkey, 0, 0, REG_SZ, (const BYTE *) Path, wcslen(Path) * 2 + 2);
    RegSetValueExW(hSubkey, L"ThreadingModel", 0, REG_SZ, (const BYTE *) L"Both", wcslen(L"Both") * 2 + 2);

    RegCloseKey(hSubkey);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}

//***************************************************************************
//
//  DllUnregisterServer
//
//  Standard OLE entry point for unregistering the server.
//
//  RETURN VALUES:
//
//      S_OK        Unregistration was successful
//      E_FAIL      Unregistration failed.
//
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    wchar_t *pGuidStr = 0;
    HKEY hKey;
    wchar_t KeyPath[256];

    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    // Delete InProcServer32 subkey.
    // =============================
    LONG lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, L"InprocServer32");
    RegCloseKey(hKey);

    // Delete CLSID GUID key.
    // ======================

    lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, L"Software\\Classes\\CLSID", &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, pGuidStr);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\instprov\stdprov.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//***************************************************************************
//
//  STDPROV.H
//  
//  Test instance provider
//
//  raymcc      02-Dec-97       
//
//***************************************************************************

#ifndef _STDPROV_H_
#define _STDPROV_H_

class CStdProvider : public IWbemServices, public IWbemProviderInit
{
    LONG m_lRef;
    IWbemClassObject *m_pClassDef;
        
public:
    CStdProvider();
   ~CStdProvider();

    // Interface members.
    // ==================

        ULONG STDMETHODCALLTYPE AddRef();
        ULONG STDMETHODCALLTYPE Release();
        STDMETHODIMP QueryInterface(REFIID riid, void** ppv);


        // IWbemProviderInit method.
        // =========================
            
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [unique][in] */ LPWSTR wszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR wszNamespace,
            /* [unique][in] */ LPWSTR wszLocale,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink
            );



        // IWbemServices methods.
        // ======================

        virtual HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult
            );
        
        virtual HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink
            );
        
        virtual HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler
            );
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            );
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );
        
        virtual HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            );
        
        virtual HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );
        
        virtual HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            );
        
        virtual HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );
        
        virtual HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            );
        
        virtual HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );
        
        virtual HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            );
        
        virtual HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );
        
        virtual HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            );
        
        virtual HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            );
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );
        
        virtual HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            );
        
        virtual HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );
        
        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            );
        
        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );
        
        virtual HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            );
        
        virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );
            

    // Private methods.
    // ================

    BOOL GetInstances(
        IWbemObjectSink *pSink
        );

    BOOL GetInstance(
        IN  wchar_t *pszDrive,
        OUT IWbemClassObject *pObj    
        );


};

void ObjectCreated();
void ObjectDestroyed();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\hiperprov\hiperprov.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

////////////////////////////////////////////////////////////////////////
//
//
//	HiPerfProv.cpp
//
//
//	Created by a-dcrews, Oct. 20, 1998	
//	
//
////////////////////////////////////////////////////////////////////////

#define _UNICODE
#define UNICODE

#include <windows.h>
#include <stdio.h>

#include <wbemprov.h>

#include "HiPerProv.h"

#define PARENT_CLASS L"Win32_HiPerfCounter"

extern long g_lObjects;
extern long g_lLocks;

struct tag_Properties{
	WCHAR	wcsPropertyName[128];
	DWORD	dwType;
} g_atcsProperties[] =
{
	L"CounterS8",	PROP_DWORD,
	L"CounterS16",	PROP_DWORD,
	L"CounterS32",	PROP_DWORD,
	L"CounterS64",	PROP_QWORD,
	L"CounterU8",	PROP_DWORD,
	L"CounterU16",	PROP_DWORD,
	L"CounterU32",	PROP_DWORD,
	L"CounterU64",	PROP_QWORD,
	L"CounterR32",	PROP_DWORD,
	L"CounterR64",	PROP_DWORD,
	L"CounterStr",	PROP_VALUE	
};

class CRefresher;


//////////////////////////////////////////////////////////////
//
//
//	CHiPerClassFactory
//
//
//////////////////////////////////////////////////////////////

STDMETHODIMP CHiPerClassFactory::QueryInterface(REFIID riid, void** ppv)
//////////////////////////////////////////////////////////////
//
//	Standard QueryInterface
//
//	Parameters:
//		riid	- the ID of the requested interface
//		ppv		- a pointer to the interface pointer
//
//////////////////////////////////////////////////////////////
{
    if(riid == IID_IUnknown)
        *ppv = (LPVOID)(IUnknown*)this;
    else if(riid == IID_IClassFactory)
        *ppv = (LPVOID)(IClassFactory*)this;
	else return E_NOINTERFACE;

	((IUnknown*)*ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) CHiPerClassFactory::AddRef()
//////////////////////////////////////////////////////////////
//
//	Standard COM AddRef
//
//////////////////////////////////////////////////////////////
{
    return InterlockedIncrement(&m_lRef);
}

STDMETHODIMP_(ULONG) CHiPerClassFactory::Release()
//////////////////////////////////////////////////////////////
//
//	Standard COM Release
//
//////////////////////////////////////////////////////////////
{
	long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;

    return lRef;
}

STDMETHODIMP CHiPerClassFactory::CreateInstance(
		/* [in] */ IUnknown* pUnknownOuter, 
		/* [in] */ REFIID iid, 
		/* [out] */ LPVOID *ppv)
//////////////////////////////////////////////////////////////
//
//	Standard COM CreateInstance
//
//////////////////////////////////////////////////////////////
{
	HRESULT hRes;
	CHiPerfProvider *pProvider = NULL;

	*ppv = NULL;

	// We do not support aggregation
	// =============================

	if (pUnknownOuter)
		return CLASS_E_NOAGGREGATION;

	// Create the provider object
	// ==========================

	pProvider = new CHiPerfProvider;

	if (!pProvider)
		return E_OUTOFMEMORY;

	// Retrieve the requested interface
	// ================================

	hRes = pProvider->QueryInterface(iid, ppv);
	if (FAILED(hRes))
	{
		delete pProvider;
		return hRes;
	}


	return S_OK;
}

STDMETHODIMP CHiPerClassFactory::LockServer(
		/* [in] */ BOOL bLock)
//////////////////////////////////////////////////////////////
//
//	Standard COM LockServer
//
//////////////////////////////////////////////////////////////
{
	if (bLock)
		InterlockedIncrement(&g_lLocks);
	else
		InterlockedDecrement(&g_lLocks);

	return S_OK;
}


////////////////////////////////////////////////////////////////////////
//
//
//	CHiPerfProvider
//
//
////////////////////////////////////////////////////////////////////////

CHiPerfProvider::CHiPerfProvider() : m_lRef(0)
////////////////////////////////////////////////////////////////////////
//
//	Constructor
//
////////////////////////////////////////////////////////////////////////
{
	InterlockedIncrement( &g_lObjects );

	// Initialize the Instace CS
	// =========================

	InitializeCriticalSection(&m_csInst);

	// Initialize internal instance cache to empty
	// ===========================================

	for (int nType = 0; nType < NUM_OBJECT_TYPES; nType++)
		for (int nID = 0; nID < NUM_OBJECTS; nID++)
			m_apInstance[nType][nID] = 0;

	// Initialize the property handles
	// ===============================

	for (int i = 0; i < NumCtrs; i++)
		m_aPropHandle[i] = 0;
}

CHiPerfProvider::~CHiPerfProvider()
//////////////////////////////////////////////////////////////
//
//	Destructor
//
//////////////////////////////////////////////////////////////
{

	InterlockedDecrement( &g_lObjects );

	for (int nType = 0; nType < NUM_OBJECT_TYPES; nType++)
		for (int nID = 0; nID < NUM_OBJECTS; nID++)
		{
			if ( NULL != m_apInstance[nType][nID] )
			{
				m_apInstance[nType][nID]->Release();
			}
		}
}

HRESULT CHiPerfProvider::SetHandles(IWbemClassObject* pSampleClass)
//////////////////////////////////////////////////////////////
//
//	Get the property handles for the well-known properties in
//	this counter type.  These property handles are available
//	to all nested classes of HiPerfProvider.
//
//	If the method fails, the property handle values may be in 
//	an indeterminite state.
//
//	TODO: query the number of counters and dynamically create 
//	a member array of tag_Properties
//
//	<pSampleClass>	An object from which the handles will be
//					evaluated.
// 
//////////////////////////////////////////////////////////////
{
	long	hProperty	= 0;
	HRESULT hRes		= 0;
    BSTR	PropName	= 0;

	// Get the IWbemAccess interface to the class
	// ==========================================

	IWbemObjectAccess* pAccess = 0;
	CReleaseMe RM1((IUnknown**)&pAccess);

	hRes = pSampleClass->QueryInterface(IID_IWbemObjectAccess, (LPVOID *)&pAccess);
	if (FAILED(hRes))
		return hRes;

	// Get the handle to the Name...
	// =============================

    PropName = SysAllocString(L"ID");
	hRes = pAccess->GetPropertyHandle(PropName, 0, &m_hID);

	if (FAILED(hRes)) 
		return hRes;

    SysFreeString(PropName);

	// ...and Type
	// ===========

    PropName = SysAllocString(L"type");
	hRes = pAccess->GetPropertyHandle(PropName, 0, &m_hType);

	if (FAILED(hRes))
		return hRes;

    SysFreeString(PropName);

	// Get the counter property handles
	// ================================

	for (int i = 0; i < NumCtrs; i++)
	{
		PropName = SysAllocString(g_atcsProperties[i].wcsPropertyName);    
		hRes = pAccess->GetPropertyHandle(PropName, 0, &(m_aPropHandle[i]));

		if (FAILED(hRes))
			return hRes;

		SysFreeString(PropName);
	}

	return WBEM_NO_ERROR;
}

HRESULT CHiPerfProvider::InitInstances(WCHAR* wcsClass, IWbemServices *pNamespace)
//////////////////////////////////////////////////////////////
//
//	Initializes all of the instance data.  If it fails, the 
//	instance data may be in an inconsistent state.
//
//	<wcsClass>		The class for which the instances are 
//					required
//	<pNamespace>	The namespace for which the instances 
//					belong
//////////////////////////////////////////////////////////////
{
	HRESULT hRes;

	int nType;

	// Lock the instances
	// ==================

	CAutoCS CS1(&m_csInst);

	// Determine the type of object
	// ============================

	CharUpperW(wcsClass);
	swscanf(wcsClass, L"WIN32_HPC%i", &nType);

	// Get a template of the parent class
	// ==================================

	IWbemClassObject* pClassObject = 0;
	CReleaseMe RM1((IUnknown**)&pClassObject);

	BSTR bstrObject = SysAllocString(wcsClass);

	hRes = pNamespace->GetObject(bstrObject, 0, NULL, &pClassObject, 0);

	SysFreeString(bstrObject);

	if (FAILED(hRes))
		return hRes;

	// And create some instances
	// =========================

	for (int nID = 0; nID < NUM_OBJECTS; nID++)
	{
		if (0 == m_apInstance[nType][nID])
		{
			IWbemClassObject* pInst = 0;
			CReleaseMe RM2((IUnknown**)&pInst);

			hRes = pClassObject->SpawnInstance(0, &pInst);
			if (FAILED(hRes))
				return hRes;

			// Get the IWbemObjectAccess interface
			// ===================================

			pInst->QueryInterface(IID_IWbemObjectAccess, (PVOID*)&(m_apInstance[nType][nID]));

			// Initialize the instance's ID and values
			// =======================================

			hRes = m_apInstance[nType][nID]->WriteDWORD(m_hID, nID);
			if (FAILED(hRes))
				return hRes;

			hRes = UpdateInstanceCtrs(m_apInstance[nType][nID], 0);
			if (FAILED(hRes))
				return hRes;
		}
	}

	return S_OK;
}

HRESULT CHiPerfProvider::UpdateInstanceCtrs(IWbemObjectAccess* pAccess, long lVal, WCHAR* pwcsTestString, int* plLastNum)
//////////////////////////////////////////////////////////////
//
//	Updates an object's property values
//
//	<nType>			The type of instance
//	<nID>			The instance's ID
//	
//////////////////////////////////////////////////////////////
{
	HRESULT hRes;

	if (!pAccess)
		return E_FAIL;

	__int8 sint8 = (__int8)lVal;
	__int16 sint16 = (__int16)lVal;
	__int32 sint32 = (__int32)lVal;
	__int64 sint64 = (__int64)lVal;
	unsigned __int8 uint8 = (unsigned __int8)lVal;
	unsigned __int16 uint16 = (unsigned __int16)lVal;
	unsigned __int32 uint32 = (unsigned __int32)lVal;
	unsigned __int64 uint64 = (unsigned __int64)lVal;
	float fCount = (float)lVal;
	double dCount = (double)lVal;

	hRes = pAccess->WritePropertyValue(m_aPropHandle[ctrS8], 1, (PBYTE)&sint8);
	hRes = pAccess->WritePropertyValue(m_aPropHandle[ctrS16], 2, (PBYTE)&sint16);
	hRes = pAccess->WriteDWORD(m_aPropHandle[ctrS32], sint32);
	hRes = pAccess->WriteQWORD(m_aPropHandle[ctrS64], sint64);
	hRes = pAccess->WritePropertyValue(m_aPropHandle[ctrU8], 1, (PBYTE)&uint8);
	hRes = pAccess->WritePropertyValue(m_aPropHandle[ctrU16], 2, (PBYTE)&uint16);
	hRes = pAccess->WriteDWORD(m_aPropHandle[ctrU32], uint32);
	hRes = pAccess->WriteQWORD(m_aPropHandle[ctrU64], uint64);
	hRes = pAccess->WritePropertyValue(m_aPropHandle[ctrR32], 4, (PBYTE)&fCount);
	hRes = pAccess->WritePropertyValue(m_aPropHandle[ctrR64], 8, (PBYTE)&dCount);

	if ( NULL == pwcsTestString )
	{
		WCHAR wcsStrCtr[1024];
		wsprintf(wcsStrCtr, L"%d", lVal);
		hRes = pAccess->WritePropertyValue(m_aPropHandle[ctrStr], 
											(wcslen(wcsStrCtr)+1)*sizeof(WCHAR),
											(BYTE*)wcsStrCtr);
	}
	else
	{
		WCHAR wcsStrCtr[1048];

		int		nNumToCopy = rand() % 1000;

		while ( nNumToCopy == *plLastNum )
		{
			nNumToCopy = rand() % 1000;
		}

		if ( 0 == nNumToCopy )
			nNumToCopy = 1;
		
		wcsncpy( wcsStrCtr, pwcsTestString, nNumToCopy );
		wcsStrCtr[nNumToCopy] = NULL;

		hRes = pAccess->WritePropertyValue(m_aPropHandle[ctrStr], 
											(wcslen(wcsStrCtr)+1)*sizeof(WCHAR),
											(BYTE*)wcsStrCtr);

		hRes = pAccess->WriteDWORD(m_aPropHandle[ctrU32], nNumToCopy);

		*plLastNum = nNumToCopy;
	}

	return NO_ERROR;
}

//////////////////////////////////////////////////////////////
//
//					COM implementations
//
//////////////////////////////////////////////////////////////

STDMETHODIMP CHiPerfProvider::QueryInterface(
	/* [in] */ REFIID riid, 
	/* [out] */ void** ppv)
//////////////////////////////////////////////////////////////
//
//	Standard QueryInterface
//
//	Parameters:
//		riid	- the ID of the requested interface
//		ppv		- a pointer to the interface pointer
//
//////////////////////////////////////////////////////////////
{
    if(riid == IID_IUnknown)
        *ppv = (LPVOID)(IUnknown*)(IWbemProviderInit*)this;
    else if(riid == IID_IWbemProviderInit)
        *ppv = (LPVOID)(IWbemProviderInit*)this;
	else if (riid == IID_IWbemHiPerfProvider)
		*ppv = (LPVOID)(IWbemHiPerfProvider*)this;
	else return E_NOINTERFACE;

	((IUnknown*)*ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) CHiPerfProvider::AddRef()
//////////////////////////////////////////////////////////////
//
//	Standard COM AddRef
//
//////////////////////////////////////////////////////////////
{
    return InterlockedIncrement(&m_lRef);
}

STDMETHODIMP_(ULONG) CHiPerfProvider::Release()
//////////////////////////////////////////////////////////////
//
//	Standard COM Release
//
//////////////////////////////////////////////////////////////
{
	long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;

    return lRef;
}

STDMETHODIMP CHiPerfProvider::Initialize( 
    /* [unique][in] */  LPWSTR wszUser,
    /* [in] */          long lFlags,
    /* [in] */          LPWSTR wszNamespace,
    /* [unique][in] */  LPWSTR wszLocale,
    /* [in] */          IWbemServices __RPC_FAR *pNamespace,
    /* [in] */          IWbemContext __RPC_FAR *pCtx,
    /* [in] */          IWbemProviderInitSink __RPC_FAR *pInitSink)
//////////////////////////////////////////////////////////////
//
//  Called once during startup.  Indicates to the provider which
//  namespace it is being invoked for and which User.  It also 
//	supplies a back pointer to WINMGMT so that class definitions 
//	can be retrieved.
//
//  We perform any one-time initialization in this routine. The
//  final call to Release() is for any cleanup.
//
//  <wszUser>           The current user.
//  <lFlags>            Reserved.
//  <wszNamespace>      The namespace for which we are activated
//  <wszLocale>         The locale under which we are running.
//  <pNamespace>        A pointer back into the current namespace
//                      from which we can retrieve schema objects.
//  <pCtx>              The user's context object.  Reuse this
//                      during reentrant operations into WINMGMT.
//  <pInitSink>         The sink which we indicate our readiness.
//
//////////////////////////////////////////////////////////////
{
	HRESULT hRes;

	// Get a class template to initialize the HiPerf handles
	// =====================================================

	IWbemClassObject* pSampleClass = 0;
	CReleaseMe pRM1((IUnknown**)&pSampleClass);

	BSTR bstrObject = SysAllocString(PARENT_CLASS);

	hRes = pNamespace->GetObject(bstrObject, 0, NULL, &pSampleClass, 0);

	SysFreeString(bstrObject);

    if (FAILED(hRes))
        return hRes;

	// Initialize the handles
	// ======================

	hRes = SetHandles(pSampleClass);
	if (FAILED(hRes))
		return hRes;

	// Initialize all of the instances
	// ===============================

	for (long lType = 0; lType < NUM_OBJECT_TYPES; lType++)
	{
		WCHAR wcsClass[128];
		wsprintf(wcsClass, L"WIN32_HPC%i", lType);
		InitInstances(wcsClass, pNamespace);
	}

    // Tell WINMGMT that we're ready to start 'providing'
	// ==================================================
	
    pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);

    return NO_ERROR;
}

STDMETHODIMP CHiPerfProvider::QueryInstances( 
    /* [in] */          IWbemServices __RPC_FAR *pNamespace,
    /* [string][in] */  WCHAR __RPC_FAR *wszClass,
    /* [in] */          long lFlags,
    /* [in] */          IWbemContext __RPC_FAR *pCtx,
    /* [in] */          IWbemObjectSink __RPC_FAR *pSink )
//////////////////////////////////////////////////////////////
//
//  Called whenever a complete, fresh list of instances for a 
//	given class is required.   The any active objects are sent 
//	back to the caller through the sink.  The sink can be used 
//	in-line as here, or the call can return and a separate 
//	thread could be used to deliver the instances to the sink.
//
//  <pNamespace>        A namespace pointer.  Don't AddRef.
//  <wszClass>          The class name for required instances.
//  <lFlags>            Reserved.
//  <pCtx>              The user-supplied context (not used here).
//  <pSink>             The sink to which to deliver the objects.  
//						The objects can be delivered synchronously 
//						through the duration of this call or 
//						asynchronously via a separate thread).  An 
//						IWbemObjectSink::SetStatus call is required 
//						at the end of the sequence.
//
//////////////////////////////////////////////////////////////
{
	HRESULT hRes;

    if (pNamespace == 0 || wszClass == 0 || pSink == 0)
        return WBEM_E_INVALID_PARAMETER;

	// Determine the 'type' of object that we are providing
	// ====================================================

	int nType;

	CharUpperW(wszClass);
	swscanf(wszClass, L"WIN32_HPC%i", &nType);

    // Quickly zip through the instances and update the values before 
    // returning them.  This is just a dummy operation to make it
    // look like the instances are continually changing like real
    // perf counters.

	for (int nID = 0; nID < NUM_OBJECTS; nID++)
	{
		IWbemObjectAccess *pAccess = m_apInstance[nType][nID];
    
		if (NULL == pAccess)
			continue;

		// We need to indicate an IWbemClassObject interface
		// =================================================

		IWbemClassObject* pOtherFormat = 0;
		CReleaseMe RM1((IUnknown**)&pOtherFormat);

		hRes = pAccess->QueryInterface(IID_IWbemClassObject, (LPVOID *) &pOtherFormat);
		if (FAILED(hRes))
			return hRes;

		// Send a copy back to the caller
		// ==============================

		pSink->Indicate(1, &pOtherFormat);
	}
    
    // Tell WINMGMT we are all finished supplying objects
	// ==================================================

    pSink->SetStatus(WBEM_STATUS_COMPLETE, WBEM_NO_ERROR, 0, 0);

    return NO_ERROR;
}    

STDMETHODIMP CHiPerfProvider::CreateRefresher( 
     /* [in] */ IWbemServices __RPC_FAR *pNamespace,
     /* [in] */ long lFlags,
     /* [out] */ IWbemRefresher __RPC_FAR *__RPC_FAR *ppRefresher )
//////////////////////////////////////////////////////////////
//
//  Called whenever a new refresher is needed by the client.
//
//  <pNamespace>        Pointer to the relevant namespace. Not used.
//  <lFlags>            Not used.
//  <ppRefresher>       Receives the requested refresher.
//
//////////////////////////////////////////////////////////////
{
//	_asm int 3;

    if (pNamespace == 0 || ppRefresher == 0)
        return WBEM_E_INVALID_PARAMETER;

    // Construct a new empty refresher
	// ===============================

	CRefresher *pNewRefresher = new CRefresher(this);

    // Follow COM rules and AddRef() the thing before sending it back
	// ==============================================================

    pNewRefresher->AddRef();
    *ppRefresher = pNewRefresher;
    
    return NO_ERROR;
}

STDMETHODIMP CHiPerfProvider::CreateRefreshableObject( 
    /* [in] */ IWbemServices __RPC_FAR *pNamespace,
    /* [in] */ IWbemObjectAccess __RPC_FAR *pTemplate,
    /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pContext,
    /* [out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
    /* [out] */ long __RPC_FAR *plId )
//////////////////////////////////////////////////////////////
//
//  Called whenever a user wants to include an object in a refresher.
//     
//  <pNamespace>        A pointer to the relevant namespace in WINMGMT.
//  <pTemplate>         A pointer to a copy of the object which is to be
//                      added.  This object itself cannot be used, as
//                      it not owned locally.        
//  <pRefresher>        The refresher to which to add the object.
//  <lFlags>            Not used.
//  <pContext>          Not used here.
//  <ppRefreshable>     A pointer to the internal object which was added
//                      to the refresher.
//  <plId>              The Object Id (for identification during removal).        
//
//////////////////////////////////////////////////////////////
{
    // The object supplied by <pTemplate> must not be copied.
    // Instead, we want to find out which object the caller is after
    // and return a pointer to *our* own private instance which is 
    // already set up internally.  This value will be sent back to the
    // caller so that everyone is sharing the same exact instance
    // in memory.

	HRESULT hRes;

    // Find out what object type is being requested for addition
	// =========================================================

	int	nType;

	hRes = pTemplate->ReadDWORD(m_hType, (DWORD*)&nType);
	if (FAILED(hRes))
		return hRes;

	// Get the ID of the instance
	// ==========================

    int nID = 0;    

	hRes = pTemplate->ReadDWORD(m_hID, (DWORD*)&nID);
	if (FAILED(hRes))
		return hRes;

	// Validate the ID and type ranges
	// ===============================

	if ((0 > nID) || (NUM_OBJECTS <= nID) || (0 > nType) || (NUM_OBJECT_TYPES <= nType))
		return WBEM_E_FAILED;

    // Cast the refresher to our Refresher object so that we can access private members
	// ================================================================================

    CRefresher *pOurRefresher = (CRefresher*) pRefresher;

    hRes = pOurRefresher->AddObject(m_apInstance[nType][nID], plId, ppRefreshable);

    return hRes;
}
    
STDMETHODIMP CHiPerfProvider::StopRefreshing( 
    /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
    /* [in] */ long lId,
    /* [in] */ long lFlags )
//////////////////////////////////////////////////////////////
//
//  Called whenever a user wants to remove an object from a refresher.
//     
//  <pRefresher>            The refresher object from which we are to 
//                          remove the perf object.
//  <lId>                   The ID of the object.
//  <lFlags>                Not used.
//  
//////////////////////////////////////////////////////////////
{
    // The refresher being supplied by the caller is actually
    // one of our own refreshers, so a simple cast is convenient
    // so that we can access private members.
    CRefresher *pOurRefresher = (CRefresher *) pRefresher;

	if (0x1000 & lId)
		pOurRefresher->RemoveEnumerator(~0x1000 & lId);
	else
		pOurRefresher->RemoveObject(lId);

    return NO_ERROR;
}

STDMETHODIMP CHiPerfProvider::CreateRefreshableEnum( 
	/* [in] */ IWbemServices* pNamespace,
	/* [in, string] */ LPCWSTR wszClass,
	/* [in] */ IWbemRefresher* pRefresher,
	/* [in] */ long lFlags,
	/* [in] */ IWbemContext* pContext,
	/* [in] */ IWbemHiPerfEnum* pHiPerfEnum,
	/* [out] */ long* plID )
//////////////////////////////////////////////////////////////
//
//	Called whenever an enumerator is being added to a refresher
//
//	<pNamespace>	A pointer to the relevant namespace
//	<wszClass>		The name of the class
//	<pRefresher>	The refresher to add the enumerator
//	<lFlags>		Not used
//	<pContext>		The user's context
//	<pHiPerfEnum>	The enumerator to add
//	<plID>			An assigned ID to identify the enumerator
//
//////////////////////////////////////////////////////////////
{
	// Cast the refresher interface to the refresher object type
	// =========================================================

	CRefresher* pRef = (CRefresher*)pRefresher;

	// NOTE: modify refresh logic to manage enumerator instances

	// Create all instances of the specified class
	// ===========================================

	InitInstances((WCHAR*)wszClass, pNamespace);

	// Add the enumerator
	// ==================

	int nType;

	WCHAR * wszTemp = new WCHAR[wcslen(wszClass) + 1];
	wcscpy(wszTemp, wszClass);
	CharUpperW(wszTemp);
	swscanf(wszTemp, L"WIN32_HPC%i", &nType);
	delete wszTemp;

	*plID = 0x1000 | nType;

	// Make sure that we are truly randomized!
	srand( GetTickCount() );

	return pRef->AddEnumerator(pHiPerfEnum, nType);

}

STDMETHODIMP CHiPerfProvider::GetObjects( 
    /* [in] */ IWbemServices* pNamespace,
	/* [in] */ long lNumObjects,
	/* [in,size_is(lNumObjects)] */ IWbemObjectAccess** apObj,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext* pContext)
{
	// Just a placeholder for now
	// ==========================

	return E_NOTIMPL;
}


//////////////////////////////////////////////////////////////
//
//	CRefresher
//
//////////////////////////////////////////////////////////////

CRefresher::CRefresher(CHiPerfProvider *pProvider) : m_lRef(0), m_lCount(0), m_pwcsTestString(NULL)
//////////////////////////////////////////////////////////////
//
//	Constructor
//
//////////////////////////////////////////////////////////////
{
	int i;

	// Copy provider. Addref it to last for the life of the refresher
	// ==============================================================

	m_pProvider = pProvider;
	if (m_pProvider)
		m_pProvider->AddRef();

	// Initialize all instances in cache
	// =================================

	for (i = 0; i < NUM_INSTANCES; i++) 
		m_aObject[i] = 0;

	// Initialize all enumerators in cache
	// ===================================

	for (i = 0; i < NUM_OBJECT_TYPES; i++) 
		m_aEnumerator[i] = 0;
}

CRefresher::~CRefresher()
//////////////////////////////////////////////////////////////
//
//	Destructor
//
//////////////////////////////////////////////////////////////
{
	int i;

	// Release the provider
	// ====================

	if (m_pProvider)
		m_pProvider->Release();

		// Initialize all instances in cache
	// =================================

	for (i = 0; i < NUM_INSTANCES; i++) 
	{
		if (m_aObject[i])
			m_aObject[i]->Release();
	}

	// Initialize all enumerators in cache
	// ===================================

	for (i = 0; i < NUM_OBJECT_TYPES; i++) 
	{
		if (m_aEnumerator[i])
			m_aEnumerator[i]->Release();
	}

	if ( NULL != m_pwcsTestString )
	{
		delete [] m_pwcsTestString;
	}
}


HRESULT CRefresher::AddObject(IWbemObjectAccess *pAccess, long* plID, IWbemObjectAccess** ppObj )
{
	HRESULT hr = E_FAIL;

	for ( int x = 0; x < NUM_INSTANCES; x++ )
	{
		// Found a slot
		if ( NULL == m_aObject[x] )
		{
			hr = CloneObjAccess( pAccess, ppObj );

			if ( SUCCEEDED( hr ) )
			{
				m_aObject[x] = *ppObj;
				m_aObject[x]->AddRef();

				if ( NULL != plID )
				{
					*plID = x;
				}

				break;
			}

		}
	}

	return hr;
}

HRESULT CRefresher::RemoveObject(long lID)
{
	if (!m_aObject[lID])
		return E_FAIL;

	m_aObject[lID]->Release();
	m_aObject[lID] = 0;

	return S_OK;
}

HRESULT CRefresher::AddEnumerator(IWbemHiPerfEnum *pHiPerfEnum, long lID)
{
	if (m_aEnumerator[lID])
	{
		return E_FAIL;
	}

	// Add the enumerator
	// ==================

	m_aEnumerator[lID] = pHiPerfEnum;
	m_aEnumerator[lID]->AddRef();
	
	// Initialize the enumerator with all initialized instances 
	// ========================================================

	long alIDs[NUM_OBJECTS];
	IWbemObjectAccess* aInstList[NUM_OBJECTS];
	
	long	lCount = 0;

	for (int nInst = 0; nInst < NUM_OBJECTS; nInst++)
	{
		if (NULL != m_pProvider->m_apInstance[lID][nInst])
		{
			HRESULT hr = CloneObjAccess( m_pProvider->m_apInstance[lID][nInst], &aInstList[lCount] );

/*
			IWbemClassObject* pObject = 0;
			CReleaseMe RM1((IUnknown**)&pObject);
			
			IWbemClassObject* pClone = 0;
			CReleaseMe RM2((IUnknown**)&pClone);

			IWbemObjectAccess* pAccessObj = 0;
			CReleaseMe RM3((IUnknown**)&pAccessObj);

			// Clone the instance
			// ==================

			m_pProvider->m_apInstance[lID][nInst]->QueryInterface(IID_IWbemClassObject, (PVOID*)&pObject);
			pObject->Clone(&pClone);
			pClone->QueryInterface(IID_IWbemObjectAccess, (PVOID*)&pAccessObj);

			// Add it to the parameter's list
			// ==============================

			aInstList[lCount] = pAccessObj;
			aInstList[lCount]->AddRef();
*/
			alIDs[lCount] = nInst;
			lCount++;
		}
	}

	pHiPerfEnum->AddObjects(0L, lCount, alIDs, aInstList);

	// Cleanup the instance list
	for (nInst = 0; nInst < NUM_OBJECTS; nInst++)
	{
		aInstList[nInst]->Release();
	}

	return S_OK;
}

HRESULT CRefresher::RemoveEnumerator(long lID)
{
	if (!m_aEnumerator[lID])
		return E_FAIL;

	m_aEnumerator[lID]->Release();
	m_aEnumerator[lID] = 0;

	return S_OK;
}


STDMETHODIMP CRefresher::QueryInterface(REFIID riid, void** ppv)
//////////////////////////////////////////////////////////////////////
//
//	Standard COM QueryInterface
//
//////////////////////////////////////////////////////////////////////
{
    if (riid == IID_IUnknown)
        *ppv = (LPVOID)(IUnknown*)this;
	else if (riid == IID_IWbemRefresher)
		*ppv = (LPVOID)(IWbemRefresher*)this;
    else return E_NOINTERFACE;

   	((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CRefresher::AddRef()
//////////////////////////////////////////////////////////////////////
//	
//	Standard COM AddRef
//
//////////////////////////////////////////////////////////////////////
{
    return InterlockedIncrement(&m_lRef);
}

STDMETHODIMP_(ULONG) CRefresher::Release()
//////////////////////////////////////////////////////////////////////
//
//	Standard COM Release
//
//////////////////////////////////////////////////////////////////////
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;

    return lRef;
}

#define	TEST_STRING	L"TestCounterString"

STDMETHODIMP CRefresher::Refresh(/* [in] */ long lFlags)
//////////////////////////////////////////////////////////////
//
//  Executed to refresh a set of instances and enumerators 
//	assigned to the particular refresher.
//
//	<lFlags>	Not used
//
//////////////////////////////////////////////////////////////
{
	HRESULT hRes;

	// Increment Counter
	// =================

	if (m_lCount == 0xFFFFFFFF)
		m_lCount = 0;

	int nLastNum = 0;

	// First time we are refreshed, generate a new string
	if ( 0 == m_lCount )
	{
		WCHAR*	pwcsNewStr = new WCHAR[wcslen( TEST_STRING ) + ( 1000 ) + 1];

		if ( NULL != pwcsNewStr )
		{
			if ( NULL != m_pwcsTestString )
			{
				delete [] m_pwcsTestString;
			}

			m_pwcsTestString = pwcsNewStr;
			wcscpy( m_pwcsTestString, TEST_STRING );

			// Add values to the string
			for ( long lCtr = 0; lCtr < 1000; lCtr++ )
			{
				wcscat( m_pwcsTestString, L"1" );
			}
		}
	}

	m_lCount++;

    // Zip through all the objects and increment the values
	// ====================================================

	for (int nIndex = 0; nIndex < NUM_INSTANCES; nIndex++)
	{
		if (0 == m_aObject[nIndex])
			continue;

		// Update the values
		// =================

		m_pProvider->UpdateInstanceCtrs(m_aObject[nIndex], m_lCount, m_pwcsTestString, &nLastNum);
	}

	// Cycle through the enumerators, adding and deleting objects
	// ==========================================================

	for (int nType = 0; nType < NUM_OBJECT_TYPES; nType++)
	{
		if (0 == m_aEnumerator[nType])
			continue;

		long lID = rand() % NUM_OBJECTS;

		long lCount = 0;
		long alIDs[NUM_OBJECTS];
		IWbemObjectAccess* aInstList[NUM_OBJECTS];

		// Just to be malicious, remove a single object here (if it exists), then
		// the lot of them.

		hRes = m_aEnumerator[nType]->RemoveObjects(0, 1, &lID);

		// Remove all objects then add a random number of objects
		// Global objects should already be initialized
		m_aEnumerator[nType]->RemoveAll( 0L );

		for (int nInst = 0; nInst < lID; nInst++)
		{
			if (NULL != m_pProvider->m_apInstance[nType][nInst])
			{
				hRes = CloneObjAccess( m_pProvider->m_apInstance[nType][nInst], &aInstList[lCount] );

				// Update the values in the instance
				m_pProvider->UpdateInstanceCtrs(aInstList[lCount], m_lCount, m_pwcsTestString, &nLastNum);

				alIDs[lCount] = nInst;
				lCount++;
			}
		}

		m_aEnumerator[nType]->AddObjects(0L, lCount, alIDs, aInstList);

		// Cleanup the instance list
		for (nInst = 0; nInst < lCount; nInst++)
		{
			aInstList[nInst]->Release();
		}


		// Get another random instance to delete from the enumerator
		// =========================================================
		lID = rand() % NUM_OBJECTS;
		hRes = m_aEnumerator[nType]->RemoveObjects(0, 1, &lID);
	}

	return NO_ERROR;
}

HRESULT	CloneObjAccess( IWbemObjectAccess* pObj, IWbemObjectAccess** ppClonedObj )
{
	IWbemClassObject* pObject = 0;
	CReleaseMe RM1((IUnknown**)&pObject);
	
	IWbemClassObject* pClone = 0;
	CReleaseMe RM2((IUnknown**)&pClone);

	// Clone the instance
	// ==================

	HRESULT	hr = pObj->QueryInterface(IID_IWbemClassObject, (PVOID*)&pObject);

	if ( SUCCEEDED( hr ) )
	{
		hr = pObject->Clone(&pClone);

		if ( SUCCEEDED( hr ) )
		{
			hr = pClone->QueryInterface(IID_IWbemObjectAccess, (PVOID*)ppClonedObj );

		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\instprov\server.cpp ===
//***************************************************************************
//
//  Copyright (c) 1996-2001, Microsoft Corporation, All rights reserved
//
//  SERVER.CPP
//
//  Generic COM server framework sample
//
//***************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <time.h>
#include <locale.h>
#include <initguid.h>


/////////////////////////////////////////////////////////////////////////////
//
//  BEGIN CLSID SPECIFIC SECTION
//
//

#include <wbemidl.h>

#include <stdprov.h>


// {A41602A4-C038-11d1-AEB6-00C04FB68820}
DEFINE_GUID(CLSID_LogicalDiskProv,
0xa41602a4, 0xc038, 0x11d1, 0xae, 0xb6, 0x0, 0xc0, 0x4f, 0xb6, 0x88, 0x20);


#define IMPLEMENTED_CLSID           CLSID_LogicalDiskProv
#define SERVER_REGISTRY_COMMENT     L"WBEM Test Provider"
#define CPP_CLASS_NAME              CStdProvider
#define INTERFACE_CAST              (IWbemProviderInit *)

//
//  END CLSID SPECIFIC SECTION
//
/////////////////////////////////////////////////////////////////////////////




HINSTANCE g_hInstance;
static ULONG g_cLock = 0;

void ObjectCreated()    { g_cLock++; }
void ObjectDestroyed() { g_cLock--; }


//***************************************************************************
//
//  class CFactory
//
//  Generic implementation of IClassFactory for CWbemLocator.
//
//***************************************************************************

class CFactory : public IClassFactory
{
    ULONG           m_cRef;
    CLSID           m_ClsId;

public:
    CFactory(const CLSID & ClsId);
    ~CFactory();

    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IClassFactory members
    //
    STDMETHODIMP     CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP     LockServer(BOOL);
};




//***************************************************************************
//
//  DllMain
//
//  Dll entry point.
//
//  PARAMETERS:
//
//      HINSTANCE hinstDLL      The handle to our DLL.
//      DWORD dwReason          DLL_PROCESS_ATTACH on load,
//                              DLL_PROCESS_DETACH on shutdown,
//                              DLL_THREAD_ATTACH/DLL_THREAD_DETACH otherwise.
//      LPVOID lpReserved       Reserved
//
//  RETURN VALUES:
//
//      TRUE is successful, FALSE if a fatal error occured.
//      NT behaves very ugly if FALSE is returned.
//
//***************************************************************************
BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        setlocale(LC_ALL, "");      // Set to the 'current' locale
        g_hInstance = hinstDLL;
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
    }

    return TRUE;
}



//***************************************************************************
//
//  DllGetClassObject
//
//  Standard OLE In-Process Server entry point to return an class factory
//  instance.
//
//  PARAMETERS:
//
//  RETURNS:
//
//      S_OK                Success
//      E_NOINTERFACE       An interface other that IClassFactory was asked for
//      E_OUTOFMEMORY
//      E_FAILED            Initialization failed, or an unsupported clsid was
//                          asked for.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID * ppv
    )
{
    CFactory *pFactory;

    //
    //  Verify the caller is asking for our type of object.
    //
    if (IMPLEMENTED_CLSID != rclsid) 
            return ResultFromScode(E_FAIL);

    //
    // Check that we can provide the interface.
    //
    if (IID_IUnknown != riid && IID_IClassFactory != riid)
        return ResultFromScode(E_NOINTERFACE);

    //
    // Get a new class factory.
    //
    pFactory = new CFactory(rclsid);

    if (!pFactory)
        return ResultFromScode(E_OUTOFMEMORY);

    //
    // Verify we can get an instance.
    //
    HRESULT hRes = pFactory->QueryInterface(riid, ppv);

    if (FAILED(hRes))
        delete pFactory;

    return hRes;
}

//***************************************************************************
//
//  DllCanUnloadNow
//
//  Standard OLE entry point for server shutdown request. Allows shutdown
//  only if no outstanding objects or locks are present.
//
//  RETURN VALUES:
//
//      S_OK        May unload now.
//      S_FALSE     May not.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllCanUnloadNow(void)
{
    SCODE sc = TRUE;

    if (g_cLock)
        sc = S_FALSE;

    return sc;
}

//***************************************************************************
//
//  DllRegisterServer
//
//  Standard OLE entry point for registering the server.
//
//  RETURN VALUES:
//
//      S_OK        Registration was successful
//      E_FAIL      Registration failed.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllRegisterServer(void)
{
    wchar_t Path[1024];
    wchar_t *pGuidStr = 0;
    wchar_t KeyPath[1024];

    // Where are we?
    // =============
    GetModuleFileNameW(g_hInstance, Path, 1024);

    // Convert CLSID to string.
    // ========================

    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    // Place it in registry.
    // CLSID\\CLSID_Nt5PerProvider_v1 : <no_name> : "name"
    //      \\CLSID_Nt5PerProvider_v1\\InProcServer32 : <no_name> : "path to DLL"
    //                                    : ThreadingModel : "both"
    // ==============================================================

    HKEY hKey;
    LONG lRes = RegCreateKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    wchar_t *pName = SERVER_REGISTRY_COMMENT; 
    RegSetValueExW(hKey, 0, 0, REG_SZ, (const BYTE *) pName, wcslen(pName) * 2 + 2);

    HKEY hSubkey;
    lRes = RegCreateKey(hKey, "InprocServer32", &hSubkey);

    RegSetValueExW(hSubkey, 0, 0, REG_SZ, (const BYTE *) Path, wcslen(Path) * 2 + 2);
    RegSetValueExW(hSubkey, L"ThreadingModel", 0, REG_SZ, (const BYTE *) L"Both", wcslen(L"Both") * 2 + 2);

    RegCloseKey(hSubkey);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}

//***************************************************************************
//
//  DllUnregisterServer
//
//  Standard OLE entry point for unregistering the server.
//
//  RETURN VALUES:
//
//      S_OK        Unregistration was successful
//      E_FAIL      Unregistration failed.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllUnregisterServer(void)
{
    wchar_t *pGuidStr = 0;
    HKEY hKey;
    wchar_t KeyPath[256];

    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    // Delete InProcServer32 subkey.
    // =============================
    LONG lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, L"InprocServer32");
    RegCloseKey(hKey);

    // Delete CLSID GUID key.
    // ======================

    lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, L"Software\\Classes\\CLSID", &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, pGuidStr);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}




//***************************************************************************
//
//  CFactory::CFactory
//
//  Constructs the class factory given the CLSID of the objects it is supposed
//  to create.
//
//  PARAMETERS:
//
//      const CLSID & ClsId     The CLSID. 
//
//***************************************************************************
CFactory::CFactory(const CLSID & ClsId)
{
    m_cRef = 0;
    ObjectCreated();
    m_ClsId = ClsId;
}

//***************************************************************************
//
//  CFactory::~CFactory
//
//  Destructor.
//
//***************************************************************************
CFactory::~CFactory()
{
    ObjectDestroyed();
}

//***************************************************************************
//
//  CFactory::QueryInterface, AddRef and Release
//
//  Standard IUnknown methods.
//
//***************************************************************************
STDMETHODIMP CFactory::QueryInterface(REFIID riid, LPVOID * ppv)
{
    *ppv = 0;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
    {
        *ppv = this;
        AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


ULONG CFactory::AddRef()
{
    return ++m_cRef;
}


ULONG CFactory::Release()
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
//
//  CFactory::CreateInstance
//
//  PARAMETERS:
//
//      LPUNKNOWN pUnkOuter     IUnknown of the aggregator. Must be NULL.
//      REFIID riid             Interface ID required.
//      LPVOID * ppvObj         Destination for the interface pointer.
//
//  RETURN VALUES:
//
//      S_OK                        Success
//      CLASS_E_NOAGGREGATION       pUnkOuter must be NULL
//      E_NOINTERFACE               No such interface supported.
//      
//***************************************************************************

STDMETHODIMP CFactory::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID * ppvObj)
{
    IUnknown* pObj;
    HRESULT  hr;

    //
    //  Defaults
    //
    *ppvObj=NULL;
    hr = ResultFromScode(E_OUTOFMEMORY);

    //
    // We aren't supporting aggregation.
    //
    if (pUnkOuter)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    if (m_ClsId == IMPLEMENTED_CLSID)
    {
        pObj = INTERFACE_CAST new CPP_CLASS_NAME;
    }

    if (!pObj)
        return hr;

    //
    //  Initialize the object and verify that it can return the
    //  interface in question.
    //
    hr = pObj->QueryInterface(riid, ppvObj);

    //
    // Kill the object if initial creation or Init failed.
    //
    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
//  CFactory::LockServer
//
//  Increments or decrements the lock count of the server. The DLL will not
//  unload while the lock count is positive.
//
//  PARAMETERS:
//
//      BOOL fLock      If TRUE, locks; otherwise, unlocks.
//
//  RETURN VALUES:
//
//      S_OK
//
//***************************************************************************
STDMETHODIMP CFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *) &g_cLock);
    else
        InterlockedDecrement((LONG *) &g_cLock);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\mergertest\server.cpp ===
//***************************************************************************
//
//  Copyright (c) 1996-2001, Microsoft Corporation, All rights reserved
//
//  SERVER.CPP
//
//  Generic COM server framework sample
//
//***************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <time.h>
#include <locale.h>
#include <initguid.h>


/////////////////////////////////////////////////////////////////////////////
//
//  BEGIN CLSID SPECIFIC SECTION
//
//

#include <wbemidl.h>

#include <stdprov.h>


// {A41602A4-C038-11d1-AEB6-00C04FB68820}
DEFINE_GUID(CLSID_LogicalDiskProv,
0xa41602a4, 0xc038, 0x11d1, 0xae, 0xb6, 0x0, 0xc0, 0x4f, 0xb6, 0x88, 0x20);


#define IMPLEMENTED_CLSID           CLSID_LogicalDiskProv
#define SERVER_REGISTRY_COMMENT     L"WBEM Test Provider"
#define CPP_CLASS_NAME              CStdProvider
#define INTERFACE_CAST              (IWbemProviderInit *)

//
//  END CLSID SPECIFIC SECTION
//
/////////////////////////////////////////////////////////////////////////////




HINSTANCE g_hInstance;
static ULONG g_cLock = 0;

void ObjectCreated()    { g_cLock++; }
void ObjectDestroyed() { g_cLock--; }


//***************************************************************************
//
//  class CFactory
//
//  Generic implementation of IClassFactory for CWbemLocator.
//
//***************************************************************************

class CFactory : public IClassFactory
{
    ULONG           m_cRef;
    CLSID           m_ClsId;

public:
    CFactory(const CLSID & ClsId);
    ~CFactory();

    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IClassFactory members
    //
    STDMETHODIMP     CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP     LockServer(BOOL);
};




//***************************************************************************
//
//  DllMain
//
//  Dll entry point.
//
//  PARAMETERS:
//
//      HINSTANCE hinstDLL      The handle to our DLL.
//      DWORD dwReason          DLL_PROCESS_ATTACH on load,
//                              DLL_PROCESS_DETACH on shutdown,
//                              DLL_THREAD_ATTACH/DLL_THREAD_DETACH otherwise.
//      LPVOID lpReserved       Reserved
//
//  RETURN VALUES:
//
//      TRUE is successful, FALSE if a fatal error occured.
//      NT behaves very ugly if FALSE is returned.
//
//***************************************************************************
BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        setlocale(LC_ALL, "");      // Set to the 'current' locale
        g_hInstance = hinstDLL;
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
    }

    return TRUE;
}



//***************************************************************************
//
//  DllGetClassObject
//
//  Standard OLE In-Process Server entry point to return an class factory
//  instance.
//
//  PARAMETERS:
//
//  RETURNS:
//
//      S_OK                Success
//      E_NOINTERFACE       An interface other that IClassFactory was asked for
//      E_OUTOFMEMORY
//      E_FAILED            Initialization failed, or an unsupported clsid was
//                          asked for.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID * ppv
    )
{
    CFactory *pFactory;

    //
    //  Verify the caller is asking for our type of object.
    //
    if (IMPLEMENTED_CLSID != rclsid) 
            return ResultFromScode(E_FAIL);

    //
    // Check that we can provide the interface.
    //
    if (IID_IUnknown != riid && IID_IClassFactory != riid)
        return ResultFromScode(E_NOINTERFACE);

    //
    // Get a new class factory.
    //
    pFactory = new CFactory(rclsid);

    if (!pFactory)
        return ResultFromScode(E_OUTOFMEMORY);

    //
    // Verify we can get an instance.
    //
    HRESULT hRes = pFactory->QueryInterface(riid, ppv);

    if (FAILED(hRes))
        delete pFactory;

    return hRes;
}

//***************************************************************************
//
//  DllCanUnloadNow
//
//  Standard OLE entry point for server shutdown request. Allows shutdown
//  only if no outstanding objects or locks are present.
//
//  RETURN VALUES:
//
//      S_OK        May unload now.
//      S_FALSE     May not.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllCanUnloadNow(void)
{
    SCODE sc = TRUE;

    if (g_cLock)
        sc = S_FALSE;

    return sc;
}

//***************************************************************************
//
//  DllRegisterServer
//
//  Standard OLE entry point for registering the server.
//
//  RETURN VALUES:
//
//      S_OK        Registration was successful
//      E_FAIL      Registration failed.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllRegisterServer(void)
{
    wchar_t Path[1024];
    wchar_t *pGuidStr = 0;
    wchar_t KeyPath[1024];

    // Where are we?
    // =============
    GetModuleFileNameW(g_hInstance, Path, 1024);

    // Convert CLSID to string.
    // ========================

    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    // Place it in registry.
    // CLSID\\CLSID_Nt5PerProvider_v1 : <no_name> : "name"
    //      \\CLSID_Nt5PerProvider_v1\\InProcServer32 : <no_name> : "path to DLL"
    //                                    : ThreadingModel : "both"
    // ==============================================================

    HKEY hKey;
    LONG lRes = RegCreateKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    wchar_t *pName = SERVER_REGISTRY_COMMENT; 
    RegSetValueExW(hKey, 0, 0, REG_SZ, (const BYTE *) pName, wcslen(pName) * 2 + 2);

    HKEY hSubkey;
    lRes = RegCreateKey(hKey, "InprocServer32", &hSubkey);

    RegSetValueExW(hSubkey, 0, 0, REG_SZ, (const BYTE *) Path, wcslen(Path) * 2 + 2);
    RegSetValueExW(hSubkey, L"ThreadingModel", 0, REG_SZ, (const BYTE *) L"Both", wcslen(L"Both") * 2 + 2);

    RegCloseKey(hSubkey);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

	if ( RegCreateKeyW( HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\WBEM\\instprov", &hKey )
		== ERROR_SUCCESS )
	{

		DWORD	dwVal = 1;
	    RegSetValueExW(hKey, L"ClassALow", 0, REG_DWORD, (const BYTE *) &dwVal, sizeof(dwVal));
	    RegSetValueExW(hKey, L"ClassFLow", 0, REG_DWORD, (const BYTE *) &dwVal, sizeof(dwVal));

		dwVal = 2;
	    RegSetValueExW(hKey, L"ClassBLow", 0, REG_DWORD, (const BYTE *) &dwVal, sizeof(dwVal));
	    RegSetValueExW(hKey, L"ClassGLow", 0, REG_DWORD, (const BYTE *) &dwVal, sizeof(dwVal));
	    RegSetValueExW(hKey, L"ClassFHi", 0, REG_DWORD, (const BYTE *) &dwVal, sizeof(dwVal));
	    RegSetValueExW(hKey, L"ClassGHi", 0, REG_DWORD, (const BYTE *) &dwVal, sizeof(dwVal));

		dwVal = 3;
	    RegSetValueExW(hKey, L"ClassCLow", 0, REG_DWORD, (const BYTE *) &dwVal, sizeof(dwVal));

		dwVal = 4;
	    RegSetValueExW(hKey, L"ClassDLow", 0, REG_DWORD, (const BYTE *) &dwVal, sizeof(dwVal));

		dwVal = 5;
	    RegSetValueExW(hKey, L"ClassELow", 0, REG_DWORD, (const BYTE *) &dwVal, sizeof(dwVal));
	    RegSetValueExW(hKey, L"ClassAHi", 0, REG_DWORD, (const BYTE *) &dwVal, sizeof(dwVal));
	    RegSetValueExW(hKey, L"ClassBHi", 0, REG_DWORD, (const BYTE *) &dwVal, sizeof(dwVal));
	    RegSetValueExW(hKey, L"ClassCHi", 0, REG_DWORD, (const BYTE *) &dwVal, sizeof(dwVal));
	    RegSetValueExW(hKey, L"ClassDHi", 0, REG_DWORD, (const BYTE *) &dwVal, sizeof(dwVal));
	    RegSetValueExW(hKey, L"ClassEHi", 0, REG_DWORD, (const BYTE *) &dwVal, sizeof(dwVal));

		RegCloseKey( hKey );

	}

    return S_OK;
}

//***************************************************************************
//
//  DllUnregisterServer
//
//  Standard OLE entry point for unregistering the server.
//
//  RETURN VALUES:
//
//      S_OK        Unregistration was successful
//      E_FAIL      Unregistration failed.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllUnregisterServer(void)
{
    wchar_t *pGuidStr = 0;
    HKEY hKey;
    wchar_t KeyPath[256];

    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    // Delete InProcServer32 subkey.
    // =============================
    LONG lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, L"InprocServer32");
    RegCloseKey(hKey);

    // Delete CLSID GUID key.
    // ======================

    lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, L"Software\\Classes\\CLSID", &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, pGuidStr);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}




//***************************************************************************
//
//  CFactory::CFactory
//
//  Constructs the class factory given the CLSID of the objects it is supposed
//  to create.
//
//  PARAMETERS:
//
//      const CLSID & ClsId     The CLSID. 
//
//***************************************************************************
CFactory::CFactory(const CLSID & ClsId)
{
    m_cRef = 0;
    ObjectCreated();
    m_ClsId = ClsId;
}

//***************************************************************************
//
//  CFactory::~CFactory
//
//  Destructor.
//
//***************************************************************************
CFactory::~CFactory()
{
    ObjectDestroyed();
}

//***************************************************************************
//
//  CFactory::QueryInterface, AddRef and Release
//
//  Standard IUnknown methods.
//
//***************************************************************************
STDMETHODIMP CFactory::QueryInterface(REFIID riid, LPVOID * ppv)
{
    *ppv = 0;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
    {
        *ppv = this;
        AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


ULONG CFactory::AddRef()
{
    return ++m_cRef;
}


ULONG CFactory::Release()
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
//
//  CFactory::CreateInstance
//
//  PARAMETERS:
//
//      LPUNKNOWN pUnkOuter     IUnknown of the aggregator. Must be NULL.
//      REFIID riid             Interface ID required.
//      LPVOID * ppvObj         Destination for the interface pointer.
//
//  RETURN VALUES:
//
//      S_OK                        Success
//      CLASS_E_NOAGGREGATION       pUnkOuter must be NULL
//      E_NOINTERFACE               No such interface supported.
//      
//***************************************************************************

STDMETHODIMP CFactory::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID * ppvObj)
{
    IUnknown* pObj;
    HRESULT  hr;

    //
    //  Defaults
    //
    *ppvObj=NULL;
    hr = ResultFromScode(E_OUTOFMEMORY);

    //
    // We aren't supporting aggregation.
    //
    if (pUnkOuter)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    if (m_ClsId == IMPLEMENTED_CLSID)
    {
        pObj = INTERFACE_CAST new CPP_CLASS_NAME;
    }

    if (!pObj)
        return hr;

    //
    //  Initialize the object and verify that it can return the
    //  interface in question.
    //
    hr = pObj->QueryInterface(riid, ppvObj);

    //
    // Kill the object if initial creation or Init failed.
    //
    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
//  CFactory::LockServer
//
//  Increments or decrements the lock count of the server. The DLL will not
//  unload while the lock count is positive.
//
//  PARAMETERS:
//
//      BOOL fLock      If TRUE, locks; otherwise, unlocks.
//
//  RETURN VALUES:
//
//      S_OK
//
//***************************************************************************
STDMETHODIMP CFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *) &g_cLock);
    else
        InterlockedDecrement((LONG *) &g_cLock);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\mergertest\stdprov.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//***************************************************************************
//
//  STDPROV.CPP
//
//  Sample provider for LogicalDisk
//
//***************************************************************************

#include "precomp.h"
#include <stdio.h>

#include <wbemidl.h>

#include <stdprov.h>


int	CLASS_A_LOW = 1;
int	CLASS_A_HI = 5;

int	CLASS_B_LOW = 2;
int	CLASS_B_HI = 5;

int	CLASS_C_LOW = 3;
int	CLASS_C_HI = 5;

int	CLASS_D_LOW = 4;
int	CLASS_D_HI = 5;

int	CLASS_E_LOW = 5;
int	CLASS_E_HI = 5;

int CLASS_F_LOW = 1;
int CLASS_F_HI = 2;

int	CLASS_G_LOW = 2;
int CLASS_G_HI = 2;

int g_fReverseOrder = FALSE;

int g_nBatchSize = 0x7FFFFFFF;
DWORD	g_dwBatchDelay = 0;


//***************************************************************************
//
//  CStdProvider constructor
//
//***************************************************************************
// ok

CStdProvider::CStdProvider()
{
    m_lRef = 0;
    m_pClassDefA = 0;
    m_pClassDefB = 0;
    m_pClassDefC = 0;
    m_pClassDefD = 0;
    m_pClassDefE = 0;
    m_pClassDefF = 0;
    m_pClassDefG = 0;

	InitializeCriticalSection( &m_cs );
}

//***************************************************************************
//
//  CStdProvider destructor
//
//***************************************************************************
// ok

CStdProvider::~CStdProvider()
{
    if (m_pClassDefA)
        m_pClassDefA->Release();

    if (m_pClassDefB)
        m_pClassDefB->Release();

    if (m_pClassDefC)
        m_pClassDefC->Release();

    if (m_pClassDefD)
        m_pClassDefD->Release();

    if (m_pClassDefE)
        m_pClassDefE->Release();

    if (m_pClassDefF)
        m_pClassDefF->Release();

    if (m_pClassDefG)
        m_pClassDefG->Release();

	DeleteCriticalSection( &m_cs );

}


//***************************************************************************
//
//  CStdProvider::AddRef
//
//***************************************************************************
// ok

ULONG CStdProvider::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

//***************************************************************************
//
//  CStdProvider::Release
//
//***************************************************************************
// ok

ULONG CStdProvider::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

//***************************************************************************
//
//  CNt5Refresher::QueryInterface
//
//  Standard COM QueryInterface().  We have to support two interfaces,
//  the IWbemServices interface itself to provide the objects and
//  the IWbemProviderInit interface to initialize the provider.
//
//***************************************************************************
// ok

HRESULT CStdProvider::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemServices)
    {
        *ppv = (IWbemServices *) this;
        AddRef();
        return S_OK;
    }
    else if (riid == IID_IWbemProviderInit)
    {
        *ppv = (IWbemProviderInit *) this;
        AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}


//***************************************************************************
//
//  CNt5Refresher::Initialize
//
//  Called once during startup.  Insdicates to the provider which
//  namespace it is being invoked for and which User.  It also supplies
//  a back pointer to CIMOM so that class definitions can be retrieved.
//
//  We perform any one-time initialization in this routine. The
//  final call to Release() is for any cleanup.
//
//  <wszUser>           The current user.
//  <lFlags>            Reserved.
//  <wszNamespace>      The namespace for which we are being activated.
//  <wszLocale>         The locale under which we are to be running.
//  <pNamespace>        An active pointer back into the current namespace
//                      from which we can retrieve schema objects.
//  <pCtx>              The user's context object.  We simply reuse this
//                      during any reentrant operations into CIMOM.
//  <pInitSink>         The sink to which we indicate our readiness.
//
//***************************************************************************
// ok

HRESULT CStdProvider::Initialize( 
    /* [unique][in] */  LPWSTR wszUser,
    /* [in] */          LONG lFlags,
    /* [in] */          LPWSTR wszNamespace,
    /* [unique][in] */  LPWSTR wszLocale,
    /* [in] */          IWbemServices __RPC_FAR *pNamespace,
    /* [in] */          IWbemContext __RPC_FAR *pCtx,
    /* [in] */          IWbemProviderInitSink __RPC_FAR *pInitSink
    )
{
    // Get the class definition.
    // =========================

    BSTR strClass = SysAllocString(L"ClassA");
    
    HRESULT hRes = pNamespace->GetObject(
        strClass,
        0, 
        pCtx, 
        &m_pClassDefA, 
        0
        );

    SysFreeString(strClass);

    if (hRes)
        return hRes;

    strClass = SysAllocString(L"ClassB");
    
    hRes = pNamespace->GetObject(
        strClass,
        0, 
        pCtx, 
        &m_pClassDefB, 
        0
        );

    SysFreeString(strClass);

//    if (hRes)
//        return hRes;

    strClass = SysAllocString(L"ClassC");
    
    hRes = pNamespace->GetObject(
        strClass,
        0, 
        pCtx, 
        &m_pClassDefC, 
        0
        );

    SysFreeString(strClass);

//    if (hRes)
//        return hRes;

    strClass = SysAllocString(L"ClassD");
    
    hRes = pNamespace->GetObject(
        strClass,
        0, 
        pCtx, 
        &m_pClassDefD, 
        0
        );

    SysFreeString(strClass);

//    if (hRes)
//        return hRes;

    strClass = SysAllocString(L"ClassE");
    
    hRes = pNamespace->GetObject(
        strClass,
        0, 
        pCtx, 
        &m_pClassDefE, 
        0
        );

    SysFreeString(strClass);

    strClass = SysAllocString(L"ClassF");
    
    hRes = pNamespace->GetObject(
        strClass,
        0, 
        pCtx, 
        &m_pClassDefF,
        0
        );

    SysFreeString(strClass);

    strClass = SysAllocString(L"ClassG");
    
    hRes = pNamespace->GetObject(
        strClass,
        0, 
        pCtx, 
        &m_pClassDefG ,
        0
        );

    SysFreeString(strClass);

//    if (hRes)
//        return hRes;

	hRes = InitializeRegInfo();

    if (hRes)
        return hRes;

    pInitSink->SetStatus(0, WBEM_S_INITIALIZED);
    return NO_ERROR;
}
    

//*****************************************************************************
//
//*****************************************************************************        


HRESULT CStdProvider::OpenNamespace( 
            /* [in] */ BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        

HRESULT CStdProvider::GetObject( 
            /* [in] */ BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::GetObjectAsync( 
            /* [in] */ BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{

	InitializeRegInfo();

    // Parse the object path.
    // ======================

    wchar_t Class[128], Key[128];
    *Class = 0;
    *Key = 0;

	int	nClass = CLASS_A;

	if ( NULL != strObjectPath )
	{
		for ( int x = 0; strObjectPath[x] != L'.'; x++ )
		{
			Class[x] = strObjectPath[x];
		}

		Class[x] = NULL;

		for ( ; strObjectPath[x] != L'='; x++ );

		x++;

		wcscpy( Key, &strObjectPath[x] );
	}

	HRESULT	hr = GetClassConst( Class, &nClass );

	if ( FAILED( hr ) )
	{
		return hr;
	}

    if (wcslen(Key) == 0)
        return WBEM_E_INVALID_PARAMETER;


    // Set up an empty instance.
    // =========================

    IWbemClassObject *pInst = 0;
    
	IWbemClassObject*	pClass = NULL;

	switch( nClass )
	{
	case CLASS_A:	pClass = m_pClassDefA; break;
	case CLASS_B:	pClass = m_pClassDefB; break;
	case CLASS_C:	pClass = m_pClassDefC; break;
	case CLASS_D:	pClass = m_pClassDefD; break;
	case CLASS_E:	pClass = m_pClassDefE; break;
	case CLASS_F:	pClass = m_pClassDefF; break;
	case CLASS_G:	pClass = m_pClassDefG; break;
	}

    HRESULT hRes = pClass->SpawnInstance(0, &pInst);
    if (hRes)
        return hRes;

    BOOL bRes = GetInstance(
		nClass,
        wcstoul( Key, NULL, 10 ),
        pInst
        );


    // If we succeeded, send the instance back to CIMOM.
    // =================================================

    if (bRes)
    {
        hr = pResponseHandler->Indicate(1, &pInst);
        pResponseHandler->SetStatus(0, hr, 0, 0);
        pInst->Release();
        return hr;
    }


    // Indicate that the instance couldn't be found.
    // ==============================================

    pResponseHandler->SetStatus(0, WBEM_E_NOT_FOUND, 0, 0);
    pInst->Release();

    return hr;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::DeleteClass( 
            /* [in] */ BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::DeleteClassAsync( 
            /* [in] */ BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::CreateClassEnum( 
            /* [in] */ BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::CreateClassEnumAsync( 
            /* [in] */ BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::DeleteInstance( 
            /* [in] */ BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::DeleteInstanceAsync( 
            /* [in] */ BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::CreateInstanceEnum( 
            /* [in] */ BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::CreateInstanceEnumAsync( 
            /* [in] */ BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
	InitializeRegInfo();

	int	nClass = CLASS_A;

	HRESULT	hr = GetClassConst( strClass, &nClass );

	if ( FAILED( hr ) )
	{
		return hr;
	}

    BOOL bRes = GetInstances( nClass, pResponseHandler );

    // Finished delivering instances.
    // ==============================

    if (bRes == TRUE)
        pResponseHandler->SetStatus(0, WBEM_NO_ERROR, 0, 0);
    else
        pResponseHandler->SetStatus(0, WBEM_E_FAILED, 0, 0);
    
    return WBEM_NO_ERROR;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::ExecQuery( 
            /* [in] */ BSTR strQueryLanguage,
            /* [in] */ BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::ExecQueryAsync( 
            /* [in] */ BSTR strQueryLanguage,
            /* [in] */ BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
//    pResponseHandler->Indicate(1, &pInst);
    pResponseHandler->SetStatus(0, WBEM_NO_ERROR, 0, 0);
    return WBEM_NO_ERROR;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::ExecNotificationQuery( 
            /* [in] */ BSTR strQueryLanguage,
            /* [in] */ BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::ExecNotificationQueryAsync( 
            /* [in] */ BSTR strQueryLanguage,
            /* [in] */ BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::ExecMethod( 
            /* [in] */ BSTR strObjectPath,
            /* [in] */ BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::ExecMethodAsync( 
            /* [in] */ BSTR strObjectPath,
            /* [in] */ BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//*****************************************************************************
//
//  GetInstances
//  
//*****************************************************************************

BOOL CStdProvider::GetInstances(
	int nClass,
    IWbemObjectSink *pSink
    )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

    wchar_t szDrive[8];

	int	nLowVal = CLASS_A_LOW;
	int	nHighVal = CLASS_A_HI;

	if ( nClass == CLASS_B )
	{
		nLowVal = CLASS_B_LOW;
		nHighVal = CLASS_B_HI;
	}
	else if ( nClass == CLASS_C )
	{
		nLowVal = CLASS_C_LOW;
		nHighVal = CLASS_C_HI;
	}
	else if ( nClass == CLASS_D )
	{
		nLowVal = CLASS_D_LOW;
		nHighVal = CLASS_D_HI;
	}
	else if ( nClass == CLASS_E )
	{
		nLowVal = CLASS_E_LOW;
		nHighVal = CLASS_E_HI;
	}
	else if ( nClass == CLASS_F )
	{
		nLowVal = CLASS_F_LOW;
		nHighVal = CLASS_F_HI;
	}
	else if ( nClass == CLASS_G )
	{
		nLowVal = CLASS_G_LOW;
		nHighVal = CLASS_G_HI;
	}

	int	x = 1;

	// If the reverse bit is not set, or we are A, C, E, or G, we will not reverse order
	if ( !g_fReverseOrder || nClass == CLASS_A || nClass == CLASS_C || nClass == CLASS_E ||
		nClass == CLASS_G )
	{
		// Loop through all the drives.
		// ============================

		for (int i = nLowVal; SUCCEEDED( hr ) && i <= nHighVal; i++)
		{
			// Create an empty instance.
			// =========================

			IWbemClassObject *pInst = 0;
    
			IWbemClassObject*	pClass = NULL;

			switch( nClass )
			{
			case CLASS_A:	pClass = m_pClassDefA; break;
			case CLASS_B:	pClass = m_pClassDefB; break;
			case CLASS_C:	pClass = m_pClassDefC; break;
			case CLASS_D:	pClass = m_pClassDefD; break;
			case CLASS_E:	pClass = m_pClassDefE; break;
			case CLASS_F:	pClass = m_pClassDefF; break;
			case CLASS_G:	pClass = m_pClassDefG; break;
			}

			HRESULT hRes = pClass->SpawnInstance(0, &pInst);

			if (hRes)
				return FALSE;


			// Fill in the instance.
			// =====================

			BOOL bRes = GetInstance( nClass, i, pInst);

			if (!bRes)
			{
				pInst->Release();
				continue;
			}
        
			// If here, the instance is good, so deliver it to CIMOM.
			// ======================================================

			hr = pSink->Indicate(1, &pInst);

			pInst->Release();

			// If we just exceeded the batch size, we should sleep for the
			// batch delay
			x++;

			if ( ( x % g_nBatchSize ) == 0 )
			{
				Sleep( g_dwBatchDelay );
				x = 1;
			}
		}

	}
	else
	{

		for (int i = nHighVal; SUCCEEDED( hr ) && i >= nLowVal; i--)
		{
			// Create an empty instance.
			// =========================

			IWbemClassObject *pInst = 0;
    
			IWbemClassObject*	pClass = NULL;

			switch( nClass )
			{
			case CLASS_A:	pClass = m_pClassDefA; break;
			case CLASS_B:	pClass = m_pClassDefB; break;
			case CLASS_C:	pClass = m_pClassDefC; break;
			case CLASS_D:	pClass = m_pClassDefD; break;
			case CLASS_E:	pClass = m_pClassDefE; break;
			case CLASS_F:	pClass = m_pClassDefF; break;
			case CLASS_G:	pClass = m_pClassDefG; break;
			}

			hr = pClass->SpawnInstance(0, &pInst);

			if ( FAILED( hr ) )
				return FALSE;


			// Fill in the instance.
			// =====================

			BOOL bRes = GetInstance( nClass, i, pInst);

			if (!bRes)
			{
				hr = WBEM_E_NOT_FOUND;
				pInst->Release();
				continue;
			}
        
			// If here, the instance is good, so deliver it to CIMOM.
			// ======================================================

			hr = pSink->Indicate(1, &pInst);

			pInst->Release();

			// If we just exceeded the batch size, we should sleep for the
			// batch delay
			x++;

			if ( ( x % g_nBatchSize ) == 0 )
			{
				Sleep( g_dwBatchDelay );
				x = 1;
			}

		}

	}

    return SUCCEEDED( hr );
}


//*****************************************************************************
//
//  GetInstance
//
//  Gets drive info for the requested drive and populates the IWbemClassObject.
//
//  Returns FALSE on fail (non-existent drive)
//  Returns TRUE on success
//
//*****************************************************************************        

BOOL CStdProvider::GetInstance(
	IN	int nClass,
    IN  int nInst,
    OUT IWbemClassObject *pObj    
    )
{
    VARIANT	v;

	if ( nClass == CLASS_A && ( nInst < CLASS_A_LOW  || nInst > CLASS_A_HI ) )
	{
		return FALSE;
	}
	else if ( nClass == CLASS_B && ( nInst < CLASS_B_LOW  || nInst > CLASS_B_HI ) )
	{
		return FALSE;
	}
	else if ( nClass == CLASS_C && ( nInst < CLASS_C_LOW  || nInst > CLASS_C_HI ) )
	{
		return FALSE;
	}
	else if ( nClass == CLASS_D && ( nInst < CLASS_D_LOW  || nInst > CLASS_D_HI ) )
	{
		return FALSE;
	}
	else if ( nClass == CLASS_E && ( nInst < CLASS_E_LOW  || nInst > CLASS_E_HI ) )
	{
		return FALSE;
	}
	else if ( nClass == CLASS_F && ( nInst < CLASS_F_LOW  || nInst > CLASS_F_HI ) )
	{
		return FALSE;
	}
	else if ( nClass == CLASS_G && ( nInst < CLASS_G_LOW  || nInst > CLASS_G_HI ) )
	{
		return FALSE;
	}

	
    // Get information on file system.
    // ===============================
        
    // Total capacity.
    // ===============

    V_VT(&v) = VT_I4;
    V_I4(&v) = nInst;

    pObj->Put(L"value", 0, &v, 0);
    VariantClear(&v);

	switch ( nClass )
	{
	case CLASS_A:
		{
			V_VT(&v) = VT_I4;
			V_I4(&v) = (LONG) 10;

			pObj->Put(L"prop1", 0, &v, 0);
			VariantClear(&v);

			V_VT(&v) = VT_I4;
			V_I4(&v) = (LONG) 10;

			pObj->Put(L"prop2", 0, &v, 0);
			VariantClear(&v);
			break;
		}

	case CLASS_B:
		{
			V_VT(&v) = VT_I4;
			V_I4(&v) = (LONG) 100;

			pObj->Put(L"prop3", 0, &v, 0);
			VariantClear(&v);

			V_VT(&v) = VT_I4;
			V_I4(&v) = (LONG) 100;

			pObj->Put(L"prop4", 0, &v, 0);
			VariantClear(&v);
			break;
		}

	case CLASS_C:
		{
			V_VT(&v) = VT_I4;
			V_I4(&v) = (LONG) 1000;

			pObj->Put(L"prop5", 0, &v, 0);
			VariantClear(&v);

			V_VT(&v) = VT_I4;
			V_I4(&v) = (LONG) 1000;

			pObj->Put(L"prop6", 0, &v, 0);
			VariantClear(&v);
			break;
		}

	case CLASS_D:
		{
			V_VT(&v) = VT_I4;
			V_I4(&v) = (LONG) 10000;

			pObj->Put(L"prop7", 0, &v, 0);
			VariantClear(&v);

			V_VT(&v) = VT_I4;
			V_I4(&v) = (LONG) 10000;

			pObj->Put(L"prop8", 0, &v, 0);
			VariantClear(&v);
			break;
		}

	case CLASS_E:
		{
			V_VT(&v) = VT_I4;
			V_I4(&v) = (LONG) 100000;

			pObj->Put(L"prop9", 0, &v, 0);
			VariantClear(&v);

			V_VT(&v) = VT_I4;
			V_I4(&v) = (LONG) 100000;

			pObj->Put(L"prop10", 0, &v, 0);
			VariantClear(&v);
			break;
		}

	case CLASS_F:
		{
			V_VT(&v) = VT_I4;
			V_I4(&v) = (LONG) 1;

			pObj->Put(L"prop11", 0, &v, 0);
			VariantClear(&v);

			V_VT(&v) = VT_I4;
			V_I4(&v) = (LONG) 1;

			pObj->Put(L"prop12", 0, &v, 0);
			VariantClear(&v);
			break;
		}

	case CLASS_G:
		{
			V_VT(&v) = VT_I4;
			V_I4(&v) = (LONG) 2;

			pObj->Put(L"prop11", 0, &v, 0);
			VariantClear(&v);

			V_VT(&v) = VT_I4;
			V_I4(&v) = (LONG) 2;

			pObj->Put(L"prop12", 0, &v, 0);
			VariantClear(&v);

			V_VT(&v) = VT_I4;
			V_I4(&v) = (LONG) 2;

			pObj->Put(L"prop13", 0, &v, 0);
			VariantClear(&v);

			V_VT(&v) = VT_I4;
			V_I4(&v) = (LONG) 2;

			pObj->Put(L"prop14", 0, &v, 0);
			VariantClear(&v);
			break;
		}


	}

    return TRUE;
}

HRESULT CStdProvider::GetClassConst( WCHAR* Class, int* pnClass )
{
    if (_wcsicmp(Class, L"ClassA") != 0 && _wcsicmp(Class, L"ClassA.value") != 0)
	{
		if (_wcsicmp(Class, L"ClassB") != 0 && _wcsicmp(Class, L"ClassB.value") != 0)
		{
			if (_wcsicmp(Class, L"ClassC") != 0 && _wcsicmp(Class, L"ClassC.value") != 0)
			{
				if (_wcsicmp(Class, L"ClassD") != 0 && _wcsicmp(Class, L"ClassD.value") != 0)
				{
					if (_wcsicmp(Class, L"ClassE") != 0 && _wcsicmp(Class, L"ClassE.value") != 0)
					{
						if (_wcsicmp(Class, L"ClassF") != 0 && _wcsicmp(Class, L"ClassF.value") != 0)
						{
							if (_wcsicmp(Class, L"ClassG") != 0 && _wcsicmp(Class, L"ClassG.value") != 0)
							{
								return WBEM_E_INVALID_PARAMETER;
							}
							else
							{
								*pnClass = CLASS_G;
							}
						}
						else
						{
							*pnClass = CLASS_F;
						}
					}
					else
					{
						*pnClass = CLASS_E;
					}
				}
				else
				{
					*pnClass = CLASS_D;
				}
			}
			else
			{
				*pnClass = CLASS_C;
			}
		}
		else
		{
			*pnClass = CLASS_B;
		}
	}
	else
	{
		*pnClass = CLASS_A;
	}

	return WBEM_S_NO_ERROR;
}

HRESULT CStdProvider::InitializeRegInfo( void )
{
	HKEY	hKey = NULL;

	EnterCriticalSection( &m_cs );

	if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Software\\Microsoft\\WBEM\\instprov", 0L, KEY_READ, &hKey )
		== ERROR_SUCCESS )
	{

		DWORD	dwBuffSize = sizeof(int);
		RegQueryValueEx( hKey, "ClassALow", NULL, NULL, (LPBYTE) &CLASS_A_LOW, &dwBuffSize );

		dwBuffSize = sizeof(int);
		RegQueryValueEx( hKey, "ClassAHi", NULL, NULL, (LPBYTE) &CLASS_A_HI, &dwBuffSize );

		dwBuffSize = sizeof(int);
		RegQueryValueEx( hKey, "ClassBLow", NULL, NULL, (LPBYTE) &CLASS_B_LOW, &dwBuffSize );
		dwBuffSize = sizeof(int);
		RegQueryValueEx( hKey, "ClassBHi", NULL, NULL, (LPBYTE) &CLASS_B_HI, &dwBuffSize );

		dwBuffSize = sizeof(int);
		RegQueryValueEx( hKey, "ClassCLow", NULL, NULL, (LPBYTE) &CLASS_C_LOW, &dwBuffSize );
		dwBuffSize = sizeof(int);
		RegQueryValueEx( hKey, "ClassCHi", NULL, NULL, (LPBYTE) &CLASS_C_HI, &dwBuffSize );

		dwBuffSize = sizeof(int);
		RegQueryValueEx( hKey, "ClassDLow", NULL, NULL, (LPBYTE) &CLASS_D_LOW, &dwBuffSize );
		dwBuffSize = sizeof(int);
		RegQueryValueEx( hKey, "ClassDHi", NULL, NULL, (LPBYTE) &CLASS_D_HI, &dwBuffSize );

		dwBuffSize = sizeof(int);
		RegQueryValueEx( hKey, "ClassELow", NULL, NULL, (LPBYTE) &CLASS_E_LOW, &dwBuffSize );
		dwBuffSize = sizeof(int);
		RegQueryValueEx( hKey, "ClassEHi", NULL, NULL, (LPBYTE) &CLASS_E_HI, &dwBuffSize );

		dwBuffSize = sizeof(int);
		RegQueryValueEx( hKey, "ClassFLow", NULL, NULL, (LPBYTE) &CLASS_F_LOW, &dwBuffSize );
		dwBuffSize = sizeof(int);
		RegQueryValueEx( hKey, "ClassFHi", NULL, NULL, (LPBYTE) &CLASS_F_HI, &dwBuffSize );

		dwBuffSize = sizeof(int);
		RegQueryValueEx( hKey, "ClassGLow", NULL, NULL, (LPBYTE) &CLASS_G_LOW, &dwBuffSize );
		dwBuffSize = sizeof(int);
		RegQueryValueEx( hKey, "ClassGHi", NULL, NULL, (LPBYTE) &CLASS_G_HI, &dwBuffSize );

		dwBuffSize = sizeof(int);
		RegQueryValueEx( hKey, "ReverseOrder", NULL, NULL, (LPBYTE) &g_fReverseOrder, &dwBuffSize );

		dwBuffSize = sizeof(int);
		RegQueryValueEx( hKey, "BatchSize", NULL, NULL, (LPBYTE) &g_nBatchSize, &dwBuffSize );

		dwBuffSize = sizeof(int);
		RegQueryValueEx( hKey, "BatchDelay", NULL, NULL, (LPBYTE) &g_dwBatchDelay, &dwBuffSize );

		RegCloseKey( hKey );

		LeaveCriticalSection( &m_cs );

		return WBEM_S_NO_ERROR;
	}

	LeaveCriticalSection( &m_cs );

	return WBEM_E_FAILED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\objdbtest\stdafx.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// stdafx.cpp : source file that includes just the standard includes
//	ObjDbTest.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\objdbtest\objdbtest.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// ObjDbTest.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "ObjDbTestApp.h"

int main(int argc, char* argv[])
{
	CObjDbTestApp app;
	return app.Run();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\objinternalstest\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>

#define COREPOL_HEADERFILE_IS_INCLUDED

#define COREPROX_POLARITY __declspec( dllimport )
#define ESSLIB_POLARITY __declspec( dllimport )

#define COREPOL_HEADERFILE_IS_INCLUDED
#define POLARITY_HEADERFILE_IS_INCLUDED
#define POLARITY __declspec( dllimport )

#include "arena.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\mergertest\stdprov.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//***************************************************************************
//
//  STDPROV.H
//  
//  Test instance provider
//
//  raymcc      02-Dec-97       
//
//***************************************************************************

#ifndef _STDPROV_H_
#define _STDPROV_H_

#define CLASS_A 0
#define CLASS_B 1
#define CLASS_C 2
#define CLASS_D 3
#define CLASS_E 4
#define CLASS_F 5
#define CLASS_G 6

class CStdProvider : public IWbemServices, public IWbemProviderInit
{
    LONG m_lRef;
    IWbemClassObject *m_pClassDefA;
    IWbemClassObject *m_pClassDefB;
    IWbemClassObject *m_pClassDefC;
    IWbemClassObject *m_pClassDefD;
    IWbemClassObject *m_pClassDefE;
    IWbemClassObject *m_pClassDefF;
    IWbemClassObject *m_pClassDefG;
	CRITICAL_SECTION	m_cs;
        
public:
    CStdProvider();
   ~CStdProvider();

    // Interface members.
    // ==================

        ULONG STDMETHODCALLTYPE AddRef();
        ULONG STDMETHODCALLTYPE Release();
        STDMETHODIMP QueryInterface(REFIID riid, void** ppv);


        // IWbemProviderInit method.
        // =========================
            
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [unique][in] */ LPWSTR wszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR wszNamespace,
            /* [unique][in] */ LPWSTR wszLocale,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink
            );



        // IWbemServices methods.
        // ======================

        virtual HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult
            );
        
        virtual HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink
            );
        
        virtual HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler
            );
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            );
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );
        
        virtual HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            );
        
        virtual HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );
        
        virtual HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            );
        
        virtual HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );
        
        virtual HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            );
        
        virtual HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );
        
        virtual HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            );
        
        virtual HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );
        
        virtual HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            );
        
        virtual HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            );
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );
        
        virtual HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            );
        
        virtual HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );
        
        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            );
        
        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );
        
        virtual HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            );
        
        virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );
            

    // Private methods.
    // ================

    BOOL GetInstances(
		int nClass,
        IWbemObjectSink *pSink
        );

    BOOL GetInstance(
		IN	int nClass,
        IN  int nKey,
        OUT IWbemClassObject *pObj    
        );

	HRESULT GetClassConst( WCHAR* pwszClass, int* pnClass );

	HRESULT InitializeRegInfo( void );

};

void ObjectCreated();
void ObjectDestroyed();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\objdbtest\objdbtestapp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#ifndef __OBJDBTESTAPP_h__
#define __OBJDBTESTAPP_h__

class CObjDbTestApp
{
public:
	typedef enum { EnumUnknown,
		   EnumCreateNamespaces,
		   EnumCreateClasses,
		   EnumCreateInstances, 
		   EnumGetInstances,
		   EnumQueryInstances,
		   EnumDeleteNamespaces,
		   EnumDeleteClasses,
		   EnumDeleteInstances,
		   EnumGetDanglingRefs,
		   EnumGetSchemaDanglingRefs,
		   EnumMMFTest,
		   EnumLastValidOption,
		   EnumChangeOptions = 50,
		   EnumFinished = 99
	} EnumUserChoice;

private:

protected:
	CObjectDatabase *m_pObjDb;
	bool m_deriveClasses;
	int m_numClasses;
	int m_numProperties;
	int m_numInstances;
	wchar_t *m_className;
	int m_numNamespaces;
	bool m_nestedNamespaces;

	int PrintMenu();
	EnumUserChoice GetChoice();

	int FormatString(wchar_t *wszTarget, int nTargetSize, const char *szFormat, const wchar_t *wszFirstString, int nNumber);

	int CreateInstances();
	int CreateClasses();
	int CreateNamespaces();
	int GetInstances();
	int QueryInstances();
	int DeleteInstances();
	int DeleteClasses();
	int DeleteNamespaces();
	int GetDanglingRefs();
	int GetSchemaDanglingRefs();
	int ChangeOptions();
	int MMFTest();
	void PrintProgress(int nCurrent, int nMax);

public:
	int Run();
};

#endif //__OBJDBTESTAPP_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\objdbtest\objdbtestapp.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "StdAfx.h"
#include "ObjDbTestApp.h"
#include "ObjDbTestSinks.h"

void ObjectCreated(unsigned long) {}
void ObjectDestroyed(unsigned long) {}
long __stdcall CBasicObjectSink::QueryInterface(struct _GUID const &,void * *) { return 0;}
unsigned long __stdcall CObjectSink::Release(void) { return 0;}
unsigned long __stdcall CObjectSink::AddRef(void) { return 0; }

int CObjDbTestApp::Run()
{
	m_deriveClasses = false;
	m_numClasses = 1000;
	m_numProperties = 1;
	m_numInstances = 1000;
	m_numNamespaces = 10;
	m_nestedNamespaces = true;
	m_className = new wchar_t[wcslen(L"test") + 1];
	wcscpy(m_className, L"test");

	m_pObjDb = new CObjectDatabase();
	if (m_pObjDb->Open() != CObjectDatabase::no_error)
	{
		printf("Failed to open the database... exiting...");
		return -1;
	}

	EnumUserChoice nChoice = EnumUnknown;

	while (nChoice != EnumFinished)
	{
		PrintMenu();
		do
		{
			nChoice = GetChoice();
		} while (nChoice == EnumUnknown);

		switch (nChoice)
		{
		case EnumCreateInstances:
			CreateInstances();
			break;
		case EnumCreateClasses:
			CreateClasses();
			break;
		case EnumCreateNamespaces:
			CreateNamespaces();
			break;
		case EnumGetInstances:
			GetInstances();
			break;
		case EnumQueryInstances:
			QueryInstances();
			break;
		case EnumDeleteInstances:
			DeleteInstances();
			break;
		case EnumDeleteClasses:
			DeleteClasses();
			break;
		case EnumDeleteNamespaces:
			DeleteNamespaces();
			break;
		case EnumGetDanglingRefs:
			GetDanglingRefs();
			break;
		case EnumGetSchemaDanglingRefs:
			GetSchemaDanglingRefs();
			break;
		case EnumMMFTest:
			MMFTest();
			break;
		case EnumChangeOptions:
			ChangeOptions();
			break;
		case EnumFinished:
			printf("Quitting...\n");
			break;
		default:
			continue;
		}
	}

	m_pObjDb->Shutdown();
	delete m_pObjDb;
	delete [] m_className;

	return 0;
}

int CObjDbTestApp::PrintMenu()
{
	printf("\n\nWinMgmt database test application.\n"
		   "Please select from the following options:\n"
		   " 1. Create Namespaces\n"
		   " 2. Create Classes\n"
		   " 3. Create Instances\n"
		   " 4. Get Instances\n"
		   " 5. Query Instances\n"
		   " 6. Delete Namespaces\n"
		   " 7. Delete Classes\n"
		   " 8. Delete Instances\n"
		   " 9. Get Dangling References\n"
		   "10. Get Schema Dangling References\n"
		   "11. Database deletion test\n"
		   "50. Change options\n"
		   "99. Quit\n");
	return 0;
}

CObjDbTestApp::EnumUserChoice CObjDbTestApp::GetChoice()
{
	EnumUserChoice nChoice = EnumUnknown;
	if (scanf("%hd", &nChoice) == 0)
	{
		//We have an error value...
		char ch;
		scanf("%c", &ch);
	}
	return nChoice;
}

int CObjDbTestApp::CreateClasses()
{
	VARIANT var;
	UINT dwNumBaseClasses = (m_deriveClasses?1:m_numClasses), dwNumDerivedClasses = (m_deriveClasses?m_numClasses: 0);
	bool bError = false;
	wchar_t wszPropName[50];
	wchar_t szClassName[200];
	printf("Creating class... please wait...\n");

	DWORD dwStartTicks = GetTickCount();

	CObjDbNS *pNs;
	if (m_pObjDb->GetNamespace(L"root\\default", &pNs) != CObjectDatabase::no_error)
		printf("Canot get root\\default namespace!\n");


	for (UINT nClassLoop = 0; nClassLoop != dwNumBaseClasses; nClassLoop++)
	{
		PrintProgress(nClassLoop, dwNumBaseClasses);
		FormatString(szClassName, 200, "%S_%u", m_className, nClassLoop);
		CWbemClass *pObj = new CWbemClass;
		pObj->InitEmpty();
		CVar varType;
		VariantInit(&var);
		V_VT(&var) = VT_BSTR;
		V_BSTR(&var) = SysAllocString(szClassName);
		if (pObj->Put(L"__class", 0, &var, CIM_STRING) != WBEM_NO_ERROR)
			printf("\nCannot put class name!");
		VariantClear(&var);
		V_VT(&var) = VT_NULL;
		if (pObj->Put(L"key", 0, &var, CIM_STRING) != WBEM_NO_ERROR)
			printf("\nCannot put key property!");

		IWbemQualifierSet* pQualifierSet = 0;
		if (pObj->GetPropertyQualifierSet(L"key", &pQualifierSet) != WBEM_NO_ERROR)
			printf("\nCannot get qualifier set on key!");

		V_VT(&var) = VT_BOOL;
		V_BOOL(&var) = TRUE;
		if (pQualifierSet->Put(L"key", &var, 0) != WBEM_NO_ERROR)
			printf("\nFailed to set key qualifier!");

		pQualifierSet->Release();

		//Add any additional prop - STARTS AT 1 BECAUSE WE ALREADY HAVE 1!!!
		V_VT(&var) = VT_NULL;
		for (UINT i = 1; i != m_numProperties; i++)
		{
			FormatString(wszPropName, 50, "%S%u", L"prop_0_", i);
			
			if (pObj->Put(wszPropName, 0, &var, CIM_STRING) != WBEM_NO_ERROR)
				printf("\nCannot put property!");

		}

		if (m_pObjDb->CreateObject(pNs, pObj, CObjectDatabase::flag_class) != CObjectDatabase::no_error)
			printf("\nCannot store class object!");
		delete pObj;
	}
	//Now do the derived classes... - STARTS AT 1 BECAUSE WE HAVE THE BASE CLASS!!!
	CWbemObject *pCurClass = 0;
	IWbemClassObject *pDerClass = 0;
	for (UINT numDerivedClass = 0; numDerivedClass != dwNumDerivedClasses; numDerivedClass++)
	{
		PrintProgress(numDerivedClass, dwNumDerivedClasses);
		FormatString(szClassName, 200, "%S_%u", m_className, numDerivedClass);
		if (m_pObjDb->GetObjectByPath(pNs, szClassName, &pCurClass) != CObjectDatabase::no_error)
		{
			printf("\nCannot get newly created parent class!");
			break;
		}

		if (pCurClass->SpawnDerivedClass(0, &pDerClass) != WBEM_NO_ERROR)
		{
			printf("\nFailed to spawn derived class!");
			pCurClass->Release();
			break;
		}
		pCurClass->Release();

		FormatString(szClassName, 200, "%S_%u", m_className, numDerivedClass+1);
		V_VT(&var) = VT_BSTR;
		V_BSTR(&var) = SysAllocString(szClassName);
		if (pDerClass->Put(L"__class", 0, &var, CIM_STRING) != WBEM_NO_ERROR)
			printf("Canot put class name!\n");
		VariantClear(&var);

		V_VT(&var) = VT_NULL;

		for (UINT j = 0; j != m_numProperties; j++)
		{
			FormatString(wszPropName, 50, "%S_%u", L"prop", numDerivedClass+1);
			FormatString(wszPropName, 50, "%S_%u", wszPropName, j);
			
			if (pDerClass->Put(wszPropName, 0, &var, CIM_STRING) != WBEM_NO_ERROR)
			{
				printf("\nCannot put property!");
				bError = true;
				break;
			}

		}
		if (m_pObjDb->CreateObject(pNs, (CWbemClass*)pDerClass, CObjectDatabase::flag_class) != CObjectDatabase::no_error)
			printf("\nCannot store derived class object!");

		pDerClass->Release();

		if (bError)
			break;
	}

	m_pObjDb->CloseNamespace(pNs);

	DWORD dwEndTicks = GetTickCount();
	printf("\nTime taken to create %u classes is %lu milliseconds.\r\n"
		   "That's %d milliseconds per object.\n", 
		   m_numClasses, dwEndTicks - dwStartTicks, (dwEndTicks - dwStartTicks)/m_numClasses);
	
	return 0;
}

int CObjDbTestApp::CreateInstances()
{
	printf("Creating %u instances... please wait...\n", m_numInstances);

	DWORD dwStartTicks = GetTickCount();

	CObjDbNS *pNs;
	if (m_pObjDb->GetNamespace(L"root\\default", &pNs) != CObjectDatabase::no_error)
	{
		printf("Cannot get root\\default namespace!\n");
		return 0;
	}

	wchar_t szClassName[200];
	if (m_deriveClasses)
	{
		FormatString(szClassName, 200, "%S_%u", m_className, m_numClasses);
	}
	else
	{
		wcscpy(szClassName, m_className);
		wcscat(szClassName, L"_0");
	}

	CWbemObject *pObj = NULL;
	if (m_pObjDb->GetObjectByPath(pNs, szClassName, &pObj) != CObjectDatabase::no_error)
	{
		printf("Cannot get class object!\n");
		m_pObjDb->CloseNamespace(pNs);
		return 0;
	}
		
	CWbemClass *pClassObj = (CWbemClass*) pObj;

	wchar_t wszKey[20];
	for (UINT i = 0; i != m_numInstances; i++)
	{
		PrintProgress(i, m_numInstances);
		FormatString(wszKey, 20, "%S%u", L"", i);

		IWbemClassObject *iObj = 0;
		if (pClassObj->SpawnInstance(0, &iObj) != WBEM_NO_ERROR)
		{
			printf("\nCannot spawn instance object!");
			break;
		}

		CWbemInstance *pInstObj = (CWbemInstance*)iObj;

		VARIANT var;
		VariantInit(&var);
		V_VT(&var) = VT_BSTR;
		V_BSTR(&var) = SysAllocString(wszKey);
		pInstObj->Put(L"key", 0, &var, CIM_STRING);
		VariantClear(&var);

		if (m_pObjDb->CreateObject(pNs, pInstObj, CObjectDatabase::flag_instance) != CObjectDatabase::no_error)
		{
			printf("\nCannot store instance object!");
			iObj->Release();
			break;
		}

		iObj->Release();
	}

	delete pClassObj;

	m_pObjDb->CloseNamespace(pNs);

	DWORD dwEndTicks = GetTickCount();
	printf("\nTime taken to create %u instances is %lu milliseconds.\r\n"
		   "That's %d milliseconds per object.\n", 
		   m_numInstances, dwEndTicks - dwStartTicks, (dwEndTicks - dwStartTicks)/m_numInstances);
	return 0;
}

int CObjDbTestApp::CreateNamespaces()
{
	printf("Creating %u namespaces... please wait...\n", m_numNamespaces);

	DWORD dwStartTicks = GetTickCount();

	wchar_t *wszCurNamespace = new wchar_t[wcslen(L"root\\default") + 1];
	wcscpy(wszCurNamespace, L"root\\default");

	CObjDbNS *pNs;
	if (m_pObjDb->GetNamespace(L"root\\default", &pNs) != CObjectDatabase::no_error)
	{
		printf("Cannot get root\\default namespace!\n");
		return 0;
	}

	wchar_t szClassName[200];
	wcscpy(szClassName, L"__namespace");

	CWbemObject *pObj = NULL;
	if (m_pObjDb->GetObjectByPath(pNs, szClassName, &pObj) != CObjectDatabase::no_error)
	{
		printf("Cannot get namespace object!\n");
		m_pObjDb->CloseNamespace(pNs);
		return 0;
	}
		
	CWbemClass *pClassObj = (CWbemClass*) pObj;

	wchar_t wszKey[20];
	wcscpy(wszKey, L"TestNamespace_0");
	for (UINT i = 0; i != m_numNamespaces; i++)
	{
		PrintProgress(i, m_numNamespaces);
		if (!m_nestedNamespaces)
		{
			FormatString(wszKey, 20, "%S_%u", L"TestNamespace", i);
		}

		IWbemClassObject *iObj = 0;
		if (pClassObj->SpawnInstance(0, &iObj) != WBEM_NO_ERROR)
		{
			printf("\nCannot spawn instance of namespace object!");
			break;
		}

		CWbemInstance *pInstObj = (CWbemInstance*)iObj;

		VARIANT var;
		VariantInit(&var);
		V_VT(&var) = VT_BSTR;
		V_BSTR(&var) = SysAllocString(wszKey);
		pInstObj->Put(L"name", 0, &var, CIM_STRING);
		VariantClear(&var);

		if (m_pObjDb->AddNamespace(pNs, wszKey, pInstObj) != CObjectDatabase::no_error)
		{
			printf("\nCannot create namespace namespace object!");
			iObj->Release();
			break;
		}

		iObj->Release();

		if (m_nestedNamespaces)
		{
			wchar_t *wszTmpNamespace = new wchar_t[wcslen(wszCurNamespace) + wcslen(L"\\") + wcslen(wszKey) + 1];
			wcscpy(wszTmpNamespace, wszCurNamespace);
			wcscat(wszTmpNamespace, L"\\");
			wcscat(wszTmpNamespace, wszKey);
			delete [] wszCurNamespace;
			wszCurNamespace = wszTmpNamespace;
			m_pObjDb->CloseNamespace(pNs);
			if (m_pObjDb->GetNamespace(wszCurNamespace, &pNs) != CObjectDatabase::no_error)
			{
				printf("\nCannot open newly created namespace!");
				break;
			}
		}
	}

	delete pClassObj;
	delete [] wszCurNamespace;

	if (pNs)
		m_pObjDb->CloseNamespace(pNs);

	DWORD dwEndTicks = GetTickCount();
	printf("\nTime taken to create %u instances is %lu milliseconds.\r\n"
		   "That's %d milliseconds per object.\n", 
		   m_numInstances, dwEndTicks - dwStartTicks, (dwEndTicks - dwStartTicks)/m_numInstances);
	return 0;
}
int CObjDbTestApp::GetInstances()
{
	printf("Getting instances... please wait...\n");

	DWORD dwStartTicks = GetTickCount();
	CObjDbNS *pNs;
	if (m_pObjDb->GetNamespace(L"root\\default", &pNs) != CObjectDatabase::no_error)
		printf("Cannot get root\\default namespace!\n");

	wchar_t szClassName[200];
	if (m_deriveClasses)
	{
		FormatString(szClassName, 200, "%S_%u", m_className, m_numClasses);
	}
	else
	{
		wcscpy(szClassName, m_className);
		wcscat(szClassName, L"_0");
	}
	for (UINT i = 0; i != m_numInstances; i++)
	{
		PrintProgress(i, m_numInstances);
		wchar_t wszKey[50];
		FormatString(wszKey, 50, "%S=%u", szClassName, i);

		CWbemObject *pObj = NULL;
		if (m_pObjDb->GetObjectByPath(pNs, wszKey, &pObj) != CObjectDatabase::no_error)
		{
			printf("\nCannot get instance object: %S!", wszKey);
			break;
		}
		pObj->Release();

	}	

	m_pObjDb->CloseNamespace(pNs);

	DWORD dwEndTicks = GetTickCount();
	printf("\nTime taken to get %u instances is %lu milliseconds.\r\n"
		   "That's %d milliseconds per object.\n", 
		    m_numInstances, dwEndTicks - dwStartTicks, (dwEndTicks - dwStartTicks)/m_numInstances);
	return 0;
}

int CObjDbTestApp::QueryInstances()
{
	printf("Table-scan query instances... please wait...\n");

	DWORD dwStartTicks = GetTickCount();
	CObjDbNS *pNs;
	if (m_pObjDb->GetNamespace(L"root\\default", &pNs) != CObjectDatabase::no_error)
		printf("Cannot get root\\default namespace!\n");

	wchar_t szClassName[200];
	if (m_deriveClasses)
	{
		FormatString(szClassName, 200, "%S_%u", m_className, m_numClasses);
	}
	else
	{
		wcscpy(szClassName, m_className);
		wcscat(szClassName, L"_0");
	}

	CQuerySink *pSink = new CQuerySink;
	if (m_pObjDb->QlTableScanQuery(pNs, szClassName, 0, 0, pSink) != CObjectDatabase::no_error)
	{
		printf("Cannot table-scan query instance objects!\n");
	}

	m_pObjDb->CloseNamespace(pNs);

	DWORD dwEndTicks = GetTickCount();
	int nCount = pSink->ReturnCount();
	if (nCount == 0)
		nCount = 1;

	printf("Time taken to query %lu instances is %lu milliseconds.\r\n"
		   "That's %d milliseconds per object.\n", 
		    nCount, dwEndTicks - dwStartTicks, (dwEndTicks - dwStartTicks)/nCount);
	delete pSink;
	return 0;
}
int CObjDbTestApp::DeleteInstances()
{
	printf("Deleting instances... please wait...\n");

	DWORD dwStartTicks = GetTickCount();
	CObjDbNS *pNs;
	if (m_pObjDb->GetNamespace(L"root\\default", &pNs) != CObjectDatabase::no_error)
		printf("Cannot get root\\default namespace!\n");

	wchar_t szClassName[200];
	if (m_deriveClasses)
	{
		FormatString(szClassName, 200, "%S_%u", m_className, m_numClasses);
	}
	else
	{
		wcscpy(szClassName, m_className);
		wcscat(szClassName, L"_0");
	}
	for (UINT i = 0; i != m_numInstances; i++)
	{
		PrintProgress(i, m_numInstances);
		wchar_t wszKey[50];
		FormatString(wszKey, 50, "%S=%u", szClassName, i);

		if (m_pObjDb->DeleteObject(pNs, wszKey) != CObjectDatabase::no_error)
		{
			printf("\nCannot delete instance object %S!", wszKey);
			break;
		}
	}	

	m_pObjDb->CloseNamespace(pNs);

	DWORD dwEndTicks = GetTickCount();
	printf("\nTime taken to delete %u instances is %lu milliseconds.\r\n"
		   "That's %d milliseconds per object.\n", 
		    m_numInstances, dwEndTicks - dwStartTicks, (dwEndTicks - dwStartTicks)/m_numInstances);
	return 0;
}
int CObjDbTestApp::DeleteClasses()
{
	wchar_t szClassName[200];
	printf("Deleting class... please wait...\n");

	UINT dwNumBaseClasses = (m_deriveClasses?1:m_numClasses);

	DWORD dwStartTicks = GetTickCount();
	CObjDbNS *pNs;
	if (m_pObjDb->GetNamespace(L"root\\default", &pNs) != CObjectDatabase::no_error)
		printf("Cannot get root\\default namespace!\n");

	for (UINT i = 0; i != dwNumBaseClasses; i++)
	{
		PrintProgress(i, dwNumBaseClasses);
		FormatString(szClassName, 200, "%S_%u", m_className, i);

		if (m_pObjDb->DeleteObject(pNs, szClassName) != CObjectDatabase::no_error)
		{
			printf("\nCannot delete class, %S!", szClassName);
			break;
		}
	}

	m_pObjDb->CloseNamespace(pNs);

	DWORD dwEndTicks = GetTickCount();
	if (m_deriveClasses)
	{
		printf("\nTime taken to delete 1 base class with %u derived classes is %lu milliseconds.\r\n",
				(m_numClasses-1), dwEndTicks - dwStartTicks);
	}
	else
	{
		printf("\nTime taken to delete %u classes is %lu milliseconds.\r\n"
			   "That's %d milliseconds per object.\n", 
			   dwNumBaseClasses, dwEndTicks - dwStartTicks, (dwEndTicks - dwStartTicks)/dwNumBaseClasses);
	}
	return 0;
}

int CObjDbTestApp::DeleteNamespaces()
{
	wchar_t szNamespaceName[200];
	wchar_t szNamespacePath[200];
	printf("Deleting namespaces... please wait...\n");

	UINT dwNumBaseClasses = (m_nestedNamespaces?1:m_numNamespaces);

	DWORD dwStartTicks = GetTickCount();
	CObjDbNS *pNs;
	if (m_pObjDb->GetNamespace(L"root\\default", &pNs) != CObjectDatabase::no_error)
		printf("Cannot get root\\default namespace!\n");

	for (UINT i = 0; i != dwNumBaseClasses; i++)
	{
		PrintProgress(i, dwNumBaseClasses);
		FormatString(szNamespaceName, 200, "%S_%u", L"TestNamespace", i);
		FormatString(szNamespacePath, 200, "%S%u\"", L"__namespace=\"TestNamespace_", i);

		if (m_pObjDb->RemoveNamespace(pNs, szNamespaceName, szNamespacePath) != CObjectDatabase::no_error)
		{
			printf("\nCannot delete namespace %S!", szNamespaceName);
			break;
		}
	}

	m_pObjDb->CloseNamespace(pNs);

	DWORD dwEndTicks = GetTickCount();
	if (m_nestedNamespaces)
	{
		printf("\nTime taken to delete 1 base namespace with %u nested namespaces is %lu milliseconds.\r\n",
				(m_numNamespaces-1), dwEndTicks - dwStartTicks);
	}
	else
	{
		printf("\nTime taken to delete %u namespaces is %lu milliseconds.\r\n"
			   "That's %d milliseconds per object.\n", 
			   dwNumBaseClasses, dwEndTicks - dwStartTicks, (dwEndTicks - dwStartTicks)/dwNumBaseClasses);
	}
	return 0;
}

int CObjDbTestApp::GetDanglingRefs()
{
	CDangRefSink* sink = new CDangRefSink;
	m_pObjDb->QueryDanglingRefs(sink);

	printf("The following classes have references to \r\ntargets which do not exist: \r\n%S\n",
		    sink->classNames);
	delete sink;
	return 0;
}
int CObjDbTestApp::GetSchemaDanglingRefs()
{
	CDangRefSink* sink = new CDangRefSink;
	m_pObjDb->QuerySchemaDanglingRefs(sink);
	
	printf("The following classes have references to \r\ntargets which do not exist: \r\n%S\n",
		    sink->classNames);
	delete sink;
	return 0;
}
int CObjDbTestApp::ChangeOptions()
{
	printf("Number of properties [%d]: ", m_numProperties);
	scanf("%d", &m_numProperties);
	printf("Number of instances [%d]: ", m_numInstances);
	scanf("%d", &m_numInstances);
	printf("Number of classes [%d]: ", m_numClasses);
	scanf("%d", &m_numClasses);
	printf("Create classes as derived classes [%d]: ", m_deriveClasses);
	scanf("%d", &m_deriveClasses);
	printf("Number of namespaces [%d]: ", m_numNamespaces);
	scanf("%d", &m_numNamespaces);
	printf("Create namespaces nested namespaces [%d]: ", m_nestedNamespaces);
	scanf("%d", &m_nestedNamespaces);
	return 0;
};

int CObjDbTestApp::MMFTest()
{
	m_pObjDb->Shutdown();
	delete m_pObjDb;
	
	//Delete the database...
	if (DeleteFile("c:\\windows\\system\\wbem\\repository\\$WinMgmt.CFG") == 0)
	{
		printf("Failed to delete $WinMgmt.CFG!  Win32 Last Error = %ld", GetLastError());
	}
	else
	{
		if (DeleteFile("c:\\windows\\system\\wbem\\repository\\cim.rep") == 0)
		{
			printf("Failed to delete cim.rep!  Win32 Last Error = %ld", GetLastError());
		}
	}


	m_pObjDb = new CObjectDatabase();
	if (m_pObjDb->Open() != CObjectDatabase::no_error)
	{
		printf("Failed to open the database... exiting...\n");
		return -1;
	}
	else
	{
		printf("Done!\n");
	}
	return 0;
}

int CObjDbTestApp::FormatString(wchar_t *wszTarget, int nTargetSize, const char *szFormat, const wchar_t *wszFirstString, int nNumber)
{
	char *buff = new char[nTargetSize];
	sprintf(buff, szFormat, wszFirstString, nNumber);
	mbstowcs(wszTarget, buff, nTargetSize);
	delete buff;
	return 0;
}

void CObjDbTestApp::PrintProgress(int nCurrent, int nMax)
{
	int nCurPercentage = (nCurrent * 100) / nMax;
	printf("\r%d of %d (%d%%)", nCurrent, nMax, nCurPercentage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\objdbtest\stdafx.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__61D54019_D82F_11D2_85E6_00105A1F8304__INCLUDED_)
#define AFX_STDAFX_H__61D54019_D82F_11D2_85E6_00105A1F8304__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <stdio.h>
#include <windows.h>
class WString;
class CWbemObject;
class CWbemClass;
#define NEWOBJECT
class CDestination;
class CVar;
class CFlexArray;
class CWStringArray;
class CLock;
struct QL_LEVEL_1_RPN_EXPRESSION;
class CWbemNamespace;
#include "WbemCli.h"
#include "WbemUtil.h"
#include "objdb.h"
#include "DbRep.h"
#include "FastAll.h"
#include "Sinks.h"
#include "mmfarena2.h"
#include "DbArry.h"
#include "DbAvl.h"


// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__61D54019_D82F_11D2_85E6_00105A1F8304__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\perfsrv\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/


#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( perfsrvidl )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( perfsrvidl ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\pdh\strings.c ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/
/*
    String constants used by the functions in the PDH.DLL library
*/
#include <windows.h>
#include "strings.h"

LPCWSTR    cszAppShortName = (LPCWSTR)L"PDH";

// registry path, key and value strings
LPCWSTR    cszNamesKey = 
    (LPCWSTR)L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
LPCWSTR    cszDefaultLangId = (LPCWSTR)L"009";
LPCWSTR    cszCounters = (LPCWSTR)L"Counters";
LPCWSTR    cszHelp = (LPCWSTR)L"Help";
LPCWSTR    cszLastHelp = (LPCWSTR)L"Last Help";
LPCWSTR    cszLastCounter = (LPCWSTR)L"Last Counter";
LPCWSTR    cszVersionName = (LPCWSTR)L"Version";
LPCWSTR    cszCounterName = (LPCWSTR)L"Counter ";
LPCWSTR    cszHelpName = (LPCWSTR)L"Explain ";
LPCWSTR    cszGlobal = (LPCWSTR)L"Global";
LPCWSTR    cszCostly = (LPCWSTR)L"Costly";
LPCWSTR    cszLogQueries = (LPCWSTR)L"SYSTEM\\CurrentControlSet\\Services\\PerfDataLog\\Log Queries";
LPCWSTR    cszLogFileType = (LPCWSTR)L"Log File Type";
LPCWSTR    cszAutoNameInterval = (LPCWSTR)L"Auto Name Interval";
LPCWSTR    cszLogFileName = (LPCWSTR)L"Log Filename";
LPCWSTR    cszLogDefaultDir = (LPCWSTR)L"Log Default Directory";
LPCWSTR    cszBaseFileName = (LPCWSTR)L"Base Filename";
LPCWSTR    cszLogFileAutoFormat = (LPCWSTR)L"Log File Auto Format";
LPCWSTR    cszAutoRenameUnits = (LPCWSTR)L"Auto Rename Units";
LPCWSTR    cszCommandFile = (LPCWSTR)L"Command File";
LPCWSTR    cszCounterList = (LPCWSTR)L"Counter List";
LPCSTR     caszCounterList = "Counter List";
LPCWSTR    cszPerfDataLog = (LPCWSTR)L"PerfDataLog";
LPCWSTR    cszDefault = (LPCWSTR)L"Default";
LPCSTR     caszDefaultLogCaption = "User Data";
LPCWSTR    cszPerfNamePathPrefix = (LPCWSTR)L"%systemroot%\\system32\\perf";
LPCWSTR    cszDat = (LPCWSTR)L".dat";
LPCWSTR    cszWBEM = (LPCWSTR)L"WBEM:";
LPCSTR     caszWBEM = "WBEM:";
LPCWSTR    cszWbemDefaultPerfRoot = (LPCWSTR)L"\\root\\cimv2";
LPCWSTR    cszSingletonInstance = (LPCWSTR)L"=@";
LPCWSTR    cszNameParam = (LPCWSTR)L".Name=\"";
LPCWSTR    cszCountertype = (LPCWSTR)L"countertype";
LPCWSTR    cszDisplayname = (LPCWSTR)L"displayname";
LPCWSTR    cszDefaultscale = (LPCWSTR)L"defaultscale";
LPCWSTR    cszSingleton = (LPCWSTR)L"singleton";
LPCWSTR    cszPerfdetail = (LPCWSTR)L"perfdetail";
LPCWSTR    cszPerfdefault = (LPCWSTR)L"perfdefault";
LPCWSTR    cszClass = (LPCWSTR)L"__CLASS";
LPCWSTR    cszPerfRawData = (LPCWSTR)L"Win32_PerfRawData";
LPCWSTR    cszNotFound = (LPCWSTR)L"Not Found";
LPCWSTR    cszName = (LPCWSTR)L"Name";
LPCWSTR    cszBaseSuffix = (LPCWSTR)L"_Base";
LPCWSTR    cszTimestampPerfTime    = (LPCWSTR)L"Timestamp_PerfTime";
LPCWSTR    cszFrequencyPerfTime    = (LPCWSTR)L"Frequency_PerfTime";
LPCWSTR    cszTimestampSys100Ns    = (LPCWSTR)L"Timestamp_Sys100NS";
LPCWSTR    cszFrequencySys100Ns    = (LPCWSTR)L"Frequency_Sys100NS";
LPCWSTR    cszTimestampObject      = (LPCWSTR)L"Timestamp_Object";
LPCWSTR    cszFrequencyObject      = (LPCWSTR)L"Frequency_Object";
LPCWSTR    cszPerfmonLogSig        = (LPCWSTR)L"Loges";

LPCWSTR    cszRemoteMachineRetryTime    = (LPCWSTR)L"Remote Reconnection Retry Time";
LPCWSTR    cszEnableRemotePdhAccess     = (LPCWSTR)L"Enable Remote PDH Access";
LPCWSTR    cszEnableRemotePdhServer     = (LPCWSTR)L"Enable Remote PDH Server";
LPCWSTR    cszRemotePdhServiceInactivityTimeout = (LPCWSTR)L"Remote Pdh Service Inactivity Timeout";
LPCWSTR    cszPdhKey                    = (LPCWSTR)L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\PDH";
LPCWSTR    cszDefaultNullDataSource     = (LPCWSTR)L"DefaultNullDataSource";
LPCWSTR    cszLogSectionName            = (LPCWSTR)L"SYSMON_LOG_READONLY_";
LPCWSTR    cszCurrentVersionKey         = (LPCWSTR)L"Software\\Microsoft\\Windows NT\\CurrentVersion";
LPCWSTR    cszCurrentVersionValueName   = (LPCWSTR)L"CurrentVersion";
LPCWSTR    cszRpdhServiceName           = (LPCWSTR)L"RemotePerfData";
LPCSTR     caszRpdhServiceName          = (LPCSTR)"RemotePerfData";
LPCWSTR    cszRpdhKeyName               = (LPCWSTR)L"SYSTEM\\CurrentControlSet\\Services\\RemotePerfData";
LPCWSTR    cszRpdhServiceDescription    = (LPCWSTR)L"Remote Performance Data Server";
LPCWSTR    cszRpdhServiceText           = (LPCWSTR)L"Processes requests for system performance data from remote computers.";

LPCWSTR    fmtDecimal = (LPCWSTR)L"%d";
LPCWSTR    fmtSpaceDecimal = (LPCWSTR)L" %d";
LPCWSTR    fmtLangId = (LPCWSTR)L"%3.3x";

// single character strings
LPCWSTR    cszEmptyString = (LPCWSTR)L"";
LPCWSTR    cszPoundSign = (LPCWSTR)L"#";
LPCWSTR    cszSplat = (LPCWSTR)L"*";
LPCWSTR    cszSlash = (LPCWSTR)L"/";
LPCWSTR    cszBackSlash = (LPCWSTR)L"\\";
LPCWSTR    cszLeftParen = (LPCWSTR)L"(";
LPCWSTR    cszRightParen = (LPCWSTR)L")";
LPCWSTR    cszC = (LPCWSTR)L"C";
LPCWSTR    cszH = (LPCWSTR)L"H";
LPCWSTR    cszColon = (LPCWSTR)L":";
LPCWSTR    cszDoubleQuote = (LPCWSTR)L"\"";
LPCWSTR	   cszAtSign = (LPCWSTR)L"@";

LPCSTR     caszPoundSign = "#";
LPCSTR     caszSplat = "*";
LPCSTR     caszSlash = "/";
LPCSTR     caszBackSlash = "\\";
LPCSTR     caszDoubleBackSlash = "\\\\";
LPCSTR     caszLeftParen = "(";
LPCSTR     caszRightParen = ")";
LPCSTR     caszSpace = " ";
LPCSTR     caszColon = ":";

LPCWSTR    cszDoubleBackSlash = (LPCWSTR)L"\\\\";
LPCWSTR    cszDoubleBackSlashDot = (LPCWSTR)L"\\\\.";
LPCWSTR    cszRightParenBackSlash = (LPCWSTR)L")\\";

// other general strings
LPCWSTR    cszSpacer = (LPCWSTR)L" - ";
LPCWSTR    cszBlg = (LPCWSTR)L"blg";

// strings only used in DEBUG builds
#ifdef _DEBUG
LPCWSTR    cszNameDontMatch = (LPCWSTR)L"Last Machine Name does not match the current selection";
LPCWSTR    cszNotice = (LPCWSTR)L"Notice!";
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\objinternalstest\objinternalstest.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// OBJINTERNALSTESTDlg.cpp : implementation file
//

//#define _WIN32_WINNT 0x0400

#include "precomp.h"
//#include <objbase.h>
#include <stdio.h>
#include <fastall.h>
#include <wbemcli.h>
#include <wbemint.h>

#define	CLASS_PROPERTY_NAME	L"__CLASS"
#define TEST_PROPERTY1_NAME	L"PROPERTY1"
#define TEST_PROPERTY2_NAME	L"PROPERTY2"
#define TEST_PROPERTY3_NAME	L"PROPERTY3"

#define	CLASS_PROPERTY_VALUE	L"TESTCLASSNAME"
#define TEST_PROPERTY1_VALUE	L"TESTPROPERTYVALUE1"
#define TEST_PROPERTY2_VALUE	L"TESTPROPERTYVALUE2"
#define TEST_PROPERTY3_VALUE	L"TESTPROPERTYVALUE3"

///////////////////////////////////////////////////////////////////
//
//	Function:	PutStringValue
//
//	Assigns a value to a property of type CIM_STRING.
//
///////////////////////////////////////////////////////////////////

HRESULT PutStringValue( IWbemClassObject* pObj, LPCWSTR Property, LPCWSTR Value )
{
	HRESULT	hr = WBEM_E_OUT_OF_MEMORY;

	BSTR		bstrClass = SysAllocString( Property );
	VARIANT		v;

	VariantInit( &v );

	v.vt = VT_BSTR;
	v.bstrVal = SysAllocString( Value );

	hr = pObj->Put( bstrClass, 0, &v, NULL );

	VariantClear( &v );

	SysFreeString( bstrClass );

	return hr;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	AddStringProperty
//
//	Adds a property of type CIM_STRING to the supplied object.
//
///////////////////////////////////////////////////////////////////

HRESULT AddStringProperty( IWbemClassObject* pObj, LPCWSTR Property )
{
	HRESULT	hr = WBEM_E_OUT_OF_MEMORY;

	BSTR		bstrProperty = SysAllocString( Property );

	// No variant needed for this
	hr = pObj->Put( bstrProperty, 0, NULL, CIM_STRING );

	SysFreeString( bstrProperty );

	return hr;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	GetStringProperty
//
//	Retrieves a property of type CIM_STRING from the supplied object.
//
///////////////////////////////////////////////////////////////////

HRESULT GetStringProperty( IWbemClassObject* pObj, LPCWSTR Property, BSTR* pbstrValue )
{
	HRESULT	hr = WBEM_E_OUT_OF_MEMORY;

	BSTR		bstrProperty = SysAllocString( Property );

	VARIANT		v;
	CIMTYPE		type;

	// Get the value and verify it's a CIM_STRING
	hr = pObj->Get( bstrProperty, 0, &v, &type, NULL );

	if ( SUCCEEDED( hr ) )
	{
		if ( CIM_STRING == type && VT_BSTR == v.vt )
		{
			*pbstrValue = SysAllocString( v.bstrVal );
		}
		else
		{
			hr = WBEM_E_FAILED;
		}
		
		VariantClear( &v );
	}

	SysFreeString( bstrProperty );

	return hr;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	TestUnmerge
//
//	Assigns a class object a class name and adds some properties
//	to the class.
//
///////////////////////////////////////////////////////////////////

HRESULT	TestUnmerge( IWbemClassObject* pObj, LPMEMORY* ppbData, length_t* pnLength )
{
	OutputDebugString( "Unmerging Object!\n" );

	CWbemObject*	pWbemObject = (CWbemClass*) pObj;

	*pnLength = pWbemObject->EstimateUnmergeSpace();

	length_t	nUnmergedLength = 0;

	*ppbData = new BYTE[*pnLength];

	HRESULT	hr = pWbemObject->Unmerge( *ppbData, *pnLength, &nUnmergedLength );

	if ( SUCCEEDED(hr) )
	{
		OutputDebugString( "Unmerging Object succeeded!\n\n\n" );
	}
	else
	{
		OutputDebugString( "Unmerging Object failed!\n\n\n" );
	}

	return hr;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	TestMergeClass
//
//	Assigns a class object a class name and adds some properties
//	to the class.
//
///////////////////////////////////////////////////////////////////

HRESULT	TestMergeClass( CWbemClass* pParent, LPMEMORY pbData, CWbemClass** ppNewClass )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	OutputDebugString( "Creating Class from BLOB!\n" );

	*ppNewClass = CWbemClass::CreateFromBlob( pParent, pbData );

	if ( NULL != *ppNewClass )
	{
		OutputDebugString( "Creating Class from BLOB succeeded!\n\n\n" );
	}
	else
	{
		OutputDebugString( "Creating Class from BLOB failed!\n\n\n" );
		DebugBreak();
		hr = WBEM_E_FAILED;
	}

	return hr;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	TestMergeClass
//
//	Assigns a class object a class name and adds some properties
//	to the class.
//
///////////////////////////////////////////////////////////////////

HRESULT	TestMergeInstance( CWbemClass* pParent, LPMEMORY pbData, CWbemInstance** ppNewInstance )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	OutputDebugString( "Creating Instance from BLOB!\n" );

	*ppNewInstance = CWbemInstance::CreateFromBlob( pParent, pbData );

	if ( NULL != *ppNewInstance )
	{
		OutputDebugString( "Creating Instance from BLOB succeeded!\n\n\n" );
	}
	else
	{
		OutputDebugString( "Creating Instance from BLOB failed!\n\n\n" );
		DebugBreak();
		hr = WBEM_E_FAILED;
	}

	return hr;
}
///////////////////////////////////////////////////////////////////
//
//	Function:	SetupClassObject
//
//	Assigns a class object a class name and adds some properties
//	to the class.
//
///////////////////////////////////////////////////////////////////

HRESULT	SetupClassObject( IWbemClassObject* pObj )
{

	OutputDebugString( "Setting Up Class Object\n" );

	// Tests that this is in fact an instance object

	_IWmiObject*	pObjInternals = NULL;
	HRESULT	hr = pObj->QueryInterface( IID__IWmiObject, (void**) &pObjInternals );

	if ( SUCCEEDED( hr ) )
	{
		hr = pObjInternals->IsObjectInstance();

		if ( WBEM_S_FALSE == hr )
		{

			// We need a class name to be able to spawn instances
			if ( SUCCEEDED(hr) )
			{
				HRESULT	hr = WBEM_S_NO_ERROR;

				_IWmiObject*	pWmiObject = NULL;

				hr = pObj->QueryInterface( IID__IWmiObject, (void**) &pWmiObject );

				if ( SUCCEEDED( hr ) )
				{
					long	lHandle = 0;
					LPVOID	pData = NULL;
					ULONG	ulFlags = 0L;

					hr = pWmiObject->GetPropertyHandleEx( L"__CLASS", 0L, NULL, &lHandle );

					hr = pWmiObject->SetPropByHandle( lHandle, 0L, ( wcslen(CLASS_PROPERTY_VALUE) + 1 ) * 2,
														CLASS_PROPERTY_VALUE );

					hr = pWmiObject->GetPropAddrByHandle( lHandle, 0L, &ulFlags, &pData );


					DWORD	dwNumAntecedents;
					DWORD	dwBuffSizeUsed;

					hr = pWmiObject->GetDerivation( 0L, 0L, &dwNumAntecedents, &dwBuffSizeUsed, NULL );

					pWmiObject->Release();
				}

				// Now put in 3 properties so we have somewhere to stick test data
				hr = AddStringProperty( pObj, TEST_PROPERTY1_NAME );

				if ( SUCCEEDED(hr) )
				{
					hr = AddStringProperty( pObj, TEST_PROPERTY2_NAME );

					if ( SUCCEEDED(hr) )
					{
						hr = AddStringProperty( pObj, TEST_PROPERTY3_NAME );

					}

				}

				_IWmiObject*	pClonedObj = NULL;

				hr = pObj->Clone( (IWbemClassObject**) &pClonedObj );

				if ( FAILED(hr) )
				{
					OutputDebugString( "Setup Class Failed!\n" );
					DebugBreak();
				}
			}
		}
		else
		{
			OutputDebugString( "SetupClassObject() fails.  Object is NOT a class!\n" );
		}

		pObjInternals->Release();

	}

	printf( "SetupClassObject() returns: %d\n", hr );

	return hr;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	SetupInstance
//
//	Assigns values to String properties in an instance.
//
///////////////////////////////////////////////////////////////////

HRESULT	SetupInstance( IWbemClassObject* pObj )
{

	// Now place values in the instance's property value
	HRESULT hr = PutStringValue( pObj, TEST_PROPERTY1_NAME, TEST_PROPERTY1_VALUE );

	if ( SUCCEEDED(hr) )
	{
		hr = PutStringValue( pObj, TEST_PROPERTY2_NAME, TEST_PROPERTY2_VALUE );

		if ( SUCCEEDED(hr) )
		{
			hr = PutStringValue( pObj, TEST_PROPERTY3_NAME, TEST_PROPERTY3_VALUE );

		}

	}

	printf( "SetupInstance() returns: %d\n", hr );

	return hr;
}

HRESULT TestUnmergeMergeInstance( IWbemClassObject** ppObj, CWbemClass* pClass )
{
	OutputDebugString( "Testing Unmerge/Merge Instance\n" );

	LPMEMORY	pbData = NULL;
	length_t	nLength = 0;

	HRESULT hr = TestUnmerge( *ppObj, &pbData, &nLength );

	if ( SUCCEEDED( hr ) )
	{
		CWbemInstance*	pRebuiltInstance = NULL;

		hr = TestMergeInstance( pClass, pbData, &pRebuiltInstance );

		if ( SUCCEEDED( hr ) )
		{
			(*ppObj)->Release();
			*ppObj = (IWbemClassObject*) pRebuiltInstance;
		}
	}

	OutputDebugString( "Testing Unmerge/Merge Instance end\n" );

	return hr;
}


///////////////////////////////////////////////////////////////////
//
//	Function:	SpawnInstance
//
//	Spawns an instance from the supplied object, and fills out
//	property values.
//
///////////////////////////////////////////////////////////////////

HRESULT	SpawnInstance( IWbemClassObject* pObj, IWbemClassObject** ppInstance, int nNum )
{
	printf( "Spawning Instance Number %d\n", nNum );

	HRESULT hr = pObj->SpawnInstance( 0L, ppInstance );

	if ( SUCCEEDED( hr ) )
	{
		hr = SetupInstance( *ppInstance );

		if ( SUCCEEDED( hr ) )
		{
			hr = TestUnmergeMergeInstance( ppInstance, (CWbemClass*) pObj );
		}

		hr = (*ppInstance)->Put( L"__SD", WBEM_FLAG_USE_CURRENT_TIME, NULL, 0L );

		hr = (*ppInstance)->Put( L"__TCREATED", WBEM_FLAG_USE_CURRENT_TIME, NULL, 0L );

	}

	printf( "Spawning Instance Number %d returns: %d\n", nNum, hr );

	return hr;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	VerifyProperty
//
//	Checks an Instance of an object against the supplied value for
//	a properties.
//
///////////////////////////////////////////////////////////////////

HRESULT	VerifyProperty( IWbemClassObject* pInstance, LPCWSTR Property, LPCWSTR Value )
{
	BSTR	bstrValue = NULL;

	printf ( "Verifying Property %S == %S\n", Property, Value );

	HRESULT hr = GetStringProperty( pInstance, Property, &bstrValue );

	if ( SUCCEEDED( hr ) )
	{
		if ( 0 == _wcsicmp( bstrValue, Value ) )
		{
			printf( "Property %S successfully verified\n", Property );
		}
		else
		{
			printf( "Property %S failed verification.  Value: %S\n", Property, bstrValue );
			DebugBreak();
		}
	}
	else
	{
		printf( "GetStringProperty() failed: %d\n", hr );
		DebugBreak();
	}

	return hr;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	VerifyInstance
//
//	Checks an Instance of an object against the preset values for
//	the class name and properties.
//
///////////////////////////////////////////////////////////////////

BOOL VerifyInstance( IWbemClassObject* pInstance )
{
	int		nTest = 0;
	BSTR	bstrValue = NULL;

	OutputDebugString( "Verifying Instance Begin\n" );

	// Tests that this is in fact an instance object

	_IWmiObject*	pObjInternals = NULL;
	HRESULT	hr = pInstance->QueryInterface( IID__IWmiObject, (void**) &pObjInternals );

	if ( SUCCEEDED( hr ) )
	{
		hr = pObjInternals->IsObjectInstance();

		if ( WBEM_S_NO_ERROR == hr )
		{
			// Class Name tested first
			hr = VerifyProperty( pInstance, CLASS_PROPERTY_NAME, CLASS_PROPERTY_VALUE );

			if ( SUCCEEDED(hr) )
			{
				hr = VerifyProperty( pInstance, TEST_PROPERTY1_NAME, TEST_PROPERTY1_VALUE );
			}

			if ( SUCCEEDED(hr) )
			{
				hr = VerifyProperty( pInstance, TEST_PROPERTY2_NAME, TEST_PROPERTY2_VALUE );
			}

			if ( SUCCEEDED(hr) )
			{
				hr = VerifyProperty( pInstance, TEST_PROPERTY3_NAME, TEST_PROPERTY3_VALUE );
			}

			if ( SUCCEEDED( hr ) )
			{
				OutputDebugString( "Verifying Instance succeeded!\n" );
			}
			else
			{
				OutputDebugString( "Verifying Instance failed!\n" );
				DebugBreak();
			}

		}
		else
		{
			printf( "Verifying Instance FAILED!  IsObjectInstance() failed.\n" );
			DebugBreak();
		}

		// Clean up the Obj Internals pointer
		pObjInternals->Release();

	}

	OutputDebugString( "Verifying Instance End\n" );

	return ( WBEM_S_NO_ERROR == hr );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	TestGetSetClassPart
//
//	Gets a class part out of an object, strips it, then restores
//	it.
//
///////////////////////////////////////////////////////////////////

BOOL TestGetSetClassPart( IWbemClassObject* pInstance )
{
	_IWmiObject*	pInternals = NULL;

	OutputDebugString( "TestGetSetClassPart() Begin\n" );

	// We need an ObjectInternals interface now
	OutputDebugString( "Querying Interface\n" );
	HRESULT	hr = pInstance->QueryInterface( IID__IWmiObject, (void**) &pInternals );

	if ( SUCCEEDED( hr ) )
	{
		BYTE*	pClassPart = NULL;
		DWORD	dwSizeOfData = 0,
				dwSizeReturned = 0;

		// We need to know how big the buffer to copy out to needs to be

		OutputDebugString( "Getting Class Data (buffer size)\n" );
		hr = pInternals->GetObjectParts( pClassPart, dwSizeOfData, WBEM_OBJ_CLASS_PART, &dwSizeReturned );

		// expected return since we used all NULLs
		if ( WBEM_E_BUFFER_TOO_SMALL == hr )
		{
			dwSizeOfData = dwSizeReturned;
			pClassPart = new BYTE[dwSizeReturned];

			if ( NULL != pClassPart )
			{
				// Now get the class data

				OutputDebugString( "Getting Class Data\n" );
				hr = pInternals->GetObjectParts( pClassPart, dwSizeOfData, WBEM_OBJ_CLASS_PART, &dwSizeReturned );

				if ( SUCCEEDED( hr ) )
				{
					// Strip existing data

					OutputDebugString( "Stripping Class Data\n" );
					hr = pInternals->StripClassPart();

					if ( SUCCEEDED( hr ) )
					{

						// Set class data using the previously obtained data

						OutputDebugString( "Restoring Class Data\n" );
						hr = pInternals->SetClassPart( pClassPart, dwSizeReturned );

						if ( SUCCEEDED( hr ) )
						{
							// Make sure we can still obtain expected values.
							OutputDebugString( "Verifying Restored Instance\n" );
							if ( !VerifyInstance( pInstance ) )
							{
								hr = WBEM_E_FAILED;
							}
						}
						else
						{
							printf( "SetClassPart() failed! hr = %d\n", hr );
						}
					}
					else
					{
						printf( "StripClassPart() failed! hr = %d\n", hr );
					}

				}
				else
				{
					printf( "GetClassPart() failed! hr = %d\n", hr );
				}

				delete [] pClassPart;
			}
			else
			{
				OutputDebugString( "Unable to allocate memory!\n");
			}
		}
		else
		{
			printf( "GetClassPart() unexpected return! hr = %d\n", hr );
		}


		pInternals->Release();
	}
	else
	{
		printf( "QueryInterface() failed! hr = %d\n", hr );
	}

	OutputDebugString( "TestGetSetClassPart() End.\n\n" );

	return ( WBEM_S_NO_ERROR == hr );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	TestMergeClassPart
//
//	Strips a class part and then merges two objects so that a class
//	part is shared between two objects.
//
///////////////////////////////////////////////////////////////////

BOOL TestMergeClassPart( IWbemClassObject* pInstance, IWbemClassObject* pMerge )
{
	_IWmiObject*	pInternals = NULL;

	OutputDebugString( "TestMergeClassPart() Begin\n" );

	// We need an ObjectInternals interface now
	OutputDebugString( "Querying Interface\n" );
	HRESULT	hr = pInstance->QueryInterface( IID__IWmiObject, (void**) &pInternals );

	if ( SUCCEEDED( hr ) )
	{
		// Strip existing data

		OutputDebugString( "Stripping Class Data\n" );
		hr = pInternals->StripClassPart();

		if ( SUCCEEDED( hr ) )
		{

			// Merge with the merge object

			OutputDebugString( "Merging Class Data\n" );
			hr = pInternals->MergeClassPart( pMerge );

			if ( SUCCEEDED( hr ) )
			{
				// Make sure we can still obtain expected values.
				OutputDebugString( "Verifying merged Instance\n" );
				if ( !VerifyInstance( pInstance ) )
				{
					hr = WBEM_E_FAILED;
				}
			}
			else
			{
				printf( "MergeClassPart() failed! hr = %d\n", hr );
			}
		}
		else
		{
			printf( "StripClassPart() failed! hr = %d\n", hr );
		}

		pInternals->Release();
	}
	else
	{
		printf( "QueryInterface() failed! hr = %d\n", hr );
	}

	OutputDebugString( "TestMergeClassPart() End\n\n" );

	return ( WBEM_S_NO_ERROR == hr );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	TestClone
//
//	Clones a supplied object and verifies the cloned object.  This
//	should succeed for both objects with merged and internal class
//	parts.
//
///////////////////////////////////////////////////////////////////

BOOL TestClone( IWbemClassObject* pInstance )
{
	OutputDebugString( "TestClone() Begin\n" );

	// Now try cloning the instance with the merged class part
	IWbemClassObject* pNewInstance = NULL;

	HRESULT hr = pInstance->Clone( &pNewInstance );

	// If cloning succeeded, verify that the instance cloned correctly, then
	// get rid of it
	if ( SUCCEEDED( hr ) )
	{
		VerifyInstance( pNewInstance );
		pNewInstance->Release();
	}
	else
	{
		printf( "Clone() failed.  HR = %d\n", hr );
	}

	OutputDebugString( "TestClone() End\n\n" );

	return ( WBEM_S_NO_ERROR == hr );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	TestSpawnInstance
//
//	Spawns an instance from a supplied object and verifies the new instance.
//	This should succeed for both objects with merged and internal class
//	parts.
//
///////////////////////////////////////////////////////////////////

BOOL TestSpawnInstance( IWbemClassObject* pInstance )
{
	OutputDebugString( "TestSpawnInstance() Begin\n" );

	// Now try cloning the instance with the merged class part
	IWbemClassObject* pNewInstance = NULL;

	HRESULT hr = pInstance->SpawnInstance( 0L, &pNewInstance );

	// If spawning succeeded, verify that the instance spawned correctly, then
	// get rid of it
	if ( SUCCEEDED( hr ) )
	{
		// Set a bunch of values which we will then verify to ensure
		// that the instance is functioning correctly (as advertised).
		SetupInstance( pNewInstance );
		VerifyInstance( pNewInstance );
		pNewInstance->Release();
	}
	else
	{
		printf( "SpawnInstance() failed.  HR = %d\n", hr );
		DebugBreak();
	}

	OutputDebugString( "TestSpawnInstance() End\n\n" );

	return ( WBEM_S_NO_ERROR == hr );
}

HRESULT TestWmiQualifierDWORDArray( _IWmiObject* pObj )
{
	HRESULT	hrTest = WBEM_S_NO_ERROR;

	long	alTest[13] = {0,1,2,3,4,5,6,7,8,9,10,11,12};

	hrTest = pObj->SetObjQual( L"DWORDArrayQual", 0L, 13 * sizeof(long), 13, CIM_UINT32 | CIM_FLAG_ARRAY,
							0L, alTest );

	if ( SUCCEEDED( hrTest ) )
	{
		OutputDebugString( "Putting DWORD Array Qualifier Succeeded!\n" );

		_IWmiArray*	pArray = NULL;
		ULONG uUsed = 0;
		CIMTYPE	ctTemp = 0;

		hrTest = pObj->GetObjQual( L"DWORDArrayQual", 0L, sizeof(pArray), &ctTemp, NULL, &uUsed, &pArray );

		DWORD	dwNumElements = 0;
		DWORD	dwTest = 0;
		DWORD	dwData = 0;
		DWORD	dwNumReturned = 0;
		DWORD	uBuffUsed = 0;

		if ( SUCCEEDED( hrTest ) )
		{
			OutputDebugString( "Getting DWORD Array Qualifier Succeeded!\n" );

			ULONG	uFlags = NULL;

			for ( ULONG x = 0; SUCCEEDED(hrTest) && x < 13; x++ )
			{
				hrTest = pArray->GetAt( 0L, x, 1, sizeof(DWORD), &dwNumReturned, &uBuffUsed, &dwData );
			}

			if ( SUCCEEDED( hrTest ) )
			{
				OutputDebugString( "Getting Array Property Element Succeeded!\n" );

				DWORD	dwTestProp = 666;
				hrTest = pArray->SetAt( 0L, 7, 1, sizeof(dwTestProp), &dwTestProp );

				if ( SUCCEEDED( hrTest ) )
				{
					hrTest = pArray->GetAt( 0L, 7, 1, sizeof(DWORD), &dwNumReturned, &uBuffUsed, &dwData );

					if ( SUCCEEDED( hrTest ) )
					{
						if ( dwTestProp != dwData )
						{
							DebugBreak();
						}
					}
					else
					{
						DebugBreak();
					}
				}
				else
				{
					DebugBreak();
				}
			}

			if ( SUCCEEDED( hrTest ) )
			{
				OutputDebugString( "Testing Appending an array of DWORD elements\n" );

				DWORD	adwValues[10];

				for ( DWORD x = 33; x < 43; x++ )
				{
					adwValues[x-33] = x;
				}

				hrTest = pArray->Append( 0L, 10, sizeof(DWORD) * 10, adwValues );

				if ( SUCCEEDED( hrTest ) )
				{
					// Get an element and see if it's what we expect
					hrTest = pArray->GetAt( 0L, 15, 1, sizeof(DWORD), &dwNumReturned, &uBuffUsed, &dwData );

					if ( SUCCEEDED( hrTest ) )
					{
						if ( adwValues[2] != dwData )
						{
							DebugBreak();
						}

						OutputDebugString( "Testing Removing a range of DWORD elements\n" );

						// Remove a range from the middle of the array, and then get an element and
						// see if we have a match
						hrTest = pArray->RemoveAt( 0L, 15, 3 );

						if ( SUCCEEDED( hrTest ) )
						{
							hrTest = pArray->GetAt( 0L, 15, 1, sizeof(DWORD), &dwNumReturned, &uBuffUsed, &dwData );

							if ( adwValues[5] != dwData )
							{
								DebugBreak();
							}

						}
						else
						{
							DebugBreak();
						}
					}
					else
					{
						DebugBreak();
					}

				}
				else
				{
					DebugBreak();
				}

			}

			pArray->Release();

		}


	}

	return hrTest;
}

HRESULT TestWmiObjectDWORDArray( _IWmiObject* pObj )
{
	HRESULT	hrTest = WBEM_S_NO_ERROR;

	long	alTest[13] = {0,1,2,3,4,5,6,7,8,9,10,11,12};

	hrTest = pObj->WriteProp( L"ArrayProp", 0L, 13 * sizeof(long), 13, CIM_UINT32 | CIM_FLAG_ARRAY,
							alTest );

	if ( SUCCEEDED( hrTest ) )
	{
		OutputDebugString( "Putting Array Property Succeeded!\n" );

		long	lHandle = 0L;

		hrTest = pObj->GetPropertyHandleEx( L"ArrayProp", 0L, NULL, &lHandle );

		DWORD	dwNumElements = 0;
		DWORD	dwTest = 0;
		LPVOID	pvData = NULL;

		if ( SUCCEEDED( hrTest ) )
		{
			OutputDebugString( "Getting Array Property Handle Succeeded!\n" );

			// Now initialize the array

			hrTest = pObj->GetArrayPropAddrByHandle( lHandle, 0L, &dwNumElements, &pvData );

			if ( WBEM_S_NO_ERROR == hrTest )
			{
				dwTest = *(UNALIGNED DWORD*)pvData;
				OutputDebugString( "Getting Array Property Address Succeeded!\n" );
			}
		}

		if ( SUCCEEDED( hrTest ) )
		{
			ULONG	uFlags = NULL;


			for ( ULONG x = 0; SUCCEEDED(hrTest) && x < dwNumElements; x++ )
			{
				hrTest = pObj->GetArrayPropElementByHandle( lHandle, 0L, x, &uFlags, &dwNumElements, &pvData );
			}

			if ( SUCCEEDED( hrTest ) )
			{
				OutputDebugString( "Getting Array Property Element Succeeded!\n" );

				DWORD	dwTestProp = 666;
				hrTest = pObj->SetArrayPropElementByHandle( lHandle, 0L, 7, sizeof(dwTestProp), &dwTestProp );

				if ( SUCCEEDED( hrTest ) )
				{
					hrTest = pObj->GetArrayPropElementByHandle( lHandle, 0L, 7, &uFlags, &dwNumElements, &pvData );

					if ( SUCCEEDED( hrTest ) )
					{
						if ( dwTestProp != *(UNALIGNED DWORD*) pvData )
						{
							DebugBreak();
						}
					}
					else
					{
						DebugBreak();
					}
				}
			}

			if ( SUCCEEDED( hrTest ) )
			{
				OutputDebugString( "Testing Appending an array of DWORD elements\n" );

				DWORD	adwValues[10];

				for ( DWORD x = 33; x < 43; x++ )
				{
					adwValues[x-33] = x;
				}

				hrTest = pObj->AppendArrayPropRangeByHandle( lHandle, 0L, 10, sizeof(DWORD) * 10, adwValues );

				if ( SUCCEEDED( hrTest ) )
				{
					// Get an element and see if it's what we expect
					hrTest = pObj->GetArrayPropElementByHandle( lHandle, 0L, 15, &uFlags, &dwNumElements, &pvData );

					if ( SUCCEEDED( hrTest ) )
					{
						if ( adwValues[2] != *((UNALIGNED DWORD*) pvData ))
						{
							DebugBreak();
						}

						OutputDebugString( "Testing Removing a range of DWORD elements\n" );

						// Remove a range from the middle of the array, and then get an element and
						// see if we have a match
						hrTest = pObj->RemoveArrayPropRangeByHandle( lHandle, 0L, 15, 3 );

						if ( SUCCEEDED( hrTest ) )
						{
							pObj->GetArrayPropElementByHandle( lHandle, 0L, 15, &uFlags, &dwNumElements, &pvData );

							if ( adwValues[5] != *((UNALIGNED DWORD*) pvData ))
							{
								DebugBreak();
							}

						}
						else
						{
							DebugBreak();
						}
					}
					else
					{
						DebugBreak();
					}

				}
				else
				{
					DebugBreak();
				}

			}


		}

	}

	return hrTest;
}

HRESULT TestWmiQualifierStringArray( _IWmiObject* pObj )
{
	HRESULT	hrTest = WBEM_S_NO_ERROR;

	WCHAR	wcsTest[512];
	WCHAR*	pTemp = wcsTest;
	ULONG	uBuffLen =0;

	// Create a linear array
	for ( long x = 10; SUCCEEDED(hrTest) && x < 23; x++ )
	{
		WCHAR	wcsValue[32];

		swprintf( wcsValue, L"TestString%d", x );
		wcscpy( pTemp, wcsValue );

		uBuffLen += ( ( wcslen( pTemp ) + 1 ) * 2 );
		pTemp += (wcslen( pTemp ) + 1);
	}

	hrTest = pObj->SetObjQual( L"StringArrayQual", 0L, uBuffLen, 13, CIM_STRING | CIM_FLAG_ARRAY,
							0L, wcsTest );

	if ( SUCCEEDED( hrTest ) )
	{
		OutputDebugString( "Putting String Array Qualifier Succeeded!\n" );

		_IWmiArray*	pArray = NULL;
		ULONG uUsed = 0;

		hrTest = pObj->GetObjQual( L"StringArrayQual", 0L, sizeof(pArray), NULL, NULL, &uUsed, &pArray );

		DWORD	dwNumElements = 0;
		DWORD	dwTest = 0;
		DWORD	dwData = 0;
		DWORD	dwNumReturned = 0;
		DWORD	uBuffUsed = 0;

		if ( SUCCEEDED( hrTest ) )
		{
			OutputDebugString( "Getting String Array Qualifier Succeeded!\n" );

			WCHAR	wcsData[512];
			ULONG	uFlags = NULL;

			for ( ULONG x = 0; SUCCEEDED(hrTest) && x < 13; x++ )
			{
				hrTest = pArray->GetAt( 0L, x, 1, sizeof(wcsData), &dwNumReturned, &uBuffUsed, wcsData );
			}

			if ( SUCCEEDED( hrTest ) )
			{
				OutputDebugString( "Getting Array Property Element Succeeded!\n" );

				char	szAsciiValue[256];
				WCHAR	wszNewValue[256];

				wcscpy( wszNewValue, L"01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789");

				// Testing Set/Get Element
				hrTest = pArray->SetAt( 0L, 7, 1, (wcslen(wszNewValue)+1)*2, wszNewValue );

				if ( SUCCEEDED( hrTest ) )
				{
					hrTest = pArray->GetAt( 0L, 7, 1, sizeof(wcsData), &dwNumReturned, &uBuffUsed, wcsData );

					if ( SUCCEEDED( hrTest ) )
					{
						if ( wcscmp( wszNewValue, wcsData ) != 0 )
						{
							DebugBreak();
						}
					}
					else
					{
						DebugBreak();
					}

				}
				else
				{
					DebugBreak();
				}

			}

			if ( SUCCEEDED( hrTest ) )
			{
				OutputDebugString( "Testing Appending an array of String elements\n" );

				LPWSTR	pwcsTemp = new WCHAR[128];
				char	szVal[128];

				wcscpy( pwcsTemp, L"9876543210" );
				wcscpy( pwcsTemp + 11, L"abcdefghijklmnopqrstuvwxyz" );

				hrTest = pArray->Append( 0L, 2, 76, pwcsTemp );

				if ( SUCCEEDED( hrTest ) )
				{
					// Get an element and see if it's what we expect
					hrTest = pArray->GetAt( 0L, 14, 1, sizeof(wcsData), &dwNumReturned, &uBuffUsed, wcsData );

					if ( SUCCEEDED( hrTest ) )
					{
						if ( wcscmp( wcsData, pwcsTemp + 11 ) != 0 )
						{
							DebugBreak();
						}

						OutputDebugString( "Testing Removing a range of String elements\n" );

						// Remove a range from the middle of the array, and then get an element and
						// see if we have a match
						hrTest = pArray->RemoveAt( 0L, 7, 3 );

						if ( SUCCEEDED( hrTest ) )
						{
							hrTest = pArray->GetAt( 0L, 7, 1, sizeof(wcsData), &dwNumReturned, &uBuffUsed, wcsData );

							if ( wcscmp( L"TestString20", wcsData ) )
							{
								DebugBreak();
							}

						}
						else
						{
							DebugBreak();
						}
					}
					else
					{
						DebugBreak();
					}

				}
				else
				{
					DebugBreak();
				}

			}

			pArray->Release();

		}


	}

	return hrTest;
}

HRESULT TestWmiObjectStringArray( _IWmiObject* pTestObj )
{
	HRESULT	hrTest = WBEM_S_NO_ERROR;

	_IWmiObjectAccessEx*	pObj = NULL;

	pTestObj->QueryInterface( IID__IWmiObjectAccessEx, (void**) &pObj );

	WCHAR	wcsTest[512];
	WCHAR*	pTemp = wcsTest;
	ULONG	uBuffLen =0;

	// Create a linear array
	for ( long x = 10; SUCCEEDED(hrTest) && x < 23; x++ )
	{
		WCHAR	wcsValue[32];

		swprintf( wcsValue, L"TestString%d", x );
		wcscpy( pTemp, wcsValue );

		uBuffLen += ( ( wcslen( pTemp ) + 1 ) * 2 );
		pTemp += (wcslen( pTemp ) + 1);
	}

	hrTest = pObj->WriteProp( L"ArrayProp", 0L, uBuffLen, 13, CIM_STRING | CIM_FLAG_ARRAY, wcsTest );

	if ( SUCCEEDED( hrTest ) )
	{
		OutputDebugString( "Putting Array Property Succeeded!\n" );

		long	lHandle = 0L;

		hrTest = pObj->GetPropertyHandleEx( L"ArrayProp", 0L, NULL, &lHandle );

		DWORD	dwNumElements = 0;
		DWORD	dwTest = 0;
		LPVOID	pvData = NULL;

		if ( SUCCEEDED( hrTest ) )
		{
			OutputDebugString( "Getting Array Property Handle Succeeded!\n" );

			hrTest = pObj->GetArrayPropAddrByHandle( lHandle, 0L, &dwNumElements, &pvData );

			// This should fail!
			if ( SUCCEEDED( hrTest ) )
			{
				OutputDebugString( "Getting Array Property Address Succeeded!\n" );
				DebugBreak();
			}
			else
			{
				OutputDebugString( "Getting String Array Property Address Failed!\n" );
				hrTest = WBEM_S_NO_ERROR;
			}
		}

		if ( SUCCEEDED( hrTest ) )
		{
			ULONG	uFlags = NULL;

			for ( ULONG x = 0; SUCCEEDED(hrTest) && x < 13; x++ )
			{
				hrTest = pObj->GetArrayPropElementByHandle( lHandle, 0L, x, &uFlags, &dwNumElements, &pvData );
			}

			if ( SUCCEEDED( hrTest ) )
			{
				OutputDebugString( "Getting Array Property Element Succeeded!\n" );

				char	szAsciiValue[256];
				WCHAR	wszNewValue[256];

				wcscpy( wszNewValue, L"01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789");
				strcpy( szAsciiValue, "01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789");

				// Testing Set/Get Element
				hrTest = pObj->SetArrayPropElementByHandle( lHandle, 0L, 7, (wcslen(wszNewValue)+1)*2, wszNewValue );

				if ( SUCCEEDED( hrTest ) )
				{
					hrTest = pObj->GetArrayPropElementByHandle( lHandle, 0L, 7, &uFlags, &dwNumElements, &pvData );

					if ( SUCCEEDED( hrTest ) )
					{
						if ( strcmp( szAsciiValue, (LPSTR) pvData ) != 0 )
						{
							DebugBreak();
						}
					}
					else
					{
						DebugBreak();
					}

				}
				else
				{
					DebugBreak();
				}


			}

			// Now we'll try appending a couple of strings
			if ( SUCCEEDED( hrTest ) )
			{
				OutputDebugString( "Testing Appending an array of String elements\n" );

				LPWSTR	pwcsTemp = new WCHAR[128];
				char	szVal[128];

				wcscpy( pwcsTemp, L"9876543210" );
				wcscpy( pwcsTemp + 11, L"abcdefghijklmnopqrstuvwxyz" );
				strcpy( szVal, "abcdefghijklmnopqrstuvwxyz" );


				hrTest = ((CWbemObject*) pObj)->AppendArrayPropRangeByHandle( lHandle, 0L, 2, 76, pwcsTemp );

				if ( SUCCEEDED( hrTest ) )
				{
					// Get an element and see if it's what we expect
					hrTest = pObj->GetArrayPropElementByHandle( lHandle, 0L, 14, &uFlags, &dwNumElements, &pvData );

					if ( SUCCEEDED( hrTest ) )
					{
						if ( strcmp( szVal, (LPSTR) pvData ) != 0 )
						{
							DebugBreak();
						}

						OutputDebugString( "Testing Removing a range of string elements\n" );

						// Remove a range from the middle of the array, and then get an element and
						// see if we have a match
						hrTest = ((CWbemObject*) pObj)->RemoveArrayPropRangeByHandle( lHandle, 0L, 7, 3 );

						if ( SUCCEEDED( hrTest ) )
						{
							pObj->GetArrayPropElementByHandle( lHandle, 0L, 7, &uFlags, &dwNumElements, &pvData );

							if ( strcmp( "TestString20", (LPSTR) pvData ) != 0 )
							{
								DebugBreak();
							}

						}
						else
						{
							DebugBreak();
						}
					}
					else
					{
						DebugBreak();
					}

				}
				else
				{
					DebugBreak();
				}

			}

		}

	}

	pObj->Release();

	return hrTest;
}

HRESULT TestWmiObjectQualifiers( _IWmiObject* pObj )
{
	HRESULT	hrTest = WBEM_S_NO_ERROR;

	WCHAR	wcsTest[512];
	WCHAR*	pTemp = wcsTest;
	ULONG	uBuffLen =0;

	DWORD	dwTest = 3000;

	wcscpy( wcsTest, L"Test String of verify importanmt caliber." );

	DWORD	dwTemp;
	WCHAR	wcsTemp[512];


	HRESULT hr = pObj->SetObjQual( L"DWORDQual", 0L, sizeof(DWORD), 1, CIM_UINT32,
							0L, &dwTest );

	if ( SUCCEEDED( hr ) )
	{
		OutputDebugString( "Set DWORD Object Qualifier!\n" );
		hr = pObj->SetObjQual( L"StringQual", 0L, ( ( wcslen( wcsTest ) + 1 ) * 2 ), 1, CIM_STRING,
								0L, wcsTest );
		
		if ( SUCCEEDED( hr ) )
		{
			OutputDebugString( "Set String Object Qualifier!\n" );

			ULONG uUsed = 0;
			CIMTYPE	ctTest = 0L;

			hrTest = pObj->GetObjQual( L"DWORDQual", 0L, sizeof(DWORD), &ctTest, NULL, &uUsed, &dwTemp );

			if ( SUCCEEDED( hrTest ) )
			{
				OutputDebugString( "Got DWORD object qualifier\n" );
				if ( dwTest != dwTemp )
				{
					DebugBreak();
				}
				
				hrTest = pObj->GetObjQual( L"StringQual", 0L, sizeof(wcsTemp), NULL, NULL, &uUsed, wcsTemp );
				if ( SUCCEEDED( hrTest ) )
				{
					OutputDebugString( "Got String object qualifier\n" );
					if ( wcscmp( wcsTemp, wcsTest ) == 0 )
					{
						DebugBreak();
					}
				}
				else
				{
					DebugBreak();
				}

				OutputDebugString( "Got DWORD object qualifier\n" );

			}
			else
			{
				DebugBreak();
			}

		}
		else
		{
			DebugBreak();
		}
	}
	else
	{
		DebugBreak();
	}

	return hr;
}

HRESULT TestWmiPropertyQualifiers( _IWmiObject* pObj )
{
	HRESULT	hrTest = WBEM_S_NO_ERROR;

	hrTest = pObj->WriteProp( L"TestQualProp", 0L, 0, 13, CIM_UINT32,
							NULL );

	WCHAR	wcsTest[512];
	WCHAR*	pTemp = wcsTest;
	ULONG	uBuffLen =0;

	DWORD	dwTest = 3000;

	wcscpy( wcsTest, L"Test String of verify importanmt caliber." );

	DWORD	dwTemp;
	WCHAR	wcsTemp[512];


	HRESULT hr = pObj->SetPropQual( L"TestQualProp", L"DWORDQual", 0L, sizeof(DWORD), 1, CIM_UINT32,
							0L, &dwTest );

	if ( SUCCEEDED( hr ) )
	{
		OutputDebugString( "Set DWORD Property Qualifier!\n" );
		hr = pObj->SetPropQual( L"TestQualProp", L"StringQual", 0L, ( ( wcslen( wcsTest ) + 1 ) * 2 ), 1, CIM_STRING,
								0L, wcsTest );
		
		if ( SUCCEEDED( hr ) )
		{
			OutputDebugString( "Set String Property Qualifier!\n" );

			CIMTYPE		ctTemp = 0;
			ULONG uUsed = 0;

			hrTest = pObj->GetPropQual( L"TestQualProp", L"DWORDQual", 0L, sizeof(DWORD), &ctTemp, NULL, &uUsed, &dwTemp );

			if ( SUCCEEDED( hrTest ) )
			{
				OutputDebugString( "Got DWORD Property qualifier\n" );
				if ( dwTest != dwTemp )
				{
					DebugBreak();
				}
				
				hrTest = pObj->GetPropQual( L"TestQualProp", L"StringQual", 0L, sizeof(wcsTemp), NULL, NULL, &uUsed, wcsTemp );
				if ( SUCCEEDED( hrTest ) )
				{
					OutputDebugString( "Got String Property qualifier\n" );
					if ( wcscmp( wcsTemp, wcsTest ) == 0 )
					{
						DebugBreak();
					}
				}
				else
				{
					DebugBreak();
				}

				OutputDebugString( "Got DWORD object qualifier\n" );

			}
			else
			{
				DebugBreak();
			}

		}
		else
		{
			DebugBreak();
		}
	}
	else
	{
		DebugBreak();
	}

	return hr;
}

HRESULT TestWmiPropertyDWORDQualifiers( _IWmiObject* pObj )
{
	HRESULT	hrTest = WBEM_S_NO_ERROR;

	long	alTest[13] = {0,1,2,3,4,5,6,7,8,9,10,11,12};

	hrTest = pObj->SetPropQual( L"TestQualProp", L"DWORDArrayQual", 0L, 13 * sizeof(long), 13, CIM_UINT32 | CIM_FLAG_ARRAY,
							0L, alTest );

	if ( SUCCEEDED( hrTest ) )
	{
		OutputDebugString( "Putting DWORD Array Property Qualifier Succeeded!\n" );

		_IWmiArray*	pArray = NULL;
		ULONG uUsed = 0;

		hrTest = pObj->GetPropQual( L"TestQualProp", L"DWORDArrayQual", 0L, sizeof(pArray), NULL, NULL, &uUsed, &pArray );

		DWORD	dwNumElements = 0;
		DWORD	dwTest = 0;
		DWORD	dwData = 0;
		DWORD	dwNumReturned = 0;
		DWORD	uBuffUsed = 0;

		if ( SUCCEEDED( hrTest ) )
		{
			OutputDebugString( "Getting DWORD Array Property Qualifier Succeeded!\n" );

			ULONG	uFlags = NULL;

			for ( ULONG x = 0; SUCCEEDED(hrTest) && x < 13; x++ )
			{
				hrTest = pArray->GetAt( 0L, x, 1, sizeof(DWORD), &dwNumReturned, &uBuffUsed, &dwData );
			}

			if ( SUCCEEDED( hrTest ) )
			{
				OutputDebugString( "Getting Array Property Element Succeeded!\n" );

				DWORD	dwTestProp = 666;
				hrTest = pArray->SetAt( 0L, 7, 1, sizeof(dwTestProp), &dwTestProp );

				if ( SUCCEEDED( hrTest ) )
				{
					hrTest = pArray->GetAt( 0L, 7, 1, sizeof(DWORD), &dwNumReturned, &uBuffUsed, &dwData );

					if ( SUCCEEDED( hrTest ) )
					{
						if ( dwTestProp != dwData )
						{
							DebugBreak();
						}
					}
					else
					{
						DebugBreak();
					}
				}
				else
				{
					DebugBreak();
				}
			}

			if ( SUCCEEDED( hrTest ) )
			{
				OutputDebugString( "Testing Appending an array of DWORD elements\n" );

				DWORD	adwValues[10];

				for ( DWORD x = 33; x < 43; x++ )
				{
					adwValues[x-33] = x;
				}

				hrTest = pArray->Append( 0L, 10, sizeof(DWORD) * 10, adwValues );

				if ( SUCCEEDED( hrTest ) )
				{
					// Get an element and see if it's what we expect
					hrTest = pArray->GetAt( 0L, 15, 1, sizeof(DWORD), &dwNumReturned, &uBuffUsed, &dwData );

					if ( SUCCEEDED( hrTest ) )
					{
						if ( adwValues[2] != dwData )
						{
							DebugBreak();
						}

						OutputDebugString( "Testing Removing a range of DWORD elements\n" );

						// Remove a range from the middle of the array, and then get an element and
						// see if we have a match
						hrTest = pArray->RemoveAt( 0L, 15, 3 );

						if ( SUCCEEDED( hrTest ) )
						{
							hrTest = pArray->GetAt( 0L, 15, 1, sizeof(DWORD), &dwNumReturned, &uBuffUsed, &dwData );

							if ( adwValues[5] != dwData )
							{
								DebugBreak();
							}

						}
						else
						{
							DebugBreak();
						}
					}
					else
					{
						DebugBreak();
					}

				}
				else
				{
					DebugBreak();
				}

			}

			pArray->Release();

		}


	}

	return hrTest;
}

HRESULT TestWmiPropertyQualifierStringArray( _IWmiObject* pObj )
{
	HRESULT	hrTest = WBEM_S_NO_ERROR;

	WCHAR	wcsTest[512];
	WCHAR*	pTemp = wcsTest;
	ULONG	uBuffLen =0;

	// Create a linear array
	for ( long x = 10; SUCCEEDED(hrTest) && x < 23; x++ )
	{
		WCHAR	wcsValue[32];

		swprintf( wcsValue, L"TestString%d", x );
		wcscpy( pTemp, wcsValue );

		uBuffLen += ( ( wcslen( pTemp ) + 1 ) * 2 );
		pTemp += (wcslen( pTemp ) + 1);
	}

	hrTest = pObj->SetPropQual( L"TestQualProp", L"StringArrayQual", 0L, uBuffLen, 13, CIM_STRING | CIM_FLAG_ARRAY,
							0L, wcsTest );

	if ( SUCCEEDED( hrTest ) )
	{
		OutputDebugString( "Putting String Array Property Qualifier Succeeded!\n" );

		_IWmiArray*	pArray = NULL;
		ULONG uUsed = 0;

		hrTest = pObj->GetPropQual( L"TestQualProp", L"StringArrayQual", 0L, sizeof(pArray), NULL, NULL, &uUsed, &pArray );

		DWORD	dwNumElements = 0;
		DWORD	dwTest = 0;
		DWORD	dwData = 0;
		DWORD	dwNumReturned = 0;
		DWORD	uBuffUsed = 0;

		if ( SUCCEEDED( hrTest ) )
		{
			OutputDebugString( "Getting String Array Property Qualifier Succeeded!\n" );

			WCHAR	wcsData[512];
			ULONG	uFlags = NULL;

			for ( ULONG x = 0; SUCCEEDED(hrTest) && x < 13; x++ )
			{
				hrTest = pArray->GetAt( 0L, x, 1, sizeof(wcsData), &dwNumReturned, &uBuffUsed, wcsData );
			}

			if ( SUCCEEDED( hrTest ) )
			{
				OutputDebugString( "Getting Array Property Element Succeeded!\n" );

				char	szAsciiValue[256];
				WCHAR	wszNewValue[256];

				wcscpy( wszNewValue, L"01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789");

				// Testing Set/Get Element
				hrTest = pArray->SetAt( 0L, 7, 1, (wcslen(wszNewValue)+1)*2, wszNewValue );

				if ( SUCCEEDED( hrTest ) )
				{
					hrTest = pArray->GetAt( 0L, 7, 1, sizeof(wcsData), &dwNumReturned, &uBuffUsed, wcsData );

					if ( SUCCEEDED( hrTest ) )
					{
						if ( wcscmp( wszNewValue, wcsData ) != 0 )
						{
							DebugBreak();
						}
					}
					else
					{
						DebugBreak();
					}

				}
				else
				{
					DebugBreak();
				}

			}

			if ( SUCCEEDED( hrTest ) )
			{
				OutputDebugString( "Testing Appending an array of String elements\n" );

				LPWSTR	pwcsTemp = new WCHAR[128];
				char	szVal[128];

				wcscpy( pwcsTemp, L"9876543210" );
				wcscpy( pwcsTemp + 11, L"abcdefghijklmnopqrstuvwxyz" );

				hrTest = pArray->Append( 0L, 2, 76, pwcsTemp );

				if ( SUCCEEDED( hrTest ) )
				{
					// Get an element and see if it's what we expect
					hrTest = pArray->GetAt( 0L, 14, 1, sizeof(wcsData), &dwNumReturned, &uBuffUsed, wcsData );

					if ( SUCCEEDED( hrTest ) )
					{
						if ( wcscmp( wcsData, pwcsTemp + 11 ) != 0 )
						{
							DebugBreak();
						}

						OutputDebugString( "Testing Removing a range of String elements\n" );

						// Remove a range from the middle of the array, and then get an element and
						// see if we have a match
						hrTest = pArray->RemoveAt( 0L, 7, 3 );

						if ( SUCCEEDED( hrTest ) )
						{
							hrTest = pArray->GetAt( 0L, 7, 1, sizeof(wcsData), &dwNumReturned, &uBuffUsed, wcsData );

							if ( wcscmp( L"TestString20", wcsData ) )
							{
								DebugBreak();
							}

						}
						else
						{
							DebugBreak();
						}
					}
					else
					{
						DebugBreak();
					}

				}
				else
				{
					DebugBreak();
				}

			}

			pArray->Release();

		}


	}

	return hrTest;
}

HRESULT TestQueryObjectInfo( _IWmiObject* pObj )
{
	unsigned __int64 nMask = WMIOBJECT_GETOBJECT_LOFLAG_ALL;
	unsigned __int64 nValues = 0;

	BOOL	fFlag = VARIANT_TRUE;

	HRESULT hr = pObj->SetObjQual( L"Association", 0L, sizeof(BOOL), 0, CIM_BOOLEAN, 0L, &fFlag );

	if ( SUCCEEDED( hr ) )
	{
		hr = pObj->QueryObjectFlags( 0L, nMask, &nValues );
	}

	return hr;
}


HRESULT TestUnmergeMergeClass( IWbemClassObject** ppObj )
{
	LPMEMORY	pbData = NULL;
	length_t	nLength = 0;

	HRESULT hr = TestUnmerge( *ppObj, &pbData, &nLength );

	if ( SUCCEEDED( hr ) )
	{
		CWbemClass*	pRebuiltClass = NULL;

		hr = TestMergeClass( NULL, pbData, &pRebuiltClass );

		if ( SUCCEEDED( hr ) )
		{
			(*ppObj)->Release();
			*ppObj = (IWbemClassObject*) pRebuiltClass;
		}
	}

	return hr;
}

HRESULT TestFreeFormObject( void )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	_IWmiObjectFactory*	pFactory = NULL;

	hr = CoCreateInstance( CLSID__WmiObjectFactory, NULL, CLSCTX_INPROC_SERVER, IID__IWmiObjectFactory, (void**) &pFactory );

	if ( SUCCEEDED( hr ) )
	{
		_IWmiFreeFormObject*	pFFObject = NULL;

		hr = pFactory->Create( NULL, 0L, CLSID__WmiFreeFormObject, IID__IWmiFreeFormObject, (void**) &pFFObject );

		if ( SUCCEEDED( hr ) )
		{
			WCHAR	wszHierarchy[128];
			WCHAR*	pwszHierarchy = wszHierarchy;

			wcscpy( pwszHierarchy, L"ClassA" );
			wcscpy( &pwszHierarchy[7], L"ClassB" );

			_IWmiObject*	pWmiObject = NULL;

			hr = pFFObject->QueryInterface( IID__IWmiObject, (void**) &pWmiObject );

			hr = pFFObject->AddProperty( L"TestPropA", WMIOBJECT_FREEFORM_FLAG_WRITE_TO_INSTANCE, 0L, 0L, CIM_UINT32, NULL );

			hr = pFFObject->SetDerivation( 0L, 2, wszHierarchy );

			hr = pFFObject->SetClassName( 0L, L"ClassC" );

			DWORD	dwVal = 0;
			hr = pFFObject->AddProperty( L"TestPropA", WMIOBJECT_FREEFORM_FLAG_WRITE_TO_INSTANCE, sizeof(DWORD), 0L, CIM_UINT32, &dwVal );

			hr = pFFObject->AddProperty( L"TestPropB", WMIOBJECT_FREEFORM_FLAG_WRITE_TO_INSTANCE, sizeof(DWORD), 0L, CIM_UINT32, &dwVal );

			hr = pWmiObject->BeginEnumeration( WBEM_FLAG_CLASS_LOCAL_AND_OVERRIDES );
//			hr = pWmiObject->BeginEnumerationEx( WBEM_FLAG_CLASS_LOCAL_AND_OVERRIDES, WMIOBJECT_BEGINENUMEX_FLAG_GETEXTPROPS );

			while ( hr == S_OK )
			{
				BSTR	bstrName = NULL;
				hr = pWmiObject->Next( 0L, &bstrName, NULL, NULL, NULL );

				if ( NULL != bstrName )
				{
					SysFreeString( bstrName );
				}
			}

			long	lHandle;

			hr = pWmiObject->GetPropertyHandleEx( L"__TC", 0L, NULL, &lHandle );
			hr = pWmiObject->GetPropertyHandleEx( L"__TE", 0L, NULL, &lHandle );
			hr = pWmiObject->GetPropertyHandleEx( L"__TM", 0L, NULL, &lHandle );

			hr = pFFObject->Reset( 0L );

			hr = pFFObject->MakeInstance( 0L );

			pWmiObject->Release();

			pFFObject->Release();
		}

		pFactory->Release();
	}

	return hr;
}

HRESULT TestEmptyClassObject( void )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	_IWmiObjectFactory*	pFactory = NULL;

	hr = CoCreateInstance( CLSID__WmiObjectFactory, NULL, CLSCTX_INPROC_SERVER, IID__IWmiObjectFactory, (void**) &pFactory );

	if ( SUCCEEDED( hr ) )
	{
		_IWmiObject*	pWmiObj = NULL;

		hr = pFactory->Create( NULL, 0L, CLSID__WbemEmptyClassObject, IID__IWmiObject, (void**) &pWmiObj );

		if ( SUCCEEDED( hr ) )
		{
			pWmiObj->Release();
		}

		pFactory->Release();
	}

	return hr;
}


HRESULT TestTextSourceObject( void )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	IWbemObjectTextSrc*	pTextSrc = NULL;

	hr = CoCreateInstance( CLSID_WbemObjectTextSrc, NULL, CLSCTX_INPROC_SERVER, IID_IWbemObjectTextSrc, (void**) &pTextSrc );

	if ( SUCCEEDED( hr ) )
	{
		hr = pTextSrc->GetText( 0L, NULL, 0L, NULL, NULL ); 
		pTextSrc->Release();
	}

	return hr;
}

HRESULT TestSubsetCode( void )
{
	_IWmiObject*	pWbemClassObject = NULL;

	HRESULT	hr = CoCreateInstance( CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, IID__IWmiObject, (void**) &pWbemClassObject );

	if ( SUCCEEDED( hr ) )
	{
		CIMTYPE	ct;
		BOOL	fIsNull = 0;
		DWORD	dwBuffSizeUsed = 0;
		hr = pWbemClassObject->ReadProp( L"__CLASS", 0L, 0L, &ct, NULL, &fIsNull, &dwBuffSizeUsed, NULL );

		hr = pWbemClassObject->WriteProp( L"__CLASS", 0L, 14, 0L, CIM_STRING, L"ClassA" );

		hr = pWbemClassObject->ReadProp( L"__CLASS", 0L, 0L, &ct, NULL, &fIsNull, &dwBuffSizeUsed, NULL );

		hr = pWbemClassObject->ReadProp( L"__RELPATH", 0L, 0L, &ct, NULL, &fIsNull, &dwBuffSizeUsed, NULL );

		// Now write about fifty UINT32 properties into it
		for ( int x = 0; SUCCEEDED( hr ) && x < 50; x++ )
		{
			WCHAR	szName[32];

			swprintf( szName, L"TestProperty%d", x );

			hr = pWbemClassObject->WriteProp( szName, 0L, 0L, 0L, CIM_UINT32, 0L );
		}
		
		if ( SUCCEEDED( hr ) )
		{
			LPCWSTR	pwszNames[4] = {L"TestProperty1", L"TestProperty12", L"TestProperty14", L"TestProperty5"};

			_IWmiObject*	pLimitedObj = NULL;

			hr = pWbemClassObject->GetClassSubset( 4, pwszNames, &pLimitedObj );

			// Test the spawn instance
			if ( SUCCEEDED( hr ) )
			{
				_IWmiObject*	pInst = NULL;

				hr = pLimitedObj->SpawnInstance( 0L, (IWbemClassObject**) &pInst );

				if ( SUCCEEDED( hr ) )
				{
					DWORD	dwVal = 123456;

					hr = pInst->WriteProp( L"TestProperty1", 0L, sizeof(DWORD), 0L, CIM_UINT32, &dwVal );
					if ( FAILED( hr ) )
					{
						DebugBreak();
					}

					hr = pInst->WriteProp( L"TestProperty12", 0L, sizeof(DWORD), 0L, CIM_UINT32, &dwVal );
					if ( FAILED( hr ) )
					{
						DebugBreak();
					}

					hr = pInst->WriteProp( L"TestProperty14", 0L, sizeof(DWORD), 0L, CIM_UINT32, &dwVal );
					if ( FAILED( hr ) )
					{
						DebugBreak();
					}

					hr = pInst->WriteProp( L"TestProperty5", 0L, sizeof(DWORD), 0L, CIM_UINT32, &dwVal );
					if ( FAILED( hr ) )
					{
						DebugBreak();
					}

					// This should fail
					hr = pInst->WriteProp( L"TestProperty6", 0L, sizeof(DWORD), 0L, CIM_UINT32, &dwVal );
					if ( SUCCEEDED( hr ) )
					{
						DebugBreak();
					}

					DWORD	dwTest = 0;
					DWORD	dwSizeUsed = 0;
					BOOL	fIsNull = FALSE;

					hr = pInst->ReadProp( L"TestProperty5", 0L, sizeof(DWORD), NULL, NULL, &fIsNull, &dwSizeUsed, &dwTest );

					if ( dwTest != dwVal )
					{
						DebugBreak();
					}

					pInst->Release();
				}

				// Test the spawn of a full instance
				if ( SUCCEEDED( hr ) )
				{
					_IWmiObject*	pInst = NULL;

					hr = pWbemClassObject->SpawnInstance( 0L, (IWbemClassObject**) &pInst );

					if ( SUCCEEDED( hr ) )
					{

						// Now fill out fifty UINT32 properties into it
						for ( int x = 0; SUCCEEDED( hr ) && x < 50; x++ )
						{
							WCHAR	szName[32];

							swprintf( szName, L"TestProperty%d", x );

							hr = pInst->WriteProp( szName, 0L, sizeof(x), 0L, CIM_UINT32, &x );
						}

						if ( SUCCEEDED( hr ) )
						{

							// Now make a limited instance and read the property
							_IWmiObject*	pLimitedInst = NULL;

							hr = pLimitedObj->MakeSubsetInst( pInst, &pLimitedInst );

							if ( SUCCEEDED( hr ) )
							{
								DWORD	dwTest = 0;
								DWORD	dwSizeUsed = 0;
								BOOL	fIsNull = FALSE;

								hr = pLimitedInst->ReadProp( L"TestProperty5", 0L, sizeof(DWORD), NULL, NULL, &fIsNull, &dwSizeUsed, &dwTest );

								if ( dwTest != 5 )
								{
									DebugBreak();
								}

								pLimitedInst->Release();
							}
						}
						else
						{
							DebugBreak();
						}

						pInst->Release();

					}

				}	// Testing a full instance chopping

			}

			pLimitedObj->Release();

		}

		pWbemClassObject->Release();

	}

	return hr;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	main
//
//	Entry point function to exercise _IWmiObject interface.
//
///////////////////////////////////////////////////////////////////

void __cdecl main( void )
{
	CoInitializeEx( 0, COINIT_MULTITHREADED );

	// Create a new Wbem class object
	IWbemClassObject*	pWbemClassObject = NULL;

	OutputDebugString( "Creating initial IWbemClassObject.\n" );
	HRESULT	hr = CoCreateInstance( CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, IID_IWbemClassObject, (void**) &pWbemClassObject );
//	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( FAILED( hr ) )
	{
		DebugBreak();
	}

	_IWmiObject*	pTest = (_IWmiObject*) pWbemClassObject;

	_IWbemRefresherMgr* pMgr = NULL;
	hr = CoCreateInstance( CLSID__WbemRefresherMgr, NULL, CLSCTX_INPROC_SERVER, IID__IWbemRefresherMgr, (void**) &pMgr );

	TestEmptyClassObject();

	OutputDebugString( "Created initial IWbemClassObject.\n" );
//	CWbemClass* pObj = new CWbemClass;
	
//	pObj->InitEmpty( 10 );

	OutputDebugString( "Created empty object.\n" );

//	pWbemClassObject = pObj;

//	printf( "CoCreateInstance() returned: %d\n", hr );

	OutputDebugString( "Testing Free Form Object.\n" );
	TestFreeFormObject();
	OutputDebugString( "Finished Testing Free Form Object.\n\n" );

	OutputDebugString( "Testing Text Source Object.\n" );
	TestTextSourceObject();
	OutputDebugString( "Finished Testing Text Source Object.\n\n" );

	OutputDebugString( "Testing Object Subset.\n" );
	TestSubsetCode();
	OutputDebugString( "Finished Testing Object Subset.\n\n" );

	if ( SUCCEEDED(hr) )
	{

		// We need a class name to be able to spawn instances
		hr = SetupClassObject( pWbemClassObject );

		if ( SUCCEEDED( hr ) )
		{

			hr = TestUnmergeMergeClass( &pWbemClassObject );


			OutputDebugString ("Testing WMI Object DWORD Array\n");
			hr = TestWmiObjectDWORDArray( (_IWmiObject*) pWbemClassObject );
			OutputDebugString ("Finished Testing WMI Object DWORD Array\n");

			OutputDebugString ("Testing WMI Object String Array\n");
			hr = TestWmiObjectStringArray( (_IWmiObject*) pWbemClassObject );
			OutputDebugString ("Finished Testing WMI Object String Array\n");

			OutputDebugString ("Testing WMI Qualifier DWORD Array\n");
			hr = TestWmiObjectQualifiers( (_IWmiObject*) pWbemClassObject );
			OutputDebugString ("Finished Testing WMI Qualifier DWORD Array\n");

			OutputDebugString ("Testing WMI Qualifier DWORD Array\n");
			hr = TestWmiQualifierDWORDArray( (_IWmiObject*) pWbemClassObject );
			OutputDebugString ("Finished Testing WMI Qualifier DWORD Array\n");

			OutputDebugString ("Testing WMI Qualifier DWORD Array\n");
			hr = TestWmiQualifierStringArray( (_IWmiObject*) pWbemClassObject );
			OutputDebugString ("Finished Testing WMI Qualifier DWORD Array\n");

			OutputDebugString("Testing WMI Object Qualifiers\n" );
			TestWmiObjectQualifiers( (_IWmiObject*) pWbemClassObject );
			OutputDebugString("Finished Testing WMI Object Qualifiers\n" );

			OutputDebugString("Testing WMI Property Qualifiers\n" );
			TestWmiPropertyQualifiers( (_IWmiObject*) pWbemClassObject );
			OutputDebugString("Finished Testing WMI Property Qualifiers\n" );

			OutputDebugString("Testing WMI Property DWORD Qualifiers\n" );
			TestWmiPropertyDWORDQualifiers( (_IWmiObject*) pWbemClassObject );
			OutputDebugString("Finished Testing WMI Property Qualifiers\n" );

			OutputDebugString("Testing WMI Property String Qualifiers\n" );
			TestWmiPropertyQualifierStringArray( (_IWmiObject*) pWbemClassObject );
			OutputDebugString("Finished Testing WMI String Qualifiers\n" );

			OutputDebugString("Testing Query Object Info\n" );
			TestQueryObjectInfo( (_IWmiObject*) pWbemClassObject );
			OutputDebugString("Finished Testing QueryObjectInfo\n" );

			IWbemClassObject*	pWbemInstance1 = NULL;
			IWbemClassObject*	pWbemInstance2 = NULL;

			// We need three instances to work with
			hr = SpawnInstance( pWbemClassObject, &pWbemInstance1, 1 );

			// Verify Instance 1 if we got it.
			if ( SUCCEEDED( hr ) )
			{
				OutputDebugString ("Verifying Instance 1\n");
				VerifyInstance( pWbemInstance1 );

				hr = TestGetSetClassPart( pWbemInstance1 );
			}

			if ( SUCCEEDED( hr ) )
			{
				hr = SpawnInstance( pWbemClassObject, &pWbemInstance2, 2 );

				_IWmiObject*	pObj = NULL;

				pWbemInstance2->Clone( (IWbemClassObject**) &pObj );

				DWORD	dwDataSize = 0;

				hr = pObj->GetObjectMemory( NULL, 0, &dwDataSize );

				{
					DWORD	dwSizeUsed = 0;
					LPBYTE	pbData = (LPBYTE) CoTaskMemAlloc( dwDataSize );

					hr = pObj->GetObjectMemory( pbData, dwDataSize, &dwSizeUsed );

					if ( SUCCEEDED( hr ) )
					{
						hr = pObj->SetObjectMemory( pbData, dwDataSize );
					}

				}

				// Merge Instance1's class part into this one.
				if ( SUCCEEDED( hr ) )
				{
					hr = TestMergeClassPart( pWbemInstance2, pWbemInstance1 );

					if ( SUCCEEDED( hr ) )
					{
						// Use the merged instance for cloning and spawning
						// to make sure things are on the up and up.

						OutputDebugString( "Cloning Instance 1\n" );
						TestClone( pWbemInstance1 );

						OutputDebugString( "Cloning Instance 2\n" );
						TestClone( pWbemInstance2 );

						OutputDebugString( "Spawning Instance from Instance 2\n" );
						TestSpawnInstance( pWbemInstance2 );

					}	// IF TestMergeClassPart() SUCCEEDED

				}	// IF SpawnInstance()  SUCCEEDED

			}	// IF TestGetSetClassPart() and SpawnInstance() SUCCEEDED

			// Clean up our instances
			if ( NULL != pWbemInstance1 )
			{
				pWbemInstance1->Release();
			}

			if ( NULL != pWbemInstance2 )
			{
				pWbemInstance2->Release();
			}

		}

		pWbemClassObject->Release();
	}

	CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\pktsecuritytest\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>

#define COREPOL_HEADERFILE_IS_INCLUDED

#define COREPROX_POLARITY __declspec( dllimport )
#define ESSLIB_POLARITY __declspec( dllimport )

#define COREPOL_HEADERFILE_IS_INCLUDED
#define POLARITY_HEADERFILE_IS_INCLUDED
#define POLARITY __declspec( dllimport )

#include "arena.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\perfsrv\perfsrvidl.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Sun Jan 10 17:36:29 1999
 */
/* Compiler settings for perfsrvidl.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __perfsrvidl_h__
#define __perfsrvidl_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IPerfCounter_FWD_DEFINED__
#define __IPerfCounter_FWD_DEFINED__
typedef interface IPerfCounter IPerfCounter;
#endif 	/* __IPerfCounter_FWD_DEFINED__ */


#ifndef __IPerfInstance_FWD_DEFINED__
#define __IPerfInstance_FWD_DEFINED__
typedef interface IPerfInstance IPerfInstance;
#endif 	/* __IPerfInstance_FWD_DEFINED__ */


#ifndef __IPerfObject_FWD_DEFINED__
#define __IPerfObject_FWD_DEFINED__
typedef interface IPerfObject IPerfObject;
#endif 	/* __IPerfObject_FWD_DEFINED__ */


#ifndef __IPerfBlock_FWD_DEFINED__
#define __IPerfBlock_FWD_DEFINED__
typedef interface IPerfBlock IPerfBlock;
#endif 	/* __IPerfBlock_FWD_DEFINED__ */


#ifndef __IPerfService_FWD_DEFINED__
#define __IPerfService_FWD_DEFINED__
typedef interface IPerfService IPerfService;
#endif 	/* __IPerfService_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_perfsrvidl_0000
 * at Sun Jan 10 17:36:29 1999
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


typedef 
enum _PERF_ENUM_TYPE
    {	PERF_ENUM_ALL	= 0,
	PERF_ENUM_GLOBAL	= PERF_ENUM_ALL + 1,
	PERF_ENUM_COSTLY	= PERF_ENUM_GLOBAL + 1
    }	PERF_ENUM_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_perfsrvidl_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_perfsrvidl_0000_v0_0_s_ifspec;

#ifndef __IPerfCounter_INTERFACE_DEFINED__
#define __IPerfCounter_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPerfCounter
 * at Sun Jan 10 17:36:29 1999
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IPerfCounter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("FC5B80C4-A4DC-11d2-B348-00105A1469B7")
    IPerfCounter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ BSTR __RPC_FAR *pstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDataString( 
            /* [in] */ IPerfCounter __RPC_FAR *pCtr,
            /* [out] */ BSTR __RPC_FAR *pstrData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPerfCounterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPerfCounter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPerfCounter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPerfCounter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IPerfCounter __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDataString )( 
            IPerfCounter __RPC_FAR * This,
            /* [in] */ IPerfCounter __RPC_FAR *pCtr,
            /* [out] */ BSTR __RPC_FAR *pstrData);
        
        END_INTERFACE
    } IPerfCounterVtbl;

    interface IPerfCounter
    {
        CONST_VTBL struct IPerfCounterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPerfCounter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPerfCounter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPerfCounter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPerfCounter_GetName(This,pstrName)	\
    (This)->lpVtbl -> GetName(This,pstrName)

#define IPerfCounter_GetDataString(This,pCtr,pstrData)	\
    (This)->lpVtbl -> GetDataString(This,pCtr,pstrData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPerfCounter_GetName_Proxy( 
    IPerfCounter __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pstrName);


void __RPC_STUB IPerfCounter_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPerfCounter_GetDataString_Proxy( 
    IPerfCounter __RPC_FAR * This,
    /* [in] */ IPerfCounter __RPC_FAR *pCtr,
    /* [out] */ BSTR __RPC_FAR *pstrData);


void __RPC_STUB IPerfCounter_GetDataString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPerfCounter_INTERFACE_DEFINED__ */


#ifndef __IPerfInstance_INTERFACE_DEFINED__
#define __IPerfInstance_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPerfInstance
 * at Sun Jan 10 17:36:29 1999
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IPerfInstance;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("FC5B80C2-A4DC-11d2-B348-00105A1469B7")
    IPerfInstance : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ BSTR __RPC_FAR *pstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginEnum( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [out] */ IPerfCounter __RPC_FAR *__RPC_FAR *ppPerfCounter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndEnum( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPerfInstanceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPerfInstance __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPerfInstance __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPerfInstance __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IPerfInstance __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginEnum )( 
            IPerfInstance __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IPerfInstance __RPC_FAR * This,
            /* [out] */ IPerfCounter __RPC_FAR *__RPC_FAR *ppPerfCounter);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndEnum )( 
            IPerfInstance __RPC_FAR * This);
        
        END_INTERFACE
    } IPerfInstanceVtbl;

    interface IPerfInstance
    {
        CONST_VTBL struct IPerfInstanceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPerfInstance_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPerfInstance_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPerfInstance_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPerfInstance_GetName(This,pstrName)	\
    (This)->lpVtbl -> GetName(This,pstrName)

#define IPerfInstance_BeginEnum(This)	\
    (This)->lpVtbl -> BeginEnum(This)

#define IPerfInstance_Next(This,ppPerfCounter)	\
    (This)->lpVtbl -> Next(This,ppPerfCounter)

#define IPerfInstance_EndEnum(This)	\
    (This)->lpVtbl -> EndEnum(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPerfInstance_GetName_Proxy( 
    IPerfInstance __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pstrName);


void __RPC_STUB IPerfInstance_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPerfInstance_BeginEnum_Proxy( 
    IPerfInstance __RPC_FAR * This);


void __RPC_STUB IPerfInstance_BeginEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPerfInstance_Next_Proxy( 
    IPerfInstance __RPC_FAR * This,
    /* [out] */ IPerfCounter __RPC_FAR *__RPC_FAR *ppPerfCounter);


void __RPC_STUB IPerfInstance_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPerfInstance_EndEnum_Proxy( 
    IPerfInstance __RPC_FAR * This);


void __RPC_STUB IPerfInstance_EndEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPerfInstance_INTERFACE_DEFINED__ */


#ifndef __IPerfObject_INTERFACE_DEFINED__
#define __IPerfObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPerfObject
 * at Sun Jan 10 17:36:29 1999
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IPerfObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("FC5B80C3-A4DC-11d2-B348-00105A1469B7")
    IPerfObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetID( 
            /* [out] */ long __RPC_FAR *plID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ BSTR __RPC_FAR *pstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginEnum( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [out] */ IPerfInstance __RPC_FAR *__RPC_FAR *ppPerfInstance) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndEnum( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPerfObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPerfObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPerfObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPerfObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetID )( 
            IPerfObject __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *plID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IPerfObject __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginEnum )( 
            IPerfObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IPerfObject __RPC_FAR * This,
            /* [out] */ IPerfInstance __RPC_FAR *__RPC_FAR *ppPerfInstance);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndEnum )( 
            IPerfObject __RPC_FAR * This);
        
        END_INTERFACE
    } IPerfObjectVtbl;

    interface IPerfObject
    {
        CONST_VTBL struct IPerfObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPerfObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPerfObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPerfObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPerfObject_GetID(This,plID)	\
    (This)->lpVtbl -> GetID(This,plID)

#define IPerfObject_GetName(This,pstrName)	\
    (This)->lpVtbl -> GetName(This,pstrName)

#define IPerfObject_BeginEnum(This)	\
    (This)->lpVtbl -> BeginEnum(This)

#define IPerfObject_Next(This,ppPerfInstance)	\
    (This)->lpVtbl -> Next(This,ppPerfInstance)

#define IPerfObject_EndEnum(This)	\
    (This)->lpVtbl -> EndEnum(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPerfObject_GetID_Proxy( 
    IPerfObject __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *plID);


void __RPC_STUB IPerfObject_GetID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPerfObject_GetName_Proxy( 
    IPerfObject __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pstrName);


void __RPC_STUB IPerfObject_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPerfObject_BeginEnum_Proxy( 
    IPerfObject __RPC_FAR * This);


void __RPC_STUB IPerfObject_BeginEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPerfObject_Next_Proxy( 
    IPerfObject __RPC_FAR * This,
    /* [out] */ IPerfInstance __RPC_FAR *__RPC_FAR *ppPerfInstance);


void __RPC_STUB IPerfObject_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPerfObject_EndEnum_Proxy( 
    IPerfObject __RPC_FAR * This);


void __RPC_STUB IPerfObject_EndEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPerfObject_INTERFACE_DEFINED__ */


#ifndef __IPerfBlock_INTERFACE_DEFINED__
#define __IPerfBlock_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPerfBlock
 * at Sun Jan 10 17:36:29 1999
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IPerfBlock;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("39FD6808-96BB-11d2-B346-00105A1469B7")
    IPerfBlock : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Update( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSysName( 
            /* [out] */ BSTR __RPC_FAR *pstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginEnum( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [out] */ IPerfObject __RPC_FAR *__RPC_FAR *ppPerfObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndEnum( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPerfBlockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPerfBlock __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPerfBlock __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPerfBlock __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Update )( 
            IPerfBlock __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSysName )( 
            IPerfBlock __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginEnum )( 
            IPerfBlock __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IPerfBlock __RPC_FAR * This,
            /* [out] */ IPerfObject __RPC_FAR *__RPC_FAR *ppPerfObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndEnum )( 
            IPerfBlock __RPC_FAR * This);
        
        END_INTERFACE
    } IPerfBlockVtbl;

    interface IPerfBlock
    {
        CONST_VTBL struct IPerfBlockVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPerfBlock_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPerfBlock_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPerfBlock_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPerfBlock_Update(This)	\
    (This)->lpVtbl -> Update(This)

#define IPerfBlock_GetSysName(This,pstrName)	\
    (This)->lpVtbl -> GetSysName(This,pstrName)

#define IPerfBlock_BeginEnum(This)	\
    (This)->lpVtbl -> BeginEnum(This)

#define IPerfBlock_Next(This,ppPerfObject)	\
    (This)->lpVtbl -> Next(This,ppPerfObject)

#define IPerfBlock_EndEnum(This)	\
    (This)->lpVtbl -> EndEnum(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPerfBlock_Update_Proxy( 
    IPerfBlock __RPC_FAR * This);


void __RPC_STUB IPerfBlock_Update_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPerfBlock_GetSysName_Proxy( 
    IPerfBlock __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pstrName);


void __RPC_STUB IPerfBlock_GetSysName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPerfBlock_BeginEnum_Proxy( 
    IPerfBlock __RPC_FAR * This);


void __RPC_STUB IPerfBlock_BeginEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPerfBlock_Next_Proxy( 
    IPerfBlock __RPC_FAR * This,
    /* [out] */ IPerfObject __RPC_FAR *__RPC_FAR *ppPerfObject);


void __RPC_STUB IPerfBlock_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPerfBlock_EndEnum_Proxy( 
    IPerfBlock __RPC_FAR * This);


void __RPC_STUB IPerfBlock_EndEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPerfBlock_INTERFACE_DEFINED__ */


#ifndef __IPerfService_INTERFACE_DEFINED__
#define __IPerfService_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPerfService
 * at Sun Jan 10 17:36:29 1999
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IPerfService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("111FFCBA-96B7-11d2-B346-00105A1469B7")
    IPerfService : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreatePerfBlock( 
            /* [in] */ long lNumIDs,
            /* [in] */ long __RPC_FAR *alID,
            /* [out] */ IPerfBlock __RPC_FAR *__RPC_FAR *ppPerfBlock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePerfBlockFromString( 
            /* [in] */ BSTR strIds,
            /* [out] */ IPerfBlock __RPC_FAR *__RPC_FAR *ppPerfBlock) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPerfServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPerfService __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPerfService __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPerfService __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePerfBlock )( 
            IPerfService __RPC_FAR * This,
            /* [in] */ long lNumIDs,
            /* [in] */ long __RPC_FAR *alID,
            /* [out] */ IPerfBlock __RPC_FAR *__RPC_FAR *ppPerfBlock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePerfBlockFromString )( 
            IPerfService __RPC_FAR * This,
            /* [in] */ BSTR strIds,
            /* [out] */ IPerfBlock __RPC_FAR *__RPC_FAR *ppPerfBlock);
        
        END_INTERFACE
    } IPerfServiceVtbl;

    interface IPerfService
    {
        CONST_VTBL struct IPerfServiceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPerfService_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPerfService_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPerfService_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPerfService_CreatePerfBlock(This,lNumIDs,alID,ppPerfBlock)	\
    (This)->lpVtbl -> CreatePerfBlock(This,lNumIDs,alID,ppPerfBlock)

#define IPerfService_CreatePerfBlockFromString(This,strIds,ppPerfBlock)	\
    (This)->lpVtbl -> CreatePerfBlockFromString(This,strIds,ppPerfBlock)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPerfService_CreatePerfBlock_Proxy( 
    IPerfService __RPC_FAR * This,
    /* [in] */ long lNumIDs,
    /* [in] */ long __RPC_FAR *alID,
    /* [out] */ IPerfBlock __RPC_FAR *__RPC_FAR *ppPerfBlock);


void __RPC_STUB IPerfService_CreatePerfBlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPerfService_CreatePerfBlockFromString_Proxy( 
    IPerfService __RPC_FAR * This,
    /* [in] */ BSTR strIds,
    /* [out] */ IPerfBlock __RPC_FAR *__RPC_FAR *ppPerfBlock);


void __RPC_STUB IPerfService_CreatePerfBlockFromString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPerfService_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\refreshertest\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>

#define COREPOL_HEADERFILE_IS_INCLUDED

#define COREPROX_POLARITY __declspec( dllimport )
#define ESSLIB_POLARITY __declspec( dllimport )

#define COREPOL_HEADERFILE_IS_INCLUDED
#define POLARITY_HEADERFILE_IS_INCLUDED
#define POLARITY __declspec( dllimport )

#include "arena.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\perfsrv\perfsrv.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//**************************************************************************
//
//
//		PerfSrv.h
//
//		
//**************************************************************************

#define UNICODE
#define _UNICODE

#ifndef _PERFSRV_H_
#define _PERFSRV_H_

#include <unk.h>
#include "perfsrvidl.h"

class CTitleLibrary
{
protected:
	TCHAR*	m_tcsDataBlock;		// The title / index data block
	TCHAR**	m_atcsNames;		// The lookup table w/ pointers indexed into the data block
	long	m_lMaxIndex;		// The upper index limit

	HRESULT Initialize();

public:
	CTitleLibrary();
	~CTitleLibrary();

	HRESULT GetName (long lID, TCHAR** ptcsName);
};

class CPerfSrv : public CUnk
{
public:
	CPerfSrv(CLifeControl *pControl) : 
	  CUnk(pControl), m_XPerfService(this) {}

protected:

// =======================================================================
//
//						COM objects
//
// =======================================================================

	virtual void* GetInterface(REFIID riid);

	class XPerfService : public CImpl<IPerfService, CPerfSrv>
	{
	public:
		XPerfService(CPerfSrv* pObject) : 
		  CImpl<IPerfService, CPerfSrv>(pObject) {}

		STDMETHOD(CreatePerfBlockFromString)(
			/*[in]*/ BSTR strIDs, 
			/*[out]*/ IPerfBlock **ppPerfBlock);
		STDMETHOD(CreatePerfBlock)(
			/*[in]*/ long lNumIDs, 
			/*[in]*/ long *alID, 
			/*[out]*/ IPerfBlock **ppPerfBlock);
	} m_XPerfService;
	friend XPerfService;

};

class CPerfBlock;

class CPerfCounter : public IPerfCounter
{
	long				m_lRef;

	PERF_COUNTER_DEFINITION*	m_pCounterData;
	BYTE*						m_pData;
	DWORD						m_dwDataLen;

	CPerfBlock*			m_pPerfBlock;

public:
	CPerfCounter(PERF_COUNTER_DEFINITION* pCounterData, PBYTE pData, DWORD dwDataLen, CPerfBlock* pPerfBlock);
	~CPerfCounter();

	CPerfBlock* GetPerfBlock() {return m_pPerfBlock;}

	STDMETHOD(QueryInterface)(REFIID riid, void** ppv);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	HRESULT GetType(long* plType);
	HRESULT GetData(byte** ppData);

	STDMETHOD(GetName)(BSTR* pstrName);
	STDMETHOD(GetDataString)(IPerfCounter* pICtr, BSTR *pstrData);
};

class CPerfInstance : public IPerfInstance
{
	long				m_lRef;

	PERF_INSTANCE_DEFINITION*	m_pInstData;
	PERF_COUNTER_DEFINITION*	m_pCtrDefn;
	long						m_lNumCtrs;

	long						m_lCurrentCounter;
	PERF_COUNTER_DEFINITION*	m_pCurrentCounter;

	CPerfBlock*					m_pPerfBlock;

	BOOL						m_bEmpty;

public:
	CPerfInstance(PERF_INSTANCE_DEFINITION* pInstData, PERF_COUNTER_DEFINITION* pCtrDefn, long lNumCtrs, CPerfBlock* pPerfBlock, BOOL bEmpty) : 
		m_pInstData(pInstData),  m_pCtrDefn(pCtrDefn), m_lNumCtrs(lNumCtrs), m_pPerfBlock(pPerfBlock), m_bEmpty(bEmpty), m_lRef(1) {}

	CPerfBlock* GetPerfBlock() {return m_pPerfBlock;}

	STDMETHOD(QueryInterface)(REFIID riid, void** ppv);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	STDMETHOD(GetName)(BSTR* pstrName);

	STDMETHOD(BeginEnum)();
	STDMETHOD(Next)(IPerfCounter** ppCounter);
	STDMETHOD(EndEnum)();

};

class CPerfObject : public IPerfObject
{
	long				m_lRef;

	long				m_lCurrentInstance;
	PERF_INSTANCE_DEFINITION* m_pCurrentInstance;

	PERF_OBJECT_TYPE*	m_pObjectData;

	CPerfBlock*			m_pPerfBlock;

public:
	CPerfObject(PERF_OBJECT_TYPE* pObjectData, CPerfBlock* pPerfBlock) : 
	  m_pObjectData(pObjectData), m_pPerfBlock(pPerfBlock), m_lRef(0) {}

	CPerfBlock* GetPerfBlock() {return m_pPerfBlock;}

	STDMETHOD(QueryInterface)(REFIID riid, void** ppv);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	STDMETHOD(GetID)(long* plID);
	STDMETHOD(GetName)(BSTR* strName);

	STDMETHOD(BeginEnum)();
	STDMETHOD(Next)(IPerfInstance** ppInstance);
	STDMETHOD(EndEnum)();

};

class CPerfBlock : public IPerfBlock
{
	long				m_lRef;

	CTitleLibrary		m_TitleLibrary;

	long				m_lObjEnumCtr;
	DWORD				m_dwCurrentObject;
	PERF_OBJECT_TYPE*	m_pCurrentObject;

	IUnknown*			m_pServer;
	TCHAR				m_tcsIDs[1024];
	PPERF_DATA_BLOCK	m_pDataBlock;

protected:
	virtual void* GetInterface(REFIID riid){if (riid == IID_IPerfBlock) return this; return NULL;}

public:
	CPerfBlock(IUnknown* pSrv);
	~CPerfBlock();

	HRESULT Initialize(long lNumIDs, long *alID);
	HRESULT Initialize(BSTR strIDs);
	HRESULT GetPerfTime(__int64* pnTime);
	HRESULT GetPerfTime100nSec(__int64* pnTime);
	HRESULT GetPerfFreq(__int64* pnFreq);
	
	CTitleLibrary* GetLibrary() {return &m_TitleLibrary;}

    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
	STDMETHOD(Update)();
	STDMETHOD(GetSysName)(BSTR* pstrName);
	STDMETHOD(BeginEnum)();
	STDMETHOD(Next)(IPerfObject** ppObject);
	STDMETHOD(EndEnum)();
};

#endif //_PERFSRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\perfsrv\perfsrv.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//**************************************************************************
//
//
//							PerfSrv.cpp
//
//	Created by a-dcrews, 17-12-98
//
//	For further information on performance counters, see 'Under the Hood', 
//	Matt Pietrek, Microsoft System Journal, Oct/96, Nov/96
//
//**************************************************************************

#define _UNICODE
#define UNICODE

#include <windows.h>
#include <stdlib.h>
#include <tchar.h>
#include "PerfSrv.h"

#define PERFLIB	TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\PerfLib")



///////////////////////////////////////////////////////////////////////////////
//
//	CTitleLibrary
//
//	The CCtrLibrary object is an object that evaluates object and counter
//	titles based on their IDs.  The object uses a lookup table, where the 
//	elements reference strings in a block of ID / title pairs and the index
//	is the ID values of the object and counters.
//
///////////////////////////////////////////////////////////////////////////////

CTitleLibrary::CTitleLibrary()
///////////////////////////////////////////////////////////////////////////////
//
//	Constructor
//
///////////////////////////////////////////////////////////////////////////////
{
	Initialize();
}

CTitleLibrary::~CTitleLibrary()
///////////////////////////////////////////////////////////////////////////////
//
//	Destructor
//
///////////////////////////////////////////////////////////////////////////////
{
	if (m_tcsDataBlock)
		delete []m_tcsDataBlock;

	if (m_atcsNames)
		delete []m_atcsNames;
}

HRESULT CTitleLibrary::Initialize()
///////////////////////////////////////////////////////////////////////////////
//
//	Initialize
//
//	Sets up the lookup table for the library.  The titles are indexed by their
//	key ID values.
//
//	Determine the maximum index value of the titles.  Attempt to query the 
//	title/index pairs to determine how large of a block must be allocated to
//	accept the structure.  Create the block, and then query the title\index
//	pairs.  Create a lookup table the size of the maximum index, and populate 
//	it with the retrieved title data.
//
///////////////////////////////////////////////////////////////////////////////
{
	HKEY hKey = 0;

	// Get the upper index limit
	// =========================

	DWORD dwSize;

    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, PERFLIB,
									  0, KEY_READ, &hKey))
        return E_FAIL;

    if (ERROR_SUCCESS != RegQueryValueEx(hKey, TEXT("Last Counter"), 
										 0, 0, (PBYTE)&m_lMaxIndex, &dwSize))
    {
        RegCloseKey(hKey);
        return E_FAIL;
    }
    
    RegCloseKey(hKey);

	// Get the size of block required to retrieve the title / index pairs
	// ==================================================================

	if (ERROR_SUCCESS != RegQueryValueEx(HKEY_PERFORMANCE_DATA, TEXT("Counter009"), 
										 0, 0, 0, &dwSize))
		return E_FAIL;

	// Allocate the block, and retrieve the title / index pairs
	// ========================================================

	m_tcsDataBlock = new TCHAR[dwSize];

	if (ERROR_SUCCESS != RegQueryValueEx(HKEY_PERFORMANCE_DATA, TEXT("Counter009"), 
										 0, 0, (PBYTE)m_tcsDataBlock,	&dwSize))
	{
		delete []m_tcsDataBlock;
		return E_FAIL;
	}

	// Allocate and clear the memory for the lookup table
	// ==================================================

	m_atcsNames = new TCHAR*[m_lMaxIndex + 1];
    memset(m_atcsNames, 0, (sizeof(TCHAR*) * (m_lMaxIndex + 1)));

	// Populate the lookup table
	// =========================

    TCHAR* tcsTemp = m_tcsDataBlock;
    int nLen, nIndex;

    while ( 0 != (nLen = lstrlen(tcsTemp)))
    {
		// Get the index
		// =============

        nIndex = _ttoi(tcsTemp);
        tcsTemp += nLen + 1;

		// Set the table element at the index value to the string pointer 
		// ==============================================================

        m_atcsNames[nIndex] = tcsTemp;
        tcsTemp += lstrlen(tcsTemp) + 1;
    }

	return S_OK;
}

HRESULT CTitleLibrary::GetName(long lID, TCHAR** ptcsName)
///////////////////////////////////////////////////////////////////////////////
//
//	GetName
//
//	Evaluates the title given an object's or counter's ID.
//
//	Parameters:
//		lID			- the Index into the library
//		pstrName	- the Name
//
///////////////////////////////////////////////////////////////////////////////
{
	// Is it a valid index?
	// ====================

	if (lID > m_lMaxIndex)
		return E_INVALIDARG;
	
	// Assign the pointer
	// ==================

	*ptcsName = m_atcsNames[lID];

	return S_OK;
}



///////////////////////////////////////////////////////////////////////////////
//
//	PerfSrv
//
//	PerfSrv is the COM service class that contains the implementation of the 
//	main perfomance classes.
//
///////////////////////////////////////////////////////////////////////////////

void* CPerfSrv::GetInterface(REFIID riid)
///////////////////////////////////////////////////////////////////////////////
//
//	GetInterface
//
//	Virtual function override from CUnk.  Recieves an object interface ID and 
//	returns a pointer to the object. 
//
//	Parameter:
//		riid		- the interface id
//
///////////////////////////////////////////////////////////////////////////////
{
	if (IID_IPerfService == riid)
		return &m_XPerfService;

	return NULL;
}



///////////////////////////////////////////////////////////////////////////////
//
//	PerfSrv::XPerfService
//
//	The central COM object is the IPerfService object.  It has the 
//	capability of creating an IPerfBlock object.  
//
///////////////////////////////////////////////////////////////////////////////

HRESULT CPerfSrv::XPerfService::CreatePerfBlock(long lNumIDs, long *alID, IPerfBlock **ppPerfBlock)
///////////////////////////////////////////////////////////////////////////////
//
//	CreatePerfBlock
//
//	Creates a performace data block from the array of id's passed via alID.
//
//	Parameters:
//		lNumIDs		- number of ID's in the array
//		alID		- the ID array
//		ppPerfBlock	- a pointer to the perf data block object
//
///////////////////////////////////////////////////////////////////////////////
{
	// Initialize a new performance object
	// ===================================

	CPerfBlock *pBlock = new CPerfBlock((IUnknown*)this);
	pBlock->Initialize(lNumIDs, alID);

	// And pass it back
	// ================

	pBlock->AddRef();
	*ppPerfBlock = pBlock;

	return S_OK;
}

HRESULT CPerfSrv::XPerfService::CreatePerfBlockFromString(BSTR strIDs, IPerfBlock **ppPerfBlock)
///////////////////////////////////////////////////////////////////////////////
//
//	CreatePerfBlockFromString
//
//	Creates a performance data block from the string passed vis strIDs.
//
//	Parameters:
//		strIDs		- the string of object IDs
//		ppPerfBlock	- a pointer to the perf data block object
//
///////////////////////////////////////////////////////////////////////////////
{
	// Initialize a new performance object
	// ===================================

	CPerfBlock *pBlock = new CPerfBlock((IUnknown*)this);
	pBlock->Initialize(strIDs);

	// And pass it back
	// ================

	pBlock->AddRef();
	*ppPerfBlock = pBlock;

	return S_OK;
}



///////////////////////////////////////////////////////////////////////////////
//
//	PerfBlock
//
//	The IPerfBlock is a COM wrapper on the performance data block.  From the 
//	IPerfBlock, IPerfObjects can be enumerated.  Each IPerfObject either 
//	enumerates a set of IPerfInstances, or IPerfCounters if no instances 
//	exist.  If instances exist, then each IPerfInstance will enumerate 
//	several IPerfCounters.  Each IPerfCounter represents an data property 
//	of the object or instance.  Note that some data requires data sampled 
//	over a period of time, therefore, it may be necessary to pass two 
//	IPerfCounters of the same instance or object from two IPerfBlocks 
//	sampled at different times.
//
///////////////////////////////////////////////////////////////////////////////

CPerfBlock::CPerfBlock(IUnknown* pSrv) :
	m_lRef(0)
///////////////////////////////////////////////////////////////////////////////
//
//	Constructor
//
///////////////////////////////////////////////////////////////////////////////
{
	pSrv->AddRef();
	m_pServer = pSrv;

	*m_tcsIDs = 0;
	m_pDataBlock = 0;
}

CPerfBlock::~CPerfBlock()
///////////////////////////////////////////////////////////////////////////////
//
//	Destructor
//
///////////////////////////////////////////////////////////////////////////////
{
	m_pServer->Release();
	if (m_pDataBlock)
		delete []m_pDataBlock;
}

HRESULT CPerfBlock::Initialize(long lNumIDs, long *alID)
///////////////////////////////////////////////////////////////////////////////
//
//	Initialize
//
//	Create the performance counter block for the given IDs in the alID array.
//
//	From the array of IDs, create a space delimited string representing the 
//	set of IDs.  Call Update to fetch the performace data block using the 
//	ID string.
//
//	Parameters:
//		lNumIDs		- the number of IDs in the ID array
//		alID		- the ID array
//
///////////////////////////////////////////////////////////////////////////////
{
	// Create ID character array
	// =========================

	m_tcsIDs[0] = TEXT('\0');

	for (int i = 0; i < lNumIDs; i++)
	{
		TCHAR tcsValue[32];
		swprintf(tcsValue, L"%i ", alID[i]);
		lstrcat(m_tcsIDs, tcsValue);
	}

	// Fetch the performance block
	// ===========================

	return Update();
}

HRESULT CPerfBlock::Initialize(BSTR strIDs)
///////////////////////////////////////////////////////////////////////////////
//
//	Initialize
//
//	Create the performance counter block for the given IDs defined in the 
//	strIDs string.
//
//	Assign the strIDs parameter to the ID string member.  Call Update to fetch 
//	the performace data block using the ID string.
//
//	Parameter:
//		strIDs		- the string of IDs
//
///////////////////////////////////////////////////////////////////////////////
{
	// Create ID character array
	// =========================

	swprintf(m_tcsIDs, L"%S", strIDs);

	// Fetch the performance block
	// ===========================

	return Update();
}

HRESULT CPerfBlock::Update()
///////////////////////////////////////////////////////////////////////////////
//
//	Update
//
//	Given the ID string, fetch the performance data block.
//
//	Since the data block is of indeterminate length, attempt to query the 
//	data block using an initial block size.  If the query fails because of 
//	data block that is too small, continue reallocating the block size until
//	the query succeeds
//
///////////////////////////////////////////////////////////////////////////////
{
	HRESULT hRes;

	// Ensure that the ID string is initialized
	// ========================================

	if (0 == *m_tcsIDs)
		return E_FAIL;

	// Delete previous data block
	// ==========================

	if (m_pDataBlock)
		delete []m_pDataBlock;

	m_pDataBlock = 0;

	// Fetch data block
	// ================

	DWORD	dwSize = 0,
			dwBufSize;

	BOOL	bDone = FALSE;

	// Continue querying for the data block until the block size id 
	// of adequate size, and the query succeeds, or an error occurs
	// ============================================================

	while (!bDone)
	{
		hRes = RegQueryValueEx(HKEY_PERFORMANCE_DATA, m_tcsIDs, 0, 0, (PBYTE)m_pDataBlock, &dwBufSize);

		if (ERROR_SUCCESS == hRes)			// Got it!
			bDone = TRUE;		
		else if (ERROR_MORE_DATA == hRes)	// Need a bigger data block
		{
			if (m_pDataBlock)
				delete []m_pDataBlock;

			dwSize += 1024;
			m_pDataBlock = (PPERF_DATA_BLOCK)new BYTE[dwSize];
			dwBufSize = dwSize;
		} 
		else								// Unknown error
		{
			delete []m_pDataBlock;
			m_pDataBlock = 0;
			return hRes;
		}
	}

	return S_OK;
}

HRESULT CPerfBlock::GetPerfTime(__int64* pnTime)
///////////////////////////////////////////////////////////////////////////////
//
//	GetPerfTime
//
//	Gets the sample time of the performance data block.
//
//	Parameter:
//		pnTime		- a pointer to the performance block time
//
///////////////////////////////////////////////////////////////////////////////
{
	*pnTime = m_pDataBlock->PerfTime.QuadPart;

	return S_OK;
}

HRESULT CPerfBlock::GetPerfTime100nSec(__int64* pnTime)
///////////////////////////////////////////////////////////////////////////////
//
//	GetPerfTime100nSec
//
//	Gets the sample time in 100 nSec units of the performance data block.
//
//	Parameter:
//		pnTime		- a pointer to the performance block time in 100 nSec units
//
///////////////////////////////////////////////////////////////////////////////
{
	*pnTime = m_pDataBlock->PerfTime100nSec.QuadPart;

	return S_OK;
}

HRESULT CPerfBlock::GetPerfFreq(__int64* pnFreq)
///////////////////////////////////////////////////////////////////////////////
//
//	GetPerfFreq
//
//	Gets the sampling frequency of the performance data block.
//
//	Parameter:
//		pnTime		- a pointer to the performance block sampling frequency
//
///////////////////////////////////////////////////////////////////////////////
{
	*pnFreq = m_pDataBlock->PerfFreq.QuadPart;

	return S_OK;
}

STDMETHODIMP CPerfBlock::QueryInterface(REFIID riid, void** ppv)
///////////////////////////////////////////////////////////////////////////////
//
//	Query Interface
//
//	Standard COM Query Interface
//
///////////////////////////////////////////////////////////////////////////////
{
    if (riid == IID_IUnknown)
        *ppv = (IUnknown*)this;
    else if (riid == IID_IPerfBlock)
		*ppv = (IPerfBlock*)this;

    if(*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}

ULONG CPerfBlock::AddRef()
///////////////////////////////////////////////////////////////////////////////
//
//	AddRef
//
//	Standard COM AddRef
//
///////////////////////////////////////////////////////////////////////////////
{
    return InterlockedIncrement(&m_lRef);
}

ULONG CPerfBlock::Release()
///////////////////////////////////////////////////////////////////////////////
//
//	Release
//
//	Standard COM Release
//
///////////////////////////////////////////////////////////////////////////////
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
    {
        m_lRef++;
        delete this;
    }
    return lRef;
}

HRESULT CPerfBlock::GetSysName(BSTR* pstrName)
///////////////////////////////////////////////////////////////////////////////
//
//	GetSysName
//
//	Gets the system name from where the performace block was retrieved
//
//	Parameter:
//		pstrName	- a pointer to the returned name of the system name
//
///////////////////////////////////////////////////////////////////////////////
{
	// If the data block does not exist, we gotta problem!
	// ===================================================

	if (!m_pDataBlock)
		return E_FAIL;

	// Assign the system name to the parameter
	// =======================================

	*pstrName = SysAllocString((LPWSTR)((DWORD)m_pDataBlock + 
								(DWORD)m_pDataBlock->SystemNameOffset));

	return S_OK;
}

HRESULT CPerfBlock::BeginEnum()
///////////////////////////////////////////////////////////////////////////////
//
//	BeginEnum
//
//	Sets the enumeration pointer to the first object in the block
//
///////////////////////////////////////////////////////////////////////////////
{
	m_dwCurrentObject = 0;
	m_pCurrentObject = (PPERF_OBJECT_TYPE)((DWORD)m_pDataBlock + (DWORD)m_pDataBlock->HeaderLength);

	return S_OK;
}

HRESULT CPerfBlock::Next(IPerfObject **ppObject)
///////////////////////////////////////////////////////////////////////////////
//
//	Next
//
//	Assigns the out parameter to the current enumeration pointer, and then 
//	advances the enumeration pointer
//
//	Parameter:
//		ppObject	- the current object in the enumeration
//
///////////////////////////////////////////////////////////////////////////////
{
	// If the current object is valid...
	// =================================

	if (m_dwCurrentObject < m_pDataBlock->NumObjectTypes)
	{
		// Assign the object to the output parameter...
		// ============================================

		*ppObject = new CPerfObject(m_pCurrentObject, this);
		(*ppObject)->AddRef();

		// And advance the current object pointer
		// ======================================

		m_dwCurrentObject++;
		m_pCurrentObject = (PPERF_OBJECT_TYPE)((DWORD)m_pCurrentObject + (DWORD)m_pCurrentObject->TotalByteLength);

		return S_OK;
	}

	// Otherwise we are at the end of the enumeration
	// ==============================================

	return S_FALSE;
}

HRESULT CPerfBlock::EndEnum()
///////////////////////////////////////////////////////////////////////////////
//
//	EndEnum
//
//	Terminates the enumeration
//
///////////////////////////////////////////////////////////////////////////////

{
	m_dwCurrentObject = m_pDataBlock->NumObjectTypes;

	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
//	PerfObject
//
//	Each IPerfObject either enumerates a set of IPerfInstances, or IPerfCounters 
//	if no instances exist.  If instances exist, then each IPerfInstance will 
//	enumerate several IPerfCounters.  Each IPerfCounter represents an data 
//	property of the object or instance.  Note that some data requires data 
//	sampled over a period of time, therefore, it may be necessary to pass two 
//	IPerfCounters of the same instance or object from two IPerfBlocks 
//	sampled at different times.

///////////////////////////////////////////////////////////////////////////////

HRESULT CPerfObject::QueryInterface(REFIID riid, void** ppv)
///////////////////////////////////////////////////////////////////////////////
//
//	Query Interface
//
//	Standard COM query interface
//
///////////////////////////////////////////////////////////////////////////////
{
    if (riid == IID_IUnknown)
        *ppv = (IUnknown*)this;
    else if (riid == IID_IPerfObject)
		*ppv = (IPerfObject*)this;

    if(*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;

}

ULONG CPerfObject::AddRef()
///////////////////////////////////////////////////////////////////////////////
//
//	AddRef
//
//	Standard COM AddRef
//
///////////////////////////////////////////////////////////////////////////////
{
    return InterlockedIncrement(&m_lRef);
}

ULONG CPerfObject::Release()
///////////////////////////////////////////////////////////////////////////////
//
//	Release
//
//	Standard COM Release
//
///////////////////////////////////////////////////////////////////////////////
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
    {
        m_lRef++;
        delete this;
    }
    return lRef;
}

HRESULT CPerfObject::GetID(long *plID)
///////////////////////////////////////////////////////////////////////////////
//
//	GetID
//
//	Returns the ID of the object
//
//	Parameter:
//		plID		- a pointer to the ID of the object
//
///////////////////////////////////////////////////////////////////////////////
{
	*plID = m_pObjectData->ObjectNameTitleIndex;

	return S_OK;
}

HRESULT CPerfObject::GetName(BSTR *pstrName)
///////////////////////////////////////////////////////////////////////////////
//
//	GetName
//
//	Returns the name of the object
//
//	Parameter:
//		pstrName	- a pointer to the name of the object
//
///////////////////////////////////////////////////////////////////////////////
{
	TCHAR* tcsName;

	m_pPerfBlock->GetLibrary()->GetName(m_pObjectData->ObjectNameTitleIndex, &tcsName);
	*pstrName = SysAllocString(tcsName);

	return S_OK;
}

HRESULT CPerfObject::BeginEnum()
///////////////////////////////////////////////////////////////////////////////
//
//	BeginEnum
//
//	Sets the enumeration pointer to the first instance in the object block
//
///////////////////////////////////////////////////////////////////////////////
{
	m_lCurrentInstance = 0;
	m_pCurrentInstance = (PPERF_INSTANCE_DEFINITION)((DWORD)m_pObjectData + (DWORD)m_pObjectData->DefinitionLength);

	return S_OK;
}

HRESULT CPerfObject::Next(IPerfInstance** ppInstance)
///////////////////////////////////////////////////////////////////////////////
//
//	Next
//
//	Assigns the out parameter to the current enumeration pointer, and then 
//	advances the enumeration pointer
//
//	Parameter:
//		ppInstance	- the current instance in the enumeration
//
///////////////////////////////////////////////////////////////////////////////
{
	HRESULT hRes = S_OK;

	if ((m_lCurrentInstance < m_pObjectData->NumInstances) 
		|| ((PERF_NO_INSTANCES == m_pObjectData->NumInstances) && (0 == m_lCurrentInstance)))
	{
		*ppInstance = 
			new CPerfInstance(m_pCurrentInstance, 
							  (PPERF_COUNTER_DEFINITION)((DWORD)m_pObjectData + (DWORD)m_pObjectData->HeaderLength), 
							  m_pObjectData->NumCounters, 
							  GetPerfBlock(), 
							  (PERF_NO_INSTANCES == m_pObjectData->NumInstances));

		m_lCurrentInstance++;
		if (PERF_NO_INSTANCES != m_pObjectData->NumInstances)
		{
			PERF_COUNTER_BLOCK* pBlock = (PPERF_COUNTER_BLOCK)((DWORD)m_pCurrentInstance + (DWORD)m_pCurrentInstance->ByteLength);
			m_pCurrentInstance = (PPERF_INSTANCE_DEFINITION)((DWORD)m_pCurrentInstance + (DWORD)m_pCurrentInstance->ByteLength + pBlock->ByteLength);
		}
	}
	else 
		hRes = S_FALSE;

	return hRes;
}

HRESULT CPerfObject::EndEnum()
///////////////////////////////////////////////////////////////////////////////
//
//	EndEnum
//
//	Terminates the enumeration
//
///////////////////////////////////////////////////////////////////////////////
{
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
//	PerfInstance
//
//	Each IPerfInstance will enumerate several IPerfCounters.  Each IPerfCounter 
//	represents an data property of the object or instance.  Note that some data 
//	requires data sampled over a period of time, therefore, it may be necessary 
//	to pass two IPerfCounters of the same instance or object from two 
//	IPerfBlocks sampled at different times.
//
//	Note that if there exists an object with no instances, then an empty 
//	instance is created to act as a place holder for enumerating the counters.
//
///////////////////////////////////////////////////////////////////////////////

HRESULT CPerfInstance::QueryInterface(REFIID riid, void** ppv)
///////////////////////////////////////////////////////////////////////////////
//
//	Query Interface
//
//	Standard COM Query Interface
//
///////////////////////////////////////////////////////////////////////////////
{
    if (riid == IID_IUnknown)
        *ppv = (IUnknown*)this;
    else if (riid == IID_IPerfInstance)
		*ppv = (IPerfInstance*)this;

    if(*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;

}

ULONG CPerfInstance::AddRef()
///////////////////////////////////////////////////////////////////////////////
//
//	AddRef
//
//	Standard COM AddRef
//
///////////////////////////////////////////////////////////////////////////////
{
    return InterlockedIncrement(&m_lRef);
}

ULONG CPerfInstance::Release()
///////////////////////////////////////////////////////////////////////////////
//
//	Release
//
//	Standard COM Release
//
///////////////////////////////////////////////////////////////////////////////
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
    {
        m_lRef++;
        delete this;
    }
    return lRef;
}

HRESULT CPerfInstance::GetName(BSTR* pstrName)
///////////////////////////////////////////////////////////////////////////////
//
//	GetName
//
//	Returns the name of the instance
//
//	Parameter:
//		pstrName	- a pointer to the name of the instance
//
///////////////////////////////////////////////////////////////////////////////
{
	if (!m_bEmpty)
		*pstrName = SysAllocString((WCHAR*)((DWORD)m_pInstData + (DWORD)m_pInstData->NameOffset));
	else
		*pstrName = NULL;

	return S_OK;
}

HRESULT CPerfInstance::BeginEnum()
///////////////////////////////////////////////////////////////////////////////
//
//	BeginEnum
//
//	Sets the enumeration pointer to the first counter 
//
///////////////////////////////////////////////////////////////////////////////
{
	m_lCurrentCounter = 0;
	m_pCurrentCounter = m_pCtrDefn;

	return S_OK;
}

HRESULT CPerfInstance::Next(IPerfCounter** ppCounter)
///////////////////////////////////////////////////////////////////////////////
//
//	Next
//
//	Assigns the out parameter to the current enumeration pointer, and then 
//	advances the enumeration pointer
//
//	Parameter:
//		ppPerfCounter	- the current counter in the enumeration
//
///////////////////////////////////////////////////////////////////////////////
{
	HRESULT hRes = S_OK;

	if (m_lCurrentCounter < m_lNumCtrs)
	{
		DWORD dwHeader;

		if (!m_bEmpty)
			dwHeader = (DWORD)m_pInstData + (DWORD)m_pInstData->ByteLength;
		else
			dwHeader = (DWORD)m_pInstData;

		BYTE* pData = (PBYTE)(dwHeader + (DWORD)m_pCurrentCounter->CounterOffset);
		*ppCounter = new CPerfCounter(m_pCurrentCounter, pData, m_pCurrentCounter->CounterSize, GetPerfBlock());

		m_lCurrentCounter++;
		m_pCurrentCounter = (PPERF_COUNTER_DEFINITION)((DWORD)m_pCurrentCounter + (DWORD)m_pCurrentCounter->ByteLength);
	}
	else
		hRes = S_FALSE;

	return hRes;
}

HRESULT CPerfInstance::EndEnum()
///////////////////////////////////////////////////////////////////////////////
//
//	EndEnum
//
//	Terminates the enumeration
//
///////////////////////////////////////////////////////////////////////////////
{
	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
//	PerfCounter
//
//	Each IPerfCounter represents an data property of the object or instance.  
//	Note that some data requires data sampled over a period of time, therefore, 
//	it may be necessary to pass two IPerfCounters of the same instance or object 
//	from two IPerfBlocks sampled at different times.
//
///////////////////////////////////////////////////////////////////////////////

CPerfCounter::CPerfCounter(PERF_COUNTER_DEFINITION* pCounterData, PBYTE pData, DWORD dwDataLen, CPerfBlock* pPerfBlock) : 
	m_pCounterData(pCounterData), m_pPerfBlock(pPerfBlock), m_lRef(0) 
///////////////////////////////////////////////////////////////////////////////
//
//	Constructor
//
///////////////////////////////////////////////////////////////////////////////
{
	m_dwDataLen = dwDataLen;
	m_pData = new BYTE[dwDataLen];
	memcpy(m_pData, pData, dwDataLen);
}

CPerfCounter::~CPerfCounter()
///////////////////////////////////////////////////////////////////////////////
//
//	Destructor
//
///////////////////////////////////////////////////////////////////////////////
{
	delete []m_pData;
}

HRESULT CPerfCounter::QueryInterface(REFIID riid, void** ppv)
///////////////////////////////////////////////////////////////////////////////
//
//	Query Interface
//
//	Standard COM Query Interface
//
///////////////////////////////////////////////////////////////////////////////
{
    if (riid == IID_IUnknown)
        *ppv = (IUnknown*)this;
    else if (riid == IID_IPerfCounter)
		*ppv = (IPerfCounter*)this;

    if(*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;

}

ULONG CPerfCounter::AddRef()
///////////////////////////////////////////////////////////////////////////////
//
//	AddRef
//
//	Standard COM AddRef
//
///////////////////////////////////////////////////////////////////////////////
{
    return InterlockedIncrement(&m_lRef);
}

ULONG CPerfCounter::Release()
///////////////////////////////////////////////////////////////////////////////
//
//	Release
//
//	Standard COM Release
//
///////////////////////////////////////////////////////////////////////////////
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
    {
        m_lRef++;
        delete this;
    }
    return lRef;
}

HRESULT CPerfCounter::GetName(BSTR* pstrName)
///////////////////////////////////////////////////////////////////////////////
//
//	GetName
//
//	Returns the name of the counter
//
//	Parameter:
//		pstrName	- a pointer to the name of the counter
//
///////////////////////////////////////////////////////////////////////////////
{
	TCHAR* tcsName;

	m_pPerfBlock->GetLibrary()->GetName(m_pCounterData->CounterNameTitleIndex, &tcsName);
	*pstrName = SysAllocString(tcsName);

	return S_OK;
}

HRESULT CPerfCounter::GetType(long* plType)
///////////////////////////////////////////////////////////////////////////////
//
//	GetType
//
//	Returns the counter type
//
//	Parameter:
//		plType	- a pointer to the counter type
//
///////////////////////////////////////////////////////////////////////////////
{
	*plType = m_pCounterData->CounterType;

	return S_OK;
}

HRESULT CPerfCounter::GetData(byte** ppData)
///////////////////////////////////////////////////////////////////////////////
//
//	GetData
//
//	Returns the byte array of the counter data
//
//	Parameter:
//		ppData	- a pointer to the data byte array
//
///////////////////////////////////////////////////////////////////////////////
{
	*ppData = m_pData;

	return S_OK;
}

HRESULT CPerfCounter::GetDataString(IPerfCounter* pICtr, BSTR *pstrData)
///////////////////////////////////////////////////////////////////////////////
//
//	GetDataString
//
//	Returns a representation of the data in a formatted string based on the 
//	type of the counter data.  See the "Calculations of Raw Counter Data" 
//	section of the SDK for descriptions of the calculations.
//
//	NOTE:  not all types have been implemented
//
//	Parameter:
//		pCtr		- a prior sampling of the same counter (when required)
//		pstrData	- a string representing the formatted data
//
///////////////////////////////////////////////////////////////////////////////
{
	// Cast our interface to a CPerfCounter object
	// ===========================================

	CPerfCounter* pCtr = (CPerfCounter*)pICtr;

	switch (m_pCounterData->CounterType)
	{
	case PERF_100NSEC_MULTI_TIMER:
		*pstrData = SysAllocString(L"PERF_100NSEC_MULTI_TIMER"); break;
	case PERF_100NSEC_MULTI_TIMER_INV:
		*pstrData = SysAllocString(L"PERF_100NSEC_MULTI_TIMER_INV"); break;
	case PERF_100NSEC_TIMER:
		{
			// 100* (X1-X0)/(Y1-Y0)
			// ====================

			WCHAR wcsVal[16];
			PBYTE	pData;

			pCtr->GetData(&pData);

			__int64 *X0 = (__int64*)pData, 
					*X1 = (__int64*)m_pData;

			__int64 Y0, Y1;

			((CPerfCounter*)pCtr)->GetPerfBlock()->GetPerfTime100nSec(&Y0);
			m_pPerfBlock->GetPerfTime100nSec(&Y1);

			if (0 != (Y1 - Y0))
				swprintf(wcsVal, L"%d%%", (100 * ((*X1)-(*X0)) / (Y1-Y0)) );  
			else
				swprintf(wcsVal, L"Undefined");

			*pstrData = SysAllocString(wcsVal); 
		}break;
	case PERF_100NSEC_TIMER_INV:
		{
			// 100*(1-(X1-X0)/(Y1-Y0))
			// =======================

			WCHAR	wcsVal[16];
			PBYTE	pData;

			pCtr->GetData(&pData);

			__int64 *X0 = (__int64*)pData, 
					*X1 = (__int64*)m_pData;

			__int64 Y0, Y1;

			((CPerfCounter*)pCtr)->GetPerfBlock()->GetPerfTime100nSec(&Y0);
			m_pPerfBlock->GetPerfTime100nSec(&Y1);

			if (0 != (Y1 - Y0))
				swprintf(wcsVal, L"%d%%", (100 - ((*X1)-(*X0)) * 100 / (Y1-Y0)) );  
			else
				swprintf(wcsVal, L"Undefined");

			*pstrData = SysAllocString(wcsVal); 
		}break;
	case PERF_AVERAGE_BASE:
		*pstrData = SysAllocString(L"PERF_AVERAGE_BASE"); break;
	case PERF_AVERAGE_BULK:
		*pstrData = SysAllocString(L"PERF_AVERAGE_BULK"); break;
	case PERF_AVERAGE_TIMER:
		*pstrData = SysAllocString(L"PERF_AVERAGE_TIMER"); break;
	case PERF_COUNTER_BULK_COUNT:
		*pstrData = SysAllocString(L"PERF_COUNTER_BULK_COUNT"); break;
	case PERF_COUNTER_COUNTER:
		{
			// (X1-X0)/((Y1-Y0)/TB)
			// ====================

			WCHAR	wcsVal[16];
			PBYTE	pData;

			pCtr->GetData(&pData);

			__int32 *X0 = (__int32*)pData, 
					*X1 = (__int32*)m_pData;

			__int64 Y0, Y1;

			((CPerfCounter*)pCtr)->GetPerfBlock()->GetPerfTime(&Y0);
			m_pPerfBlock->GetPerfTime(&Y1);

			__int64 TB;

			m_pPerfBlock->GetPerfFreq(&TB);
			
			if ((0 != TB) && (0 != ((Y1-Y0)/TB)))
				swprintf(wcsVal, L"%d/Sec", (*X1)-(*X0) / ((Y1-Y0)/TB) );  
			else
				swprintf(wcsVal, L"Undefined");

			*pstrData = SysAllocString(wcsVal); 
		}break;
	case PERF_COUNTER_DELTA:
		*pstrData = SysAllocString(L"PERF_COUNTER_DELTA"); break;
	case PERF_COUNTER_LARGE_DELTA:
		*pstrData = SysAllocString(L"PERF_COUNTER_LARGE_DELTA"); break;
	case PERF_COUNTER_LARGE_QUEUELEN_TYPE:
		*pstrData = SysAllocString(L"PERF_COUNTER_LARGE_QUEUELEN_TYPE"); break;
	case PERF_COUNTER_MULTI_BASE:
		*pstrData = SysAllocString(L"PERF_COUNTER_MULTI_BASE"); break;
	case PERF_COUNTER_MULTI_TIMER:
		*pstrData = SysAllocString(L"PERF_COUNTER_MULTI_TIMER"); break;
	case PERF_COUNTER_MULTI_TIMER_INV:
		*pstrData = SysAllocString(L"PERF_COUNTER_MULTI_TIMER_INV"); break;
	case PERF_COUNTER_QUEUELEN_TYPE:
		*pstrData = SysAllocString(L"PERF_COUNTER_QUEUELEN_TYPE"); break;
	case PERF_COUNTER_TIMER:
		*pstrData = SysAllocString(L"PERF_COUNTER_TIMER"); break;
	case PERF_COUNTER_TIMER_INV:
		*pstrData = SysAllocString(L"PERF_COUNTER_TIMER_INV"); break;
	case PERF_ELAPSED_TIME:
		*pstrData = SysAllocString(L"PERF_ELAPSED_TIME"); break;
	case PERF_COUNTER_LARGE_RAWCOUNT:
		{
			WCHAR wcsVal[16];
			swprintf(wcsVal, L"%d", *((__int64*)m_pData));
			*pstrData = SysAllocString(wcsVal);
		}break;
	case PERF_COUNTER_LARGE_RAWCOUNT_HEX:
		{
			WCHAR wcsVal[16];
			swprintf(wcsVal, L"0x%X", *((__int64*)m_pData));
			*pstrData = SysAllocString(wcsVal);
		}break;
	case PERF_COUNTER_NODATA:
		*pstrData = SysAllocString(L"-"); break;
	case PERF_COUNTER_RAWCOUNT:
		{
			WCHAR wcsVal[16];
			swprintf(wcsVal, L"%d", *((DWORD*)m_pData));
			*pstrData = SysAllocString(wcsVal);
		}break;
	case PERF_COUNTER_RAWCOUNT_HEX:
		{
			WCHAR wcsVal[16];
			swprintf(wcsVal, L"0x%X", *((DWORD*)m_pData));
			*pstrData = SysAllocString(wcsVal);
		}break;
	case PERF_COUNTER_TEXT:
		*pstrData = SysAllocString((WCHAR*)(m_pData+4));break;
	case PERF_RAW_BASE:
		*pstrData = SysAllocString(L"PERF_COUNTER_TEXT");break;
	case PERF_RAW_FRACTION:
		*pstrData = SysAllocString(L"PERF_RAW_BASE");break;
	case PERF_SAMPLE_BASE:
		*pstrData = SysAllocString(L"PERF_SAMPLE_BASE");break;
	case PERF_SAMPLE_COUNTER:
		*pstrData = SysAllocString(L"PERF_SAMPLE_COUNTER");break;
	case PERF_SAMPLE_FRACTION:
		*pstrData = SysAllocString(L"PERF_SAMPLE_FRACTION");break;
	default:
		*pstrData = SysAllocString(L"None of the above");break;
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\pdh\wbem.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    wmi.c

Abstract:

    WMI interface functions exported by PDH.DLL

--*/

#include <windows.h>
#include <winperf.h>
#include <pdh.h>
#include <pdhmsg.h>
#include <assert.h>
#include "wbemdef.h"
#include "pdhitype.h"
#include "pdhidef.h"

#define PERF_TIMER_FIELD \
    (PERF_TIMER_TICK | PERF_TIMER_100NS | PERF_OBJECT_TIMER)

// at this point, calling the refresher while adding items to the refresher
// doesn't work. so for the time being, we'll use this interlock to prevent
// a collision
static BOOL bDontRefresh = FALSE;

// Prototype
HRESULT WbemSetProxyBlanket(
    IUnknown                 *pInterface,
    DWORD                     dwAuthnSvc,
    DWORD                     dwAuthzSvc,
    OLECHAR                  *pServerPrincName,
    DWORD                     dwAuthLevel,
    DWORD                     dwImpLevel,
    RPC_AUTH_IDENTITY_HANDLE  pAuthInfo,
    DWORD                     dwCapabilities );

HRESULT SetWbemSecurity( IUnknown *pInterface )
{
	return WbemSetProxyBlanket( pInterface, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
				RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE );
}


// This is the same timeout value the refresher uses so we can pretend
// we're doing the same thing.

#define	WBEM_REFRESHER_TIMEOUT	10000

//	This class is designed to encapsulate the IWbemRefresher functionality
//	The definition and implementation are all in this source file

class CWbemRefresher : public IUnknown
{
protected:
    LONG						m_lRefCount;

	// The primitives that will control the multithreading stuff
	HANDLE						m_hQuitEvent;
	HANDLE						m_hDoWorkEvent;
	HANDLE						m_hWorkDoneEvent;
	HANDLE						m_hRefrMutex;
	HANDLE						m_hInitializedEvent;
	HANDLE						m_hThread;
	DWORD						m_dwThreadId;
	BOOL						m_fThreadOk;

	// These are the pass-thru variables we will use as placeholders
	// as we perform our operations.  Note that a couple are missing.
	// This is because we are not really using them in our code, so
	// no sense in adding anything we don't really need.

	IStream*			m_pNSStream;
	LPCWSTR				m_wszPath;
	LPCWSTR				m_wszClassName;
	long				m_lFlags;
	IWbemClassObject**	m_ppRefreshable;
	IWbemHiPerfEnum**	m_ppEnum;
	long*				m_plId;
	long				m_lId;
	HRESULT				m_hOperResult;

	// This is what will be set to indicate to the thread which operation
	// it is supposed to perform.

	typedef enum
	{
		eRefrOpNone,
		eRefrOpRefresh,
		eRefrOpAddByPath,
		eRefrOpAddEnum,
		eRefrOpRemove,
		eRefrOpLast
	}	tRefrOps;

	tRefrOps			m_eRefrOp;

	// Thread ebtryt
	class XRefresher : public IWbemRefresher
	{
	protected:
		CWbemRefresher*	m_pOuter;

	public:
		XRefresher( CWbemRefresher* pOuter ) : m_pOuter( pOuter ) {};
		~XRefresher()	{};

		STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
		STDMETHOD_(ULONG, AddRef)(THIS);
		STDMETHOD_(ULONG, Release)(THIS);
        STDMETHOD(Refresh)(long lFlags);

	} m_xRefresher;

	class XConfigRefresher : public IWbemConfigureRefresher
	{
	protected:
		CWbemRefresher*	m_pOuter;

	public:
		XConfigRefresher( CWbemRefresher* pOuter ) : m_pOuter( pOuter ) {};
		~XConfigRefresher()	{};

		STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
		STDMETHOD_(ULONG, AddRef)(THIS);
		STDMETHOD_(ULONG, Release)(THIS);
        STDMETHOD(AddObjectByPath)(IWbemServices* pNamespace, LPCWSTR wszPath,
            long lFlags, IWbemContext* pContext, 
            IWbemClassObject** ppRefreshable, long* plId);

        STDMETHOD(AddObjectByTemplate)(IWbemServices* pNamespace, 
            IWbemClassObject* pTemplate,
            long lFlags, IWbemContext* pContext, 
            IWbemClassObject** ppRefreshable, long* plId);

        STDMETHOD(AddRefresher)(IWbemRefresher* pRefresher, long lFlags,
            long* plId);

        STDMETHOD(Remove)(long lId, long lFlags);

		STDMETHOD(AddEnum)(	IWbemServices*	pNamespace, LPCWSTR wscClassName,
			long lFlags, IWbemContext* pContext, IWbemHiPerfEnum** ppEnum,
			long* plId );

	} m_xConfigRefresher;

protected:

	void Initialize( void );
	void Cleanup( void );

	// Operation helpers
	HRESULT SignalRefresher( void );
	HRESULT SetRefresherParams( IWbemServices* pNamespace, tRefrOps eOp,
			LPCWSTR pwszPath, LPCWSTR pwszClassName, long lFlags,
			IWbemClassObject** ppRefreshable, IWbemHiPerfEnum** ppEnum, long* plId,
			long lId );
	void ClearRefresherParams( void );

	DWORD WINAPI RealEntry( void );

	static DWORD WINAPI ThreadProc( void * pThis )
	{
		return ((CWbemRefresher*) pThis)->RealEntry();
	}

public:
    CWbemRefresher();
    virtual ~CWbemRefresher();

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

	// The real implementations
    STDMETHOD(AddObjectByPath)(IWbemServices* pNamespace, LPCWSTR wszPath,
        long lFlags, IWbemContext* pContext, 
        IWbemClassObject** ppRefreshable, long* plId);

    STDMETHOD(AddObjectByTemplate)(IWbemServices* pNamespace, 
        IWbemClassObject* pTemplate,
        long lFlags, IWbemContext* pContext, 
        IWbemClassObject** ppRefreshable, long* plId);

    STDMETHOD(AddRefresher)(IWbemRefresher* pRefresher, long lFlags,
        long* plId);

    STDMETHOD(Remove)(long lId, long lFlags);

	STDMETHOD(AddEnum)(	IWbemServices*	pNamespace, LPCWSTR wscClassName,
		long lFlags, IWbemContext* pContext, IWbemHiPerfEnum** ppEnum,
		long* plId );

	STDMETHOD(Refresh)(long lFlags);

};

/*
**	Begin CWbemRefresher Implementation
*/

// CTor and DTor
CWbemRefresher::CWbemRefresher( void )
: m_lRefCount(0), m_xRefresher( this ), m_xConfigRefresher( this ),
		m_hQuitEvent( NULL ),
		m_hDoWorkEvent( NULL ), m_hRefrMutex( NULL ), m_hInitializedEvent( NULL ),
		m_hThread( NULL ), m_hWorkDoneEvent( NULL ), m_dwThreadId( 0 ),
		m_pNSStream( NULL ), m_wszPath( NULL ), m_wszClassName( NULL ),
		m_lFlags( 0L ), m_ppRefreshable( NULL ), m_ppEnum( NULL ), m_plId( NULL ),
		m_eRefrOp( eRefrOpRefresh ), m_hOperResult( WBEM_S_NO_ERROR ), m_fThreadOk( FALSE ),
		m_lId( 0 )
{
	Initialize();
}

CWbemRefresher::~CWbemRefresher( void )
{
	Cleanup();
}

void CWbemRefresher::Initialize( void )
{
	// Now create the events, mutexes and our pal, the MTA thread on which all of
	// the operations will run

	m_hQuitEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
	m_hDoWorkEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
	m_hInitializedEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
	m_hWorkDoneEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

	m_hRefrMutex = CreateMutex( NULL, FALSE, NULL );

	// If we don't have all these, something's gone south
	if (	NULL	==	m_hQuitEvent		||
			NULL	==	m_hDoWorkEvent		||
			NULL	==	m_hInitializedEvent	||
			NULL	==	m_hWorkDoneEvent	||
			NULL	==	m_hRefrMutex		)
	{
		return;
	}

	// Kick off the thread and wait for the initialized event signal (we'll give it
	// 5 seconds...if it don't get signalled in that timeframe, something is most likely
	// wrong, but we'll bounce out so whoever allocated us isn't left wondering what
	// to do).

	m_hThread = CreateThread( NULL, 0, CWbemRefresher::ThreadProc,
					(void*) this, 0, &m_dwThreadId );

	if ( NULL == m_hThread )
	{
		return;
	}

	WaitForSingleObject( m_hInitializedEvent, 5000 );

}

void CWbemRefresher::Cleanup( void )
{
	// If we have a thread, tell it to go away
	if ( NULL != m_hThread )
	{
		// Signal the quit event and give the thread a 5 second grace period
		// to shutdown.  If it don't, don't worry, just close the handle and go away.

		SetEvent( m_hQuitEvent );
		WaitForSingleObject( m_hThread, 5000 );

		CloseHandle( m_hThread );
		m_hThread = NULL;
	}

	// Cleanup the primitives

	if ( NULL != m_hQuitEvent )
	{
		CloseHandle( m_hQuitEvent );
		m_hQuitEvent = NULL;
	}

	if ( NULL != m_hDoWorkEvent )
	{
		CloseHandle( m_hDoWorkEvent );
		m_hDoWorkEvent = NULL;
	}

	if ( NULL != m_hInitializedEvent )
	{
		CloseHandle( m_hInitializedEvent );
		m_hInitializedEvent = NULL;
	}

	if ( NULL != m_hWorkDoneEvent )
	{
		CloseHandle( m_hWorkDoneEvent );
		m_hWorkDoneEvent = NULL;
	}

	if ( NULL != m_hRefrMutex )
	{
		CloseHandle( m_hRefrMutex );
		m_hRefrMutex = NULL;
	}

}

DWORD CWbemRefresher::RealEntry( void )
{
	// Grab hold of all the things we may care about in case some evil timing
	// problem occurs, so we don't get left trying to hit on member variables that
	// don't exist anymore.

	HANDLE	hQuitEvent			=	m_hQuitEvent,
			hDoWorkEvent		=	m_hDoWorkEvent,
			hInitializedEvent	=	m_hInitializedEvent,
			hWorkDoneEvent		=	m_hWorkDoneEvent;

	DWORD	dwWait = 0;

	HANDLE	ahEvents[2];

	ahEvents[0] = hDoWorkEvent;
	ahEvents[1] = hQuitEvent;

	// Initialize this thread
	HRESULT	hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );

	// Now get the refresher and config refresher pointers.

	IWbemRefresher*				pWbemRefresher = NULL;
	IWbemConfigureRefresher*	pWbemConfig = NULL;

	if ( SUCCEEDED( hr ) )
	{
		hr = CoCreateInstance (CLSID_WbemRefresher, 0, CLSCTX_SERVER,
						IID_IWbemRefresher, (LPVOID *)&pWbemRefresher);

		if ( SUCCEEDED( hr ) )
		{
			pWbemRefresher->QueryInterface( IID_IWbemConfigureRefresher, (LPVOID *) &pWbemConfig );
		}

	}

	// Ready to go --- Signal the Initialized Event
	SetEvent( hInitializedEvent );

	//	Obviously we can't go any further if we don't have our pointers correctly
	//	setup.
	m_fThreadOk = SUCCEEDED( hr );

	if ( m_fThreadOk )
	{

		while ( ( dwWait = WaitForMultipleObjects( 2, ahEvents, FALSE,  INFINITE ) ) == WAIT_OBJECT_0 )
		{
			// Don't continue if quit is signalled
			if ( WaitForSingleObject( hQuitEvent, 0 ) == WAIT_OBJECT_0 )
			{
				break;
			}

			// This is where we'll do the real operation

			switch( m_eRefrOp )
			{
				case eRefrOpRefresh:
				{
					m_hOperResult = pWbemRefresher->Refresh( m_lFlags );
					break;
				}

				// For both of these ops, we will need to umarshal the
				// namespace
				case eRefrOpAddEnum:
				case eRefrOpAddByPath:
				{
					IWbemServices*	pNamespace = NULL;

					// Unmarshal the interface, then set security
					m_hOperResult = CoGetInterfaceAndReleaseStream(
						m_pNSStream, IID_IWbemServices,
						(void**) &pNamespace );
					m_pNSStream = NULL;

					if ( SUCCEEDED( m_hOperResult ) )
					{
						m_hOperResult = SetWbemSecurity( pNamespace );

						if ( SUCCEEDED( m_hOperResult ) )
						{
							if ( eRefrOpAddByPath == m_eRefrOp )
							{
								m_hOperResult = pWbemConfig->AddObjectByPath(
									pNamespace, m_wszPath, m_lFlags, NULL,
									m_ppRefreshable, m_plId );
							}
							else
							{
								m_hOperResult = pWbemConfig->AddEnum(
									pNamespace, m_wszClassName, m_lFlags, NULL,
									m_ppEnum, m_plId );
							}
						}

						pNamespace->Release();
					}

					break;
				}

				case eRefrOpRemove:
				{
					m_hOperResult = pWbemConfig->Remove( m_lId, m_lFlags );
					break;
				}

				default:
				{
					m_hOperResult = WBEM_E_FAILED;
				}
			}

			// Signal the event to let a waiting thread know we're done doing
			// what it asked us to do.
			SetEvent( hWorkDoneEvent );
		}

	}

	// This means we're not processing anymore (for whatever reason)
	m_fThreadOk = FALSE;

	// Cleanup our pointers
	if ( NULL != pWbemRefresher )
	{
		pWbemRefresher->Release();
	}

	if ( NULL != pWbemConfig )
	{
		pWbemConfig->Release();
	}

	CoUninitialize();

	return 0;
}

// CWbemRefresher class functions
SCODE CWbemRefresher::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = 0;

    if (IID_IUnknown==riid)
    {
        *ppvObj = (IUnknown*)this;
        AddRef();
        return NOERROR;
    }
	else if ( IID_IWbemRefresher == riid )
	{
		*ppvObj = (IWbemRefresher*) &m_xRefresher;
		AddRef();
		return NOERROR;
	}
	else if ( IID_IWbemConfigureRefresher == riid )
	{
		*ppvObj = (IWbemConfigureRefresher*) &m_xConfigRefresher;
		AddRef();
		return NOERROR;
	}

    return ResultFromScode(E_NOINTERFACE);
}

ULONG CWbemRefresher::AddRef()
{
    return InterlockedIncrement(&m_lRefCount);
}

ULONG CWbemRefresher::Release()
{
    long lRef = InterlockedDecrement(&m_lRefCount);
        
    if (0 != lRef)
        return lRef;

    delete this;
    return 0;
}

HRESULT CWbemRefresher::SignalRefresher( void )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( SetEvent( m_hDoWorkEvent ) )
	{
		if ( WaitForSingleObject( m_hWorkDoneEvent, INFINITE ) == WAIT_OBJECT_0 )
		{
			hr = m_hOperResult;
		}
		else
		{
			hr = WBEM_E_FAILED;
		}
	}
	else
	{
		hr = WBEM_E_FAILED;
	}

	ClearRefresherParams();

	return hr;
}

HRESULT CWbemRefresher::SetRefresherParams( IWbemServices* pNamespace, tRefrOps eOp,
			LPCWSTR pwszPath, LPCWSTR pwszClassName, long lFlags,
			IWbemClassObject** ppRefreshable, IWbemHiPerfEnum** ppEnum, long* plId,
			long lId )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( NULL != pNamespace )
	{
		// Marshal the namespace pointer into the stream member
		hr = CoMarshalInterThreadInterfaceInStream( IID_IWbemServices, pNamespace,
			&m_pNSStream );
	}
	else
	{
		m_pNSStream = NULL;
	}

	if ( SUCCEEDED( hr ) )
	{
		m_eRefrOp = eOp;
		m_wszPath = pwszPath;
		m_wszClassName = pwszClassName,
		m_lFlags = lFlags;
		m_ppRefreshable = ppRefreshable;
		m_ppEnum = ppEnum;
		m_plId = plId;
		m_lId = lId;
	}

	return hr;
}

void CWbemRefresher::ClearRefresherParams( void )
{
	m_pNSStream = NULL;
	m_eRefrOp = eRefrOpNone;
	m_wszPath = NULL;
	m_wszClassName = NULL,
	m_lFlags = 0L;
	m_ppRefreshable = NULL;
	m_ppEnum = NULL;
	m_plId = NULL;
	m_lId = 0L;
	m_hOperResult = WBEM_S_NO_ERROR;
}

// These are the real method implementations
STDMETHODIMP CWbemRefresher::AddObjectByPath(
    IWbemServices* pNamespace, LPCWSTR wszPath,
    long lFlags, IWbemContext* pContext, 
    IWbemClassObject** ppRefreshable, long* plId)
{
	HRESULT	hr = WBEM_E_FAILED;

	if ( WaitForSingleObject( m_hRefrMutex, WBEM_REFRESHER_TIMEOUT ) == WAIT_OBJECT_0 )
	{
		// Check that the thread is still running
		if ( m_fThreadOk )
		{
			// Setup the parameters and perform the operation
			hr = SetRefresherParams( pNamespace, eRefrOpAddByPath, wszPath, NULL,
					lFlags, ppRefreshable, NULL, plId, 0L );

			if ( SUCCEEDED( hr ) )
			{
				// This is where we ask the thread to do the work
				hr = SignalRefresher();
			}
		}
		else
		{
			hr = WBEM_E_FAILED;
		}

		ReleaseMutex( m_hRefrMutex );
	}
	else
	{
		hr = WBEM_E_REFRESHER_BUSY;
	}

	return hr;
}

STDMETHODIMP CWbemRefresher::AddObjectByTemplate(
    IWbemServices* pNamespace, 
    IWbemClassObject* pTemplate,
    long lFlags, IWbemContext* pContext, 
    IWbemClassObject** ppRefreshable, long* plId)
{
	// We don't call this internally, so don't implement
	return WBEM_E_METHOD_NOT_IMPLEMENTED;
}

STDMETHODIMP CWbemRefresher::Remove(long lId, long lFlags)
{

	HRESULT	hr = WBEM_E_FAILED;

	if ( WaitForSingleObject( m_hRefrMutex, WBEM_REFRESHER_TIMEOUT ) == WAIT_OBJECT_0 )
	{
		// Check that the thread is still running
		if ( m_fThreadOk )
		{
			// Setup the parameters and perform the operation
			hr = SetRefresherParams( NULL, eRefrOpRemove, NULL, NULL,
					lFlags, NULL, NULL, NULL, lId );

			if ( SUCCEEDED( hr ) )
			{
				// This is where we ask the thread to do the work
				hr = SignalRefresher();
			}
		}
		else
		{
			hr = WBEM_E_FAILED;
		}

		ReleaseMutex( m_hRefrMutex );
	}
	else
	{
		hr = WBEM_E_REFRESHER_BUSY;
	}

	return hr;

}

STDMETHODIMP CWbemRefresher::AddRefresher(
                    IWbemRefresher* pRefresher, long lFlags, long* plId)
{
	// We don't call this internally, so don't implement
	return WBEM_E_METHOD_NOT_IMPLEMENTED;
}

HRESULT CWbemRefresher::AddEnum(
		IWbemServices* pNamespace, LPCWSTR wszClassName,
		long lFlags, IWbemContext* pContext, IWbemHiPerfEnum** ppEnum,
		long* plId)
{

	HRESULT	hr = WBEM_E_FAILED;

	if ( WaitForSingleObject( m_hRefrMutex, WBEM_REFRESHER_TIMEOUT ) == WAIT_OBJECT_0 )
	{
		// Check that the thread is still running
		if ( m_fThreadOk )
		{
			// Setup the parameters and perform the operation
			hr = SetRefresherParams( pNamespace, eRefrOpAddEnum, NULL, wszClassName,
					lFlags, NULL, ppEnum, plId, 0L );

			if ( SUCCEEDED( hr ) )
			{
				// This is where we ask the thread to do the work
				hr = SignalRefresher();
			}
		}
		else
		{
			hr = WBEM_E_FAILED;
		}

		ReleaseMutex( m_hRefrMutex );
	}
	else
	{
		hr = WBEM_E_REFRESHER_BUSY;
	}

	return hr;

}

STDMETHODIMP CWbemRefresher::Refresh( long lFlags )
{
	HRESULT	hr = WBEM_E_FAILED;

	if ( WaitForSingleObject( m_hRefrMutex, WBEM_REFRESHER_TIMEOUT ) == WAIT_OBJECT_0 )
	{
		// Check that the thread is still running
		if ( m_fThreadOk )
		{
			// Setup the parameters and perform the operation
			hr = SetRefresherParams( NULL, eRefrOpRefresh, NULL, NULL,
					lFlags, NULL, NULL, NULL, 0L );

			if ( SUCCEEDED( hr ) )
			{
				// This is where we ask the thread to do the work
				hr = SignalRefresher();
			}
		}
		else
		{
			hr = WBEM_E_FAILED;
		}

		ReleaseMutex( m_hRefrMutex );
	}
	else
	{
		hr = WBEM_E_REFRESHER_BUSY;
	}

	return hr;
}

// XRefresher
SCODE CWbemRefresher::XRefresher::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	return m_pOuter->QueryInterface( riid, ppvObj );
}

ULONG CWbemRefresher::XRefresher::AddRef()
{
    return m_pOuter->AddRef();
}

ULONG CWbemRefresher::XRefresher::Release()
{
    return m_pOuter->Release();
}

STDMETHODIMP CWbemRefresher::XRefresher::Refresh( long lFlags )
{
	// Pass through
	return m_pOuter->Refresh( lFlags );
}

// XConfigRefresher
SCODE CWbemRefresher::XConfigRefresher::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	return m_pOuter->QueryInterface( riid, ppvObj );
}

ULONG CWbemRefresher::XConfigRefresher::AddRef()
{
    return m_pOuter->AddRef();
}

ULONG CWbemRefresher::XConfigRefresher::Release()
{
    return m_pOuter->Release();
}

STDMETHODIMP CWbemRefresher::XConfigRefresher::AddObjectByPath(
    IWbemServices* pNamespace, LPCWSTR wszPath,
    long lFlags, IWbemContext* pContext, 
    IWbemClassObject** ppRefreshable, long* plId)
{
	// Pass through
	return m_pOuter->AddObjectByPath( pNamespace, wszPath, lFlags, pContext,
			ppRefreshable, plId );
}

STDMETHODIMP CWbemRefresher::XConfigRefresher::AddObjectByTemplate(
    IWbemServices* pNamespace, 
    IWbemClassObject* pTemplate,
    long lFlags, IWbemContext* pContext, 
    IWbemClassObject** ppRefreshable, long* plId)
{
	// Pass through
	return m_pOuter->AddObjectByTemplate( pNamespace, pTemplate, lFlags, pContext,
			ppRefreshable, plId );
}

STDMETHODIMP CWbemRefresher::XConfigRefresher::Remove(long lId, long lFlags)
{
	return m_pOuter->Remove( lId, lFlags );
}

STDMETHODIMP CWbemRefresher::XConfigRefresher::AddRefresher(
                    IWbemRefresher* pRefresher, long lFlags, long* plId)
{
	return m_pOuter->AddRefresher( pRefresher, lFlags, plId );
}

HRESULT CWbemRefresher::XConfigRefresher::AddEnum(
		IWbemServices* pNamespace, LPCWSTR wszClassName,
		long lFlags, IWbemContext* pContext, IWbemHiPerfEnum** ppEnum,
		long* plId)
{
	return m_pOuter->AddEnum( pNamespace, wszClassName, lFlags, pContext,
			ppEnum, plId );
}

/*
**	End CWbemRefresher Implementation!
*/

// HELPER Function to establish the CWbemRefresher Interface pass-thru
HRESULT CoCreateRefresher( IWbemRefresher** ppRefresher )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// Allocate the pass-thru object then, if successful, get
	// the interface pointer out of it
	CWbemRefresher*	pWbemRefresher = new CWbemRefresher;

	if ( NULL != pWbemRefresher )
	{
		hr = pWbemRefresher->QueryInterface( IID_IWbemRefresher, (LPVOID*) ppRefresher );
	}
	else
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}

	return hr;
}

PPDHI_WBEM_SERVER_DEF pFirstWbemServer = NULL;
BOOL    bWbemInitialized = FALSE;

PDH_FUNCTION PdhiCloseWbemServer (PPDHI_WBEM_SERVER_DEF pWbemServer);

PDH_FUNCTION
PdhiDisconnectWbemServer (
    PPDHI_WBEM_SERVER_DEF pWbemServer
)
{
    PDH_STATUS  pdhReturn = ERROR_SUCCESS;
    if (pWbemServer != NULL) {
        pWbemServer->lRefCount--;
        if (pWbemServer->lRefCount <= 0) {
            pdhReturn = PdhiCloseWbemServer (pWbemServer);
            pWbemServer->lRefCount = 0;
            assert (pWbemServer->pSvc == NULL);
        }
    }

    return pdhReturn;
}

PDH_FUNCTION
PdhiFreeWbemQuery (
    PPDHI_QUERY     pThisQuery
)
{
    HRESULT hRes;

    if ((pThisQuery->pRefresherCfg) != NULL) {
        hRes = pThisQuery->pRefresherCfg->Release ();
        pThisQuery->pRefresherCfg = NULL;
    }

    if ((pThisQuery->pRefresher) != NULL) {
        hRes = pThisQuery->pRefresher->Release ();
        pThisQuery->pRefresher = NULL;
    }

    return ERROR_SUCCESS;
}

PDH_FUNCTION
PdhiCloseWbemCounter (
    PPDHI_COUNTER   pThisCounter
)
{
    HRESULT hRes;

    assert (pThisCounter->pOwner->pRefresherCfg != NULL);
    hRes = pThisCounter->pOwner->pRefresherCfg->Remove (
        pThisCounter->lWbemRefreshId, 0L);
    // assert (hRes == S_OK); the function returns a BOOL even though it's defined as an HRESULT

    if (pThisCounter->pWbemAccess != NULL) {
        pThisCounter->pWbemAccess->Release();
        pThisCounter->pWbemAccess = NULL;
    }

    if (pThisCounter->pWbemObject != NULL) {
        pThisCounter->pWbemObject->Release();
        pThisCounter->pWbemObject = NULL;
    }
 
    return ERROR_SUCCESS;
}

PDH_FUNCTION
PdhiBreakWbemMachineName (
    LPCWSTR     szMachineAndNamespace,
    LPWSTR      szMachine,
    LPWSTR      szNamespace
)
/*
    assumes szMachine and szPath are large enough to hold the result
*/
{
    LPWSTR  szSrc = NULL;
    LPWSTR  szDest = NULL;

    assert (szMachine != NULL);
    assert (szNamespace != NULL);

    szSrc = (LPWSTR)szMachineAndNamespace;

    if (szSrc == NULL) {
        // then use local machine and default namespace
        lstrcpyW (szMachine, szStaticLocalMachineName); // local machine
        lstrcpyW (szNamespace, cszWbemDefaultPerfRoot);
        return ERROR_SUCCESS;
    } else {
        // break into components
        if (*szSrc  != NULL) {
            // there's a string, see if it's a machine or a namespace
            if ((szSrc[0] == L'\\') && (szSrc[1] == L'\\')) {
                szDest = szMachine;
                // then there's a machine name
                *szDest++ = *szSrc++;
                *szDest++ = *szSrc++;
                while ((*szSrc != 0) && (*szSrc != L'\\')){
                    *szDest++ = *szSrc++;
                }
                *szDest = 0;
            } else {
                // no machine so use default
                // it must be just a namespace
            }
        } else {
            // no machine so use default
        }

        if (szDest == NULL) {
            // nothing found yet, so insert local machine as default
            szDest = szMachine;
            lstrcpyW (szDest, szStaticLocalMachineName);
        }

        szDest = szNamespace;

        if (*szSrc != 0) {
            // if there's a namespace then copy it
            szSrc++;    // move past backslash
            while (*szSrc != 0) {
                *szDest++ = *szSrc++;
            }
            *szDest = 0;
        } else {
            // else return the default;
            lstrcpyW (szDest, cszWbemDefaultPerfRoot);
        }
        return ERROR_SUCCESS;
    }
}

PDH_FUNCTION
PdhiMakeWbemInstancePath (
    IN      PDH_COUNTER_PATH_ELEMENTS_W *pCounterPathElements,
    IN      LPWSTR                      szFullPathBuffer,
    IN      BOOL                        bMakeRelativePath
)
{
    WCHAR   szMachine[MAX_PATH];
    WCHAR   szNamespace[MAX_PATH];
    WCHAR   szWbemInstance[MAX_PATH];

    LPWSTR  szSrc, szDest;
    //  the function assumes that the path buffer is sufficiently large
    //  to hold the result
    //
    //
    // the wbem class instance path consists of one of the following formats:
    // for perf objects with one and only one instance (singleton classes in
    // WBEM parlance) the format is
    //
    //      <objectname>=@
    //
    // for object with instances, the format is
    //
    //      <objectname>.Name="<instancename>"
    //
    if (!bMakeRelativePath) {
        PdhiBreakWbemMachineName (
            pCounterPathElements->szMachineName,
            szMachine,
            szNamespace);
        lstrcpyW (szFullPathBuffer, szMachine);
        lstrcatW (szFullPathBuffer, cszBackSlash);
        lstrcatW (szFullPathBuffer, szNamespace);
        lstrcatW (szFullPathBuffer, cszColon);
    } else {
        *szFullPathBuffer = 0;
    }

    if (pCounterPathElements->szInstanceName == NULL) {
        // then apply the singleton logic
        lstrcatW (szFullPathBuffer, pCounterPathElements->szObjectName);
        lstrcatW (szFullPathBuffer, cszSingletonInstance);
    } else {
        // wbem will interpret the backslash character as an
        // escape char (as "C" does) so we'll have to double each
        // backslash in the string to make it come out OK
        szDest = &szWbemInstance[0];
        if (pCounterPathElements->szParentInstance != NULL) {
            szSrc = pCounterPathElements->szParentInstance;
            while (*szSrc != 0) {
                *szDest = *szSrc;
                if (*szSrc == BACKSLASH_L) {
                    *++szDest = BACKSLASH_L;
                }
                szDest++;
                szSrc++;
                assert (szDest < &szWbemInstance[MAX_PATH]);
            }
            *szDest++ = '/'; // parent/child delimiter
        }
        szSrc = pCounterPathElements->szInstanceName;
        while (*szSrc != 0) {
            *szDest = *szSrc;
            if (*szSrc == BACKSLASH_L) {
                *++szDest = BACKSLASH_L;
            }
            szDest++;
            szSrc++;
            assert (szDest < &szWbemInstance[MAX_PATH]);
        }
        *szDest = 0;
        // apply the instance name format
        lstrcatW (szFullPathBuffer, pCounterPathElements->szObjectName);
        lstrcatW (szFullPathBuffer, cszNameParam);
        lstrcatW (szFullPathBuffer, szWbemInstance);
        lstrcatW (szFullPathBuffer, cszDoubleQuote);
    }
    return ERROR_SUCCESS;
}

PDH_FUNCTION
PdhiWbemGetCounterPropertyName (
    IWbemClassObject        *pThisClass,
    LPCWSTR                 szCounterDisplayName,
    LPWSTR                  szPropertyName,
    DWORD                   dwPropertyNameSize
)
{
    HRESULT         hResult;
    PDH_STATUS      pdhStatus = PDH_CSTATUS_NO_COUNTER;
    SAFEARRAY       *psaNames = NULL;
    long            lLower, lUpper, lCount;
    BSTR            bsPropName = NULL;
    BSTR            bsCountertype = NULL;
    BSTR            bsDisplayname = NULL;
    VARIANT         vName, vCountertype;
    IWbemQualifierSet       *pQualSet = NULL;

    VariantInit (&vName);
    VariantInit (&vCountertype);

    // get the properties of this class as a Safe Array
    hResult = pThisClass->GetNames (NULL,
        WBEM_FLAG_NONSYSTEM_ONLY, NULL, &psaNames);
    if (hResult == WBEM_NO_ERROR) {
        hResult = SafeArrayGetLBound (psaNames, 1, &lLower);
        if (hResult == S_OK) {
            hResult = SafeArrayGetUBound (psaNames, 1, &lUpper);
        }
        if (hResult == S_OK) {
            bsCountertype = SysAllocString (cszCountertype);
            bsDisplayname = SysAllocString (cszDisplayname);
            for (lCount = lLower; lCount <= lUpper; lCount++) {
                hResult = SafeArrayGetElement (psaNames, &lCount, &bsPropName);
                if (hResult == S_OK) {
                    // this is the desired counter so
                    // get the qualifier set for this property
                    hResult = pThisClass->GetPropertyQualifierSet (
                        bsPropName, &pQualSet);
                    if (hResult == WBEM_NO_ERROR) {
                        LONG    lCounterType;
                        // make sure this is a perf counter property
                        hResult = pQualSet->Get (bsCountertype, 0, &vCountertype, NULL);
                        if (hResult == WBEM_NO_ERROR) {
                            lCounterType = V_I4(&vCountertype);
                            // then see if this is a displayable counter
                            if (!(lCounterType & PERF_DISPLAY_NOSHOW) ||
                                (lCounterType == PERF_AVERAGE_BULK)) {
                                // by testing for the counter type
                                // get the display name for this property
                                hResult = pQualSet->Get (bsDisplayname, 0, &vName, NULL);
                                if (hResult == WBEM_NO_ERROR) {
                                    // display name found compare it
                                    if (lstrcmpiW(szCounterDisplayName, V_BSTR(&vName)) == 0) {
                                        // then this is the correct property so return
                                        if ((DWORD)lstrlenW(bsPropName) < dwPropertyNameSize) {
                                            lstrcpyW (szPropertyName, (LPWSTR)bsPropName);
                                            pdhStatus = ERROR_SUCCESS;
                                            pQualSet->Release();
                                            pQualSet = NULL;
                                            break;
                                        } else {
                                            pdhStatus = PDH_MORE_DATA;
                                        }
                                    } else {
                                        //not this property so continue
                                    }
                                }
                            } else {
                                // this is a "don't show" counter so skip it
                            }
                        } else {
                            // unable to get the counter type so it's probably
                            // not a perf counter property, skip it and continue
                        }
                        VariantClear (&vName);
                        VariantClear (&vCountertype);
                        pQualSet->Release();
                        pQualSet = NULL;
                    } else {
                        // unable to read qualifiers so skip
                        continue;
                    }
                } else {
                    // unable to read element in SafeArray
                    pdhStatus = PDH_WBEM_ERROR;
                    SetLastError(hResult);
                }
            } // end for each element in SafeArray
            if (bsCountertype != NULL) SysFreeString (bsCountertype);
            if (bsDisplayname != NULL) SysFreeString (bsDisplayname);
        } else {
            // unable to get array boundries
            pdhStatus = PDH_WBEM_ERROR;
            SetLastError (hResult);
        }
    } else {
        // unable to get property strings
        pdhStatus = PDH_WBEM_ERROR;
        SetLastError (hResult);
    }

    VariantClear (&vName);
    VariantClear (&vCountertype);

    // make sure it was released
    assert (pQualSet == NULL);

    return pdhStatus;
}

PDH_FUNCTION
PdhiWbemGetCounterDisplayName (
    IWbemClassObject        *pThisClass,
    LPCWSTR                 szCounterName,
    LPWSTR                  szDisplayName,
    DWORD                   dwDisplayNameSize
)
{
    HRESULT         hResult;
    PDH_STATUS      pdhStatus = PDH_CSTATUS_NO_COUNTER;
    SAFEARRAY       *psaNames = NULL;
    long            lLower, lUpper, lCount;
    BSTR            bsPropName = NULL;
    BSTR            bsCountertype = NULL;
    BSTR            bsDisplayname = NULL;
    VARIANT         vName, vCountertype;
    IWbemQualifierSet       *pQualSet = NULL;

    VariantInit (&vName);
    VariantInit (&vCountertype);

    // get the properties of this class as a Safe Array
    hResult = pThisClass->GetNames (NULL,
        WBEM_FLAG_NONSYSTEM_ONLY, NULL, &psaNames);
    if (hResult == WBEM_NO_ERROR) {
        hResult = SafeArrayGetLBound (psaNames, 1, &lLower);
        if (hResult == S_OK) {
            hResult = SafeArrayGetUBound (psaNames, 1, &lUpper);
        }
        if (hResult == S_OK) {
            bsCountertype = SysAllocString (cszCountertype);
            bsDisplayname = SysAllocString (cszDisplayname);
            for (lCount = lLower; lCount <= lUpper; lCount++) {
                hResult = SafeArrayGetElement (psaNames, &lCount, &bsPropName);
                if (hResult == S_OK) {
                    if (lstrcmpiW ((LPWSTR)bsPropName, szCounterName) == 0) {
                        // this is the desired counter so
                        // get the qualifier set for this property
                        hResult = pThisClass->GetPropertyQualifierSet (
                            bsPropName, &pQualSet);
                        if (hResult == WBEM_NO_ERROR) {
                            LONG    lCounterType;
                            // make sure this is a perf counter property
                            hResult = pQualSet->Get (bsCountertype, 0, &vCountertype, NULL);
                            if (hResult == WBEM_NO_ERROR) {
                                lCounterType = V_I4(&vCountertype);
                                // then see if this is a displayable counter
                                if (!(lCounterType & PERF_DISPLAY_NOSHOW) ||
                                    (lCounterType == PERF_AVERAGE_BULK)) {
                                    // by testing for the counter type
                                    // get the display name for this property
                                    hResult = pQualSet->Get (bsDisplayname, 0, &vName, NULL);
                                    if (hResult == WBEM_NO_ERROR) {
                                        // display name found so copy and break
                                        if ((DWORD)lstrlenW(V_BSTR(&vName)) < dwDisplayNameSize) {
                                            lstrcpyW (szDisplayName, V_BSTR(&vName));
                                            pdhStatus = ERROR_SUCCESS;
                                            pQualSet->Release();
                                            pQualSet = NULL;
                                            break;
                                        } else {
                                            pdhStatus = PDH_MORE_DATA;
                                        }
                                    }
                                } else {
                                    // this is a "don't show" counter so skip it
                                }
                            } else {
                                // unable to get the counter type so it's probably
                                // not a perf counter property, skip it and continue
                            }
                            VariantClear (&vName);
                            VariantClear (&vCountertype);
                            pQualSet->Release();
                            pQualSet = NULL;
                        } else {
                            // unable to read qualifiers so skip
                            continue;
                        }
                    } else {
                        // aren't interested in this property, so
                        continue;
                    }
                } else {
                    // unable to read element in SafeArray
                    pdhStatus = PDH_WBEM_ERROR;
                    SetLastError(hResult);
                }
            } // end for each element in SafeArray
            if (bsCountertype != NULL) SysFreeString (bsCountertype);
            if (bsDisplayname != NULL) SysFreeString (bsDisplayname);
        } else {
            // unable to get array boundries
            pdhStatus = PDH_WBEM_ERROR;
            SetLastError (hResult);
        }
    } else {
        // unable to get property strings
        pdhStatus = PDH_WBEM_ERROR;
        SetLastError (hResult);
    }

    VariantClear (&vName);
    VariantClear (&vCountertype);

    // make sure it was released
    assert (pQualSet == NULL);

    return pdhStatus;
}

PDH_FUNCTION
PdhiWbemGetClassObjectByName (
    PPDHI_WBEM_SERVER_DEF   pThisServer,
    LPCWSTR                 szClassName,
    IWbemClassObject        **pReturnClass
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;

    HRESULT hResult;
    BSTR    bsClassName;

    IWbemClassObject        *pThisClass = NULL;

    bsClassName = SysAllocString (szClassName);

    hResult = pThisServer->pSvc->GetObject (
        bsClassName, // class name
        0, NULL,
        &pThisClass,
        NULL);

    SysFreeString (bsClassName);
    
    if (hResult != WBEM_NO_ERROR) {
        pdhStatus = PDH_WBEM_ERROR;
        SetLastError (hResult);
    } else {
        *pReturnClass = pThisClass;
    }

    return (pdhStatus);
}

PDH_FUNCTION
PdhiWbemGetClassDisplayName (
    PPDHI_WBEM_SERVER_DEF   pThisServer,
    LPCWSTR                 szClassName,
    LPWSTR                  szClassDisplayName,
    DWORD                   dwClassDisplayNameSize,
    IWbemClassObject        **pReturnClass
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;

    HRESULT hResult;
    BSTR    bsClassName;
    BSTR    bsClass;
    BSTR    bsDisplayName;
    VARIANT vName;
    LPWSTR  szDisplayName;

    IWbemClassObject        *pThisClass = NULL;
    IWbemQualifierSet       *pQualSet = NULL;

    VariantInit (&vName);

    bsClassName = SysAllocString (szClassName);

    hResult = pThisServer->pSvc->GetObject (
        bsClassName, // class name
        0, NULL,
        &pThisClass,
        NULL);
    if (hResult != WBEM_NO_ERROR) {
        pdhStatus = PDH_WBEM_ERROR;
        SetLastError (hResult);
    }
    SysFreeString (bsClassName);

    if (pdhStatus == ERROR_SUCCESS) {
        // get the display name property of this class
        pThisClass->GetQualifierSet (&pQualSet);
        if (pQualSet != NULL) {
            bsDisplayName = SysAllocString (cszDisplayname);
            hResult = pQualSet->Get (bsDisplayName, 0, &vName, 0);

            if (hResult == WBEM_E_NOT_FOUND) {
                // then this has not display name so
                // pull the class name
                bsClass = SysAllocString (cszClass);
                hResult = pThisClass->Get (bsClass, 0, &vName, 0, 0);
                SysFreeString (bsClass);
            }
            pQualSet->Release();
        } else {
            hResult = WBEM_E_NOT_FOUND;
        }

        if (hResult == WBEM_E_NOT_FOUND) {
            //unable to look up a display name so nothing to return
            pdhStatus = PDH_WBEM_ERROR;
            SetLastError (hResult);
        } else {
            // copy string to caller's buffers
            szDisplayName = V_BSTR(&vName);
            if ((DWORD)lstrlenW(szDisplayName) < dwClassDisplayNameSize) {
                lstrcpyW (szClassDisplayName, szDisplayName);
                pdhStatus = ERROR_SUCCESS;
            }
            if (pReturnClass != NULL) {
                // return the class pointer, the caller will close it
                *pReturnClass = pThisClass;
            } else {
                // close it
                pThisClass->Release();
            }
        }
    }

    VariantClear (&vName);

    return pdhStatus;
}
BOOL
PdhiIsSingletonClass (
    IWbemClassObject        *pThisClass
)
{
    HRESULT                 hResult;
    BOOL                    bReturnValue = FALSE;   //
    BSTR                    bsSingleton = NULL;
    VARIANT                 vValue;
    IWbemQualifierSet       *pQualSet = NULL;

    bsSingleton = SysAllocString (cszSingleton);

    // get the display name of this class
    pThisClass->GetQualifierSet (&pQualSet);
    if (pQualSet != NULL) {
        hResult = pQualSet->Get (bsSingleton, 0, &vValue, 0);
        pQualSet->Release();
    } else {
        hResult = WBEM_E_NOT_FOUND;
    }

    if (hResult == ERROR_SUCCESS) {
        bReturnValue = TRUE;
    }

    VariantClear (&vValue);
    SysFreeString (bsSingleton);

    return bReturnValue;
}

PDH_FUNCTION
PdhiWbemGetObjectClassName (
    PPDHI_WBEM_SERVER_DEF   pThisServer,
    LPCWSTR                 szObjectName,
    LPWSTR                  szObjectClassName,
    DWORD                   dwObjectClassNameSize,
    IWbemClassObject        **pReturnClass
)
{
    PDH_STATUS              pdhStatus = ERROR_SUCCESS;
    HRESULT                 hResult;
    DWORD                   dwBufferSize = 0;
    DWORD                   dwRtnCount;
    VARIANT                 vName;
    LPWSTR                  szDisplayName;
    LONG                    lResult;
    BSTR                    bsTemp = NULL;
    BSTR                    bsDisplayName = NULL;
    BSTR                    bsClass = NULL;

    IEnumWbemClassObject    *pEnum = NULL;
    IWbemClassObject        *pThisClass = NULL;
    IWbemQualifierSet       *pQualSet = NULL;

    assert (pThisServer != NULL);
    assert (szObjectName != NULL);
    assert (szObjectClassName != NULL);
    assert (dwObjectClassNameSize > 0);

    VariantInit (&vName);

    // create an enumerator of the PerfRawData class
    bsTemp = SysAllocString (cszPerfRawData);

    hResult = pThisServer->pSvc->CreateClassEnum (
        bsTemp,
        WBEM_FLAG_DEEP | WBEM_FLAG_USE_AMENDED_QUALIFIERS,
        NULL,
        &pEnum);

	// Set security on the proxy
	if ( SUCCEEDED( hResult ) )
	{
		hResult = SetWbemSecurity( pEnum );
	}

    SysFreeString (bsTemp);

    if (hResult != WBEM_NO_ERROR) {
        pdhStatus = PDH_WBEM_ERROR;
        SetLastError (hResult);
    }

    if (pdhStatus == ERROR_SUCCESS) {
        bsDisplayName = SysAllocString (cszDisplayname);
        bsClass = SysAllocString (cszClass);
        // walk down list of objects and find a match
        while (TRUE) {
            hResult = pEnum->Next (
                0,      // timeout
                1,      // return only 1 object
                &pThisClass,
                &dwRtnCount);

            // no more classes
            if (dwRtnCount == 0) {
                // no matching object not found
                pdhStatus = PDH_CSTATUS_NO_OBJECT;
                pThisClass =  NULL;
                break;
            }

            // get the display name of this class
            pThisClass->GetQualifierSet (&pQualSet);
            if (pQualSet != NULL) {
                hResult = pQualSet->Get (bsDisplayName, 0, &vName, 0);
                pQualSet->Release();
            } else {
                hResult = WBEM_E_NOT_FOUND;
            }

            if (hResult == WBEM_E_NOT_FOUND) {
                // then this has not display name so
                // pull the class name
                hResult = pThisClass->Get (bsClass, 0, &vName, 0, 0);
            }

            if (hResult == WBEM_E_NOT_FOUND) {
                continue; // and try the next one
            } else {
                szDisplayName = V_BSTR(&vName);
                lResult =  lstrcmpiW(szDisplayName, szObjectName);
                if (lResult == 0) {
                    VariantClear (&vName);
                    // copy the class name and exit
                    hResult = pThisClass->Get (bsClass, 0, &vName, 0, 0);
                    if ((DWORD)lstrlenW(V_BSTR(&vName)) < dwObjectClassNameSize) {
                        pdhStatus = ERROR_SUCCESS;
                        lstrcpyW (szObjectClassName, (LPWSTR)V_BSTR(&vName));
                        if (pReturnClass != NULL) {
                            *pReturnClass = pThisClass;
                        }
                    } else {
                        pdhStatus = PDH_MORE_DATA;
                    }
                    // exit here, but keep the class pointer
                    break;
                }
            }
            // clear the variant
            VariantClear (&vName);
            // release this class
            pThisClass->Release();
        }
        SysFreeString (bsDisplayName);
        SysFreeString (bsClass);

        pEnum->Release();

        if (pReturnClass == NULL) {
            // otherwise, free this class now
            pThisClass->Release();
        }

        VariantClear (&vName);

    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiAddWbemServer (
    LPCWSTR  szMachineName,
    PPDHI_WBEM_SERVER_DEF *pWbemServer
)
{
    IWbemLocator    *pWbemLocator = 0;
    IWbemServices   *pWbemServices = 0;
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    HRESULT         hResult;
    DWORD           dwResult;
    LPWSTR          szNameSpaceString = NULL;
    DWORD           dwStrLen = 0;
    PPDHI_WBEM_SERVER_DEF pNewServer = NULL;
    WCHAR           szLocalMachineName[MAX_PATH];
    WCHAR           szLocalServerPath[MAX_PATH];
    WCHAR           szLocalNameSpaceString[MAX_PATH];
	WCHAR			szLocale[32];

    // szMachineName can be null,
    // that means use the local machine and default namespace
    assert (pWbemServer != NULL);

    if (!bWbemInitialized) {
        hResult = CoInitializeEx (0, COINIT_MULTITHREADED);

        hResult = CoInitializeSecurity(
            NULL,   //Points to security descriptor
            -1L,     //Count of entries in asAuthSvc -1 means use default
            NULL,   //Array of names to register
            NULL,   //Reserved for future use
            RPC_C_AUTHN_LEVEL_CONNECT,  //The default authentication level 
                                // for proxies
            RPC_C_IMP_LEVEL_IMPERSONATE,    //The default impersonation level 
                                // for proxies
            NULL,   //Authentication information for 
                    // each authentication service
            EOAC_NONE,   //Additional client and/or 
                            // server-side capabilities
            NULL    //Reserved for future use
            );

        bWbemInitialized = TRUE;
    }

    // connect to locator
    dwResult = CoCreateInstance (CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
        IID_IWbemLocator, (LPVOID *)&pWbemLocator);

    if (dwResult != S_OK) {
        SetLastError (dwResult);
        pdhStatus = PDH_CANNOT_CONNECT_MACHINE;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        PdhiBreakWbemMachineName (
            szMachineName,
            szLocalMachineName,
            szLocalNameSpaceString);
        lstrcpyW (szLocalServerPath, szLocalMachineName);
        lstrcatW (szLocalServerPath, szLocalNameSpaceString);

		// Create the locale
		swprintf( szLocale, L"MS_%hX", GetUserDefaultLangID() );

        // try to connect to the service
        hResult = pWbemLocator->ConnectServer (
            szLocalServerPath,
            NULL, NULL, szLocale,
            0L,
            0,0,
            &pWbemServices);

        if (hResult) {
            SetLastError (hResult);
            // DEVNOTE: This should probably be a new error code
            pdhStatus =  PDH_CANNOT_CONNECT_MACHINE;
        } else {
            dwStrLen = lstrlenW (szLocalMachineName ) + 1;
        }
        // free the locator
        pWbemLocator->Release();
    }

    // If we succeeded, we need to set Interface Security on the proxy and its
    // IUnknown in order for Impersonation to correctly work.

    if ( pdhStatus == ERROR_SUCCESS )
    {
        pdhStatus = SetWbemSecurity( pWbemServices );
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // everything went ok so save this connection
        if (*pWbemServer == NULL) {
            // then this is a new connection
            pNewServer = (PPDHI_WBEM_SERVER_DEF)G_ALLOC (sizeof (PDHI_WBEM_SERVER_DEF) + (dwStrLen * sizeof (WCHAR)));
            if (pNewServer == NULL) {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            } else {
                // insert this at the head of the list
                pNewServer->pNext = pFirstWbemServer;
                pFirstWbemServer = pNewServer;
                pNewServer->szMachine = (LPWSTR)&pNewServer[1];
                lstrcpyW (pNewServer->szMachine, szLocalMachineName);
                pNewServer->lRefCount = 0; // it'll be incremented in the connect function
                *pWbemServer = pNewServer;
            }
        } else {
            // we are reconnecting and reusing an old memory block
            // so just update the pointer
            pNewServer = *pWbemServer;
        }   
        // if reconnecting or connecting for the first time, this should be NULL
        assert (pNewServer->pSvc == NULL);

        if (pdhStatus == ERROR_SUCCESS) {
            // update fields
            // load the name fields
            pNewServer->pSvc = pWbemServices;
        } else {
            // something failed so return a NULL for the server pointer
            *pWbemServer = NULL;
        }
    } else {
        // unable to connect so return NULL
        *pWbemServer = NULL;
    }

    // if there was an eror, then free the new sever memory
    if (pWbemServer == NULL) G_FREE(pNewServer);

    return pdhStatus;
}

PDH_FUNCTION
PdhiCloseWbemServer (
    PPDHI_WBEM_SERVER_DEF pWbemServer
)
{
    assert (pWbemServer != NULL);

    if (pWbemServer != NULL) {
        if (pWbemServer->pSvc != NULL) {
            // this is about all that's currently required
            pWbemServer->pSvc->Release();
            pWbemServer->pSvc = NULL;
        } else {
            // no server is connected
        }
    } else {
        // no structure exists
        }


    return ERROR_SUCCESS;
}

PDH_FUNCTION
PdhiConnectWbemServer (
    LPCWSTR  szMachineName,
    PPDHI_WBEM_SERVER_DEF *pWbemServer
)
{
    PDH_STATUS  pdhStatus = PDH_CANNOT_CONNECT_MACHINE;
    PPDHI_WBEM_SERVER_DEF pThisServer = NULL;

    LPWSTR  szWideMachineName = NULL;
    LPWSTR  szWideNamespace = NULL;
    LPWSTR  szMachineNameArg;

    // get the local machine name & default name space if the caller
    // has passed in a NULL machine name

    if (szMachineName == NULL) {
        szWideMachineName = (LPWSTR) G_ALLOC (2048); // this should be long enough
        szWideNamespace = (LPWSTR) G_ALLOC (1024); // this should be long enough
        if ((szWideMachineName != NULL) && (szWideNamespace != NULL)) {
            pdhStatus = PdhiBreakWbemMachineName (
                NULL,
                szWideMachineName,
                szWideNamespace);
//            lstrcatW (szWideMachineName, cszBackSlash);
//            lstrcatW (szWideMachineName, szWideNamespace);
            G_FREE (szWideNamespace);
            szMachineNameArg = szWideMachineName;
        } else {
            pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
    } else {
        szMachineNameArg = (LPWSTR)szMachineName;
    }

    // walk down list of connected servers and find the requested one
    assert (pWbemServer != NULL);

    for (pThisServer = pFirstWbemServer;
         pThisServer != NULL;
         pThisServer = pThisServer->pNext) {
        // machine name includes the namespace
        if (lstrcmpiW(pThisServer->szMachine, szMachineNameArg) == 0) {
            pdhStatus = ERROR_SUCCESS;
            break;
        }
    }

    if (pThisServer == NULL) {
         // then add it to the list and return it
         pdhStatus = PdhiAddWbemServer (
            szMachineNameArg,
            &pThisServer);
    } else {
        // make sure the server is really there
        // this is just a dummy call to see if the server will respond
        // with an error or RPC will respond with an error that there's 
        // no server anymore.
        HRESULT hrTest;
        if (pThisServer->pSvc != NULL) {
            hrTest = pThisServer->pSvc->CancelAsyncCall(NULL);
        } else {
            // there is no service connected so set the HRESULT to 
            // get the next block to try and reconnect
            hrTest = 0x800706BF; // some bad status value thats NOT WBEM_E_INVALID_PARAMETER
        }
        
        // if the error is WBEM_E_INVALID_PARAMETER then the server is there
        // so we can continue
        // else if the error is something else then try to reconnect by closing and
        // reopening this connection

        if (hrTest != WBEM_E_INVALID_PARAMETER) {
            PdhiCloseWbemServer (pThisServer);
            pdhStatus = PdhiAddWbemServer (
                szMachineNameArg,
                &pThisServer);
        }
    }

    *pWbemServer = pThisServer;

    if (szWideMachineName != NULL) G_FREE (szWideMachineName);

    if (pdhStatus == ERROR_SUCCESS) pThisServer->lRefCount++;

    return pdhStatus;
}

PDH_FUNCTION
PdhiFreeAllWbemServers (
)
{
    PPDHI_WBEM_SERVER_DEF pThisServer;
    PPDHI_WBEM_SERVER_DEF pNextServer;

    pThisServer = pFirstWbemServer;
    while (pThisServer != NULL) {
        pNextServer = pThisServer->pNext;
        PdhiCloseWbemServer (pThisServer);
        G_FREE(pThisServer);
        pThisServer = pNextServer;
    }
    pFirstWbemServer = NULL;
    return ERROR_SUCCESS;
}

BOOL
IsWbemDataSource (
    IN  LPCWSTR  szDataSource
)
{
    if (DataSourceTypeW(szDataSource) == DATA_SOURCE_WBEM)
        return TRUE;
    else
        return FALSE;
}

PDH_FUNCTION
PdhiEnumWbemMachines (
    IN      LPVOID      pMachineList,
    IN      LPDWORD     pcchBufferSize,
    IN      BOOL        bUnicode
)
{
    PDH_STATUS  pdhStatus;
    PPDHI_WBEM_SERVER_DEF pThisServer = NULL;
    DWORD   dwCharsLeftInBuffer = *pcchBufferSize;
    DWORD   dwBufferSize = 0;
    DWORD   dwStrLen;
    DWORD   dwResult;

    assert (pcchBufferSize != NULL);

    // test to see if we've connected to the local machine yet, if not then do it
    if (pFirstWbemServer == NULL) {
        // add local machine
        pdhStatus = PdhiAddWbemServer (
            NULL,
            &pThisServer);
    }

    // walk down list of known machines and find the machines that are using
    // the specified name space.

    pThisServer = pFirstWbemServer;
    while (pThisServer != NULL) {
        dwStrLen = lstrlenW (pThisServer->szMachine);
        if ((pMachineList != NULL) && (dwCharsLeftInBuffer > dwStrLen)) {
            // then it will fit so add it
            dwResult = AddUniqueWideStringToMultiSz (
                pMachineList, pThisServer->szMachine, bUnicode);
            if (dwResult > 0) {
                dwBufferSize = dwResult;
                dwCharsLeftInBuffer = *pcchBufferSize - dwBufferSize;
            } // else
            // this string is already in the list so
            // nothing was added
        } else {
            // just add the string length to estimate the buffer size
            // required
            dwCharsLeftInBuffer = 0; // to prevent any other strings from being added
            dwBufferSize += dwStrLen + 1;
        }
        pThisServer = pThisServer->pNext;
    }// end of while loop

    if (dwBufferSize <= *pcchBufferSize) {
        // add terminating MSZ Null char size
        dwBufferSize++;
        pdhStatus = ERROR_SUCCESS;
    } else {
        // there wasn't enough room. See if a buffer was passed in
        if (pMachineList != NULL) {
            // then this is an error
            pdhStatus = PDH_MORE_DATA;
        } else {
            // this was just a size query so it's ok
            pdhStatus = ERROR_SUCCESS;
        }
    }
    // return the size used or required
    *pcchBufferSize = dwBufferSize;

    return pdhStatus;
}

PDH_FUNCTION
PdhiEnumWbemObjects (
    IN  LPCWSTR     szWideMachineName,
    IN  LPVOID      mszObjectList,
    IN  LPDWORD     pcchBufferSize,
    IN  DWORD       dwDetailLevel,
    IN  BOOL        bRefresh,       // ignored
    IN  BOOL        bUnicode)
{
    // this function enumerates the classes that are subclassed
    // from the Win32_PerfRawData Superclass
    PDH_STATUS              pdhStatus;
    PPDHI_WBEM_SERVER_DEF   pThisServer;
    HRESULT                 hResult;
    DWORD                   dwCharsLeftInBuffer = *pcchBufferSize;
    DWORD                   dwBufferSize = 0;
    DWORD                   dwStrLen;
    DWORD                   dwRtnCount;
    DWORD                   dwResult;
    DWORD                   dwDetailLevelDesired;
    DWORD                   dwItemDetailLevel = 0;
    LPWSTR                  szClassName;
    VARIANT                 vName;
    VARIANT                 vDetailLevel;
    BSTR                    bsTemp = NULL;
    BSTR                    bsDisplayName = NULL;
    BSTR                    bsClass = NULL;
    BSTR                    bsCostly = NULL;
    BSTR                    bsDetailLevel = NULL;

    BOOL                    bGetCostlyItems = FALSE;
    BOOL                    bIsCostlyItem = FALSE;

    IEnumWbemClassObject    *pEnum = NULL;
    IWbemClassObject        *pThisClass = NULL;
    IWbemQualifierSet       *pQualSet = NULL;

    DBG_UNREFERENCED_PARAMETER (bRefresh);

    VariantInit (&vName);
    VariantInit (&vDetailLevel);

    pdhStatus = PdhiConnectWbemServer (
        szWideMachineName,
        &pThisServer);

    if (pdhStatus == ERROR_SUCCESS) {
        // create an enumerator of the PerfRawData class
        bsTemp = SysAllocString (cszPerfRawData);
        hResult = pThisServer->pSvc->CreateClassEnum (
            bsTemp,
            WBEM_FLAG_DEEP | WBEM_FLAG_USE_AMENDED_QUALIFIERS,
            NULL,
            &pEnum);
        SysFreeString (bsTemp);

		// Set security on the proxy
		if ( SUCCEEDED( hResult ) )
		{
			hResult = SetWbemSecurity( pEnum );
		}

        if (hResult != WBEM_NO_ERROR) {
            pdhStatus = PDH_WBEM_ERROR;
            SetLastError (hResult);
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // set costly flag
        bGetCostlyItems = ((dwDetailLevel & PERF_DETAIL_COSTLY) == PERF_DETAIL_COSTLY);
        dwDetailLevelDesired = (DWORD)(dwDetailLevel & PERF_DETAIL_STANDARD);
        bsCostly = SysAllocString (cszCostly);
        bsDisplayName = SysAllocString (cszDisplayname);
        bsClass = SysAllocString (cszClass);
        bsDetailLevel = SysAllocString (cszPerfdetail);
        while (TRUE) {
            hResult = pEnum->Next (
                0,      // timeout
                1,      // return only 1 object
                &pThisClass,
                &dwRtnCount);

            // no more classes
            if (dwRtnCount == 0) break;

            // get the display name of this class
            bIsCostlyItem = FALSE; // assume it's not unless proven otherwise
            pThisClass->GetQualifierSet (&pQualSet);
            if (pQualSet != NULL) {
                VariantClear (&vName);
                hResult = pQualSet->Get (bsCostly, 0, &vName, 0);
                if (hResult == S_OK) {
                    bIsCostlyItem = TRUE;
                }
                hResult = pQualSet->Get (bsDetailLevel, 0, &vDetailLevel, 0);
                if (hResult == S_OK) {
                    dwItemDetailLevel = (DWORD)V_I4(&vDetailLevel);
                } else {
                    dwItemDetailLevel = 0;
                }
                VariantClear (&vName);
                hResult = pQualSet->Get (bsDisplayName, 0, &vName, 0);
                pQualSet->Release();
            } else {
                hResult = WBEM_E_NOT_FOUND;
            }

            if (hResult == WBEM_E_NOT_FOUND) {
                // then this has not display name so
                // pull the class name
                hResult = pThisClass->Get (bsClass, 0, &vName, 0, 0);
            }

            if (hResult == WBEM_E_NOT_FOUND) {
                szClassName = (LPWSTR)cszNotFound;
            } else {
                szClassName = (LPWSTR)V_BSTR(&vName);
            }

            if (((bIsCostlyItem && bGetCostlyItems) || // if costly and we want them
                (!bIsCostlyItem)) && (dwItemDetailLevel <= dwDetailLevelDesired)) {
                dwStrLen = lstrlenW (szClassName);
                if ((mszObjectList != NULL) && (dwCharsLeftInBuffer > dwStrLen)) {
                    // then it will fit so add it
                    dwResult = AddUniqueWideStringToMultiSz (
                        mszObjectList, szClassName, bUnicode);
                    if (dwResult > 0) {
                        dwBufferSize = dwResult;
                        dwCharsLeftInBuffer = *pcchBufferSize - dwBufferSize;
                    } // else
                } else {
                    // just add the string length to estimate the buffer size
                    // required
                    dwCharsLeftInBuffer = 0; // to prevent any other strings from being added
                    dwBufferSize += dwStrLen + 1;
                }
            }
            // clear the variant
            VariantClear (&vName);
            VariantClear (&vDetailLevel);

            // free this class
            pThisClass->Release();
        }
        SysFreeString (bsDisplayName);
        SysFreeString (bsClass);
        SysFreeString (bsCostly);
        SysFreeString (bsDetailLevel);

        if (dwBufferSize <= *pcchBufferSize) {
            pdhStatus = ERROR_SUCCESS;
        } else {
            // there wasn't enough room. See if a buffer was passed in
            if (mszObjectList != NULL) {
                // then this is an error
                pdhStatus = PDH_MORE_DATA;
            } else {
                // add terminating MSZ Null char size
                dwBufferSize++;
                // this was just a size query so it's ok
                pdhStatus = ERROR_SUCCESS;
            }
        }
        // return the size used or required
        *pcchBufferSize = dwBufferSize;
    }

    VariantClear (&vName);
    VariantClear (&vDetailLevel);

    if (pEnum != NULL) pEnum->Release();

    pdhStatus = PdhiDisconnectWbemServer (pThisServer);

    return pdhStatus;
}

PDH_FUNCTION
PdhiGetDefaultWbemObject (
    IN  LPCWSTR     szMachineName,
    IN  LPVOID      szDefaultObjectName,
    IN  LPDWORD     pcchBufferSize,
    IN  BOOL        bUnicode)
{
    // walk down the list of WBEM perf classes and find the one with the
    // default qualifier

    PDH_STATUS              pdhStatus;
    PPDHI_WBEM_SERVER_DEF   pThisServer;
    HRESULT                 hResult;
    DWORD                   dwCharsLeftInBuffer = *pcchBufferSize;
    DWORD                   dwBufferSize = 0;
    DWORD                   dwStrLen;
    DWORD                   dwRtnCount;
    LPWSTR                  szClassName;
    VARIANT                 vName;
    BSTR                    bsTemp = NULL;
    BSTR                    bsDisplayName = NULL;
    BSTR                    bsClass = NULL;
    BSTR                    bsPerfDefault = NULL;
    BOOL                    bDefaultFlag = FALSE;

    IEnumWbemClassObject    *pEnum = NULL;
    IWbemClassObject        *pThisClass = NULL;
    IWbemQualifierSet       *pQualSet = NULL;

    VariantInit (&vName);

    pdhStatus = PdhiConnectWbemServer (
        szMachineName,
        &pThisServer);

    if (pdhStatus == ERROR_SUCCESS) {
        // create an enumerator of the PerfRawData class
        bsTemp = SysAllocString (cszPerfRawData);
        hResult = pThisServer->pSvc->CreateClassEnum (
            bsTemp,
            WBEM_FLAG_DEEP | WBEM_FLAG_USE_AMENDED_QUALIFIERS,
            NULL,
            &pEnum);
        SysFreeString (bsTemp);

		// Set security on the proxy
		if ( SUCCEEDED( hResult ) )
		{
			hResult = SetWbemSecurity( pEnum );
		}

        if (hResult != WBEM_NO_ERROR) {
            pdhStatus = PDH_WBEM_ERROR;
            SetLastError (hResult);
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        bsDisplayName = SysAllocString (cszDisplayname);
        bsClass = SysAllocString (cszClass);
        bsPerfDefault = SysAllocString (cszPerfdefault);
        while (TRUE) {
            hResult = pEnum->Next (
                0,      // timeout
                1,      // return only 1 object
                &pThisClass,
                &dwRtnCount);

            // no more classes
            if (dwRtnCount == 0) break;

            // get the display name of this class
            pThisClass->GetQualifierSet (&pQualSet);
            if (pQualSet != NULL) {
                hResult = pQualSet->Get (bsPerfDefault, 0, &vName, 0);
            } else {
                hResult = WBEM_E_NOT_FOUND;
            }

            if (hResult == WBEM_E_NOT_FOUND) {
                bDefaultFlag = FALSE;
            } else {
                bDefaultFlag = (BOOL)V_BOOL(&vName);
            }

            if (bDefaultFlag) {
                VariantClear(&vName);
                hResult = pQualSet->Get (bsDisplayName, 0, &vName, 0);
                szClassName = (LPWSTR)V_BSTR(&vName);
                dwStrLen = lstrlenW (szClassName);
                if (dwStrLen < *pcchBufferSize) {
                    // then copy it down
                    if (szDefaultObjectName != NULL) {
                        if (bUnicode) {
                            lstrcpyW ((LPWSTR)szDefaultObjectName, szClassName);
                        } else {
                            wcstombs ((LPSTR)szDefaultObjectName, szClassName, dwStrLen+1);
                        }
                        dwBufferSize = dwStrLen + 1;
                    }
                    pdhStatus = ERROR_SUCCESS;
                } else {
                    if (szDefaultObjectName != NULL) {
                        pdhStatus = PDH_MORE_DATA;
                    } else {
                        pdhStatus = ERROR_SUCCESS;
                    }
                }
                // found the default so release the set and bail out here
                pQualSet->Release();
                break;
            }

            // clear the variant
            VariantClear (&vName);

            // free this qualifier set
            pQualSet->Release();
            // free this class
            pThisClass->Release();
        }
        SysFreeString (bsPerfDefault);
        SysFreeString (bsDisplayName);
        SysFreeString (bsClass);
    }

    // return the size used or required
    *pcchBufferSize = dwBufferSize;

    if (pEnum != NULL) pEnum->Release();

    pdhStatus = PdhiDisconnectWbemServer (pThisServer);

    VariantClear (&vName);

    return pdhStatus;
}

PDH_FUNCTION
PdhiEnumWbemObjectItems (
    IN LPCWSTR      szWideMachineName,
    IN LPCWSTR      szWideObjectName,
    IN LPVOID       mszCounterList,
    IN LPDWORD      pcchCounterListLength,
    IN LPVOID       mszInstanceList,
    IN LPDWORD      pcchInstanceListLength,
    IN DWORD        dwDetailLevel,
    IN DWORD        dwFlags,
    IN BOOL         bUnicode
)
{

    PDH_STATUS          pdhStatus = ERROR_SUCCESS;
    DWORD               dwStrLen;
    PPDHI_WBEM_SERVER_DEF   pThisServer;
    HRESULT                 hResult;
    DWORD               dwReturnCount;
    DWORD               dwCounterStringLen = 0;
    DWORD               dwInstanceStringLen = 0;
    LPWSTR              szNextWideString = NULL;
    LPSTR               szNextAnsiString = NULL;
    WCHAR               szObjectClassName[MAX_PATH];
    BSTR                bsName = NULL;
    BSTR                bsClassName = NULL;
    BOOL                bSingletonClass = FALSE;
    VARIANT             vName;

    IEnumWbemClassObject    *pEnum = NULL;
    IWbemClassObject        *pThisClass = NULL;
    IWbemQualifierSet       *pQualSet = NULL;

    DBG_UNREFERENCED_PARAMETER (dwFlags);

    assert (szWideObjectName != NULL);
    assert (pcchCounterListLength != NULL);
    assert (pcchInstanceListLength != NULL);

    pdhStatus = PdhiConnectWbemServer (
        szWideMachineName,
        &pThisServer);

    // enumerate the instances
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhiWbemGetObjectClassName (
            pThisServer,
            szWideObjectName,
            &szObjectClassName[0],
            sizeof(szObjectClassName) / sizeof(szObjectClassName[0]),
            &pThisClass);

        assert (pThisClass != NULL);

        if (pdhStatus == ERROR_SUCCESS) {
            bSingletonClass = PdhiIsSingletonClass (pThisClass);

        } else {
            //unable to find matching perf class
        }
    }

    //enumerate the counter properties

    if (pdhStatus == ERROR_SUCCESS) {
        SAFEARRAY   *psaNames = NULL;
        long        lLower, lUpper, lCount;
        BSTR        bsPropName = NULL;
        BSTR        bsCountertype = NULL;
        BSTR        bsDisplayname = NULL;
        BSTR        bsDetailLevel = NULL;
        VARIANT     vCountertype;
        VARIANT     vDetailLevel;
        DWORD       dwItemDetailLevel;

        VariantInit (&vName);
        VariantInit (&vCountertype);
        VariantInit (&vDetailLevel);

        assert (pThisClass != NULL);

        dwDetailLevel &= PERF_DETAIL_STANDARD; // mask off any inappropriate bits

        // get the properties of this class as a Safe Array
        hResult = pThisClass->GetNames (NULL,
            WBEM_FLAG_NONSYSTEM_ONLY, NULL, &psaNames);
        if (hResult == WBEM_NO_ERROR) {
            hResult = SafeArrayGetLBound (psaNames, 1, &lLower);
            if (hResult == S_OK) {
                hResult = SafeArrayGetUBound (psaNames, 1, &lUpper);
            }
            if (hResult == S_OK) {
                szNextAnsiString = (LPSTR)mszCounterList;
                szNextWideString = (LPWSTR)mszCounterList;
                bsCountertype = SysAllocString (cszCountertype);
                bsDisplayname = SysAllocString (cszDisplayname);
                bsDetailLevel = SysAllocString (cszPerfdetail);
                for (lCount = lLower; lCount <= lUpper; lCount++) {
                    hResult = SafeArrayGetElement (psaNames, &lCount, &bsPropName);
                    if (hResult == S_OK) {
                        // get the qualifier set for this property
                        hResult = pThisClass->GetPropertyQualifierSet (
                            bsPropName, &pQualSet);
                        if (hResult == WBEM_NO_ERROR) {
                            LONG    lCounterType;
                            hResult = pQualSet->Get (bsDetailLevel, 0, &vDetailLevel, 0);
                            if (hResult == S_OK) {
                                dwItemDetailLevel = (DWORD)V_I4(&vDetailLevel);
                            } else {
                                dwItemDetailLevel = 0;
                            }

                            // make sure this is a perf counter property
                            hResult = pQualSet->Get (bsCountertype, 0, &vCountertype, NULL);
                            if (hResult == WBEM_NO_ERROR) {
                                lCounterType = V_I4(&vCountertype);
                                // then see if this is a displayable counter
                                if ((!(lCounterType & PERF_DISPLAY_NOSHOW) ||
                                     (lCounterType == PERF_AVERAGE_BULK)) &&
                                    (dwItemDetailLevel <= dwDetailLevel)) {
                                    // by testing for the counter type
                                    // get the display name for this property
                                    hResult = pQualSet->Get (bsDisplayname, 0, &vName, NULL);
                                    if (hResult == WBEM_NO_ERROR) {
                                        // display name found
                                        dwStrLen = lstrlenW (V_BSTR(&vName)) + 1;
                                        if (mszCounterList != NULL) {
                                            if ((dwCounterStringLen + dwStrLen) < *pcchCounterListLength) {
                                                if (bUnicode) {
                                                    lstrcpyW (szNextWideString, V_BSTR(&vName));
                                                    szNextWideString += dwStrLen;
                                                } else {
                                                    wcstombs (szNextAnsiString, V_BSTR(&vName), dwStrLen);
                                                    szNextAnsiString += dwStrLen;
                                                }
                                            } else {
                                                pdhStatus = PDH_MORE_DATA;
                                            }
                                        }
                                        dwCounterStringLen += dwStrLen;
                                    }
                                } else {
                                    // this is a "don't show" counter so skip it
                                }
                            } else {
                                // unable to get the counter type so it's probably
                                // not a perf counter property, skip it and continue
                            }
                            VariantClear (&vName);
                            VariantClear (&vCountertype);
                            VariantClear (&vDetailLevel);

                            pQualSet->Release();
                        } else {
                            // no properties so continue with the next one
                        }
                    } else {
                        // unable to read element in SafeArray
                        pdhStatus = PDH_WBEM_ERROR;
                        SetLastError(hResult);
                    }
                } // end for each element in SafeArray
                if (bsCountertype != NULL) SysFreeString (bsCountertype);
                if (bsDisplayname != NULL) SysFreeString (bsDisplayname);
                if (bsDetailLevel != NULL) SysFreeString (bsDetailLevel);
            } else {
                // unable to get array boundries
                pdhStatus = PDH_WBEM_ERROR;
                SetLastError (hResult);
            }
        } else {
            // unable to get property strings
            pdhStatus = PDH_WBEM_ERROR;
            SetLastError (hResult);
        }

        if (bUnicode) {
            if (szNextWideString != NULL) {
                if (szNextWideString != (LPWSTR)mszCounterList) {
                    dwCounterStringLen++;
                    *szNextWideString++ = 0;
                } else {
                    // nothing returned
                    dwCounterStringLen = 0;
                }
            } else {
                // then this is just a length query so return
                // include the the MSZ term null char
                dwCounterStringLen++;
            }
        } else {
            if (szNextAnsiString != NULL) {
                if (szNextAnsiString != (LPSTR)mszCounterList) {
                    dwCounterStringLen++;
                    *szNextAnsiString++ = 0;
                } else {
                    dwCounterStringLen = 0;
                }
            } else {
                // then this is just a length query so return
                // include the the MSZ term null char
                dwCounterStringLen++;
            }
        }

        VariantClear (&vName);
        VariantClear (&vCountertype);
        VariantClear (&vDetailLevel);

        *pcchCounterListLength = dwCounterStringLen;
    }

    pThisClass->Release();

    // Get instance strings if necessary

    if (pdhStatus == ERROR_SUCCESS) {
        szNextAnsiString = (LPSTR)mszInstanceList;
        szNextWideString = (LPWSTR)mszInstanceList;
        if (!bSingletonClass) {
            bsName = SysAllocString (cszName);
            bsClassName = SysAllocString(szObjectClassName);
            // get Create enumerator for this class and get the instances
            hResult = pThisServer->pSvc->CreateInstanceEnum (
                bsClassName,
                WBEM_FLAG_DEEP,
                NULL,
                &pEnum);

			// Set security on the proxy
			if ( SUCCEEDED( hResult ) )
			{
				hResult = SetWbemSecurity( pEnum );
			}

            if (hResult != WBEM_NO_ERROR) {
                pdhStatus = PDH_WBEM_ERROR;
                SetLastError (hResult);
            } else {
                while (TRUE) {
                    hResult = pEnum->Next (
                        0,
                        1,
                        &pThisClass,
                        &dwReturnCount);

                    if (dwReturnCount == 0) {
                        // no more instances
                        break;
                    } else {
                        // name of this instance is in the NAME property
                        hResult = pThisClass->Get (
                            bsName, 0,
                            &vName, 0, 0);
                        if (hResult == WBEM_NO_ERROR) {
                            dwStrLen = lstrlenW (V_BSTR(&vName)) + 1;
                            if (mszInstanceList != NULL) {
                                if ((dwInstanceStringLen + dwStrLen) < *pcchInstanceListLength) {
                                    if (bUnicode) {
                                        lstrcpyW (szNextWideString, V_BSTR(&vName));
                                        szNextWideString += dwStrLen;
                                    } else {
                                        wcstombs (szNextAnsiString, V_BSTR(&vName), dwStrLen);
                                        szNextAnsiString += dwStrLen;
                                    }
                                } else {
                                    pdhStatus = PDH_MORE_DATA;
                                }
                            }
                            dwInstanceStringLen += dwStrLen;
                        }
                        // clear the variant
                        VariantClear (&vName);

                    }
                    // free this class
                    pThisClass->Release();
                } // end while (TRUE)
            }
            if (bsName != NULL) SysFreeString (bsName);
            if (pEnum != NULL) pEnum->Release();
        }

        if (bUnicode) {
            if (szNextWideString != NULL) {
                if (szNextWideString != (LPWSTR)mszInstanceList) {
                    *szNextWideString++ = 0;
                    dwInstanceStringLen++;
                } else {
                    dwInstanceStringLen = 0;
                }
            } else {
                // then this is just a length query so return
                // include the the MSZ term null char
                    dwInstanceStringLen++;
            }
        } else {
            if (szNextAnsiString != NULL) {
                if (szNextAnsiString != (LPSTR)mszInstanceList) {
                    *szNextAnsiString++ = 0;
                    dwInstanceStringLen++;
                } else {
                    dwInstanceStringLen = 0;
                }
            } else {
                // then this is just a length query so return
                // include the the MSZ term null char
                    dwInstanceStringLen++;
            }
        }
        *pcchInstanceListLength = dwInstanceStringLen;
    }

    if (bsClassName != NULL) SysFreeString (bsClassName);
    VariantClear (&vName);

    pdhStatus = PdhiDisconnectWbemServer (pThisServer);

    return pdhStatus;
}

PDH_FUNCTION
PdhiGetDefaultWbemProperty (
    IN LPCWSTR      szMachineName,
    IN LPCWSTR      szObjectName,
    IN LPVOID       szDefaultCounterName,
    IN LPDWORD      pcchBufferSize,
    IN BOOL         bUnicode
)
{
    PDH_STATUS          pdhStatus = ERROR_SUCCESS;
    DWORD               dwStrLen;
    PPDHI_WBEM_SERVER_DEF   pThisServer;
    HRESULT                 hResult;
    DWORD               dwCounterStringLen = 0;
    DWORD               dwInstanceStringLen = 0;
    WCHAR               szObjectClassName[MAX_PATH];
    BSTR                bsName = NULL;
    BSTR                bsClassName = NULL;

    IWbemClassObject        *pThisClass = NULL;
    IWbemQualifierSet       *pQualSet = NULL;

    assert (szMachineName != NULL);
    assert (szObjectName != NULL);
    assert (pcchBufferSize != NULL);

    pdhStatus = PdhiConnectWbemServer (
        szMachineName,
        &pThisServer);

    // enumerate the instances
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhiWbemGetObjectClassName (
            pThisServer,
            szObjectName,
            &szObjectClassName[0],
            sizeof(szObjectClassName) / sizeof(szObjectClassName[0]),
            &pThisClass);
    }

    //enumerate the counter properties

    if (pdhStatus == ERROR_SUCCESS) {
        SAFEARRAY   *psaNames = NULL;
        long        lLower, lUpper, lCount;
        BSTR        bsPropName = NULL;
        BSTR        bsCountertype = NULL;
        BSTR        bsDisplayname = NULL;
        BSTR        bsPerfDefault = NULL;
        VARIANT     vName, vCountertype;

        VariantInit (&vName);
        VariantInit (&vCountertype);

        // get the properties of this class as a Safe Array
        hResult = pThisClass->GetNames (NULL,
            WBEM_FLAG_NONSYSTEM_ONLY, NULL, &psaNames);
        if (hResult == WBEM_NO_ERROR) {
            hResult = SafeArrayGetLBound (psaNames, 1, &lLower);
            if (hResult == S_OK) {
                hResult = SafeArrayGetUBound (psaNames, 1, &lUpper);
            }
            if (hResult == S_OK) {
                bsDisplayname = SysAllocString (cszDisplayname);
                bsPerfDefault = SysAllocString (cszPerfdefault);
                for (lCount = lLower; lCount <= lUpper; lCount++) {
                    hResult = SafeArrayGetElement (psaNames, &lCount, &bsPropName);
                    if (hResult == S_OK) {
                        // get the qualifier set for this property
                        hResult = pThisClass->GetPropertyQualifierSet (
                            bsPropName, &pQualSet);
                        if (hResult == WBEM_NO_ERROR) {
                            // make sure this is a perf counter property
                            hResult = pQualSet->Get (bsPerfDefault, 0, &vCountertype, NULL);
                            if (hResult == WBEM_NO_ERROR) {
                                if ((BOOL)V_BOOL(&vCountertype)) {
                                    // found the default property so load it and return
                                    hResult = pQualSet->Get (bsDisplayname, 0, &vName, NULL);
                                    if (hResult == WBEM_NO_ERROR) {
                                        // display name found
                                        dwStrLen = lstrlenW (V_BSTR(&vName)) + 1;
                                        if (dwStrLen < *pcchBufferSize) {
                                            if (szDefaultCounterName != NULL) {
                                                if (bUnicode) {
                                                    lstrcpyW ((LPWSTR)szDefaultCounterName,
                                                        (LPWSTR)V_BSTR(&vName));
                                                } else {
                                                    wcstombs ((LPSTR)szDefaultCounterName,
                                                        (LPWSTR)V_BSTR(&vName),
                                                        dwStrLen);
                                                }
                                                dwCounterStringLen = dwStrLen;
                                                pdhStatus = ERROR_SUCCESS;
                                            } else {
                                                // no buffer to write to
                                            }
                                        } else {
                                            // not enough room
                                            if (szDefaultCounterName != NULL) {
                                                pdhStatus = ERROR_MORE_DATA;
                                            } else {
                                                pdhStatus = ERROR_SUCCESS;
                                            }
                                        }
                                        // free qualifier set
                                        pQualSet->Release();
                                        // now leave
                                        break;
                                    } else {
                                        // no qualifier so assume FALSE
                                    }
                                } else {
                                    // value found but is FALSE
                                }
                                // free the qualifier set
                                pQualSet->Release();
                            }
                            VariantClear (&vName);
                            VariantClear (&vCountertype);
                        } else {
                            // no properties so continue with the next one
                        }
                    } else {
                        // unable to read element in SafeArray
                        pdhStatus = PDH_WBEM_ERROR;
                        SetLastError(hResult);
                    }
                } // end for each element in SafeArray
                if (bsPerfDefault != NULL) SysFreeString (bsPerfDefault);
                if (bsDisplayname != NULL) SysFreeString (bsDisplayname);
            } else {
                // unable to get array boundries
                pdhStatus = PDH_WBEM_ERROR;
                SetLastError (hResult);
            }
        } else {
            // unable to get property strings
            pdhStatus = PDH_WBEM_ERROR;
            SetLastError (hResult);
        }

        VariantClear (&vName);
        VariantClear (&vCountertype);

        pThisClass->Release();
    }
    *pcchBufferSize = dwCounterStringLen;

    pdhStatus = PdhiDisconnectWbemServer (pThisServer);

    return pdhStatus;
}

PDH_FUNCTION
PdhiEncodeWbemPathW (
    IN      PDH_COUNTER_PATH_ELEMENTS_W *pCounterPathElements,
    IN      LPWSTR                      szFullPathBuffer,
    IN      LPDWORD                     pcchBufferSize,
    IN      LANGID                      LangId,
    IN      DWORD                       dwFlags
)
/*++

  converts a set of path elements in either Registry or WBEM format
  to a path in either Registry or WBEM format as defined by the flags.

--*/
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    DWORD       dwBuffSize;
    LPWSTR      szTempPath;
    DWORD       dwCurSize = 0;

    LPWSTR      szThisChar;
    IWbemClassObject        *pWbemClass = NULL;
    PPDHI_WBEM_SERVER_DEF   pWbemServer = NULL;

    DBG_UNREFERENCED_PARAMETER (LangId);

    assert (pCounterPathElements != NULL); // this is not allowed
    assert (dwFlags != 0); // this should be caught by the calling fn.
    assert (pcchBufferSize != NULL); // this is required

    // create a working buffer the same size as the one passed in

    if (*pcchBufferSize == 0L) {
        dwBuffSize = *pcchBufferSize * sizeof(WCHAR);
    } else {
        dwBuffSize = 1024 * sizeof(WCHAR); // just something to work with
    }

    szTempPath = (LPWSTR)G_ALLOC(dwBuffSize);

    if (szTempPath == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // start by adding the machine name to the path
        if (pCounterPathElements->szMachineName != NULL) {
            lstrcpyW (szTempPath, pCounterPathElements->szMachineName);
            if (dwFlags == (PDH_PATH_WBEM_INPUT)) {
                // if this is a wbem element in to a registry path out,
                // then remove the namespace which occurs starting at the
                // second backslash
                for (szThisChar = &szTempPath[2];
                    (*szThisChar != 0) && (*szThisChar != L'\\');
                    szThisChar++);
                if (*szThisChar != 0) *szThisChar = 0;
            } else if (dwFlags == (PDH_PATH_WBEM_RESULT)) {
                // if this is a registry element in to a WBEM out, then
                // append the default namespace to the machine name
//NAMEFIX                lstrcatW (szTempPath, cszWbemDefaultPerfRoot);
            }
        } else {
            // no machine name specified so add the default machine
            // and default namespace for a wbem output path
            if (dwFlags == (PDH_PATH_WBEM_RESULT)) {
                lstrcpyW (szTempPath, cszDoubleBackSlashDot); // default machine
//NAMEFIX                lstrcatW (szTempPath, cszWbemDefaultPerfRoot);
            } else {
                // no entry required for the registry path
            }
        }
        dwCurSize = lstrlenW(szTempPath);

        // now add the object or class name
        if (pdhStatus == ERROR_SUCCESS) {
            if (pCounterPathElements->szObjectName != NULL) {
                DWORD   dwSize;
                WCHAR   szTempObjectString[1024];

                dwSize = 1024;
                // then the input is different from the output
                // so convert from one to the other
                // and default name space since perf counters won't be
                // found elsewhere
                pdhStatus = PdhiConnectWbemServer (
                    NULL, // use local machine
                    &pWbemServer);
                if (pdhStatus == ERROR_SUCCESS) {
                    if (dwFlags & PDH_PATH_WBEM_INPUT) {
                        // convert the WBEM Class to the display name
                        pdhStatus = PdhiWbemGetClassDisplayName (
                            pWbemServer,
                            pCounterPathElements->szObjectName,
                            &szTempObjectString[0],
                            dwSize,
                            &pWbemClass);
                        // add a backslash path separator for registry output
                        if (pdhStatus == ERROR_SUCCESS) {
                            if (dwFlags & PDH_PATH_WBEM_RESULT) {
                                lstrcatW(szTempPath, cszColon);
                                // just copy the string, but save
                                lstrcpyW (szTempObjectString, pCounterPathElements->szObjectName);
                            } else {
                                lstrcatW(szTempPath, cszBackSlash);
                                // copy the retrieved string
                            }
                        }
                    } else {
                        // convert the display name to a Wbem class name
                        pdhStatus = PdhiWbemGetObjectClassName (
                            pWbemServer,
                            pCounterPathElements->szObjectName,
                            &szTempObjectString[0],
                            dwSize,
                            &pWbemClass);
                        // add a colon path separator
                        lstrcatW(szTempPath, cszColon);
                    }
                    if (pdhStatus == ERROR_SUCCESS) {
                        //then add the string
                        lstrcatW(szTempPath, szTempObjectString);
                        dwCurSize += lstrlenW(szTempObjectString) + 1; // includes delimiter
                    }

                    pdhStatus = PdhiDisconnectWbemServer (pWbemServer);

                }
            } else {
                // no object name, so bad structure
                pdhStatus = PDH_CSTATUS_NO_OBJECT;
            }
        }

        // check for instance entries to add before adding the counter.
        if (pdhStatus == ERROR_SUCCESS) {
            if (pCounterPathElements->szInstanceName != NULL) {
                lstrcatW (szTempPath, cszLeftParen);
                dwCurSize += 1;
                if (pCounterPathElements->szParentInstance != NULL) {
                    lstrcatW (szTempPath, pCounterPathElements->szParentInstance);
                    lstrcatW (szTempPath, cszSlash);
                    dwCurSize += lstrlenW( pCounterPathElements->szParentInstance ) + 1;
                }
                lstrcatW (szTempPath, pCounterPathElements->szInstanceName);
                lstrcatW (szTempPath, cszRightParen);
                dwCurSize += lstrlenW( pCounterPathElements->szInstanceName ) + 1;
            } else {
                // this is OK
                assert (pCounterPathElements->szParentInstance == NULL);
                assert (pCounterPathElements->dwInstanceIndex == 0);
            }
        }

        // add counter name
        if (pdhStatus == ERROR_SUCCESS) {
            if (pCounterPathElements->szCounterName != NULL) {
                DWORD   dwSize;
                WCHAR   szTempCounterString[1024];

                dwSize = 1024;
                // then the input is different from the output
                // so convert from one to the other
                // and default name space since perf counters won't be
                // found elsewhere
                assert (pWbemServer != NULL);
                if (pdhStatus == ERROR_SUCCESS) {
                    // add a backslash path separator
                    lstrcatW(szTempPath, cszBackSlash);
                    if (dwFlags & PDH_PATH_WBEM_INPUT) {
                        // convert the WBEM Class to the display name
                        pdhStatus = PdhiWbemGetCounterDisplayName (
                            pWbemClass,
                            pCounterPathElements->szCounterName,
                            &szTempCounterString[0],
                            dwSize);
                        if (dwFlags & PDH_PATH_WBEM_RESULT) {
                            // just copy the string, but save
                            // the class pointer
                            lstrcpyW (szTempCounterString, pCounterPathElements->szCounterName);
                        } else {
                            // copy the retrieved string
                        }
                    } else {
                        // convert the display name to a Wbem class name
                        pdhStatus = PdhiWbemGetCounterPropertyName (
                            pWbemClass,
                            pCounterPathElements->szCounterName,
                            &szTempCounterString[0],
                            dwSize);
                    }
                    if (pdhStatus == ERROR_SUCCESS) {
                        //then add the string
                        lstrcatW(szTempPath, szTempCounterString);
                        dwCurSize += lstrlenW(szTempCounterString) + 1; // includes delimiter
                    }
                }
            } else {
                // no object name, so bad structure
                pdhStatus = PDH_CSTATUS_NO_COUNTER;
            }
        }

        assert (dwCurSize == (DWORD)lstrlenW(szTempPath));
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // copy path to the caller's buffer if it will fit
        assert (dwCurSize == (DWORD)lstrlenW(szTempPath));
        if (dwCurSize < *pcchBufferSize) {
            if (szFullPathBuffer != NULL) {
                lstrcpyW (szFullPathBuffer, szTempPath);
            }
        } else {
            if (szFullPathBuffer != NULL) {
                // the buffer passed in is too small
                pdhStatus = PDH_MORE_DATA;
            }
        }
        *pcchBufferSize = dwCurSize;
    }

    if (pWbemClass != NULL) pWbemClass->Release();

    return pdhStatus;
}

PDH_FUNCTION
PdhiEncodeWbemPathA (
    PDH_COUNTER_PATH_ELEMENTS_A *pCounterPathElements,
    LPSTR                       szFullPathBuffer,
    LPDWORD                     pcchBufferSize,
    LANGID                      LangId,
    DWORD                       dwFlags
)
{
    PDH_STATUS                  pdhStatus = ERROR_SUCCESS;
    LPWSTR                      wszNextString;
    LPWSTR                      wszReturnBuffer;
    PDH_COUNTER_PATH_ELEMENTS_W *pWideCounterPathElements;
    DWORD                       dwBuffSize;

    // convert elements structure to UNICODE and call W function

    // get required buffer size...
    dwBuffSize = sizeof (PDH_COUNTER_PATH_ELEMENTS_W);

    if (pCounterPathElements->szMachineName != NULL) {
        dwBuffSize += (lstrlenA(pCounterPathElements->szMachineName) + 1) * sizeof(WCHAR);
    }

    if (pCounterPathElements->szObjectName != NULL) {
        dwBuffSize += (lstrlenA(pCounterPathElements->szObjectName) + 1) * sizeof(WCHAR);
    }

    if (pCounterPathElements->szInstanceName != NULL) {
        dwBuffSize += (lstrlenA(pCounterPathElements->szInstanceName) + 1) * sizeof(WCHAR);
    }

    if (pCounterPathElements->szParentInstance != NULL) {
        dwBuffSize += (lstrlenA(pCounterPathElements->szParentInstance) + 1) * sizeof(WCHAR);
    }

    if (pCounterPathElements->szCounterName != NULL) {
        dwBuffSize += (lstrlenA(pCounterPathElements->szCounterName) + 1) * sizeof(WCHAR);
    }

    // add in room for the return buffer
    dwBuffSize += *pcchBufferSize * sizeof(WCHAR);

    pWideCounterPathElements = (PDH_COUNTER_PATH_ELEMENTS_W *)G_ALLOC(dwBuffSize);

    if (pWideCounterPathElements != NULL) {
        // populate the fields
        wszNextString = (LPWSTR)&pWideCounterPathElements[1];

        if (pCounterPathElements->szMachineName != NULL) {
            pWideCounterPathElements->szMachineName = wszNextString;
            mbstowcs (wszNextString,
                pCounterPathElements->szMachineName,
                (lstrlenA(pCounterPathElements->szMachineName) + 1));
            wszNextString += lstrlenA(pCounterPathElements->szMachineName) + 1;
        } else {
            pWideCounterPathElements->szMachineName = NULL;
        }

        if (pCounterPathElements->szObjectName != NULL) {
            pWideCounterPathElements->szObjectName = wszNextString;
            mbstowcs (wszNextString,
                pCounterPathElements->szObjectName,
                (lstrlenA(pCounterPathElements->szObjectName) + 1));
            wszNextString += (lstrlenA(pCounterPathElements->szObjectName) + 1);
        } else {
            pWideCounterPathElements->szObjectName = NULL;
        }

        if (pCounterPathElements->szInstanceName != NULL) {
            pWideCounterPathElements->szInstanceName = wszNextString;
            mbstowcs (wszNextString,
                pCounterPathElements->szInstanceName,
                (lstrlenA(pCounterPathElements->szInstanceName) + 1));
            wszNextString += (lstrlenA(pCounterPathElements->szInstanceName) + 1);
        } else {
            pWideCounterPathElements->szInstanceName = NULL;
        }

        if (pCounterPathElements->szParentInstance != NULL) {
            pWideCounterPathElements->szParentInstance = wszNextString;
            mbstowcs (wszNextString,
                pCounterPathElements->szParentInstance,
                (lstrlenA(pCounterPathElements->szParentInstance) + 1));
            wszNextString += (lstrlenA(pCounterPathElements->szParentInstance) + 1);
        } else {
            pWideCounterPathElements->szParentInstance = NULL;
        }

        if (pCounterPathElements->szCounterName != NULL) {
            pWideCounterPathElements->szCounterName = wszNextString;
            mbstowcs (wszNextString,
                pCounterPathElements->szCounterName,
                (lstrlenA(pCounterPathElements->szCounterName) + 1));
            wszNextString += (lstrlenA(pCounterPathElements->szCounterName) + 1);
        } else {
            pWideCounterPathElements->szCounterName = NULL;
        }

        pWideCounterPathElements->dwInstanceIndex =
            pCounterPathElements->dwInstanceIndex;

        if (szFullPathBuffer != NULL) {
            wszReturnBuffer = wszNextString;
        } else {
            wszReturnBuffer = NULL;
        }

        // call wide function
        pdhStatus = PdhiEncodeWbemPathW (
            pWideCounterPathElements,
            wszReturnBuffer,
            pcchBufferSize,
            LangId,
            dwFlags);

        if ((pdhStatus == ERROR_SUCCESS) && (szFullPathBuffer != NULL)) {
            // convert the wide path back to ANSI
            wcstombs (szFullPathBuffer, wszReturnBuffer, (*pcchBufferSize + 1));
        }

        G_FREE (pWideCounterPathElements);
    } else {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
    }

    return pdhStatus;

}

PDH_FUNCTION
PdhiDecodeWbemPathW (
    IN      LPCWSTR                     szFullPathBuffer,
    IN      PDH_COUNTER_PATH_ELEMENTS_W *pCounterPathElements,
    IN      LPDWORD                     pdwBufferSize,
    IN      LANGID                      LangId,
    IN      DWORD                       dwFlags
)
{
    PPDHI_COUNTER_PATH  pLocalCounterPath;
    PDH_STATUS          pdhStatus = ERROR_SUCCESS;
    DWORD               dwSize;
    LPWSTR              szString;
    WCHAR               wszTempBuffer[MAX_PATH];
    LPWSTR              szSrc;

    PPDHI_WBEM_SERVER_DEF   pThisServer = NULL;
    IWbemClassObject    *pThisClass = NULL;

    DBG_UNREFERENCED_PARAMETER (LangId);

     // allocate a temporary work buffer
    pLocalCounterPath = (PPDHI_COUNTER_PATH)G_ALLOC (
        (sizeof(PDHI_COUNTER_PATH) +
            2 * lstrlenW(szFullPathBuffer) * sizeof (WCHAR)));

    if (pLocalCounterPath != NULL) {
        dwSize = (DWORD)G_SIZE (pLocalCounterPath);
        assert (dwSize != NULL);

        if (pdhStatus == ERROR_SUCCESS) {
            // get WBEM server since we'll probably need it later
            if (ParseFullPathNameW (szFullPathBuffer,
                &dwSize, pLocalCounterPath,
                (dwFlags & PDH_PATH_WBEM_INPUT ? TRUE : FALSE))) {
                // parsed successfully so load into user's buffer
                if (*pdwBufferSize != 0) {
                    if (pCounterPathElements != NULL) {
                        // see if there's enough room
                        if (*pdwBufferSize >= dwSize) {
                            // there's room so copy / translate the data
                            szString = (LPWSTR)&pCounterPathElements[1];
                            if (pLocalCounterPath->szMachineName != NULL) {
                                pCounterPathElements->szMachineName = szString;
                                lstrcpyW (szString, pLocalCounterPath->szMachineName);
                                szString += lstrlenW (szString) + 1;
                                ALIGN_ON_DWORD (szString);
                            } else {
                                pCounterPathElements->szMachineName = NULL;
                            }
                            dwSize = (DWORD)((LPBYTE)szString - (LPBYTE)pCounterPathElements);
                        }

						// Now that we have the proper machine name,
						// connect to the server if we need to
						if (dwFlags != (PDH_PATH_WBEM_INPUT | PDH_PATH_WBEM_RESULT)) {
							pdhStatus = PdhiConnectWbemServer (
								pCounterPathElements->szMachineName, &pThisServer);
						} else {
							// this will just be a copy operation
							pdhStatus = ERROR_SUCCESS;
						}

						if ( pdhStatus == ERROR_SUCCESS ) {

							if (pLocalCounterPath->szObjectName != NULL) {
								pCounterPathElements->szObjectName = szString;
								if (dwFlags & PDH_PATH_WBEM_RESULT) {
									if (dwFlags & PDH_PATH_WBEM_INPUT) {
										// just copy
										szSrc = pLocalCounterPath->szObjectName;
									} else {
										// interpret the display name to a class name
										pdhStatus = PdhiWbemGetObjectClassName (
											pThisServer,
											pLocalCounterPath->szObjectName,
											wszTempBuffer,
											sizeof(wszTempBuffer) / sizeof(wszTempBuffer[0]),
											&pThisClass);
										if (pdhStatus == ERROR_SUCCESS) {
											szSrc = wszTempBuffer;
										}
									}
								} else {
									if (dwFlags & PDH_PATH_WBEM_INPUT) {
										// translate class name to a display name
										pdhStatus = PdhiWbemGetClassDisplayName (
											pThisServer, pLocalCounterPath->szObjectName,
											wszTempBuffer,
											sizeof(wszTempBuffer) / sizeof(wszTempBuffer[0]),
											&pThisClass);
										if (pdhStatus == ERROR_SUCCESS) {
											szSrc = wszTempBuffer;
										}
									} else {
										assert (dwFlags != 0); // this should be caught earlier
									}
								}

								dwSize += (lstrlenW(szSrc) +1) * sizeof(WCHAR);
								if (*pdwBufferSize >= dwSize) {
									lstrcpyW (szString, szSrc);
									szString += lstrlenW (szString) + 1;
									ALIGN_ON_DWORD (szString);
									dwSize = (DWORD)((LPBYTE)szString - (LPBYTE)pCounterPathElements);
								} else {
									// not enough room
									pdhStatus = PDH_INSUFFICIENT_BUFFER;
								}
							} else {
								pCounterPathElements->szObjectName = NULL;
							}


							if (pLocalCounterPath->szInstanceName != NULL) {
								pCounterPathElements->szInstanceName = szString;
								szSrc = pLocalCounterPath->szInstanceName;
								dwSize += (lstrlenW(szSrc) +1) * sizeof(WCHAR);
								if (*pdwBufferSize >= dwSize) {
									lstrcpyW (szString, szSrc);
									szString += lstrlenW (szString) + 1;
									ALIGN_ON_DWORD (szString);
									dwSize = (DWORD)((LPBYTE)szString - (LPBYTE)pCounterPathElements);
								} else {
									// not enough room
									pdhStatus = PDH_INSUFFICIENT_BUFFER;
								}

								if (pLocalCounterPath->szParentName != NULL) {
									pCounterPathElements->szParentInstance = szString;
									szSrc = pLocalCounterPath->szParentName;
									dwSize += (lstrlenW(szSrc) +1) * sizeof(WCHAR);
									if (*pdwBufferSize >= dwSize) {
										lstrcpyW (szString, szSrc);
										szString += lstrlenW (szString) + 1;
										ALIGN_ON_DWORD (szString);
										dwSize = (DWORD)((LPBYTE)szString - (LPBYTE)pCounterPathElements);
									} else {
										// not enough room
										pdhStatus = PDH_INSUFFICIENT_BUFFER;
									}
								} else {
									pCounterPathElements->szParentInstance = NULL;
								}

								pCounterPathElements->dwInstanceIndex =
									pLocalCounterPath->dwIndex;

							} else {
								pCounterPathElements->szInstanceName = NULL;
								pCounterPathElements->szParentInstance = NULL;
								pCounterPathElements->dwInstanceIndex = (DWORD)-1;
							}

							if (pLocalCounterPath->szCounterName != NULL) {
								pCounterPathElements->szCounterName = szString;
								if (dwFlags & PDH_PATH_WBEM_RESULT) {
									if (dwFlags & PDH_PATH_WBEM_INPUT) {
										// just copy
										szSrc = pLocalCounterPath->szCounterName;
									} else {
										// interpret the display name to a property name
										pdhStatus = PdhiWbemGetCounterPropertyName (
											pThisClass,
											pLocalCounterPath->szCounterName,
											wszTempBuffer,
											sizeof(wszTempBuffer) / sizeof(wszTempBuffer[0]));
										if (pdhStatus == ERROR_SUCCESS) {
											szSrc = wszTempBuffer;
										}
									}
								} else {
									if (dwFlags & PDH_PATH_WBEM_INPUT) {
										// translate class name to a display name
										pdhStatus = PdhiWbemGetCounterDisplayName (
											pThisClass, pLocalCounterPath->szCounterName,
											wszTempBuffer,
											sizeof(wszTempBuffer) / sizeof(wszTempBuffer[0]));
										if (pdhStatus == ERROR_SUCCESS) {
											szSrc = wszTempBuffer;
										}
									} else {
										assert (dwFlags != 0); // this should be caught earlier
									}
								}
								dwSize += (lstrlenW(szSrc) +1) * sizeof(WCHAR);
								if (*pdwBufferSize >= dwSize) {
									lstrcpyW (szString, szSrc);
									szString += lstrlenW (szString) + 1;
									ALIGN_ON_DWORD (szString);
									dwSize = (DWORD)((LPBYTE)szString - (LPBYTE)pCounterPathElements);
								} else {
									// not enough room
									pdhStatus = PDH_INSUFFICIENT_BUFFER;
								}
							} else {
								pCounterPathElements->szCounterName = NULL;
							}

						}	// If pdhStatus == ERROR_SUCCESS

                        dwSize = (DWORD)((LPBYTE)szString - (LPBYTE)pCounterPathElements);

                        *pdwBufferSize = dwSize;
                    } else {
                        // a null buffer pointer was passed int
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                } else {
                    // this is just a size check so return size required
                    *pdwBufferSize = dwSize * 2; // doubled to insure room for path expansions
                    pdhStatus = ERROR_SUCCESS;
                }
            } else {
                // unable to read path
                pdhStatus = PDH_INVALID_PATH;
            }
            // release class object if used
            if (pThisClass != NULL) pThisClass->Release();

			// Cleanup pThisServer if used
			if ( NULL != pThisServer )
			{
				pdhStatus = PdhiDisconnectWbemServer (pThisServer);
			}

        }
        G_FREE (pLocalCounterPath);
    } else {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhiDecodeWbemPathA (
    IN      LPCSTR                      szFullPathBuffer,
    IN      PDH_COUNTER_PATH_ELEMENTS_A *pCounterPathElements,
    IN      LPDWORD                     pdwBufferSize,
    IN      LANGID                      LangId,
    IN      DWORD                       dwFlags
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    LPWSTR      wszWidePath = NULL;
    PDH_COUNTER_PATH_ELEMENTS_W     *pWideElements = NULL;
    DWORD       dwSize;
    LPSTR       szNextString;

    wszWidePath = (LPWSTR)G_ALLOC((lstrlenA(szFullPathBuffer) + 1) * sizeof(WCHAR));

    if (wszWidePath == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // compute size of temp element buffer
        dwSize = *pdwBufferSize - sizeof(PDH_COUNTER_PATH_ELEMENTS_A);
        // dwSize now has the size of the buffer AFTER the structure so
        // adjust this for the longer char length to make it a fair comparison
        dwSize *= sizeof(WCHAR)/sizeof(CHAR);
        // and add back in the structure
        dwSize += sizeof(PDH_COUNTER_PATH_ELEMENTS_W);

        if (pCounterPathElements != NULL) {
            pWideElements = (PDH_COUNTER_PATH_ELEMENTS_W *)G_ALLOC(dwSize);
            if (pWideElements == NULL) {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        } else {
            pWideElements = NULL;
            pdhStatus = ERROR_SUCCESS;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // convert path to Wide
        mbstowcs (wszWidePath, szFullPathBuffer, lstrlenA(szFullPathBuffer));
        pdhStatus = PdhiDecodeWbemPathW (
            wszWidePath,
            pWideElements,
            &dwSize,
            LangId,
            dwFlags);

        if (pdhStatus == ERROR_SUCCESS) {
            if (pCounterPathElements != NULL) {
                // populate the fields of the caller's buffer
                szNextString = (LPSTR)&pCounterPathElements[1];

                if (pWideElements->szMachineName != NULL) {
                    pCounterPathElements->szMachineName = szNextString;
                    wcstombs (szNextString,
                        pWideElements->szMachineName,
                        (lstrlenW(pWideElements->szMachineName) + 1));
                    szNextString += lstrlenW(pWideElements->szMachineName) + 1;
                } else {
                    pCounterPathElements->szMachineName = NULL;
                }

                if (pWideElements->szObjectName != NULL) {
                    pCounterPathElements->szObjectName = szNextString;
                    wcstombs (szNextString,
                        pWideElements->szObjectName,
                        (lstrlenW(pWideElements->szObjectName) + 1));
                    szNextString += (lstrlenW(pWideElements->szObjectName) + 1);
                } else {
                    pCounterPathElements->szObjectName = NULL;
                }

                if (pWideElements->szInstanceName != NULL) {
                    pCounterPathElements->szInstanceName = szNextString;
                    wcstombs (szNextString,
                        pWideElements->szInstanceName,
                        (lstrlenW(pWideElements->szInstanceName) + 1));
                    szNextString += (lstrlenW(pWideElements->szInstanceName) + 1);
                } else {
                    pCounterPathElements->szInstanceName = NULL;
                }

                if (pWideElements->szParentInstance != NULL) {
                    pCounterPathElements->szParentInstance = szNextString;
                    wcstombs(szNextString,
                        pWideElements->szParentInstance,
                        (lstrlenW(pWideElements->szParentInstance) + 1));
                    szNextString += (lstrlenW(pWideElements->szParentInstance) + 1);
                } else {
                    pCounterPathElements->szParentInstance = NULL;
                }

                if (pWideElements->szCounterName != NULL) {
                    pCounterPathElements->szCounterName = szNextString;
                    wcstombs(szNextString,
                        pWideElements->szCounterName,
                        (lstrlenW(pWideElements->szCounterName) + 1));
                    szNextString += (lstrlenW(pWideElements->szCounterName) + 1);
                } else {
                    pCounterPathElements->szCounterName = NULL;
                }

                pCounterPathElements->dwInstanceIndex =
                    pWideElements->dwInstanceIndex;

                *pdwBufferSize = (DWORD)((LPBYTE)szNextString - (LPBYTE)pCounterPathElements);
            } else {
                // just return the size required adjusted for wide/ansi characters
                *pdwBufferSize = sizeof(PDH_COUNTER_PATH_ELEMENTS_A);
                dwSize -= sizeof(PDH_COUNTER_PATH_ELEMENTS_W);
                dwSize /= sizeof(WCHAR)/sizeof(CHAR);
                *pdwBufferSize += dwSize;
            }
        } else {
            // call to wide function failed so just return error
        }
    } else {
        // memory allocation failed so return error
    }

    if (pWideElements != NULL) G_FREE(pWideElements);
    if (wszWidePath != NULL) G_FREE(wszWidePath);

    return pdhStatus;
}

BOOL
WbemInitCounter (
    IN      PPDHI_COUNTER pCounter
)
/*++

Routine Description:

    Initialized the counter data structure by:
        Allocating the memory block to contain the counter structure
            and all the associated data fields. If this allocation
            is successful, then the fields are initialized by
            verifying the counter is valid.

Arguments:

    IN      PPDHI_COUNTER pCounter
        pointer of the counter to initialize using the system data

Return Value:

    TRUE if the counter was successfully initialized
    FALSE if a problem was encountered

    In either case, the CStatus field of the structure is updated to
    indicate the status of the operation.

--*/
{
    DWORD               dwResult;
    PDH_STATUS          pdhStatus;
    PPDHI_WBEM_SERVER_DEF   pWbemServer;
    HRESULT             hRes = S_OK;
    VARIANT             vCountertype;
    WCHAR               szBasePropertyName[MAX_PATH];
    WCHAR               szFreqPropertyName[MAX_PATH];
    WCHAR               szWbemItemPath[MAX_PATH];
    ULONGLONG           llValue;
    LONG                lOffset;

    PPDH_COUNTER_PATH_ELEMENTS_W    pPathElem = NULL;
    BOOL                            bReturn = TRUE;
    DWORD                           dwBufferSize = 0;
    BSTR                            bsPropName = NULL;
    BSTR                            bsCountertype = NULL;
    IWbemQualifierSet               *pQualSet = NULL;
    PPDHI_COUNTER                   pCounterInList = NULL;
    PPDHI_COUNTER_PATH              pPdhiCtrPath = NULL;

    VariantInit (&vCountertype);

    pCounter->dwFlags |= PDHIC_WBEM_COUNTER; // make sure WBEM flag is set

    // make sure the query has a refresher started already
    if (pCounter->pOwner->pRefresher == NULL) {
        // it hasn't been started so start now
        if (!bWbemInitialized) {
            CoInitializeEx (0, COINIT_MULTITHREADED);
            hRes = CoInitializeSecurity(
                NULL,   //Points to security descriptor
                0L,     //Count of entries in asAuthSvc
                NULL,   //Array of names to register
                NULL,   //Reserved for future use
                RPC_C_AUTHN_LEVEL_CONNECT,  //The default authentication level 
                                    // for proxies
                RPC_C_IMP_LEVEL_IMPERSONATE,    //The default impersonation level 
                                    // for proxies
                NULL,   //Authentication information for 
                        // each authentication service
                EOAC_AUTO_IMPERSONATE,   //Additional client and/or 
                                // server-side capabilities
                NULL    //Reserved for future use
                );
            bWbemInitialized = TRUE;
        }

//        dwResult = CoCreateInstance (CLSID_WbemRefresher, 0, CLSCTX_SERVER,
//            IID_IWbemRefresher, (LPVOID *)&pCounter->pOwner->pRefresher);

		dwResult = CoCreateRefresher( &pCounter->pOwner->pRefresher );

        if (dwResult != S_OK) {
            pCounter->pOwner->pRefresher = NULL;
            SetLastError (dwResult);
            bReturn = FALSE;
        } else {
            // open config interface
            dwResult = pCounter->pOwner->pRefresher->QueryInterface (
                IID_IWbemConfigureRefresher,
                (LPVOID *)&pCounter->pOwner->pRefresherCfg);
            if (dwResult != S_OK) {
                pCounter->pOwner->pRefresherCfg = NULL;
                pCounter->pOwner->pRefresher->Release();
                pCounter->pOwner->pRefresher = NULL;
                SetLastError (dwResult);
                bReturn = FALSE;
            }
        }
    }

    if (bReturn) {
        // so far so good, now figure out the WBEM path to add it to the
        // refresher
        dwBufferSize = lstrlenW(pCounter->szFullName) * sizeof(WCHAR) * 10;
        dwBufferSize += sizeof (PDH_COUNTER_PATH_ELEMENTS_W);

        pPathElem = (PPDH_COUNTER_PATH_ELEMENTS_W) G_ALLOC (dwBufferSize);
        // the path is display names, so convert to WBEM class names first

        if (pPathElem == NULL) {
            SetLastError (PDH_MEMORY_ALLOCATION_FAILURE);
            bReturn = FALSE;
        } else {
            pdhStatus = PdhiDecodeWbemPathW (
                pCounter->szFullName,
                pPathElem,
                &dwBufferSize,
                pCounter->pOwner->LangID,
                PDH_PATH_WBEM_RESULT);
            if (pdhStatus == ERROR_SUCCESS) {
                // continue
            } else {
                SetLastError (pdhStatus);
                bReturn = FALSE;
            }
        }
    }

    if (bReturn) {
        dwBufferSize *= 8; // just to be safe
        pPdhiCtrPath = (PPDHI_COUNTER_PATH) G_ALLOC (dwBufferSize);
        if (pPdhiCtrPath == NULL) {
            SetLastError (PDH_MEMORY_ALLOCATION_FAILURE);
            bReturn = FALSE;
        } else {
            // break path into display elements
            bReturn = ParseFullPathNameW (
                pCounter->szFullName,
                &dwBufferSize,
                pPdhiCtrPath,
                FALSE);
            if (bReturn) {
                // realloc to use only the memory needed
                pCounter->pCounterPath = (PPDHI_COUNTER_PATH)
                    G_REALLOC (pPdhiCtrPath, dwBufferSize);
                if ((pPdhiCtrPath != pCounter->pCounterPath) &&
                    (pCounter->pCounterPath != NULL)){
                    // the memory block moved so
                    // correct addresses inside structure
                    lOffset = (LONG)((ULONG_PTR)pCounter->pCounterPath -
                                     (ULONG_PTR)pPdhiCtrPath);
                    if (pCounter->pCounterPath->szMachineName) {
                        pCounter->pCounterPath->szMachineName = (LPWSTR)(
                            (LPBYTE)pCounter->pCounterPath->szMachineName + lOffset);
                    }
                    if (pCounter->pCounterPath->szObjectName) {
                        pCounter->pCounterPath->szObjectName = (LPWSTR)(
                            (LPBYTE)pCounter->pCounterPath->szObjectName + lOffset);
                    }
                    if (pCounter->pCounterPath->szInstanceName) {
                        pCounter->pCounterPath->szInstanceName = (LPWSTR)(
                            (LPBYTE)pCounter->pCounterPath->szInstanceName + lOffset);
                    }
                    if (pCounter->pCounterPath->szParentName) {
                        pCounter->pCounterPath->szParentName = (LPWSTR)(
                            (LPBYTE)pCounter->pCounterPath->szParentName + lOffset);
                    }
                    if (pCounter->pCounterPath->szCounterName) {
                        pCounter->pCounterPath->szCounterName = (LPWSTR)(
                            (LPBYTE)pCounter->pCounterPath->szCounterName + lOffset);
                    }
                }
            } else {
                // free the buffer
                G_FREE (pPdhiCtrPath);
                SetLastError (PDH_WBEM_ERROR);
            }
        }
    }

    // connect to the WBEM Server on that machine
    if (bReturn) {
        pdhStatus = PdhiConnectWbemServer (
            pCounter->pCounterPath->szMachineName,
            &pWbemServer);
        if (pdhStatus != ERROR_SUCCESS) {
            SetLastError (pdhStatus);
            bReturn = FALSE;
        }
    }

    if (bReturn) {
        // make WBEM Instance path out of path elements
        pdhStatus = PdhiMakeWbemInstancePath (
            pPathElem,
            szWbemItemPath,
            TRUE);

        // check for an object/class of this type that has already been added
        // walk down counter list to find a matching:
        //  machine\namespace
        //  object
        //  instance name
    }

    if (bReturn) {
        assert (pCounter->pWbemObject == NULL);
        assert (pCounter->lWbemRefreshId == 0);

        pCounterInList = pCounter->pOwner->pCounterListHead;
        if (pCounterInList == NULL) {
            // then there are no entries to search so continue
        } else {
            do {
                // check for matching machine name
                if (lstrcmpiW(pCounterInList->pCounterPath->szMachineName,
                    pCounter->pCounterPath->szMachineName) == 0) {
                    // then the machine name matches
                    if (lstrcmpiW (pCounterInList->pCounterPath->szObjectName,
                        pCounter->pCounterPath->szObjectName) == 0) {
                        // then the object name matches
                        // see if the instance matches
                        if (lstrcmpiW (pCounterInList->pCounterPath->szInstanceName,
                            pCounter->pCounterPath->szInstanceName) == 0) {
                            if ((pCounter->pCounterPath->szInstanceName != NULL) &&
                                (*pCounter->pCounterPath->szInstanceName == SPLAT_L)) {
                                // then this is a Wild Card or multiple instance path
                                // see if an enumerator for this object has already been created
                                // if so, then AddRef it
                                if (pCounterInList->pWbemEnum != NULL) {
                                    pCounter->pWbemObject = pCounterInList->pWbemObject;
                                    pCounter->pWbemEnum = pCounterInList->pWbemEnum;
                                    // bump the ref counts on this object so it
                                    //  doesn't disapper from us
                                    pCounter->pWbemObject->AddRef();
                                    pCounter->pWbemEnum->AddRef();
                                    pCounter->lWbemEnumId = pCounterInList->lWbemEnumId;
                                    pCounter->dwFlags |= PDHIC_MULTI_INSTANCE;
                                } 
                                // and exit loop
                                hRes = S_OK;
                                break;
                            } else {
                                // then it's a regular instance the instance name matches
                                // so get the Object pointer
                                pCounter->pWbemObject = pCounterInList->pWbemObject;
                                pCounter->pWbemAccess = pCounterInList->pWbemAccess;
                                // bump the ref counts on this object so it
                                //  doesn't disapper from us
                                pCounter->pWbemObject->AddRef();
                                pCounter->pWbemAccess->AddRef();
                                pCounter->lWbemRefreshId = pCounterInList->lWbemRefreshId;
                                // and exit loop
                                hRes = S_OK;
                                break;
                            }
                        } else {
                            // no match so go to next one
                        }
                    } else {
                        // no match so go to next one
                    }
                } else {
                    // no match so go to next counter
                }
                pCounterInList = pCounterInList->next.flink;
            } while (pCounterInList != pCounter->pOwner->pCounterListHead);
        }

        bDontRefresh = TRUE;

        // determine if we should and an object or an enumerator
        if ((pCounter->pCounterPath->szInstanceName != NULL) &&
            (*pCounter->pCounterPath->szInstanceName == SPLAT_L)) {
            // then this is an enum type so see if there's already one assigned
            // if not, then create one
            if (pCounter->pWbemEnum == NULL) {
                hRes = pCounter->pOwner->pRefresherCfg->AddEnum( 
                    pWbemServer->pSvc,
                    pPathElem->szObjectName,
                    WBEM_FLAG_USE_AMENDED_QUALIFIERS, 0,
                    &pCounter->pWbemEnum,
                    &pCounter->lWbemEnumId);

                if (hRes != S_OK) {
                    bReturn = FALSE;
                    SetLastError (hRes);
                } else {
                    PdhiWbemGetClassObjectByName (
                        pWbemServer,
                        pPathElem->szObjectName,
                        &pCounter->pWbemObject);
                }
                // set multi instance flag
                pCounter->dwFlags |= PDHIC_MULTI_INSTANCE;
            } else {
                // we must have copied another one so continue
            }

        } else {
            // this is a single counter
            if (pCounter->pWbemObject == NULL) {
                // and it hasn't been added yet, so just add one object
                hRes = pCounter->pOwner->pRefresherCfg->AddObjectByPath (
                    pWbemServer->pSvc,
                    szWbemItemPath,
                    WBEM_FLAG_USE_AMENDED_QUALIFIERS, 0,
                    &pCounter->pWbemObject,
                    &pCounter->lWbemRefreshId);
                if (hRes != S_OK) {
                    bReturn = FALSE;
                    SetLastError (hRes);
                }
            } else {
                // it must have been copied from another
            }
        }

        if (hRes == S_OK) {
            // get handles for subsequent data collection from this object
            hRes = pCounter->pWbemObject->QueryInterface (IID_IWbemObjectAccess,
                (LPVOID *)&pCounter->pWbemAccess);
            if (hRes == S_OK) {
                if (!PdhiIsSingletonClass (pCounter->pWbemObject)) {
                    CIMTYPE cimType = 0;
                    bsPropName = SysAllocString(cszName);               
                    // get handle to the name property for this counter
                    hRes = pCounter->pWbemAccess->GetPropertyHandle (
                        bsPropName, &cimType,
                        &pCounter->lNameHandle);
                    assert (hRes == S_OK);
                    assert (cimType == CIM_STRING);
                } else {
                    pCounter->lNameHandle = -1;
                }
                // get handle to the data property for this counter
                hRes = pCounter->pWbemAccess->GetPropertyHandle (
                    pPathElem->szCounterName, &pCounter->lNumItemType,
                    &pCounter->lNumItemHandle);
                assert (hRes == S_OK);

                // get counter type field
                // first get the property qualifiers
                bsPropName = SysAllocString (pPathElem->szCounterName);
                hRes = pCounter->pWbemObject->GetPropertyQualifierSet (
                        bsPropName, &pQualSet);
                if (hRes == WBEM_NO_ERROR) {

                    // now get the specific value
                    VariantClear (&vCountertype);
                    bsCountertype = SysAllocString (cszCountertype);
                    hRes = pQualSet->Get (bsCountertype, 0, &vCountertype, NULL);
                    if (hRes == WBEM_NO_ERROR) {
                        pCounter->plCounterInfo.dwCounterType = (DWORD)V_I4(&vCountertype);
                    } else {
                        pCounter->plCounterInfo.dwCounterType = 0;
                    }
                    SysFreeString (bsCountertype);

                    // if this is a fraction counter that has a "base" value
                    // then look it up by appending the "base" string to the
                    // property name

                    if ((pCounter->plCounterInfo.dwCounterType == PERF_SAMPLE_FRACTION) ||
                        (pCounter->plCounterInfo.dwCounterType == PERF_AVERAGE_TIMER)   ||
                        (pCounter->plCounterInfo.dwCounterType == PERF_AVERAGE_BULK)    ||
                        (pCounter->plCounterInfo.dwCounterType == PERF_RAW_FRACTION)) {

                        // make sure we have room for the "_Base" string
                        assert (lstrlenW(pPathElem->szCounterName) < (MAX_PATH - 6));
                        lstrcpyW (szBasePropertyName, pPathElem->szCounterName);
                        lstrcatW (szBasePropertyName, cszBaseSuffix);

                        // get the handle to the denominator
                        hRes = pCounter->pWbemAccess->GetPropertyHandle (
                            szBasePropertyName, &pCounter->lDenItemType,
                            &pCounter->lDenItemHandle);
                        assert (hRes == S_OK);

                    } else {
                        // the denominator is a time field
                        if ((pCounter->plCounterInfo.dwCounterType & PERF_TIMER_FIELD) == PERF_TIMER_TICK) {
                            // use the system perf time timestamp as the denominator
                            lstrcpyW (szBasePropertyName, cszTimestampPerfTime);
                            lstrcpyW (szFreqPropertyName, cszFrequencyPerfTime);
                        } else if ((pCounter->plCounterInfo.dwCounterType & PERF_TIMER_FIELD) == PERF_TIMER_100NS) {
                            lstrcpyW (szBasePropertyName, cszTimestampSys100Ns);
                            lstrcpyW (szFreqPropertyName, cszFrequencySys100Ns);
                        } else if ((pCounter->plCounterInfo.dwCounterType & PERF_TIMER_FIELD) == PERF_OBJECT_TIMER) {
                            lstrcpyW (szBasePropertyName, cszTimestampObject);
                            lstrcpyW (szFreqPropertyName, cszFrequencyObject);
                        } else {
                            assert (FALSE); // this should never happen
                        }

                        // get the handle to the denominator
                        hRes = pCounter->pWbemAccess->GetPropertyHandle (
                            szBasePropertyName, &pCounter->lDenItemType,
                            &pCounter->lDenItemHandle);
                        assert (hRes == S_OK);

                        // get the handle to the frequency
                        hRes = pCounter->pWbemAccess->GetPropertyHandle (
                            szFreqPropertyName, &pCounter->lFreqItemType,
                            &pCounter->lFreqItemHandle);
                        assert (hRes == S_OK);
                    }

                    // get the default scale value of this counter
                    VariantClear (&vCountertype);
                    bsCountertype = SysAllocString (cszDefaultscale);
                    hRes = pQualSet->Get (bsCountertype, 0, &vCountertype, NULL);
                    if (hRes == WBEM_NO_ERROR) {
                        pCounter->lScale = 0;
                        pCounter->plCounterInfo.lDefaultScale = (DWORD)V_I4(&vCountertype);
                    } else {
                        pCounter->plCounterInfo.lDefaultScale = 0;
                        pCounter->lScale = 0;
                    }
                    SysFreeString (bsCountertype);

                    // this may not be initialized but we try anyway
                    if ((pCounter->lFreqItemType == VT_I8) ||
                        (pCounter->lFreqItemType == VT_UI8)) {
                        pCounter->pWbemAccess->ReadQWORD (
                            pCounter->lFreqItemHandle, &llValue);
                    } else {
                        llValue = 0;
                    }
                    // the timebase is a 64 bit integer
                    pCounter->TimeBase = llValue;

                    pQualSet->Release();
                } else {
                    SetLastError (hRes);
                    bReturn = FALSE;
                }
                SysFreeString (bsPropName);
            } else {
                SetLastError (hRes);
                bReturn = FALSE;
            }
        } else {
            SetLastError (hRes);
            bReturn = FALSE;
        }

        bDontRefresh = FALSE;
    }

    if (bReturn) {
        bReturn = AssignCalcFunction (
            pCounter->plCounterInfo.dwCounterType,
            &pCounter->CalcFunc,
            &pCounter->StatFunc);
    }

    if (pPathElem != NULL) G_FREE(pPathElem);
    VariantClear (&vCountertype);

    pdhStatus = PdhiDisconnectWbemServer (pWbemServer);

    return bReturn;
}

BOOL
UpdateWbemCounterValue (
    IN      PPDHI_COUNTER   pCounter,
    IN      FILETIME        *pTimeStamp
)
{
    DWORD   LocalCStatus = 0;
    DWORD   LocalCType  = 0;
    LPVOID  pData = NULL;
    LONGLONG    pObjPerfTime = 0;
    LONGLONG    pObjPerfFreq = 0;
    ULONGLONG   llValue;
    DWORD       dwValue;

    BOOL    bReturn  = FALSE;

    // move current value to last value buffer
    pCounter->LastValue = pCounter->ThisValue;

    // and clear the old value
    pCounter->ThisValue.MultiCount = 1;
    pCounter->ThisValue.FirstValue =
        pCounter->ThisValue.SecondValue = 0;
    pCounter->ThisValue.TimeStamp = *pTimeStamp;

    // DEVNOTE:
    // need to find where WBEM stores this info. assume Success for now
    //
    // get the counter's machine status first. There's no point in
    // contuning if the machine is offline

    LocalCStatus = ERROR_SUCCESS;

    if (IsSuccessSeverity(LocalCStatus)) {
        // get the pointer to the counter data
        LocalCType = pCounter->plCounterInfo.dwCounterType;
        switch (LocalCType) {
            //
            // these counter types are loaded as:
            //      Numerator = Counter data from perf data block
            //      Denominator = Perf Time from perf data block
            //      (the time base is the PerfFreq)
            //
            case PERF_COUNTER_COUNTER:
            case PERF_COUNTER_QUEUELEN_TYPE:
            case PERF_SAMPLE_COUNTER:
                // this should be a DWORD counter
                assert ((pCounter->lNumItemType == VT_I4) ||
                        (pCounter->lNumItemType == VT_UI4));
                pCounter->pWbemAccess->ReadDWORD (
                    pCounter->lNumItemHandle, &dwValue);
                pCounter->ThisValue.FirstValue = (LONGLONG)(dwValue);

                assert ((pCounter->lDenItemType == VT_I8) ||
                        (pCounter->lDenItemType == VT_UI8));
                pCounter->pWbemAccess->ReadQWORD (
                    pCounter->lDenItemHandle, &llValue);
                // the denominator should be a 64-bit timestamp
                pCounter->ThisValue.SecondValue = llValue;

                // look up the timebase freq if necessary
                if (pCounter->TimeBase == 0) {
                    assert ((pCounter->lFreqItemType == VT_I8) ||
                            (pCounter->lFreqItemType == VT_UI8));
                    pCounter->pWbemAccess->ReadQWORD (
                        pCounter->lFreqItemHandle, &llValue);
                    // the timebase is a 64 bit integer
                    pCounter->TimeBase = llValue;
                }

                break;

            case PERF_ELAPSED_TIME:
            case PERF_100NSEC_TIMER:
            case PERF_100NSEC_TIMER_INV:
            case PERF_COUNTER_TIMER:
            case PERF_COUNTER_TIMER_INV:
            case PERF_COUNTER_BULK_COUNT:
            case PERF_COUNTER_MULTI_TIMER:
            case PERF_COUNTER_LARGE_QUEUELEN_TYPE:
            case PERF_OBJ_TIME_TIMER:
            case PERF_COUNTER_100NS_QUEUELEN_TYPE:
            case PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE:
            case PERF_PRECISION_SYSTEM_TIMER:
            case PERF_PRECISION_100NS_TIMER:
            case PERF_PRECISION_OBJECT_TIMER:
                // this should be a QWORD counter
                assert ((pCounter->lNumItemType == VT_I8) ||
                        (pCounter->lNumItemType == VT_UI8));
                pCounter->pWbemAccess->ReadQWORD (
                    pCounter->lNumItemHandle, &llValue);
                pCounter->ThisValue.FirstValue = (LONGLONG)(llValue);

                assert ((pCounter->lDenItemType == VT_I8) ||
                        (pCounter->lDenItemType == VT_UI8));
                pCounter->pWbemAccess->ReadQWORD (
                    pCounter->lDenItemHandle, &llValue);
                // the denominator should be a 64-bit timestamp
                pCounter->ThisValue.SecondValue = llValue;

                // look up the timebase freq if necessary
                if (pCounter->TimeBase == 0) {
                    assert ((pCounter->lFreqItemType == VT_I8) ||
                            (pCounter->lFreqItemType == VT_UI8));
                    pCounter->pWbemAccess->ReadQWORD (
                        pCounter->lFreqItemHandle, &llValue);
                    // the timebase is a 64 bit integer
                    pCounter->TimeBase = llValue;
                }

                break;
            //
            //  These counters do not use any time reference
            //
            case PERF_COUNTER_RAWCOUNT:
            case PERF_COUNTER_RAWCOUNT_HEX:
                // this should be a DWORD counter
                assert ((pCounter->lNumItemType == VT_I4) ||
                        (pCounter->lNumItemType == VT_UI4));
                pCounter->pWbemAccess->ReadDWORD (
                    pCounter->lNumItemHandle, &dwValue);
                pCounter->ThisValue.FirstValue = (LONGLONG)(dwValue);
                pCounter->ThisValue.SecondValue = 0;
                break;

            case PERF_COUNTER_LARGE_RAWCOUNT:
            case PERF_COUNTER_LARGE_RAWCOUNT_HEX:
                // this should be a DWORD counter
                assert ((pCounter->lNumItemType == VT_I8) ||
                        (pCounter->lNumItemType == VT_UI8));
                pCounter->pWbemAccess->ReadQWORD (
                    pCounter->lNumItemHandle, &llValue);
                pCounter->ThisValue.FirstValue = (LONGLONG)(llValue);
                pCounter->ThisValue.SecondValue = 0;
                break;

            //
            //  These counters use two data points, the one pointed to by
            //  pData and the one immediately after
            //
            case PERF_SAMPLE_FRACTION:
            case PERF_RAW_FRACTION:
                // this should be a DWORD counter
                assert ((pCounter->lNumItemType == VT_I4) ||
                        (pCounter->lNumItemType == VT_UI4));
                pCounter->pWbemAccess->ReadDWORD (
                    pCounter->lNumItemHandle, &dwValue);
                pCounter->ThisValue.FirstValue = (LONGLONG)dwValue;

                assert ((pCounter->lDenItemType == VT_I4) ||
                        (pCounter->lDenItemType == VT_UI4));
                pCounter->pWbemAccess->ReadDWORD (
                    pCounter->lDenItemHandle, &dwValue);
                // the denominator should be a 32-bit value
                pCounter->ThisValue.SecondValue = (LONGLONG)dwValue;
                break;

            case PERF_AVERAGE_TIMER:
            case PERF_AVERAGE_BULK:
                // counter (numerator) is a LONGLONG, while the
                // denominator is just a DWORD
                // this should be a DWORD counter
                assert ((pCounter->lNumItemType == VT_I8) ||
                        (pCounter->lNumItemType == VT_UI8));
                pCounter->pWbemAccess->ReadQWORD (
                    pCounter->lNumItemHandle, &llValue);
                pCounter->ThisValue.FirstValue = (LONGLONG)llValue;

                assert ((pCounter->lDenItemType == VT_I4) ||
                        (pCounter->lDenItemType == VT_UI4));
                pCounter->pWbemAccess->ReadDWORD (
                    pCounter->lDenItemHandle, &dwValue);
                // the denominator should be a 32-bit value
                pCounter->ThisValue.SecondValue = (LONGLONG)dwValue;

                // look up the timebase freq if necessary
                if (pCounter->TimeBase == 0) {
                    assert ((pCounter->lFreqItemType == VT_I8) ||
                            (pCounter->lFreqItemType == VT_UI8));
                    pCounter->pWbemAccess->ReadQWORD (
                        pCounter->lFreqItemHandle, &llValue);
                    // the timebase is a 64 bit integer
                    pCounter->TimeBase = llValue;
                }
                break;
            //
            //  These counters are used as the part of another counter
            //  and as such should not be used, but in case they are
            //  they'll be handled here.
            //
            case PERF_SAMPLE_BASE:
            case PERF_AVERAGE_BASE:
            case PERF_COUNTER_MULTI_BASE:
            case PERF_RAW_BASE:
                pCounter->ThisValue.FirstValue = 0;
                pCounter->ThisValue.SecondValue = 0;
                break;

            //
            //  These counters are not supported by this function (yet)
            //
            case PERF_COUNTER_TEXT:
            case PERF_COUNTER_NODATA:
            case PERF_COUNTER_HISTOGRAM_TYPE:
                pCounter->ThisValue.FirstValue = 0;
                pCounter->ThisValue.SecondValue = 0;
                break;

            case PERF_100NSEC_MULTI_TIMER:
            case PERF_100NSEC_MULTI_TIMER_INV:
            default:
                // an unidentified  or unsupported
                // counter was returned so
                pCounter->ThisValue.FirstValue = 0;
                pCounter->ThisValue.SecondValue = 0;
                bReturn = FALSE;
                break;
        }
    } else {
        // else this counter is not valid so this value == 0
        pCounter->ThisValue.FirstValue = 0;
        pCounter->ThisValue.SecondValue = 0;
        bReturn = FALSE;
    }

    return bReturn;
}

BOOL
UpdateWbemMultiInstanceCounterValue (
    IN      PPDHI_COUNTER   pCounter,
    IN      FILETIME        *pTimestamp
)
{
    IWbemObjectAccess   *pWbemAccess;
    HRESULT     hRes;

    DWORD       LocalCStatus = 0;
    DWORD       LocalCType  = 0;
    LPVOID      pData = NULL;
    DWORD       dwValue;
    ULONGLONG   llValue;
    LONGLONG    pObjPerfTime = 0;
    LONGLONG    pObjPerfFreq = 0;
    DWORD       dwSize;
    DWORD       dwFinalSize;
    LONG        lAvailableSize;
    LONG        lReturnSize;
    LONG        lThisInstanceIndex;
    LONG        lNumInstances;

    LPWSTR  szNextNameString;
    PPDHI_RAW_COUNTER_ITEM   pThisItem;

    BOOL    bReturn  = FALSE;

    if (pCounter->pThisRawItemList != NULL) {
        // free old counter buffer list
        G_FREE(pCounter->pLastRawItemList);
        pCounter->pLastRawItemList =
            pCounter->pThisRawItemList;
        pCounter->pThisRawItemList = NULL;
    }

    // get the counter's machine status first. There's no point in
    // contuning if the machine is offline

    LocalCStatus = ERROR_SUCCESS;

    if (IsSuccessSeverity(LocalCStatus)) {
        IWbemObjectAccess   **pWbemInstances = NULL;
        // get count of instances in enumerator
        assert (pCounter->pWbemEnum != NULL);
        hRes = pCounter->pWbemEnum->GetObjects(0, 0, NULL, (LPDWORD)&lNumInstances);
        if (hRes == WBEM_E_BUFFER_TOO_SMALL) {
            // then we should know how many have been returned so allocate an
            // array of pointers
            pWbemInstances = new IWbemObjectAccess * [lNumInstances];
            assert (pWbemInstances != NULL);
            hRes = pCounter->pWbemEnum->GetObjects(0, 
                lNumInstances, pWbemInstances, (LPDWORD)&lNumInstances);
        }

        if (hRes == S_OK) {
            // then we have a table of instances
            // estimate the size required for the new data block
            dwSize = sizeof (PDHI_RAW_COUNTER_ITEM_BLOCK) - sizeof (PDHI_RAW_COUNTER_ITEM);
            dwSize += lNumInstances * (sizeof(PDH_RAW_COUNTER_ITEM_W) + (MAX_PATH * 2 * sizeof(WCHAR)));

            pCounter->pThisRawItemList = (PPDHI_RAW_COUNTER_ITEM_BLOCK)G_ALLOC (dwSize);

            if (pCounter->pThisRawItemList != NULL) {

                dwFinalSize = lNumInstances * sizeof(PDH_RAW_COUNTER_ITEM_W);
                szNextNameString = (LPWSTR)((PBYTE)pCounter->pThisRawItemList + dwFinalSize);

                for (lThisInstanceIndex = 0; 
                    lThisInstanceIndex < lNumInstances; 
                    lThisInstanceIndex++) {
                    // get pointer to this raw data block in the array
                    pThisItem = &pCounter->pThisRawItemList->pItemArray[lThisInstanceIndex];
                    // get pointer to this IWbemObjectAccess pointer
                    pWbemAccess = pWbemInstances[lThisInstanceIndex];
                    // compute the remaining size of the buffer
                    lAvailableSize = (long)(dwSize - dwFinalSize);

                    assert (lAvailableSize > 0);
                    
                    if (pCounter->lNameHandle != -1) {
                        hRes = pWbemAccess->ReadPropertyValue(
                            pCounter->lNameHandle,
                            lAvailableSize,
                            &lReturnSize,
                            (LPBYTE)szNextNameString);
                        assert(hRes == S_OK);
                    } else {
                        szNextNameString[0] = ATSIGN_L;
                        szNextNameString[1] = 0;
                        lReturnSize = 2;
                    }

                    pThisItem->szName = szNextNameString;
                    szNextNameString = (LPWSTR)((LPBYTE)szNextNameString + lReturnSize);
                    dwFinalSize += lReturnSize;
                    dwFinalSize = DWORD_MULTIPLE(dwFinalSize);

                    LocalCType = pCounter->plCounterInfo.dwCounterType;
                    switch (LocalCType) {
                        //
                        // these counter types are loaded as:
                        //      Numerator = Counter data from perf data block
                        //      Denominator = Perf Time from perf data block
                        //      (the time base is the PerfFreq)
                        //
                        case PERF_COUNTER_COUNTER:
                        case PERF_COUNTER_QUEUELEN_TYPE:
                        case PERF_SAMPLE_COUNTER:
                            // this should be a DWORD counter
                            assert ((pCounter->lNumItemType == VT_I4) ||
                                    (pCounter->lNumItemType == VT_UI4));
                            pWbemAccess->ReadDWORD (
                                pCounter->lNumItemHandle, &dwValue);
                            pThisItem->FirstValue = (LONGLONG)(dwValue);

                            assert ((pCounter->lDenItemType == VT_I8) ||
                                    (pCounter->lDenItemType == VT_UI8));
                            pWbemAccess->ReadQWORD (
                                pCounter->lDenItemHandle, &llValue);
                            // the denominator should be a 64-bit timestamp
                            pThisItem->SecondValue = llValue;

                            // look up the timebase freq if necessary
                            if (pCounter->TimeBase == 0) {
                                assert ((pCounter->lFreqItemType == VT_I8) ||
                                        (pCounter->lFreqItemType == VT_UI8));
                                pWbemAccess->ReadQWORD (
                                    pCounter->lFreqItemHandle, &llValue);
                                // the timebase is a 64 bit integer
                                pCounter->TimeBase = llValue;
                            }

                            break;

                        case PERF_ELAPSED_TIME:
                        case PERF_100NSEC_TIMER:
                        case PERF_100NSEC_TIMER_INV:
                        case PERF_COUNTER_TIMER:
                        case PERF_COUNTER_TIMER_INV:
                        case PERF_COUNTER_BULK_COUNT:
                        case PERF_COUNTER_MULTI_TIMER:
                        case PERF_COUNTER_LARGE_QUEUELEN_TYPE:
                        case PERF_OBJ_TIME_TIMER:
                        case PERF_COUNTER_100NS_QUEUELEN_TYPE:
                        case PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE:
                        case PERF_PRECISION_SYSTEM_TIMER:
                        case PERF_PRECISION_100NS_TIMER:
                        case PERF_PRECISION_OBJECT_TIMER:
                            // this should be a QWORD counter
                            assert ((pCounter->lNumItemType == VT_I8) ||
                                    (pCounter->lNumItemType == VT_UI8));
                            pWbemAccess->ReadQWORD (
                                pCounter->lNumItemHandle, &llValue);
                            pThisItem->FirstValue = (LONGLONG)(llValue);

                            assert ((pCounter->lDenItemType == VT_I8) ||
                                    (pCounter->lDenItemType == VT_UI8));
                            pWbemAccess->ReadQWORD (
                                pCounter->lDenItemHandle, &llValue);
                            // the denominator should be a 64-bit timestamp
                            pThisItem->SecondValue = llValue;

                            // look up the timebase freq if necessary
                            if (pCounter->TimeBase == 0) {
                                assert ((pCounter->lFreqItemType == VT_I8) ||
                                        (pCounter->lFreqItemType == VT_UI8));
                                pWbemAccess->ReadQWORD (
                                    pCounter->lFreqItemHandle, &llValue);
                                // the timebase is a 64 bit integer
                                pCounter->TimeBase = llValue;
                            }

                            break;
                        //
                        //  These counters do not use any time reference
                        //
                        case PERF_COUNTER_RAWCOUNT:
                        case PERF_COUNTER_RAWCOUNT_HEX:
                            // this should be a DWORD counter
                            assert ((pCounter->lNumItemType == VT_I4) ||
                                    (pCounter->lNumItemType == VT_UI4));
                            pWbemAccess->ReadDWORD (
                                pCounter->lNumItemHandle, &dwValue);
                            pThisItem->FirstValue = (LONGLONG)(dwValue);
                            pThisItem->SecondValue = 0;
                            break;

                        case PERF_COUNTER_LARGE_RAWCOUNT:
                        case PERF_COUNTER_LARGE_RAWCOUNT_HEX:
                            // this should be a DWORD counter
                            assert ((pCounter->lNumItemType == VT_I8) ||
                                    (pCounter->lNumItemType == VT_UI8));
                            pWbemAccess->ReadQWORD (
                                pCounter->lNumItemHandle, &llValue);
                            pThisItem->FirstValue = (LONGLONG)(llValue);
                            pThisItem->SecondValue = 0;
                            break;

                        //
                        //  These counters use two data points, the one pointed to by
                        //  pData and the one immediately after
                        //
                        case PERF_SAMPLE_FRACTION:
                        case PERF_RAW_FRACTION:
                            // this should be a DWORD counter
                            assert ((pCounter->lNumItemType == VT_I4) ||
                                    (pCounter->lNumItemType == VT_UI4));
                            pWbemAccess->ReadDWORD (
                                pCounter->lNumItemHandle, &dwValue);
                            pThisItem->FirstValue = (LONGLONG)dwValue;

                            assert ((pCounter->lDenItemType == VT_I4) ||
                                    (pCounter->lDenItemType == VT_UI4));
                            pWbemAccess->ReadDWORD (
                                pCounter->lDenItemHandle, &dwValue);
                            // the denominator should be a 32-bit value
                            pThisItem->SecondValue = (LONGLONG)dwValue;
                            break;

                        case PERF_AVERAGE_TIMER:
                        case PERF_AVERAGE_BULK:
                            // counter (numerator) is a LONGLONG, while the
                            // denominator is just a DWORD
                            // this should be a DWORD counter
                            assert ((pCounter->lNumItemType == VT_I8) ||
                                    (pCounter->lNumItemType == VT_UI8));
                            pWbemAccess->ReadQWORD (
                                pCounter->lNumItemHandle, &llValue);
                            pThisItem->FirstValue = (LONGLONG)llValue;

                            assert ((pCounter->lDenItemType == VT_I4) ||
                                    (pCounter->lDenItemType == VT_UI4));
                            pWbemAccess->ReadDWORD (
                                pCounter->lDenItemHandle, &dwValue);
                            // the denominator should be a 32-bit value
                            pThisItem->SecondValue = (LONGLONG)dwValue;

                            // look up the timebase freq if necessary
                            if (pCounter->TimeBase == 0) {
                                assert ((pCounter->lFreqItemType == VT_I8) ||
                                        (pCounter->lFreqItemType == VT_UI8));
                                pWbemAccess->ReadQWORD (
                                    pCounter->lFreqItemHandle, &llValue);
                                // the timebase is a 64 bit integer
                                pCounter->TimeBase = llValue;
                            }
                            break;
                        //
                        //  These counters are used as the part of another counter
                        //  and as such should not be used, but in case they are
                        //  they'll be handled here.
                        //
                        case PERF_SAMPLE_BASE:
                        case PERF_AVERAGE_BASE:
                        case PERF_COUNTER_MULTI_BASE:
                        case PERF_RAW_BASE:
                            pThisItem->FirstValue = 0;
                            pThisItem->SecondValue = 0;
                            break;

                        //
                        //  These counters are not supported by this function (yet)
                        //
                        case PERF_COUNTER_TEXT:
                        case PERF_COUNTER_NODATA:
                        case PERF_COUNTER_HISTOGRAM_TYPE:
                            pThisItem->FirstValue = 0;
                            pThisItem->SecondValue = 0;
                            break;

                        case PERF_100NSEC_MULTI_TIMER:
                        case PERF_100NSEC_MULTI_TIMER_INV:
                        default:
                            // an unidentified  or unsupported
                            // counter was returned so
                            pThisItem->FirstValue = 0;
                            pThisItem->SecondValue = 0;
                            bReturn = FALSE;
                            break;
                    }
                    // we're done with this one so release it
                    pWbemAccess->Release();
                }
                // measure the memory block used
                assert (dwFinalSize == (DWORD)((LPBYTE)szNextNameString -
                        (LPBYTE)(pCounter->pThisRawItemList)));

                pCounter->pThisRawItemList->dwLength = dwFinalSize;
                pCounter->pThisRawItemList->dwItemCount = lNumInstances;
                pCounter->pThisRawItemList->dwReserved = 0;
                pCounter->pThisRawItemList->CStatus = ERROR_SUCCESS;

                pCounter->pThisRawItemList->TimeStamp = *pTimestamp;

            } else {
                // unable to allocate a new buffer so return error
                SetLastError (ERROR_OUTOFMEMORY);
                bReturn = FALSE;
            }
        }
    }
    return bReturn;
}

LONG
GetQueryWbemData (
    IN  PPDHI_QUERY         pQuery
)
{
    LONGLONG            llTimeStamp;
    HRESULT             hRes;
    LONG                lRetStatus = ERROR_SUCCESS;\

    PPDHI_COUNTER       pCounter;
    PDH_STATUS          pdhStatus;

    // refresh Wbem Refresher

    if (bDontRefresh) return ERROR_BUSY;

    hRes = pQuery->pRefresher->Refresh(0);

	// If multiple objects are being refreshed, some objects may succeed and
	// others may fail, in which case WBEM_S_PARTIAL_RESULTS is returned.

    if ( FAILED( hRes ) ) {
        SetLastError (hRes);
        lRetStatus = PDH_WBEM_ERROR;
    }

    if (lRetStatus == ERROR_SUCCESS) {
        // get timestamp for this counter
        GetLocalFileTime (&llTimeStamp);

        // now update the counters using this new data
        if ((pCounter = pQuery->pCounterListHead) != NULL) {
            do {
                if (pCounter->dwFlags & PDHIC_MULTI_INSTANCE) {
                    pdhStatus = UpdateWbemMultiInstanceCounterValue (
                        pCounter, (FILETIME *)&llTimeStamp);
                } else {
                    // update single instance counter values
                    pdhStatus = UpdateWbemCounterValue (pCounter,
                        (FILETIME *)&llTimeStamp);
                }
                pCounter = pCounter->next.flink;
            } while (pCounter != pQuery->pCounterListHead);
            pdhStatus = ERROR_SUCCESS;
        } else {
            // no counters in the query  (?!)
            pdhStatus = PDH_NO_DATA;
        }
        lRetStatus = pdhStatus;
    }

    return lRetStatus;
}

HRESULT WbemSetProxyBlanket(
    IUnknown                 *pInterface,
    DWORD                     dwAuthnSvc,
    DWORD                     dwAuthzSvc,
    OLECHAR                  *pServerPrincName,
    DWORD                     dwAuthLevel,
    DWORD                     dwImpLevel,
    RPC_AUTH_IDENTITY_HANDLE  pAuthInfo,
    DWORD                     dwCapabilities )
{
    // Security MUST be set on both the Proxy and it's IUnknown!

    IUnknown * pUnk = NULL;
    IClientSecurity * pCliSec = NULL;
    HRESULT sc = pInterface->QueryInterface(IID_IUnknown, (void **) &pUnk);
    if(sc != S_OK)
        return sc;
    sc = pInterface->QueryInterface(IID_IClientSecurity, (void **) &pCliSec);
    if(sc != S_OK)
    {
        pUnk->Release();
        return sc;
    }
    sc = pCliSec->SetBlanket(pInterface, dwAuthnSvc, dwAuthzSvc, pServerPrincName,
        dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities);
    pCliSec->Release();
    pCliSec = NULL;
    sc = pUnk->QueryInterface(IID_IClientSecurity, (void **) &pCliSec);
    if(sc == S_OK)
    {
        sc = pCliSec->SetBlanket(pUnk, dwAuthnSvc, dwAuthzSvc, pServerPrincName,
            dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities);
        pCliSec->Release();
    }
    else if (sc == 0x80004002)
        sc = S_OK;
    pUnk->Release();
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\perfsrv\server.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// HiPerfServer.cpp: implementation of the CHiPerfServer class.
//
//////////////////////////////////////////////////////////////////////

#define _WIN32_DCOM

#include <commain.h>
#include <clsfac.h>
#include <wbemcli.h>
#include <wbemint.h>

#include "Server.h"
#include "PerfSrv.h"
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

class CServer : public CComServer  
{
public:

	virtual void Initialize()
	{
		AddClassInfo(CLSID_PERFSRV_v1, 
			new CSimpleClassFactory<CPerfSrv>(GetLifeControl()), 
			"Test Performance Server", TRUE);

	}
} g_Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\perfsrv\server.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// Server.h: interface for the Server class.
//
//////////////////////////////////////////////////////////////////////

#ifndef _SERVER_H_
#define _SERVER_H_

// {AF3DDC44-95FB-11d2-B346-00105A1469B7}
const CLSID CLSID_PERFSRV_v1 = 
	{ 0xaf3ddc44, 0x95fb, 0x11d2, { 0xb3, 0x46, 0x0, 0x10, 0x5a, 0x14, 0x69, 0xb7 } };


#endif // _SERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\semisynchtest\semisynchtest.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// SemiSychTest.cpp : implementation file
//

#define _WIN32_WINNT 0x0400

#include <windows.h>
#include <stdio.h>
#include <wbemcli.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include <fastall.h>
#include <cominit.h>
#include "semisyncsink.h"

//#define TEST_CLASS	L"Win32_BIOS"
//#define TEST_CLASS	L"Win32_DiskPartition"
#define TEST_CLASS	L"Win32_IRQResource"
//#define TEST_CLASS	L"Win32_Directory"

#define	OBJECT_INTERVAL	10

void SinkTest( void )
{
	IWbemLocator*		pWbemLocator = NULL;

	HRESULT hr = CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (void**) &pWbemLocator );

	if ( SUCCEEDED(hr) )
	{
		LPWSTR	lpwcsMachineName = L"SANJNECK";
		LPWSTR	lpwcsNameSpace = L"ROOT\\CIMV2";
		WCHAR	wszNameSpace[255];

		swprintf( wszNameSpace, L"\\\\%s\\%s", lpwcsMachineName, lpwcsNameSpace );

		// Name space to connect to
		BSTR	bstrNameSpace = SysAllocString( wszNameSpace );

		LPWSTR	lpwcsObjectPath = L"Win32_SerialPort.DeviceID=\"COM1\"";
		BSTR	bstrObjectPath = NULL;

		bstrObjectPath = SysAllocString( lpwcsObjectPath );

		IWbemServices*	pNameSpace = NULL;

		hr = pWbemLocator->ConnectServer(	bstrNameSpace,	// NameSpace Name
											NULL,			// UserName
											NULL,			// Password
											NULL,			// Locale
											0L,				// Security Flags
											NULL,			// Authority
											NULL,			// Wbem Context
											&pNameSpace		// Namespace
											);

		if ( SUCCEEDED(hr) )
		{
			SetInterfaceSecurity(pNameSpace, NULL, NULL, NULL, 
 								RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE);

			HANDLE	hDoneEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
			HANDLE	hGetNextSet = CreateEvent( NULL, FALSE, FALSE, NULL );

			CSemiSyncSink*	pNotSink = new CSemiSyncSink( hDoneEvent, hGetNextSet );

			BSTR	bstrClass = SysAllocString( TEST_CLASS );

			IEnumWbemClassObject*	pEnum;

			printf( "Querying WINMGMT for instances of class: %S\n", TEST_CLASS );

			hr = pNameSpace->CreateInstanceEnum( bstrClass,
												WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
												NULL,
												&pEnum );

			// Walk the enumerator
			if ( SUCCEEDED( hr ) )
			{
				HANDLE	ahEvents[2];

				ahEvents[0] = hGetNextSet;
				ahEvents[1] = hDoneEvent;

				DWORD	dwReturn= 0;

				// We do things asynch in this here loop
				do
				{
					Sleep(500);
					hr = pEnum->NextAsync( OBJECT_INTERVAL, pNotSink );
				}
				while ( SUCCEEDED( hr )
						&& ( dwReturn = WaitForMultipleObjects( 2, ahEvents, FALSE, INFINITE ) )
						== WAIT_OBJECT_0 );


				// Clean up the enumerator and the sink
				pNotSink->Release();
				pEnum->Release();

			}

			// Done with it.
			pNameSpace->Release();

		}	// IF Got NameSpace

		// Done with it.
		pWbemLocator->Release();

		// Cleanup BEASTERS
		SysFreeString( bstrObjectPath );
		SysFreeString( bstrNameSpace );

	}	// IF Got WbemLocator
}


///////////////////////////////////////////////////////////////////
//
//	Function:	main
//
//	Entry point function to exercise IWbemObjectInternals interface.
//
///////////////////////////////////////////////////////////////////

int main( int argc, char *argv[] )
{
	InitializeCom();

	InitializeSecurity(RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE );

	SinkTest();

	CoUninitialize();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\pktsecuritytest\syncenumtest.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// OBJINTERNALSTESTDlg.cpp : implementation file
//

#include "precomp.h"
//#include <objbase.h>
#include <stdio.h>
#include <wbemcli.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include <fastall.h>
#include <cominit.h>
#include "objindpacket.h"

//#define TEST_CLASS	L"Win32_BIOS"
#define TEST_CLASS	L"Win32_Process"
//#define TEST_CLASS	L"Win32_IRQResource"
//#define TEST_CLASS	L"Win32_Directory"

int g_nMode = 0L;

SCODE WINAPI DetermineLoginType(BSTR & AuthArg, BSTR & UserArg,BSTR & User)
{

    // first step is to determine if there is a backslash in the user name somewhere between the
    // second and second to last character

    WCHAR * pSlashInUser = NULL;
    if(User)
    {
        WCHAR * pEnd = User + wcslen(User) - 1;
        for(pSlashInUser = User; pSlashInUser <= pEnd; pSlashInUser++)
            if(*pSlashInUser == L'\\')      // dont think forward slash is allowed!
                break;
        if(pSlashInUser > pEnd)
            pSlashInUser = NULL;
    }

    if(pSlashInUser)
    {
        DWORD_PTR iDomLen = pSlashInUser-User;
        WCHAR cTemp[MAX_PATH];
        wcsncpy(cTemp, User, iDomLen);
        cTemp[iDomLen] = 0;
        AuthArg = SysAllocString(cTemp);
        if(wcslen(pSlashInUser+1))
            UserArg = SysAllocString(pSlashInUser+1);
    }
    else
        if(User) UserArg = SysAllocString(User);

    return S_OK;
}

void SinkTest( BOOL fRemote, WCHAR* pwszMachineName, WCHAR* pwszUserName, WCHAR* pwszPassword )
{
	IWbemLocator*		pWbemLocator = NULL;

	HRESULT hr = CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (void**) &pWbemLocator );

	if ( SUCCEEDED(hr) )
	{
		LPWSTR	lpwcsMachineName = L".";
		LPWSTR	lpwcsNameSpace = L"ROOT\\CIMV2";
		WCHAR	wszNameSpace[255];

		swprintf( wszNameSpace, L"\\\\%s\\%s", pwszMachineName, lpwcsNameSpace );

		// Name space to connect to
		BSTR	bstrNameSpace = SysAllocString( wszNameSpace );
		BSTR	bstrUserName = ( NULL != pwszUserName ? SysAllocString( pwszUserName ) : NULL );
		BSTR	bstrPassword = ( NULL != pwszPassword ? SysAllocString( pwszPassword ) : NULL );

		IWbemServices*	pNameSpace = NULL;

		hr = pWbemLocator->ConnectServer(	bstrNameSpace,	// NameSpace Name
											bstrUserName,			// UserName
											bstrPassword,			// Password
											NULL,			// Locale
											0L,				// Security Flags
											NULL,			// Authority
											NULL,			// Wbem Context
											&pNameSpace		// Namespace
											);

		if ( SUCCEEDED(hr) )
		{

			COAUTHINFO	authinfo;
			COAUTHINFO*	pCoAuthInfo = &authinfo;

			CoQueryProxyBlanket( pNameSpace, &pCoAuthInfo->dwAuthnSvc, &pCoAuthInfo->dwAuthzSvc,
					&pCoAuthInfo->pwszServerPrincName, &pCoAuthInfo->dwAuthnLevel,
					&pCoAuthInfo->dwImpersonationLevel, (RPC_AUTH_IDENTITY_HANDLE*) &pCoAuthInfo->pAuthIdentityData,
					&pCoAuthInfo->dwCapabilities );

			printf( "Authentication Level on IWbemServices was set to: 0x%x\n", pCoAuthInfo->dwAuthnLevel );

			BSTR	bstrUser = NULL;
			BSTR	bstrAuth = NULL;

			COAUTHIDENTITY	authident;
			RPC_AUTH_IDENTITY_HANDLE*	pAuthIdentity = (RPC_AUTH_IDENTITY_HANDLE*) COLE_DEFAULT_AUTHINFO;
		    char szUser[MAX_PATH], szDomain[MAX_PATH], szPassword[MAX_PATH];

			if ( NULL != bstrUserName )
			{
				DetermineLoginType( bstrAuth, bstrUser, bstrUserName );

				// Fill in the indentity structure

				if(bstrUser)
				{
					wcstombs(szUser, bstrUser, MAX_PATH);
					authident.UserLength = strlen(szUser);
					authident.User = (LPWSTR)szUser;
				}
				if(bstrAuth)
				{
					wcstombs(szDomain, bstrAuth, MAX_PATH);
					authident.DomainLength = strlen(szDomain);
					authident.Domain = (LPWSTR)szDomain;
				}
				if(pwszPassword)
				{
					wcstombs(szPassword, pwszPassword, MAX_PATH);
					authident.PasswordLength = strlen(szPassword);
					authident.Password = (LPWSTR)szPassword;
				}
				authident.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;

				pAuthIdentity = (RPC_AUTH_IDENTITY_HANDLE*) &authident;
			}


			BSTR	bstrClass = SysAllocString( TEST_CLASS );

			IEnumWbemClassObject*	pEnum;

			printf( "Querying WINMGMT for instances of class: %S\n", TEST_CLASS );

			hr = pNameSpace->CreateInstanceEnum( bstrClass,
												WBEM_FLAG_FORWARD_ONLY,
												NULL,
												&pEnum );

			long	lCount = 0;

			// Walk the enumerator
			if ( SUCCEEDED( hr ) )
			{

				printf( "Successfully received instances.\n" );

				if ( g_nMode >= 1 )
				{
					DWORD	dwAuthnLevel = pCoAuthInfo->dwAuthnLevel;

					if ( g_nMode == 2 )
					{
						dwAuthnLevel = RPC_C_AUTHN_LEVEL_CONNECT;
					}

					hr = CoSetProxyBlanket( pEnum, pCoAuthInfo->dwAuthnSvc, pCoAuthInfo->dwAuthzSvc,
						pCoAuthInfo->pwszServerPrincName, dwAuthnLevel, RPC_C_IMP_LEVEL_IMPERSONATE,
						pAuthIdentity, pCoAuthInfo->dwCapabilities );
				}

				CoQueryProxyBlanket( pEnum, &pCoAuthInfo->dwAuthnSvc, &pCoAuthInfo->dwAuthzSvc,
						&pCoAuthInfo->pwszServerPrincName, &pCoAuthInfo->dwAuthnLevel,
						&pCoAuthInfo->dwImpersonationLevel, (RPC_AUTH_IDENTITY_HANDLE*) &pCoAuthInfo->pAuthIdentityData,
						&pCoAuthInfo->dwCapabilities );

				printf( "Authentication Level on enum is set to: 0x%x\n", pCoAuthInfo->dwAuthnLevel );

				IWbemClassObject*	pObj;

				ULONG		ulTotalReturned = 0;

				while ( SUCCEEDED( hr ) )
				{
					ULONG	ulNumReturned = 0;

					IWbemClassObject*	apObjectArray[100];

					ZeroMemory( apObjectArray, sizeof(apObjectArray) );

					// Go through the object 100 at a time
					hr = pEnum->Next( WBEM_INFINITE,
									100,
									apObjectArray,
									&ulNumReturned );

					// Calculate our packet size and attempt to marshal and
					// unmarshal the packet.

					if ( SUCCEEDED( hr ) && ulNumReturned > 0 )
					{
						ulTotalReturned += ulNumReturned;

						// How many were returned
						printf( "Got %d objects. Total Returned = %d.\n", ulNumReturned, ulTotalReturned );

						// Clean up the objects
						for ( int x = 0; x < ulNumReturned; x++ )
						{
							apObjectArray[x]->Release();
						}

					}
					else if ( ulNumReturned == 0 )
					{
						break;
					}
				}

				if ( FAILED( hr ) )
				{
					printf( "Next failed: hr = %x\n", hr );
				}

				lCount = pEnum->Release();

			}
			else
			{
				printf( "CreateInstanceEnum failed: hr = %x\n", hr );
			}

			// Done with it.
			pNameSpace->Release();

		}	// IF Got NameSpace
		else
		{
			printf( "Connect failed: hr = %x\n", hr );
		}

		// Done with it.
		pWbemLocator->Release();

		// Cleanup BEASTERS
		SysFreeString( bstrNameSpace );

	}	// IF Got WbemLocator
}


///////////////////////////////////////////////////////////////////
//
//	Function:	main
//
//	Entry point function to exercise IWbemObjectInternals interface.
//
///////////////////////////////////////////////////////////////////

int _cdecl wmain( int argc, WCHAR *argv[] )
{
	char	szMachineName[256];

	HRESULT	hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );

	hr = CoInitializeSecurity( NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_IMP_LEVEL_IMPERSONATE,
										NULL, EOAC_NONE, NULL );


	WCHAR	wszName[3];
	wcscpy( wszName, L"." );

	LPWSTR	pwszMachineName = wszName;
	LPWSTR	pwszUserName = NULL;
	LPWSTR	pwszPassword = NULL;

	BOOL	fRemote = FALSE;

	// See if we were told to go remote or not.
	if ( argc > 1 )
	{
		g_nMode = wcstol( argv[1], NULL, 10 );

		if ( argc > 2 )
		{
			pwszMachineName = argv[2];

			if ( argc > 3 )
			{
				if ( g_nMode == 0 )
				{
					printf( "Username cannot be specified in mode 0\n" );
					return 0;
				}

				pwszUserName = argv[3];

				if ( argc > 4 )
				{
					pwszPassword = argv[4];
				}
			}
		}

	}

	SinkTest( fRemote, pwszMachineName, pwszUserName, pwszPassword );

	CoUninitialize();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\semisynchtest\semisyncsink.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#ifndef __SEMISYNCSINK_H__
#define __SEMISYNCSINK_H__

class CSemiSyncSink : public IWbemObjectSink
{
private:
    long				m_lRefCount;
	HANDLE				m_hEventDone;
	HANDLE				m_hGetNextObjectSet;
	BOOL				m_dwEmptySetStatus;
	BOOL				m_dwNumObjectsReceived;
	BOOL				m_bIndicateCalled;
    CRITICAL_SECTION	m_cs;
    
public:
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam, 
                         IWbemClassObject* pObjPAram);

    // Private to implementation.
    // ==========================

    CSemiSyncSink( HANDLE hDoneEvent, HANDLE hGetNextObjectSet );
    ~CSemiSyncSink();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\semisynchtest\semisyncsink.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#define _WIN32_WINNT 0x0400

#include <windows.h>
#include <stdio.h>
#include <wbemcomn.h>
#include <fastall.h>
#include <wbemcli.h>
#include "semisyncsink.h"


SCODE CSemiSyncSink::QueryInterface(
    REFIID riid,
    LPVOID * ppvObj
    )
{
    if (riid == IID_IUnknown)
    {
        *ppvObj = this;
    }
    else if (riid == IID_IWbemObjectSink)
        *ppvObj = this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}


ULONG CSemiSyncSink::AddRef()
{
    InterlockedIncrement(&m_lRefCount);
    return (ULONG) m_lRefCount;
}

ULONG CSemiSyncSink::Release()
{
    InterlockedDecrement(&m_lRefCount);

    if (0 != m_lRefCount)
    {
        return 1;
    }

    delete this;
    return 0;
}


SCODE CSemiSyncSink::Indicate(
    long lObjectCount,
    IWbemClassObject ** pObjArray
    )
{
	EnterCriticalSection( &m_cs );

	m_dwNumObjectsReceived += lObjectCount;

	printf( "Received Indicate of %d objects, Total objects received: %d\n", lObjectCount, m_dwNumObjectsReceived );

	m_bIndicateCalled = TRUE;

	LeaveCriticalSection( &m_cs );

    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CSemiSyncSink::SetStatus(long lFlags, long lParam, BSTR strParam, 
                         IWbemClassObject* pObjParam)
{ 
	printf( "SetStatus Called: lFlags = %d, lParam = %d\n", lFlags, lParam );

	if ( SUCCEEDED( lParam ) )
	{
		EnterCriticalSection( &m_cs );
		
		// If Indicate was called, set the event to get the next object.
		// If it is not, then we must be plumb outa objects, so set the
		// done event.

		if ( m_bIndicateCalled )
		{
			// This is flase until an indicate happens
			m_bIndicateCalled = FALSE;
			m_dwEmptySetStatus = 0;
			// We got all available objects
			SetEvent( m_hGetNextObjectSet );
		}
		else
		{
			if ( ++m_dwEmptySetStatus > 10 )
			{
				SetEvent( m_hEventDone );
			}
			else
			{
				SetEvent( m_hGetNextObjectSet );
			}
		}

		LeaveCriticalSection( &m_cs );
	}
	else
	{
		// Something bad happened
		SetEvent( m_hEventDone );
	}

	return WBEM_NO_ERROR;

}

CSemiSyncSink::CSemiSyncSink( HANDLE hDoneEvent, HANDLE hGetNextObjectSet )
:	m_hEventDone( hDoneEvent ),
	m_hGetNextObjectSet( hGetNextObjectSet ),
	m_lRefCount( 1 ),
	m_dwNumObjectsReceived( 0 ),
	m_dwEmptySetStatus( 0 ),
	m_bIndicateCalled( FALSE )
{
	InitializeCriticalSection( &m_cs );
}

CSemiSyncSink::~CSemiSyncSink()
{
    DeleteCriticalSection(&m_cs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\simphiperf\common.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#ifndef _COMMON_H_
#define _COMMON_H_

#include <stdio.h>

// Logging macros

#define _LOGGING

#ifdef _LOGGING

#define LOGFILE "LOG.TXT"

#define INITLOG \
{\
DeleteFile(LOGFILE);\
}

#define LOG(msg) \
{\
FILE *f = fopen(LOGFILE, "a");\
SYSTEMTIME st;\
GetLocalTime(&st);\
fprintf(f, "%u\\%u\\%u %u:%u %s\n", st.wDay, st.wMonth, st.wYear, st.wHour, st.wMinute, msg);\
fclose(f);\
}

#define LOGERROR(msg) \
{\
FILE *f = fopen(LOGFILE, "a");\
SYSTEMTIME st;\
GetLocalTime(&st);\
fprintf(f, "%u\\%u\\%u %u:%u **ERROR**: %s\n", st.wDay, st.wMonth, st.wYear, st.wHour, st.wMinute, msg);\
fclose(f);\
}

#else

#define INITLOG
#define LOG(msg)
#define ERROR(msg)

#endif // _LOGGING

#endif // _COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\simphiperf\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>

#define COREPROX_POLARITY __declspec( dllexport )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\simphiperf\hiperfserver.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// HiPerfServer.h: interface for the CHiPerfServer class.
//
//////////////////////////////////////////////////////////////////////

#ifndef _HIPERFSERVER_H_
#define _HIPERFSERVER_H_

// {72371C12-8F7E-11d2-B34B-00105A1F8177}
const CLSID CLSID_HiPerfProvider_v1 = { 0x72371c12, 0x8f7e, 0x11d2, { 0xb3, 0x4b, 0x0, 0x10, 0x5a, 0x1f, 0x81, 0x77 } };

#endif // _HIPERFSERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\simphiperf\hiperfserver.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// HiPerfServer.cpp: implementation of the CHiPerfServer class.
//
//////////////////////////////////////////////////////////////////////

#define _WIN32_DCOM

#include "precomp.h"
#include <commain.h>
#include <clsfac.h>
#include <wbemcli.h>
#include <wbemint.h>

#include "common.h"
#include "SimpHiPerf.h"
#include "HiPerfServer.h"
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

class CHiPerfServer : public CComServer  
{
public:

	virtual HRESULT Initialize()
	{
		return AddClassInfo(CLSID_HiPerfProvider_v1, 
			new CSimpleClassFactory<CHiPerfProvider>(GetLifeControl()), 
			L"WBEM HiPerf Provider", TRUE);

	}
} g_Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\syncenumtest\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>

#define COREPOL_HEADERFILE_IS_INCLUDED

#define COREPROX_POLARITY __declspec( dllimport )
#define ESSLIB_POLARITY __declspec( dllimport )

#define COREPOL_HEADERFILE_IS_INCLUDED
#define POLARITY_HEADERFILE_IS_INCLUDED
#define POLARITY __declspec( dllimport )

#include "arena.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\refreshertest\refreshertest.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// OBJINTERNALSTESTDlg.cpp : implementation file
//


#include "precomp.h"
#include <process.h>
//#include <objbase.h>
#include <stdio.h>
#include <wbemcli.h>
//#include <wbemint.h>
//#include <wbemcomn.h>
//#include <cominit.h>

///////////////////////////////////////////////////////////////////
//
//	Function:	main
//
//	Entry point function to exercise IWbemObjectInternals interface.
//
///////////////////////////////////////////////////////////////////


#define	NUMINSTANCES	1

IWbemServices*	g_pNameSpace = NULL;
WCHAR			g_wcsObjectPath[2048];
DWORD			g_dwNumReps = 1;
DWORD			g_dwNumThreads = 1;
BOOL			g_fAddDel = FALSE;
DWORD			g_dwSleepTick = 0;

unsigned __stdcall RefreshThread( void * pvData )
{
	DWORD	dwThreadId = (DWORD) pvData;

	IWbemRefresher*				pRefresher = NULL;
	IWbemConfigureRefresher*	pConfig = NULL;
	BOOL						fEnum = FALSE;

	CoInitializeEx( NULL, COINIT_MULTITHREADED );

	HRESULT hr = CoCreateInstance( CLSID_WbemRefresher, NULL, CLSCTX_INPROC_SERVER, IID_IWbemRefresher, (void**) &pRefresher );

	if ( SUCCEEDED( hr ) )
	{
		IWbemConfigureRefresher*	pConfig = NULL;

		// Need an interface through which we can configure the refresher
		hr = pRefresher->QueryInterface( IID_IWbemConfigureRefresher, (void**) &pConfig );

		if ( SUCCEEDED( hr ) )
		{
			IWbemClassObject*		pRefreshable = NULL;
			IWbemHiPerfEnum*		pEnum = NULL;
			long					lID = 0;
			IWbemObjectAccess*		pObjAccess = NULL;
			IWbemClassObject*		pObj = NULL;

			// Add an object or an enumerator.  If the path to the object contains
			// an L'=', then it is an object path, otherwise we assume it is a class
			// name and therefore return an enumerator.

			if ( NULL != wcschr( g_wcsObjectPath, L'=' ) )
			{
				if ( !g_fAddDel )
				{
					hr = pConfig->AddObjectByPath( g_pNameSpace, g_wcsObjectPath, 0, NULL, &pObj, &lID );

					if ( SUCCEEDED( hr ) )
					{
						pObj->QueryInterface( IID_IWbemObjectAccess, (void**) &pObjAccess );
						pObj->Release();
					}
					else
					{
						printf( "AddObjectByPath() failed, 0x%x\n", hr );
					}

				}

			}
			else
			{
				if ( !g_fAddDel )
				{
					hr = pConfig->AddEnum( g_pNameSpace, g_wcsObjectPath, 0, NULL, &pEnum, &lID );

					if ( FAILED(hr) )
					{
						printf( "AddEnum() failed, 0x%x\n", hr );
					}
				}

				fEnum = TRUE;
			}

			// Add an object and then the enumerator
			if ( SUCCEEDED( hr ) )
			{
				DWORD				dwNumReturned = NUMINSTANCES;
				BOOL				fGotHandles = 0;

				DWORD	dwValue = 0,
						dwNumObjects = 0;
				WORD	wValue = 0;
				BYTE	bVal = 0;
				IWbemObjectAccess**	apEnumAccess = NULL;

				for ( DWORD x = 0; SUCCEEDED( hr ) && x < g_dwNumReps; x++ )
				{
					if ( g_fAddDel )
					{
						if ( fEnum )
						{
							hr = pConfig->AddEnum( g_pNameSpace, g_wcsObjectPath, 0, NULL, &pEnum, &lID );

							if ( FAILED(hr) )
							{
								printf( "AddEnum() failed, 0x%x\n", hr );
							}

						}
						else
						{
							hr = pConfig->AddObjectByPath( g_pNameSpace, g_wcsObjectPath, 0, NULL, &pObj, &lID );

							if ( SUCCEEDED( hr ) )
							{
								pObj->QueryInterface( IID_IWbemObjectAccess, (void**) &pObjAccess );
								pObj->Release();
							}
							else
							{
								printf( "AddObjectByPath() failed, 0x%x\n", hr );
							}
						}
					}

					if ( SUCCEEDED( hr ) )
					{
						// Refresh and if we have an enumerator, retrieve the
						// objects and release them

						hr = pRefresher->Refresh( 0L );

						if ( SUCCEEDED( hr ) )
						{
							if ( fEnum )
							{
								hr = pEnum->GetObjects( 0L, dwNumObjects, apEnumAccess, &dwNumReturned );

								if ( FAILED( hr ) && WBEM_E_BUFFER_TOO_SMALL == hr )
								{
									IWbemObjectAccess**	apTempAccess = new IWbemObjectAccess*[dwNumReturned];

									if ( NULL != apTempAccess )
									{
										ZeroMemory( apTempAccess, dwNumReturned * sizeof(IWbemObjectAccess*) );

										if ( NULL != apEnumAccess )
										{
											CopyMemory( apTempAccess, apEnumAccess, dwNumObjects * sizeof(IWbemObjectAccess*) );
											delete [] apEnumAccess;
										}

										// Store the new values and retry
										apEnumAccess = apTempAccess;
										dwNumObjects = dwNumReturned;

										hr = pEnum->GetObjects( 0L, dwNumObjects, apEnumAccess, &dwNumReturned );
									}
									else
									{
										hr = WBEM_E_OUT_OF_MEMORY;
									}

								}	// IF Buffer too small


								for ( DWORD nCtr = 0; nCtr < dwNumReturned; nCtr++ )
								{
									apEnumAccess[nCtr]->Release();
								}

							}	// IF fEnum

							printf ( "Thread %d Refreshed %d instances of %S from provider: rep# %d\n", dwThreadId, dwNumReturned, g_wcsObjectPath, x );

						}	// IF refresh succeeded
						else
						{
							printf ( "Thread %d Refresh failed: rep# %d, hr = 0x%x\n", dwThreadId, x, hr );

							// So we keep on refreshing (allows quick and easy auto-reconnect testing).
							hr = WBEM_S_NO_ERROR;
						}

						if ( SUCCEEDED( hr ) && g_fAddDel )
						{
							// Remove will be the same whether this is an object or enumerator
							hr = pConfig->Remove( lID, 0L );

							if ( FAILED(hr) )
							{
								printf ( "Thread %d Remove failed: rep# %d, hr = 0x%x\n", dwThreadId, x, hr );
							}

							hr = WBEM_S_NO_ERROR;

							if ( fEnum )
							{
								pEnum->Release();
							}
							else
							{
								pObjAccess->Release();
								pObjAccess = NULL;
							}
						}

					}	// IF Succeeded(HR)
					else
					{
						hr = WBEM_S_NO_ERROR;
					}

					Sleep( g_dwSleepTick );

				}	// FOR Refresh

				// Release anything we got back from the refresher and any
				// memory we may have allocated.
				if ( fEnum )
				{
					if ( !g_fAddDel )
						pEnum->Release();

					if ( NULL != apEnumAccess )
					{
						delete [] apEnumAccess;
					}

				}
				else
				{
					if ( !g_fAddDel )
						pObjAccess->Release();
				}

			}

			pConfig->Release();
		}

	}

	if ( NULL != pRefresher )
		pRefresher->Release();

	CoUninitialize();

	return 0;

}

int _cdecl main( int argc, char *argv[] )
{
	WCHAR	wcsSvrName[256];
	WCHAR	wcsNameSpace[256];
	BOOL	fEnum = FALSE;

	wcscpy( wcsSvrName, L"." );
	wcscpy( wcsNameSpace, L"\\\\.\\root\\default");

	CoInitializeEx( NULL, COINIT_MULTITHREADED );
	CoInitializeSecurity( NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE,
			NULL, EOAC_NONE, NULL );
//	InitializeSecurity(RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE );

	// See if we were told to go remote or not.
	if ( argc > 1 )
	{
		MultiByteToWideChar( CP_ACP, 0L, argv[1], -1, g_wcsObjectPath, 2048 );

		if ( argc > 2 )
		{
			g_fAddDel = strtoul( argv[2], NULL, 10 );

			if ( argc > 3 )
			{
				g_dwNumReps = strtoul( argv[3], NULL, 10 );

				if ( argc > 4 )
				{
					g_dwNumThreads = strtoul( argv[4], NULL, 10 );

					if ( argc > 5 )
					{
						g_dwSleepTick = strtoul( argv[5], NULL, 10 );

						if ( argc > 6 )
						{
							MultiByteToWideChar( CP_ACP, 0L, argv[6], -1, wcsNameSpace, 2048 );
						}
					}
				}
			}
		}
	}
	else
	{
		printf( "No object path!\n" );
		printf( "Usage: refreshertest.exe <object_path> <delete_object> <Num_Refreshes> <Num_Threads> <Tick_Interval> <Namespace>\n" );
		return 0;
	} 

	IWbemLocator*		pWbemLocator = NULL;

	HRESULT hr = CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (void**) &pWbemLocator );

	// Name space to connect to
	BSTR	bstrNameSpace = SysAllocString( wcsNameSpace );

	hr = pWbemLocator->ConnectServer(	bstrNameSpace,	// NameSpace Name
										NULL,			// UserName
										NULL,			// Password
										NULL,			// Locale
										0L,				// Security Flags
										NULL,			// Authority
										NULL,			// Wbem Context
										&g_pNameSpace		// Namespace
										);

	SysFreeString( bstrNameSpace );

	if ( SUCCEEDED( hr ) )
	{
		IUnknown*	pUnk = NULL;
			
		g_pNameSpace->QueryInterface( IID_IUnknown, (void**) &pUnk );

		CoSetProxyBlanket( pUnk, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL, RPC_C_AUTHN_LEVEL_CONNECT,
			RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE );

		pUnk->Release();

		CoSetProxyBlanket( g_pNameSpace, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL, RPC_C_AUTHN_LEVEL_CONNECT,
			RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE );

		HANDLE*	ahThreads = new HANDLE[g_dwNumThreads];

		for ( DWORD	dwCtr = 0; dwCtr < g_dwNumThreads; dwCtr++ )
		{
			ahThreads[dwCtr] = (HANDLE) _beginthreadex( NULL, 0, RefreshThread, (void*) dwCtr, 0, NULL );
			Sleep(1000);
		}

		// Wait for all the threads to get signalled
		WaitForMultipleObjects( g_dwNumThreads, ahThreads, TRUE, INFINITE );

		delete [] ahThreads;

	}

	// Cleanup main objects

	if ( NULL != g_pNameSpace )
		g_pNameSpace->Release();

	if ( NULL != pWbemLocator )
		pWbemLocator->Release();

	CoUninitialize();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\transact\client\utils.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

template <class T> class CDeleteMe
{
private:
	T *m_param;

public:
	CDeleteMe(T *param) : m_param(param) {}
	~CDeleteMe() { if (m_param) delete m_param; }

	void DeleteNow() { if (m_param) {delete m_param; m_param = NULL; }}
};

template <class T> class CVectorDeleteMe
{
private:
	T *m_param;

public:
	CVectorDeleteMe(T *param) : m_param(param) {}
	~CVectorDeleteMe() { if (m_param) delete [] m_param; }

	void DeleteNow() { if (m_param) {delete [] m_param; m_param = NULL; }}
};

template <class T> class CReleaseMe
{
private:
	T *m_param;

public:
	CReleaseMe(T *param) : m_param(param) {}
	~CReleaseMe() { if (m_param) m_param->Release(); }

	void DeleteNow() { if (m_param) { m_param->Release(); m_param = NULL; }}
};

class CSysFreeStringMe
{
private:
	BSTR m_param;

public:
	CSysFreeStringMe(BSTR param) : m_param(param) {}
	~CSysFreeStringMe() { if (m_param) SysFreeString(m_param); }

	void DeleteNow() { if (m_param) {SysFreeString(m_param); m_param = NULL; }}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\simphiperf\simphiperf.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

/*************************************************************
**************************************************************
*
*
*	HiPerfProv.cpp
*
*
*	Created by a-dcrews, Oct. 20, 1998	
*
*
**************************************************************
*************************************************************/


#include "precomp.h"
#include <stdio.h>

#include <wbemidl.h>
#include <wbemint.h>

#include "common.h"
#include "SimpHiPerf.h"

const enum CounterHandles
{
	ctr1,
	ctr2,
	ctr3,
	ctr4,
	ctr5,
	NumCtrs
};

struct tag_Properties{
	LONG	lHandle;
	_TCHAR	tcsPropertyName[128];
	DWORD	dwType;
} g_atcsProperties[] =
{
	0,	_T("Counter1"),	PROP_DWORD,
	0,	_T("Counter2"),	PROP_DWORD,
	0,	_T("Counter3"),	PROP_DWORD,
	0,	_T("Counter4"),	PROP_DWORD,
	0,	_T("Counter5"),	PROP_DWORD
};

/*************************************************************
**************************************************************
*
*
*	CHiPerfProvider
*
*
**************************************************************
*************************************************************/

CHiPerfProvider::CHiPerfProvider(CLifeControl *pControl) : 
CUnk(pControl), m_XProviderInit(this), m_XHiPerfProvider(this)
/*************************************************************
*
*	Constructor
*
*************************************************************/
{
	int i;

    // Initialize internal instance cache to empty
	// ===========================================

    for (i = 0; i < NUM_SAMPLE_INSTANCES; i++)
        m_apInstances[i] = 0;

    // Initialize name handles to zero
	// ===============================

	m_hName = 0;

}

CHiPerfProvider::~CHiPerfProvider()
/*************************************************************
*
*	Destructor
*
*************************************************************/
{
	int i;

    // Release all the objects which have been added to the array
	// ==========================================================

    for (i = 0; i < NUM_SAMPLE_INSTANCES; i++)
	{
        if (m_apInstances[i])
            m_apInstances[i]->Release();
	}

}

void* CHiPerfProvider::GetInterface(REFIID riid)
/*************************************************************
*
*	Provides interface id resolution to CUnk
*
*************************************************************/
{

    if(riid == IID_IWbemProviderInit)
        return &m_XProviderInit;
	if (riid == IID_IWbemHiPerfProvider)
		return &m_XHiPerfProvider;

    return NULL;
}

//////////////////////////////////////////////////////////////
//
//					COM implementations
//
//////////////////////////////////////////////////////////////


HRESULT CHiPerfProvider::SetHandles(IWbemClassObject* pSampleClass)
/*************************************************************
*
*	Get the property handles for the well-known properties in
*	this counter type.  These property handles are available
*	to all nested classes of HiPerfProvider.
*
*	If the method fails, the property handle values may be in 
*	an indeterminite state.
*
*************************************************************/
{
	LONG	hProperty	= 0;
	HRESULT hRes		= 0;
    BSTR PropName		= 0;

	// Get the IWbemAccess interface to the class
	// ==========================================

	IWbemObjectAccess *pAccess;

	hRes = pSampleClass->QueryInterface(IID_IWbemObjectAccess, (LPVOID *)&pAccess);
	if (FAILED(hRes))
	{
		return hRes;
	}

	// Get the handle to the Name
	// ==========================

    PropName = SysAllocString(L"Name");
    hRes = pAccess->GetPropertyHandle(PropName, 0, &m_hName);
	if (FAILED(hRes))
	{
		pAccess->Release();
		return hRes;
	}
    SysFreeString(PropName);

	// Get the counter property handles
	// ================================

	for (int i = 0; i < NumCtrs; i++)
	{
		PropName = SysAllocString(g_atcsProperties[i].tcsPropertyName);    
		hRes = pAccess->GetPropertyHandle(PropName, 0, &g_atcsProperties[i].lHandle);
		if (FAILED(hRes))
		{
			pAccess->Release();
			return hRes;
		}

		SysFreeString(PropName);
	}

	pAccess->Release();

	return WBEM_NO_ERROR;
}


STDMETHODIMP CHiPerfProvider::XProviderInit::Initialize( 
    /* [unique][in] */  LPWSTR wszUser,
    /* [in] */          LONG lFlags,
    /* [in] */          LPWSTR wszNamespace,
    /* [unique][in] */  LPWSTR wszLocale,
    /* [in] */          IWbemServices __RPC_FAR *pNamespace,
    /* [in] */          IWbemContext __RPC_FAR *pCtx,
    /* [in] */          IWbemProviderInitSink __RPC_FAR *pInitSink)
//////////////////////////////////////////////////////////////////////
//
//  Called once during startup.  Indicates to the provider which
//  namespace it is being invoked for and which User.  It also supplies
//  a back pointer to WINMGMT so that class definitions can be retrieved.
//
//  We perform any one-time initialization in this routine. The
//  final call to Release() is for any cleanup.
//
//  <wszUser>           The current user.
//  <lFlags>            Reserved.
//  <wszNamespace>      The namespace for which we are being activated.
//  <wszLocale>         The locale under which we are to be running.
//  <pNamespace>        An active pointer back into the current namespace
//                      from which we can retrieve schema objects.
//  <pCtx>              The user's context object.  We simply reuse this
//                      during any reentrant operations into WINMGMT.
//  <pInitSink>         The sink to which we indicate our readiness.
//
//////////////////////////////////////////////////////////////////////
{
	IWbemClassObject  *pSampleClass = 0;
    IWbemObjectAccess *pAccess = 0;

    // Get a copy of our sample class def so that we can create & maintain
    // instances of it.

	BSTR bstrObject = SysAllocString(SAMPLE_CLASS);

	HRESULT hRes = pNamespace->GetObject(bstrObject, 0, pCtx, &pSampleClass, 0);

	SysFreeString(bstrObject);

    if (FAILED(hRes))
	{
        return hRes;
	}

	hRes = m_pObject->SetHandles(pSampleClass);
	if (FAILED(hRes))
	{
		pSampleClass->Release();
		return hRes;
	}

    // Precreate 100 instances, and set them up in an array which
    // is a member of this C++ class.
    //
    // We only store the IWbemObjectAccess pointers, since
    // we are updating 'well-known' properties and already 
    // know their names.

    for (int i = 0; i < NUM_SAMPLE_INSTANCES; i++)
    {
		IWbemClassObject *pInst = 0;

		// Create the instance
		// ===================

		hRes = pSampleClass->SpawnInstance(0, &pInst);
		if (FAILED(hRes))
		{
			pSampleClass->Release();
			return hRes;
		}

		// Get the IWbemObjectAccess interface
		// ===================================

        pInst->QueryInterface(IID_IWbemObjectAccess, (LPVOID *)&pAccess);

        // Initialize the instance's name
		// ==============================

		WCHAR wcsName[128];
		swprintf(wcsName, L"Inst_%d", i);
		hRes = pAccess->WritePropertyValue(m_pObject->m_hName, (wcslen(wcsName)+1)*sizeof(wchar_t), (BYTE*)wcsName);
		
		if (FAILED(hRes))
		{
			pSampleClass->Release();
			pAccess->Release();
			return hRes;
		}

		// Set the initial counter values
		// ==============================

		for (int nProp = 0; nProp < NumCtrs; nProp++)
		{
			LONG lHandle = g_atcsProperties[nProp].lHandle;

			switch(g_atcsProperties[nProp].dwType)
			{
			case PROP_DWORD:
					hRes = pAccess->WriteDWORD(lHandle, DWORD(i));break;
			}
			if (FAILED(hRes))
			{
				pSampleClass->Release();
				pAccess->Release();
				return hRes;
			}
		}

		// Add to the instance array
		// =========================

        m_pObject->m_apInstances[i] = pAccess;

		// Release the IWbemClassObject
		// ============================

        pInst->Release();
    }

    // We now have all the instances ready to go and all the 
    // property handles cached.   Tell WINMGMT that we're
    // ready to start 'providing'
	
    pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);

	pSampleClass->Release();

    return NO_ERROR;
}

STDMETHODIMP CHiPerfProvider::XHiPerfProvider::QueryInstances( 
    /* [in] */          IWbemServices __RPC_FAR *pNamespace,
    /* [string][in] */  WCHAR __RPC_FAR *wszClass,
    /* [in] */          long lFlags,
    /* [in] */          IWbemContext __RPC_FAR *pCtx,
    /* [in] */          IWbemObjectSink __RPC_FAR *pSink )
//////////////////////////////////////////////////////////////////////
//
//  Called whenever a complete, fresh list of instances for a given
//  class is required.   The objects are constructed and sent back to the
//  caller through the sink.  The sink can be used in-line as here, or
//  the call can return and a separate thread could be used to deliver
//  the instances to the sink.
//
//  Parameters:
//  <pNamespace>        A pointer to the relevant namespace.  This
//                      should not be AddRef'ed.
//  <wszClass>          The class name for which instances are required.
//  <lFlags>            Reserved.
//  <pCtx>              The user-supplied context (not used here).
//  <pSink>             The sink to which to deliver the objects.  The objects
//                      can be delivered synchronously through the duration
//                      of this call or asynchronously (assuming we
//                      had a separate thread).  A IWbemObjectSink::SetStatus
//                      call is required at the end of the sequence.
//
//////////////////////////////////////////////////////////////////////
{
	HRESULT hRes;

    if (pNamespace == 0 || wszClass == 0 || pSink == 0)
        return WBEM_E_INVALID_PARAMETER;

    // Quickly zip through the instances and update the values before 
    // returning them.  This is just a dummy operation to make it
    // look like the instances are continually changing like real
    // perf counters.

    for (int i = 0; i < NUM_SAMPLE_INSTANCES; i++)
    {
        IWbemObjectAccess *pAccess = m_pObject->m_apInstances[i];
        
        // Every object can be access one of two ways.  In this case
        // we get the 'other' (primary) interface to this same object.
 
		IWbemClassObject *pOtherFormat = 0;
		hRes = pAccess->QueryInterface(IID_IWbemClassObject, (LPVOID *) &pOtherFormat);
		if (FAILED(hRes))
		{
			return hRes;
		}

        // Send a copy back to the caller
		// ==============================

        pSink->Indicate(1, &pOtherFormat);

        pOtherFormat->Release();    // Don't need this any more
    }
    
    // Tell WINMGMT we are all finished supplying objects
	// ==================================================

    pSink->SetStatus(0, WBEM_NO_ERROR, 0, 0);

    return NO_ERROR;
}    

STDMETHODIMP CHiPerfProvider::XHiPerfProvider::CreateRefresher( 
     /* [in] */ IWbemServices __RPC_FAR *pNamespace,
     /* [in] */ long lFlags,
     /* [out] */ IWbemRefresher __RPC_FAR *__RPC_FAR *ppRefresher )
//////////////////////////////////////////////////////////////////////
//
//  Called whenever a new refresher is needed by the client.
//
//  Parameters:
//  <pNamespace>        A pointer to the relevant namespace.  Not used.
//  <lFlags>            Not used.
//  <ppRefresher>       Receives the requested refresher.
//
//////////////////////////////////////////////////////////////////////
{
    if (pNamespace == 0 || ppRefresher == 0)
        return WBEM_E_INVALID_PARAMETER;

    // Construct a new empty refresher
	// ===============================

	XRefresher *pNewRefresher = new XRefresher(m_pObject);

    // Follow COM rules and AddRef() the thing before sending it back
	// ==============================================================

    pNewRefresher->AddRef();
    *ppRefresher = pNewRefresher;
    
    return NO_ERROR;
}

STDMETHODIMP CHiPerfProvider::XHiPerfProvider::CreateRefreshableObject( 
    /* [in] */ IWbemServices __RPC_FAR *pNamespace,
    /* [in] */ IWbemObjectAccess __RPC_FAR *pTemplate,
    /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pContext,
    /* [out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
    /* [out] */ long __RPC_FAR *plId )
//////////////////////////////////////////////////////////////////////
//
//  Called whenever a user wants to include an object in a refresher.
//     
//  Parameters:
//  <pNamespace>        A pointer to the relevant namespace in WINMGMT.
//  <pTemplate>         A pointer to a copy of the object which is to be
//                      added.  This object itself cannot be used, as
//                      it not owned locally.        
//  <pRefresher>        The refresher to which to add the object.
//  <lFlags>            Not used.
//  <pContext>          Not used here.
//  <ppRefreshable>     A pointer to the internal object which was added
//                      to the refresher.
//  <plId>              The Object Id (for identification during removal).        
//
//////////////////////////////////////////////////////////////////////
{
    // The object supplied by <pTemplate> must not be copied.
    // Instead, we want to find out which object the caller is after
    // and return a pointer to *our* own private instance which is 
    // already set up internally.  This value will be sent back to the
    // caller so that everyone is sharing the same exact instance
    // in memory.

	HRESULT	hres = WBEM_S_NO_ERROR;

    // Find out which object is being requested for addition.
    wchar_t buf[128];
    *buf = 0;
    LONG lNameLength = 0;    
    pTemplate->ReadPropertyValue(m_pObject->m_hName, 128, &lNameLength, LPBYTE(buf));
    
    // Scan out the index from the instance name.  We only do this
    // because the instance name is a string.
    DWORD dwIndex = 0;    
    swscanf(buf, L"Inst_%u", &dwIndex);

	if ( dwIndex >= NUM_SAMPLE_INSTANCES )
	{
		return WBEM_E_NOT_FOUND;
	}

    // Now we know which object is desired.
    IWbemObjectAccess *pOurCopy = m_pObject->m_apInstances[dwIndex];

    // The refresher being supplied by the caller is actually
    // one of our own refreshers, so a simple cast is convenient
    // so that we can access private members.
    XRefresher *pOurRefresher = (XRefresher *) pRefresher;

    pOurRefresher->AddObject(pOurCopy, plId);

    // Return a copy of the internal object.
    pOurCopy->AddRef();
    *ppRefreshable = pOurCopy;
    *plId = LONG(dwIndex);

    return NO_ERROR;
}
    
STDMETHODIMP CHiPerfProvider::XHiPerfProvider::StopRefreshing( 
    /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
    /* [in] */ long lId,
    /* [in] */ long lFlags )
//////////////////////////////////////////////////////////////////////
//
//  Called whenever a user wants to remove an object from a refresher.
//     
//  Parameters:
//  <pRefresher>            The refresher object from which we are to 
//                          remove the perf object.
//  <lId>                   The ID of the object.
//  <lFlags>                Not used.
//  
//////////////////////////////////////////////////////////////////////
{
    // The refresher being supplied by the caller is actually
    // one of our own refreshers, so a simple cast is convenient
    // so that we can access private members.
    XRefresher *pOurRefresher = (XRefresher *) pRefresher;

    pOurRefresher->RemoveObject(lId);

    return NO_ERROR;
}

STDMETHODIMP CHiPerfProvider::XHiPerfProvider::CreateRefreshableEnum( 
	/* [in] */ IWbemServices* pNamespace,
	/* [in, string] */ LPCWSTR wszClass,
	/* [in] */ IWbemRefresher* pRefresher,
	/* [in] */ long lFlags,
	/* [in] */ IWbemContext* pContext,
	/* [in] */ IWbemHiPerfEnum* pHiPerfEnum,
	/* [out] */ long* plId )
{

    // The refresher being supplied by the caller is actually
    // one of our own refreshers, so a simple cast is convenient
    // so that we can access private members.
    XRefresher *pOurRefresher = (XRefresher *) pRefresher;

	return pOurRefresher->AddEnum( pHiPerfEnum, plId );
}

STDMETHODIMP CHiPerfProvider::XHiPerfProvider::GetObjects( 
    /* [in] */ IWbemServices* pNamespace,
	/* [in] */ long lNumObjects,
	/* [in,size_is(lNumObjects)] */ IWbemObjectAccess** apObj,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext* pContext)
{
	// Just a placeholder for now
	return E_NOTIMPL;
}


CHiPerfProvider::XRefresher::XRefresher(CHiPerfProvider *pObject)
: m_pObject( pObject ), m_lRef( 0 )
{
	// AddRef the object
	if ( NULL != m_pObject )
	{
		m_pObject->AddRef();
	}

    // Initialize the instance cache as empty
	// ======================================

    for (int i = 0; i < NUM_SAMPLE_INSTANCES; i++)
        m_aRefInstances[i] = 0;

	// Initialize enumerator array
	// ===========================

	for (i = 0; i < NUM_ENUMERATORS; i++)
		m_apEnumerators[i] = 0;


}

CHiPerfProvider::XRefresher::~XRefresher()
{
    // Release the cached IWbemObjectAccess instances
	// ==============================================

    for (DWORD i = 0; i < NUM_SAMPLE_INSTANCES; i++)
    {
        if (m_aRefInstances[i])
            m_aRefInstances[i]->Release();
    }            

	// Cleanup
	if ( NULL != m_pObject )
	{
		m_pObject->Release();
	}

	// Release all of the enumerators
	// ==============================

	for (i = 0; i < NUM_ENUMERATORS; i++)
	{
		if (0 != m_apEnumerators[i])
		{
			m_apEnumerators[i]->m_pEnum->Release();
			delete m_apEnumerators[i];
		}
	}


}

ULONG STDMETHODCALLTYPE CHiPerfProvider::XRefresher::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CHiPerfProvider::XRefresher::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

HRESULT STDMETHODCALLTYPE CHiPerfProvider::XRefresher::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemRefresher)
    {
        *ppv = this;
    }
    else return E_NOINTERFACE;

    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

BOOL CHiPerfProvider::XRefresher::AddObject(IWbemObjectAccess *pObj, LONG *plId)
//////////////////////////////////////////////////////////////////////
//
//  Adds an object to the refresher.   This is a private mechanism
//  used by CHiPerfProvider and not part of the COM interface.
//
//  The ID we return for future identification is simply
//  the array index.
//
//////////////////////////////////////////////////////////////////////
{
    for (DWORD i = 0; i < NUM_SAMPLE_INSTANCES; i++)
    {
        if (m_aRefInstances[i] == 0)
		{
			pObj->AddRef();
			m_aRefInstances[i] = pObj;
            
            // The ID we return for future identification is simply
            // the array index.
			*plId = i;
            return TRUE;
        }
    }        

    return FALSE;
}

BOOL CHiPerfProvider::XRefresher::RemoveObject(LONG lId)
//////////////////////////////////////////////////////////////////////
//
//  Removes an object from the refresher.  This is a private mechanism 
//	used by CHiPerfProvider and not part of the COM interface.
//
//  Removes an object from the refresher by ID.   In our case, the ID
//  is actually the array index we used internally, so it is simple
//  to locate and remove the object.
//
//////////////////////////////////////////////////////////////////////
{
	// This means its an enumerator
	if ( lId & 0x1000 )
	{
		//	Mask out the enumerator bit
		long lIndex = ( lId &~ 0x1000 );

		if ( m_apEnumerators[lIndex] == 0 )
		{
			return FALSE;
		}

		m_apEnumerators[lIndex]->m_pEnum->Release();
		delete m_apEnumerators[lIndex];
		m_apEnumerators[lIndex] = NULL;
	}
	else
	{
		if (m_aRefInstances[lId] == 0)
			return FALSE;
        
		m_aRefInstances[lId]->Release();
		m_aRefInstances[lId] = 0;
	}

	return TRUE;        
}

HRESULT CHiPerfProvider::XRefresher::AddEnum( IWbemHiPerfEnum* pHiPerfEnum, long* plId )
{

	for (int nIndex = 0; nIndex < NUM_ENUMERATORS; nIndex++)
	{
		if (0 == m_apEnumerators[nIndex])
		{
			CEnumerator *pEnum = new CEnumerator;

			pHiPerfEnum->AddRef();
			pEnum->m_pEnum = pHiPerfEnum;

			// Add all the objects at once into the enumerator
			pHiPerfEnum->AddObjects( 0L, NUM_SAMPLE_INSTANCES, pEnum->m_alIDs, m_pObject->m_apInstances );

			m_apEnumerators[nIndex] = pEnum;

			*plId = nIndex | 0x1000L;

			return S_OK;
		}
	}
	return E_FAIL;
}

HRESULT CHiPerfProvider::XRefresher::Refresh(/* [in] */ long lFlags)
//////////////////////////////////////////////////////////////////////
//
//  Executed to refresh a set of instances bound to the particular 
//  refresher.
//
//////////////////////////////////////////////////////////////////////
{
	// We don't change any values here.  This provider is only here to help exercise
	// the code in a controlled situation so we can better track problems like memory
	// leaks and such.
	return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\simphiperf\simphiperf.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//////////////////////////////////////////////////////////////////////
//
//	HiPerfProv.h
//
//	Based on NTPerf by raymcc.
//
//	Created by a-dcrews, Oct 15, 1998
//	
//////////////////////////////////////////////////////////////////////

#ifndef _HIPERFPROV_H_
#define _HIPERFPROV_H_

#include <unk.h>

#include <tchar.h> 

#define NUM_SAMPLE_INSTANCES	5
#define NUM_ENUMERATORS			10

#define SAMPLE_CLASS			_T("Win32_SimpleHiPerf")

#define MMF_NAME				_T("HPP_MMF")
#define MMF_FILENAME			_T("HPP_MMF.DAT")

const IID IID_IHiPerfProvider = {0x33f5cbf8, 0x6519, 0x11d2, 0xb7, 0x22, 0x0, 0x10, 0x4b, 0x70, 0x3e, 0x46};

#define PROP_DWORD	0x0001L
#define PROP_QWORD	0x0002L
#define PROP_VALUE	0x0004L



class CEnumerator
{
public:

	CEnumerator()
	{
		for ( int nCtr = 0; nCtr < NUM_SAMPLE_INSTANCES; nCtr++ )
		{
			m_alIDs[nCtr] = nCtr;
		}
	}

	~CEnumerator()
	{};

	IWbemHiPerfEnum	*m_pEnum;
	long	m_alIDs[NUM_SAMPLE_INSTANCES];

	long GetRandItem() {return m_alIDs[rand() % NUM_SAMPLE_INSTANCES];}
};

class CHiPerfProvider : public CUnk
{
protected:
	IWbemObjectAccess	*m_apInstances[NUM_SAMPLE_INSTANCES];

	LONG	m_hName;

	PBYTE	m_pbView;

	HRESULT SetHandles(IWbemClassObject* pSampleClass);
	BOOL CreateMMF();
	BOOL RemoveMMF();

	friend class CRefresher;

protected:
	class XProviderInit : public CImpl<IWbemProviderInit, CHiPerfProvider>
	{
	public:
		XProviderInit(CHiPerfProvider *pObject) : 
		  CImpl<IWbemProviderInit, CHiPerfProvider>(pObject)
		  {}

		STDMETHOD(Initialize)( 
			/* [unique][in] */ LPWSTR wszUser,
			/* [in] */ LONG lFlags,
			/* [in] */ LPWSTR wszNamespace,
			/* [unique][in] */ LPWSTR wszLocale,
			/* [in] */ IWbemServices __RPC_FAR *pNamespace,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink );
	} m_XProviderInit;
	friend XProviderInit;

    class XHiPerfProvider : public CImpl<IWbemHiPerfProvider, CHiPerfProvider>
	{
	public:
		XHiPerfProvider(CHiPerfProvider *pObject) : 
		  CImpl<IWbemHiPerfProvider, CHiPerfProvider>(pObject)
		  {}

		STDMETHOD(QueryInstances)( 
			/* [in] */ IWbemServices __RPC_FAR *pNamespace,
			/* [string][in] */ WCHAR __RPC_FAR *wszClass,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [in] */ IWbemObjectSink __RPC_FAR *pSink );
        
		STDMETHOD(CreateRefresher)( 
			/* [in] */ IWbemServices __RPC_FAR *pNamespace,
			/* [in] */ long lFlags,
			/* [out] */ IWbemRefresher __RPC_FAR *__RPC_FAR *ppRefresher );
        
		STDMETHOD(CreateRefreshableObject)( 
			/* [in] */ IWbemServices __RPC_FAR *pNamespace,
			/* [in] */ IWbemObjectAccess __RPC_FAR *pTemplate,
			/* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pContext,
			/* [out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
			/* [out] */ long __RPC_FAR *plId );
        
		STDMETHOD(StopRefreshing)( 
			/* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
			/* [in] */ long lId,
			/* [in] */ long lFlags );

		STDMETHOD(CreateRefreshableEnum)(
			/* [in] */ IWbemServices* pNamespace,
			/* [in, string] */ LPCWSTR wszClass,
			/* [in] */ IWbemRefresher* pRefresher,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext* pContext,
			/* [in] */ IWbemHiPerfEnum* pHiPerfEnum,
			/* [out] */ long* plId);

		STDMETHOD(GetObjects)(
            /* [in] */ IWbemServices* pNamespace,
			/* [in] */ long lNumObjects,
			/* [in,size_is(lNumObjects)] */ IWbemObjectAccess** apObj,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pContext);

	} m_XHiPerfProvider;
	friend XHiPerfProvider;

	class XRefresher : public IWbemRefresher
	{
		friend XHiPerfProvider;
		IWbemObjectAccess *m_aRefInstances[NUM_SAMPLE_INSTANCES];
		CEnumerator			*m_apEnumerators[NUM_ENUMERATORS];

		BOOL AddObject(IWbemObjectAccess *pObj, LONG *plId);
		HRESULT AddEnum(IWbemHiPerfEnum *pEnum, LONG *plId);
		BOOL RemoveObject(LONG lId);

		long	m_lRef;

	public:
		XRefresher(CHiPerfProvider *pObject);
		virtual ~XRefresher();

        ULONG STDMETHODCALLTYPE AddRef();
        ULONG STDMETHODCALLTYPE Release();
        HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);

		STDMETHOD(Refresh)(/* [in] */ long lFlags);

		CHiPerfProvider*	m_pObject;

	};
	friend XRefresher;

public:
	CHiPerfProvider(CLifeControl *pControl);
	~CHiPerfProvider();

	virtual void* GetInterface(REFIID riid);
};

#endif // _HIPERFPROV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\syncenumtest\syncenumtest.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// OBJINTERNALSTESTDlg.cpp : implementation file
//

#include "precomp.h"
//#include <objbase.h>
#include <stdio.h>
#include <wbemcli.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include <fastall.h>
#include <cominit.h>
#include "objindpacket.h"

//#define TEST_CLASS	L"Win32_BIOS"
#define TEST_CLASS	L"Win32_DiskPartition"
//#define TEST_CLASS	L"Win32_IRQResource"
//#define TEST_CLASS	L"Win32_Directory"

void SinkTest( BOOL fRemote, LPCTSTR pszMachineName )
{
	IWbemLocator*		pWbemLocator = NULL;

	HRESULT hr = CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (void**) &pWbemLocator );

	if ( SUCCEEDED(hr) )
	{
		LPWSTR	lpwcsMachineName = L".";
		LPWSTR	lpwcsNameSpace = L"ROOT\\DEFAULT";
		WCHAR	wszNameSpace[255];

		swprintf( wszNameSpace, L"\\\\%s\\%s", lpwcsMachineName, lpwcsNameSpace );

		// Name space to connect to
		BSTR	bstrNameSpace = SysAllocString( wszNameSpace );

		LPWSTR	lpwcsObjectPath = L"Win32_SerialPort.DeviceID=\"COM1\"";
		BSTR	bstrObjectPath = NULL;

		bstrObjectPath = SysAllocString( lpwcsObjectPath );

		IWbemServices*	pNameSpace = NULL;

		hr = pWbemLocator->ConnectServer(	bstrNameSpace,	// NameSpace Name
											NULL,			// UserName
											NULL,			// Password
											NULL,			// Locale
											0L,				// Security Flags
											NULL,			// Authority
											NULL,			// Wbem Context
											&pNameSpace		// Namespace
											);

		if ( SUCCEEDED(hr) )
		{

			BSTR	bstrClass = SysAllocString( TEST_CLASS );

			IEnumWbemClassObject*	pEnum;

			printf( "Querying WINMGMT for instances of class: %S\n", TEST_CLASS );

			hr = pNameSpace->CreateInstanceEnum( bstrClass,
												WBEM_FLAG_FORWARD_ONLY,
												NULL,
												&pEnum );

			long	lCount = 0;

			// Walk the enumerator
			if ( SUCCEEDED( hr ) )
			{

				printf( "Successfully received instances.\n" );

				IWbemClassObject*	pObj;

				ULONG		ulTotalReturned = 0;

				while ( SUCCEEDED( hr ) )
				{
					ULONG	ulNumReturned = 0;

					IWbemClassObject*	apObjectArray[100];

					ZeroMemory( apObjectArray, sizeof(apObjectArray) );

					// Go through the object 100 at a time
					hr = pEnum->Next( WBEM_INFINITE,
									100,
									apObjectArray,
									&ulNumReturned );

					// Calculate our packet size and attempt to marshal and
					// unmarshal the packet.

					if ( SUCCEEDED( hr ) && ulNumReturned > 0 )
					{
						ulTotalReturned += ulNumReturned;

						// How many were returned
						printf( "Got %d objects. Total Returned = %d.\n", ulNumReturned, ulTotalReturned );

						// Clean up the objects
						for ( int x = 0; x < ulNumReturned; x++ )
						{
							apObjectArray[x]->Release();
						}

					}
					else if ( ulNumReturned == 0 )
					{
						hr = WBEM_E_FAILED;
					}
				}

				lCount = pEnum->Release();

			}

			// Done with it.
			pNameSpace->Release();

		}	// IF Got NameSpace

		// Done with it.
		pWbemLocator->Release();

		// Cleanup BEASTERS
		SysFreeString( bstrObjectPath );
		SysFreeString( bstrNameSpace );

	}	// IF Got WbemLocator
}


///////////////////////////////////////////////////////////////////
//
//	Function:	main
//
//	Entry point function to exercise IWbemObjectInternals interface.
//
///////////////////////////////////////////////////////////////////

int _cdecl main( int argc, char *argv[] )
{
	char	szMachineName[256];

	HRESULT	hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );

	hr = CoInitializeSecurity( NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE,
										NULL, EOAC_NONE, NULL );


	LPSTR	pszMachineName = szMachineName;
	DWORD	dwSizeBuffer = sizeof(szMachineName);

	GetComputerName( szMachineName, &dwSizeBuffer );

	BOOL	fRemote = FALSE;

	// See if we were told to go remote or not.
	if ( argc > 1 && _stricmp( argv[1], "/Remote" ) == 0 )
	{
		fRemote = TRUE;

		if ( argc > 2 )
		{
			pszMachineName = argv[2];
		}
	}

	SinkTest( fRemote, pszMachineName );

	CoUninitialize();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\smallarr\main.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include <windows.h>
#include <stdio.h>
#include <wbemcomn.h>
#include <smallarr.h>

#define FATAL {printf("Error: line %d\n", __LINE__); exit(1);}

void TestEmpty(CSmallArray& a)
{
    if(a.Size() != 0) FATAL;
    a.Sort();
    a.Trim();
    if(a.GetArrayPtr() != NULL) FATAL;

    a.InsertAt(0, (void*)4);
    if(a.Size() != 1) FATAL;
    if(a.GetAt(0) != (void*)4) FATAL;

    a.RemoveAt(0);
    if(a.Size() != 0) FATAL;
    
    a.Add((void*)4);
    if(a.Size() != 1) FATAL;
    if(a.GetAt(0) != (void*)4) FATAL;
    if(*a.GetArrayPtr() != (void*)4) FATAL;

    a.Trim();
    if(a.Size() != 1) FATAL;
    a.SetAt(0, NULL);
    if(a.GetAt(0) != NULL) FATAL;
    a.Trim();
    if(a.Size() != 0) FATAL;
}

void TestSingle(CSmallArray& a)
{
    a.Add((void*)4);
    a.Add((void*)8);

    if(a.Size() != 2) FATAL;
    if(a.GetAt(0) != (void*)4) FATAL;
    if(a.GetAt(1) != (void*)8) FATAL;
    if(*a.GetArrayPtr() != (void*)4) FATAL;

    a.RemoveAt(0);
    if(a.Size() != 1) FATAL;
    if(a.GetAt(0) != (void*)8) FATAL;
   
    a.Empty();
    if(a.Size() != 0) FATAL;
    a.Add((void*)8);
    a.InsertAt(0, (void*)4);
    if(a.Size() != 2) FATAL;
    if(a.GetAt(0) != (void*)4) FATAL;
    if(a.GetAt(1) != (void*)8) FATAL;

    a.RemoveAt(1);
    if(a.Size() != 1) FATAL;
    if(a.GetAt(0) != (void*)4) FATAL;
    a.Empty();
}

void Test10(CSmallArray& a)
{
    int i;
    for(i = 0; i < 100; i++)
        a.Add((void*)(i*4));

    if(a.Size() != 100) FATAL;
    for(i = 0; i < 100; i++)
        if(a[i] != (void*)(i*4)) FATAL;

    for(i = 0; i < 80; i++)
        a.RemoveAt(1);

    if(a[0] != (void*)0) FATAL;
    for(i = 1; i < 19; i++)
        if(a[i] != (void*)((i+80)*4)) FATAL;

    a.InsertAt(1, (void*)4);
    if(a[0] != (void*)0) FATAL;
    if(a[1] != (void*)4) FATAL;
    if(a[2] != (void*)(81*4)) FATAL;
}

void main()
{
    CSmallArray a;

    TestEmpty(a);
    
    TestSingle(a);

    Test10(a);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\transact\client\main.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include <windows.h>
#include <mtxdm.h>
#include <xolehlp.h>
#include <Txcoord.h>
#include <stdio.h>
#include <wbemcli.h>
#include "utils.h"

//void DoExportOfTransaction(ITransactionDispenser *pTransactionDispenser, ITransaction *pTransaction, IWbemContext *pWbemContext);

void __cdecl main(void)
{
	//Initialise all the COM and security.  This is not needed for transactioning, however
	//it is required for WMI...
	HRESULT hres = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	if (FAILED(hres))
	{
		printf("Failed to initialize com, hRes = 0x%x\n", hres);
		return;
	}
	hres = CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, 0);
	if (FAILED(hres))
	{
		printf("Failed to initialize security, hRes = 0x%x\n", hres);
		return;
	}
	{
		//Automatic destructors need to be called before the CoUninitialize!!!

		//Create the locator so we can connect to WMI...
		IWbemLocator *pWbemLocator = NULL;
		hres = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID *) &pWbemLocator);
		if (FAILED(hres))
		{
			printf("Failed to create an IWbemLocator, hRes = 0x%x\n", hres);
			return;
		}
		CReleaseMe<IWbemLocator> relmepWbemLocator(pWbemLocator);

		//Create the WBEM Context object that we are going to store the transaction information in...
		IWbemContext *pWbemContext = NULL;
		hres = CoCreateInstance(CLSID_WbemContext, 0, CLSCTX_INPROC_SERVER, IID_IWbemContext, (LPVOID *) &pWbemContext);
		if (FAILED(hres))
		{
			printf("Failed to create an IWbemContext, hRes = 0x%x\n", hres);
			return;
		}
		CReleaseMe<IWbemContext> relmepWbemContext(pWbemContext);

		//We need to connect to the DTC to get a transaction dispenser.  This is what allows us to start
		//the transaction, returning us a transaction pointer...
		ITransactionDispenser *pTransactionDispenser;
		hres = DtcGetTransactionManager(0, 0, IID_ITransactionDispenser, 0, 0, 0, (void**)&pTransactionDispenser);
		if (FAILED(hres))
		{
			printf("Failed to get the transaction dispenser, hRes = 0x%x\n", hres);
			return;
		}
		CReleaseMe<ITransactionDispenser> relMepTransactionDispenser(pTransactionDispenser);

		//Start that transaction... getting the transaction pointer in the process...
		ITransaction *pTransaction;
		hres = pTransactionDispenser->BeginTransaction(NULL, ISOLATIONLEVEL_ISOLATED, ISOFLAG_RETAIN_DONTCARE, NULL, &pTransaction);
		if (FAILED(hres))
		{
			printf("Failed to get the transaction, hRes = 0x%x\n", hres);
			return;
		}
		CReleaseMe<ITransaction> relMepTransaction(pTransaction);

		//If we need to export the transaction to the destination, do it in here...
		//As we do not need to do this, then this is commented out!!!
//	DoExportOfTransaction(pTransactionDispenser, pTransaction, pWbemContext);

		//Put the ITransaction pointer in the context...
		BSTR bstrContextName2 = SysAllocString(L"__TRANSACTION_INTERFACE");
		if (bstrContextName2 == NULL)
		{
			printf("Out of memory\n");
			return;
		}
		CSysFreeStringMe sysfreemebstrContextName2(bstrContextName2);
		VARIANT varTransactionInterface;
		VariantInit(&varTransactionInterface);
		V_VT(&varTransactionInterface) = VT_UNKNOWN;
		V_UNKNOWN(&varTransactionInterface) = pTransaction;
		hres = pWbemContext->SetValue(bstrContextName2, 0, &varTransactionInterface);
		if (FAILED(hres))
		{
			printf("Failed to put the transaction interface into the context!\n");
			return;
		}
		//NO variant clear on purpose!!!
		

		//Connect to WMI, passing in the context object with the transaction information included
		//in the context object.
		IWbemServices *pWbemServices = NULL;
		BSTR bstrNamespace = SysAllocString(L"\\\\.\\root\\default");
		if (bstrNamespace == NULL)
		{
			printf("Out of memory\n");
			return;
		}
		CSysFreeStringMe sysfreemebstrNamespace(bstrNamespace);

		hres = pWbemLocator->ConnectServer(bstrNamespace,NULL,NULL,NULL,0,NULL,pWbemContext,&pWbemServices);
		if (FAILED(hres))
		{
			printf("Failed to create an IWbemServices, hRes = 0x%x\n", hres);
			return;
		}
		CReleaseMe<IWbemServices> relmepWbemServices(pWbemServices);
		relmepWbemLocator.DeleteNow();
		sysfreemebstrNamespace.DeleteNow();

		//Now we have set up the transaction, and we have set up the connection to WMI.  Now all we have 
		//to do is call into WMI and perform some information within the transacation.
		IEnumWbemClassObject *pEnumWbemClassObject = NULL;
		BSTR bstrClass = SysAllocString(L"InstProvSamp");
		if (bstrClass == NULL)
		{
			printf("Out of memory\n");
			return;
		}
		CSysFreeStringMe sysfreemebstrClass(bstrClass);
		hres = pWbemServices->CreateInstanceEnum(bstrClass, 0, pWbemContext, &pEnumWbemClassObject);
		if (FAILED(hres))
		{
			printf("Failed to call CreateInstanceEnum on IWbemServices, hRes = 0x%x\n", hres);
			return;
		}
		CReleaseMe<IEnumWbemClassObject> relmepEnumWbemClassObject(pEnumWbemClassObject);
		relmepEnumWbemClassObject.DeleteNow();
		relmepWbemContext.DeleteNow();
		sysfreemebstrClass.DeleteNow();

		//Now that we have finished processing everything, we are now going to commit the transaction
		//so everything really does get committed.
		hres = pTransaction->Commit(0, 0, 0);
		if (FAILED(hres))
		{
			printf("Failed to commit the transaction, hRes = 0x%x\n", hres);
			return;
		}
		
		relMepTransaction.DeleteNow();

	}
	//Deinitialise COM...
	CoUninitialize();

}

/*
//************************************************************************************
//If we need to do an export of a transaction, then this is how we need to do it.
//This will export it to the same machine!  If it needs to export to another machine,
//the whereabouts would need to be retrieved from the destination machine using
//some private application mechanism.
//************************************************************************************
void DoExportOfTransaction(ITransactionDispenser *pTransactionDispenser, ITransaction *pTransaction, IWbemContext *pWbemContext)
{
	//Create the whereabouts interface object so we can find out where we are...
	ITransactionImportWhereabouts *pTransactionImportWhereabouts = 0;
	HRESULT hres = pTransactionDispenser->QueryInterface(IID_ITransactionImportWhereabouts, (void**)&pTransactionImportWhereabouts);
	if (FAILED(hres))
	{
		printf("Failed to get the transaction whereabouts, hRes = 0x%x\n", hres);
		return;
	}
	CReleaseMe<ITransactionImportWhereabouts> relmepTransactionImportWhereabouts(pTransactionImportWhereabouts);

	//Get the whereabouts information...
	ULONG ulWhereaboutsSize;
	hres = pTransactionImportWhereabouts->GetWhereaboutsSize(&ulWhereaboutsSize);
	if (FAILED(hres))
	{
		printf("Failed to get the transaction whereabouts, hRes = 0x%x\n", hres);
		return;
	}
	BYTE *pbWhereabouts = new BYTE[ulWhereaboutsSize];
	if (pbWhereabouts == NULL)
	{
		printf("Out of memory\n");
		return;
	}
	CVectorDeleteMe<BYTE> vecdelmepbWhereabouts(pbWhereabouts);
	hres = pTransactionImportWhereabouts->GetWhereabouts(ulWhereaboutsSize, pbWhereabouts, &ulWhereaboutsSize);
	if (FAILED(hres))
	{
		printf("Failed to get the transaction whereabouts, hRes = 0x%x\n", hres);
		return;
	}
	relmepTransactionImportWhereabouts.DeleteNow();

	//Now we need to do create the exporter factory...
	ITransactionExportFactory *pTransactionExportFactory = NULL;
	hres = pTransactionDispenser->QueryInterface(IID_ITransactionExportFactory, (void**)&pTransactionExportFactory);
	if (FAILED(hres))
	{
		printf("Failed to get the  transaction exporter factory, hRes = 0x%x\n", hres);
		return;
	}
	CReleaseMe<ITransactionExportFactory> relmepTransactionExportFactory(pTransactionExportFactory);

	//Create the exporter object...
	ITransactionExport *pTransactionExport = NULL;
	hres = pTransactionExportFactory->Create(ulWhereaboutsSize, pbWhereabouts, &pTransactionExport);
	if (FAILED(hres))
	{
		printf("Failed to get the  transaction exporter factory, hRes = 0x%x\n", hres);
		return;
	}
	CReleaseMe<ITransactionExport> relmepTransactionExport(pTransactionExport);
	vecdelmepbWhereabouts.DeleteNow();
	relmepTransactionExportFactory.DeleteNow();

	//Export the transaction and get the transaction cookie
	ULONG ulTransactionCookieLength = 0;
	hres = pTransactionExport->Export(pTransaction, &ulTransactionCookieLength);
	if (FAILED(hres))
	{
		printf("Failed to get the  transaction exporter factory, hRes = 0x%x\n", hres);
		return;
	}

	BYTE *pbTransactionCookie = new BYTE[ulTransactionCookieLength];
	if (pbTransactionCookie == NULL)
	{
		printf("Memory allocation failure\n");
		return;
	}
	CVectorDeleteMe<BYTE> vecdelmepbTransactionCookie(pbTransactionCookie);
	hres = pTransactionExport->GetTransactionCookie(pTransaction, ulTransactionCookieLength, pbTransactionCookie, &ulTransactionCookieLength);
	if (FAILED(hres))
	{
		printf("Failed to get the  transaction exporter factory, hRes = 0x%x\n", hres);
		return;
	}
	relmepTransactionExport.DeleteNow();

	//Add the transaction cookie to the context object...
	VARIANT varTransactionCookie;
	VariantInit(&varTransactionCookie);
	V_VT(&varTransactionCookie) = VT_ARRAY | VT_UI1;
    SAFEARRAYBOUND sab;
    sab.cElements = ulTransactionCookieLength;
    sab.lLbound = 0;
    V_ARRAY(&varTransactionCookie) = SafeArrayCreate(VT_UI1, 1, &sab);
    if(V_ARRAY(&varTransactionCookie) == NULL)
	{
		printf("SafeArrayCreate returned NULL\n");
        return ;
	}
    BYTE* saTransactionCookie = NULL;
    hres = SafeArrayAccessData(V_ARRAY(&varTransactionCookie), (void**)&saTransactionCookie);
    if(FAILED(hres))
	{
        return ;
	}
	memcpy(saTransactionCookie, pbTransactionCookie, ulTransactionCookieLength);
	SafeArrayUnaccessData(V_ARRAY(&varTransactionCookie));
	vecdelmepbTransactionCookie.DeleteNow();

	//Add the transaction details to the context object...
	BSTR bstrContextName = SysAllocString(L"__TRANSACTION_COOKIE");
	if (bstrContextName == NULL)
	{
		printf("Out of memory\n");
		return;
	}
	CSysFreeStringMe sysfreemebstrContextName(bstrContextName);
	hres = pWbemContext->SetValue(bstrContextName, 0, &varTransactionCookie);
	VariantClear(&varTransactionCookie);
	if (FAILED(hres))
	{
		printf("Failed to add transaction cookie details to the context, hRes = 0x%x\n", hres);
		return;
	}
	sysfreemebstrContextName.DeleteNow();
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\umitest\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>

#define COREPOL_HEADERFILE_IS_INCLUDED

#define COREPROX_POLARITY __declspec( dllimport )
#define ESSLIB_POLARITY __declspec( dllimport )

#define COREPOL_HEADERFILE_IS_INCLUDED
#define POLARITY_HEADERFILE_IS_INCLUDED
#define POLARITY __declspec( dllimport )

#include "arena.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\transact\instprov\classfac.cpp ===
//***************************************************************************
//
//  CLASSFAC.CPP
//
//  Module: WMI Instance provider sample code
//
//  Purpose: Contains the class factory.  This creates objects when
//           connections are requested.
//
//  Copyright (c) 1997-2001 Microsoft Corporation
//
//***************************************************************************

#include <objbase.h>
#include <mtxdm.h>
#include <txdtc.h>
#include <xolehlp.h>
#include "sample.h"

//***************************************************************************
//
// CProvFactory::CProvFactory
// CProvFactory::~CProvFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CProvFactory::CProvFactory()
{
    m_cRef=0L;
    return;
}

CProvFactory::~CProvFactory(void)
{
    return;
}

//***************************************************************************
//
// CProvFactory::QueryInterface
// CProvFactory::AddRef
// CProvFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CProvFactory::QueryInterface(REFIID riid
    , PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CProvFactory::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CProvFactory::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

//***************************************************************************
//
// CProvFactory::CreateInstance
//
// Purpose: Instantiates a Locator object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CProvFactory::CreateInstance(LPUNKNOWN pUnkOuter
    , REFIID riid, PPVOID ppvObj)
{
    CInstPro *   pObj;
    HRESULT hr;

    *ppvObj=NULL;

    // This object doesnt support aggregation.

    if (NULL!=pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    // Create the locator object.
    
    pObj=new CInstPro();
    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.

    if (FAILED(hr))
        delete pObj;
    return hr;
}

//***************************************************************************
//
// CProvFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CProvFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\transact\instprov\sinks.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

class CResourceManagerSink : public IResourceManagerSink
{
protected:
	ULONG	m_cRef;

public:
	CResourceManagerSink() : m_cRef(0) {}
	STDMETHODIMP QueryInterface(const struct _GUID &,void ** );
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP_(LONG) TMDown(void);
};


class CTransactionResourceAsync : public ITransactionResourceAsync
{
protected:
	ULONG	m_cRef;
	ITransactionEnlistmentAsync *m_pTransactionEnlistmentAsync;

public:
	CTransactionResourceAsync();
	~CTransactionResourceAsync();

	STDMETHODIMP QueryInterface(const struct _GUID &,void ** );
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	STDMETHODIMP PrepareRequest (BOOL fRetaining,DWORD grfRM,BOOL fWantMoniker,BOOL fSinglePhase);

	STDMETHODIMP CommitRequest (DWORD grfRM, XACTUOW * pNewUOW);

	STDMETHODIMP AbortRequest (BOID *pboidReason,BOOL fRetaining,XACTUOW * pNewUOW);

	STDMETHODIMP TMDown ();

	void SetTransactionEnlistmentAync(ITransactionEnlistmentAsync *pTransactionEnlistmentAsync)
	{
		m_pTransactionEnlistmentAsync = pTransactionEnlistmentAsync;
		m_pTransactionEnlistmentAsync->AddRef();
	}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\transact\instprov\utils.cpp ===
//***************************************************************************
//
//  UTILS.CPP
//
//  Module: WMI Instance provider sample code
//
//  Purpose: General purpose utilities.  
//
//  Copyright (c) 1997-2001 Microsoft Corporation
//
//***************************************************************************

#include <objbase.h>
#include <mtxdm.h>
#include <txdtc.h>
#include <xolehlp.h>
#include "sample.h"


//***************************************************************************
//
// CreateInst
//
// Purpose: Creates a new instance and sets
//          the inital values of the properties.
//
// Return:   S_OK if all is well, otherwise an error code is returned
//
//***************************************************************************

SCODE CreateInst(IWbemServices * pNamespace, LPWSTR pKey, long lVal, 
                                        IWbemClassObject ** pNewInst,
                                        WCHAR * pwcClassName,
										IWbemContext  *pCtx)
{   
    SCODE sc;
    IWbemClassObject * pClass;
    sc = pNamespace->GetObject(pwcClassName, 0, pCtx, &pClass, NULL);
    if(sc != S_OK)
        return WBEM_E_FAILED;
    sc = pClass->SpawnInstance(0, pNewInst);
    pClass->Release();
    if(FAILED(sc))
        return sc;
    VARIANT v;

    // Set the key property value.

    v.vt = VT_BSTR;
    v.bstrVal = SysAllocString(pKey);
    sc = (*pNewInst)->Put(L"MyKey", 0, &v, 0);
    VariantClear(&v);

    // Set the number property value.

    v.vt = VT_I4;
    v.lVal = lVal;
    sc = (*pNewInst)->Put(L"MyValue", 0, &v, 0);
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\transact\instprov\sinks.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include <windows.h>
#include <objbase.h>
#include <process.h>
#include <stdio.h>
#include <mtxdm.h>
#include <txdtc.h>
#include <xolehlp.h>
#include "instprov.h"
#include "sinks.h"

STDMETHODIMP CResourceManagerSink::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;

    if(IID_IUnknown==riid || riid== IID_IWbemProviderInit)
       *ppv=(IWbemProviderInit*)this;
    

    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;
  
}


STDMETHODIMP_(ULONG) CResourceManagerSink::AddRef(void)
{
    InterlockedIncrement((long *)&m_cRef);
	return m_cRef;
}

STDMETHODIMP_(ULONG) CResourceManagerSink::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

STDMETHODIMP_(LONG) CResourceManagerSink::TMDown(void)
{
    return 0;
}

CTransactionResourceAsync::CTransactionResourceAsync() 
: m_cRef(0) 
{
}

CTransactionResourceAsync::~CTransactionResourceAsync() 
{ 
	if (m_pTransactionEnlistmentAsync) 
		m_pTransactionEnlistmentAsync->Release(); 
}

STDMETHODIMP CTransactionResourceAsync::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;

    if(IID_IUnknown==riid || riid== IID_ITransactionResourceAsync)
       *ppv=this;
    

    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;
  
}


STDMETHODIMP_(ULONG) CTransactionResourceAsync::AddRef(void)
{
    InterlockedIncrement((long *)&m_cRef);
	return m_cRef;
}

STDMETHODIMP_(ULONG) CTransactionResourceAsync::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

STDMETHODIMP CTransactionResourceAsync::PrepareRequest (BOOL fRetaining,DWORD grfRM,BOOL fWantMoniker,BOOL fSinglePhase)
{
	m_pTransactionEnlistmentAsync->PrepareRequestDone(S_OK, NULL, NULL);
	return NO_ERROR;
}

STDMETHODIMP CTransactionResourceAsync::CommitRequest (DWORD grfRM, XACTUOW * pNewUOW)
{
	m_pTransactionEnlistmentAsync->CommitRequestDone(NO_ERROR);
	return NO_ERROR;
}

STDMETHODIMP CTransactionResourceAsync::AbortRequest (BOID *pboidReason,BOOL fRetaining,XACTUOW * pNewUOW)
{
	m_pTransactionEnlistmentAsync->AbortRequestDone(NO_ERROR);
	return NO_ERROR;
}


STDMETHODIMP CTransactionResourceAsync::TMDown(void)
{
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\transact\instprov\instprov.cpp ===
//***************************************************************************
//
//  INSTPRO.CPP
//
//  Module: WMI Instance provider sample code
//
//  Purpose: Defines the CInstPro class.  An object of this class is
//           created by the class factory for each connection.
//
//  Copyright (c) 1997-2001 Microsoft Corporation
//
//***************************************************************************

#include <windows.h>
#include <objbase.h>
#include <process.h>
#include <stdio.h>
#include <mtxdm.h>
#include <txdtc.h>
#include <xolehlp.h>
#include "instprov.h"
#include "sinks.h"



InstDef MyDefs[] = {{L"a", 1}, {L"b", 2}, {L"c", 3}};

long glNumInst = sizeof(MyDefs)/sizeof(InstDef);

//***************************************************************************
//
// CInstPro::CInstPro
// CInstPro::~CInstPro
//
//***************************************************************************

CInstPro::CInstPro(BSTR ObjectPath, BSTR User, BSTR Password, IWbemContext * pCtx)
{
    m_pNamespace = NULL;
    m_cRef=0;
    InterlockedIncrement(&g_cObj);
    return;
}

CInstPro::~CInstPro(void)
{
	m_pResourceManagerSink->Release();
	m_pTransactionResourceAsync->Release();
	m_pResourceManager->Release();

    if(m_pNamespace)
        m_pNamespace->Release();
    InterlockedDecrement(&g_cObj);
    return;
}

//***************************************************************************
//
// CInstPro::QueryInterface
// CInstPro::AddRef
// CInstPro::Release
//
// Purpose: IUnknown members for CInstPro object.
//***************************************************************************


STDMETHODIMP CInstPro::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;

    // Since we have dual inheritance, it is necessary to cast the return type

    if(riid== IID_IWbemServices)
       *ppv=(IWbemServices*)this;

    if(IID_IUnknown==riid || riid== IID_IWbemProviderInit)
       *ppv=(IWbemProviderInit*)this;
    

    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;
  
}


STDMETHODIMP_(ULONG) CInstPro::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CInstPro::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

/***********************************************************************
*                                                                      *
*   CInstPro::Initialize                                                *
*                                                                      *
*   Purpose: This is the implementation of IWbemProviderInit. The method  *
*   is need to initialize with CIMOM.                                    *
*                                                                      *
***********************************************************************/

STDMETHODIMP CInstPro::Initialize(LPWSTR pszUser, LONG lFlags,
                                    LPWSTR pszNamespace, LPWSTR pszLocale,
                                    IWbemServices *pNamespace, 
                                    IWbemContext *pCtx,
                                    IWbemProviderInitSink *pInitSink)
{
    if(pNamespace)
        pNamespace->AddRef();
    m_pNamespace = pNamespace;

	BSTR bstrContextName = SysAllocString(L"__TRANSACTION_INTERFACE");
	VARIANT varContextValue;
	HRESULT hres = pCtx->GetValue(bstrContextName, 0, &varContextValue);
	SysFreeString(bstrContextName);
	if (FAILED(hres))
	{
		printf("Failed to get transaction cookie!\n");
	}
	else if (V_VT(&varContextValue) != (VT_UNKNOWN))
	{
		printf("transaction cookie is of the wrong type!\n");
		VariantClear(&varContextValue);
	}
	else
	{
		//Extract the ITransaction pointer from the 
		IUnknown *pTransactionUnknown= V_UNKNOWN(&varContextValue);
		ITransaction *pTransaction = 0;
		hres = pTransactionUnknown->QueryInterface(IID_ITransaction, (void**)&pTransaction);
		if (FAILED(hres))
		{	
			printf("Failed to get the ITransaction from cookie, hRes = 0x%x\n", hres);
			return WBEM_E_FAILED;
		}

		VariantClear(&varContextValue);


		//We are part of a transaction, so we need to talk to the DTC and tell it we 
		//are interested in transactions!

		IUnknown *pUnknown = 0;
		hres = DtcGetTransactionManager(0, 0, IID_IUnknown, 0, 0, 0, (void**)&pUnknown);
		if (FAILED(hres))
		{	
			printf("Failed to get the IUnknown from the DTC, hRes = 0x%x\n", hres);
			return WBEM_E_FAILED;
		}

		IResourceManagerFactory *pResourceManagerFactory = NULL;
		hres = pUnknown->QueryInterface(IID_IResourceManagerFactory, (void**)&pResourceManagerFactory);
		if (FAILED(hres))
		{
			printf("Failed to get the IResourceManagerFactory from the DTC, hRes = 0x%x\n", hres);
			return WBEM_E_FAILED;
		}

		//we need to create and register our ResourceManagerSink...
		m_pResourceManagerSink = new CResourceManagerSink;
		hres = pResourceManagerFactory->Create((GUID*)&IID_IWbemProviderInit, "Sample Transacted Instance Provider", m_pResourceManagerSink, &m_pResourceManager);
		if (FAILED(hres))
		{
			printf("Failed to create resource manager, hRes = 0x%x\n", hres);
			return WBEM_E_FAILED;
		}

		if (FAILED(hres))
		{
			printf("Failed to  get the ITransaction pointer, hRes = 0x%x\n", hres);
			return WBEM_E_FAILED;
		}


		m_pTransactionResourceAsync = new CTransactionResourceAsync;
		LONG lIsolationLevel = 0;
		ITransactionEnlistmentAsync *pTransactionEnlistmentAsync = NULL;
		BOID boidTransaction;
		hres = m_pResourceManager->Enlist(pTransaction, m_pTransactionResourceAsync, &boidTransaction, &lIsolationLevel, &pTransactionEnlistmentAsync);
		if (FAILED(hres))
		{
			printf("Failed to enlist in the transaction, hRes = 0x%x\n", hres);
			return WBEM_E_FAILED;
		}

		m_pTransactionResourceAsync->SetTransactionEnlistmentAync(pTransactionEnlistmentAsync);

		pTransactionEnlistmentAsync->Release();

		pResourceManagerFactory->Release();

		pUnknown->Release();

	}

   //Let CIMOM know you are initialized
    //==================================
    
    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
// CInstPro::CreateInstanceEnumAsync
//
// Purpose: Asynchronously enumerates the instances.  
//
//***************************************************************************

SCODE CInstPro::CreateInstanceEnumAsync( const BSTR RefStr, long lFlags, IWbemContext *pCtx,
       IWbemObjectSink FAR* pHandler)
{
    SCODE sc;
    int iCnt;
    IWbemClassObject FAR* pNewInst;
  
    // Do a check of arguments and make sure we have pointer to Namespace

    if(pHandler == NULL || m_pNamespace == NULL)
        return WBEM_E_INVALID_PARAMETER;

    for(iCnt=0; iCnt < glNumInst; iCnt++)
    {
        sc = CreateInst(m_pNamespace,MyDefs[iCnt].pwcKey,
                    MyDefs[iCnt].lValue, &pNewInst, RefStr, pCtx);
 
        if(sc != S_OK)
            break;

        // Send the object to the caller

        pHandler->Indicate(1,&pNewInst);
        pNewInst->Release();
    }

    // Set status

    pHandler->SetStatus(0,sc,NULL, NULL);

    return sc;
}


//***************************************************************************
//
// CInstPro::GetObjectByPath
// CInstPro::GetObjectByPathAsync
//
// Purpose: Creates an instance given a particular path value.
//
//***************************************************************************



SCODE CInstPro::GetObjectAsync(const BSTR ObjectPath, long lFlags,IWbemContext  *pCtx,
                    IWbemObjectSink FAR* pHandler)
{

    SCODE sc;
    IWbemClassObject FAR* pObj;
    BOOL bOK = FALSE;

    // Do a check of arguments and make sure we have pointer to Namespace

    if(ObjectPath == NULL || pHandler == NULL || m_pNamespace == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // do the get, pass the object on to the notify
    
    sc = GetByPath(ObjectPath,&pObj, pCtx);
    if(sc == S_OK) 
    {
        pHandler->Indicate(1,&pObj);
        pObj->Release();
        bOK = TRUE;
    }

    sc = (bOK) ? S_OK : WBEM_E_NOT_FOUND;

    // Set Status

    pHandler->SetStatus(0,sc, NULL, NULL);

    return sc;
}
 
//***************************************************************************
//
// CInstPro::GetByPath
//
// Purpose: Creates an instance given a particular Path value.
//
//***************************************************************************

SCODE CInstPro::GetByPath(BSTR ObjectPath, IWbemClassObject FAR* FAR* ppObj, IWbemContext  *pCtx)
{
    SCODE sc = S_OK;
    
    int iCnt;

    // do a simple path parse.  The path will look something like
    // InstProvSamp.MyKey="a"
    // Create a test string with just the part between quotes.

    WCHAR wcTest[MAX_PATH+1];
    wcscpy(wcTest,ObjectPath);
    WCHAR * pwcTest, * pwcCompare = NULL;
    int iNumQuotes = 0;
    for(pwcTest = wcTest; *pwcTest; pwcTest++)
        if(*pwcTest == L'\"')
        {
            iNumQuotes++;
            if(iNumQuotes == 1)
            {
                pwcCompare = pwcTest+1;
            }
            else if(iNumQuotes == 2)
            {
                *pwcTest = NULL;
                break;
            }
        }
        else if(*pwcTest == L'.')
            *pwcTest = NULL;    // issolate the class name.
    if(iNumQuotes != 2)
        return WBEM_E_FAILED;

    // check the instance list for a match.

    for(iCnt = 0; iCnt < glNumInst; iCnt++)
    {
        if(!_wcsicmp(MyDefs[iCnt].pwcKey, pwcCompare))
        {
            sc = CreateInst(m_pNamespace,MyDefs[iCnt].pwcKey,
                    MyDefs[iCnt].lValue, ppObj, wcTest, pCtx);
            return sc;
        }
    }

    return WBEM_E_NOT_FOUND;
}
 

HRESULT CInstPro::OpenNamespace( 
    /* [in] */ const BSTR Namespace,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) 
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CInstPro::CancelAsyncCall( 
    /* [in] */ IWbemObjectSink __RPC_FAR *pSink) 
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CInstPro::QueryObjectSink( 
    /* [in] */ long lFlags,
    /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) 
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CInstPro::GetObject( 
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CInstPro::PutClass( 
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CInstPro::PutClassAsync( 
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CInstPro::DeleteClass( 
    /* [in] */ const BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CInstPro::DeleteClassAsync( 
    /* [in] */ const BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CInstPro::CreateClassEnum( 
    /* [in] */ const BSTR Superclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CInstPro::CreateClassEnumAsync( 
    /* [in] */ const BSTR Superclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CInstPro::PutInstance( 
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CInstPro::PutInstanceAsync( 
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CInstPro::DeleteInstance( 
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CInstPro::DeleteInstanceAsync( 
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CInstPro::CreateInstanceEnum( 
    /* [in] */ const BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
{
	  return WBEM_E_NOT_SUPPORTED;
}


HRESULT CInstPro::ExecQuery( 
    /* [in] */ const BSTR QueryLanguage,
    /* [in] */ const BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CInstPro::ExecQueryAsync( 
    /* [in] */ const BSTR QueryLanguage,
    /* [in] */ const BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CInstPro::ExecNotificationQuery( 
    /* [in] */ const BSTR QueryLanguage,
    /* [in] */ const BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CInstPro::ExecNotificationQueryAsync( 
    /* [in] */ const BSTR QueryLanguage,
    /* [in] */ const BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CInstPro::ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
    IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) 
{
	return WBEM_E_NOT_SUPPORTED;
}

HRESULT CInstPro::ExecMethodAsync( const BSTR, const BSTR, long, 
    IWbemContext*, IWbemClassObject*, IWbemObjectSink*) 
{
	return WBEM_E_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\transact\instprov\instprov.h ===
//***************************************************************************
//
//  sample.h
//
//  Module: WMI Instance provider sample code
//
//  Purpose: Genral purpose include file.
//
//  Copyright (c) 1997-2001 Microsoft Corporation
//
//***************************************************************************

#ifndef _sample_H_
#define _sample_H_

#include <wbemprov.h>

typedef LPVOID * PPVOID;
class CResourceManagerSink;
class CTransactionResourceAsync;

// Provider interfaces are provided by objects of this class
 
class CInstPro : public IWbemServices, public IWbemProviderInit
    {
    protected:
        ULONG					   m_cRef;
        IWbemServices			  *m_pNamespace;
		CResourceManagerSink	  *m_pResourceManagerSink;
		CTransactionResourceAsync *m_pTransactionResourceAsync;
		IResourceManager		  *m_pResourceManager;

     public:
        CInstPro(BSTR ObjectPath = NULL, BSTR User = NULL, BSTR Password = NULL, IWbemContext * pCtx=NULL);
        ~CInstPro(void);

        //Non-delegating object IUnknown

        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

                //IWbemProviderInit

        HRESULT STDMETHODCALLTYPE Initialize(
             /* [in] */ LPWSTR pszUser,
             /* [in] */ LONG lFlags,
             /* [in] */ LPWSTR pszNamespace,
             /* [in] */ LPWSTR pszLocale,
             /* [in] */ IWbemServices *pNamespace,
             /* [in] */ IWbemContext *pCtx,
             /* [in] */ IWbemProviderInitSink *pInitSink
                        );

        SCODE GetByPath( BSTR Path, IWbemClassObject FAR* FAR* pObj, IWbemContext  *pCtx);

        //IWbemServices  

		  HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) ;
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) ;
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
            IWbemClassObject*, IWbemClassObject**, IWbemCallResult**);

        HRESULT STDMETHODCALLTYPE ExecMethodAsync( const BSTR, const BSTR, long, 
            IWbemContext*, IWbemClassObject*, IWbemObjectSink*);

};

typedef CInstPro *PCInstPro;

// This class is the class factory for CInstPro objects.

class CProvFactory : public IClassFactory
    {
    protected:
        ULONG           m_cRef;

    public:
        CProvFactory(void);
        ~CProvFactory(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID
                                 , PPVOID);
        STDMETHODIMP         LockServer(BOOL);
    };

typedef CProvFactory *PCProvFactory;



// These variables keep track of when the module can be unloaded

extern long       g_cObj;
extern long       g_cLock;

// General purpose utilities.  

             
SCODE CreateInst( IWbemServices * pNamespace, LPWSTR pKey, long lVal, 
                                             IWbemClassObject ** pNewInst,
                                             WCHAR * pwcClassName,
											 IWbemContext  *pCtx); 

typedef struct {
   WCHAR * pwcKey;
   long lValue;
   } InstDef;

extern InstDef MyDefs[];
extern long glNumInst;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\transact\instprov\maindll.cpp ===
//***************************************************************************
//
//  MAINDLL.CPP
// 
//  Module: WMI Instance provider sample code
//
//  Purpose: Contains DLL entry points.  Also has code that controls
//           when the DLL can be unloaded by tracking the number of
//           objects and locks as well as routines that support
//           self registration.
//
//  Copyright (c) 1997-2001 Microsoft Corporation
//
//***************************************************************************

#include <objbase.h>
#include <initguid.h>
#include <mtxdm.h>
#include <txdtc.h>
#include <xolehlp.h>
#include "sample.h"

HMODULE ghModule;

// TODO, GuidGen should be used to generate a unique number for any 
// providers that are going to be used for anything more extensive 
// than just testing.

DEFINE_GUID(CLSID_instprovider,0x22cb8761, 0x914a, 0x11cf, 0xb7, 0x5, 0x0, 0xaa, 0x0, 0x62, 0xcb, 0xb7);
// {22CB8761-914A-11cf-B705-00AA0062CBB7}

//Count number of objects and number of locks.

long       g_cObj=0;
long       g_cLock=0;

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.
//
// Return: TRUE if OK.
//
//***************************************************************************


BOOL WINAPI DllMain(HINSTANCE hInstance, ULONG ulReason
    , LPVOID pvReserved)
{
    if (DLL_PROCESS_ATTACH==ulReason)
        ghModule = hInstance;
    return TRUE;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PVOID *ppv)
{
    HRESULT hr;
    CProvFactory *pObj;

    if (CLSID_instprovider!=rclsid)
        return E_FAIL;

    pObj=new CProvFactory();

    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    sc=(0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;
    return sc;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    char       szID[128];
    WCHAR      wcID[128];
    char       szCLSID[128];
    char       szModule[MAX_PATH];
    char * pName = "WMI Sample Instance Provider";
    char * pModel = "Both";
    HKEY hKey1, hKey2;

    // Create the path.

    StringFromGUID2(CLSID_instprovider, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("Software\\classes\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, lstrlen(pName)+1);
    RegCreateKey(hKey1,"InprocServer32",&hKey2);

    GetModuleFileName(ghModule, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        lstrlen(szModule)+1);
    RegSetValueEx(hKey2, "ThreadingModel", 0, REG_SZ, 
                                        (BYTE *)pModel, lstrlen(pModel)+1);
    RegCloseKey(hKey1);
    RegCloseKey(hKey2);
    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    char       szID[128];
    WCHAR      wcID[128];
    char  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

    StringFromGUID2(CLSID_instprovider, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("Software\\classes\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, "InProcServer32");
        RegCloseKey(hKey);
    }

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, "Software\\classes\\CLSID", &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        RegCloseKey(hKey);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\coretest\umitest\umitest.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

// OBJINTERNALSTESTDlg.cpp : implementation file
//

//#define _WIN32_WINNT 0x0400

#include "precomp.h"
//#include <objbase.h>
#include <stdio.h>
#include <fastall.h>
#include <wbemcli.h>
#include <wbemint.h>

#define	CLASS_PROPERTY_NAME	L"__CLASS"
#define TEST_PROPERTY1_NAME	L"PROPERTY1"
#define TEST_PROPERTY2_NAME	L"PROPERTY2"
#define TEST_PROPERTY3_NAME	L"PROPERTY3"

#define	CLASS_PROPERTY_VALUE	L"TESTCLASSNAME"
#define TEST_PROPERTY1_VALUE	L"TESTPROPERTYVALUE1"
#define TEST_PROPERTY2_VALUE	L"TESTPROPERTYVALUE2"
#define TEST_PROPERTY3_VALUE	L"TESTPROPERTYVALUE3"


HRESULT TestWmiQualifierDWORDArray( _IWmiObject* pObj )
{
	HRESULT	hrTest = WBEM_S_NO_ERROR;

	long	alTest[13] = {0,1,2,3,4,5,6,7,8,9,10,11,12};

	hrTest = pObj->SetObjQual( L"DWORDArrayQual", 0L, 13 * sizeof(long), 13, CIM_UINT32 | CIM_FLAG_ARRAY,
							0L, alTest );

	if ( SUCCEEDED( hrTest ) )
	{
		OutputDebugString( "Putting DWORD Array Qualifier Succeeded!\n" );

		_IWmiArray*	pArray = NULL;
		ULONG uUsed = 0;

		hrTest = pObj->GetObjQual( L"DWORDArrayQual", 0L, sizeof(pArray), NULL, NULL, &uUsed, &pArray );

		DWORD	dwNumElements = 0;
		DWORD	dwTest = 0;
		DWORD	dwData = 0;
		DWORD	dwNumReturned = 0;
		DWORD	uBuffUsed = 0;

		if ( SUCCEEDED( hrTest ) )
		{
			OutputDebugString( "Getting DWORD Array Qualifier Succeeded!\n" );

			ULONG	uFlags = NULL;

			for ( ULONG x = 0; SUCCEEDED(hrTest) && x < 13; x++ )
			{
				hrTest = pArray->GetAt( 0L, x, 1, sizeof(DWORD), &dwNumReturned, &uBuffUsed, &dwData );
			}

			if ( SUCCEEDED( hrTest ) )
			{
				OutputDebugString( "Getting Array Property Element Succeeded!\n" );

				DWORD	dwTestProp = 666;
				hrTest = pArray->SetAt( 0L, 7, 1, sizeof(dwTestProp), &dwTestProp );

				if ( SUCCEEDED( hrTest ) )
				{
					hrTest = pArray->GetAt( 0L, 7, 1, sizeof(DWORD), &dwNumReturned, &uBuffUsed, &dwData );

					if ( SUCCEEDED( hrTest ) )
					{
						if ( dwTestProp != dwData )
						{
							DebugBreak();
						}
					}
					else
					{
						DebugBreak();
					}
				}
				else
				{
					DebugBreak();
				}
			}

			if ( SUCCEEDED( hrTest ) )
			{
				OutputDebugString( "Testing Appending an array of DWORD elements\n" );

				DWORD	adwValues[10];

				for ( DWORD x = 33; x < 43; x++ )
				{
					adwValues[x-33] = x;
				}

				hrTest = pArray->Append( 0L, 10, sizeof(DWORD) * 10, adwValues );

				if ( SUCCEEDED( hrTest ) )
				{
					// Get an element and see if it's what we expect
					hrTest = pArray->GetAt( 0L, 15, 1, sizeof(DWORD), &dwNumReturned, &uBuffUsed, &dwData );

					if ( SUCCEEDED( hrTest ) )
					{
						if ( adwValues[2] != dwData )
						{
							DebugBreak();
						}

						OutputDebugString( "Testing Removing a range of DWORD elements\n" );

						// Remove a range from the middle of the array, and then get an element and
						// see if we have a match
						hrTest = pArray->RemoveAt( 0L, 15, 3 );

						if ( SUCCEEDED( hrTest ) )
						{
							hrTest = pArray->GetAt( 0L, 15, 1, sizeof(DWORD), &dwNumReturned, &uBuffUsed, &dwData );

							if ( adwValues[5] != dwData )
							{
								DebugBreak();
							}

						}
						else
						{
							DebugBreak();
						}
					}
					else
					{
						DebugBreak();
					}

				}
				else
				{
					DebugBreak();
				}

			}

			pArray->Release();

		}


	}

	return hrTest;
}

HRESULT TestWmiObjectDWORDArray( _IWmiObject* pObj )
{
	HRESULT	hrTest = WBEM_S_NO_ERROR;

	long	alTest[13] = {0,1,2,3,4,5,6,7,8,9,10,11,12};

	hrTest = pObj->WriteProp( L"ArrayProp", 0L, 13 * sizeof(long), 13, CIM_UINT32 | CIM_FLAG_ARRAY,
							alTest );

	if ( SUCCEEDED( hrTest ) )
	{
		OutputDebugString( "Putting Array Property Succeeded!\n" );

		long	lHandle = 0L;

		hrTest = pObj->GetPropertyHandleEx( L"ArrayProp", 0L, NULL, &lHandle );

		DWORD	dwNumElements = 0;
		DWORD	dwTest = 0;
		LPVOID	pvData = NULL;

		if ( SUCCEEDED( hrTest ) )
		{
			OutputDebugString( "Getting Array Property Handle Succeeded!\n" );

			// Now initialize the array

			hrTest = pObj->GetArrayPropAddrByHandle( lHandle, 0L, &dwNumElements, &pvData );

			if ( WBEM_S_NO_ERROR == hrTest )
			{
				dwTest = *(UNALIGNED DWORD*)pvData;
				OutputDebugString( "Getting Array Property Address Succeeded!\n" );
			}
		}

		if ( SUCCEEDED( hrTest ) )
		{
			ULONG	uFlags = NULL;


			for ( ULONG x = 0; SUCCEEDED(hrTest) && x < dwNumElements; x++ )
			{
				hrTest = pObj->GetArrayPropElementByHandle( lHandle, 0L, x, &uFlags, &dwNumElements, &pvData );
			}

			if ( SUCCEEDED( hrTest ) )
			{
				OutputDebugString( "Getting Array Property Element Succeeded!\n" );

				DWORD	dwTestProp = 666;
				hrTest = pObj->SetArrayPropElementByHandle( lHandle, 0L, 7, sizeof(dwTestProp), &dwTestProp );

				if ( SUCCEEDED( hrTest ) )
				{
					hrTest = pObj->GetArrayPropElementByHandle( lHandle, 0L, 7, &uFlags, &dwNumElements, &pvData );

					if ( SUCCEEDED( hrTest ) )
					{
						if ( dwTestProp != *(UNALIGNED DWORD*) pvData )
						{
							DebugBreak();
						}
					}
					else
					{
						DebugBreak();
					}
				}
			}

			if ( SUCCEEDED( hrTest ) )
			{
				OutputDebugString( "Testing Appending an array of DWORD elements\n" );

				DWORD	adwValues[10];

				for ( DWORD x = 33; x < 43; x++ )
				{
					adwValues[x-33] = x;
				}

				hrTest = pObj->AppendArrayPropRangeByHandle( lHandle, 0L, 10, sizeof(DWORD) * 10, adwValues );

				if ( SUCCEEDED( hrTest ) )
				{
					// Get an element and see if it's what we expect
					hrTest = pObj->GetArrayPropElementByHandle( lHandle, 0L, 15, &uFlags, &dwNumElements, &pvData );

					if ( SUCCEEDED( hrTest ) )
					{
						if ( adwValues[2] != *((UNALIGNED DWORD*) pvData ))
						{
							DebugBreak();
						}

						OutputDebugString( "Testing Removing a range of DWORD elements\n" );

						// Remove a range from the middle of the array, and then get an element and
						// see if we have a match
						hrTest = pObj->RemoveArrayPropRangeByHandle( lHandle, 0L, 15, 3 );

						if ( SUCCEEDED( hrTest ) )
						{
							pObj->GetArrayPropElementByHandle( lHandle, 0L, 15, &uFlags, &dwNumElements, &pvData );

							if ( adwValues[5] != *((UNALIGNED DWORD*) pvData ))
							{
								DebugBreak();
							}

						}
						else
						{
							DebugBreak();
						}
					}
					else
					{
						DebugBreak();
					}

				}
				else
				{
					DebugBreak();
				}

			}


		}

	}

	return hrTest;
}

HRESULT TestWmiQualifierStringArray( _IWmiObject* pObj )
{
	HRESULT	hrTest = WBEM_S_NO_ERROR;

	WCHAR	wcsTest[512];
	WCHAR*	pTemp = wcsTest;
	ULONG	uBuffLen =0;

	// Create a linear array
	for ( long x = 10; SUCCEEDED(hrTest) && x < 23; x++ )
	{
		WCHAR	wcsValue[32];

		swprintf( wcsValue, L"TestString%d", x );
		wcscpy( pTemp, wcsValue );

		uBuffLen += ( ( wcslen( pTemp ) + 1 ) * 2 );
		pTemp += (wcslen( pTemp ) + 1);
	}

	hrTest = pObj->SetObjQual( L"StringArrayQual", 0L, uBuffLen, 13, CIM_STRING | CIM_FLAG_ARRAY,
							0L, wcsTest );

	if ( SUCCEEDED( hrTest ) )
	{
		OutputDebugString( "Putting String Array Qualifier Succeeded!\n" );

		_IWmiArray*	pArray = NULL;
		ULONG uUsed = 0;

		hrTest = pObj->GetObjQual( L"StringArrayQual", 0L, sizeof(pArray), NULL, NULL, &uUsed, &pArray );

		DWORD	dwNumElements = 0;
		DWORD	dwTest = 0;
		DWORD	dwData = 0;
		DWORD	dwNumReturned = 0;
		DWORD	uBuffUsed = 0;

		if ( SUCCEEDED( hrTest ) )
		{
			OutputDebugString( "Getting String Array Qualifier Succeeded!\n" );

			WCHAR	wcsData[512];
			ULONG	uFlags = NULL;

			for ( ULONG x = 0; SUCCEEDED(hrTest) && x < 13; x++ )
			{
				hrTest = pArray->GetAt( 0L, x, 1, sizeof(wcsData), &dwNumReturned, &uBuffUsed, wcsData );
			}

			if ( SUCCEEDED( hrTest ) )
			{
				OutputDebugString( "Getting Array Property Element Succeeded!\n" );

				char	szAsciiValue[256];
				WCHAR	wszNewValue[256];

				wcscpy( wszNewValue, L"01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789");

				// Testing Set/Get Element
				hrTest = pArray->SetAt( 0L, 7, 1, (wcslen(wszNewValue)+1)*2, wszNewValue );

				if ( SUCCEEDED( hrTest ) )
				{
					hrTest = pArray->GetAt( 0L, 7, 1, sizeof(wcsData), &dwNumReturned, &uBuffUsed, wcsData );

					if ( SUCCEEDED( hrTest ) )
					{
						if ( wcscmp( wszNewValue, wcsData ) != 0 )
						{
							DebugBreak();
						}
					}
					else
					{
						DebugBreak();
					}

				}
				else
				{
					DebugBreak();
				}

			}

			if ( SUCCEEDED( hrTest ) )
			{
				OutputDebugString( "Testing Appending an array of String elements\n" );

				LPWSTR	pwcsTemp = new WCHAR[128];
				char	szVal[128];

				wcscpy( pwcsTemp, L"9876543210" );
				wcscpy( pwcsTemp + 11, L"abcdefghijklmnopqrstuvwxyz" );

				hrTest = pArray->Append( 0L, 2, 76, pwcsTemp );

				if ( SUCCEEDED( hrTest ) )
				{
					// Get an element and see if it's what we expect
					hrTest = pArray->GetAt( 0L, 14, 1, sizeof(wcsData), &dwNumReturned, &uBuffUsed, wcsData );

					if ( SUCCEEDED( hrTest ) )
					{
						if ( wcscmp( wcsData, pwcsTemp + 11 ) != 0 )
						{
							DebugBreak();
						}

						OutputDebugString( "Testing Removing a range of String elements\n" );

						// Remove a range from the middle of the array, and then get an element and
						// see if we have a match
						hrTest = pArray->RemoveAt( 0L, 7, 3 );

						if ( SUCCEEDED( hrTest ) )
						{
							hrTest = pArray->GetAt( 0L, 7, 1, sizeof(wcsData), &dwNumReturned, &uBuffUsed, wcsData );

							if ( wcscmp( L"TestString20", wcsData ) )
							{
								DebugBreak();
							}

						}
						else
						{
							DebugBreak();
						}
					}
					else
					{
						DebugBreak();
					}

				}
				else
				{
					DebugBreak();
				}

			}

			pArray->Release();

		}


	}

	return hrTest;
}

HRESULT TestWmiObjectStringArray( _IWmiObject* pTestObj )
{
	HRESULT	hrTest = WBEM_S_NO_ERROR;

	_IWmiObjectAccessEx*	pObj = NULL;

	pTestObj->QueryInterface( IID__IWmiObjectAccessEx, (void**) &pObj );

	WCHAR	wcsTest[512];
	WCHAR*	pTemp = wcsTest;
	ULONG	uBuffLen =0;

	// Create a linear array
	for ( long x = 10; SUCCEEDED(hrTest) && x < 23; x++ )
	{
		WCHAR	wcsValue[32];

		swprintf( wcsValue, L"TestString%d", x );
		wcscpy( pTemp, wcsValue );

		uBuffLen += ( ( wcslen( pTemp ) + 1 ) * 2 );
		pTemp += (wcslen( pTemp ) + 1);
	}

	hrTest = pObj->WriteProp( L"ArrayProp", 0L, uBuffLen, 13, CIM_STRING | CIM_FLAG_ARRAY, wcsTest );

	if ( SUCCEEDED( hrTest ) )
	{
		OutputDebugString( "Putting Array Property Succeeded!\n" );

		long	lHandle = 0L;

		hrTest = pObj->GetPropertyHandleEx( L"ArrayProp", 0L, NULL, &lHandle );

		DWORD	dwNumElements = 0;
		DWORD	dwTest = 0;
		LPVOID	pvData = NULL;

		if ( SUCCEEDED( hrTest ) )
		{
			OutputDebugString( "Getting Array Property Handle Succeeded!\n" );

			hrTest = pObj->GetArrayPropAddrByHandle( lHandle, 0L, &dwNumElements, &pvData );

			// This should fail!
			if ( SUCCEEDED( hrTest ) )
			{
				OutputDebugString( "Getting Array Property Address Succeeded!\n" );
				DebugBreak();
			}
			else
			{
				OutputDebugString( "Getting String Array Property Address Failed!\n" );
				hrTest = WBEM_S_NO_ERROR;
			}
		}

		if ( SUCCEEDED( hrTest ) )
		{
			ULONG	uFlags = NULL;

			for ( ULONG x = 0; SUCCEEDED(hrTest) && x < 13; x++ )
			{
				hrTest = pObj->GetArrayPropElementByHandle( lHandle, 0L, x, &uFlags, &dwNumElements, &pvData );
			}

			if ( SUCCEEDED( hrTest ) )
			{
				OutputDebugString( "Getting Array Property Element Succeeded!\n" );

				char	szAsciiValue[256];
				WCHAR	wszNewValue[256];

				wcscpy( wszNewValue, L"01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789");
				strcpy( szAsciiValue, "01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789");

				// Testing Set/Get Element
				hrTest = pObj->SetArrayPropElementByHandle( lHandle, 0L, 7, (wcslen(wszNewValue)+1)*2, wszNewValue );

				if ( SUCCEEDED( hrTest ) )
				{
					hrTest = pObj->GetArrayPropElementByHandle( lHandle, 0L, 7, &uFlags, &dwNumElements, &pvData );

					if ( SUCCEEDED( hrTest ) )
					{
						if ( strcmp( szAsciiValue, (LPSTR) pvData ) != 0 )
						{
							DebugBreak();
						}
					}
					else
					{
						DebugBreak();
					}

				}
				else
				{
					DebugBreak();
				}


			}

			// Now we'll try appending a couple of strings
			if ( SUCCEEDED( hrTest ) )
			{
				OutputDebugString( "Testing Appending an array of String elements\n" );

				LPWSTR	pwcsTemp = new WCHAR[128];
				char	szVal[128];

				wcscpy( pwcsTemp, L"9876543210" );
				wcscpy( pwcsTemp + 11, L"abcdefghijklmnopqrstuvwxyz" );
				strcpy( szVal, "abcdefghijklmnopqrstuvwxyz" );


				hrTest = ((CWbemObject*) pObj)->AppendArrayPropRangeByHandle( lHandle, 0L, 2, 76, pwcsTemp );

				if ( SUCCEEDED( hrTest ) )
				{
					// Get an element and see if it's what we expect
					hrTest = pObj->GetArrayPropElementByHandle( lHandle, 0L, 14, &uFlags, &dwNumElements, &pvData );

					if ( SUCCEEDED( hrTest ) )
					{
						if ( strcmp( szVal, (LPSTR) pvData ) != 0 )
						{
							DebugBreak();
						}

						OutputDebugString( "Testing Removing a range of string elements\n" );

						// Remove a range from the middle of the array, and then get an element and
						// see if we have a match
						hrTest = ((CWbemObject*) pObj)->RemoveArrayPropRangeByHandle( lHandle, 0L, 7, 3 );

						if ( SUCCEEDED( hrTest ) )
						{
							pObj->GetArrayPropElementByHandle( lHandle, 0L, 7, &uFlags, &dwNumElements, &pvData );

							if ( strcmp( "TestString20", (LPSTR) pvData ) != 0 )
							{
								DebugBreak();
							}

						}
						else
						{
							DebugBreak();
						}
					}
					else
					{
						DebugBreak();
					}

				}
				else
				{
					DebugBreak();
				}

			}

		}

	}

	pObj->Release();

	return hrTest;
}

HRESULT TestWmiObjectQualifiers( _IWmiObject* pObj )
{
	HRESULT	hrTest = WBEM_S_NO_ERROR;

	WCHAR	wcsTest[512];
	WCHAR*	pTemp = wcsTest;
	ULONG	uBuffLen =0;

	DWORD	dwTest = 3000;

	wcscpy( wcsTest, L"Test String of verify importanmt caliber." );

	DWORD	dwTemp;
	WCHAR	wcsTemp[512];


	HRESULT hr = pObj->SetObjQual( L"DWORDQual", 0L, sizeof(DWORD), 1, CIM_UINT32,
							0L, &dwTest );

	if ( SUCCEEDED( hr ) )
	{
		OutputDebugString( "Set DWORD Object Qualifier!\n" );
		hr = pObj->SetObjQual( L"StringQual", 0L, ( ( wcslen( wcsTest ) + 1 ) * 2 ), 1, CIM_STRING,
								0L, wcsTest );
		
		if ( SUCCEEDED( hr ) )
		{
			OutputDebugString( "Set String Object Qualifier!\n" );

			ULONG uUsed = 0;

			hrTest = pObj->GetObjQual( L"DWORDQual", 0L, sizeof(DWORD), NULL, NULL, &uUsed, &dwTemp );

			if ( SUCCEEDED( hrTest ) )
			{
				OutputDebugString( "Got DWORD object qualifier\n" );
				if ( dwTest != dwTemp )
				{
					DebugBreak();
				}
				
				hrTest = pObj->GetObjQual( L"StringQual", 0L, sizeof(wcsTemp), NULL, NULL, &uUsed, wcsTemp );
				if ( SUCCEEDED( hrTest ) )
				{
					OutputDebugString( "Got String object qualifier\n" );
					if ( wcscmp( wcsTemp, wcsTest ) == 0 )
					{
						DebugBreak();
					}
				}
				else
				{
					DebugBreak();
				}

				OutputDebugString( "Got DWORD object qualifier\n" );

			}
			else
			{
				DebugBreak();
			}

		}
		else
		{
			DebugBreak();
		}
	}
	else
	{
		DebugBreak();
	}

	return hr;
}

HRESULT TestWmiPropertyQualifiers( _IWmiObject* pObj )
{
	HRESULT	hrTest = WBEM_S_NO_ERROR;

	hrTest = pObj->WriteProp( L"TestQualProp", 0L, 0, 13, CIM_UINT32,
							NULL );

	WCHAR	wcsTest[512];
	WCHAR*	pTemp = wcsTest;
	ULONG	uBuffLen =0;

	DWORD	dwTest = 3000;

	wcscpy( wcsTest, L"Test String of verify importanmt caliber." );

	DWORD	dwTemp;
	WCHAR	wcsTemp[512];


	HRESULT hr = pObj->SetPropQual( L"TestQualProp", L"DWORDQual", 0L, sizeof(DWORD), 1, CIM_UINT32,
							0L, &dwTest );

	if ( SUCCEEDED( hr ) )
	{
		OutputDebugString( "Set DWORD Property Qualifier!\n" );
		hr = pObj->SetPropQual( L"TestQualProp", L"StringQual", 0L, ( ( wcslen( wcsTest ) + 1 ) * 2 ), 1, CIM_STRING,
								0L, wcsTest );
		
		if ( SUCCEEDED( hr ) )
		{
			OutputDebugString( "Set String Property Qualifier!\n" );

			ULONG uUsed = 0;

			hrTest = pObj->GetPropQual( L"TestQualProp", L"DWORDQual", 0L, sizeof(DWORD), NULL, NULL, &uUsed, &dwTemp );

			if ( SUCCEEDED( hrTest ) )
			{
				OutputDebugString( "Got DWORD Property qualifier\n" );
				if ( dwTest != dwTemp )
				{
					DebugBreak();
				}
				
				hrTest = pObj->GetPropQual( L"TestQualProp", L"StringQual", 0L, sizeof(wcsTemp), NULL, NULL, &uUsed, wcsTemp );
				if ( SUCCEEDED( hrTest ) )
				{
					OutputDebugString( "Got String Property qualifier\n" );
					if ( wcscmp( wcsTemp, wcsTest ) == 0 )
					{
						DebugBreak();
					}
				}
				else
				{
					DebugBreak();
				}

				OutputDebugString( "Got DWORD object qualifier\n" );

			}
			else
			{
				DebugBreak();
			}

		}
		else
		{
			DebugBreak();
		}
	}
	else
	{
		DebugBreak();
	}

	return hr;
}

HRESULT TestWmiPropertyDWORDQualifiers( _IWmiObject* pObj )
{
	HRESULT	hrTest = WBEM_S_NO_ERROR;

	long	alTest[13] = {0,1,2,3,4,5,6,7,8,9,10,11,12};

	hrTest = pObj->SetPropQual( L"TestQualProp", L"DWORDArrayQual", 0L, 13 * sizeof(long), 13, CIM_UINT32 | CIM_FLAG_ARRAY,
							0L, alTest );

	if ( SUCCEEDED( hrTest ) )
	{
		OutputDebugString( "Putting DWORD Array Property Qualifier Succeeded!\n" );

		_IWmiArray*	pArray = NULL;
		ULONG uUsed = 0;

		hrTest = pObj->GetPropQual( L"TestQualProp", L"DWORDArrayQual", 0L, sizeof(pArray), NULL, NULL, &uUsed, &pArray );

		DWORD	dwNumElements = 0;
		DWORD	dwTest = 0;
		DWORD	dwData = 0;
		DWORD	dwNumReturned = 0;
		DWORD	uBuffUsed = 0;

		if ( SUCCEEDED( hrTest ) )
		{
			OutputDebugString( "Getting DWORD Array Property Qualifier Succeeded!\n" );

			ULONG	uFlags = NULL;

			for ( ULONG x = 0; SUCCEEDED(hrTest) && x < 13; x++ )
			{
				hrTest = pArray->GetAt( 0L, x, 1, sizeof(DWORD), &dwNumReturned, &uBuffUsed, &dwData );
			}

			if ( SUCCEEDED( hrTest ) )
			{
				OutputDebugString( "Getting Array Property Element Succeeded!\n" );

				DWORD	dwTestProp = 666;
				hrTest = pArray->SetAt( 0L, 7, 1, sizeof(dwTestProp), &dwTestProp );

				if ( SUCCEEDED( hrTest ) )
				{
					hrTest = pArray->GetAt( 0L, 7, 1, sizeof(DWORD), &dwNumReturned, &uBuffUsed, &dwData );

					if ( SUCCEEDED( hrTest ) )
					{
						if ( dwTestProp != dwData )
						{
							DebugBreak();
						}
					}
					else
					{
						DebugBreak();
					}
				}
				else
				{
					DebugBreak();
				}
			}

			if ( SUCCEEDED( hrTest ) )
			{
				OutputDebugString( "Testing Appending an array of DWORD elements\n" );

				DWORD	adwValues[10];

				for ( DWORD x = 33; x < 43; x++ )
				{
					adwValues[x-33] = x;
				}

				hrTest = pArray->Append( 0L, 10, sizeof(DWORD) * 10, adwValues );

				if ( SUCCEEDED( hrTest ) )
				{
					// Get an element and see if it's what we expect
					hrTest = pArray->GetAt( 0L, 15, 1, sizeof(DWORD), &dwNumReturned, &uBuffUsed, &dwData );

					if ( SUCCEEDED( hrTest ) )
					{
						if ( adwValues[2] != dwData )
						{
							DebugBreak();
						}

						OutputDebugString( "Testing Removing a range of DWORD elements\n" );

						// Remove a range from the middle of the array, and then get an element and
						// see if we have a match
						hrTest = pArray->RemoveAt( 0L, 15, 3 );

						if ( SUCCEEDED( hrTest ) )
						{
							hrTest = pArray->GetAt( 0L, 15, 1, sizeof(DWORD), &dwNumReturned, &uBuffUsed, &dwData );

							if ( adwValues[5] != dwData )
							{
								DebugBreak();
							}

						}
						else
						{
							DebugBreak();
						}
					}
					else
					{
						DebugBreak();
					}

				}
				else
				{
					DebugBreak();
				}

			}

			pArray->Release();

		}


	}

	return hrTest;
}

HRESULT TestWmiPropertyQualifierStringArray( _IWmiObject* pObj )
{
	HRESULT	hrTest = WBEM_S_NO_ERROR;

	WCHAR	wcsTest[512];
	WCHAR*	pTemp = wcsTest;
	ULONG	uBuffLen =0;

	// Create a linear array
	for ( long x = 10; SUCCEEDED(hrTest) && x < 23; x++ )
	{
		WCHAR	wcsValue[32];

		swprintf( wcsValue, L"TestString%d", x );
		wcscpy( pTemp, wcsValue );

		uBuffLen += ( ( wcslen( pTemp ) + 1 ) * 2 );
		pTemp += (wcslen( pTemp ) + 1);
	}

	hrTest = pObj->SetPropQual( L"TestQualProp", L"StringArrayQual", 0L, uBuffLen, 13, CIM_STRING | CIM_FLAG_ARRAY,
							0L, wcsTest );

	if ( SUCCEEDED( hrTest ) )
	{
		OutputDebugString( "Putting String Array Property Qualifier Succeeded!\n" );

		_IWmiArray*	pArray = NULL;
		ULONG uUsed = 0;

		hrTest = pObj->GetPropQual( L"TestQualProp", L"StringArrayQual", 0L, sizeof(pArray), NULL, NULL, &uUsed, &pArray );

		DWORD	dwNumElements = 0;
		DWORD	dwTest = 0;
		DWORD	dwData = 0;
		DWORD	dwNumReturned = 0;
		DWORD	uBuffUsed = 0;

		if ( SUCCEEDED( hrTest ) )
		{
			OutputDebugString( "Getting String Array Property Qualifier Succeeded!\n" );

			WCHAR	wcsData[512];
			ULONG	uFlags = NULL;

			for ( ULONG x = 0; SUCCEEDED(hrTest) && x < 13; x++ )
			{
				hrTest = pArray->GetAt( 0L, x, 1, sizeof(wcsData), &dwNumReturned, &uBuffUsed, wcsData );
			}

			if ( SUCCEEDED( hrTest ) )
			{
				OutputDebugString( "Getting Array Property Element Succeeded!\n" );

				char	szAsciiValue[256];
				WCHAR	wszNewValue[256];

				wcscpy( wszNewValue, L"01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789");

				// Testing Set/Get Element
				hrTest = pArray->SetAt( 0L, 7, 1, (wcslen(wszNewValue)+1)*2, wszNewValue );

				if ( SUCCEEDED( hrTest ) )
				{
					hrTest = pArray->GetAt( 0L, 7, 1, sizeof(wcsData), &dwNumReturned, &uBuffUsed, wcsData );

					if ( SUCCEEDED( hrTest ) )
					{
						if ( wcscmp( wszNewValue, wcsData ) != 0 )
						{
							DebugBreak();
						}
					}
					else
					{
						DebugBreak();
					}

				}
				else
				{
					DebugBreak();
				}

			}

			if ( SUCCEEDED( hrTest ) )
			{
				OutputDebugString( "Testing Appending an array of String elements\n" );

				LPWSTR	pwcsTemp = new WCHAR[128];
				char	szVal[128];

				wcscpy( pwcsTemp, L"9876543210" );
				wcscpy( pwcsTemp + 11, L"abcdefghijklmnopqrstuvwxyz" );

				hrTest = pArray->Append( 0L, 2, 76, pwcsTemp );

				if ( SUCCEEDED( hrTest ) )
				{
					// Get an element and see if it's what we expect
					hrTest = pArray->GetAt( 0L, 14, 1, sizeof(wcsData), &dwNumReturned, &uBuffUsed, wcsData );

					if ( SUCCEEDED( hrTest ) )
					{
						if ( wcscmp( wcsData, pwcsTemp + 11 ) != 0 )
						{
							DebugBreak();
						}

						OutputDebugString( "Testing Removing a range of String elements\n" );

						// Remove a range from the middle of the array, and then get an element and
						// see if we have a match
						hrTest = pArray->RemoveAt( 0L, 7, 3 );

						if ( SUCCEEDED( hrTest ) )
						{
							hrTest = pArray->GetAt( 0L, 7, 1, sizeof(wcsData), &dwNumReturned, &uBuffUsed, wcsData );

							if ( wcscmp( L"TestString20", wcsData ) )
							{
								DebugBreak();
							}

						}
						else
						{
							DebugBreak();
						}
					}
					else
					{
						DebugBreak();
					}

				}
				else
				{
					DebugBreak();
				}

			}

			pArray->Release();

		}


	}

	return hrTest;
}

// Tests the free form object code
HRESULT CreateFreeFormObject( IUmiPropList** pObj )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	_IWmiObjectFactory*	pFactory = NULL;

	hr = CoCreateInstance( CLSID__WmiObjectFactory, NULL, CLSCTX_INPROC_SERVER, IID__IWmiObjectFactory, (void**) &pFactory );

	if ( SUCCEEDED( hr ) )
	{
		_IWmiFreeFormObject*	pFFObject = NULL;

		hr = pFactory->Create( NULL, 0L, CLSID__WmiFreeFormObject, IID__IWmiFreeFormObject, (void**) &pFFObject );

		if ( SUCCEEDED( hr ) )
		{
			WCHAR	wszHierarchy[128];
			WCHAR*	pwszHierarchy = wszHierarchy;
			DWORD	dwVal = 4;
			WCHAR*	pszTestString = L"A very important string.";
			BYTE	bData = 1;

			wcscpy( pwszHierarchy, L"ClassA" );
			wcscpy( &pwszHierarchy[7], L"ClassB" );

			_IWmiObject*	pWmiObject = NULL;

			hr = pFFObject->QueryInterface( IID__IWmiObject, (void**) &pWmiObject );

			hr = pFFObject->AddProperty( L"TestPropA", WMIOBJECT_FREEFORM_FLAG_WRITE_TO_INSTANCE, sizeof(DWORD), 0L, CIM_UINT32, &dwVal );

			hr = pFFObject->AddProperty( L"TestPropB", WMIOBJECT_FREEFORM_FLAG_WRITE_TO_INSTANCE, ( wcslen(pszTestString) + 1 ) * 2, 0L, CIM_STRING, pszTestString );

			hr = pFFObject->SetDerivation( 0L, 2, wszHierarchy );

			hr = pFFObject->SetClassName( 0L, L"ClassC" );

			hr = pFFObject->MakeInstance( 0L );

			if ( SUCCEEDED( hr ) )
			{
				hr = pFFObject->QueryInterface( IID_IUmiPropList, (void**) pObj );
			}

			pWmiObject->Release();

			pFFObject->Release();
		}

		pFactory->Release();
	}

	return hr;
}

// Tests the free form object code
HRESULT TestUmiWrapper( IUmiPropList* pObj )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	_IWmiObjectFactory*	pFactory = NULL;

	hr = CoCreateInstance( CLSID__WmiObjectFactory, NULL, CLSCTX_INPROC_SERVER, IID__IWmiObjectFactory, (void**) &pFactory );

	if ( SUCCEEDED( hr ) )
	{
		_IWbemUMIObjectWrapper*	pObjWrapper = NULL;

		hr = pFactory->Create( NULL, 0L, CLSID__WbemUMIObjectWrapper, IID__IWbemUMIObjectWrapper, (void**) &pObjWrapper );

		if ( SUCCEEDED( hr ) )
		{
			hr = pObjWrapper->SetObject( 0L, pObj );
			pObjWrapper->Release();
		}

		pFactory->Release();
	}

	return hr;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	main
//
//	Entry point function to exercise _IWmiObject interface.
//
///////////////////////////////////////////////////////////////////

void __cdecl main( void )
{
	CoInitializeEx( 0, COINIT_MULTITHREADED );

	// Create a new Wbem class object
	IUmiPropList*	pUmiPropList = NULL;

	printf( "Creating FreeForm Object.\n" );

	HRESULT hr = CreateFreeFormObject( &pUmiPropList );

	if ( SUCCEEDED( hr ) )
	{
		hr = TestUmiWrapper( pUmiPropList );

		UMI_PROPERTY_VALUES*	pPropertyValues = NULL;
		LPCWSTR					apszProps[2] = { L"TestPropA", L"TestPropB" };

		hr = pUmiPropList->GetProps( apszProps, 2L, 0L, &pPropertyValues );

		if ( SUCCEEDED( hr ) )
		{

			pPropertyValues->uCount = 2;
			pPropertyValues->pPropArray[0].uOperationType = UMI_OPERATION_UPDATE;
			pPropertyValues->pPropArray[1].uOperationType = UMI_OPERATION_UPDATE;


			UMI_PROPERTY_VALUES*	pCoercedPropertyValues = NULL;
			hr = pUmiPropList->PutProps( apszProps, 2L, 0L, pPropertyValues );

			hr = pUmiPropList->GetAs( apszProps[0], 0L, UMI_TYPE_R8, &pCoercedPropertyValues );

			pUmiPropList->FreeMemory( 0L, pPropertyValues );
			pUmiPropList->FreeMemory( 0L, pCoercedPropertyValues );
		}

		pUmiPropList->Release();
	}

	CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\dbgsignal\signal.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include <windows.h>
#include <stdio.h>
#include <string.h>

class CWinMgmtDebugSignal
{
public:
    enum { H_ENABLE_LEAK_TRACKING = 0,
           H_DISABLE_LEAK_TRACKING = 1,
           H_RESET_LEAK_TRACKING = 2,
           H_DUMP_LEAK_TRACKING = 3,
           H_FAIL_ALLOCATOR = 4,
           H_RESTORE_ALLOCATOR = 5,
           H_FAIL_NEXT_ALLOC = 6,
           H_ENABLE_EXCEPTION_TRACKING = 7,
           H_DISABLE_EXCEPTION_TRACKING = 8,
           H_DEBUG_BREAK = 9,
           H_ENABLE_OBJECT_VALIDATION = 10,
           H_DISABLE_OBJECT_VALIDATION = 11,
           H_LAST
         };

    static void Init();
    static HANDLE m_hArray[H_LAST];
};

HANDLE CWinMgmtDebugSignal::m_hArray[H_LAST] = {0};

void CWinMgmtDebugSignal::Init()
{
    // Set up the IPC signals.
    // =======================
    m_hArray[H_ENABLE_LEAK_TRACKING] =
        OpenEventW(EVENT_ALL_ACCESS, FALSE, L"EVENT_WINMGMT_ENABLE_LEAK_TRACKING");

    m_hArray[H_DISABLE_LEAK_TRACKING] =
        OpenEventW(EVENT_ALL_ACCESS, FALSE,  L"EVENT_WINMGMT_DISABLE_LEAK_TRACKING");

    m_hArray[H_RESET_LEAK_TRACKING] =
        OpenEventW(EVENT_ALL_ACCESS, FALSE,  L"EVENT_WINMGMT_RESET_LEAK_TRACKING");

    m_hArray[H_DUMP_LEAK_TRACKING] =
        OpenEventW(EVENT_ALL_ACCESS, FALSE,  L"EVENT_WINMGMT_DUMP_LEAK_TRACKING");

    m_hArray[H_FAIL_ALLOCATOR] =
        OpenEventW(EVENT_ALL_ACCESS, FALSE,  L"EVENT_WINMGMT_FAIL_ALLOCATOR");
    m_hArray[H_RESTORE_ALLOCATOR] =
        OpenEventW(EVENT_ALL_ACCESS, FALSE,  L"EVENT_WINMGMT_RESTORE_ALLOCATOR");
    m_hArray[H_FAIL_NEXT_ALLOC] =
        OpenEventW(EVENT_ALL_ACCESS, FALSE,  L"EVENT_WINMGMT_FAIL_NEXT_ALLOCATION");

    m_hArray[H_ENABLE_EXCEPTION_TRACKING] =
        OpenEventW(EVENT_ALL_ACCESS, FALSE,  L"EVENT_WINMGMT_ENABLE_EXCEPTION_TRACKING");
    m_hArray[H_DISABLE_EXCEPTION_TRACKING] =
        OpenEventW(EVENT_ALL_ACCESS, FALSE,  L"EVENT_WINMGMT_DISABLE_EXCEPTION_TRACKING");

    m_hArray[H_DEBUG_BREAK] =
        OpenEventW(EVENT_ALL_ACCESS, FALSE,  L"EVENT_WINMGMT_DEBUG_BREAK");

    m_hArray[H_ENABLE_OBJECT_VALIDATION] =
        OpenEventW(EVENT_ALL_ACCESS, FALSE,  L"EVENT_WINMGMT_ENABLE_OBJECT_VALIDATION");

    m_hArray[H_DISABLE_OBJECT_VALIDATION] =
        OpenEventW(EVENT_ALL_ACCESS, FALSE,  L"EVENT_WINMGMT_DISABLE_OBJECT_VALIDATION");

}



void main(int argc, char **argv)
{
    CWinMgmtDebugSignal::Init();

    if (argc < 2)
    {
        printf(
            "\n\n* WinMgmt Debug Event Signaller  [%s]\n\n"
            "Usage:\n"
            "   /ENABLE_LEAK_TRACKING\n"
            "   /DISABLE_LEAK_TRACKING\n"
            "   /RESET_LEAK_TRACKING\n"
            "   /DUMP_LEAK_TRACKING\n"
            "   /FAIL_ALLOCATOR\n"
            "   /RESTORE_ALLOCATOR\n"
            "   /FAIL_NEXT_ALLOC\n"
            "   /ENABLE_EXCEPTION_TRACKING\n"
            "   /DISABLE_EXCEPTION_TRACKING\n"
            "   /DEBUG_BREAK\n"
            "   /ENABLE_OBJECT_VALIDATION\n"
            "   /DISABLE_OBJECT_VALIDATION\n"
            "\n\n",
            __DATE__
            );
            return;
    }


    if (_stricmp(argv[1], "/ENABLE_LEAK_TRACKING") == 0)
    {
        SetEvent(CWinMgmtDebugSignal::m_hArray[CWinMgmtDebugSignal::H_ENABLE_LEAK_TRACKING]);
        printf("-> Enable Leak Tracking\n");
    }

    if (_stricmp(argv[1], "/DISABLE_LEAK_TRACKING") == 0)
    {
        SetEvent(CWinMgmtDebugSignal::m_hArray[CWinMgmtDebugSignal::H_DISABLE_LEAK_TRACKING]);
        printf("-> Disable Leak Tracking\n");
    }
    if (_stricmp(argv[1], "/RESET_LEAK_TRACKING") == 0)
    {
        SetEvent(CWinMgmtDebugSignal::m_hArray[CWinMgmtDebugSignal::H_RESET_LEAK_TRACKING]);
        printf("-> Reset Leak Tracking\n");
    }
    if (_stricmp(argv[1], "/DUMP_LEAK_TRACKING") == 0)
    {
        SetEvent(CWinMgmtDebugSignal::m_hArray[CWinMgmtDebugSignal::H_DUMP_LEAK_TRACKING]);
        printf("-> Dump Leak Tracking\n");
    }
    if (_stricmp(argv[1], "/FAIL_ALLOCATOR") == 0)
    {
        SetEvent(CWinMgmtDebugSignal::m_hArray[CWinMgmtDebugSignal::H_FAIL_ALLOCATOR]);
        printf("-> Fail Allocator\n");
    }
    if (_stricmp(argv[1], "/RESTORE_ALLOCATOR") == 0)
    {
        SetEvent(CWinMgmtDebugSignal::m_hArray[CWinMgmtDebugSignal::H_RESTORE_ALLOCATOR]);
        printf("-> Restore Allocator\n");
    }
    if (_stricmp(argv[1], "/FAIL_NEXT_ALLOC") == 0)
    {
        SetEvent(CWinMgmtDebugSignal::m_hArray[CWinMgmtDebugSignal::H_FAIL_NEXT_ALLOC]);
        printf("-> Fail Next Allocation\n");
    }
    if (_stricmp(argv[1], "/ENABLE_EXCEPTION_TRACKING") == 0)
    {
        SetEvent(CWinMgmtDebugSignal::m_hArray[CWinMgmtDebugSignal::H_ENABLE_EXCEPTION_TRACKING]);
        printf("-> Enable Exception Tracking\n");
    }
    if (_stricmp(argv[1], "/DISABLE_EXCEPTION_TRACKING") == 0)
    {
        SetEvent(CWinMgmtDebugSignal::m_hArray[CWinMgmtDebugSignal::H_DISABLE_EXCEPTION_TRACKING]);
        printf("-> Disable Exception Tracking\n");
    }

    if (_stricmp(argv[1], "/DEBUG_BREAK") == 0)
    {
        SetEvent(CWinMgmtDebugSignal::m_hArray[CWinMgmtDebugSignal::H_DEBUG_BREAK]);
        printf("-> Debug Break\n");
    }

    if (_stricmp(argv[1], "/ENABLE_OBJECT_VALIDATION") == 0)
    {
        SetEvent(CWinMgmtDebugSignal::m_hArray[CWinMgmtDebugSignal::H_ENABLE_OBJECT_VALIDATION]);
        printf("-> Enable Object Validation\n");
    }

    if (_stricmp(argv[1], "/DISABLE_OBJECT_VALIDATION") == 0)
    {
        SetEvent(CWinMgmtDebugSignal::m_hArray[CWinMgmtDebugSignal::H_DISABLE_OBJECT_VALIDATION]);
        printf("-> Disable Object Validation\n");
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\egg\unegg.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include <windows.h>	   
#include <stdio.h>

DWORD g_aData[] = 
{
	787298196, 389638077, 
	341926582, 774741813, 
	93260522, 163092950, 
	1990849060, 347345683, 
	877836976, 1572821297, 
	648067937, 2085921890, 
	185524536, 456812682, 
	0, 757935405, 
	0, 757935405, 
	0, 757935405, 
	0, 757935405, 
	137293882, 647272253, 
	926837903, 691288938, 
	2110722223, 753493867, 
	1158850856, 231595791, 
	891966499, 1864871608, 
	369617977, 1136871300, 
	1171009120, 869085779, 
	1450103344, 1086868440, 
	1961959123, 1059058093, 
	1935842809, 802291789, 
	67991817, 981707677, 
	1259917513, 326492489, 
	1576246720, 1771986875, 
	0, 757935405, 
	0, 757935405, 
	0, 757935405, 
	0, 757935405, 
	923580586, 196610576, 
	422396857, 1268611680, 
	612189215, 1446180055, 
	273627650, 1037431929, 
	1582243822, 530725520, 
	802440210, 1390869936, 
	1406698670, 882125910, 
	1438991232, 560627627, 
	519127596, 452431388, 
	247297193, 1875650637, 
	1095739709, 1333936659, 
	488415888, 58615958, 
	2113012991, 1738890481, 
	1232434023, 576968899, 
	408785170, 2004132969, 
	1072488881, 1949997283, 
	686278613, 103342821, 
	1802391228, 1692614641, 
	1467267833, 20439818, 
	1881687054, 139215331, 
	883980780, 1810507476, 
	328677840, 457133755, 
	142591755, 1983286802, 
	1996404059, 1271126329, 
	1134573462, 762500247, 
	1814903789, 840278466, 
	1546035302, 748041854, 
	1627769996, 1594286475, 
	485134963, 1356626587, 
	985018630, 725840743, 
	894740359, 1781303086, 
	191459340, 113223348, 
	1637410797, 99004090, 
	1314737521, 1672532217, 
	1668536725, 1304979453, 
	1000359187, 88572926, 
	940387879, 86954543, 
	581549221, 1279191550, 
	582252523, 1728435494, 
	1684935272, 658131775, 
	120729547, 480600746, 
	1434799119, 1826855997, 
	132314003, 890416705, 
	1550628941, 1593392703, 
	212468432, 1977475751, 
	145875476, 1283143786, 
	339648658, 1258446305, 
	1259855840, 1196087906, 
	74939557, 525823171, 
	282953689, 879773678, 
	702241042, 1008129545, 
	529353019, 143169584, 
	0, 543978849, 
	0, 1701604417, 
	371789987, 422923611, 
	1151970391, 221238405, 
	1680390471, 894991504, 
	1173777616, 157967432, 
	1766201693, 1082091029, 
	961250332, 418310210, 
	2064488210, 1090270119, 
	2001088245, 1778413437, 
	791205667, 120892331, 
	425237262, 1210731199, 
	905501056, 1963224902, 
	1495907077, 1762779656, 
	1793196122, 900671011, 
	565554614, 877067351, 
	1684925417, 1390111021, 
	1324408981, 1523119716, 
	1985677317, 1014717431, 
	2058211074, 325132225, 
	1158869461, 1242277359, 
	940757120, 1456714425, 
	1912286107, 1599660744, 
	1030658283, 1328068605, 
	1672026279, 818606002, 
	1811916152, 731129312, 
	62148729, 371093903, 
	300023322, 1713323730, 
	1016690981, 453549345, 
	1591860349, 929856991, 
	1154873655, 1234446286, 
	1969529918, 889192916, 
	506902349, 1583269362, 
	596405421, 29222317, 
	1957020972, 428224461, 
	705503535, 1900946280, 
	1636949272, 753322603, 
	1574175218, 74107011, 
	620920752, 2000334733, 
	286975576, 1272973499, 
	832394219, 1049983536, 
	719744492, 863138508, 
	152013962, 961843672, 
	92216887, 220011621, 
	2005324671, 676471875, 
	801005260, 2107228857, 
	1417629424, 1535412939, 
	927485975, 971812307, 
	440891913, 2031435089, 
	2075684028, 1235594918, 
	15075279, 255504492, 
	1292850514, 1653838496, 
	1575207405, 771884304, 
	762297916, 113481758, 
	1344439445, 1543107246, 
	852400584, 1804221292, 
	1525438309, 110908311, 
	86765426, 771128997, 
	697445823, 961217353, 
	21213263, 1351154252, 
	10599418, 1651444261, 
	35441527, 1052114448, 
	1590203695, 1004220318, 
	526682473, 905611632, 
	1769355382, 1506382359, 
	44165446, 222203003, 
	1796395753, 236997150, 
	1183262379, 1958681932, 
	874728503, 1225185820, 
	570241278, 732193933, 
	858685714, 2074455587, 
	1560512242, 570149966, 
	951907138, 1616617795, 
	1487056392, 1358244054, 
	970286561, 92310071, 
	756933636, 1110268445, 
	1440979143, 1265100897, 
	2084942205, 818510862, 
	1320638918, 823264617, 
	1971233622, 1847199921, 
	95431188, 242470127, 
	856458457, 897727972, 
	329752498, 468812383, 
	144227962, 769935106, 
	144227962, 769935106, 
	144227962, 769935106, 
	144227962, 769935106, 
	534716163, 1761870124, 
	1020475911, 15843303, 
	144227962, 769935106, 
	144227962, 769935106, 
	144227962, 769935106, 
	144227962, 769935106, 
	1067808548, 208610277, 
	211579674, 1653240566, 
	239108456, 885154717, 
	21370838, 1331889325, 
	981841190, 31603421, 
	776487910, 155411510, 
	2071731226, 122456632, 
	124476971, 416326125, 
	763251302, 178690314, 
	1119537894, 126896069, 
	806112306, 1933102105, 
	364993844, 1805041121, 
	1424534966, 727711589, 
	2077763860, 274369686, 
	2093089868, 1733803912, 
	84954222, 1079628647, 
	264022324, 2037751576, 
	1024375655, 434843389, 
	1902071860, 2111102903, 
	695270825, 1907355848, 
	1911415748, 1337430371, 
	971966920, 1236686408, 
	2033536277, 945241688, 
	1505165919, 920928449, 
	1140463463, 867695560, 
	425854658, 1224833536, 
	1898028372, 1356457614, 
	1790370482, 816827286, 
	451463270, 1522918624, 
	1281670814, 931443332, 
	405066436, 2107792490, 
	261570442, 204422508, 
	1182010752, 1359667668, 
	520647196, 199392831, 
	1232260743, 1016215239, 
	1066977689, 1846685821, 
	1393055485, 1149327626, 
	728869925, 1227807534, 
	1223562861, 1215769115, 
	1234782934, 1500675318, 
	1670384851, 1546713131, 
	680528633, 517371164, 
	1190806955, 761856969, 
	2145532613, 1742670338, 
	1002949577, 295468350, 
	538754217, 2099052296, 
	1487886738, 1318580638, 
	1540413980, 1248769325, 
	203789634, 144460909, 
	1948818884, 1383042119, 
	1106605766, 249692350, 
	1654887685, 799220325, 
	266335729, 1064242885, 
	935948902, 1729316369, 
	1904596453, 602576498, 
	1393926903, 1868790805, 
	999121367, 1482517664, 
	1106424117, 1619863692, 
	475802887, 1065758854, 
	1578128863, 1073664523, 
	1902406644, 1490177493, 
	189884687, 370196266, 
	2067425084, 1295173952, 
	719320527, 1966542348, 
	1402266308, 627647129, 
	321290752, 563241132, 
	1055096585, 1304486941, 
	923108668, 487059104, 
	344621029, 714650744, 
	1350621712, 1393479868, 
	496766707, 337566155, 
	1398161423, 1065556157, 
	1637951588, 1664109644, 
	1897844973, 39233871, 
	738269405, 2096910723, 
	92694589, 236509435, 
	1190806955, 761856969, 
	338757023, 812768206, 
	1849559800, 854377249, 
	1404336425, 1207126318, 
	1662034928, 342925931, 
	658926774, 426922867, 
	1729186771, 1061508106, 
	563502611, 1697133477, 
	840094768, 1210950740, 
	1835414483, 769859538, 
	747821704, 1438378136, 
	2126687472, 278562278, 
	1238007326, 59100431, 
	1897844973, 39233871, 
	450014323, 1915307751, 
	1426814736, 286322278, 
	846462709, 324087749, 
	1264181614, 609866356, 
	537228654, 1155735254, 
	1669911731, 295201152, 
	2051750308, 1634959694, 
	2037895850, 1121635198, 
	1191562139, 871349233, 
	384085527, 1485591712, 
	593489313, 1334053277, 
	1201558042, 1284197474, 
	1267301451, 1295178886, 
	712333739, 1466813771, 
	1382958161, 55608330, 
	1404336425, 1207126318, 
	1420100579, 1516550283, 
	1034307423, 253077413, 
	364993844, 1805041121, 
	2107257906, 1288714714, 
	2127080717, 1122861179, 
	496953976, 480397759, 
	1539886260, 2049877054, 
	1458240017, 1918020923, 
	1736195893, 934320622, 
	270972983, 295012450, 
	1020551866, 2134232563, 
	673302697, 1363075082, 
	329752498, 468812383, 
	144227962, 769935106, 
	144227962, 769935106, 
	144227962, 769935106, 
	144227962, 769935106, 
	1764104557, 547082180, 
	497927576, 24480816, 
	589828949, 1975205479, 
	144227962, 769935106, 
	144227962, 769935106, 
	144227962, 769935106, 
	144227962, 769935106, 
	144227962, 769935106, 
	602187998, 287638516, 
	2008233392, 1060225789, 
	1192430968, 1339353572, 
	1428531475, 1905392579, 
	1670384851, 1546713131, 
	680528633, 517371164, 
	330641664, 1605658617, 
	664197573, 1993238793, 
	329752498, 468812383, 
	144227962, 769935106, 
	144227962, 769935106, 
	144227962, 769935106, 
	144227962, 769935106, 
	337739951, 76463872, 
	1786957427, 416636494, 
	144227962, 769935106, 
	144227962, 769935106, 
	144227962, 769935106, 
	144227962, 769935106, 
	144227962, 769935106, 
	363957482, 713099117, 
	715207258, 1444991911, 
	906492934, 201308803, 
	549588084, 1261979109, 
	1198999088, 295629922, 
	1456701468, 2004408543, 
	1587159928, 1248983505, 
	144227962, 769935106, 
	144227962, 769935106, 
	144227962, 769935106, 
	144227962, 769935106, 
	1067808548, 208610277, 
	156509796, 1042008667, 
	426198684, 1629282820, 
	301389858, 1871183307, 
	593620859, 1798829104, 
	144227962, 769935106, 
	144227962, 769935106, 
	144227962, 769935106, 
	144227962, 769935106, 
	1067808548, 208610277, 
	941907548, 507139560, 
	1042233049, 945161939, 
	807955139, 99055478, 
	999121367, 1482517664, 
	1308773551, 1409554373, 
	1523086598, 413771652, 
	52391019, 1186011222, 
	563372826, 1525327567, 
	2102151822, 1136009315, 
	1574765603, 1457921496, 
	867496441, 1693047572, 
	407929249, 542656253, 
	1795844148, 255267812, 
	1218529061, 1059803448, 
	39529162, 1398686543, 
	490430000, 1686718086, 
	489233830, 1863308304 
};

#define NUM_DATA (sizeof(g_aData)/sizeof(DWORD))
#define LARGE_PRIME 2147483659

DWORD HashKey(char* szKey)
{
	DWORD n = 1;
	while(*szKey)
	{
		n = n * (2*(DWORD)*szKey + 1);
		szKey++;
	}
	return n % LARGE_PRIME;
}

LPSTR GetText(LPSTR szKey)
{
	LPSTR szResult = new char[NUM_DATA*2+4];
	DWORD* pdwResult = (DWORD*)szResult;

	DWORD dwKey = HashKey(szKey);
	for(int i = 0; i < NUM_DATA; i+=2)
	{
		__int64 i64A = g_aData[i];
		__int64 i64B = g_aData[i+1];
		__int64 i64Res = (i64A*dwKey + i64B) % LARGE_PRIME;
		*pdwResult = (DWORD)i64Res;
		pdwResult++;
	}
	*pdwResult = 0;

	return szResult;
}

BOOL CheckText(char* szText)
{
	while(*szText)
	{
        if (*szText < 8 || *szText > 127)
            return FALSE;
		szText++;
	}
	return TRUE;
}


void main()
{
	printf("Key: ");
	char szKey[100];
	scanf("%s", szKey);
	LPSTR szResult = GetText(szKey);
	if(!CheckText(szResult))
		printf("INVALID!\n");
	else
		printf("%s\n", szResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\binding.h ===
//******************************************************************************
//
//  BINDING.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************
#ifndef __WMI_ESS_BINDING__H_
#define __WMI_ESS_BINDING__H_

#include <wbemcomn.h>
#include "evtools.h"
#include "evsink.h"
#include <unload.h>
#include <wbemstr.h>
#include <sortarr.h>
#include <ql.h>
#include "qsink.h"

class CEventConsumer;
class CEventFilter;
class CEssNamespace;

//******************************************************************************
//
//  Immutable after initialization
//
//******************************************************************************

class CBinding : public CEventSink
{
protected:
    long m_lRef;
    CEventConsumer* m_pConsumer; // immutable after init
    CEventFilter* m_pFilter; // immutable after init

    DWORD m_dwQoS; // immutable after init
    bool m_bSecure;  // immutable after init
    bool m_bSlowDown; // immutable after init
    bool m_bDisabledForSecurity; 

public:
    CBinding();
    CBinding(ADDREF CEventConsumer* pConsumer, ADDREF CEventFilter* pFilter);
    virtual ~CBinding();

    HRESULT SetEndpoints(ADDREF CEventConsumer* pConsumer, 
                        ADDREF CEventFilter* pFilter,
                        PSID pBinderSid);
    void DisableForSecurity();
    INTERNAL CEventConsumer* GetConsumer() NOCS {return m_pConsumer;}
    INTERNAL CEventFilter* GetFilter() NOCS {return m_pFilter;}
    DWORD GetQoS() NOCS;
    bool IsSynch() NOCS;
    bool IsSecure() NOCS;
    bool ShouldSlowDown() NOCS;

    HRESULT Indicate( long lNumEvents, IWbemEvent** apEvents, 
                        CEventContext* pContext);
};

class CEventConsumer : public CQueueingEventSink
{
protected:
    CRefedPointerSmallArray<CBinding> m_apBindings;
    CInternalString m_isKey;
    PBYTE m_pOwnerSid;

public:
    
    CEventConsumer(CEssNamespace* pNamespace);

    virtual ~CEventConsumer();

    inline const CInternalString& GetKey() const {return m_isKey;}
    inline const PSID GetOwner() {return m_pOwnerSid;}

    virtual BOOL IsPermanent() const {return FALSE;}
    virtual BOOL UnloadIfUnusedFor(CWbemInterval Interval) {return FALSE;}
    virtual BOOL IsFullyUnloaded() {return TRUE;}
    virtual HRESULT ResetProviderRecord(LPCWSTR wszProviderRef) 
        {return S_FALSE;}
    virtual HRESULT Shutdown(bool bQuiet = false) {return S_OK;}
    virtual HRESULT Validate(IWbemClassObject* pLogicalConsumer) {return S_OK;}

    HRESULT EnsureReferences(CEventFilter* pFilter, CBinding* pBinding);
    HRESULT EnsureNotReferences(CEventFilter* pFilter);
    HRESULT Unbind();

    HRESULT ConsumeFromBinding(CBinding* pBinding, 
                                long lNumEvents, IWbemEvent** apEvents,
                                CEventContext* pContext);
    HRESULT GetAssociatedFilters(
                CRefedPointerSmallArray<CEventFilter>& apFilters);

    virtual HRESULT ActuallyDeliver(long lNumEvents, IWbemEvent** apEvents,
                                    BOOL bSecure, CEventContext* pContext) = 0;
    virtual HRESULT ReportEventDrop(IWbemEvent* pEvent);
};

//*****************************************************************************
//
//  m_cs controls access to data members.  No critical sections may be acquired
//          while holding m_cs.
//
//  m_csChangeBindings controls activation/deactivation requests on this filter.
//      As long as an activation/deactivation request is proceeding, no other
//      such request can get underway.  This ensures that the activation state
//      state of the filter always matches the state of its bindings.  At the
//      same time, the filter can filter events while such a request executes, 
//      since m_cs is not held.  Only m_cs can be acquired while holding
//      m_csActivation
//
//*****************************************************************************

class CEventFilter : public CEventSink, public CUpdateLockable
{
protected:
    CEssNamespace* m_pNamespace; // immutable after init
    CRefedPointerSmallArray<CBinding> m_apBindings; // changes
    CCritSec m_cs;
    // CCritSec m_csChangeBindings; // don't need since the namespace is locked
    bool m_bSingleAsync;
    CInternalString m_isKey;
    PBYTE m_pOwnerSid;
    long m_lSecurityChecksRemaining;
    bool m_bCheckSDs;
    HRESULT m_hresFilterError;
    bool m_bHasBeenValid;
    IWbemToken* m_pToken;
    HRESULT m_hresTokenError;
    DWORD m_dwLastTokenAttempt;
    WString m_wsGuardQuery;
    WString m_wsGuardNamespace;
    bool m_bDeactivatedByGuard;
    bool m_bGuardError;
    bool m_bReconstructOnHit;
    HRESULT m_hresPollingError;

    enum 
    {
        e_Inactive, e_Active
    } m_eState; //changes

    enum
    {
        e_Unknown, e_PermanentlyInvalid, e_TemporarilyInvalid, e_Valid
    } m_eValidity;

    friend class CEventForwardingSink;

    class CEventForwardingSink : public CAbstractEventSink
    {
    protected:
        CEventFilter* m_pOwner;
    
    public:
        CEventForwardingSink(CEventFilter* pOwner) : m_pOwner(pOwner){}

        ULONG STDMETHODCALLTYPE AddRef() {return m_pOwner->AddRef();}
        ULONG STDMETHODCALLTYPE Release() {return m_pOwner->Release();}
        HRESULT Indicate(long lNumEvents, IWbemEvent** apEvents, 
                            CEventContext* pContext);
    } m_ForwardingSink; // immutable

    class CClassChangeSink : public CEmbeddedObjectSink<CEventFilter>
    {
    public:
        CClassChangeSink(CEventFilter* pOwner) : 
            CEmbeddedObjectSink<CEventFilter>(pOwner){}
        STDMETHOD(Indicate)(long lNumEvents, IWbemEvent** apEvents);
    } m_ClassChangeSink; // immutable

    CWbemPtr<IWbemObjectSink> m_pActualClassChangeSink; 

    friend CEventForwardingSink;

    class CFilterGuardingSink : public CObjectSink
    {
    protected:
        CEventFilter* m_pFilter;

    protected:
        bool IsCountZero(_IWmiObject* pObj);

    public:
        CFilterGuardingSink(CEventFilter* m_pFilter);
        virtual ~CFilterGuardingSink();

        STDMETHOD(Indicate)(long lNumObject, IWbemClassObject** apEvents);
    };

    friend CFilterGuardingSink;
    CFilterGuardingSink* m_pGuardingSink;
        

public:
    CEventFilter(CEssNamespace* pEssNamespace);
    virtual ~CEventFilter();

    virtual bool IsInternal() { return false; }

    //**************
    // Acquire CSs
    //**************

    HRESULT EnsureReferences(CEventConsumer* pConsumer, CBinding* pBinding);
    HRESULT EnsureNotReferences(CEventConsumer* pConsumer);
    HRESULT Unbind(bool bShuttingDown = false);
    bool IsBound();

    virtual BOOL DoesNeedType(int nType) const = 0;
    HRESULT Indicate(long lNumEvents, IWbemEvent** apEvents, 
                CEventContext* pContext) = 0;

    virtual HRESULT LockForUpdate();
    virtual HRESULT UnlockForUpdate();

    //*******************
    // Do not acquire CSs
    //*******************

    virtual HRESULT GetCoveringQuery(DELETE_ME LPWSTR& wszQueryLanguage, 
                DELETE_ME LPWSTR& wszQuery, BOOL& bExact,
                DELETE_ME QL_LEVEL_1_RPN_EXPRESSION** ppExp) = 0;
    virtual HRESULT GetEventNamespace(DELETE_ME LPWSTR* pwszNamespace);
    virtual DWORD GetForceFlags() {return 0;}
    virtual bool DoesAllowInvalid() 
        {return ((GetForceFlags() & WBEM_FLAG_STRONG_VALIDATION) == 0);}
    bool HasBeenValid() {return m_bHasBeenValid;}

    inline const CInternalString& GetKey() {return m_isKey;}
    inline const PSID GetOwner() { return m_pOwnerSid; }

    virtual CAbstractEventSink* GetNonFilteringSink() = 0;
    virtual HRESULT GetReady(LPCWSTR wszQuery, 
                            QL_LEVEL_1_RPN_EXPRESSION* pExp) = 0;
    virtual HRESULT GetReadyToFilter() = 0;
    virtual BOOL IsPermanent() = 0;
    virtual HRESULT SetThreadSecurity() = 0;
    virtual HRESULT ObtainToken(IWbemToken** ppToken) = 0;
    virtual void Park(){}
    virtual const PSECURITY_DESCRIPTOR GetEventAccessSD() { return NULL; }
    void MarkAsPermanentlyInvalid(HRESULT hres);
    void MarkAsTemporarilyInvalid(HRESULT hres);
    void MarkAsValid();
    void SetInactive();
    void SetGuardStatus(bool bEnable, bool bError = false);
    void GetGuardStatus(bool *pbEnable, bool *pbError);
    BOOL IsActive();
    HRESULT GetFilterError();
    void MarkReconstructOnHit(bool bReconstruct = true);
    HRESULT SetGuardQuery(LPCWSTR wszQuery, LPCWSTR wszNamespace);
    bool IsGuarded();
    bool IsGuardActive();
    HRESULT ActivateGuard();
    HRESULT DeactivateGuard();

    void SetPollingError(HRESULT hres) {m_hresPollingError = hres;}
    HRESULT GetPollingError() {return m_hresPollingError;}

    void IncrementRemainingSecurityChecks();
    void DecrementRemainingSecurityChecks(HRESULT hresProvider);

    INTERNAL IWbemObjectSink* GetClassChangeSink() {return &m_ClassChangeSink;}
    
    // 
    // this so the caller can wrap the class change sink however they want and
    // store the resultant sink with the filter object.
    //
    HRESULT SetActualClassChangeSink( IWbemObjectSink* pSink, 
                                      IWbemObjectSink** ppOldSink );

    HRESULT Reactivate();

protected:
    HRESULT Deliver(long lNumEvents, IWbemEvent** apEvents,
                    CEventContext* pContext);
    HRESULT AdjustActivation();
    void AdjustSingleAsync();
    BOOL DoesNeedDeactivation();
    HRESULT AccessCheck( CEventContext* pEventContext, IWbemEvent* pEvent );

    HRESULT CheckEventAccessToFilter( IServerSecurity* pProvCtx );
    HRESULT CheckFilterAccessToEvent( PSECURITY_DESCRIPTOR pEventSD );

    friend class CBindingTable;
};



class CConsumerWatchInstruction : public CBasicUnloadInstruction
{
protected:
    class CBindingTableRef* m_pTableRef;
    static CWbemInterval mstatic_Interval;

public:
    CConsumerWatchInstruction(CBindingTable* pTable);
    ~CConsumerWatchInstruction();
    HRESULT Fire(long, CWbemTime);
    static void staticInitialize(IWbemServices* pRoot);
};

//******************************************************************************
//
// This class is a comparer (as required by the sorted array template) that
// compares an object with CInternalString* GetKey() method (e.g. filter or 
// consumer) to another such object or an LPCWSTR
//
//******************************************************************************

template<class TObject>
class CInternalStringComparer
{
public:
    int Compare(TObject* p1, TObject* p2) const
    {
        return p1->GetKey().Compare(p2->GetKey());
    }
    int Compare(const CInternalString& isKey, TObject* p) const
    {
        return - p->GetKey().Compare(isKey);
    }
    int Compare(LPCWSTR wszKey, TObject* p) const
    {
        return - p->GetKey().Compare(wszKey);
    }
    int Compare(const CInternalString& isKey1, 
                const CInternalString& isKey2) const
    {
        return isKey1.Compare(isKey2);
    }
    const CInternalString& Extract(TObject* p) const
    {
        return p->GetKey();
    }
};

template<class TObject>
class CSortedRefedKeyedPointerArray : 
    public CRefedPointerSortedTree<CInternalString, TObject, 
                                    CInternalStringComparer<TObject> >
{
    typedef CRefedPointerSortedTree<CInternalString, TObject, 
                                  CInternalStringComparer<TObject> > TParent;
public:
    inline bool Find(LPCWSTR wszKey, TObject** ppObj)
    {
        CInternalString is(wszKey);
        if (is.IsEmpty())
            return false;
        return TParent::Find(is, ppObj);
    }
    inline bool Remove(LPCWSTR wszKey, TObject** ppObj)
    {
        CInternalString is(wszKey);
        if (is.IsEmpty())
            return false;        
        return TParent::Remove(is, ppObj);
    }
    inline TParent::TIterator Remove(TParent::TIterator it, TObject** ppObj)
    {
        return TParent::Remove(it, ppObj);
    }
};

/*
template<class TObject>
class CSortedRefedKeyedPointerArray : 
    public CRefedPointerSortedArray<LPCWSTR, TObject, 
                                    CInternalStringComparer<TObject> >
{
};
*/
        
class CBindingTableRef
{
protected:
    long m_lRef;
    CBindingTable* m_pTable;
    CCritSec m_cs;


protected:
    virtual ~CBindingTableRef();

public:
    CBindingTableRef(CBindingTable* pTable);
    void AddRef();
    void Release();
    void Disconnect();
    HRESULT UnloadUnusedConsumers(CWbemInterval Interval);
    HRESULT GetNamespace(RELEASE_ME CEssNamespace** ppNamespace);
};

class CBindingTable
{
protected:
    CEssNamespace* m_pNamespace;
    CCritSec m_cs;

    CSortedRefedKeyedPointerArray<CEventFilter> m_apFilters;
    typedef CSortedRefedKeyedPointerArray<CEventFilter>::TIterator 
                TFilterIterator;
    CSortedRefedKeyedPointerArray<CEventConsumer> m_apConsumers;
    typedef CSortedRefedKeyedPointerArray<CEventConsumer>::TIterator 
                TConsumerIterator;

    long m_lNumPermConsumers;
    CConsumerWatchInstruction* m_pInstruction;
    BOOL m_bUnloadInstruction;
    CBindingTableRef* m_pTableRef;
    
public:

    //****************************************************
    // all members should be assumed to acquire random CSs
    //****************************************************

    CBindingTable(CEssNamespace* pNamespace);
    void Clear( bool bSkipClean );
    ~CBindingTable() { Clear(true); }

    HRESULT AddEventFilter(CEventFilter* pFilter);
    HRESULT AddEventConsumer(CEventConsumer* pConsumer);

    HRESULT FindEventFilter(LPCWSTR wszKey, RELEASE_ME CEventFilter** ppFilter);
    HRESULT FindEventConsumer(LPCWSTR wszKey, 
                                        RELEASE_ME CEventConsumer** ppConsumer);

    HRESULT RemoveEventFilter(LPCWSTR wszKey);
    HRESULT RemoveEventConsumer(LPCWSTR wszKey);

    HRESULT Bind(LPCWSTR wszFilterKey, LPCWSTR wszConsumerKey, 
                    CBinding* pBinding, PSID pBinderSid);
    HRESULT Unbind(LPCWSTR wszFilterKey, LPCWSTR wszConsumerKey);
    
    BOOL DoesHavePermanentConsumers();
    HRESULT ListActiveNamespaces(CWStringArray& wsNamespaces);
    HRESULT ResetProviderRecords(LPCWSTR wszProvider);
    HRESULT RemoveConsumerWithFilters(LPCWSTR wszConsumerKey);
    HRESULT ReactivateAllFilters();
    HRESULT RemoveConsumersStartingWith(LPCWSTR wszPrefix);
    
    HRESULT EnsureConsumerWatchInstruction();
    void Park();
    void DumpStatistics(FILE* f, long lFlags);

    BOOL GetEventFilters( CRefedPointerArray< CEventFilter > & apEventFilters );

protected:
    void MarkRemoval(CEventConsumer* pConsumer);

    HRESULT UnloadUnusedConsumers(CWbemInterval Interval);

    BOOL GetConsumers(CRefedPointerArray<CEventConsumer>& apConsumers);
    friend CConsumerWatchInstruction;
    friend CBindingTableRef;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\clscache.cpp ===
//******************************************************************************
//
//  CLSCACHE.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <nsrep.h>

CEssClassCache::~CEssClassCache()
{
    Clear();
}

HRESULT CEssClassCache::GetClass( LPCWSTR wszClassName, 
                                  IWbemContext* pContext,
                                  _IWmiObject** ppClass )
{
    HRESULT hres;

    // Search the map
    // ==============

    {
        CInCritSec ics(&m_cs);
        TIterator it = m_mapClasses.find((LPWSTR)wszClassName);
        if(it != m_mapClasses.end())
        {
            *ppClass = it->second;
            (*ppClass)->AddRef();
            return S_OK;
        }
    }

    // Not found --- retrieve
    // ======================

    _IWmiObject* pClass = NULL;
    hres = m_pNamespace->GetClassFromCore(wszClassName, &pClass);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm2(pClass);

    // Cache it if needed
    // ==================

    {
        CInCritSec ics(&m_cs);
        if(m_mapClasses.find((LPWSTR)wszClassName) == m_mapClasses.end())
        {
            try
            {
                m_mapClasses[wszClassName] = pClass;
                pClass->AddRef();                
            }
            catch(CX_MemoryException &)
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
    }
            
    *ppClass = pClass;
    pClass->AddRef();
    return WBEM_S_NO_ERROR;
}

HRESULT CEssClassCache::Clear()
{
    CInCritSec ics(&m_cs);

    for(TIterator it = m_mapClasses.begin(); it != m_mapClasses.end(); it++)
    {        
        it->second->Release();
    }

    m_mapClasses.clear();
    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\binding.cpp ===
//******************************************************************************
//
//  BINDING.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <pragmas.h>
#include <ess.h>
#include <permbind.h>
#include <cominit.h>
#include <callsec.h>
#include <wmimsg.h>
#include "Quota.h"

#include <tchar.h>

#define MIN_TIMEOUT_BETWEEN_TOKEN_ATTEMPTS 60000

//*****************************************************************************
//
//  Syncronization model:
//
//  1. Bindings themselves are immutable and do not require protection. 
//  2. Releasing a binding (removing from table) can release the other end-point
//      and generally cannot be done in a CS.
//
//*************************** Event Consumer **********************************

long g_lNumConsumers = 0;
long g_lNumBindings = 0;
long g_lNumFilters = 0;

CEventConsumer::CEventConsumer( CEssNamespace* pNamespace )
: CQueueingEventSink(pNamespace), m_pOwnerSid(NULL)
{
    InterlockedIncrement( &g_lNumConsumers );
}

CEventConsumer::~CEventConsumer()
{
    InterlockedDecrement( &g_lNumConsumers );
    delete [] m_pOwnerSid;
}

HRESULT CEventConsumer::EnsureReferences(CEventFilter* pFilter, 
                                            CBinding* pBinding)
{
    CBinding* pOldBinding = NULL;
    {
        CInCritSec ics(&m_cs);
    
        for(int i = 0; i < m_apBindings.GetSize(); i++)
        {
            if(m_apBindings[i]->GetFilter() == pFilter)
            {
                // Replace the binding
                // ===================
    
                m_apBindings.SetAt(i, pBinding, &pOldBinding);
                break;
            }
        }

        if(pOldBinding == NULL)
        {
            // Add it to the list
            // ==================
    
            if(m_apBindings.Add(pBinding) < 0)
                return WBEM_E_OUT_OF_MEMORY;
        }
    }

    if(pOldBinding)
    {
        // Found
        // =====

        pOldBinding->Release();
        return S_FALSE;
    }
    else
    {
        return S_OK;
    }
}

HRESULT CEventConsumer::EnsureNotReferences(CEventFilter* pFilter)
{
    CBinding* pOldBinding = NULL;

    {
        CInCritSec ics(&m_cs);
    
        for(int i = 0; i < m_apBindings.GetSize(); i++)
        {
            if(m_apBindings[i]->GetFilter() == pFilter)
            {
                // Remove the binding
                // ==================
    
                m_apBindings.RemoveAt(i, &pOldBinding);
                break;
            }
        }
    }

    if(pOldBinding)
    {
        pOldBinding->Release();
        return S_OK;
    }
    else
    {
        // Not found
        // =========
    
        return S_FALSE;
    }
}

HRESULT CEventConsumer::Unbind()
{
    // Unbind the binding array from the consumer
    // ==========================================

    CBinding** apBindings = NULL;
    int nNumBindings = 0;

    {
        CInCritSec ics(&m_cs);
        nNumBindings = m_apBindings.GetSize();
        apBindings = m_apBindings.UnbindPtr();

        if ( NULL == apBindings )
        {
            return WBEM_S_FALSE;
        }
    }
    
    // Instruct all the filters that are bound to us to unbind
    // =======================================================

    HRESULT hres = S_OK;

    for(int i = 0; i < nNumBindings; i++)
    {
        HRESULT hr = apBindings[i]->GetFilter()->EnsureNotReferences(this);
        if( FAILED( hr ) ) 
        {
            hres = hr;
        }
        apBindings[i]->Release();
    }

    delete [] apBindings;

#ifdef __WHISTLER_UNCUT
    //
    // tell the associated queueing sink that it needs to clean up its queues. 
    // TODO : this is temporary because we will later support the case where
    // there is a many-to-1 mapping between consumers and queueing sinks.
    // When that happens, this logic will be moved elsewhere.
    //

    CleanupPersistentQueues();
#endif

    return hres;
}

HRESULT CEventConsumer::ConsumeFromBinding(CBinding* pBinding, 
                                long lNumEvents, IWbemEvent** apEvents,
                                CEventContext* pContext)
{
    DWORD dwQoS = pBinding->GetQoS();

    if( dwQoS == WMIMSG_FLAG_QOS_SYNCHRONOUS )
    {
        // Synchronous delivery --- call the ultimate client
        // =================================================

        IUnknown* pOldSec = NULL;
        if(!pBinding->IsSecure())
        {
            CoSwitchCallContext(NULL, &pOldSec);
        }

        HRESULT hres = ActuallyDeliver( lNumEvents, 
                                apEvents, 
                                pBinding->IsSecure(), 
                                pContext );

        if(!pBinding->IsSecure())
        {
            IUnknown* pGarb = NULL;
            CoSwitchCallContext(pOldSec, &pGarb);
        }

        return hres;
    }

    // Asynchronous delivery --- delegate to queueing sink
    // ===================================================
    
    return CQueueingEventSink::SecureIndicate( lNumEvents, 
                                               apEvents,
                                               pBinding->IsSecure(), 
                                               pBinding->ShouldSlowDown(),
                                               dwQoS,
                                               pContext );
}

HRESULT CEventConsumer::GetAssociatedFilters(
                            CRefedPointerSmallArray<CEventFilter>& apFilters)
{
    CInCritSec ics(&m_cs);

    for(int i = 0; i < m_apBindings.GetSize(); i++)
    {
        if(apFilters.Add(m_apBindings[i]->GetFilter()) < 0)
            return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CEventConsumer::ReportEventDrop(IWbemEvent* pEvent)
{
    // Log a message
    // =============

    ERRORTRACE((LOG_ESS, "Dropping event destined for event consumer %S in "
            "namespace %S\n", (LPCWSTR)(WString)GetKey(), 
                                m_pNamespace->GetName()));

    if(pEvent->InheritsFrom(EVENT_DROP_CLASS) == S_OK)
    {
        ERRORTRACE((LOG_ESS, "Unable to deliver an event indicating inability "
            "to deliver another event to event consumer %S in namespace %S.\n"
            "Not raising an error event to avoid an infinite loop!\n", 
            (LPCWSTR)(WString)GetKey(), m_pNamespace->GetName()));

        return S_FALSE;
    }
    return S_OK;
}
    
//*************************** Event Filter **********************************

CEventFilter::CEventFilter(CEssNamespace* pNamespace) 
    : m_pNamespace(pNamespace), m_eState(e_Inactive), 
        m_ForwardingSink(this), m_ClassChangeSink(this), 
        m_eValidity(e_TemporarilyInvalid), m_pOwnerSid(NULL),
        m_bSingleAsync(false), m_lSecurityChecksRemaining(0), 
        m_hresFilterError(WBEM_E_CRITICAL_ERROR), m_bCheckSDs(false),
        m_bHasBeenValid(false), m_dwLastTokenAttempt(0), m_pToken(NULL),
        m_bDeactivatedByGuard(false), m_bReconstructOnHit(false),
        m_pGuardingSink(NULL), m_hresTokenError(WBEM_E_CRITICAL_ERROR),
        m_hresPollingError(S_OK)
{
    InterlockedIncrement( &g_lNumFilters );

    m_pNamespace->AddRef();
}

CEventFilter::~CEventFilter()
{
    InterlockedDecrement( &g_lNumFilters );

    delete [] m_pOwnerSid;

    if(m_pNamespace)
        m_pNamespace->Release();
    if(m_pToken)
        m_pToken->Release();
}

HRESULT CEventFilter::EnsureReferences(CEventConsumer* pConsumer, 
                                        CBinding* pBinding)
{
    CBinding* pOldBinding = NULL;

    {
        CInUpdate iu(this);

        // Actually change the bindings
        // ============================

        {
            CInCritSec ics(&m_cs);
        
            for(int i = 0; i < m_apBindings.GetSize(); i++)
            {
                if(m_apBindings[i]->GetConsumer() == pConsumer)
                {
                    // Replace the binding
                    // ===================
        
                    // binding cannot change synchronicity --- in such cases,
                    // it is first removed, and then re-added.  Therefore,
                    // no m_bSingleAsync adjustment is needed

                    m_apBindings.SetAt(i, pBinding, &pOldBinding);
                    break;
                }
            }

            if(pOldBinding == NULL)
            {
                // Add it to the list
                // ==================
        
                if(m_apBindings.Add(pBinding) < 0)
                    return WBEM_E_OUT_OF_MEMORY;

                AdjustSingleAsync();
            }
        }

        // Activate if needed
        // ==================

        AdjustActivation();
    }

    if(pOldBinding)
    {
        // Found
        // =====

        pOldBinding->Release();
        return S_FALSE;
    }
    else
    {
        return S_OK;
    }
}

HRESULT CEventFilter::EnsureNotReferences(CEventConsumer* pConsumer)
{
    CBinding* pOldBinding = NULL;

    {
        CInUpdate iu(this);

        // Make the actual change
        // ======================

        {
            CInCritSec ics(&m_cs);
        
            for(int i = 0; i < m_apBindings.GetSize(); i++)
            {
                if(m_apBindings[i]->GetConsumer() == pConsumer)
                {
                    // Remove the binding
                    // ==================
        
                    m_apBindings.RemoveAt(i, &pOldBinding);

                    AdjustSingleAsync();

                    break;
                }
            } // for
        } // m_cs

        // Deactivate the filter if necessary
        // ==================================

        AdjustActivation();
    } // update

    if(pOldBinding)
    {
        pOldBinding->Release();
        return S_OK;
    }
    else
    {
        // Not found
        // =========
    
        return S_FALSE;
    }
}

HRESULT CEventFilter::Unbind(bool bShuttingDown)
{
    // Unbind the binding array from the filter
    // ========================================
    
    CBinding** apBindings = NULL;
    int nNumBindings = 0;

    {
        CInUpdate iu(this);

        {
            CInCritSec ics(&m_cs);
            nNumBindings = m_apBindings.GetSize();
            apBindings = m_apBindings.UnbindPtr();

            if ( NULL == apBindings )
            {
                return WBEM_S_FALSE;
            }

            m_bSingleAsync = false;
        }

        if(!bShuttingDown)
            AdjustActivation();
    }
    
    // Instruct all the consumers that are bound to us to unbind
    // =========================================================

    HRESULT hres = S_OK;

    for(int i = 0; i < nNumBindings; i++)
    {
        HRESULT hr = apBindings[i]->GetConsumer()->EnsureNotReferences(this);
        if ( FAILED( hr ) ) 
        {
            hres = hr;
        }

        apBindings[i]->Release();
    }

    delete [] apBindings;

    return hres;
}

// This function is only called at construction --- no locks are needed
HRESULT CEventFilter::SetGuardQuery(LPCWSTR wszQuery, LPCWSTR wszNamespace)
{
    if(wszQuery)
        m_wsGuardQuery = wszQuery;
    else
        m_wsGuardQuery.Empty();

    if(wszNamespace)
        m_wsGuardNamespace = wszNamespace;
    else
        m_wsGuardNamespace.Empty();

    return WBEM_S_NO_ERROR;
}

bool CEventFilter::IsGuarded()
{
    return (m_wsGuardQuery.Length() != 0);
}

bool CEventFilter::IsGuardActive()
{
    return (m_pGuardingSink != NULL);
}

HRESULT CEventFilter::ActivateGuard()
{
    HRESULT hres;

    //
    // Check if the guard is already active
    //

    if(IsGuardActive())
        return WBEM_S_FALSE;

    //
    // Create the guarding sink --- the one that receives notifications
    // of the guard going up or down
    //

    CFilterGuardingSink* pSink = new CFilterGuardingSink(this);
    if(pSink == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pSink->AddRef();
    CReleaseMe rm1(pSink);
    
    //
    // Issue the monitor for the guarding query.  It is up to the monitoring
    // subsystem to optimize similar monitors
    //

    CEssNamespace* pNamespace = NULL;
    if(m_wsGuardNamespace.Length() > 0)
    {
        hres = m_pNamespace->GetEss()->GetNamespaceObject( m_wsGuardNamespace, 
                                                           TRUE,
                                                           &pNamespace );
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Unable to connect to namespace '%S' of "
                "guarding monitor '%S' for "
                "event filter '%S': 0x%X.  The filter will remain inactive\n",
                (LPCWSTR)m_wsGuardNamespace, (LPCWSTR)m_wsGuardQuery, 
                (LPCWSTR)(WString)GetKey(), hres));

            SetGuardStatus(false);
            return hres;
        }
    }
    else
    {
        pNamespace = m_pNamespace;
        pNamespace->AddRef();
    }

    CTemplateReleaseMe<CEssNamespace> rm2(pNamespace);

    hres = pNamespace->InternalRegisterNotificationSink(L"WQL", 
                m_wsGuardQuery,
                WBEM_FLAG_MONITOR, WMIMSG_FLAG_QOS_SYNCHRONOUS, 
                GetCurrentEssContext(), pSink, false, NULL );
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Unable to issue guarding monitor '%S' for "
            "event filter '%S': 0x%X.  The filter will remain inactive\n",
            (LPCWSTR)m_wsGuardQuery, (LPCWSTR)(WString)GetKey(), 
            hres));

        SetGuardStatus(false);
        return hres;
    }

    //
    // Store the sink AddRef'ed in the filter object. This creates a 
    // circular reference count, but that's OK, since the sink is released 
    // during filter deactivation and shutdown
    //

    m_pGuardingSink = pSink;
    m_pGuardingSink->AddRef();

    return S_OK;
}

HRESULT CEventFilter::DeactivateGuard()
{
    HRESULT hres;

    if(!IsGuardActive())
        return WBEM_S_FALSE;

    //
    // Cancel the monitor
    //

    hres = m_pNamespace->InternalRemoveNotificationSink(m_pGuardingSink);
    
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Unable to stop guarding monitor '%S' for "
            "event filter '%S': 0x%X\n",
            (LPCWSTR)m_wsGuardQuery, (LPCWSTR)(WString)GetKey(), 
            hres));
    }

    m_pGuardingSink->Release();
    m_pGuardingSink = NULL;

    return S_OK;
}

CEventFilter::CFilterGuardingSink::CFilterGuardingSink(CEventFilter* pFilter)
    : m_pFilter(pFilter)
{
    m_pFilter->AddRef();
}
    
CEventFilter::CFilterGuardingSink::~CFilterGuardingSink()
{
    if(m_pFilter)
        m_pFilter->Release();
}

STDMETHODIMP CEventFilter::CFilterGuardingSink::Indicate(long lNumObjects, 
                                        IWbemClassObject** apEvents)
{
    HRESULT hres;

    //
    // Get current state from the filter
    //

    bool bEnable;
    bool bError;

    m_pFilter->GetGuardStatus(&bEnable, &bError);

    bool bOldEnable = bEnable;
    bool bOldError = bError;

    //
    // Traverse the entire list computing the end result --- whether the 
    // guard should be true or false
    //


    for(long i = 0; i < lNumObjects; i++)
    {
        _IWmiObject* pObj = NULL;
        hres = apEvents[i]->QueryInterface(IID__IWmiObject, (void**)&pObj);
        if(FAILED(hres))
            return hres;
        CReleaseMe rm1(pObj);

        //
        // Determine the class and process accordingly
        //

        WCHAR wszClassName[256];
        BOOL bIsNull;
        DWORD dwSizeUsed;

        hres = pObj->ReadProp(L"__CLASS", 0, 256 * sizeof(WCHAR), NULL, NULL, 
                        &bIsNull, &dwSizeUsed, wszClassName);
        if(FAILED(hres))
            return hres;

        if(bIsNull)
            return WBEM_E_INVALID_CLASS;

        if(!wbem_wcsicmp(wszClassName, ASSERT_EVENT_CLASS))
        {
            if(!bError)
                bEnable = true;
        }
        else if(!wbem_wcsicmp(wszClassName, RETRACT_EVENT_CLASS))
        {
            if(!bError)
                bEnable = !IsCountZero(pObj);
        }
        else if(!wbem_wcsicmp(wszClassName, GOINGUP_EVENT_CLASS))
        {
            bEnable = !IsCountZero(pObj);
            bError = false; 
        }
        else if(!wbem_wcsicmp(wszClassName, MONITORERROR_EVENT_CLASS) ||
                !wbem_wcsicmp(wszClassName, GOINGDOWN_EVENT_CLASS))
        {
            bError = true; 
        }
    }

    if(bError != bOldError || bOldEnable != bEnable)
    {
        CEssThreadObject Obj(NULL);
        SetConstructedEssThreadObject(&Obj);

        //
        // Set the guard state back
        //
    
        m_pFilter->SetGuardStatus(bEnable, bError);
        m_pFilter->AdjustActivation();
    
        m_pFilter->m_pNamespace->FirePostponedOperations();
        ClearCurrentEssThreadObject();
    }

    return S_OK;
}

bool CEventFilter::CFilterGuardingSink::IsCountZero(_IWmiObject* pObj)
{
    HRESULT hres;

    //
    // Get the count
    //

    DWORD dwCurrentCount;
    BOOL bIsNull;
    DWORD dwSize;
    hres = pObj->ReadProp(MONITORCOUNT_EVENT_PROPNAME, 0, sizeof(DWORD),  NULL,
                     NULL, &bIsNull, &dwSize, &dwCurrentCount);
    if(FAILED(hres) || bIsNull)
    {
        // internal error
        return true;
    }

    return (dwCurrentCount == 0);
}

    
void CEventFilter::SetInactive()
{
    m_eState = e_Inactive;
}

BOOL CEventFilter::IsActive()
{
    return (m_eState == e_Active);
}

HRESULT CEventFilter::GetFilterError()
{
    return m_hresFilterError;
}

HRESULT CEventFilter::GetEventNamespace(LPWSTR* pwszNamespace)
{
    *pwszNamespace = NULL;
    return S_OK;
}

// assumes in m_cs
void CEventFilter::AdjustSingleAsync()
{
    if(m_apBindings.GetSize() > 1)
        m_bSingleAsync = false;
    else if(m_apBindings.GetSize() == 0)
        m_bSingleAsync = false;
    else if(m_apBindings[0]->IsSynch())
        m_bSingleAsync = false;
    else
        m_bSingleAsync = true;
}

bool CEventFilter::IsBound()
{
    return (m_apBindings.GetSize() != 0);
}

// Requires: in m_csChangeBindings
HRESULT CEventFilter::AdjustActivation()
{
    // Invalid filters cannot be activated or deactivated
    // ==================================================

    if(m_eValidity == e_PermanentlyInvalid)
        return S_FALSE;

    //
    // Check if we need to activate or deactivate our guarding mechanism
    //

    if(IsBound() && IsGuarded() && !IsGuardActive())
    {
        // The default guard status is false --- the monitor is sure to tell
        // us if it has anything

        SetGuardStatus(false);
        ActivateGuard();
    }
    else if(IsGuardActive() && (!IsBound() || !IsGuarded()))
    {
        DeactivateGuard();
    }

    HRESULT hres = S_FALSE;
    if(!IsBound() || m_bDeactivatedByGuard)
    {
        //
        // Even if this filter is not active, it may be subscribed for
        // activation events if it is temporarily invalid (and that's the only
        // reason it is not active). 
        //
        
        m_pNamespace->UnregisterFilterFromAllClassChanges(this);
    
        if(m_eState == e_Active)
        {
            hres = m_pNamespace->DeactivateFilter(this);
            if(FAILED(hres)) return hres;
            m_eState = e_Inactive;
        }
        return WBEM_S_NO_ERROR;
    }
    else if(m_eState == e_Inactive && IsBound() && !m_bDeactivatedByGuard)
    {
        //
        // Even though this filter is not active, it may be subscribed for
        // activation events if it is temporarily invalid (and that's the only
        // reason it is not active). 
        //
        
        m_pNamespace->UnregisterFilterFromAllClassChanges(this);
    
        hres = m_pNamespace->ActivateFilter(this);
        if(FAILED(hres)) return hres;
        m_eState = e_Active;

        return WBEM_S_NO_ERROR;
    }
    else
    {
        return S_FALSE;
    }
}
        
void CEventFilter::MarkAsPermanentlyInvalid(HRESULT hres)
{
    m_eValidity = e_PermanentlyInvalid;
    m_hresFilterError = hres;
}

void CEventFilter::MarkAsTemporarilyInvalid(HRESULT hres)
{
    m_eValidity = e_TemporarilyInvalid;
    m_hresFilterError = hres;
}

void CEventFilter::MarkAsValid()
{
    m_eValidity = e_Valid;
    m_bHasBeenValid = true;
    m_hresFilterError = WBEM_S_NO_ERROR;
}

void CEventFilter::MarkReconstructOnHit(bool bReconstruct)
{
    //
    // Reconstruction is not really needed, since dummer nodes are used for 
    // this
    //

    m_bReconstructOnHit = bReconstruct;
}

void CEventFilter::GetGuardStatus(bool *pbEnable, bool *pbError)
{
    *pbError = m_bGuardError;
    *pbEnable = !m_bDeactivatedByGuard;
}
    
void CEventFilter::SetGuardStatus(bool bEnable, bool bError)
{
    // Activation adjustment is handled by the caller
    m_bGuardError = bError;
    m_bDeactivatedByGuard = (bError || !bEnable);
}

HRESULT CEventFilter::CheckEventAccessToFilter( IServerSecurity* pProvCtx )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    const PSECURITY_DESCRIPTOR pEventAccessSD = GetEventAccessSD();

    if ( pEventAccessSD == NULL )
    {
        //
        // filter allows all events 
        //
        return WBEM_S_NO_ERROR;
    }

    //
    // check that the event provider's calling context has access to filter 
    // 

    if ( pProvCtx != NULL )
    {
        hr = pProvCtx->ImpersonateClient();

        if ( SUCCEEDED(hr) )
        {
            HANDLE hToken;

            if ( OpenThreadToken( GetCurrentThread(), 
                                  TOKEN_QUERY,
                                  TRUE,
                                  &hToken ) )
            {
                GENERIC_MAPPING map;
                ZeroMemory( &map, sizeof(GENERIC_MAPPING) );

                PRIVILEGE_SET ps;
                DWORD dwPrivLength = sizeof(ps);
                
                BOOL bStatus;
                DWORD dwGranted;
      
                if ( ::AccessCheck( PSECURITY_DESCRIPTOR(pEventAccessSD), 
                                    hToken,
                                    WBEM_RIGHT_PUBLISH,
                                    &map, 
                                    &ps,
                                    &dwPrivLength, 
                                    &dwGranted, 
                                    &bStatus ) )
                {
                    hr = bStatus ? WBEM_S_NO_ERROR : WBEM_E_ACCESS_DENIED;
                }
                else
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                }

                CloseHandle( hToken );
            }
            else
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
            }

            pProvCtx->RevertToSelf();       
        }
    }

    return hr;
}


HRESULT CEventFilter::CheckFilterAccessToEvent( PSECURITY_DESCRIPTOR pEventSD )
{
    HRESULT hr;
    
    if ( pEventSD == NULL )
    {
        //
        // event provider allows all filters access 
        //
        return WBEM_S_NO_ERROR;
    }

    if( !m_bCheckSDs )
    {
        //
        // This filter was unconditionally allowed by all its event providers!
        //
        return WBEM_S_NO_ERROR;
    }

    //
    // Get the token for this filter
    //

    if( m_pToken == NULL && FAILED(m_hresTokenError) )
    {
        //
        // Check how long it's been since we last attempted to get the token --
        // don't want to do that too often.
        //

        if(m_dwLastTokenAttempt == 0 || 
            m_dwLastTokenAttempt < 
                GetTickCount() - MIN_TIMEOUT_BETWEEN_TOKEN_ATTEMPTS )
        {
            //
            // Get the filter to find a token, however it does that
            //
            m_hresTokenError = ObtainToken( &m_pToken );
            
            if( FAILED(m_hresTokenError) )
            {
                m_dwLastTokenAttempt = GetTickCount();
            }
        }
    }

    if ( m_hresTokenError == WBEM_S_NO_ERROR )
    {
        _DBG_ASSERT( m_pToken != NULL );

        //
        // Check security for real
        //
        
        DWORD dwGranted;
        hr = m_pToken->AccessCheck( WBEM_RIGHT_SUBSCRIBE, 
                                    (const BYTE*)pEventSD, 
                                    &dwGranted );
        if( SUCCEEDED(hr) )
        {
            if(dwGranted & WBEM_RIGHT_SUBSCRIBE)
            {
                hr = WBEM_S_NO_ERROR;
            }
            else
            {
                hr = WBEM_E_ACCESS_DENIED;
            }
        }
    }
    else 
    {
        hr = m_hresTokenError;
    }

    return hr;
}

HRESULT CEventFilter::AccessCheck( CEventContext* pContext, IWbemEvent* pEvent)
{
    HRESULT hr;

    // 
    // With polling, there will be a null context. we don't do an access 
    // check in that case.
    // 

    if ( pContext == NULL )
    {
        return WBEM_S_NO_ERROR;
    }

    PSECURITY_DESCRIPTOR pEventSD = (PSECURITY_DESCRIPTOR)pContext->GetSD();

    //
    // check that the filter allows access to the event provider and owner.
    // owner and provider can be different when the provider is signaling 
    // events on behalf of some other identity.
    // 
    
    CWbemPtr<IServerSecurity> pProvCtx = NULL;
    CoGetCallContext( IID_IServerSecurity, (void**)&pProvCtx );

    //
    // NOTE: With cross namespace events, the two parts of the access check 
    // are split up between the namespaces.  The FilterAccessToEvent is 
    // performed in the event's namespace with the temp subscription's
    // AccessCheck.  This is possible because the owner sid is propagated 
    // over with the temp subscription.  The EventAccessToFilter is performed
    // in the subscription namespace.  This is possible because the call 
    // context and the SD of the event ( containing the event owner sid ) 
    // is propagated with the event.  Both functions are called in 
    // both namespaces, but the unnecessary calls turn out to be no-ops.
    // 

    hr = CheckEventAccessToFilter( pProvCtx );

    if ( SUCCEEDED(hr) )
    {
        //
        // check that the event provider allows access to the filter.
        //

        hr = CheckFilterAccessToEvent( pEventSD );
    }

    return hr;
}

HRESULT CEventFilter::Deliver( long lNumEvents, 
                               IWbemEvent** apEvents,
                               CEventContext* pContext )
{
    int i;

    if( m_lSecurityChecksRemaining > 0 )
    {
        return WBEM_S_FALSE;
    }

    CBinding* pBinding = NULL;
    {
        CInCritSec ics(&m_cs);

        if(m_bSingleAsync)
        {
            //
            // Thought we could deliver (call Indicate on the binding) right 
            // here, since single async ensures that no delivery will occur on
            // this thread.  But no --- an error may be raised, and that event
            // will be delivered on this thread, so we must exit the critsec 
            // before calling
            // 
    
            pBinding = m_apBindings[0];
            pBinding->AddRef();
        }
    }

    if( pBinding )
    {
        CReleaseMe rm1(pBinding);
        return pBinding->Indicate( lNumEvents, apEvents, pContext );
    }

    // Make referenced copies of all the bindings to deliver over
    // ==========================================================

    // CANNOT USE SCOPING DUE TO CTempArray --- it uses _alloca

    m_cs.Enter();
    CTempArray<CBinding*> apBindings;
    int nSize = m_apBindings.GetSize();
    if(!INIT_TEMP_ARRAY(apBindings, nSize))
    {
        m_cs.Leave();
        return WBEM_E_OUT_OF_MEMORY;
    }

    {
        for(i = 0; i < nSize; i++)
        {
            CBinding* pBindingInner = m_apBindings[i];
            pBindingInner->AddRef();
            apBindings[i] = pBindingInner;
        }
    }
    
    m_cs.Leave();

    // Deliver and release the bindings
    // ================================

    HRESULT hresGlobal = S_OK;
    for(i = 0; i < nSize; i++)
    {
        CBinding* pBindingInner = apBindings[i];
        HRESULT hres = pBindingInner->Indicate( lNumEvents, apEvents, pContext ); 
        pBindingInner->Release();
        if(FAILED(hres))
            hresGlobal = hres;
    }

    return hresGlobal;
}

HRESULT CEventFilter::LockForUpdate()
{
    // Don't need to do anything since the namespace is locked!
/*
    m_csChangeBindings.Enter();
    AddRef();
*/
    return S_OK;
}

HRESULT CEventFilter::UnlockForUpdate()
{
/*
    m_csChangeBindings.Leave();
    Release();
*/
    return S_OK;
}

HRESULT CEventFilter::CEventForwardingSink::Indicate(long lNumEvents, 
                                                        IWbemEvent** apEvents,
                                                        CEventContext* pContext)
{
    return m_pOwner->Deliver(lNumEvents, apEvents, pContext);
}

void CEventFilter::IncrementRemainingSecurityChecks()
{
    InterlockedIncrement(&m_lSecurityChecksRemaining);
}

void CEventFilter::DecrementRemainingSecurityChecks(HRESULT hresProvider)
{
    //
    // The provider could have said;
    //      S_OK: this subscription is fine, send all events through or
    //      S_SUBJECT_TO_SDS: check event security descriptors before sending
    // So, if all the providers gave us a blank check, we won't check security
    // descriptors, but if any did, we will check them all.
    //

    if(hresProvider  == WBEM_S_SUBJECT_TO_SDS)
    {
        m_bCheckSDs = true;
    }
    else if(hresProvider != WBEM_S_NO_ERROR)
    {
        ERRORTRACE((LOG_ESS, "Invalid return code from provider security test: "
                    "0x%X\n", hresProvider));
        return;
    }

    InterlockedDecrement(&m_lSecurityChecksRemaining);
}

HRESULT CEventFilter::SetActualClassChangeSink( IWbemObjectSink* pSink, 
                                                IWbemObjectSink** ppOldSink )
{
    HRESULT hr;

    if ( m_pActualClassChangeSink != NULL )
    {
        m_pActualClassChangeSink->AddRef();
        *ppOldSink = m_pActualClassChangeSink;
        hr = WBEM_S_NO_ERROR;
    }
    else
    {
        *ppOldSink = NULL;
        hr = WBEM_S_FALSE;
    }

    m_pActualClassChangeSink = pSink;
    
    return hr;
}

HRESULT CEventFilter::Reactivate()
{
    HRESULT hres;

    // 
    // This is called when a class or something like that changes from
    // from underneath us.
    // What we need to do is lock the namespace, deactivate this filter, then
    // activate it again
    //

    CInUpdate iu(m_pNamespace);

    DEBUGTRACE((LOG_ESS, "Attempting to reactivate filter '%S' in namespace "
                            "'%S'\n",  (LPCWSTR)(WString)GetKey(), 
                                m_pNamespace->GetName()));

    // Invalid filters cannot be activated or deactivated
    // ==================================================

    if(m_eValidity == e_PermanentlyInvalid)
    {
        DEBUGTRACE((LOG_ESS, "Not reactivate filter '%S' in namespace "
                            "'%S': permanently invalid\n",  
                        (LPCWSTR)(WString)GetKey(), m_pNamespace->GetName()));
        return S_FALSE;
    }

    if(m_eState == e_Active)
    {
        DEBUGTRACE((LOG_ESS, "Deactivating filter '%S' in namespace "
                            "'%S' prior to reactivation\n",  
                        (LPCWSTR)(WString)GetKey(), m_pNamespace->GetName()));
        hres = m_pNamespace->DeactivateFilter(this);
        if(FAILED(hres)) 
        {
            ERRORTRACE((LOG_ESS, "Deactivating filter '%S' in namespace "
                            "'%S' prior to reactivation failed: 0x%X\n",  
                        (LPCWSTR)(WString)GetKey(), m_pNamespace->GetName(),
                        hres));
            return hres;
        }
        m_eState = e_Inactive;
    }

    hres = AdjustActivation();

    DEBUGTRACE((LOG_ESS, "Reactivating filter '%S' in namespace "
                            "'%S' returned 0x%X\n",  
                        (LPCWSTR)(WString)GetKey(), m_pNamespace->GetName(),
                        hres));
    return hres;
}

STDMETHODIMP CEventFilter::CClassChangeSink::Indicate( long lNumEvents,
                                                       IWbemEvent** apEvents )
{
    HRESULT hr;

    hr = m_pOuter->Reactivate();

    if ( SUCCEEDED(hr) )
    {
        hr = m_pOuter->m_pNamespace->FirePostponedOperations();
    }
    else
    {
        m_pOuter->m_pNamespace->FirePostponedOperations();
    }

    if ( FAILED(hr) )
    {
        ERRORTRACE((LOG_ESS, "Error encountered when reactivating filter '%S' "
                    "due to a class change.  Namespace is '%S', HRES=0x%x\n",
                    (LPCWSTR)(WString)m_pOuter->GetKey(), 
                    m_pOuter->m_pNamespace->GetName(),
                    hr ));
    }

    return hr;
}
 
//***************************** Binding ***************************************

CBinding::CBinding()
 : m_pConsumer(NULL), m_pFilter(NULL), m_dwQoS( WMIMSG_FLAG_QOS_EXPRESS ),
   m_bSlowDown(false), m_bSecure(false), m_bDisabledForSecurity(false)
{
    InterlockedIncrement( &g_lNumBindings );
}

CBinding::CBinding(ADDREF CEventConsumer* pConsumer, 
                        ADDREF CEventFilter* pFilter)
    : m_pConsumer(NULL), m_pFilter(NULL), m_dwQoS( WMIMSG_FLAG_QOS_EXPRESS ),
        m_bSlowDown(false), m_bSecure(false)
{
    InterlockedIncrement( &g_lNumBindings );

    SetEndpoints(pConsumer, pFilter, NULL);
}

HRESULT CBinding::SetEndpoints(ADDREF CEventConsumer* pConsumer, 
                            ADDREF CEventFilter* pFilter,
                            READONLY PSID pBinderSid)
{
    m_pConsumer = pConsumer;
    m_pConsumer->AddRef();
    m_pFilter = pFilter;
    m_pFilter->AddRef();

    // Make sure that the owner of this binding is the same as the
    // owners of the endpoints
    // ==================================================================

    if(pBinderSid && (!EqualSid(pBinderSid, pConsumer->GetOwner()) ||
       !EqualSid(pBinderSid, pFilter->GetOwner())))
    {
        DisableForSecurity();
    }

    return WBEM_S_NO_ERROR;
}
    
void CBinding::DisableForSecurity()
{
    ERRORTRACE((LOG_ESS, "An event binding is disabled because its creator is "
        "not the same security principal as the creators of the endpoints.  "
        "The binding and the endpoints must be created by the same user!\n"));

    m_bDisabledForSecurity = true;
}

CBinding::~CBinding()
{
    InterlockedDecrement( &g_lNumBindings );

    if(m_pConsumer)
        m_pConsumer->Release();
    if(m_pFilter)
        m_pFilter->Release();
}

DWORD CBinding::GetQoS() NOCS
{
    return m_dwQoS;
}

bool CBinding::IsSynch() NOCS
{
    return m_dwQoS == WMIMSG_FLAG_QOS_SYNCHRONOUS;
}

bool CBinding::IsSecure() NOCS
{
    return m_bSecure;
}

bool CBinding::ShouldSlowDown() NOCS
{
    return m_bSlowDown;
}

HRESULT CBinding::Indicate(long lNumEvents, IWbemEvent** apEvents,
                                CEventContext* pContext)
{
    // Check if this binding is active
    // ===============================

    if(m_bDisabledForSecurity)
        return WBEM_S_FALSE;

    // It is: deliver
    // ==============

    return m_pConsumer->ConsumeFromBinding(this, lNumEvents, apEvents, 
                                            pContext);
}

//************************* Consumer watch instruction ************************

CWbemInterval CConsumerWatchInstruction::mstatic_Interval;
CConsumerWatchInstruction::CConsumerWatchInstruction(CBindingTable* pTable)
    : CBasicUnloadInstruction(mstatic_Interval), 
        m_pTableRef(pTable->m_pTableRef)
{
    if(m_pTableRef)
        m_pTableRef->AddRef();
}

CConsumerWatchInstruction::~CConsumerWatchInstruction()
{
    if(m_pTableRef)
        m_pTableRef->Release();
}

void CConsumerWatchInstruction::staticInitialize(IWbemServices* pRoot)
{
    mstatic_Interval = CBasicUnloadInstruction::staticRead(pRoot, GetCurrentEssContext(), 
                                            L"__EventSinkCacheControl=@");
}

HRESULT CConsumerWatchInstruction::Fire(long, CWbemTime)
{
    if(!m_bTerminate)
    {
        CEssThreadObject Obj(NULL);
        SetConstructedEssThreadObject(&Obj);
    
        CEssNamespace* pNamespace = NULL;

        if(m_pTableRef)
        {
            m_pTableRef->GetNamespace(&pNamespace);
            m_pTableRef->UnloadUnusedConsumers(m_Interval);
        }

        Terminate();

        if( pNamespace )
        {
            pNamespace->FirePostponedOperations();
            pNamespace->Release();
        }

        ClearCurrentEssThreadObject();
    }
    return WBEM_S_NO_ERROR; // no point worrying the timer
}

//*************************** Binding Table ************************************

class CConsumersToRelease
{
    CEventConsumer** m_apConsumers;
    int m_nNumConsumers;

public:
    CConsumersToRelease(CEventConsumer** apConsumers, int nNumConsumers) 
        : m_apConsumers(apConsumers), m_nNumConsumers(nNumConsumers)
    {
    }
    ~CConsumersToRelease()
    {
        for(int i = 0; i < m_nNumConsumers; i++)
        {
            m_apConsumers[i]->Shutdown();
            m_apConsumers[i]->Release();
        }
        delete [] m_apConsumers;
    }

    static DWORD Delete(void* p)
    {
        delete (CConsumersToRelease*)p;
        return 0;
    }
};

CBindingTable::CBindingTable(CEssNamespace* pNamespace) 
    : m_pNamespace(pNamespace), m_pInstruction(NULL), 
        m_bUnloadInstruction(FALSE), m_lNumPermConsumers(0), 
        m_pTableRef(NULL)
{
    m_pTableRef = new CBindingTableRef(this);
    if(m_pTableRef)
        m_pTableRef->AddRef();
}


void CBindingTable::Clear( bool bSkipClean )
{
    //
    // Ensure that no more unloading instructions can make it in
    //

    if(m_pTableRef)
    {
        m_pTableRef->Disconnect();
        m_pTableRef->Release();
        m_pTableRef = NULL;
    }

    // Unbind filter and consumer arrays from the table
    // ================================================

    CEventFilter** apFilters;
    int nNumFilters;
    CEventConsumer** apConsumers;
    int nNumConsumers;

    {
        CInCritSec ics(&m_cs);
        nNumFilters = m_apFilters.GetSize();
        apFilters = m_apFilters.UnbindPtr();
        nNumConsumers = m_apConsumers.GetSize();
        apConsumers = m_apConsumers.UnbindPtr();
    }

    int i;

    // Unbind and release all filters
    // ==============================

    if ( apFilters )
    {
        for(i = 0; i < nNumFilters; i++)
        {
            if (!apFilters[i]->IsInternal())
            {
                g_quotas.DecrementQuotaIndex(
                    apFilters[i]->GetOwner() ? ESSQ_PERM_SUBSCRIPTIONS :
                                               ESSQ_TEMP_SUBSCRIPTIONS,
                    apFilters[i],
                    1 );
            }

            apFilters[i]->Unbind(bSkipClean); // shutting down
            apFilters[i]->Release();
        }
        delete [] apFilters;
    }

    //
    // unbind all consumers, but postpone their release. 
    // 

    if ( apConsumers )
    {
        for(i = 0; i < nNumConsumers; i++)
        {
            apConsumers[i]->Unbind(); // shutting down
        }

        //
        // Release all consumers (unbound by virtue of filter unbinding), but do
        // so on a separate thread
        //

        CConsumersToRelease* pToRelease = 
            new CConsumersToRelease(apConsumers, nNumConsumers);
        DWORD dwId;
        HANDLE hThread = CreateThread(NULL, 0, 
            (LPTHREAD_START_ROUTINE)CConsumersToRelease::Delete, pToRelease, 0, 
            &dwId);
        if(hThread == NULL)
        {
            ERRORTRACE((LOG_ESS, "Unable to launch consumer deleting thread: %d\n", 
                  GetLastError()));
        }
        else
        {
            //
            // Wait for 8 seconds --- David's magic constant
            //
            DWORD dwRes = WaitForSingleObject(hThread, 8000); 
            CloseHandle(hThread);
            if(dwRes != WAIT_OBJECT_0)
            {
                ERRORTRACE((LOG_ESS, "Consumer deleting thread failed to finish in "
                    "time in namespace %S.  Some consumers may not receive their "
                    "Release calls until DCOM times out\n", 
                    m_pNamespace->GetName()));
            }
        }
    }
}


HRESULT CBindingTable::AddEventFilter(CEventFilter* pFilter)
{
    HRESULT hr;

    if (pFilter->IsInternal() ||
        SUCCEEDED(hr = g_quotas.IncrementQuotaIndex(
        pFilter->GetOwner() ? ESSQ_PERM_SUBSCRIPTIONS : ESSQ_TEMP_SUBSCRIPTIONS,
        pFilter,
        1)))
    {
        CInCritSec ics(&m_cs);

        if (m_apFilters.Add(pFilter) >= 0)
            hr = S_OK;
        else
            hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

HRESULT CBindingTable::AddEventConsumer(CEventConsumer* pConsumer)
{
    CInCritSec ics(&m_cs);
    if(m_apConsumers.Add(pConsumer) < 0)
        return WBEM_E_OUT_OF_MEMORY;
    
    if(pConsumer->IsPermanent())
    {
        if(m_lNumPermConsumers++ == 0)
            m_pNamespace->SetActive();
    }

    return S_OK;
}

HRESULT CBindingTable::FindEventFilter(LPCWSTR wszKey, 
                                        RELEASE_ME CEventFilter** ppFilter)
{
    CInCritSec ics(&m_cs);

    if(m_apFilters.Find(wszKey, ppFilter))
        return S_OK;
    else
        return WBEM_E_NOT_FOUND;
}
    
HRESULT CBindingTable::FindEventConsumer(LPCWSTR wszKey, 
                                        RELEASE_ME CEventConsumer** ppConsumer)
{
    CInCritSec ics(&m_cs);

    if(m_apConsumers.Find(wszKey, ppConsumer))
        return S_OK;
    else
        return WBEM_E_NOT_FOUND;
}

HRESULT CBindingTable::RemoveEventFilter(LPCWSTR wszKey)
{
    // Find it and remove it from the table
    // ====================================

    CEventFilter* pFilter = NULL;
    HRESULT hres;

    {
        CInCritSec ics(&m_cs);

        if(!m_apFilters.Remove(wszKey, &pFilter))
            return WBEM_E_NOT_FOUND;
    }
        
    if(pFilter == NULL)
        return WBEM_E_CRITICAL_ERROR;

    // Remove 1 from our quota count.
    if (!pFilter->IsInternal())
    {
        g_quotas.DecrementQuotaIndex(
            pFilter->GetOwner() ? ESSQ_PERM_SUBSCRIPTIONS : ESSQ_TEMP_SUBSCRIPTIONS,
            pFilter,
            1);
    }

    // Unbind it, thus deactivating
    // ============================

    hres = pFilter->Unbind();
    pFilter->Release();


    return hres;
}

void CBindingTable::MarkRemoval(CEventConsumer* pConsumer)
{
    if(pConsumer && pConsumer->IsPermanent())
    {
        if(--m_lNumPermConsumers == 0)
            m_pNamespace->SetInactive();
    }
}

HRESULT CBindingTable::RemoveEventConsumer(LPCWSTR wszKey)
{
    // Find it and remove it from the table
    // ====================================

    CEventConsumer* pConsumer = NULL;
    HRESULT hres;

    {
        CInCritSec ics(&m_cs);

        if(!m_apConsumers.Remove(wszKey, &pConsumer))
            return WBEM_E_NOT_FOUND;
        
        MarkRemoval(pConsumer);
    }
        
    if(pConsumer == NULL)
        return WBEM_E_CRITICAL_ERROR;
    hres = pConsumer->Unbind();
    pConsumer->Release();
    return hres;
}

HRESULT CBindingTable::Bind(LPCWSTR wszFilterKey, LPCWSTR wszConsumerKey, 
                CBinding* pBinding, PSID pBinderSid)
{
    // Find them both and get ref-counted pointers
    // ===========================================

    CEventFilter* pFilter;
    CEventConsumer* pConsumer;
    HRESULT hres;

    {
        CInCritSec ics(&m_cs);
    
        hres = FindEventFilter(wszFilterKey, &pFilter);
        if(FAILED(hres)) return hres;
    
        hres = FindEventConsumer(wszConsumerKey, &pConsumer);
        if(FAILED(hres)) 
        {
            pFilter->Release();
            return hres;
        }
    }

    // Fully construct the binding --- will check security
    // ===================================================

    hres = pBinding->SetEndpoints(pConsumer, pFilter, pBinderSid);
    if(FAILED(hres))
        return hres;

    // Make them reference each other
    // ==============================

    HRESULT hresGlobal = S_OK;
    hres = pFilter->EnsureReferences(pConsumer, pBinding);
    if(FAILED(hres)) 
        hresGlobal = hres;
    hres = pConsumer->EnsureReferences(pFilter, pBinding);
    if(FAILED(hres)) 
        hresGlobal = hres;

    // Cleanup
    // =======

    pConsumer->Release();
    pFilter->Release();

    return hresGlobal;
}

HRESULT CBindingTable::Unbind(LPCWSTR wszFilterKey, LPCWSTR wszConsumerKey)
{
    // Find them both and get ref-counted pointers
    // ===========================================

    CEventFilter* pFilter;
    CEventConsumer* pConsumer;
    HRESULT hres;

    {
        CInCritSec ics(&m_cs);
    
        hres = FindEventFilter(wszFilterKey, &pFilter);
        if(FAILED(hres)) return hres;
    
        hres = FindEventConsumer(wszConsumerKey, &pConsumer);
        if(FAILED(hres)) 
        {
            pFilter->Release();
            return hres;
        }
    }

    // Remove respective references
    // ============================

    HRESULT hresGlobal = S_OK;
    hres = pFilter->EnsureNotReferences(pConsumer);
    if(FAILED(hres))
        hresGlobal = hres;
    pConsumer->EnsureNotReferences(pFilter);
    if(FAILED(hres))
        hresGlobal = hres;

    pFilter->Release();
    pConsumer->Release();
    return hresGlobal;
}
    
BOOL CBindingTable::DoesHavePermanentConsumers()
{
    return (m_lNumPermConsumers != 0);
}

HRESULT CBindingTable::ResetProviderRecords(LPCWSTR wszProviderRef)
{
    // Make a copy of the list of consumers, AddRefed
    // ==============================================

    CRefedPointerArray<CEventConsumer> apConsumers;
    if(!GetConsumers(apConsumers))
        return WBEM_E_OUT_OF_MEMORY;

    // Go through all the consumers and see if they reference this record
    // ==================================================================

    for(int i = 0; i < apConsumers.GetSize(); i++)
    {
        apConsumers[i]->ResetProviderRecord(wszProviderRef);
    }
    return S_OK;
}
    
//*******************************************************************************
//
//  EnsureConsumerWatchInstruction / UnloadUnusedConsumers synchronization
//
//  Usage:
//
//  ECWI is called when a consumer is loaded.  It is called after the consumer 
//      record has been updated. Post-condition: UnloadUnusedConsumers must be 
//      called at least once after this function starts executing.
//
//  UUC is called by the CConsumerWatchTimerInstruction::Fire on timer.  The 
//      instruction then self-destructs. Post-condition: idle consumers 
//      unloaded; if any are still active, another UUC will occur in the future;
//      If none are active for a while, no UUC will occur in the future, 
//      until ECWI is called.
//
//  Primitives: 
//
//  CS m_cs: atomic, data access
//
//  BOOL m_bUnloadInstruction: Can only be accessed in m_cs.  Semantics:
//      TRUE if an instruction is either scheduled or will be scheduled 
//      shortly; this putative instruction, when fired, is guaranteed to 
//      examine any consumer in the table at the time of he check.
//
//  Algorithm:
//
//  ECWI checks m_bUnloadInstructiion (in m_cs) and if TRUE does nothing, as the
//      m_bUnloadInstruction == TRUE guarantee above assures that UUC will be
//      called.  If it is FALSE, ECWI sets it to TRUE, then schedules an 
//      instruction (outside of m_cs).  The setting of m_bUnloadInstruction to
//      TRUE is correct, since an instruction will be scheduled shortly.  Thus,
//      ECWI post-condition is satisfied, assuming primitive semantics above.
//
//  UUC, in m_cs, sets m_bUnloadInstriction to FALSE and makes a copy of the 
//      consumer list.  Outside of m_cs, it iterates over the copy and unloads
//      consumers as required. Then, if any are active, it calls ECWI. This 
//      guarantees that another UUC will be called.  If a consumer was active
//      before the entry into m_cs, we call ECWI. If a consumer became active
//      after we entered into m_cs, it will call ECWI after we have reset 
//      m_bUnloadInstruction, causing another instruction to be scheduled. This
//      proves our post-condition assuming primitive semantics above.
//
//  Proof of primitives:
//
//  m_bUnloadInstruction becomes TRUE only in ECWI. When it does, ECWI is
//  guaranteed to schedule a new instruction, causing a call to UUC. So, the
//  semantics holds in the beginning.  It can become invalid if UUC fires and is
//  not rescheduled. But UUC resets m_bUnloadInstruction to FALSE, thus making 
//  semantics valid vacuously. 
//
//  Now, we need to show that any consumer in the table at the time when
//  m_bUnloadInstruction == TRUE will be examined by the scheduled UUC. Well,
//  the latest scheduled (or about to be scheduled) UUC, cannot have exited 
//  its m_cs stint yet, for otherwise m_bUnloadInstruction would be FALSE. 
//  Therefore, it hasn't entered it yet, and therefore hasn't made a copy yet.
//
//******************************************************************************

HRESULT CBindingTable::EnsureConsumerWatchInstruction()
{
    // Check if it is already there
    // ============================

    BOOL bMustSchedule = FALSE;
    {
        CInCritSec ics(&m_cs);

        if(!m_bUnloadInstruction)
        {
            // Not there.  Mark as there, preventing others from scheduling 
            // more. 
            // ============================================================

            m_bUnloadInstruction = TRUE;
            bMustSchedule = TRUE;
        }
    }

    if(bMustSchedule)
    {
        CConsumerWatchInstruction* pInst = new CConsumerWatchInstruction(this);
        if(pInst == NULL)
        {
            CInCritSec ics(&m_cs);
            m_bUnloadInstruction = FALSE;
            return WBEM_E_OUT_OF_MEMORY;
        }
        pInst->AddRef();
    
        // Set it in the generator
        // =======================
    
        HRESULT hres = m_pNamespace->GetTimerGenerator().Set(pInst);
        if(FAILED(hres))
        {
            CInCritSec ics(&m_cs);
            m_bUnloadInstruction = FALSE;
            return hres;
        }
        
        pInst->Release();

        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

HRESULT CBindingTable::UnloadUnusedConsumers(CWbemInterval Interval)
{
    // Mark unload instruction as empty and copy consumer records
    // ==========================================================

    CRefedPointerArray<CEventConsumer> apConsumers;

    {
        CInCritSec ics(&m_cs);
        m_bUnloadInstruction = FALSE;
        if(!GetConsumers(apConsumers))
            return WBEM_E_OUT_OF_MEMORY;
    }

    // Go through the consumers and unload them if needed
    // ==================================================

    BOOL bUnloaded = FALSE;
    BOOL bActive = FALSE;

    for(int i = 0; i < apConsumers.GetSize(); i++)
    {
        if(apConsumers[i]->UnloadIfUnusedFor(Interval))
            bUnloaded = TRUE;
        else if(!apConsumers[i]->IsFullyUnloaded())
            bActive = TRUE;
    }

    // Schedule DLL unloading if any COM objects were unloaded
    // =======================================================

    if(bUnloaded)
        m_pNamespace->GetTimerGenerator().ScheduleFreeUnusedLibraries();

    // Schedule the new instruction if needed
    // ======================================

    if(bActive)
        return EnsureConsumerWatchInstruction();

    return S_OK;
}

BOOL CBindingTable::GetConsumers(
        CRefedPointerArray<CEventConsumer>& apConsumers)
{
    CInCritSec ics(&m_cs);
    TConsumerIterator it;
    for(it = m_apConsumers.Begin(); it != m_apConsumers.End(); it++)
    {
        if(apConsumers.Add(*it) < 0)
            return FALSE;
    }

    return TRUE;
}


BOOL CBindingTable::GetEventFilters( CRefedPointerArray< CEventFilter > & apEventFilters )
{
    CInCritSec ics( &m_cs );

    TFilterIterator it;

    for( it = m_apFilters.Begin( ); it != m_apFilters.End( ); ++it )
    {
        if( apEventFilters.Add( *it ) < 0 )
        {
            return FALSE;
        }
    }

    return TRUE;
}


HRESULT CBindingTable::RemoveConsumersStartingWith(LPCWSTR wszPrefix)
{
    CRefedPointerArray<CEventConsumer> apToRelease;
    int nLen = wcslen(wszPrefix);

    {
        CInCritSec ics(&m_cs);

        TConsumerIterator it = m_apConsumers.Begin();
        while(it != m_apConsumers.End())
        {
            if(!wcsncmp((WString)(*it)->GetKey(), wszPrefix, nLen))
            {
                // Found it --- move to the "to be released" list
                // ==============================================

                CEventConsumer* pConsumer;
                it = m_apConsumers.Remove(it, &pConsumer);
            
                MarkRemoval(pConsumer);
                apToRelease.Add(pConsumer);
                pConsumer->Release();
            }
            else
            {
                it++;
            }
        }
    }

    // Unbind all the consumers we have left.  Release will happen on destruct
    // =======================================================================

    for(int i = 0; i < apToRelease.GetSize(); i++)
    {
        apToRelease[i]->Unbind();
    }

    return WBEM_S_NO_ERROR;
}
    
HRESULT CBindingTable::RemoveConsumerWithFilters(LPCWSTR wszConsumerKey)
{
    HRESULT hres;

    CRefedPointerSmallArray<CEventFilter> apFilters;

    {
        CInCritSec ics(&m_cs);

        // Find the consumer in question
        // =============================

        CEventConsumer* pConsumer = NULL;
        hres = FindEventConsumer(wszConsumerKey, &pConsumer);
        if(FAILED(hres))
            return hres;

        CReleaseMe rm1(pConsumer);

        // Make addrefed copies of all its associated filters
        // ==================================================

        hres = pConsumer->GetAssociatedFilters(apFilters);
        if(FAILED(hres))
            return hres;
    }
    
    // Remove the consumer
    // ===================

    RemoveEventConsumer(wszConsumerKey);

    // Remove every one of its filters
    // ===============================

    for(int i = 0; i < apFilters.GetSize(); i++)
    {
        RemoveEventFilter((WString)apFilters[i]->GetKey());
    }
    
    return S_OK;
}
        
HRESULT CBindingTable::ReactivateAllFilters()
{
    // Retrieve a copy of all the filters
    // ==================================

    CRefedPointerArray<CEventFilter> apFilters;

    {
        CInCritSec ics(&m_cs);
        TFilterIterator it;
        for(it = m_apFilters.Begin(); it != m_apFilters.End(); it++)
        {
            if(apFilters.Add(*it) < 0)
                return WBEM_E_OUT_OF_MEMORY;
        }
    }

    // Reactivate them all
    // ===================
    
    for(int i = 0; i < apFilters.GetSize(); i++)
    {
        CEventFilter* pFilter = apFilters[i];
        pFilter->SetInactive();
        pFilter->AdjustActivation();
    }

    return WBEM_S_NO_ERROR;
}


void CBindingTable::Park()
{
    // 
    // Tell each filter to "park" itself
    //

    CInCritSec ics(&m_cs);

    TFilterIterator it;
    for(it = m_apFilters.Begin(); it != m_apFilters.End(); it++)
    {
        (*it)->Park();
    }
}


void CBindingTable::DumpStatistics(FILE* f, long lFlags)
{
    fprintf(f, "%d consumers (%d permanent), %d filters\n", 
        m_apConsumers.GetSize(), m_lNumPermConsumers, 
        m_apFilters.GetSize());
}

CBindingTableRef::~CBindingTableRef()
{
}

CBindingTableRef::CBindingTableRef(CBindingTable* pTable)
    : m_pTable(pTable), m_lRef(0)
{
}

void CBindingTableRef::AddRef()
{
    InterlockedIncrement(&m_lRef);
}

void CBindingTableRef::Release()
{
    if(InterlockedDecrement(&m_lRef) == 0)
        delete this;
}
    
void CBindingTableRef::Disconnect()
{
    CInCritSec ics(&m_cs);
    m_pTable = NULL;
}

HRESULT CBindingTableRef::UnloadUnusedConsumers(CWbemInterval Interval)
{
    CInCritSec ics(&m_cs);

    if(m_pTable)
        return m_pTable->UnloadUnusedConsumers(Interval);
    else
        return WBEM_S_FALSE;
}
    
HRESULT CBindingTableRef::GetNamespace(RELEASE_ME CEssNamespace** ppNamespace)
{
    CInCritSec ics(&m_cs);
    if(m_pTable)
    {
        *ppNamespace = m_pTable->m_pNamespace;
        if(*ppNamespace)
            (*ppNamespace)->AddRef();
    }
    else
    {
        *ppNamespace = NULL;
    }
    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\egg\egg.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include <windows.h>
#include <stdio.h>

typedef unsigned __int64 LUINT;

#define LARGE_PRIME 2147483659

DWORD HashKey(char* szKey);
LUINT Invert(LUINT n, LUINT p = LARGE_PRIME);

void main(int argc, char** argv)
{
	if(argc < 3)
	{
		printf("Usage: egg <first> <second>\n");
		return;
	}

	FILE* f1 = fopen(argv[1], "r");
	if(f1 == NULL)
	{
		printf("Cannot open %s\n", argv[1]);
		return;
	}

	FILE* f2 = fopen(argv[2], "r");
	if(f2 == NULL)
	{
		printf("Cannot open %s\n", argv[2]);
		return;
	}

	char szKey1[100];
	char szKey2[100];

	fgets(szKey1, 100, f1);
	szKey1[strlen(szKey1)-1] = 0;
	fgets(szKey2, 100, f2);
	szKey2[strlen(szKey2)-1] = 0;

	char* szText1 = new char[100000];
	memset(szText1, 0, 100000);
	char* szText2 = new char[100000];
	memset(szText2, 0, 100000);

	int i;

	i = 0;
	while((szText1[i] = getc(f1)) != EOF) i++;
	szText1[i] = 0;

	i = 0;
	while((szText2[i] = getc(f2)) != EOF) i++;
	szText2[i] = 0;

	LUINT nK1 = HashKey(szKey1);
	LUINT nK2 = HashKey(szKey2);

	LUINT nDiff = (nK1 > nK2)?nK1-nK2:LARGE_PRIME-(nK2-nK1);
	LUINT nDet = Invert(nDiff);


	LUINT nA, nB, nC, nD;
	nA = nDet;
	nB = LARGE_PRIME - nDet;
	nC = (nB * nK2) % LARGE_PRIME;
	nD = (nA * nK1) % LARGE_PRIME;

	int nTextLen = (strlen(szText1)+1) / sizeof(DWORD) + 1;
	DWORD* pnText1 = (DWORD*)szText1;
	DWORD* pnText2 = (DWORD*)szText2;

	for(i = 0; i < nTextLen; i++)
	{
		__int64 z1 = pnText1[i];
		__int64 z2 = pnText2[i];

		__int64 s1 = (z1*nA + z2*nB) % LARGE_PRIME;
		__int64 s2 = (z1*nC + z2*nD) % LARGE_PRIME;

		__int64 zz2 = (s1*nK2 + s2) % LARGE_PRIME;
		printf("\t%lu, %lu, \n", (DWORD)s1, (DWORD)s2);
	}
}
	
DWORD HashKey(char* szKey)
{
	DWORD n = 1;
	while(*szKey)
	{
		n = n * (2*(DWORD)*szKey + 1);
		szKey++;
	}
	return n % LARGE_PRIME;
}


LUINT Invert(LUINT n, LUINT p)
{
	LUINT nPower = p-2;
	__int64 nResult = 1;

	for(int i = 31; i >= 0; i--)
	{
		nResult = (nResult*nResult) % p;
		if(nPower & (1 << i))
		{
			nResult = (nResult*n) % p;
		}
	}

	return (LUINT)nResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\aggreg.h ===
//******************************************************************************
//
//  AGGREG.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#ifndef __WBEM_AGGREGATOR__H_
#define __WBEM_AGGREGATOR__H_

#include <stdio.h>
#include <wbemcomn.h>
#include "tss.h"
#include "binding.h"
#include <evaltree.h>
#include "postpone.h"

class CEventAggregator : public COwnedEventSink
{
protected:
    long m_lNumProperties; // immutable
    CPropertyName* m_aProperties; // immutable
    double m_fTolerance; // immutable

    CEssNamespace* m_pNamespace; // immutable
    CEvalTree* m_pHavingTree; // immutable

    CCritSec m_cs;
    static IWbemClassObject* mstatic_pClass;

    class CBucket
    {
    protected:
        IWbemEvent* m_pRepresentative;
        DWORD m_dwCount;
        CVarVector* m_pvvData;
    public:
        CBucket(IWbemEvent* pEvent, CVarVector* pvvData);
        ~CBucket();

        BOOL CompareTo(CVarVector& vv);
        HRESULT AddEvent(IWbemEvent* pEvent);
        HRESULT MakeAggregateEvent(IWbemEvent** ppAggEvent) NOCS;
        CBucket* Clone();
    };

    class CBucketInstruction : public CTimerInstruction
    {
        long m_lRefCount;
        CEventAggregator* m_pAggregator;
        CBucket* m_pBucket;
        CWbemInterval m_Interval;

    public:
        CBucketInstruction(CEventAggregator* pAggregator, CBucket* pBucket,
                            double fMsTimeout);
        ~CBucketInstruction();
        INTERNAL CEventAggregator* GetAggregator() {return m_pAggregator;}

        void AddRef();
        void Release();
        int GetInstructionType();
    
        CWbemTime GetNextFiringTime(CWbemTime LastFiringTime,
            OUT long* plFiringCount) const;
        CWbemTime GetFirstFiringTime() const;
        HRESULT Fire(long lNumTimes, CWbemTime NextFiringTime);
    };

    class CAggregatorInstructionTest : public CInstructionTest
    {
        CEventAggregator* m_pAgg;
    public:
        CAggregatorInstructionTest(CEventAggregator* pAgg) : m_pAgg(pAgg){}

        BOOL operator()(CTimerInstruction* pToTest);
    };

    friend CBucket;
    friend CBucketInstruction;

    CUniquePointerArray<CBucket> m_apBuckets; // changes

public:
    CEventAggregator(CEssNamespace* pNamespace, CAbstractEventSink* pDest);

    ~CEventAggregator();

    HRESULT Deactivate(bool bFire);

    HRESULT SetQueryExpression(CContextMetaData* pMeta, 
                                QL_LEVEL_1_RPN_EXPRESSION* pExpr);

    HRESULT CopyStateTo(CEventAggregator* pOther);
    HRESULT Indicate(long lNumEvents, IWbemEvent** apEvents, 
                        CEventContext* pContext);

    CEventFilter* GetEventFilter() {return m_pOwner->GetEventFilter();}
public:
    static HRESULT Initialize(IWbemServices* pNamespace);
    static HRESULT Shutdown();

protected:
    HRESULT DispatchBucket(CBucket* pBucket);
    HRESULT ComputeAggregationVector(IN IWbemEvent* pEvent,
                                     OUT CVarVector& vv);
    HRESULT Process(IWbemEvent* pEvent);
    HRESULT AddEventToBucket(IWbemEvent* pEvent, 
            ACQUIRE CVarVector* pvv, CBucket** ppCreatedBucket);
    HRESULT PostponeFireAllBuckets();
    HRESULT FireEvent(IWbemClassObject* pAggEvent, bool bRightNow);
    HRESULT PostponeDispatchFirstBucket();
    HRESULT PostponeIndicate(CAbstractEventSink* pDest, IWbemEvent* pEvent);
};

class CPostponedIndicate : public CPostponedRequest
{
protected:
    CAbstractEventSink* m_pDest;
    IWbemEvent* m_pEvent;
public:
    CPostponedIndicate(CAbstractEventSink* pDest, IWbemEvent* pEvent)
        : m_pDest(pDest), m_pEvent(pEvent)
    {
        if(m_pDest)
            m_pDest->AddRef();
        if(m_pEvent)
            m_pEvent->AddRef();
    }
    ~CPostponedIndicate()
    {
        if(m_pDest)
            m_pDest->Release();
        if(m_pEvent)
            m_pEvent->Release();
    }

    HRESULT Execute(CEssNamespace* pNamespace)
    {
        // BUGBUG: context
        if(m_pDest)
            return m_pDest->Indicate(1, &m_pEvent, NULL);
        else
            return WBEM_E_OUT_OF_MEMORY;
    }
};

        
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\aggreg.cpp ===
//******************************************************************************
//
//  AGGREG.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include "ess.h"
#include "aggreg.h"

IWbemClassObject* CEventAggregator::mstatic_pClass = NULL;

CEventAggregator::CEventAggregator(CEssNamespace* pNamespace, 
                                    CAbstractEventSink* pDest)
        : COwnedEventSink(pDest), m_aProperties(NULL), m_pNamespace(pNamespace),
            m_lNumProperties(0), m_pHavingTree(NULL)
{
}

CEventAggregator::~CEventAggregator()
{
    delete [] m_aProperties;
    delete m_pHavingTree;
}

HRESULT CEventAggregator::SetQueryExpression(CContextMetaData* pMeta, 
                                              QL_LEVEL_1_RPN_EXPRESSION* pExpr)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Check that, if aggregation is required, tolerance is specified
    // ==============================================================

    if(!pExpr->bAggregated)
    {
        return WBEM_E_CRITICAL_ERROR; // internal error
    }

    if(pExpr->bAggregated && pExpr->AggregationTolerance.m_bExact)
    {
        ERRORTRACE((LOG_ESS, "Event aggregation query specified GROUP BY, but "
            "not GROUP WITHIN.  This query is invalid and will not be acted "
            "upon\n"));
        return WBEM_E_MISSING_GROUP_WITHIN;
    }

    m_fTolerance = pExpr->AggregationTolerance.m_fTolerance;
    if(m_fTolerance < 0)
        return WBEM_E_INVALID_PARAMETER;

    // Check that all properties are valid
    // ===================================

    if(pExpr->bAggregateAll)
    {
        ERRORTRACE((LOG_ESS, "Aggregating based on all properties of an event "
            "is not supported\n"));
        return WBEM_E_MISSING_AGGREGATION_LIST;
    }

    // Get the class
    // =============

    _IWmiObject* pClass = NULL;
    pMeta->GetClass(pExpr->bsClassName, &pClass);
    if(pClass == NULL)
    {
        return WBEM_E_INVALID_CLASS;
    }
    CReleaseMe rm1(pClass);

    // Allocate the array to hold property names
    // =========================================

    delete [] m_aProperties;
    m_lNumProperties = pExpr->nNumAggregatedProperties;
    m_aProperties = new CPropertyName[m_lNumProperties];
    if(m_aProperties == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    int i;
    for(i = 0; i < pExpr->nNumAggregatedProperties; i++)
    {
        CPropertyName& PropName = pExpr->pAggregatedPropertyNames[i];

        // Check existence
        // ===============

        CIMTYPE ct;
        if(FAILED(pClass->Get((LPWSTR)PropName.GetStringAt(0), 0, NULL, 
                                &ct, NULL)))
        {
            ERRORTRACE((LOG_ESS, "Invalid aggregation property %S --- not a "
                "member of class %S\n", (LPWSTR)PropName.GetStringAt(0),
                pExpr->bsClassName));
                
            return WBEM_E_INVALID_PROPERTY;
        }
  
        if(PropName.GetNumElements() > 1 && ct != CIM_OBJECT)
        {
            return WBEM_E_PROPERTY_NOT_AN_OBJECT;
        }
        if(PropName.GetNumElements() == 1 && ct == CIM_OBJECT)
        {
            return WBEM_E_AGGREGATING_BY_OBJECT;
        }
        m_aProperties[i] = PropName;
    }
            
    // Initialize post-evaluator with the data from the HAVING clause
    // ==============================================================

    QL_LEVEL_1_RPN_EXPRESSION* pHavingExpr = _new QL_LEVEL_1_RPN_EXPRESSION;
    if(pHavingExpr == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    pHavingExpr->SetClassName(L"__AggregateEvent");
    
    for(i = 0; i < pExpr->nNumHavingTokens; i++)
    {
        pHavingExpr->AddToken(pExpr->pArrayOfHavingTokens[i]);
    }

    delete m_pHavingTree;
    m_pHavingTree = new CEvalTree;
    if(m_pHavingTree == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    
    hres = m_pHavingTree->CreateFromQuery(pMeta, pHavingExpr, 0, 0x7FFFFFFF);
    delete pHavingExpr;

    return hres;
}

HRESULT CEventAggregator::Initialize(IWbemServices* pNamespace)
{
    return pNamespace->GetObject(L"__AggregateEvent", 0, GetCurrentEssContext(),
                                    &mstatic_pClass, NULL);
}

HRESULT CEventAggregator::Shutdown()
{
    if(mstatic_pClass)
        mstatic_pClass->Release();
    mstatic_pClass = NULL;

    return WBEM_S_NO_ERROR;
}

HRESULT CEventAggregator::Indicate(long lNumEvents, IWbemEvent** apEvents,
                                    CEventContext* pContext)
{
    HRESULT hresGlobal = S_OK;

    //
    // Note: we are going to lose the event's security context, but that is OK,
    // since the security check has already been done.
    //

    for(long i = 0; i < lNumEvents; i++)
    {
        HRESULT hres = Process(apEvents[i]);
        if(FAILED(hres))
            hresGlobal = hres;
    }

    return hresGlobal;
}

HRESULT CEventAggregator::Process(IWbemEvent* pEvent)
{
    // Compute the event's aggregation vector
    // ======================================

    CVarVector* pvv = _new CVarVector;
    if(pvv == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    HRESULT hres = ComputeAggregationVector(pEvent, *pvv);
    if(FAILED(hres))
    {
        delete pvv;
        return hres;
    }

    // Add event to the right bucket, creating one if needed.
    // THIS CALL ACQUIRES pvv!!!
    // ======================================================

    CBucket* pCreatedBucket = NULL;
    hres = AddEventToBucket(pEvent, pvv, &pCreatedBucket);
    if(FAILED(hres))
    {
        return hres;
    }

    if(pCreatedBucket)
    {
        // Create a timer instruction to empty this bucket
        // ===============================================
        
        CBucketInstruction* pInst = 
            _new CBucketInstruction(this, pCreatedBucket, m_fTolerance);
        if(pInst == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        pInst->AddRef();
        hres = m_pNamespace->GetTimerGenerator().Set(pInst, 
                                                        CWbemTime::GetZero());
        pInst->Release();
        
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Failed to schedule aggregation instruction %p"
                "\n", pInst));
            return hres;
        }
    }
    
    return S_OK;
}

HRESULT CEventAggregator::AddEventToBucket(IWbemEvent* pEvent, 
            ACQUIRE CVarVector* pvv, CBucket** ppCreatedBucket)
{
    // Search for a matching bucket
    // ============================

    CInCritSec ics(&m_cs);

    BOOL bFound = FALSE;
    for(int i = 0; i < m_apBuckets.GetSize(); i++)
    {
        CBucket* pBucket = m_apBuckets[i];
        if(pBucket->CompareTo(*pvv))
        {
            HRESULT hres = pBucket->AddEvent(pEvent);
            delete pvv;
            *ppCreatedBucket = NULL;
            return hres;
        }
    }

    // Need a _new bucket
    // ==================

    CBucket* pBucket = _new CBucket(pEvent, pvv); // takes over pvv
    if(pBucket == NULL)
    {
        delete pvv; 
        return WBEM_E_OUT_OF_MEMORY;
    }

    if(m_apBuckets.Add(pBucket) < 0)
    {
        delete pBucket;
        return WBEM_E_OUT_OF_MEMORY;
    }
    *ppCreatedBucket = pBucket;
    return S_OK;
}

HRESULT CEventAggregator::ComputeAggregationVector(
                                        IN IWbemEvent* pEvent,
                                        OUT CVarVector& vv)
{
    HRESULT hres;
    
    IWbemPropertySource* pPropSource = NULL;
    if(FAILED(pEvent->QueryInterface(IID_IWbemPropertySource, 
        (void**)&pPropSource)))
    {
        return E_NOINTERFACE;
    }

    CReleaseMe rm1(pPropSource);

    // Go through all the properties and add their values to the array
    // ===============================================================

    for(int i = 0; i < m_lNumProperties; i++)
    {
        CPropertyName& PropName = m_aProperties[i];
        
        // Get the value
        // =============

        VARIANT v;
        VariantInit(&v);
        hres = pPropSource->GetPropertyValue(&PropName, 0, NULL, &v);
        if(FAILED(hres))
            return hres;
    
        // Add it to the array
        // ===================

        CVar* pVar = _new CVar;
        if(pVar == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        pVar->SetVariant(&v);
        VariantClear(&v);
        
        if(vv.Add(pVar) < 0)  // ACQUIRES pVar
        {
            delete pVar;
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CEventAggregator::PostponeDispatchFirstBucket()
{
    HRESULT hres;

    //
    // Construct the aggregate event while locked
    //

    IWbemEvent* pAggEvent = NULL;
    {
        CInCritSec ics(&m_cs);

        if(m_apBuckets.GetSize() == 0)
            return WBEM_S_FALSE;

        hres = m_apBuckets[0]->MakeAggregateEvent(&pAggEvent);
        if(FAILED(hres))
            return hres;

        m_apBuckets.RemoveAt(0);
    }

    CReleaseMe rm1(pAggEvent);
    return FireEvent(pAggEvent, false);
}

HRESULT CEventAggregator::DispatchBucket(CBucket* pBucket)
{
    // Search for the bucket
    // =====================
    
    IWbemEvent* pAggEvent = NULL;
    {
        CInCritSec ics(&m_cs);
    
        BOOL bFound = FALSE;
        for(int i = 0; i < m_apBuckets.GetSize(); i++)
        {
            if(m_apBuckets[i] == pBucket)
            {
                // Found it. Construct its event
                // =============================
    
                HRESULT hres = pBucket->MakeAggregateEvent(&pAggEvent);
            
                if(FAILED(hres))
                {
                    ERRORTRACE((LOG_ESS, "Could not create an aggregate event: "
                                    "%X\n", hres));
                    return hres;
                }

                // Delete the bucket
                // =================

                m_apBuckets.RemoveAt(i);
                break;
            }
        }
    }

    if(pAggEvent == NULL)
    {
        // No bucket!
        // ==========

        return WBEM_E_CRITICAL_ERROR; // internal error
    }

    CReleaseMe rm1(pAggEvent);

    //
    // We can fire this event directly on this thread, as it is ours
    //

    return FireEvent(pAggEvent, true);
}

HRESULT CEventAggregator::FireEvent(IWbemClassObject* pAggEvent,
                                    bool bRightNow)
{
    // Constructed aggregate. Decorate it
    // ==================================

    m_pNamespace->DecorateObject(pAggEvent);
    
    // Check HAVING query
    // ==================

    BOOL bResult;
    CSortedArray aTrues;
    IWbemObjectAccess* pAccess;
    pAggEvent->QueryInterface(IID_IWbemObjectAccess, (void**)&pAccess);
    if(FAILED(m_pHavingTree->Evaluate(pAccess, aTrues)))
    {
        bResult = FALSE;
    }
    else
    {
        bResult = (aTrues.Size() > 0);
    }
    pAccess->Release();

    if(bResult)
    {
        // Get destination pointer, protecting from Deactivation
        // =====================================================

        CAbstractEventSink* pDest = NULL;
        {
            CInCritSec ics(&m_cs);
            pDest = m_pOwner;
            if(pDest)
                pDest->AddRef();
        }

        if(pDest)
        {
            if(bRightNow)
                pDest->Indicate(1, &pAggEvent, NULL);
            else
                PostponeIndicate(pDest, pAggEvent);

            pDest->Release();
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CEventAggregator::PostponeIndicate(CAbstractEventSink* pDest,
                                            IWbemEvent* pEvent)
{
    CPostponedList* pList = GetCurrentPostponedEventList();
    if(pList == NULL)
        return pDest->Indicate(1, &pEvent, NULL);

    CPostponedIndicate* pReq = new CPostponedIndicate(pDest, pEvent);
    if(pReq == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    return pList->AddRequest( m_pNamespace, pReq );
}

    
HRESULT CEventAggregator::Deactivate(bool bFire)
{
    HRESULT hres;

    //
    // First remove all timer instructions that may still be scheduled.
    // Timer instructions have a ref-count on us (and therefore our owner),
    // so we may not disconnect until we are done
    //

    CAggregatorInstructionTest Test(this);
    CTimerGenerator& Generator = m_pNamespace->GetTimerGenerator();
    hres = Generator.Remove(&Test);

    //
    // If requested, fire all buckets, albeit not right now
    //

    if(bFire)
        PostponeFireAllBuckets();
        
    Disconnect();
    return hres;
}

HRESULT CEventAggregator::PostponeFireAllBuckets()
{
    HRESULT hres;
    while((hres = PostponeDispatchFirstBucket()) != S_FALSE);

    if(FAILED(hres))
        return hres;
    else
        return WBEM_S_NO_ERROR;
}
        
    
HRESULT CEventAggregator::CopyStateTo(CEventAggregator* pDest)
{
    CInCritSec ics(&m_cs);

    for(int i = 0; i < m_apBuckets.GetSize(); i++)
    {
        CBucket* pNewBucket = m_apBuckets[i]->Clone();
        if(pNewBucket == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        if(pDest->m_apBuckets.Add(pNewBucket) < 0)
        {
            delete pNewBucket;
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    return S_OK;
}
        





CEventAggregator::CBucket::CBucket(IWbemEvent* pEvent, 
                                   CVarVector* pvvData)
    : m_pvvData(pvvData), m_dwCount(1), m_pRepresentative(NULL)
{
    pEvent->Clone(&m_pRepresentative);
}

CEventAggregator::CBucket::~CBucket() 
{
    delete m_pvvData;
    if(m_pRepresentative)
        m_pRepresentative->Release();
}

BOOL CEventAggregator::CBucket::CompareTo(CVarVector& vv)
{
    return m_pvvData->CompareTo(vv, TRUE);
}

HRESULT CEventAggregator::CBucket::AddEvent(IWbemEvent* pEvent)
{
    // Just increment the number of events in the bucket
    // =================================================

    m_dwCount++;
    return WBEM_S_NO_ERROR;
}

HRESULT CEventAggregator::CBucket::MakeAggregateEvent(
                                      IWbemClassObject** ppAggregateEvent) NOCS
{
    HRESULT hres;

    // Create an instance of the aggregate event class
    // ===============================================

    if(mstatic_pClass == NULL)
        return WBEM_E_SHUTTING_DOWN;

    IWbemClassObject* pAgg;
    hres = mstatic_pClass->SpawnInstance(0, &pAgg);
    if(FAILED(hres)) return hres;

    // Fill in the number of events in the bucket
    // ==========================================

    VARIANT v;
    VariantInit(&v);
    V_VT(&v) = VT_I4;
    V_I4(&v) = (long)m_dwCount;

    hres = pAgg->Put(L"NumberOfEvents", 0, &v, NULL);
    if(FAILED(hres)) 
    {
        pAgg->Release();
        return hres;
    }

    // Fill in the representative
    // ==========================

    V_VT(&v) = VT_EMBEDDED_OBJECT;
    V_EMBEDDED_OBJECT(&v) = m_pRepresentative;

    hres = pAgg->Put(L"Representative", 0, &v, NULL);
    if(FAILED(hres)) 
    {
        pAgg->Release();
        return hres;
    }

    *ppAggregateEvent = pAgg;
    return WBEM_S_NO_ERROR;
}

CEventAggregator::CBucket* CEventAggregator::CBucket::Clone()
{
    CVarVector* pNewVv = new CVarVector(*m_pvvData);
    if(pNewVv == NULL)
        return NULL;
    CBucket* pNewBucket = new CBucket(m_pRepresentative, pNewVv);
    if(pNewBucket == NULL)
    {
        delete pNewVv;
        return NULL;
    }
    pNewBucket->m_dwCount = m_dwCount;
    return pNewBucket;
}











CEventAggregator::CBucketInstruction::CBucketInstruction(
            CEventAggregator* pAggregator, CBucket* pBucket, double fSTimeout)
    : m_pAggregator(pAggregator), m_pBucket(pBucket), m_lRefCount(0)
{
    m_Interval.SetMilliseconds(fSTimeout * 1000);
    m_pAggregator->AddRef();
}

CEventAggregator::CBucketInstruction::~CBucketInstruction()
{
    m_pAggregator->Release();
}

void CEventAggregator::CBucketInstruction::AddRef()
{
    InterlockedIncrement(&m_lRefCount);
}

void CEventAggregator::CBucketInstruction::Release()
{
    if(InterlockedDecrement(&m_lRefCount) == 0)
        delete this;
}

int CEventAggregator::CBucketInstruction::GetInstructionType()
{
    return INSTTYPE_AGGREGATION;
}

CWbemTime CEventAggregator::CBucketInstruction::GetNextFiringTime(
        CWbemTime LastFiringTime, OUT long* plFiringCount) const
{
    // Only fires once.
    // ================

    return CWbemTime::GetInfinity();
}

CWbemTime CEventAggregator::CBucketInstruction::GetFirstFiringTime() const
{
    // In "interval" ms from now
    // =========================

    return CWbemTime::GetCurrentTime() + m_Interval;
}

HRESULT CEventAggregator::CBucketInstruction::Fire(long lNumTimes, 
                                                   CWbemTime NextFiringTime)
{
    m_pAggregator->DispatchBucket(m_pBucket);
    return WBEM_S_NO_ERROR;
}

BOOL CEventAggregator::CAggregatorInstructionTest::
operator()(
        CTimerInstruction* pToTest)
{
    if(pToTest->GetInstructionType() == INSTTYPE_AGGREGATION)
    {
        CBucketInstruction* pInst = (CBucketInstruction*)pToTest;
        return (pInst->GetAggregator() == m_pAgg);
    }
    else return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\clscache.h ===
//******************************************************************************
//
//  CLSCACHE.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************
#ifndef __WMI_ESS_CLASS_CACHE__H_
#define __WMI_ESS_CLASS_CACHE__H_

#include <parmdefs.h>
#include <wbemcomn.h>
#include <wbemint.h>
#include <map>
#include <wstlallc.h>

class CEssNamespace;

class CEssClassCache
{
protected:
    typedef std::map<WString,_IWmiObject*, WSiless, wbem_allocator<_IWmiObject*> > TClassMap;
    typedef TClassMap::iterator TIterator;

    TClassMap m_mapClasses;
    CEssNamespace* m_pNamespace;
    CCritSec m_cs;

public:
    CEssClassCache(CEssNamespace* pNamespace) : m_pNamespace(pNamespace){}
    ~CEssClassCache();

    HRESULT GetClass( LPCWSTR wszClassName, IWbemContext* pContext,
                      _IWmiObject** ppClass );
    HRESULT Clear();
};
        
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\consprov.cpp ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  CONPROV.CPP
//
//  This file implements the classes for event consumer provider caching.
//
//  Classes implemented:
//
//      CConsumerProviderRecord  --- a single consumer provider record
//      CConsumerProviderCache  --- a collection of records.
//
//  History:
//
//  11/27/96    a-levn      Compiles.
//
//=============================================================================
#include "precomp.h"
#include "ess.h"
#include "consprov.h"
#include <provinit.h>
#include <genutils.h>
#include <cominit.h>
#include "NCEvents.h"

CConsumerProviderRecord::CConsumerProviderRecord(CEssNamespace* pNamespace)
        : m_pLogicalProvider(NULL), m_pConsumerProvider(NULL),
        m_pSink(NULL), m_bResolved(FALSE), m_pNamespace(pNamespace),
        m_lRef(0), m_wszMachineName(NULL), m_wszProviderName(NULL), 
        m_wszProviderRef(NULL), m_bAnonymous(FALSE)
{
    m_pNamespace->AddRef();
}



HRESULT CConsumerProviderRecord::Initialize(
                                    IWbemClassObject* pLogicalProvider,
                                    LPCWSTR wszProviderRef,
                                    LPCWSTR wszProviderName,
                                    LPCWSTR wszMachineName)
{
    m_LastAccess = CWbemTime::GetCurrentTime();

    m_pLogicalProvider = pLogicalProvider;
    m_pLogicalProvider->AddRef();

    if(wszMachineName)
        m_wszMachineName = CloneWstr(wszMachineName);

    m_wszProviderName = CloneWstr(wszProviderName);
    m_wszProviderRef = CloneWstr(wszProviderRef);

    if(m_wszProviderName == NULL || m_wszProviderRef == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    // Extract the CLSID
    // =================

    VARIANT vClassId;
    VariantInit(&vClassId);
    CClearMe cm(&vClassId);

    HRESULT hres = pLogicalProvider->Get(CONSPROV_CLSID_PROPNAME, 0, &vClassId, 
                        NULL, NULL);

    if(FAILED(hres) || V_VT(&vClassId) != VT_BSTR) 
    {
        ERRORTRACE((LOG_ESS, "Class ID is missing from consumer "
            "provider record!!\n"));
        return hres;
    }

    if(FAILED(CLSIDFromString(V_BSTR(&vClassId), &m_clsid)))
    {
        ERRORTRACE((LOG_ESS, "INVALID Class ID in consumer "
            "provider record!!\n"));
        return WBEM_E_INVALID_PROVIDER_REGISTRATION;
    }

    return WBEM_S_NO_ERROR;
}

CConsumerProviderRecord::~CConsumerProviderRecord()
{
    _DBG_ASSERT( m_pNamespace != NULL );

    if(m_pLogicalProvider)
        m_pLogicalProvider->Release();
    if(m_pSink)
        m_pNamespace->PostponeRelease(m_pSink);
    if(m_pConsumerProvider)
        m_pNamespace->PostponeRelease(m_pConsumerProvider);
    
    if(m_pSink || m_pConsumerProvider)
    {
        //
        // Report the MSFT_WmiConsumerProviderUnloaded event.
        //
        FIRE_NCEVENT(
            g_hNCEvents[MSFT_WmiConsumerProviderUnloaded], 
            WMI_SENDCOMMIT_SET_NOT_REQUIRED,

            // Data follows...
            m_pNamespace->GetName(),
            m_wszProviderName,
            m_wszMachineName);
    }
    
    if(m_pNamespace)
        m_pNamespace->Release();
    delete [] m_wszMachineName;
    delete [] m_wszProviderName;
    delete [] m_wszProviderRef;
}

long CConsumerProviderRecord::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

long CConsumerProviderRecord::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

void CConsumerProviderRecord::Invalidate()
{
    IWbemUnboundObjectSink* pSink;
    IWbemEventConsumerProvider* pConsumerProvider;

    {
        CInCritSec ics(&m_cs);

        pSink = m_pSink;
        m_pSink = NULL;

        pConsumerProvider = m_pConsumerProvider;
        m_pConsumerProvider = NULL;

        m_bResolved = FALSE;
    }
        
    _DBG_ASSERT( m_pNamespace != NULL );

    if (pSink)
        m_pNamespace->PostponeRelease(pSink);
    
    if (pConsumerProvider)
        m_pNamespace->PostponeRelease(pConsumerProvider);

    if (pConsumerProvider || pSink)
    {
        //
        // Report the MSFT_WmiConsumerProviderUnloaded event.
        //
        FIRE_NCEVENT(
            g_hNCEvents[MSFT_WmiConsumerProviderUnloaded], 
            WMI_SENDCOMMIT_SET_NOT_REQUIRED,

            // Data follows...
            m_pNamespace->GetName(),
            m_wszProviderName,
            m_wszMachineName);
    }    
}

HRESULT CConsumerProviderRecord::ValidateConsumer(
                                    IWbemClassObject* pLogicalConsumer)
{
    HRESULT hres;

    // Check if consumer provider is cached
    // ====================================

    IWbemEventConsumerProvider* pConsumerProvider = NULL;
    IWbemEventConsumerProviderEx* pConsumerProviderEx = NULL;

    BOOL bResolved = FALSE;
    
    {
        CInCritSec ics(&m_cs);
        m_LastAccess = CWbemTime::GetCurrentTime();

        if(m_bResolved)
        {
            if(m_pConsumerProviderEx)
            {
                pConsumerProviderEx = m_pConsumerProviderEx;
                pConsumerProviderEx->AddRef();
            }
            else
            {
                pConsumerProvider = m_pConsumerProvider;
                if(pConsumerProvider)
                    pConsumerProvider->AddRef();
            }

            bResolved = TRUE;
        }
    }

    // Resolve if not cached
    // =====================

    if(!bResolved)
    {
        IWbemUnboundObjectSink* pGlobalSink;

        hres = ResolveAndCache(&pGlobalSink, &pConsumerProvider, 
                                &pConsumerProviderEx);
        if(FAILED(hres)) return hres;

        if(pGlobalSink)
            pGlobalSink->Release();
    }

    CReleaseMe rm1(pConsumerProvider);
    CReleaseMe rm2(pConsumerProviderEx);

    if(pConsumerProvider == NULL && pConsumerProviderEx)
    {
        //
        // Clearly, this consumer does not support validation
        //

        return WBEM_S_FALSE;
    }

    try
    {
        if(pConsumerProviderEx)
        {
            hres = pConsumerProviderEx->ValidateSubscription(pLogicalConsumer);
        }
        else
        {
            //
            // Old-type provider --- we can still achieve validation by calling
            // FindConsumer --- it might reject this consumer at that time
            //

            IWbemUnboundObjectSink* pSink = NULL;
            hres = pConsumerProvider->FindConsumer(pLogicalConsumer, &pSink);
            if(SUCCEEDED(hres) && pSink)
                pSink->Release();
        }
    }
    catch(...)
    {
        ERRORTRACE((LOG_ESS, "Event consumer provider %S in namespace %S "
            "threw an exception in ValidateConsumer/FindConsumer\n", 
                m_wszProviderName, m_pNamespace->GetName()));
        hres = WBEM_E_PROVIDER_FAILURE;
    }

    return hres;
}
    

HRESULT CConsumerProviderRecord::GetGlobalObjectSink(
                OUT IWbemUnboundObjectSink** ppSink, 
                IN IWbemClassObject *pLogicalProvider)
{
    *ppSink = NULL;

    // Check of a cached version is available
    // ======================================

    {
        CInCritSec ics(&m_cs);
        m_LastAccess = CWbemTime::GetCurrentTime();

        if(m_bResolved)
        {
            // It is --- return it
            // ===================

            *ppSink = m_pSink;
            if(m_pSink)
                m_pSink->AddRef();
            return WBEM_S_NO_ERROR;
        }
    }

    // No cached version --- retrieve it
    // =================================

    IWbemUnboundObjectSink* pSink;
    IWbemEventConsumerProvider* pConsumerProvider;
    IWbemEventConsumerProviderEx* pConsumerProviderEx;

    HRESULT hres = ResolveAndCache(&pSink, &pConsumerProvider, 
                                    &pConsumerProviderEx);
    if(FAILED(hres))
        return hres;

    if(pConsumerProvider)
        pConsumerProvider->Release();
    if(pConsumerProviderEx)
        pConsumerProviderEx->Release();
    
    *ppSink = pSink;

    if (*ppSink != NULL)
    {
        //
        // Report the MSFT_WmiConsumerProviderSinkLoaded event.
        //
        FireNCSinkEvent(
            MSFT_WmiConsumerProviderSinkLoaded,
            pLogicalProvider);
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CConsumerProviderRecord::ResolveAndCache(
                            IWbemUnboundObjectSink** ppSink,
                            IWbemEventConsumerProvider** ppConsumerProvider,
                            IWbemEventConsumerProviderEx** ppConsumerProviderEx)
{
    // Resolve it first
    // ================

    HRESULT hres = Resolve(ppSink, ppConsumerProvider, ppConsumerProviderEx);
    if(FAILED(hres))
        return hres;

    // Cache if needed
    // ===============

    {
        CInCritSec ics(&m_cs);
        m_LastAccess = CWbemTime::GetCurrentTime();
        
        if(m_bResolved)
        {
            // Already cached.  Release ours. 
            // ==============================

            if(*ppSink)
                (*ppSink)->Release();
            if(*ppConsumerProvider)
                (*ppConsumerProvider)->Release();
            if(*ppConsumerProviderEx)
                (*ppConsumerProviderEx)->Release();

            // Use the cached one
            // ==================

            *ppSink = m_pSink;
            if(m_pSink)
                m_pSink->AddRef();

            *ppConsumerProvider = m_pConsumerProvider;
            if(m_pConsumerProvider)
                m_pConsumerProvider->AddRef();

            *ppConsumerProviderEx = m_pConsumerProviderEx;
            if(m_pConsumerProviderEx)
                m_pConsumerProviderEx->AddRef();
        }
        else
        {
            // Cache it
            // ========

            m_pSink = *ppSink;
            if(m_pSink)
                m_pSink->AddRef();

            m_pConsumerProvider = *ppConsumerProvider;
            if(m_pConsumerProvider)
                m_pConsumerProvider->AddRef();

            m_pConsumerProviderEx = *ppConsumerProviderEx;
            if(m_pConsumerProviderEx)
                m_pConsumerProviderEx->AddRef();
    
            m_bResolved = TRUE;
        }
    }

    return S_OK;
}

void CConsumerProviderRecord::FireNCSinkEvent(
    DWORD dwIndex, 
    IWbemClassObject *pLogicalConsumer)
{
    if (IS_NCEVENT_ACTIVE(dwIndex))
    {
        // Get the path of the logical consumer.
        VARIANT vPath;
        BSTR    strLogicalConsumerPath;
            
        VariantInit(&vPath);

        if (pLogicalConsumer && 
            SUCCEEDED(pLogicalConsumer->Get(L"__PATH", 0, &vPath, NULL, NULL)))
            strLogicalConsumerPath = V_BSTR(&vPath);
        else
            strLogicalConsumerPath = NULL;

        //
        // Report the event.
        //
        FIRE_NCEVENT(
            g_hNCEvents[dwIndex], 
            WMI_SENDCOMMIT_SET_NOT_REQUIRED,

            // Data follows...
            m_pNamespace->GetName(),
            m_wszProviderName,
            m_wszMachineName,
            strLogicalConsumerPath);
            
        VariantClear(&vPath);
    }
}

HRESULT CConsumerProviderRecord::FindConsumer(
                IN IWbemClassObject* pLogicalConsumer,
                OUT IWbemUnboundObjectSink** ppSink)
{
    HRESULT hres;

    // Check if consumer provider is cached
    // ====================================

    IWbemEventConsumerProvider* pConsumerProvider = NULL;
    BOOL bResolved = FALSE;
    
    {
        CInCritSec ics(&m_cs);
        m_LastAccess = CWbemTime::GetCurrentTime();

        if(m_bResolved)
        {
            pConsumerProvider = m_pConsumerProvider;
            if(pConsumerProvider)
                pConsumerProvider->AddRef();

            bResolved = TRUE;
        }
    }

    // Resolve if not cached
    // =====================

    if(!bResolved)
    {
        IWbemUnboundObjectSink* pGlobalSink;
        IWbemEventConsumerProviderEx* pConsumerProviderEx = NULL;

        hres = ResolveAndCache(&pGlobalSink, &pConsumerProvider, 
                                    &pConsumerProviderEx);
        if(FAILED(hres)) return hres;

        if(pGlobalSink)
            pGlobalSink->Release();
        if(pConsumerProviderEx)
            pConsumerProviderEx->Release();
    }

    if(pConsumerProvider == NULL)
        return E_NOINTERFACE;

    try
    {
        hres = pConsumerProvider->FindConsumer(pLogicalConsumer, ppSink);
    }
    catch(...)
    {
        ERRORTRACE((LOG_ESS, "Event consumer provider %S in namespace %S "
            "threw an exception in FindConsumer\n", 
                m_wszProviderName, m_pNamespace->GetName()));
        hres = WBEM_E_PROVIDER_FAILURE;
    }

    if(SUCCEEDED(hres) && ppSink != NULL)
    {
        if(*ppSink == NULL)
        {
            ERRORTRACE((LOG_ESS, "Event consumer provider %S in namespace %S "
                "returned success from IWbemEventConsumerProvider::FindConsumer"
                " call while returning a NULL sink.  This behavior is invalid! "
                " Consumers will not receive events.\n", 
                m_wszProviderName, m_pNamespace->GetName()));
            return E_NOINTERFACE;
        }

        //
        // Report the MSFT_WmiConsumerProviderSinkLoaded event.
        //
        FireNCSinkEvent(
            MSFT_WmiConsumerProviderSinkLoaded,
            pLogicalConsumer);


        // Configure proxy settings
        // ========================

        if(m_bAnonymous)
        {
            hres = SetInterfaceSecurity(*ppSink, NULL, NULL, NULL,
                        RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_ANONYMOUS);
        }
        else
        {
            hres = WbemSetDynamicCloaking(*ppSink, RPC_C_AUTHN_LEVEL_CONNECT,
                        RPC_C_IMP_LEVEL_IDENTIFY);
        }
        if(FAILED(hres))
            return hres;
        else
            hres = WBEM_S_NO_ERROR;

    }
    pConsumerProvider->Release();

    return hres;
}

HRESULT CConsumerProviderRecord::Resolve(
                            IWbemUnboundObjectSink** ppSink,
                            IWbemEventConsumerProvider** ppConsumerProvider,
                            IWbemEventConsumerProviderEx** ppConsumerProviderEx)
{
    HRESULT hres;

    // Prepare for CoCreateInstance(Ex)
    // ================================

    COSERVERINFO* pServerInfo = NULL;
    DWORD dwClsCtx;
    if(m_wszMachineName)
    {
        pServerInfo = _new COSERVERINFO;
        if(pServerInfo == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        pServerInfo->pwszName = m_wszMachineName;
        pServerInfo->pAuthInfo = NULL;
        pServerInfo->dwReserved1 = 0;
        pServerInfo->dwReserved2 = 0;
        dwClsCtx = CLSCTX_REMOTE_SERVER | CLSCTX_LOCAL_SERVER;
    }
    else
    {
        dwClsCtx = CLSCTX_ALL;
    }

    CDeleteMe<COSERVERINFO> dm(pServerInfo);
    
    IUnknown* pProtoSink = NULL;
    if(m_wszMachineName)
    {
        //
        // Remote activation --- do everything ourselves
        //

        IClassFactory* pFactory;
        hres = WbemCoGetClassObject(m_clsid, dwClsCtx, pServerInfo,
                                IID_IClassFactory, (void**)&pFactory);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, 
                "Failed to get a class factory for CLSID on server %S.  "
                        "Return code %X\n",
                (pServerInfo?pServerInfo->pwszName:L"(local)"), hres));
            return hres;
        }
        CReleaseMe rm0(pFactory);
    
        if(pFactory == NULL)
        {
            ERRORTRACE((LOG_ESS, "NULL Class Factory received from event consumer "
                "%S.  Consumer needs to have its code examined\n", 
                m_wszProviderName));
    
            return WBEM_E_PROVIDER_LOAD_FAILURE;
        }
                
        // Get the instance
        // ================
    
        hres = pFactory->CreateInstance(NULL, IID_IUnknown, (void**)&pProtoSink);
        if(FAILED(hres)) 
        {
            //
            // Try again at lower security
            //
            
            SetInterfaceSecurity(pFactory, NULL, NULL, NULL,
                            RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_ANONYMOUS);
            hres = pFactory->CreateInstance(NULL, IID_IUnknown, (void**)&pProtoSink);
            if(SUCCEEDED(hres))
                m_bAnonymous = TRUE;
        }
        if(FAILED(hres)) 
        {
            ERRORTRACE((LOG_ESS, 
                "Failed to create an instance from a class factory for %S. "
                " Return code: %X\n", m_wszProviderName, hres));
            return hres;
        }
        if(pProtoSink == NULL)
        {
            ERRORTRACE((LOG_ESS, "NULL object received from event consumer "
                "%S factory.  Consumer needs to have its code examined\n", 
                m_wszProviderName));
    
            return WBEM_E_PROVIDER_LOAD_FAILURE;
        }
    }
    else // not REMOTE_SERVER
    {
        //
        // Use PSS
        //

        hres = m_pNamespace->LoadConsumerProvider(m_wszProviderName, 
                                    &pProtoSink);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "ESS unable to load consumer provider %S from "
                            "provider subsystem: 0x%X\n", 
                        (LPCWSTR)m_wszProviderName, hres));
            return hres;
        }
    }

    CReleaseMe rm1(pProtoSink);

    if(m_bAnonymous)
        SetInterfaceSecurity(pProtoSink, NULL, NULL, NULL,
                        RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_ANONYMOUS);
        

    // Query for the interfaces
    // ========================

    *ppSink = NULL;
    hres = pProtoSink->QueryInterface(IID_IWbemUnboundObjectSink, 
                            (void**)ppSink);
    if(FAILED(hres))
    {
        DEBUGTRACE((LOG_ESS, 
            "Consumer provider %S does not support "
                    "IWbemUnboundObjectSink: error code %X\n", 
                        m_wszProviderName, hres));
    }
    else
    {
        if(*ppSink == NULL)
        {
            ERRORTRACE((LOG_ESS, "NULL object received from event consumer "
                "%S QueryInterface. Consumer needs to have its code examined\n",
                m_wszProviderName));
    
            return WBEM_E_PROVIDER_LOAD_FAILURE;
        }

        // Configure proxy settings
        // ========================

        if(m_bAnonymous)
        {
            hres = SetInterfaceSecurity(*ppSink, NULL, NULL, NULL,
                        RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_ANONYMOUS);
        }
        else
        {
            hres = WbemSetDynamicCloaking(*ppSink, RPC_C_AUTHN_LEVEL_CONNECT,
                        RPC_C_IMP_LEVEL_IDENTIFY);
        }
        if(FAILED(hres))
            return hres;
    }

    *ppConsumerProvider = NULL;
    hres = pProtoSink->QueryInterface(IID_IWbemEventConsumerProvider, 
                            (void**)ppConsumerProvider);
    if(FAILED(hres))
    {
    }
    else if(*ppConsumerProvider == NULL)
    {
        ERRORTRACE((LOG_ESS, "NULL object received from event consumer "
            "%S QueryInterface.  Consumer needs to have its code examined\n", 
            m_wszProviderName));

        return WBEM_E_PROVIDER_LOAD_FAILURE;
    }
    else
    {
        if(m_bAnonymous)
            SetInterfaceSecurity(*ppConsumerProvider, NULL, NULL, NULL,
                        RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_ANONYMOUS);
    }

    *ppConsumerProviderEx = NULL;
    hres = pProtoSink->QueryInterface(IID_IWbemEventConsumerProviderEx, 
                            (void**)ppConsumerProviderEx);
    if(FAILED(hres))
    {
    }
    else if(*ppConsumerProviderEx == NULL)
    {
        ERRORTRACE((LOG_ESS, "NULL object received from event consumer "
            "%S QueryInterface.  Consumer needs to have its code examined\n", 
            m_wszProviderName));

        return WBEM_E_PROVIDER_LOAD_FAILURE;
    }
    else
    {
        if(m_bAnonymous)
            SetInterfaceSecurity(*ppConsumerProviderEx, NULL, NULL, NULL,
                        RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_ANONYMOUS);
    }

#if 0
    // Check if initialization is desired
    // ==================================

    IWbemProviderInit* pInit;
    if(SUCCEEDED(pProtoSink->QueryInterface(IID_IWbemProviderInit, 
                                            (void**)&pInit)))
    {
        if(pInit == NULL)
        {
            ERRORTRACE((LOG_ESS, "NULL object received from event consumer "
                "%S factory.  Consumer needs to have its code examined\n", 
                m_wszProviderName));
    
            return WBEM_E_PROVIDER_LOAD_FAILURE;
        }
    
        if(m_bAnonymous)
            SetInterfaceSecurity(pInit, NULL, NULL, NULL,
                        RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_ANONYMOUS);

        CReleaseMe rm2(pInit);

        CProviderInitSink* pSink = new CProviderInitSink;
        if(pSink == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        pSink->AddRef();
        CReleaseMe rm3(pSink);

        // Retrieve a namespace pointer suitable for providers
        // ===================================================

        IWbemServices* pServices = NULL;
        hres = m_pNamespace->GetProviderNamespacePointer(&pServices);
        if(FAILED(hres))
            return hres;
        CReleaseMe rm4(pServices);

        hres = pInit->Initialize(NULL, 0, (LPWSTR)m_pNamespace->GetName(), 
                            NULL, pServices, NULL, pSink);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Event consumer provider %S failed to "
                                "initialize: 0x%X\n", m_wszProviderName,
                                                            hres));
            return hres;
        }
    
        hres = pSink->WaitForCompletion();
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Event consumer provider %S failed to "
                                "initialize: 0x%X\n", m_wszProviderName, hres));
            return hres;
        }
    }

#endif
   
    // Inform the cache that unloading may be required
    // ===============================================

    m_pNamespace->GetConsumerProviderCache().EnsureUnloadInstruction();

    //
    // Report the MSFT_WmiConsumerProviderLoaded event.
    //
    FIRE_NCEVENT(
        g_hNCEvents[MSFT_WmiConsumerProviderLoaded], 
        WMI_SENDCOMMIT_SET_NOT_REQUIRED,

        // Data follows...
        m_pNamespace->GetName(),
        m_wszProviderName,
        m_wszMachineName);

    return S_OK;
}
    


CConsumerProviderCache::~CConsumerProviderCache()
{
    if(m_pInstruction)
    {
        m_pInstruction->Terminate();
        m_pInstruction->Release();
    }
}

BOOL CConsumerProviderCache::DoesContain(IWbemClassObject* pProvReg, 
                                            IWbemClassObject* pConsumerReg)
{
    HRESULT hres;

    // Get its class list
    // ==================

    VARIANT v;
    VariantInit(&v);
    CClearMe cm(&v);

    hres = pProvReg->Get(L"ConsumerClassNames", 0, &v, NULL, NULL);

    if(SUCCEEDED(hres) && V_VT(&v) == (VT_BSTR | VT_ARRAY))
    {
        SAFEARRAY* psa = V_ARRAY(&v);
        long lLBound, lUBound;
        BSTR* astrData;
        SafeArrayGetLBound(psa, 1, &lLBound);
        SafeArrayGetUBound(psa, 1, &lUBound);
        SafeArrayAccessData(psa, (void**)&astrData);
        CUnaccessMe um(psa);
        
        for(int i = 0; i <= lUBound - lLBound; i++)
        {
            if(pConsumerReg->InheritsFrom(astrData[i]) == S_OK)
                return TRUE;
        }
    }

    return FALSE;
}
            
//
// Need a class for dynamic enumeration of consumer provider registrations
//

class CProviderRegistrationSink : public CObjectSink
{
protected:
    CConsumerProviderCache* m_pCache;
    IWbemClassObject* m_pLogicalConsumer;
    IWbemClassObject** m_ppReg;
public:
    CProviderRegistrationSink(CConsumerProviderCache* pCache, 
        IWbemClassObject* pLogicalConsumer, IWbemClassObject** ppReg) : 
            m_pCache(pCache), m_pLogicalConsumer(pLogicalConsumer),
            m_ppReg(ppReg)
    {
        AddRef();
        // same thread --- no need to AddRef paramters
    }
    ~CProviderRegistrationSink(){}
    STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects)
    {
        for(long i = 0; i < lNumObjects; i++)
        {
            //
            // Check if this one is ours
            //

            if(m_pCache->DoesContain(apObjects[i], m_pLogicalConsumer))
            {
                *m_ppReg = apObjects[i];
                (*m_ppReg)->AddRef();
                return WBEM_E_CALL_CANCELLED;
            }
        }
        return WBEM_S_NO_ERROR;
    }
};


INTERNAL CConsumerProviderRecord*
CConsumerProviderCache::GetRecord(IN IWbemClassObject* pLogicalConsumer)
{
    CInCritSec ics(&m_cs);
    HRESULT hres;

    //
    // Enumerate all the registrations into a sink that will check if this
    // one is the right one
    //


    IWbemClassObject* pReg = NULL;
    CProviderRegistrationSink Sink(this, pLogicalConsumer, &pReg);

    hres = m_pNamespace->CreateInstanceEnum(
        CONSUMER_PROVIDER_REGISTRATION_CLASS, 0, &Sink);

    if(pReg == NULL)
    {
        // Not found
        return NULL;
    }
    
    CReleaseMe rm1(pReg);

    // Get the Win32Provider record
    // ============================

    VARIANT vPath;
    hres = pReg->Get(CONSPROV_PROVIDER_REF_PROPNAME, 0, &vPath, NULL, NULL);
    if(FAILED(hres) || V_VT(&vPath) != VT_BSTR)
    {
        ERRORTRACE((LOG_ESS, "Event consumer provider registration is invalid: "
                                "Provider property is missing\n"));
        return NULL;
    }

    INTERNAL BSTR strProviderRef = V_BSTR(&vPath);
    CClearMe cm2(&vPath);

    _IWmiObject* pProv = NULL;
    hres = m_pNamespace->GetInstance(V_BSTR(&vPath), &pProv);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Invalid event consumer provider registration: "
                                "dangling provider reference %S\n", 
                                    V_BSTR(&vPath)));
        return NULL;
    }

    CReleaseMe rm(pProv);

    // Get the name of the provider
    // ============================

    VARIANT vProvName;
    VariantInit(&vProvName);
    CClearMe cm3(&vProvName);

    hres = pProv->Get(PROVIDER_NAME_PROPNAME, 0, &vProvName, NULL, NULL);
    if(FAILED(hres) || V_VT(&vProvName) != VT_BSTR)
    {
        ERRORTRACE((LOG_ESS, "Event provider registration without a name at "
                        "%S\n", V_BSTR(&vPath)));
        return NULL;
    }
    INTERNAL BSTR strProviderName = V_BSTR(&vProvName);

    // Get the machine name 
    // ====================

    VARIANT vMachine;
    VariantInit(&vMachine);
    CClearMe cm4(&vMachine);

    hres = pLogicalConsumer->Get(CONSUMER_MACHINE_NAME_PROPNAME, 0, &vMachine, 
                                    NULL, NULL);
    if(FAILED(hres)) return NULL;

    INTERNAL BSTR strMachineName = NULL;
    if(V_VT(&vMachine) != VT_NULL)
        strMachineName = V_BSTR(&vMachine);

    // Search for the record
    // =====================

    BOOL bFound = FALSE;
    CConsumerProviderRecord* pRecord;
    for(int i = 0; i < m_apRecords.GetSize(); i++)
    {
        pRecord = m_apRecords[i];

        if(_wcsicmp(pRecord->GetProviderName(), strProviderName))
            continue;
        if(pRecord->GetMachineName() && strMachineName)
        {
            if(_wcsicmp(pRecord->GetMachineName(), strMachineName))
                continue;
        }
        else
        {
            if(pRecord->GetMachineName() != strMachineName)
                continue;
        }

        bFound = TRUE;
        break;
    }

    if(!bFound)
    {
        pRecord = new CConsumerProviderRecord(m_pNamespace);
        if(pRecord == NULL)
            return NULL;
        hres = pRecord->Initialize(pProv, strProviderRef, strProviderName, 
                                    strMachineName);
        if(m_apRecords.Add(pRecord) < 0)
        {
            delete pRecord;
            return NULL;
        }
    }

    pRecord->AddRef();
    return pRecord;
}

void CConsumerProviderCache::EnsureUnloadInstruction()
{
    CInCritSec ics(&m_cs);

    if(m_pInstruction == NULL)
    {
        m_pInstruction = new CConsumerProviderWatchInstruction(this);
        if(m_pInstruction)
        {
            m_pInstruction->AddRef();
            m_pNamespace->GetTimerGenerator().Set(m_pInstruction);
        }
    }
}

    
HRESULT CConsumerProviderCache::UnloadUnusedProviders(CWbemInterval Interval)
{
    CRefedPointerArray<CConsumerProviderRecord> apToInvalidate;
    BOOL bUnloaded = FALSE;

    {
        CInCritSec ics(&m_cs);
    
        BOOL bActiveLeft = FALSE;
        for(int i = 0; i < m_apRecords.GetSize(); i++)
        {
            CConsumerProviderRecord* pRecord = m_apRecords[i];
        
            // Prevent the record from being used while its fate is determined
            // ===============================================================
    
            if(pRecord->IsActive())
            {
                if(CWbemTime::GetCurrentTime() - pRecord->GetLastAccess() > 
                        Interval)
                {
                    apToInvalidate.Add(pRecord);
                    DEBUGTRACE((LOG_ESS, "Unloading consumer provider %S on "
                        "%S\n", pRecord->GetProviderName(), 
                                pRecord->GetMachineName()));
                    bUnloaded = TRUE;
                }
                else
                    bActiveLeft = TRUE;
            }
        }

        if(m_pInstruction && !bActiveLeft)
        {
            m_pInstruction->Terminate();
            m_pInstruction->Release();
            m_pInstruction = NULL;
        }
    }
    
    // Actually unload
    // ===============

    for(int i = 0; i < apToInvalidate.GetSize(); i++)
    {
        apToInvalidate[i]->Invalidate();
    }

    if(bUnloaded)
        m_pNamespace->GetTimerGenerator().ScheduleFreeUnusedLibraries();
    return WBEM_S_NO_ERROR;
}

HRESULT CConsumerProviderCache::RemoveConsumerProvider(LPCWSTR wszProviderRef)
{
    CInCritSec ics(&m_cs);
    for(int i = 0; i < m_apRecords.GetSize(); i++)
    {
        CConsumerProviderRecord* pRecord = m_apRecords[i];
    
        if(!_wcsicmp(pRecord->GetProviderRef(), wszProviderRef))
        {
            // Matches --- remove
            // ==================

            DEBUGTRACE((LOG_ESS, "Removing consumer provider record: %S in %S"
                "\n", m_pNamespace->GetName(), wszProviderRef));

            m_apRecords.RemoveAt(i);
            i--;
        }
    }

    return WBEM_S_NO_ERROR;
}

// static
SYSFREE_ME BSTR CConsumerProviderCache::GetProviderRefFromRecord(
                        IWbemClassObject* pReg)
{
    VARIANT v;
    VariantInit(&v);
    if(FAILED(pReg->Get(CONSPROV_PROVIDER_REF_PROPNAME, 0, &v, NULL, NULL)) || 
            V_VT(&v) != VT_BSTR)
    {
        VariantClear(&v);
        return NULL;
    }
    else
    {
        // Variant intentionally not cleared
        return V_BSTR(&v);
    }
}

class CSingleElementSink : public CObjectSink
{
protected:
    IWbemClassObject** m_ppObj;
public:
    CSingleElementSink(IWbemClassObject** ppObj) : m_ppObj(ppObj)
    {
        AddRef();
    }

    STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects)
    {
        if(lNumObjects > 0)
        {
            *m_ppObj = apObjects[0];
            apObjects[0]->AddRef();
        }
        return S_OK;
    }
};



HRESULT CConsumerProviderCache::GetConsumerProviderRegFromProviderReg(
                        IWbemClassObject* pProv, 
                        IWbemClassObject** ppConsProv)
{
    HRESULT hres;

    // Get the path
    // ============

    VARIANT vPath;
    VariantInit(&vPath);
    if(FAILED(pProv->Get(L"__RELPATH", 0, &vPath, NULL, NULL)) || 
             V_VT(&vPath) != VT_BSTR)
    {
        return WBEM_E_INVALID_PROVIDER_REGISTRATION;
    }
    
    WString wsPath = WString(V_BSTR(&vPath)).EscapeQuotes();
    VariantClear(&vPath);

    // Construct the query
    // ===================

    BSTR strQuery = 
        SysAllocStringLen(NULL, wsPath.Length()*2 + 100);
    CSysFreeMe sfm(strQuery);

    swprintf(strQuery, 
            L"select * from " CONSUMER_PROVIDER_REGISTRATION_CLASS L" where "
                L"Provider = \"%s\"",  (LPWSTR)wsPath);
    
    // Issue the query
    // ===============

    *ppConsProv = NULL;
    CSingleElementSink Sink(ppConsProv);
    hres = m_pNamespace->ExecQuery(strQuery, 0, &Sink);
    if(FAILED(hres))
        return hres;
    else if(*ppConsProv == NULL)
        return WBEM_E_NOT_FOUND;
    else 
        return WBEM_S_NO_ERROR;
}
    
void CConsumerProviderCache::Clear()
{
    CInCritSec ics(&m_cs);

    m_apRecords.RemoveAll();
    if(m_pInstruction)
    {
        m_pInstruction->Terminate();
        m_pInstruction->Release();
        m_pInstruction = NULL;
    }
}

    
void CConsumerProviderCache::DumpStatistics(FILE* f, long lFlags)
{
    fprintf(f, "%d consumer provider records\n", m_apRecords.GetSize());
}

// static 
CWbemInterval CConsumerProviderWatchInstruction::mstatic_Interval;
void CConsumerProviderWatchInstruction::staticInitialize(IWbemServices* pRoot)
{
    mstatic_Interval = 
            CBasicUnloadInstruction::staticRead(pRoot, GetCurrentEssContext(),
                                L"__EventConsumerProviderCacheControl=@");
}

CConsumerProviderWatchInstruction::CConsumerProviderWatchInstruction(
                                                CConsumerProviderCache* pCache)
    : CBasicUnloadInstruction(mstatic_Interval), m_pCache(pCache)
{}

HRESULT CConsumerProviderWatchInstruction::Fire(long, CWbemTime)
{
    if(!m_bTerminate)
    {
        CEssThreadObject Obj(NULL);
        SetConstructedEssThreadObject(&Obj);
    
        m_pCache->UnloadUnusedProviders(m_Interval);

        m_pCache->m_pNamespace->FirePostponedOperations();
        ClearCurrentEssThreadObject();
        return WBEM_S_NO_ERROR;
    }
    else
        return WBEM_S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\corefind.cpp ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  COREFIND.CPP
//
//  This file implements classes needed to search for event filters matching an
//  event.
//
//  See corefind.h for documentation.
//
//  History:
//
//  11/27/96    a-levn      Inefficient version compiles.
//  4/13/00     levn        Efficient version works.
//
//=============================================================================

#include "precomp.h"
#include <stdio.h>
#include "ess.h"
#include "corefind.h"

CCoreEventProvider::CCoreEventProvider(CLifeControl* pControl) 
    : TUnkBase(pControl), m_pNamespace(NULL), m_pSink(NULL)
{
}

CCoreEventProvider::~CCoreEventProvider()
{
    Shutdown();
}

HRESULT CCoreEventProvider::Shutdown()
{
    CInEssSharedLock( &m_Lock, TRUE );

    if ( m_pSink != NULL )
    {
        m_pSink->Release();
        m_pSink = NULL;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CCoreEventProvider::SetNamespace( CEssNamespace* pNamespace )
{
    _DBG_ASSERT( m_pNamespace == NULL );

    //
    // don't hold reference, else there would be a circular ref.
    // We are guaranteed that as long as the we're alive the namespace will
    // be alive.
    // 
    m_pNamespace = pNamespace;
    
    if ( m_Lock.Initialize() )
	return S_OK;

    return WBEM_E_OUT_OF_MEMORY;
}

STDMETHODIMP CCoreEventProvider::ProvideEvents( IWbemObjectSink* pSink, 
                                                long lFlags )
{
    CInEssSharedLock isl( &m_Lock, TRUE );

    _DBG_ASSERT( m_pSink == NULL );

    HRESULT hres;
    hres = pSink->QueryInterface(IID_IWbemEventSink, (void**)&m_pSink);
    if(FAILED(hres))
        return hres;
    
    return S_OK;
}

HRESULT CCoreEventProvider::Fire( CEventRepresentation& Event, 
                                  CEventContext* pContext )
{
    //
    // it is important to hold the shared lock the entire time because 
    // we must ensure that we're not going to use the sink after shutdown 
    // is called. 
    // 

    CInEssSharedLock isl( &m_Lock, FALSE );

    //
    // Check if the sink is active
    //

    if ( m_pSink == NULL || m_pSink->IsActive() != WBEM_S_NO_ERROR )
    {
        return WBEM_S_FALSE;
    }

    //
    // Convert to real event
    // 

    IWbemClassObject* pEvent;
    HRESULT hres = Event.MakeWbemObject(m_pNamespace, &pEvent);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm2(pEvent);

    //
    // Fire it
    //

    hres = m_pSink->Indicate(1, (IWbemClassObject**)&pEvent);

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\consprov.h ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  CONPROV.H
//
//  This file defines the classes for event consumer provider caching.
//
//  Classes defined:
//
//      CConsumerProviderRecord  --- a single consumer provider record
//      CConsumerProviderCache  --- a collection of records.
//
//  History:
//
//  11/27/96    a-levn      Compiles.
//
//=============================================================================
#ifndef __CONSUMER_PROVIDER_CACHE
#define __CONSUMER_PROVIDER_CACHE

#include <arrtempl.h>
#include <wbemidl.h>
#include <parmdefs.h>
#include <unload.h>

class CEssNamespace;
class CConsumerProviderRecord
{
private:
    long m_lRef;
    CEssNamespace* m_pNamespace;
    
    IWbemClassObject* m_pLogicalProvider;
    LPWSTR m_wszMachineName;
    LPWSTR m_wszProviderName;
    LPWSTR m_wszProviderRef;
    CLSID m_clsid;

    IWbemEventConsumerProvider* m_pConsumerProvider;
    IWbemEventConsumerProviderEx* m_pConsumerProviderEx;
    IWbemUnboundObjectSink* m_pSink;

    BOOL m_bResolved;
    CWbemTime m_LastAccess;
    CCritSec m_cs;
    BOOL m_bAnonymous;

    CConsumerProviderRecord(CEssNamespace* pNamespace);
    HRESULT Initialize(IWbemClassObject* pLogicalProvider, 
                            LPCWSTR wszProviderRef,
                            LPCWSTR wszProviderName,
                            LPCWSTR wszMachineName);
    void Enter() {EnterCriticalSection(&m_cs);}
    void Leave() {LeaveCriticalSection(&m_cs);}

    friend class CConsumerProviderCache;
protected:
    HRESULT ResolveAndCache(IWbemUnboundObjectSink** ppSink,
                           IWbemEventConsumerProvider** ppConsumerProvider,
                           IWbemEventConsumerProviderEx** ppConsumerProviderEx);
    HRESULT Resolve(IWbemUnboundObjectSink** ppSink,
                           IWbemEventConsumerProvider** ppConsumerProvider,
                           IWbemEventConsumerProviderEx** ppConsumerProviderEx);

public:
    ~CConsumerProviderRecord();

    HRESULT GetGlobalObjectSink(OUT IWbemUnboundObjectSink** ppSink,
                                IN IWbemClassObject *pLogicalConsumer);
    HRESULT FindConsumer(IN IWbemClassObject* pLogicalConsumer,
                         OUT IWbemUnboundObjectSink** ppSink);
    HRESULT ValidateConsumer(IWbemClassObject* pLogicalConsumer);
    void Invalidate();
    CWbemTime GetLastAccess() {return m_LastAccess;}
    void Touch() {m_LastAccess = CWbemTime::GetCurrentTime();}
    BOOL IsActive() {return m_bResolved;}

    LPCWSTR GetMachineName() {return m_wszMachineName;}
    REFCLSID GetCLSID() {return m_clsid;}
    LPCWSTR GetProviderName() {return m_wszProviderName;}
    LPCWSTR GetProviderRef() {return m_wszProviderRef;}

    void FireNCSinkEvent(DWORD dwIndex, IWbemClassObject *pLogicalConsumer);

    long AddRef();
    long Release();
};

class CEssNamespace;
class CConsumerProviderCache
{
public:
    friend class CConsumerProviderRecord;
    friend class CConsumerProviderWatchInstruction;

    CConsumerProviderCache(CEssNamespace* pNamespace) 
        : m_pNamespace(pNamespace), m_pInstruction(NULL){}
    ~CConsumerProviderCache();

    RELEASE_ME CConsumerProviderRecord* GetRecord(
                IN IWbemClassObject* pLogicalConsumer);

    HRESULT RemoveConsumerProvider(LPCWSTR wszProvider);
    static SYSFREE_ME BSTR GetProviderRefFromRecord(IWbemClassObject* pReg);
    HRESULT GetConsumerProviderRegFromProviderReg(
                    IWbemClassObject* pProv, IWbemClassObject** ppConsProv);
    void DumpStatistics(FILE* f, long lFlags);
    void Clear();
protected:
    HRESULT UnloadUnusedProviders(CWbemInterval Interval);
    void EnsureUnloadInstruction();
    BOOL DoesContain(IWbemClassObject* pProvReg, IWbemClassObject* pConsumer);

protected:
    CRefedPointerArray<CConsumerProviderRecord> m_apRecords;

    CEssNamespace* m_pNamespace;
    CCritSec m_cs;
    class CConsumerProviderWatchInstruction* m_pInstruction;
    friend CConsumerProviderWatchInstruction;
    friend class CProviderRegistrationSink;
};
        
class CConsumerProviderWatchInstruction : public CBasicUnloadInstruction
{
protected:
    CConsumerProviderCache* m_pCache;

    static CWbemInterval mstatic_Interval;

public:
    CConsumerProviderWatchInstruction(CConsumerProviderCache* pCache);
    virtual ~CConsumerProviderWatchInstruction() {}

    HRESULT Fire(long, CWbemTime);

    static void staticInitialize(IWbemServices* pRoot);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\corefind.h ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  FINDTRIG.H
//
//  This file defines the classes for an event filter search engine.  
//
//  Classes defined:
//
//      CEventFilterEnumerator      An enumerator of event filters
//      CArrayEventFilterEnumerator Array-based enumerator of event filters
//      CSearchHint                 Information passed from one search to next
//      CEventFilterSearchEngine    Search engine class.
//
//  History:
//
//  11/27/96    a-levn      Compiles.
//
//=============================================================================
#ifndef __FIND_FILTER__H_
#define __FIND_FILTER__H_

#include "binding.h"
#include "arrtempl.h"
#include "essutils.h"

class CCoreEventProvider : 
        public CUnkBase<IWbemEventProvider, &IID_IWbemEventProvider>
{
protected:
    STDMETHOD(ProvideEvents)(IWbemObjectSink* pSink, long lFlags);

protected:
    CEssSharedLock m_Lock;
    CEssNamespace* m_pNamespace;
    IWbemEventSink* m_pSink;

public:
    CCoreEventProvider(CLifeControl* pControl = NULL);
    ~CCoreEventProvider();
    HRESULT SetNamespace(CEssNamespace* pNamespace);
    HRESULT Shutdown();

    HRESULT Fire(CEventRepresentation& Event, CEventContext* pContext);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\delivrec.cpp ===
//******************************************************************************
//
//  Copyright (c) 1999-2000, Microsoft Corporation, All rights reserved
//
//*****************************************************************************

#include "precomp.h"
#include <wbemint.h>
#include "delivrec.h"
#include "qsink.h"
#include "nsrep.h"

/*************************************************************************
  CDeliveryRecord
**************************************************************************/

CDeliveryRecord::~CDeliveryRecord()
{ 
    if ( m_pNamespace )
    {
        m_pNamespace->RemoveFromCache( m_dwSize );
    }

    Clear(); 
}

void CDeliveryRecord::AddToCache( CEssNamespace * pNamespace, DWORD dwTotalSize, DWORD * pdwSleep )
{
    _DBG_ASSERT( pNamespace );

    if ( NULL == m_pNamespace )
    {
        m_pNamespace = pNamespace;
    }

    m_pNamespace->AddToCache( m_dwSize, dwTotalSize, pdwSleep );
}


HRESULT CDeliveryRecord::Initialize( IWbemClassObject** apEvents, 
                                     ULONG cEvents,
                                     IWbemCallSecurity* pCallSec )
{
    HRESULT hr;

    Clear();

    m_pCallSec = pCallSec;

    for( ULONG i=0; i < cEvents; i++ )
    {
        //
        // TODO : should clone the object here later. 
        // 

        if ( m_Events.Add( apEvents[i] ) < 0 )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        hr = AdjustTotalSize( apEvents[i] );

        if ( FAILED(hr) )
        {
            return WBEM_E_CRITICAL_ERROR;
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CDeliveryRecord::AdjustTotalSize( IWbemClassObject* pObj )
{
    HRESULT hr;

    CWbemPtr<_IWmiObject> pEventInt;
    
    hr = pObj->QueryInterface( IID__IWmiObject, (void**)&pEventInt );
    
    if ( FAILED(hr) )
    {
        return hr;
    }
    
    DWORD dwSize;
    
    hr = pEventInt->GetObjectMemory( NULL, 0, &dwSize );
    
    if ( FAILED(hr) && hr != WBEM_E_BUFFER_TOO_SMALL )
    {
        return hr;
    }
    
    m_dwSize += dwSize;

    return WBEM_S_NO_ERROR;
}

HRESULT CDeliveryRecord::Persist( IStream* pStrm )
{
    HRESULT hr;

    DWORD dwNumObjects = m_Events.GetSize();

    hr = pStrm->Write( &dwNumObjects, sizeof(DWORD), NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }
                      
    for( DWORD i=0; i < dwNumObjects; i++ )
    {
        hr = CoMarshalInterface( pStrm, 
                                 IID_IWbemClassObject, 
                                 m_Events[i], 
                                 MSHCTX_DIFFERENTMACHINE, 
                                 NULL, 
                                 MSHLFLAGS_NORMAL );
        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CDeliveryRecord::Unpersist( IStream* pStrm )
{
    HRESULT hr;

    Clear();

    DWORD dwNumObjects;

    hr = pStrm->Read( &dwNumObjects, sizeof(DWORD), NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    for( DWORD i=0; i < dwNumObjects; i++ )
    {
        CWbemPtr<IWbemClassObject> pEvent;

        hr = CoUnmarshalInterface( pStrm, 
                                   IID_IWbemClassObject,
                                   (void**)&pEvent );

        if ( FAILED(hr) )
        {
            return hr;
        }

        if ( m_Events.Add( pEvent ) < 0 )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        hr = AdjustTotalSize( pEvent );

        if ( FAILED(hr) )
        {
            return WBEM_E_CRITICAL_ERROR;
        }
    }

    return WBEM_S_NO_ERROR;
}

/*************************************************************************
  CGuaranteedDeliveryRecord
**************************************************************************/

HRESULT CGuaranteedDeliveryRecord::PreDeliverAction( ITransaction* pTxn )
{
    return WBEM_S_NO_ERROR;
}

HRESULT CGuaranteedDeliveryRecord::PostDeliverAction( ITransaction* pTxn, 
                                                      HRESULT hres )
{
#ifdef __WHISTLER_UNCUT
    return m_pSink->GuaranteedPostDeliverAction( m_pRcvr );
#else
    return WBEM_E_NOT_SUPPORTED;
#endif
}

/*************************************************************************
  CExpressDeliveryRecord
**************************************************************************/

HRESULT CExpressDeliveryRecord::PreDeliverAction( ITransaction* pTxn )
{
    return WBEM_S_NO_ERROR;
}

HRESULT CExpressDeliveryRecord::PostDeliverAction( ITransaction* pTxn, 
                                                   HRESULT hres )
{
    return WBEM_S_NO_ERROR;
}

CReuseMemoryManager CExpressDeliveryRecord::mstatic_Manager(sizeof CExpressDeliveryRecord);

void *CExpressDeliveryRecord::operator new(size_t nBlock)
{
    return mstatic_Manager.Allocate();
}
void CExpressDeliveryRecord::operator delete(void* p)
{
    mstatic_Manager.Free(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\delivrec.h ===
//******************************************************************************
//
//  Copyright (c) 1999-2000, Microsoft Corporation, All rights reserved
//
//*****************************************************************************

#ifndef __DELIVREC_H__
#define __DELIVREC_H__

#include <wmimsg.h>
#include <wbemcli.h>
#include <arrtempl.h>
#include <comutl.h>
#include <winntsec.h>
#include <callsec.h>
#include <unk.h>
#include "evsink.h"

class CQueueingEventSink;
class CEssNamespace;


/*************************************************************************
  CDeliveryRecord
**************************************************************************/

class CDeliveryRecord : public CUnk // for ref counting
{
private:

    DWORD m_dwSize;
    CRefedPointerArray<IWbemClassObject> m_Events;
    CWbemPtr<IWbemCallSecurity> m_pCallSec;
    CEssNamespace * m_pNamespace;

    //
    // later we'll have a consumer id here.
    //

    HRESULT AdjustTotalSize( IWbemClassObject* pObj );
    void* GetInterface( REFIID ) { return NULL; }

public:

    CDeliveryRecord() : m_dwSize(0), m_pNamespace( NULL ) { }
    virtual ~CDeliveryRecord();
    
    void AddToCache( CEssNamespace * pNamespace, DWORD dwTotalSize, DWORD * pdwSleep );

    IWbemClassObject** GetEvents() { return m_Events.GetArrayPtr(); }
    IWbemCallSecurity* GetCallSecurity() { return m_pCallSec; }

    ULONG GetNumEvents() { return m_Events.GetSize(); }
    ULONG GetTotalBytes() { return m_dwSize; }

    void Clear() { m_Events.RemoveAll(); m_dwSize = 0; }

    HRESULT Initialize( IWbemClassObject** apEvents, 
                        ULONG cEvents,
                        IWbemCallSecurity* pCallSec = NULL );
    
    virtual HRESULT PreDeliverAction( ITransaction* ppTxn ) = 0;
    virtual HRESULT PostDeliverAction( ITransaction* pTxn, HRESULT hres ) = 0;

    HRESULT Persist( IStream* pStrm );
    HRESULT Unpersist( IStream* pStrm );
};

/*************************************************************************
  CExpressDeliveryRecord
**************************************************************************/

class CExpressDeliveryRecord : public CDeliveryRecord
{
    static CReuseMemoryManager mstatic_Manager;

public:

    HRESULT PreDeliverAction( ITransaction* ppTxn );
    HRESULT PostDeliverAction( ITransaction* pTxn, HRESULT hres );

    void* operator new(size_t nSize);
    void operator delete(void* p);
};

/*************************************************************************
  CGuaranteedDeliveryRecord
**************************************************************************/

class CGuaranteedDeliveryRecord : public CDeliveryRecord
{
    CQueueingEventSink* m_pSink;
    CWbemPtr<IWmiMessageQueueReceiver> m_pRcvr;

public:

    void SetCB( CQueueingEventSink* pSink, IWmiMessageQueueReceiver* pRcvr ) 
    {
        m_pSink = pSink; 
        m_pRcvr = pRcvr;
    }

    HRESULT PreDeliverAction( ITransaction* ppTxn ) ;
    HRESULT PostDeliverAction( ITransaction* pTxn, HRESULT hres );
};

#endif // __DELIVREC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\equeue.h ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  EQUEUE.H
//
//  This file defines the classes for a queue of events which have matched 
//  some of the filters and will have to be dispatched.
//
//  Classes defined:
//
//      CEventQueue
//
//  History:
//
//  11/27/96    a-levn      Compiles.
//
//=============================================================================

#ifndef __EVENT_QUEUE__H_
#define __EVENT_QUEUE__H_

#include "binding.h"
#include <wbemcomn.h>
#include <execq.h>

class CEss;

//*****************************************************************************
//
//  class CEventQueue
//
//  This class stores a queue of events that need to be dispatched to 
//  consumers. It also handles the actual dispatcher functionality: when an
//  instance of this class is created (and there expected to be only one), a 
//  new thread is created which will wake up when new requests are added to the
//  queue and process them.
//
//*****************************************************************************

class CEventQueue : public CExecQueue
{
protected:
    class CDeliverRequest : public CExecRequest
    {
    private: 
        CQueueingEventSink* m_pConsumer;
    public:
        CDeliverRequest(CQueueingEventSink* pConsumer);
        ~CDeliverRequest();
        HRESULT Execute();
    };

    CEss* m_pEss;

protected:
    virtual void ThreadMain(CThreadRecord* pRecord);
    void InitializeThread();
    void UninitializeThread();

public:
    CEventQueue(STORE CEss* pEss);

    HRESULT EnqueueDeliver(CQueueingEventSink* pConsumer);
    void DumpStatistics(FILE* f, long lFlags);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\equeue.cpp ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  EQUEUE.CPP
//
//  This file implements the classes for a queue of events which have matched
//  some of the filters and will have to be dispatched.
//
//  See equeue.h for documentation
//
//  History:
//
//  11/27/96    a-levn      Compiles.
//
//=============================================================================

#include "precomp.h"
#include <stdio.h>
#include "ess.h"
#include "equeue.h"
#include <cominit.h>
#include "NCEvents.h"

CEventQueue::CDeliverRequest::CDeliverRequest(CQueueingEventSink* pConsumer)
    : m_pConsumer(pConsumer)
{
    m_pConsumer->AddRef();
}

CEventQueue::CDeliverRequest::~CDeliverRequest()
{
    m_pConsumer->Release();
}

HRESULT CEventQueue::CDeliverRequest::Execute()
{
    return m_pConsumer->DeliverAll();
}


//*****************************************************************************
//************************ CEventQueue ****************************************
//*****************************************************************************

CEventQueue::CEventQueue(CEss* pEss) : m_pEss(pEss)
{
    SetThreadLimits(100, 100, -1);
    m_dwTimeout = 60000;
}

void CEventQueue::InitializeThread()
{
    //
    // Report the MSFT_WmiThreadPoolThreadCreated event.
    //

    FIRE_NCEVENT( g_hNCEvents[MSFT_WmiThreadPoolThreadCreated], 
                  WMI_SENDCOMMIT_SET_NOT_REQUIRED,
                  GetCurrentThreadId());
}

void CEventQueue::UninitializeThread()
{
    //
    // Report the MSFT_WmiThreadPoolThreadDeleted event.
    //

    FIRE_NCEVENT( g_hNCEvents[MSFT_WmiThreadPoolThreadDeleted], 
                  WMI_SENDCOMMIT_SET_NOT_REQUIRED,
                  GetCurrentThreadId() );
}

void CEventQueue::ThreadMain(CThreadRecord* pRecord)
{    
    try
    {
        CExecQueue::ThreadMain(pRecord);
    }
    catch(...)
    {
        // Exit this thread gracefully
        // ===========================

        ShutdownThread(pRecord);
    }
}
        

HRESULT CEventQueue::EnqueueDeliver(CQueueingEventSink* pConsumer)
{
    // Create a new request
    // ====================

    CDeliverRequest* pRequest = new CDeliverRequest(pConsumer);
    if(pRequest == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CExecQueue::Enqueue(pRequest);
    return S_OK;
}

void CEventQueue::DumpStatistics(FILE* f, long lFlags)
{
    fprintf(f, "%d requests (%d threads) on the main queue\n", m_lNumRequests,
        m_lNumThreads);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\ess.h ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  ESS.H
//
//  Implements the class that contains all the fuctionality of the ESS by 
//  virtue of containing all the necessary components.
//
//  Classes defined:
//
//      CEss
//
//  History:
//
//  11/27/96    a-levn      Compiles.
//  1/6/97      a-levn      Updated to initialize TSS.
//
//=============================================================================
#ifndef __ESS__H_
#define __ESS__H_

#include "pragmas.h"
#include "nsrep.h"
#include "equeue.h"
#include "wbemtss.h"
#include "essself.h"
#include <evtlog.h>
#include <sleeper.h>
#include <wmimsg.h>
#include <wstlallc.h>

//*****************************************************************************
//
//  class CEss
//
//  This class is the central "collection point" for the ESS. It contains the
//  list of namespace objects and some shared components.
//
//*****************************************************************************

class CInitActiveNamespacesRequest;
class CInitNamespaceRequest;  

class CEss
{
protected:
    typedef std::map<WString, CEssNamespace*, WSiless, 
                        wbem_allocator<CEssNamespace*> > TNamespaceMap;

    typedef TNamespaceMap::iterator TNamespaceIterator;

    TNamespaceMap m_mapNamespaces;
    CWinMgmtTimerGenerator m_TimerGenerator;
    CEventQueue m_Queue;
    IWbemLocator* m_pLocator;
    _IWmiCoreServices* m_pCoreServices;
    _IWmiProvSS* m_pProvSS;
    _IWmiProvSSSink* m_pProvSSSink;
    LPWSTR m_wszServerName; 

    IWbemDecorator* m_pDecorator;
    IWbemLifeControl* m_pLifeControl;
    long m_lObjectCount;
    long m_lNumActiveNamespaces;

    CEventLog m_EventLog;
    CRegistryMinMaxLimitControl m_LimitControl;
    IWbemTokenCache* m_pTokenCache;
    HANDLE m_hReadyEvent;

    BOOL  m_bLastCallForCoreCalled;
    
    CCritSec m_cs;

    //
    // the number of namespaces that were active on startup by are still 
    // initializating. 
    //
    long m_lOutstandingActiveNamespaceInit;

    //
    // we use a background thread to perform recovery of guaranteed 
    // event deliveries.  
    // 
    HANDLE m_hRecoveryThread;
    HRESULT InitiateRecovery(); 
    static ULONG WINAPI PerformRecovery( void* pCtx );
    
    HANDLE m_hExitBootPhaseTimer;
    static void CALLBACK ExitBootPhaseCallback( LPVOID, BOOLEAN );
    void ExecuteDeferredNSInitRequests();

    //
    // If we are in the boot phase, then we will queue up the ns init events
    // until we're out of the boot phase.
    //
    CPointerArray<CExecRequest> m_aDeferredNSInitRequests;

    BOOL m_bMSMQDisabled;

public:
    CEss();
    ~CEss();

    void TriggerDeferredInitialization();

    HRESULT Initialize( LPCWSTR wszServer,
                        long lFlags,
                        _IWmiCoreServices* pCoreServices,
                        IWbemDecorator* pDecorator );

    HRESULT Shutdown(BOOL bIsSystemShutdown);
    HRESULT LastCallForCore(LONG lSystemShutDown);

    HRESULT GetNamespaceObject( LPCWSTR wszNamespace,
                                BOOL bEnsureActivation,
                                RELEASE_ME CEssNamespace** ppNamespace );

    HRESULT GetNamespacePointer( LPCWSTR wszNamespace,
                                 BOOL bRepositoryOnly,
                                 RELEASE_ME IWbemServices** ppNamespace );

    HRESULT Decorate(IWbemClassObject* pObject, LPCWSTR wszNamespace);
    HRESULT GetProviderFactory(LPCWSTR wszNamespace, IWbemServices* pNamespace,
                                _IWmiProviderFactory** ppFactory);

    HRESULT ReloadProvider( long lFlags, 
                            LPCWSTR wszNamespace, 
                            LPCWSTR wszName );

    HRESULT PurgeNamespace(LPCWSTR wszNamespace);

    HRESULT ProcessEvent(READ_ONLY CEventRepresentation& Event, long lFlags);
    HRESULT ProcessQueryObjectSinkEvent( READ_ONLY CEventRepresentation& Event );
    HRESULT VerifyInternalEvent(READ_ONLY CEventRepresentation& Event);

    HRESULT RegisterNotificationSink(WBEM_CWSTR wszNamespace, 
                            WBEM_CWSTR wszQueryLanguage, WBEM_CWSTR wszQuery, 
                            long lFlags, IWbemContext* pContext, 
                            IWbemObjectSink* pSink);
    HRESULT RemoveNotificationSink(IWbemObjectSink* pSink);

    CWinMgmtTimerGenerator& GetTimerGenerator() {return m_TimerGenerator;}
    CEventLog& GetEventLog() {return m_EventLog;}

    void IncrementObjectCount();
    void DecrementObjectCount();

    HRESULT SetNamespaceActive(LPCWSTR wszNamespace);
    HRESULT SetNamespaceInactive(LPCWSTR wszNamespace);
    HRESULT SaveActiveNamespaceList();
    HRESULT RequestStartOnBoot(BOOL bStart = TRUE);
    HRESULT InitializeTimerGenerator(LPCWSTR wszNamespace, 
                    IWbemServices* pNamespace);

    static HRESULT DecorateObject(IWbemClassObject* pObj, LPCWSTR wszNamespace);

    HRESULT EnqueueDeliver(CQueueingEventSink* pDest);
    HRESULT Enqueue(CExecRequest* pReq);

    HRESULT AddSleepCharge(DWORD dwSleep);
    HRESULT AddCache();
    HRESULT RemoveCache();
    HRESULT AddToCache(DWORD dwAdd, DWORD dwMemberTotal, 
                        DWORD* pdwSleep = NULL);
    HRESULT RemoveFromCache(DWORD dwRemove);
    HRESULT GetToken(PSID pSid, IWbemToken** ppToken);

    HRESULT CreatePersistentQueue( LPCWSTR wszQueueName, DWORD dwQos );
    HRESULT DestroyPersistentQueue( LPCWSTR wszQueueName );

    void DumpStatistics(FILE* f, long lFlags);

    //
    // each namespace that is active on startup notifies us when it has 
    // finished initialization. 
    //
    void NotifyActiveNamespaceInitComplete();

protected:

    typedef CPointerArray<CInitActiveNamespacesRequest> InitActiveNsRequestList;

    HRESULT PrepareNamespaceInitRequest( 
                                      LPCWSTR wszNamespace,
                                      CInitActiveNamespacesRequest* pRequest );

    HRESULT PrepareNamespaceInitRequests( IWbemServices* pRoot,
                                          BOOL bRediscover,
                                          InitActiveNsRequestList& aRequests);
   
    HRESULT RecursivePrepareNamespaceInitRequests(
                                       LPCWSTR wszNamespace,
                                       IWbemServices* pNamespace, 
                                       CInitActiveNamespacesRequest* pRequest);

    HRESULT ScheduleNamespaceInitialize( CExecRequest* pReq );

    HRESULT LoadActiveNamespaces( IWbemServices* pRoot, BOOL bRediscover );

    HRESULT CreateNamespaceObject( LPCWSTR wszNormName, 
                                   CEssNamespace** ppNamespace );

    HRESULT LoadNamespaceObject( LPCWSTR wszNamespace, 
                                 BOOL bKnownEmpty,
                                 RELEASE_ME CEssNamespace** ppNamespace );
    inline HRESULT GetQueueManager( IWmiMessageQueueManager** ppQueueMgr );
 
    friend class CInObjectCount;
};

class CInObjectCount
{
protected:
    CEss* m_pEss;
public:
    CInObjectCount(CEss* pEss) : m_pEss(pEss)
    {
        m_pEss->IncrementObjectCount();
    }
    ~CInObjectCount()
    {
        m_pEss->DecrementObjectCount();
    }
};
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\ess.cpp ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  ESS.CPP
//
//  Implements the class that contains all the fuctionality of the ESS by 
//  virtue of containing all the necessary components.
//
//  See ess.h for documentation
//
//  History:
//
//  11/27/96    a-levn      Compiles.
//  1/6/97      a-levn      Updated to initialize TSS.
//
//=============================================================================

#include "precomp.h"
#include <stdio.h>
#include <wmimsg.h>
#include "ess.h"
#include "persistcfg.h"
#include "WinMgmtR.h"
#include "GenUtils.h" // For SetObjectAccess
#include "NCEvents.h"
#include "Quota.h"

#define BOOT_PHASE_MS 60*2*1000

#define WBEM_REG_ESS_ACTIVE_NAMESPACES __TEXT("List of event-active namespaces")
#define WBEM_ESS_OPEN_FOR_BUSINESS_EVENT_NAME L"WBEM_ESS_OPEN_FOR_BUSINESS"

// The use of this pointer to initialize parent class is valid in this context
#pragma warning(disable : 4355) 

//
// this guid is used to identify the MSMQ queues that are used for guaranteed
// delivery.  A type guid is a property of an MSMQ queue, so one can tell 
// by looking at an MSMQ queue if its an ess one or not. 
//
// {555471B4-0BE3-4e42-A98B-347AF72898FA}
//
const CLSID g_guidQueueType =  
{ 0x555471b4, 0xbe3, 0x4e42, {0xa9, 0x8b, 0x34, 0x7a, 0xf7, 0x28, 0x98, 0xfa}};

#pragma warning(push)

// not all control paths return due to infinite loop
#pragma warning(disable:4715)  

DWORD DumpThread(CEss* pEss)
{
    while(1)
    {
        FILE* f = fopen("c:\\stat.log", "a");
        if(f == NULL)
            return 1;
        pEss->DumpStatistics(f, 0);
        fclose(f);
        Sleep(10000);
    }
    return 0;
}
#pragma warning(pop)

DWORD RegDeleteSubKeysW( HKEY hkey )
{
    FILETIME ft;
    DWORD dwIndex=0;
    LONG lRes = ERROR_SUCCESS;
    LONG lResReturn = lRes;
    DWORD dwBuffSize = 256;
    DWORD cName = dwBuffSize;
    LPWSTR wszName = new WCHAR[dwBuffSize];

    if ( wszName == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CWStringArray awsKeysToDelete;

    //
    // enumerate through all subkeys and make recursive call.
    // 

    while( lRes == ERROR_SUCCESS && 
          ( lRes=RegEnumKeyExW( hkey, dwIndex, wszName, &cName, NULL,
                                NULL, NULL, &ft ) ) != ERROR_NO_MORE_ITEMS )
    {
        if ( lRes == ERROR_SUCCESS )
        {
            HKEY hkeySub;

            //
            // open key and make recursive call.
            // 
            
            lRes = RegOpenKeyExW( hkey, 
                                  wszName, 
                                  0, 
                                  KEY_ALL_ACCESS, 
                                  &hkeySub );
            
            if ( lRes == ERROR_SUCCESS )
            {
                lRes = RegDeleteSubKeysW( hkeySub );
                RegCloseKey( hkeySub );
            }

            //
            // defer deletion of key until we're done enumerating.
            // 

            try 
            {
                awsKeysToDelete.Add( wszName );
            }
            catch( CX_MemoryException )
            {
                lRes = ERROR_NOT_ENOUGH_MEMORY;
            }

            //
            // we want to try to keep going if we fail.
            //
            
            if ( lRes != ERROR_SUCCESS )
            {
                lResReturn = lRes;
                lRes = ERROR_SUCCESS;
            }

            dwIndex++;                
        }
        else if ( lRes == ERROR_MORE_DATA )
        {
            dwBuffSize += 256;
            delete [] wszName;
            wszName = new WCHAR[dwBuffSize];
            
            if ( wszName == NULL )
            {
                lRes = ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        cName = dwBuffSize;
    }

    delete [] wszName;

    for( int i=0; i < awsKeysToDelete.Size(); i++ )
    {
        lRes = RegDeleteKeyW( hkey, awsKeysToDelete[i] );

        if ( lRes != ERROR_SUCCESS )
        {
            lResReturn = lRes;
        }
    }
     
    return lResReturn;
}

/****************************************************************************
  CProviderReloadRequest
*****************************************************************************/

class CProviderReloadRequest : public CExecRequest
{
protected:
    CEss* m_pEss;
    long m_lFlags;
    CWbemPtr<IWbemContext> m_pContext;
    WString m_wsNamespace;
    WString m_wsProvider;

public:

    CProviderReloadRequest( CEss* pEss,
                            long lFlags,
                            IWbemContext* pContext,
                            LPCWSTR wszNamespace,
                            LPCWSTR wszProvider )
    : m_pEss( pEss ), m_lFlags( lFlags ), m_pContext( pContext ), 
      m_wsNamespace(wszNamespace),  m_wsProvider( wszProvider ) {}

    HRESULT Execute();
};

HRESULT CProviderReloadRequest::Execute()
{
    HRESULT hr;

    _DBG_ASSERT( GetCurrentEssThreadObject() == NULL );

    SetCurrentEssThreadObject( m_pContext );
    
    if ( GetCurrentEssThreadObject() != NULL )
    {
        hr = m_pEss->ReloadProvider( m_lFlags, 
                                     m_wsNamespace,
                                     m_wsProvider );

        delete GetCurrentEssThreadObject();
        ClearCurrentEssThreadObject();
    }
    else
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}
    
/****************************************************************************
  CEssProvSSSink
*****************************************************************************/
 
class CEssProvSSSink : public CUnkBase<_IWmiProvSSSink, &IID__IWmiProvSSSink >
{
    CEss* m_pEss;

public:

    CEssProvSSSink( CEss* pEss ) : m_pEss( pEss ),
     CUnkBase< _IWmiProvSSSink, &IID__IWmiProvSSSink >( NULL ) { }

    STDMETHOD(Synchronize)( long lFlags,
                       IWbemContext* pContext, 
                       LPCWSTR wszNamespace, 
                       LPCWSTR wszProvider );
};

STDMETHODIMP CEssProvSSSink::Synchronize( long lFlags,
                                     IWbemContext* pContext,
                                     LPCWSTR wszNamespace,
                                     LPCWSTR wszProvider )
{
    HRESULT hr;
    
    CProviderReloadRequest* pReq;

    try
    {    
        pReq = new CProviderReloadRequest( m_pEss,
                                           lFlags,
                                           pContext,
                                           wszNamespace,
                                           wszProvider );
    }
    catch( CX_MemoryException )
    {
        pReq = NULL;  
    }

    if ( pReq != NULL )
    {
        hr = m_pEss->Enqueue( pReq );
        
        if ( FAILED(hr) )
        {
            delete pReq;
        }
    }
    else
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }
    
    return hr;
}

/***************************************************************************
  CNamespaceInitRequest - Used to execute a single namespace initialize.  It 
  can be set to perform various stages of Namespace initialization.  
****************************************************************************/
class CNamespaceInitRequest : public CExecRequest
{
protected:
    BOOL m_bActiveOnStart;
    CWbemPtr<CEssNamespace> m_pNamespace;
    CWbemPtr<IWbemContext> m_pContext;

public:

    CNamespaceInitRequest( CEssNamespace* pNamespace, BOOL bActiveOnStart )
    : m_pNamespace(pNamespace), m_bActiveOnStart( bActiveOnStart )
    {
        m_pContext = GetCurrentEssContext();
    }

    HRESULT Execute()
    {
        HRESULT hr = WBEM_S_NO_ERROR;

        _DBG_ASSERT( GetCurrentEssThreadObject() == NULL );

        SetCurrentEssThreadObject( m_pContext );

        if ( GetCurrentEssThreadObject() != NULL )
        {
            //
            // if this namespace was active on boot, then it has already had
            // its Initialize() called.
            //

            if ( !m_bActiveOnStart ) 
            {
                hr = m_pNamespace->Initialize();
            }

            if ( SUCCEEDED(hr) )
            {
                hr = m_pNamespace->CompleteInitialization();
            }

            m_pNamespace->MarkAsInitialized( hr );
        
            delete GetCurrentEssThreadObject();
            ClearCurrentEssThreadObject();
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }

        //
        // if we're initializing because the namespace was active on 
        // startup then notify ess that we're done because its waiting 
        // for all active namespaces to finish initializing.
        // 

        if ( m_bActiveOnStart )
        {
            m_pNamespace->GetEss()->NotifyActiveNamespaceInitComplete();
        }

        if(FAILED(hr))
        {
            ERRORTRACE((LOG_ESS, "ESS failed to initialize a namespace "
                    "'%S'. Error code 0x%X\n", m_pNamespace->GetName(), hr));
        }
        
        return hr;
    }
};

/**************************************************************************
  CInitActiveNamespacesRequest - Used to initialize 1 or more active event 
  namespaces.  An active event namespace is one that was active on the last 
  shutdown.  The reason for initialization of multiple namespaces together is
  that the Stage1 Initialization of dependent active namespaces must complete
  before the Stage2 Initialization of any one of them.  This is so all 
  inter-namespace subscriptions can be put in place before event providers 
  are activated in any one of them.  Enforcing that all stage1 initialization 
  of dependent active namespaces does not cause a problem of all namespaces 
  being doomed by one faulty class provider in any single namespace because 
  stage1 init is guaranteed not to access any providers.  All stage2 init of 
  dependent active namespace, which may access providers, is performed 
  asynchronously. 
****************************************************************************/

class CInitActiveNamespacesRequest : public CExecRequest
{
protected:

    CEss* m_pEss;
    CRefedPointerArray<CEssNamespace> m_apNamespaces;
    CWbemPtr<IWbemContext> m_pContext;
    
public:
 
    CInitActiveNamespacesRequest( CEss* pEss ) : m_pEss(pEss) 
    { 
        m_pContext = GetCurrentEssContext();
    }

    int GetNumNamespaces() { return m_apNamespaces.GetSize(); }

    void Reset()
    {
        m_apNamespaces.RemoveAll();
    }

    HRESULT Add( CEssNamespace* pNamespace )
    {
        if ( m_apNamespaces.Add( pNamespace ) < 0 ) 
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        return WBEM_S_NO_ERROR;
    }

    HRESULT Execute()
    {
        HRESULT hr;
        HRESULT hrGlobal = WBEM_S_NO_ERROR;

        _DBG_ASSERT( GetCurrentEssThreadObject() == NULL );

        SetCurrentEssThreadObject( m_pContext );

        if ( GetCurrentEssThreadObject() == NULL )
        {
            for( int i=0; i < m_apNamespaces.GetSize(); i++ )
            {
                m_pEss->NotifyActiveNamespaceInitComplete();
            }

            return WBEM_E_OUT_OF_MEMORY;
        }

        for( int i=0; i < m_apNamespaces.GetSize(); i++ )
        {
            hr = m_apNamespaces[i]->Initialize();

            if ( FAILED(hr) )
            {
                ERRORTRACE((LOG_ESS, "ESS failed to initialize active "
                            "namespace '%S'. Error code 0x%x\n", 
                             m_apNamespaces[i]->GetName(), hr ));
                
                m_apNamespaces[i]->MarkAsInitialized(hr);
                m_apNamespaces.SetAt(i, NULL);
                m_pEss->NotifyActiveNamespaceInitComplete();
                hrGlobal = hr;
            }
        }

        for( int i=0; i < m_apNamespaces.GetSize(); i++ )
        {
            if ( m_apNamespaces[i] == NULL )
            {
                continue;
            }

            CNamespaceInitRequest* pReq;
            pReq = new CNamespaceInitRequest( m_apNamespaces[i], TRUE );

            if ( pReq != NULL )
            {
                hr = m_pEss->Enqueue( pReq );
            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

            if ( FAILED(hr) )
            {
                ERRORTRACE((LOG_ESS, "ESS failed to issue request for "
                            "completion of init for namespace '%S'. HR=0x%x\n",
                             m_apNamespaces[i]->GetName(), hr ));

                m_apNamespaces[i]->MarkAsInitialized( hr );
                m_pEss->NotifyActiveNamespaceInitComplete();
                hrGlobal = hr;
            }
        }

        _DBG_ASSERT( GetCurrentEssContext() == m_pContext ); 
        delete GetCurrentEssThreadObject();
        ClearCurrentEssThreadObject();

        return hrGlobal;
    }
};
    

inline LPWSTR NormalizeNamespaceString( LPCWSTR wszName )
{
    int cLen = wcslen( wszName );

    LPWSTR wszNormName = new WCHAR[cLen+5]; // 5 is for '\\.\' + '\0'

    if ( wszNormName == NULL )
    {
        return NULL;
    }

    if ( wcsncmp( wszName, L"\\\\", 2 ) == 0 || 
         wcsncmp( wszName, L"//", 2 ) == 0 )
    {
        wcscpy( wszNormName, wszName );
    }
    else 
    {
        wcscpy( wszNormName, L"\\\\.\\" );
        wcscat( wszNormName, wszName );
    }

    //
    // also convert all backwards slashes to forward slashes so that the 
    // normalized name can serve as both a valid wmi namespace string and as 
    // a valid persistent string ( wrt msmq and registry keys ).
    //

    WCHAR* pch = wszNormName;
    while( *pch != '\0' )
    {
        if ( *pch == '\\' )
        {
            *pch = '/';
        }
        pch++;
    }       

    return wszNormName;
}

//******************************************************************************
//  public
//
//  See ess.h for documentation
//
//******************************************************************************
CEss::CEss() : m_pLocator(NULL), m_pCoreServices(NULL), m_Queue(this), 
    m_TimerGenerator(this), m_hExitBootPhaseTimer(NULL),
    m_wszServerName(NULL), m_lObjectCount(0), m_lNumActiveNamespaces(0),
    m_pLifeControl(NULL), m_hReadyEvent(NULL), m_pProvSS(NULL),  m_bLastCallForCoreCalled(FALSE),
    m_pProvSSSink(NULL), m_pTokenCache(NULL), m_pDecorator(NULL),
    m_hRecoveryThread(NULL), m_lOutstandingActiveNamespaceInit(0), 
    m_bMSMQDisabled(FALSE),
    m_LimitControl(LOG_ESS, L"events held for consumers", 
               L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
               L"Low Threshold On Events (B)",
               L"High Threshold On Events (B)",
               L"Max Wait On Events (ms)")
{
    // Set the defaults for the limit control and read it from the registry
    // ====================================================================

    m_LimitControl.SetMin(10000000);
    m_LimitControl.SetMax(20000000);
    m_LimitControl.SetSleepAtMax(2000);
    m_LimitControl.Reread();

    InitNCEvents();
}

//******************************************************************************
//  public
//
//  See ess.h for documentation
//
//******************************************************************************
HRESULT CEss::LastCallForCore(LONG lIsSystemShutdown)
{

    m_bLastCallForCoreCalled = TRUE;
    
    // Shut down the timer generator (needs persistence)
    // =================================================
    m_TimerGenerator.SaveAndRemove(lIsSystemShutdown);

    return WBEM_S_NO_ERROR;
}

HRESULT CEss::Shutdown(BOOL bIsSystemShutdown)
{
    HRESULT hres;

    _DBG_ASSERT(m_bLastCallForCoreCalled);

    if ( m_hReadyEvent != NULL )
    {
        //
        // we must reset the ready event before parking the namespace.
        // this way providers can maybe tell why they are being shutdown.
        //
        ResetEvent( m_hReadyEvent );
    }

    CInCritSec ics(&m_cs);

    // Get persistent storage up-to-date
    // =================================

    {
        m_TimerGenerator.SaveAndRemove((LONG)FALSE);

	    TNamespaceIterator it = m_mapNamespaces.begin();
	    while(it != m_mapNamespaces.end())
	    {
	        it->second->Park();
	        it++;
	    }
    }    

    return WBEM_S_NO_ERROR;
}

HRESULT CEss::RequestStartOnBoot(BOOL bStart)
{
    CPersistentConfig per;
    per.SetPersistentCfgValue(PERSIST_CFGVAL_CORE_ESS_NEEDS_LOADING, bStart);
    SaveActiveNamespaceList();
    
    return WBEM_S_NO_ERROR;
}

CEss::~CEss() 
{
    if ( m_hReadyEvent != NULL )
    {
        CloseHandle( m_hReadyEvent );
    }

    if( GetCurrentEssThreadObject() == NULL )
    {
        SetCurrentEssThreadObject(NULL);
    }

    m_EventLog.Close();
    
    if(m_pTokenCache)
    {
        m_pTokenCache->Shutdown();
    }

    //
    // make sure that recovery has finished. 
    //
    if ( m_hRecoveryThread != NULL )
    {
        WaitForSingleObject( m_hRecoveryThread, INFINITE );
        CloseHandle( m_hRecoveryThread );
        m_hRecoveryThread = NULL;
    }

    //
    // Shutdown the quotas. This must be done before we cleanup the 
    // namespaces because it uses the root namespace for registering
    // for quota change events.
    //
    g_quotas.Shutdown();

    m_TimerGenerator.Shutdown();

    // Clear the namespace map
    // =======================

    BOOL bLeft = TRUE;
    do
    {
        // Retrieve the next namespace object and remove it from the map
        // =============================================================

        CEssNamespace* pNamespace = NULL;
        {
            CInCritSec ics(&m_cs);

            TNamespaceIterator it = m_mapNamespaces.begin();
            if(it != m_mapNamespaces.end())
            {
                pNamespace = it->second;
                m_mapNamespaces.erase(it);
            }
        }

        // Shut it down if retrieved
        // =========================

        if(pNamespace)
        {
            pNamespace->Shutdown();
            pNamespace->Release();
        }

        // Check if any are left
        // =====================
        {
            CInCritSec ics(&m_cs);
            bLeft = !m_mapNamespaces.empty();
        }

    } while(bLeft);

    //
    // make sure we remove the callback timer so that we're sure that no 
    // callbacks occur after we destruct.  Make sure that we're not holding 
    // the critsec at this point because their could be a deadlock, since 
    // the callback could be executing right now and be waiting for the 
    // critsec.  We would then deadlock when calling DeleteTimerQueueTimer()
    //

    if ( m_hExitBootPhaseTimer != NULL )
    {
        DeleteTimerQueueTimer( NULL,
                              m_hExitBootPhaseTimer, 
                              INVALID_HANDLE_VALUE );
    }

    m_Queue.Shutdown();

    delete GetCurrentEssThreadObject();
    ClearCurrentEssThreadObject();

    if ( m_pProvSS != NULL && m_pProvSSSink != NULL )
    {
        m_pProvSS->UnRegisterNotificationSink( 0, NULL, m_pProvSSSink );
    }

    CEventRepresentation::Shutdown();
    CEventAggregator::Shutdown();
    if(m_pLocator) 
        m_pLocator->Release();
    if(m_pCoreServices) 
        m_pCoreServices->Release();
    if(m_pProvSS)
        m_pProvSS->Release();
    if(m_pProvSSSink)
        m_pProvSSSink->Release();
    if(m_pDecorator) 
        m_pDecorator->Release();
    if(m_pLifeControl)
        m_pLifeControl->Release();

    delete [] m_wszServerName;
    m_pTokenCache->Release();
    
    CEssThreadObject::ClearSpecialContext();

    for( int i=0; i < m_aDeferredNSInitRequests.GetSize(); i++ )
        delete m_aDeferredNSInitRequests[i];

    DeinitNCEvents();
}

HRESULT CEss::SetNamespaceActive(LPCWSTR wszNamespace)
{
    LONG lRes;
    HKEY hkeyEss, hkeyNamespace;

    DEBUGTRACE((LOG_ESS,"Namespace %S is becoming Active\n", wszNamespace));

    //
    // If this is the first active namespace, request that WinMgmt load us the
    // next time around
    //

    if(m_lNumActiveNamespaces++ == 0)
    {
        RequestStartOnBoot(TRUE);
    }

    //
    // open ess key. 
    // 

    lRes = RegOpenKeyExW( HKEY_LOCAL_MACHINE, 
                          WBEM_REG_ESS,
                          0,
                          KEY_ALL_ACCESS,
                          &hkeyEss );
    //
    // open or create namespace key.
    // 

    if ( lRes == ERROR_SUCCESS )
    {
        lRes = RegCreateKeyExW( hkeyEss,
                                wszNamespace,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hkeyNamespace,
                                NULL );

        if ( lRes == ERROR_SUCCESS )
        {
            RegCloseKey( hkeyNamespace );
        }

        RegCloseKey( hkeyEss );
    }

    if ( lRes != ERROR_SUCCESS )
    {
        ERRORTRACE((LOG_ESS,"Error adding active namespace key %S to "
                    "registry. Res=%d\n", wszNamespace, lRes ));
    }
        
    return HRESULT_FROM_WIN32( lRes );
}

HRESULT CEss::SetNamespaceInactive(LPCWSTR wszNamespace)
{
    LONG lRes;
    HKEY hkeyEss, hkeyNamespace;
    
    DEBUGTRACE((LOG_ESS,"Namespace %S is becoming Inactive\n", wszNamespace));

    //
    // If this is the last active namespace, request that WinMgmt not load us 
    // the next time around
    //

    if(--m_lNumActiveNamespaces == 0)
    {
        RequestStartOnBoot(FALSE);
    }

    //
    // open ess key. 
    // 

    lRes = RegOpenKeyExW( HKEY_LOCAL_MACHINE, 
                          WBEM_REG_ESS,
                          0,
                          KEY_ALL_ACCESS,
                          &hkeyEss );

    //
    // delete namespace key
    // 

    if ( lRes == ERROR_SUCCESS )
    {
        lRes = RegOpenKeyExW( hkeyEss,
                              wszNamespace,
                              0,
                              KEY_ALL_ACCESS,
                              &hkeyNamespace );
        
        if ( lRes == ERROR_SUCCESS )
        {
            lRes = RegDeleteSubKeysW( hkeyNamespace );
            RegCloseKey( hkeyNamespace );
        }

        if ( lRes == ERROR_SUCCESS )
        {
            lRes = RegDeleteKeyW( hkeyEss, wszNamespace );
        }

        RegCloseKey( hkeyEss );
    }

    if ( lRes != ERROR_SUCCESS )
    {
        ERRORTRACE((LOG_ESS,"Error removing active namespace key %S from "
                    "registry. Res=%d\n", wszNamespace, lRes ));
    }

    return HRESULT_FROM_WIN32(lRes);
}

HRESULT CEss::SaveActiveNamespaceList()
{
    CWStringArray wsNamespaces;

    //
    // Iterate through the namespaces
    //

    DWORD dwTotalLen = 0;
    {
        CInCritSec ics(&m_cs);

        for(TNamespaceIterator it = m_mapNamespaces.begin();
            it != m_mapNamespaces.end(); it++)
        {
            if(it->second->IsNeededOnStartup())
            {
                LPCWSTR wszName = it->second->GetName();
                if(wsNamespaces.Add(wszName) < 0)
                    return WBEM_E_OUT_OF_MEMORY;
                dwTotalLen += wcslen(wszName) + 1;
            }
        }
    }

    dwTotalLen += 1;

    //
    // Allocate a buffer for all of these strings and copy them all in, 
    // separated by NULLs.
    //

    WCHAR* awcBuffer = new WCHAR[dwTotalLen];
    if(awcBuffer == NULL)
    return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<WCHAR> vdm(awcBuffer);

    WCHAR* pwcCurrent = awcBuffer;

    for(int i = 0; i < wsNamespaces.Size(); i++)
    {
        LPCWSTR wszName = wsNamespaces[i];
        wcscpy(pwcCurrent, wszName);
        pwcCurrent += wcslen(wszName)+1;
    }
    *pwcCurrent = NULL;

    //
    // Store this string in the registry
    //

    Registry r(WBEM_REG_WINMGMT);
    int nRes = r.SetBinary(WBEM_REG_ESS_ACTIVE_NAMESPACES, (byte*)awcBuffer, 
                           dwTotalLen * sizeof(WCHAR));
    if(nRes != Registry::no_error)
        return WBEM_E_FAILED;
    
    //
    // Return S_FALSE if no namespaces are active
    //

    if(wsNamespaces.Size() > 0)
        return S_OK;
    else
        return S_FALSE;
}

#ifdef __WHISTLER_UNCUT

/* NOTE - a better way to do the guaranteed delivery design would be 
to have the queuing sink be responsible fo performing recovery.   When 
we have an active namespace on boot, we should go through all the bindings 
and look for ones that are guaranteed.  We then perform try to open their 
queue and perform recovery for each one of them.  As for garbage collection,
all we have to do is delete all of our queues when we detect that we performed
recovery.  We would also enumerate the bindings and delete any associated
queues when a namespace is deleted. */  

inline HRESULT CEss::GetQueueManager( IWmiMessageQueueManager** ppQueueMgr )
{
    HRESULT hr;

    *ppQueueMgr = NULL;

    if(m_bMSMQDisabled)
        return WMIMSG_E_REQSVCNOTAVAIL;

    //
    // first obtain a pointer to the queue manager.
    //

    hr = CoCreateInstance( CLSID_WmiMessageQueueManager,
                           NULL,
                           CLSCTX_INPROC,
                           IID_IWmiMessageQueueManager,
                           (void**)ppQueueMgr );

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    return WBEM_S_NO_ERROR;
}

ULONG WINAPI CEss::PerformRecovery( void* pCtx )
{
    HRESULT hr;

    try
    {
        CEss* pSelf = (CEss*)pCtx;

        //
        // obtain queue manager. normally we'd hold onto the queue manager
        // since it would be used later, however, we don't want to keep 
        // msmq loaded if we never need it. We'll refetch the queue manager 
        // later if necessary.
        //

        CWbemPtr<IWmiMessageQueueManager> pQueueMgr;

        hr = pSelf->GetQueueManager( &pQueueMgr );

        if ( FAILED(hr) )
        {
            if(hr == WMIMSG_E_REQSVCNOTAVAIL)
                pSelf->m_bMSMQDisabled = TRUE;
            return hr;
        }

        //
        // get all the persistent queues that are registered with MSMQ.
        // we filter based on our type guid.
        //

        LPWSTR* pwszNames;
        ULONG cNames;

        hr = pQueueMgr->GetAllNames( g_guidQueueType,
                                     TRUE,
                                     &pwszNames,
                                     &cNames );
        if ( FAILED(hr) )
        {
            if(hr == WMIMSG_E_REQSVCNOTAVAIL)
                pSelf->m_bMSMQDisabled = TRUE;
            return hr;
        }

        //
        // go through all the names.Recover ones that are registered as sinks.
        // destroy the ones that are aren't registered as sinks. Note that
        // that there is a possibility that a sink could get registered or
        // unregistered while we are doing this, however this case is fully 
        // supported.
        // 

        ULONG i;
        for(i=0; i < cNames; i++ )
        {
            DWORD dwQoS;
            WString wsSinkName;
            WString wsNamespace;

            hr = CQueueingEventSink::QueueNameToSinkName( pwszNames[i], 
                                                          wsSinkName,
                                                          wsNamespace,
                                                          dwQoS );
            if ( FAILED(hr) )
            {
                break;
            }

            //
            // obtain the namespace and from that obtain the sink.
            //

            CEssNamespace* pNamespace;
            CQueueingEventSink* pQueueingSink = NULL;

            {
                CInCritSec ics( &pSelf->m_cs );            
                pNamespace = pSelf->m_mapNamespaces[wsNamespace];
            }

            if ( pNamespace != NULL )
            {
                pQueueingSink = pNamespace->GetQueueingEventSink(wsSinkName);
            }

            if ( pQueueingSink == NULL )
            {
                hr = pQueueMgr->Destroy( pwszNames[i] );

                //
                // the queue may be destroyed between the time we obtained the
                // name of the queue and now. This happens if a call to remove
                // the sink is made during recovery.
                //
                
                if ( FAILED(hr) )
                {
                    if ( hr != WMIMSG_E_TARGETNOTFOUND )
                    {
                        break;
                    }
                    hr = WBEM_S_NO_ERROR;
                }
            }
            else
            {
                hr = pQueueingSink->Recover( pwszNames[i], dwQoS );
            }

            if ( FAILED(hr) )
            {
                ERRORTRACE((LOG_ESS, "Could not recover queue: %S , HR: 0x%x", 
                            pwszNames[i], hr));
            }
        }

        for(i=0; i < cNames; i++ )
        {
            CoTaskMemFree( pwszNames[i] );
        }
        CoTaskMemFree( pwszNames );
    }
    catch( ... )
    {
        ERRORTRACE((LOG_ESS, "Exception Thrown in Recovery Thread !!"));
    }

    return 0;
}

HRESULT CEss::DestroyPersistentQueue( LPCWSTR wszQueueName )
{
    HRESULT hr;

    CWbemPtr<IWmiMessageQueueManager> pQueueMgr;

    hr = GetQueueManager( &pQueueMgr );

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    return pQueueMgr->Destroy( wszQueueName );
}
   
HRESULT CEss::CreatePersistentQueue( LPCWSTR wszQueueName, DWORD dwQoS )
{
    HRESULT hr;

    CWbemPtr<IWmiMessageQueueManager> pQueueMgr;

    hr = GetQueueManager( &pQueueMgr );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // TODO: SD should allow only local system access.
    //

    return pQueueMgr->Create( wszQueueName,
                              g_guidQueueType,
                              FALSE, 
                              dwQoS, 
                              INFINITE, 
                              NULL );
}

HRESULT CEss::InitiateRecovery()
{
    HRESULT hr;

    //
    // perform actual recovery on a background thread.  We want to
    // keep any interaction with msmq off the main initialization
    // thread.  This is because we may need to wait for the msmq
    // service to come up.
    //

    m_hRecoveryThread = CreateThread( NULL,
                                      0,
                                      PerformRecovery,
                                      this,
                                      0,
                                      NULL );

    if ( m_hRecoveryThread == INVALID_HANDLE_VALUE )
    {
        m_hRecoveryThread = NULL;
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    return WBEM_S_NO_ERROR;
}
#endif

HRESULT CEss::Initialize( LPCWSTR wszServerName, 
                          long lFlags,
                          _IWmiCoreServices* pCoreServices,
                          IWbemDecorator* pDecorator )
{
    HRESULT hres;

    try
    {
    
    m_EventLog.Open();
    
    hres = CoCreateInstance(CLSID_WbemTokenCache, NULL, CLSCTX_ALL, 
                IID_IWbemTokenCache, (void**)&m_pTokenCache);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Cannot create a token cache: 0x%x\n", hres));
        return hres;
    }

    m_wszServerName = _new WCHAR[wcslen(wszServerName)+1];
    if(m_wszServerName == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    wcscpy(m_wszServerName, wszServerName);

    m_pCoreServices = pCoreServices;
    m_pCoreServices->AddRef();

    //
    // Get provider subsystem and register our callback with it.
    //

    hres = m_pCoreServices->GetProviderSubsystem(0, &m_pProvSS);
    
    if( SUCCEEDED(hres) )
    {
        m_pProvSSSink = new CEssProvSSSink( this );

        if ( m_pProvSSSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        
        m_pProvSSSink->AddRef();

        hres = m_pProvSS->RegisterNotificationSink( 0, NULL, m_pProvSSSink ); 

        if ( FAILED(hres) )
        {
            ERRORTRACE((LOG_ESS, "Failed to register notification sink "
                        "with provider subsystem: 0x%X\n",hres));
        }
    }
    else
    {
        ERRORTRACE((LOG_ESS, "No provider subsystem: 0x%X\n", hres));
    }

    // Store the "decorator"
    // =====================

    m_pDecorator = pDecorator;
    m_pDecorator->AddRef();
    m_pDecorator->QueryInterface(IID_IWbemLifeControl, (void**)&m_pLifeControl);

    CInObjectCount ioc(this);

    // Connect to the default namespace
    // ================================

    IWbemServices* pRoot;
    hres = m_pCoreServices->GetServices(L"root", NULL,NULL,
                        WMICORE_FLAG_REPOSITORY | WMICORE_CLIENT_TYPE_ESS, 
                        IID_IWbemServices, (void**)&pRoot);
    if(FAILED(hres)) return hres;
    CReleaseMe rm1(pRoot);

    // Pre-load event classes
    // ======================

    hres = CEventRepresentation::Initialize(pRoot, pDecorator);
    if(FAILED(hres)) return hres;

    // Initialize aggregator
    // =====================

    CEventAggregator::Initialize(pRoot);

    // Initialize timer instructions
    // =============================

    CConsumerProviderWatchInstruction::staticInitialize(pRoot);
    CEventProviderWatchInstruction::staticInitialize(pRoot);
    CConsumerWatchInstruction::staticInitialize(pRoot);


    // 
    // construct an event announcing to the world that ESS is open for business
    //

    //
    // Construct a security descriptor
    //

    CNtSecurityDescriptor SD;

    SID_IDENTIFIER_AUTHORITY idNtAuthority = SECURITY_NT_AUTHORITY;
    PSID pRawSid = NULL;

    if(!AllocateAndInitializeSid(&idNtAuthority, 2,
        SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
        0,0,0,0,0,0,&pRawSid))
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CNtSid SidAdmins(pRawSid);
    FreeSid(pRawSid);
    pRawSid = NULL;

    SID_IDENTIFIER_AUTHORITY idWorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    if(!AllocateAndInitializeSid( &idWorldAuthority, 1,
        SECURITY_WORLD_RID, 
        0, 0,0,0,0,0,0,&pRawSid))
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CNtSid SidEveryone(pRawSid);
    FreeSid(pRawSid);

    CNtAce AceAdmins(EVENT_ALL_ACCESS, ACCESS_ALLOWED_ACE_TYPE, 0, SidAdmins);
    CNtAce AceOthers(SYNCHRONIZE, ACCESS_ALLOWED_ACE_TYPE, 0, SidEveryone);

    CNtAcl Acl;
    if(!Acl.AddAce(&AceAdmins))
        return WBEM_E_OUT_OF_MEMORY;

    if(!Acl.AddAce(&AceOthers))
        return WBEM_E_OUT_OF_MEMORY;

    if(!SD.SetDacl(&Acl))
        return WBEM_E_OUT_OF_MEMORY;
        
    SECURITY_ATTRIBUTES sa;
    sa.nLength = sizeof sa;
    sa.lpSecurityDescriptor = SD.GetPtr();
    sa.bInheritHandle = FALSE;
    
    m_hReadyEvent = CreateEventW( &sa, 
                                  TRUE, 
                                  FALSE, 
                                  WBEM_ESS_OPEN_FOR_BUSINESS_EVENT_NAME );

    if( m_hReadyEvent == NULL )
    {
        ERRORTRACE((LOG_ESS, "Unable to create 'ready' event: 0x%X\n", 
                    GetLastError()