                          ~ ChipIOUp_TachLite_Control_GP4)));

        CFuncWriteTL_ControlReg( hpRoot,
                                   ( ChipIOUp_TachLite_Control_FEQ |
                                   (( Status &  ChipIOUp_TachLite_Control_GPIO_0_3_MASK) &
                                            ~ ChipIOUp_TachLite_Control_GP4)));

        osStallThread(
                       hpRoot,
                       Interrupt_Polling_osStallThread_Parameter
                     );

        fiTimerTick(
                       hpRoot,
                       Interrupt_Polling_osStallThread_Parameter
                     );
    }


    fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "TL Setting %s %08X",
                        "ChipIOUp_TachLite_Control_FFA",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        ChipIOUp_TachLite_Control_FFA |
                                Status &  ChipIOUp_TachLite_Control_GPIO_0_3_MASK &
                                        ~ ChipIOUp_TachLite_Control_GP4,
                        0,0,0,0,0,0,0);

    CFuncWriteTL_ControlReg( hpRoot,
                               ( ChipIOUp_TachLite_Control_FFA |
                               (( Status &  ChipIOUp_TachLite_Control_GPIO_0_3_MASK) &
                                        ~ ChipIOUp_TachLite_Control_GP4)));

    while( ! CThread_ptr(hpRoot)->FCP_FROZEN )
   {
        if( CThread->thread_hdr.currentState == CStateLIPEventStorm         ||
            CThread->thread_hdr.currentState == CStateElasticStoreEventStorm   ) return(agTRUE);

        PollingCalls++;

        if(PollingCalls > 2 * ( SF_EDTOV / Interrupt_Polling_osStallThread_Parameter))
        {
            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "FCP CFuncFreezeQueuesPoll  TIMEOUT FM %08X InIMQ %x TL status %08X Qf %d",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        CThread->ProcessingIMQ,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        CFunc_Queues_Frozen( hpRoot ),
                        0,0,0,0);

            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "LD %x IR %x OR %x ERQ %x FCP %x Queues %x",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        CThread_ptr(hpRoot)->LOOP_DOWN,
                        CThread_ptr(hpRoot)->IDLE_RECEIVED,
                        CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                        CThread_ptr(hpRoot)->ERQ_FROZEN,
                        CThread_ptr(hpRoot)->FCP_FROZEN,
                        CFunc_Queues_Frozen( hpRoot ),
                        0,0);

            return(agTRUE);
        }
        if( ! CThread->FuncPtrs.Proccess_IMQ( hpRoot ))
        {
            if(osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ) &
                   (~ ( ChipIOUp_Frame_Manager_Status_LP      |
                        ChipIOUp_Frame_Manager_Status_LSM_MASK   )) )
            {
                if (CThread->HostCopy_IMQConsIndex == CThread->FuncPtrs.GetIMQProdIndex(hpRoot))
                {
                    CFuncFMCompletion(hpRoot);
                }
                else
                {
                    continue;
                }
            }
        }
        CFuncWriteTL_ControlReg( hpRoot,
                                   ( ChipIOUp_TachLite_Control_FFA |
                                    ((Status &  ChipIOUp_TachLite_Control_GPIO_0_3_MASK) &
                                            ~ ChipIOUp_TachLite_Control_GP4)));

        CFuncWriteTL_ControlReg( hpRoot,
                                   ( ChipIOUp_TachLite_Control_FEQ |
                                   (( Status &  ChipIOUp_TachLite_Control_GPIO_0_3_MASK) &
                                            ~ ChipIOUp_TachLite_Control_GP4)));

        osStallThread(
                       hpRoot,
                       Interrupt_Polling_osStallThread_Parameter
                     );

        fiTimerTick(
                       hpRoot,
                       Interrupt_Polling_osStallThread_Parameter
                     );
    }

    return(agFALSE);
}


agBOOLEAN CFuncAll_clear( agRoot_t *hpRoot )
{
/* If chip is IO ready these are true */
    CThread_t       *   pCThread      = CThread_ptr(hpRoot);

    os_bit32 FM_Status;

    FM_Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );
#ifdef NPORT_STUFF
    /* For now, we are not going to be as proactive as the LOOP to
     * check if the nport link is up. Need to modify this latter.
     */
    if (pCThread->InitAsNport)
    {
        if((FM_Status & FRAMEMGR_NPORT_OK ) == FRAMEMGR_NPORT_OK )
        {
            if(! CFunc_Queues_Frozen( hpRoot ))
            {
                return agTRUE;
            }
        }
        return agFALSE;
    }

#endif  /* NPORT_STUFF */

    FM_Status &=  ~  ChipIOUp_Frame_Manager_Status_LSM_MASK;

    FM_Status &=  ~ ChipIOUp_Frame_Manager_Status_BA;

    FM_Status &=  ~ ChipIOUp_Frame_Manager_Status_OLS;


    if(FM_Status ==  ChipIOUp_Frame_Manager_Status_LP   &&
                    ! CFunc_Queues_Frozen( hpRoot )         )

    {
        return agTRUE;
    }

#ifdef OSLayer_Stub
    return agTRUE;
#else  /* OSLayer_Stub was not defined */

    pCThread->FuncPtrs.Proccess_IMQ(hpRoot);

    FM_Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );

    FM_Status &=  ~ ChipIOUp_Frame_Manager_Status_LSM_MASK;

    FM_Status &=  ~ ChipIOUp_Frame_Manager_Status_BA;

    FM_Status &=  ~ ChipIOUp_Frame_Manager_Status_OLS;

    if(FM_Status ==  ChipIOUp_Frame_Manager_Status_LP &&
                    ! CFunc_Queues_Frozen( hpRoot )         )

    {
        return agTRUE;
    }

    if((FM_Status ==  0) && (! CFunc_Queues_Frozen( hpRoot )) )

    {
        return agTRUE;
    }


    FM_Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );
    if( FM_Status & ChipIOUp_Frame_Manager_Status_BA && CFunc_Queues_Frozen( hpRoot ) )
    {
        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, ~ ChipIOUp_Frame_Manager_Status_BA);
        if( ! CFunc_Always_Enable_Queues( hpRoot ))
        return agTRUE;

    }

    fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "CFuncAll_clear(Org %08X) Fail FM %08X TL %08X Qf %d CState %d",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        FM_Status,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        CFunc_Queues_Frozen( hpRoot ),
                        pCThread->thread_hdr.currentState,
                        0,0,0);

    fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        CThread_ptr(hpRoot)->LOOP_DOWN,
                        CThread_ptr(hpRoot)->IDLE_RECEIVED,
                        CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                        CThread_ptr(hpRoot)->ERQ_FROZEN,
                        CThread_ptr(hpRoot)->FCP_FROZEN,
                        CThread_ptr(hpRoot)->ProcessingIMQ,
                        0,0);

    return agFALSE;
#endif /* OSLayer_Stub was not defined */
}

agBOOLEAN CFuncTakeOffline( agRoot_t *hpRoot )
{
    CThread_t       *   pCThread      = CThread_ptr(hpRoot);
    os_bit32 TimeOut =0;
    fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "CFuncTakeOffline",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);


    if(pCThread->LoopPreviousSuccess)
    {

        CFuncFreezeQueuesPoll( hpRoot);

        CFuncDisable_Interrupts(hpRoot,ChipIOUp_INTEN_INT);

/*
        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration, 0 );
*/

        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control, ChipIOUp_Frame_Manager_Control_CMD_Exit_Loop );

        osStallThread(hpRoot,1006);

        pCThread->FuncPtrs.Proccess_IMQ(hpRoot);

/*
        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ));

*/
        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Primitive, 0x15F7F7);


        pCThread->PrimitiveReceived = agFALSE;
        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control,
                                   ChipIOUp_Frame_Manager_Control_CMD_Host_Control   |
                                   ChipIOUp_Frame_Manager_Control_SP                 |
                                   ChipIOUp_Frame_Manager_Control_SQ                   );


        TimeOut = 0;
        while( ! pCThread->PrimitiveReceived)
        {
            osStallThread(hpRoot,1005);

            CFuncFMCompletion(hpRoot);

            if( TimeOut > 10 )
            {
                fiLogDebugString(hpRoot,
                                CFuncLogConsoleERROR,
                                "After CFuncTakeOffline Timed Out !",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                0,0,0,0,0,0,0,0);
            break;
            }
            TimeOut++;

        }

    }
    else
    {
        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control, ChipIOUp_Frame_Manager_Control_CMD_Exit_Loop );

        osStallThread(hpRoot,1006);

        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Primitive, 0x15F7F7);

        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control,
                               ChipIOUp_Frame_Manager_Control_CMD_Host_Control   |
                               ChipIOUp_Frame_Manager_Control_SP                 |
                               ChipIOUp_Frame_Manager_Control_SQ                   );


        for (TimeOut = 0; TimeOut < 10; TimeOut++) {
            osStallThread(hpRoot,1000);
        }

    }

    osStallThread(hpRoot,1004);

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control, ChipIOUp_Frame_Manager_Control_CMD_Exit_Host_Control );

    osStallThread(hpRoot,1003);

    CFuncFMCompletion(hpRoot);



return(agTRUE);
}

agBOOLEAN CFuncToReinit( os_bit32 FM_Status)
{

    if(FM_Status & ChipIOUp_Frame_Manager_Status_LS)
        return (agFALSE);
    else
        return (agTRUE);

}

/* Begin: Big_Endian_Code */


void CFuncSwapDmaMemBeforeIoSent(fi_thread__t *thread, os_bit32 DoFunc)
{
    agRoot_t        * hpRoot        = thread->hpRoot;
    CThread_t       * pCThread      = CThread_ptr(hpRoot);
    CDBThread_t     * pCDBThread;
    SFThread_t      * pSFThread;
#ifdef _DvrArch_1_30_
    PktThread_t     * pPktThread;
#endif /* _DvrArch_1_30_ was defined */

    SG_Element_t    * pESGL;
    SG_Element_t    * pESGLNext;

    SEST_t          * SEST;
    IRB_t           * pIrb;
    FCHS_t          * FCHS;
    void            * CmndPayload;
    fiMemMapMemoryDescriptor_t * ERQ;
    fiMemMapMemoryDescriptor_t * ESGLs;
    ERQProdIndex_t  tempERQ_index = 0;

    os_bit32             Payload_len;
    os_bit32             ChunksPerESGL ;

    ESGLs         = &(pCThread->Calculation.MemoryLayout.ESGL);
    ChunksPerESGL = pCThread->Calculation.Parameters.SizeSGLs;

    ERQ     = &(pCThread->Calculation.MemoryLayout.ERQ);
    pIrb    = (IRB_t *)ERQ->addr.DmaMemory.dmaMemoryPtr;
    /*
    **  The ERQ index has already been incremented, so what we
    **  want here is what it *used* to be.
    **  RSB/Orca 7/3/99
    */
    if (pCThread->HostCopy_ERQProdIndex != 0)
    {
        tempERQ_index = pCThread->HostCopy_ERQProdIndex - 1;
    }
    else
    {
        tempERQ_index = pCThread->Calculation.MemoryLayout.ERQ.elements - 1;
    }
    pIrb   += tempERQ_index;

    if (DoFunc == DoFuncCdbCmnd)
    {
        pCDBThread    = (CDBThread_t *)thread;
        SEST          = pCDBThread->SEST_Ptr;
        FCHS          = pCDBThread->FCP_CMND_Ptr;
        CmndPayload   = (void *)((os_bit8 *)FCHS + sizeof(FCHS_t));
        Payload_len   = sizeof(agFcpCmnd_t)/4;

        if (!(((USE_t *)SEST)->LOC & USE_LOC))/* Detect ESGL use */
        {
            pESGL         = (SG_Element_t *)((os_bit8 *)(ESGLs->addr.DmaMemory.dmaMemoryPtr) + (SEST->USE.First_SG.L32 - ESGLs->addr.DmaMemory.dmaMemoryLower32));
            while (pESGL)
            {
                pESGLNext = (SG_Element_t *)((os_bit8 *)(ESGLs->addr.DmaMemory.dmaMemoryPtr) + ((pESGL + ChunksPerESGL - 1)->L32 - ESGLs->addr.DmaMemory.dmaMemoryLower32));
                osSwapDownwardNonPayloadToTachLiteEndian((void *)pESGL, (ChunksPerESGL*sizeof(SG_Element_t)/sizeof(os_bit32)));
                pESGL     = pESGLNext;
            }
        }

        osSwapDownwardNonPayloadToTachLiteEndian((void *)SEST, sizeof(SEST_t)/4);
    }
    else if (DoFunc == DoFuncSfCmnd)
    {
        pSFThread     = (SFThread_t * )thread;
        FCHS          = pSFThread->SF_CMND_Ptr;
        CmndPayload   = (void *)((os_bit8 *)FCHS + sizeof(FCHS_t));
        Payload_len   = ((pIrb->Req_A.Bits__SFS_Len & 0xfff)-sizeof(FCHS_t))/4;
    }
#ifdef _DvrArch_1_30_
    else /* DoFuncPktCmnd */
    {
        pPktThread    = (PktThread_t * )thread;
        FCHS          = pPktThread->Pkt_CMND_Ptr;
        CmndPayload   = (void *)((os_bit8 *)FCHS + sizeof(FCHS_t));
        Payload_len   = ((pIrb->Req_A.Bits__SFS_Len & 0xfff)-sizeof(FCHS_t))/4;
    }
#endif /* _DvrArch_1_30_ was defined */

    osSwapDownwardNonPayloadToTachLiteEndian((void *)FCHS, sizeof(FCHS_t)/4);
    osSwapDownwardPayloadToTachLiteEndian(CmndPayload, Payload_len);
    osSwapDownwardNonPayloadToTachLiteEndian((void *)pIrb, sizeof(IRB_t)/4);

    osChipIOLoWriteBit32(hpRoot, ChipIOLo_ERQ_Producer_Index,
                          (os_bit32)pCThread->HostCopy_ERQProdIndex);

    return;
}


void CFuncSwapDmaMemAfterIoDone(agRoot_t *hpRoot)
{
    CThread_t       * pCThread     = CThread_ptr(hpRoot);
    CDBThread_t     * pCDBThread;

    os_bit32                         tempCMType;
    os_bit32                         tempBit32;

    os_bit32                         SFQ_Num_entry;
    os_bit32                         SFQ_Start_index;
    os_bit32                         Frame_Len;
    os_bit32                         SFQ_Index;
    os_bit32                         SFQ_Ele_Size;

    X_ID_t                        X_ID;
    SEST_t *                      SEST;
    FCHS_t *                      FCHS;
    FC_FCP_RSP_Payload_t *        fcprsp;
    FC_ELS_Unknown_Payload_t *    Payload;

    CM_Unknown_t *                pGenericCM;
    fiMemMapMemoryDescriptor_t *  SFQ_MemoryDescriptor;
    fiMemMapMemoryDescriptor_t *  CDBThread_MemoryDescriptor;
    fiMemMapMemoryDescriptor_t *  ESGLs;
    os_bit32                      ChunksPerESGL ;
    SG_Element_t               *  pESGL;

    pGenericCM  = pCThread->Calculation.MemoryLayout.IMQ.addr.DmaMemory.dmaMemoryPtr;
    pGenericCM += pCThread->HostCopy_IMQConsIndex;
    osSwapUpwardNonPayloadToSystemEndian((void *)pGenericCM, (os_bit32) sizeof(CM_Unknown_t)/sizeof(os_bit32));

    tempCMType  = pGenericCM->INT__CM_Type & CM_Unknown_CM_Type_MASK;
    switch (tempCMType)
    {
        case  CM_Unknown_CM_Type_Inbound_FCP_Exchange:
            X_ID =(X_ID_t)(pGenericCM->Unused_DWord_1 & CM_Inbound_FCP_Exchange_SEST_Index_MASK);
/*            pCDBThread = (CDBThread_t *)((os_bit8 *)(pCThread->CDBThread_Base)  */
/*                                      + (X_ID * pCThread->CDBThread_Size));  */
            CDBThread_MemoryDescriptor = &(pCThread->Calculation.MemoryLayout.CDBThread);
            pCDBThread = (CDBThread_t *)((os_bit8 *)(CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                               + (X_ID * CDBThread_MemoryDescriptor->elementSize));
            fcprsp = (FC_FCP_RSP_Payload_t *)(((os_bit8 *)pCDBThread->FCP_RESP_Ptr) + sizeof(FCHS_t));
            osSwapUpwardPayloadToFcLinkEndian((void *)fcprsp, (os_bit32) 6);
            /* Doesn't matter 'RPC bit set or not', doing it won't hurt. */

            if((pGenericCM->Unused_DWord_1 &             /* error ststus and Sest Index */
                        (CM_Inbound_FCP_Exchange_LKF
                        +CM_Inbound_FCP_Exchange_CNT
                        +CM_Inbound_FCP_Exchange_OVF
                        +CM_Inbound_FCP_Exchange_RPC)) == CM_Inbound_FCP_Exchange_RPC)
            {
                if (!fcprsp->FCP_STATUS.SCSI_status_byte)
                    break;
            }

            tempBit32 = pCThread->Calculation.MemoryLayout.FCP_RESP.elementSize/4 - 6;
            osSwapUpwardPayloadToFcLinkEndian((void *)(((os_bit8 *)fcprsp)+6*4), tempBit32);
            SEST = (SEST_t *)pCDBThread->SEST_Ptr;
            ESGLs         = &(pCThread->Calculation.MemoryLayout.ESGL);
            ChunksPerESGL = pCThread->Calculation.Parameters.SizeSGLs;
            osSwapUpwardNonPayloadToSystemEndian((void *)SEST, (os_bit32) sizeof(SEST_t)/sizeof(os_bit32));
            if (!(((USE_t *)SEST)->LOC & USE_LOC))/* Detect ESGL use */
            {
                pESGL     = (SG_Element_t *)((os_bit8 *)(ESGLs->addr.DmaMemory.dmaMemoryPtr) + (SEST->USE.First_SG.L32 - ESGLs->addr.DmaMemory.dmaMemoryLower32));
                while (pESGL)
                {
                    osSwapUpwardNonPayloadToSystemEndian((void *)pESGL, (ChunksPerESGL*sizeof(SG_Element_t)/sizeof(os_bit32)));
                    pESGL = (SG_Element_t *)((os_bit8 *)(ESGLs->addr.DmaMemory.dmaMemoryPtr) + ((pESGL + ChunksPerESGL - 1)->L32 - ESGLs->addr.DmaMemory.dmaMemoryLower32));
                }
            }

            break;

        case  CM_Unknown_CM_Type_Inbound:
            SFQ_MemoryDescriptor = &(pCThread->Calculation.MemoryLayout.SFQ);
            SFQ_Ele_Size = SFQ_MemoryDescriptor->elementSize;

            SFQ_Index = pGenericCM->Unused_DWord_1 & CM_Inbound_SFQ_Prod_Index_MASK;

            Frame_Len = pGenericCM->Unused_DWord_2;

            if(Frame_Len % 64) SFQ_Num_entry = (Frame_Len / 64) + 1;
            else SFQ_Num_entry = (Frame_Len / 64);

            SFQ_Start_index = SFQ_Index - SFQ_Num_entry;

            if (SFQ_Start_index > SFQ_MemoryDescriptor->elements)
                SFQ_Start_index += SFQ_MemoryDescriptor->elements;

            FCHS =    (FCHS_t *)((os_bit8 *)(SFQ_MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr)
                                        +(SFQ_Start_index * SFQ_Ele_Size));
            Payload = (FC_ELS_Unknown_Payload_t *)((os_bit8 *)FCHS + sizeof(FCHS_t));

            /* first SFQ entry, 64 bytes */
            osSwapUpwardNonPayloadToSystemEndian((void *)FCHS,    (os_bit32) (sizeof(FCHS_t)/sizeof(os_bit32)));
            osSwapUpwardPayloadToFcLinkEndian((void *)Payload, (os_bit32) ((SFQ_Ele_Size-sizeof(FCHS_t))/sizeof(os_bit32)));

            while (--SFQ_Num_entry)
            {
                if (++SFQ_Start_index >= SFQ_MemoryDescriptor->elements)
                {
                  Payload = (FC_ELS_Unknown_Payload_t *)((os_bit8 *)(SFQ_MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr));
                  SFQ_Start_index = 0;
                }
                else
                  Payload = (FC_ELS_Unknown_Payload_t *)((os_bit8 *)Payload + SFQ_Ele_Size);

                osSwapUpwardPayloadToFcLinkEndian((void *)Payload, (os_bit32) (SFQ_Ele_Size/4));
            }
            break;

        case  CM_Unknown_CM_Type_Frame_Manager:
        case  CM_Unknown_CM_Type_Outbound:
        case  CM_Unknown_CM_Type_Error_Idle:
        case  CM_Unknown_CM_Type_ERQ_Frozen:
        default:
        break;
    }

    return;
}

/* End: Big_Endian_Code */


event_t CFuncCheckCstate(agRoot_t * hpRoot)
{
    CThread_t       *  CThread      = CThread_ptr(hpRoot);
    event_t            event_to_send = 0;
    os_bit32           FM_Status       = 0;

    if( ! CThread->ProcessingIMQ )
    {
        if( CThread->thread_hdr.currentState != CStateNormal )
        {

            FM_Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );
            switch( CThread->thread_hdr.currentState )
            {
                case CStateResetNeeded:
                            if (CThread->InitAsNport )
                            {
                                if((FM_Status & FRAMEMGR_NPORT_OK ) == FRAMEMGR_NPORT_OK )
                                {
                                    if( CFuncAll_clear( hpRoot ))
                                    {
                                        if(CThread->NumberOfFLOGITimeouts >= MAX_FLOGI_TIMEOUTS )
                                        {
                                            event_to_send = (event_t) CEventGoToInitializeFailed;
                                        }
                                        else
                                        {
                                            event_to_send = (event_t) CEventResetIfNeeded;
                                        }
                                    }
                                    else
                                    {
                                         event_to_send = (event_t) CEventDoInitalize;
                                    }
                                    break;
                                }
                                 if((FM_Status & FRAMEMGR_NPORT_LINK_FAIL ) == FRAMEMGR_NPORT_LINK_FAIL )
                                {
                                    event_to_send = (event_t) CEventGoToInitializeFailed;
                                    break;
                                }

                                if(CThread->Loop_Reset_Event_to_Send == CEventInitalizeSuccess )
                                {
                                    CThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
                                }
                                else
                                {
                                    event_to_send = (event_t) CThread->Loop_Reset_Event_to_Send;
                                }
                                break;
                            }
                            else
                            {
                                if((FM_Status & FRAMEMGR_LINK_DOWN ) == FRAMEMGR_LINK_DOWN )
                                {
                                    if((FM_Status & ChipIOUp_Frame_Manager_Status_LSM_MASK ) == ChipIOUp_Frame_Manager_Status_LSM_Loop_Fail )
                                    {/*This helps to get out of FM storms */
                                        event_to_send = (event_t) CEventGoToInitializeFailed;
                                    }
                                    else
                                    {
                                        event_to_send = (event_t) 0;
                                    }
                                }
                                else
                                {
                                    if((FM_Status & ChipIOUp_Frame_Manager_Status_LP ) == ChipIOUp_Frame_Manager_Status_LP )
                                    {
                                        event_to_send = CEventResetIfNeeded;
                                    }
                                    else
                                    {
                                        if((FM_Status & ChipIOUp_Frame_Manager_Status_LUP ) == ChipIOUp_Frame_Manager_Status_LUP )
                                        {
                                            event_to_send = CEventResetIfNeeded;
                                        }
                                        else
                                        {
                                            event_to_send = (event_t) CThread->Loop_Reset_Event_to_Send;
                                        }
                                    }
                                }
                            }

                            break;
                case CStateExternalLogout:
                            event_to_send = CEventResetIfNeeded;
                            break;
                case CStateExternalDeviceReset:
                            event_to_send = CEventDoExternalDeviceReset;
                            break;
                case CStateLoopFailedReInit:
                            event_to_send = CEventDoInitalize;
                            fiLogDebugString(hpRoot,
                                            CFuncCheckCstateErrorLevel,
                                            "%s %s FM_Status %08X ",
                                            "CFuncCheckCstate","CStateLoopFailedReInit",
                                            (void *)agNULL,(void *)agNULL,
                                            FM_Status,
                                            0,0,
                                            0,0,0,0,0);
                            if( FM_Status &  ~ChipIOUp_Frame_Manager_Status_LSM_MASK  )
                            {
                                if( CThread->LoopPreviousSuccess)
                                {
                                    event_to_send = CEventLoopConditionCleared;
                                }
                                else
                                {
                                    event_to_send = CEventDoInitalize;
                                }
                            }
                            else
                            {
                                event_to_send = CEventDoInitalize;
                            }
                            break;

                case CStateInitializeFailed:

                            fiLogDebugString(hpRoot,
                                            CFuncCheckCstateErrorLevel,
                                            "%s %s FM_Status %08X FM_IMQ_Status %08X ",
                                            "CFuncCheckCstate","CStateInitializeFailed",
                                            (void *)agNULL,(void *)agNULL,
                                            FM_Status,
                                            CThread->From_IMQ_Frame_Manager_Status,
                                            0,0,0,0,0,0);
#ifdef NPORT_STUFF
                            if (CThread->InitAsNport )
                            {
                                if (CFuncToReinit( FM_Status))
                                {
                                    if((FM_Status &  FRAMEMGR_NPORT_OK) == FRAMEMGR_NPORT_OK )
                                    {
                                        CThread->Loop_Reset_Event_to_Send = CEventResetDetected;
                                        if(CThread->DeviceSelf)
                                        {
                                            event_to_send = CEventAllocFlogiThread;
                                        }
                                        else
                                        {
                                            event_to_send = CEventInitChipSuccess;
                                        }


                                        if(CThread->FlogiRcvdFromTarget )
                                        {
                                            event_to_send = 0;
                                        }

                                            fiLogDebugString(hpRoot,
                                                        CFuncCheckCstateErrorLevel,
                                                       "%s My_ID %08X Self %p ETS %d FM %08X",
                                                        "CFCS",(char *)agNULL,
                                                        CThread->DeviceSelf,(void *)agNULL,
                                                        fiComputeCThread_S_ID(CThread),
                                                        event_to_send,
                                                        FM_Status,
                                                        0,0,0,0,0);

                                        break;

                                    }
                                    if((FM_Status & FRAMEMGR_NPORT_NO_CABLE ) == FRAMEMGR_NPORT_NO_CABLE )
                                    {
                                        if((FM_Status & ChipIOUp_Frame_Manager_Status_PSM_LF2 ) == ChipIOUp_Frame_Manager_Status_PSM_LF2 )
                                        {
                                            osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control, ChipIOUp_Frame_Manager_Control_CMD_Clear_LF );

                                            osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, FM_Status);

                                        }

                                        event_to_send = (event_t) 0;
                                    }
                                    else
                                    {
                                        fiLogDebugString(hpRoot,
                                                        CFuncCheckCstateErrorLevel,
                                                        "%s CFuncToReinit Failed %s FM_Status %08X FM_IMQ_Status %08X ",
                                                        "CFuncCheckCstate","CEventLIPEventStorm",
                                                        (void *)agNULL,(void *)agNULL,
                                                        FM_Status,
                                                        CThread->From_IMQ_Frame_Manager_Status,0,
                                                        0,0,0,0,0);
                                        /* CThread->TwoGigSuccessfull = CFuncDoLinkSpeedNegotiation( hpRoot); */
                                        event_to_send = CEventLIPEventStorm;
                                    }
                                }
                                else
                                {
                                    event_to_send = 0;
                                }

                                return (event_to_send);
                            }
#endif /* NPORT_STUFF */

                            if(  FM_Status  &  ChipIOUp_Frame_Manager_Status_OLS      )
                            {
                                if(CThread->NOS_DetectedInIMQ > 12)
                                {
                                    CThread->NOS_DetectedInIMQ =0;
                                    event_to_send = CEventDoInitalize;
                                }
                                CThread->NOS_DetectedInIMQ ++;
                                break;
                            }
                            if( FM_Status == ChipIOUp_Frame_Manager_Status_LP)
                            {
                                if( CThread->DeviceSelf != agNULL)
                                {
                                    fiLogDebugString(hpRoot,
                                                    FCMainLogErrorLevel,
                                                    "%s %s FM_Status %08X ",
                                                    "CFuncCheckCstate","Recover NO LIP",
                                                    (void *)agNULL,(void *)agNULL,
                                                    FM_Status,
                                                    0,0,0,0,0,0,0);
                                    if( CFuncShowWhereDevThreadsAre( hpRoot))
                                    {
                                        event_to_send = 0;
                                        break;
                                    }
                                    if(CThread->NumberOfFLOGITimeouts >= MAX_FLOGI_TIMEOUTS )
                                    {
                                        event_to_send = (event_t) 0;
                                        break;
                                    }
                                    CThread->Loop_Reset_Event_to_Send = CEventResetDetected;
                                    event_to_send = CEventAsyncLoopEventDetected;
                                    break;
                                }
                                break;
                            }

                            if( ( FM_Status & ChipIOUp_Frame_Manager_Status_LSM_MASK ) == ChipIOUp_Frame_Manager_Status_LSM_Loop_Fail)
                            {
                                if( CThread->TwoGigSuccessfull )
                                {
                                    CThread->NumberTwoGigFailures++;
                                    if(CThread->NumberTwoGigFailures % 30 )
                                    {
                                        event_to_send = 0;
                                    }
                                    else /* Retry every 30 seconds */
                                    {
                                        fiLogString(hpRoot,
                                                    "%s FM %08X %d",
                                                    "Check BIOS 2 gig setting",(char *)agNULL,
                                                    (void *)agNULL,(void *)agNULL,
                                                    FM_Status,
                                                    CThread->NumberTwoGigFailures,
                                                    0,0,0,0,0,0);

                                        event_to_send = CEventDoInitalize;
                                    }
                                }
                                break;
                            }
                            else
                            {

                                if( ! ( FM_Status & ~ ( ChipIOUp_Frame_Manager_Status_LSM_MASK |
                                                        ChipIOUp_Frame_Manager_Status_BYP)       ) )
                                {
                                    event_to_send = CEventDoInitalize;
                                }
                                else
                                {

                                    if(!( FM_Status & ~ ChipIOUp_Frame_Manager_Status_LP ))
                                    {
                                        event_to_send = CEventDoInitalize;
                                    }
                                    else
                                    {
                                        if( FM_Status &  ChipIOUp_Frame_Manager_Status_LUP  )
                                        {
                                            event_to_send = CEventDoInitalize;
                                        }
                                        else
                                        {
                                            if( FM_Status &  ChipIOUp_Frame_Manager_Status_BYP  )
                                            {
                                                event_to_send = 0;
                                            }
                                            else
                                            {
                                                if( FM_Status &  ChipIOUp_Frame_Manager_Status_LPF  )
                                                {
                                                    /* Check this
                                                    osChipIOUpWriteBit32(hpRoot, ChipIOUp_Frame_Manager_Status,FM_Status );
                                                    event_to_send = 0;
                                                    */
                                                }
                                                else
                                                {
                                                    if(( FM_Status &  ~ChipIOUp_Frame_Manager_Status_LSM_MASK ) > ChipIOUp_Frame_Manager_Status_LSM_Initialize)
                                                    {
                                                        event_to_send = 0;
                                                    }
                                                    else
                                                    {
                                                        /* event_to_send = CEventLIPEventStorm;
                                                        */

                                                        CThread->Loop_Reset_Event_to_Send = CEventResetDetected;
                                                        event_to_send = CEventAsyncLoopEventDetected;

                                                        fiLogDebugString(hpRoot,
                                                                        FCMainLogErrorLevel,
                                                                        "%s sends %s FM_Status %08X real FM %08X Result %08X",
                                                                        "CFuncCheckCstate","CEventLIPEventStorm",
                                                                        (void *)agNULL,(void *)agNULL,
                                                                        FM_Status,
                                                                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                                                                        ( ! ( FM_Status & ~ ( ChipIOUp_Frame_Manager_Status_LSM_MASK |
                                                                              ChipIOUp_Frame_Manager_Status_BYP)  ) ),
                                                                        0,0,0,0,0);

                                                        fiLogDebugString(hpRoot,
                                                                        FCMainLogErrorLevel,
                                                                        "IntStat %08X Logical Ints %08X",
                                                                        (char *)agNULL,(char *)agNULL,
                                                                        (void *)agNULL,(void *)agNULL,
                                                                        CFuncRead_Interrupts(hpRoot),
                                                                        CThread->sysIntsLogicallyEnabled,
                                                                        0,0,0,0,0,0);

                                                        fiLogDebugString(hpRoot,
                                                                        SFStateLogErrorLevel,
                                                                        "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                                                                        (char *)agNULL,(char *)agNULL,
                                                                        (void *)agNULL,(void *)agNULL,
                                                                        CThread_ptr(hpRoot)->LOOP_DOWN,
                                                                        CThread_ptr(hpRoot)->IDLE_RECEIVED,
                                                                        CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                                                                        CThread_ptr(hpRoot)->ERQ_FROZEN,
                                                                        CThread_ptr(hpRoot)->FCP_FROZEN,
                                                                        CThread_ptr(hpRoot)->ProcessingIMQ,
                                                                        0,0);

                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            break;
                            }
                            break;
                case CStateRSCNErrorBackIOs:
                            break;


                default: break;
            }

            if ( event_to_send != 0 )
            {
                fiLogDebugString(hpRoot,
                                FCMainLogErrorLevel,
                                "%s Not CStateNormal %d Send event %d FM_Status %08X Lrsts %d",
                                "CFuncCheckCstate",(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                CThread->thread_hdr.currentState,
                                event_to_send,
                                FM_Status,
                                CThread->Loop_Reset_Event_to_Send,0,0,0,0);

/*
                if( CThread->thread_hdr.currentState == CStateInitializeFailed )
                {
                    CThread->TwoGigSuccessfull = CFuncDoLinkSpeedNegotiation( hpRoot);
                }
*/
            }
        }
        else
        {
            if (CThread->InitAsNport )
            {
                FM_Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );
                if((FM_Status & ChipIOUp_Frame_Manager_Status_PSM_MASK) != ChipIOUp_Frame_Manager_Status_PSM_ACTIVE)
                {
                fiLogDebugString(hpRoot,
                                FCMainLogErrorLevel,
                                "%s FM_Status %08X ",
                                "CFuncCheckCstate",(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                FM_Status,
                                0,0,
                                0,0,0,0,0);

                }

            }
        }
    }
    return(event_to_send);
}

void CFuncCompleteAllActiveCDBThreads( agRoot_t * hpRoot,os_bit32 CompletionStatus, event_t event_to_send )
{
    CThread_t     * pCThread      = CThread_ptr(hpRoot);
    DevThread_t   * pDevThread;
    CDBThread_t   * pCDBThread;
    fiList_t      * pCdbList;
    fiList_t      * pDevList;

    pDevList = &pCThread->Active_DevLink;
    pDevList = pDevList->flink;

    while((&pCThread->Active_DevLink) != pDevList)
    {
        pDevThread = hpObjectBase(DevThread_t,
                              DevLink,pDevList );

        if (fiListNotEmpty( &pDevThread->Active_CDBLink_0  ))
        {

            pCdbList = &pDevThread->Active_CDBLink_0;
            pCdbList = pCdbList->flink;

            while((&pDevThread->Active_CDBLink_0) != pCdbList)
            {
                pCDBThread = hpObjectBase(CDBThread_t,
                                          CDBLink,pCdbList );

                pCdbList = pCdbList->flink;

                fiLogDebugString(hpRoot,
                                CStateLogConsoleLevelLip,
                                "%s Device %p Sending Event (%d) CDBthread %p State %d @ %d",
                                "CfuncCompleteAllActiveCDBThreads",(char *)agNULL,
                                pDevThread,pCDBThread,
                                event_to_send,
                                pCDBThread->thread_hdr.currentState,
                                pCDBThread->TimeStamp,
                                0,0,0,0,0);

                pCDBThread->CompletionStatus =  CompletionStatus;
                fiSendEvent(&pCDBThread->thread_hdr,event_to_send);
            }
        }
        if (fiListNotEmpty( &pDevThread->Active_CDBLink_1  ))
        {

            pCdbList = &pDevThread->Active_CDBLink_1;
            pCdbList = pCdbList->flink;

            while((&pDevThread->Active_CDBLink_1) != pCdbList)
            {
                pCDBThread = hpObjectBase(CDBThread_t,
                                          CDBLink,pCdbList );

                pCdbList = pCdbList->flink;

                fiLogDebugString(hpRoot,
                                CStateLogConsoleLevelLip,
                                "%s Device %p Sending Event (%d) CDBthread %p State %d @ %d",
                                "CfuncCompleteAllActiveCDBThreads",(char *)agNULL,
                                pDevThread,pCDBThread,
                                event_to_send,
                                pCDBThread->thread_hdr.currentState,
                                pCDBThread->TimeStamp,
                                0,0,0,0,0);

                pCDBThread->CompletionStatus =  CompletionStatus;

                fiSendEvent(&pCDBThread->thread_hdr,event_to_send);
            }
        }
        if (fiListNotEmpty( &pDevThread->Active_CDBLink_2  ))
        {

            pCdbList = &pDevThread->Active_CDBLink_2;
            pCdbList = pCdbList->flink;

            while((&pDevThread->Active_CDBLink_2) != pCdbList)
            {
                pCDBThread = hpObjectBase(CDBThread_t,
                                          CDBLink,pCdbList );

                pCdbList = pCdbList->flink;

                fiLogDebugString(hpRoot,
                                CStateLogConsoleLevelLip,
                                "%s Device %p Sending Event (%d) CDBthread %p State %d @ %d",
                                "CfuncCompleteAllActiveCDBThreads",(char *)agNULL,
                                pDevThread,pCDBThread,
                                event_to_send,
                                pCDBThread->thread_hdr.currentState,
                                pCDBThread->TimeStamp,
                                0,0,0,0,0);

                pCDBThread->CompletionStatus =  CompletionStatus;

                fiSendEvent(&pCDBThread->thread_hdr,event_to_send);
            }
        }
        if (fiListNotEmpty( &pDevThread->Active_CDBLink_3  ))
        {

            pCdbList = &pDevThread->Active_CDBLink_3;
            pCdbList = pCdbList->flink;

            while((&pDevThread->Active_CDBLink_3) != pCdbList)
            {
                pCDBThread = hpObjectBase(CDBThread_t,
                                          CDBLink,pCdbList );

                pCdbList = pCdbList->flink;

                fiLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "%s Device %p Sending Event (%d) CDBthread %p State %d @ %d",
                                "CfuncCompleteAllActiveCDBThreads",(char *)agNULL,
                                pDevThread,pCDBThread,
                                event_to_send,
                                pCDBThread->thread_hdr.currentState,
                                pCDBThread->TimeStamp,
                                0,0,0,0,0);

                pCDBThread->CompletionStatus =  CompletionStatus;

                fiSendEvent(&pCDBThread->thread_hdr,event_to_send);
            }
        }
        if (fiListNotEmpty( &pDevThread->TimedOut_CDBLink  ))
        {

            pCdbList = &pDevThread->TimedOut_CDBLink;
            pCdbList = pCdbList->flink;

            while((&pDevThread->TimedOut_CDBLink) != pCdbList)
            {
                pCDBThread = hpObjectBase(CDBThread_t,
                                          CDBLink,pCdbList );

                pCdbList = pCdbList->flink;

                fiLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "%s Device %p Sending Event (%d) CDBthread %p State %d @ %d",
                                "CfuncCompleteAllActiveCDBThreads",(char *)agNULL,
                                pDevThread,pCDBThread,
                                event_to_send,
                                pCDBThread->thread_hdr.currentState,
                                pCDBThread->TimeStamp,
                                0,0,0,0,0);

                pCDBThread->CompletionStatus =  CompletionStatus;

                fiSendEvent(&pCDBThread->thread_hdr,event_to_send);
            }
        }

        pDevList = pDevList->flink;

    }

    if(pCThread->CDBpollingCount)
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "%s Ccnt Non Zero Ccnt %x",
                    "CFuncCompleteAllActiveCDBThreads",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->CDBpollingCount,
                    0,0,0,0,0,0,0);
    }

}

void CFuncCompleteAwaitingLoginCDBThreadsOnDevice(DevThread_t   * pDevThread ,os_bit32 CompletionStatus, event_t event_to_send )
{
    CDBThread_t   * pCDBThread;
    fiList_t      * pCdbList;

    if (fiListNotEmpty( &pDevThread->Awaiting_Login_CDBLink  ))
    {

        pCdbList = &pDevThread->Awaiting_Login_CDBLink;
        pCdbList = pCdbList->flink;

        while((&pDevThread->Awaiting_Login_CDBLink) != pCdbList)
        {
            pCDBThread = hpObjectBase(CDBThread_t,
                                      CDBLink,pCdbList );

            pCdbList = pCdbList->flink;

            fiLogDebugString(pDevThread->thread_hdr.hpRoot,
                            CStateLogConsoleLevelLip,
                            "%s Device %p Sending Event (%d) CDBthread %p State %d @ %d",
                            "CFuncCompleteAwaitingLoginCDBThreadsOnDevice",(char *)agNULL,
                            pDevThread,pCDBThread,
                            event_to_send,
                            pCDBThread->thread_hdr.currentState,
                            pCDBThread->TimeStamp,
                            0,0,0,0,0);

            pCDBThread->CompletionStatus =  CompletionStatus;

            fiSendEvent(&pCDBThread->thread_hdr,event_to_send);
        }
    }

}

void CFuncCompleteActiveCDBThreadsOnDevice(DevThread_t * pDevThread ,os_bit32 CompletionStatus, event_t event_to_send )
{
    agRoot_t      * hpRoot        = pDevThread->thread_hdr.hpRoot;
    CThread_t     * pCThread      = CThread_ptr(hpRoot);
    CDBThread_t   * pCDBThread;
    fiList_t      * pCdbList;

    if (fiListNotEmpty( &pDevThread->Active_CDBLink_0  ))
    {

        pCdbList = &pDevThread->Active_CDBLink_0;
        pCdbList = pCdbList->flink;

        while((&pDevThread->Active_CDBLink_0) != pCdbList)
        {
            pCDBThread = hpObjectBase(CDBThread_t,
                                      CDBLink,pCdbList );

            pCdbList = pCdbList->flink;

            fiLogDebugString(hpRoot,
                            CStateLogConsoleLevelLip,
                            "%s Device %p Sending Event (%d) CDBthread %p State %d @ %d",
                            "CFuncCompleteActiveCDBThreadsOnDevice",(char *)agNULL,
                            pDevThread,pCDBThread,
                            event_to_send,
                            pCDBThread->thread_hdr.currentState,
                            pCDBThread->TimeStamp,
                            0,0,0,0,0);

            pCDBThread->CompletionStatus =  CompletionStatus;

            fiSendEvent(&pCDBThread->thread_hdr,event_to_send);
        }
    }
    if (fiListNotEmpty( &pDevThread->Active_CDBLink_1  ))
    {

        pCdbList = &pDevThread->Active_CDBLink_1;
        pCdbList = pCdbList->flink;

        while((&pDevThread->Active_CDBLink_1) != pCdbList)
        {
            pCDBThread = hpObjectBase(CDBThread_t,
                                      CDBLink,pCdbList );

            pCdbList = pCdbList->flink;

            fiLogDebugString(hpRoot,
                            CStateLogConsoleLevelLip,
                            "%s Device %p Sending Event (%d) CDBthread %p State %d @ %d",
                            "CFuncCompleteActiveCDBThreadsOnDevice",(char *)agNULL,
                            pDevThread,pCDBThread,
                            event_to_send,
                            pCDBThread->thread_hdr.currentState,
                            pCDBThread->TimeStamp,
                            0,0,0,0,0);

            pCDBThread->CompletionStatus =  CompletionStatus;

            fiSendEvent(&pCDBThread->thread_hdr,event_to_send);
        }
    }
    if (fiListNotEmpty( &pDevThread->Active_CDBLink_2  ))
    {

        pCdbList = &pDevThread->Active_CDBLink_2;
        pCdbList = pCdbList->flink;

        while((&pDevThread->Active_CDBLink_2) != pCdbList)
        {
            pCDBThread = hpObjectBase(CDBThread_t,
                                      CDBLink,pCdbList );

            pCdbList = pCdbList->flink;

            fiLogDebugString(hpRoot,
                            CStateLogConsoleLevelLip,
                            "%s Device %p Sending Event (%d) CDBthread %p State %d @ %d",
                            "CFuncCompleteActiveCDBThreadsOnDevice",(char *)agNULL,
                            pDevThread,pCDBThread,
                            event_to_send,
                            pCDBThread->thread_hdr.currentState,
                            pCDBThread->TimeStamp,
                            0,0,0,0,0);

            pCDBThread->CompletionStatus =  CompletionStatus;

            fiSendEvent(&pCDBThread->thread_hdr,event_to_send);
        }
    }
    if (fiListNotEmpty( &pDevThread->Active_CDBLink_3  ))
    {

        pCdbList = &pDevThread->Active_CDBLink_3;
        pCdbList = pCdbList->flink;

        while((&pDevThread->Active_CDBLink_3) != pCdbList)
        {
            pCDBThread = hpObjectBase(CDBThread_t,
                                      CDBLink,pCdbList );

            pCdbList = pCdbList->flink;

            fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "%s Device %p Sending Event (%d) CDBthread %p State %d @ %d",
                            "CFuncCompleteActiveCDBThreadsOnDevice",(char *)agNULL,
                            pDevThread,pCDBThread,
                            event_to_send,
                            pCDBThread->thread_hdr.currentState,
                            pCDBThread->TimeStamp,
                            0,0,0,0,0);

            pCDBThread->CompletionStatus =  CompletionStatus;

            fiSendEvent(&pCDBThread->thread_hdr,event_to_send);
        }
    }
    if (fiListNotEmpty( &pDevThread->TimedOut_CDBLink  ))
    {

        pCdbList = &pDevThread->TimedOut_CDBLink;
        pCdbList = pCdbList->flink;

        while((&pDevThread->TimedOut_CDBLink) != pCdbList)
        {
            pCDBThread = hpObjectBase(CDBThread_t,
                                      CDBLink,pCdbList );

            pCdbList = pCdbList->flink;

            fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "%s Device %p Sending Event (%d) CDBthread %p State %d @ %d",
                            "CFuncCompleteActiveCDBThreadsOnDevice",(char *)agNULL,
                            pDevThread,pCDBThread,
                            event_to_send,
                            pCDBThread->thread_hdr.currentState,
                            pCDBThread->TimeStamp,
                            0,0,0,0,0);

            pCDBThread->CompletionStatus =  CompletionStatus;

            fiSendEvent(&pCDBThread->thread_hdr,event_to_send);
        }
    }

    if (fiListNotEmpty( &pDevThread->Send_IO_CDBLink  ))
    {

        pCdbList = &pDevThread->Send_IO_CDBLink;
        pCdbList = pCdbList->flink;

        while((&pDevThread->Send_IO_CDBLink) != pCdbList)
        {
            pCDBThread = hpObjectBase(CDBThread_t,
                                      CDBLink,pCdbList );

            pCdbList = pCdbList->flink;

            fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "%s Device %p Sending Event (%d) CDBthread %p State %d @ %d",
                            "CFuncCompleteActiveCDBThreadsOnDevice",(char *)agNULL,
                            pDevThread,pCDBThread,
                            event_to_send,
                            pCDBThread->thread_hdr.currentState,
                            pCDBThread->TimeStamp,
                            0,0,0,0,0);

            pCDBThread->CompletionStatus =  CompletionStatus;

            fiSendEvent(&pCDBThread->thread_hdr,event_to_send);
        }
    }

    if(pCThread->CDBpollingCount)
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "%s Ccnt Non Zero Ccnt %x",
                    "CFuncCompleteActiveCDBThreadsOnDevice",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->CDBpollingCount,
                    0,0,0,0,0,0,0);
    }

}

agBOOLEAN CFuncCheckForDuplicateDevThread( agRoot_t     *hpRoot)
{
    FC_Port_ID_t  Port_ID;
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    DevThread_t   * pDevThread  = (DevThread_t *)agNULL;
    fiList_t      * pList;

/*
    CFuncShowDevThreadActive( hpRoot);
*/
    if(  fiListNotEmpty(&pCThread->Active_DevLink ) )
    {

        pList = &pCThread->Active_DevLink;
        pList = pList->flink;
        while((&pCThread->Active_DevLink) != pList)
        {
            pDevThread = hpObjectBase(DevThread_t, DevLink,pList );
            pList = pList->flink;

            Port_ID.Struct_Form.Domain = pDevThread->DevInfo.CurrentAddress.Domain;
            Port_ID.Struct_Form.Area   = pDevThread->DevInfo.CurrentAddress.Area;
            Port_ID.Struct_Form.AL_PA  = pDevThread->DevInfo.CurrentAddress.AL_PA;

            if( ! CFuncCheckIfPortActive(hpRoot, Port_ID))
            {
                fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "Called %s %s Device NOT Found D %x A %x ALPA %x != D %x A %x ALPA %x",
                        "CFuncCheckIfDevThreadActive","FAILED",
                        pDevThread,agNULL,
                        Port_ID.Struct_Form.Domain,
                        Port_ID.Struct_Form.Area,
                        Port_ID.Struct_Form.AL_PA,
                        pDevThread->DevInfo.CurrentAddress.Domain,
                        pDevThread->DevInfo.CurrentAddress.Area,
                        pDevThread->DevInfo.CurrentAddress.AL_PA,
                        0,0);

            }
        }
    }
    return(agFALSE);
}


agBOOLEAN CFuncCheckIfPortActive( agRoot_t     *hpRoot, FC_Port_ID_t  Port_ID)
{ /* Searches Active_DevLink if Port_ID found returns agTRUE */
    CThread_t     * pCThread        = CThread_ptr(hpRoot);
    DevThread_t   * pDevThread      = (DevThread_t *)agNULL;
    DevThread_t   * pDevThreadFound[3];

    fiList_t      * pList;
    os_bit32        Num_Devices = 0;

    pDevThreadFound[0] = (DevThread_t *)agNULL;
    pDevThreadFound[1] = (DevThread_t *)agNULL;
    pDevThreadFound[2] = (DevThread_t *)agNULL;

    if(  fiListNotEmpty(&pCThread->Active_DevLink ) )
    {
        pList = &pCThread->Active_DevLink;
        pList = pList->flink;
        while((&pCThread->Active_DevLink) != pList)
        {
            pDevThread = hpObjectBase(DevThread_t, DevLink,pList );
            pList = pList->flink;

            if(pDevThread->DevInfo.CurrentAddress.Domain != Port_ID.Struct_Form.Domain )
            {
                continue;
            }
            if(pDevThread->DevInfo.CurrentAddress.Area   != Port_ID.Struct_Form.Area)
            {
                continue;
            }
            if(pDevThread->DevInfo.CurrentAddress.AL_PA  != Port_ID.Struct_Form.AL_PA)
            {
                continue;
            }

            pDevThreadFound[Num_Devices] = pDevThread;

            if(Num_Devices++ > 3)Num_Devices=0;
/*
            fiLogString(hpRoot,
                    "%s %d %s %p Domain %x Area %x AL_PA %x",
                    "CFuncCheckIfDevThreadActive","Found",
                    pDevThread,agNULL,
                    Num_Devices,
                    Port_ID.Struct_Form.Domain,
                    Port_ID.Struct_Form.Area,
                    Port_ID.Struct_Form.AL_PA,
                    0,0,0,0);
*/
        }
    }
    else
    {
/*
        fiLogString(hpRoot,
                "%s %d %s D %x A %x ALPA %x",
                "CFuncCheckIfDevThreadActive","fiListNotEmpty(&pCThread->Active_DevLink )",
                ,agNULL,agNULL,
                Num_Devices,
                Port_ID.Struct_Form.Domain,
                Port_ID.Struct_Form.Area,
                Port_ID.Struct_Form.AL_PA,
                0,0,0,0);
*/
    }


    if(Num_Devices > 1 )
    {
        fiLogString(hpRoot,
                "%s %d %s Found %p Dup %p Domain %x Area %x AL_PA %x",
                "CFuncCheckIfDevThreadActive","Duplicates",
                pDevThreadFound[0],
                pDevThreadFound[1],
                Num_Devices,
                Port_ID.Struct_Form.Domain,
                Port_ID.Struct_Form.Area,
                Port_ID.Struct_Form.AL_PA,
                0,0,0,0);
    }

    if( Num_Devices != 0  )
    {
        return(agTRUE);
    }
    else
    {
/*
        fiLogString(hpRoot,
                "%s %d %s %p Domain %x Area %x AL_PA %x",
                "CFuncCheckIfDevThreadActive","NOT Found",
                pDevThread,agNULL,
                Num_Devices,
                Port_ID.Struct_Form.Domain,
                Port_ID.Struct_Form.Area,
                Port_ID.Struct_Form.AL_PA,
                0,0,0,0);
*/
        return(agFALSE);
    }
}

agBOOLEAN CFuncCheckIfPortPrev_Active( agRoot_t     *hpRoot, FC_Port_ID_t  Port_ID)
{ /* Searches Prev_Active_DevLink if Port_ID found returns agTRUE */
    CThread_t     * pCThread        = CThread_ptr(hpRoot);
    DevThread_t   * pDevThread      = (DevThread_t *)agNULL;
    DevThread_t   * pDevThreadFound[3];

    fiList_t      * pList;
    os_bit32        Num_Devices = 0;

    pDevThreadFound[0] = (DevThread_t *)agNULL;
    pDevThreadFound[1] = (DevThread_t *)agNULL;
    pDevThreadFound[2] = (DevThread_t *)agNULL;

    if(  fiListNotEmpty(&pCThread->Prev_Active_DevLink) )
    {
        pList = &pCThread->Prev_Active_DevLink;
        pList = pList->flink;
        while((&pCThread->Prev_Active_DevLink) != pList)
        {
            pDevThread = hpObjectBase(DevThread_t, DevLink,pList );
            pList = pList->flink;

            if(pDevThread->DevInfo.CurrentAddress.Domain != Port_ID.Struct_Form.Domain )
            {
                continue;
            }
            if(pDevThread->DevInfo.CurrentAddress.Area   != Port_ID.Struct_Form.Area)
            {
                continue;
            }
            if(pDevThread->DevInfo.CurrentAddress.AL_PA  != Port_ID.Struct_Form.AL_PA)
            {
                continue;
            }

            pDevThreadFound[Num_Devices] = pDevThread;

            if(Num_Devices++ > 3)Num_Devices=0;
/*
            fiLogString(hpRoot,
                    "%s %d %s %p Domain %x Area %x AL_PA %x",
                    "CFuncCheckIfDevThreadPrevActive","Found",
                    pDevThread,agNULL,
                    Num_Devices,
                    Port_ID.Struct_Form.Domain,
                    Port_ID.Struct_Form.Area,
                    Port_ID.Struct_Form.AL_PA,
                    0,0,0,0);
*/
        }
    }
    else
    {
/*
        fiLogString(hpRoot,
                "%s %d %s D %x A %x ALPA %x",
                "CFuncCheckIfDevThreadPrevActive","fiListNotEmpty(&pCThread->Prev_Active_DevLink )",
                ,agNULL,agNULL,
                Num_Devices,
                Port_ID.Struct_Form.Domain,
                Port_ID.Struct_Form.Area,
                Port_ID.Struct_Form.AL_PA,
                0,0,0,0);
*/
    }


    if(Num_Devices > 1 )
    {
        fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "%s %d %s Found %p Dup %p Domain %x Area %x AL_PA %x",
                    "CFuncCheckIfDevThreadPrevActive","Duplicates",
                    pDevThreadFound[0],
                    pDevThreadFound[1],
                    Num_Devices,
                    Port_ID.Struct_Form.Domain,
                    Port_ID.Struct_Form.Area,
                    Port_ID.Struct_Form.AL_PA,
                    0,0,0,0);
    }

    if( Num_Devices != 0  )
    {
        return(agTRUE);
    }
    else
    {
/*
        fiLogString(hpRoot,
                "%s %d %s %p Domain %x Area %x AL_PA %x",
                "CFuncCheckIfDevThreadPrevActive","NOT Found",
                pDevThread,agNULL,
                Num_Devices,
                Port_ID.Struct_Form.Domain,
                Port_ID.Struct_Form.Area,
                Port_ID.Struct_Form.AL_PA,
                0,0,0,0);
*/
        return(agFALSE);
    }
}

void CFuncShowDevThreadActive( agRoot_t     *hpRoot)
{ /* Searches Active_DevLink if Port_ID found returns agTRUE */
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    DevThread_t   * pDevThread  = (DevThread_t *)agNULL;
    fiList_t      * pList;

    if(  fiListNotEmpty(&pCThread->Active_DevLink ) )
    {

        pList = &pCThread->Active_DevLink;
        pList = pList->flink;
        while((&pCThread->Active_DevLink) != pList)
        {
            pDevThread = hpObjectBase(DevThread_t, DevLink,pList );
            pList = pList->flink;
            fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "%s Found %p Domain %x Area %x AL_PA %x",
                        "CFuncShowDevThreadActive",(char *)agNULL,
                        pDevThread,agNULL,
                        pDevThread->DevInfo.CurrentAddress.Domain,
                        pDevThread->DevInfo.CurrentAddress.Area,
                        pDevThread->DevInfo.CurrentAddress.AL_PA,
                        0,0,0,0,0);

        }
    }

}


agBOOLEAN CFuncShowWhereDevThreadsAre( agRoot_t * hpRoot)
{
    CThread_t     * pCThread    = CThread_ptr(hpRoot);

    os_bit32           Active_DevLink_Count             = 0;
    os_bit32           Unknown_Slot_DevLink_Count       = 0;
    os_bit32           AWaiting_Login_DevLink_Count     = 0;
    os_bit32           AWaiting_ADISC_DevLink_Count     = 0;
    os_bit32           Slot_Searching_DevLink_Count     = 0;
    os_bit32           Prev_Active_DevLink_Count        = 0;
    os_bit32           Prev_Unknown_Slot_DevLink_Count  = 0;
    os_bit32           DevSelf_NameServer_DevLink_Count = 0;
    os_bit32           Free_DevLink_Count               = 0;

    Active_DevLink_Count                = fiNumElementsOnList(&pCThread->Active_DevLink);
    Unknown_Slot_DevLink_Count          = fiNumElementsOnList(&pCThread->Unknown_Slot_DevLink);
    AWaiting_Login_DevLink_Count        = fiNumElementsOnList(&pCThread->AWaiting_Login_DevLink);
    AWaiting_ADISC_DevLink_Count        = fiNumElementsOnList(&pCThread->AWaiting_ADISC_DevLink);
    Slot_Searching_DevLink_Count        = fiNumElementsOnList(&pCThread->Slot_Searching_DevLink);
    Prev_Active_DevLink_Count           = fiNumElementsOnList(&pCThread->Prev_Active_DevLink);
    Prev_Unknown_Slot_DevLink_Count     = fiNumElementsOnList(&pCThread->Prev_Unknown_Slot_DevLink);
    DevSelf_NameServer_DevLink_Count    = fiNumElementsOnList(&pCThread->DevSelf_NameServer_DevLink);
    Free_DevLink_Count                  = fiNumElementsOnList(&pCThread->Free_DevLink);


    if( pCThread->Calculation.MemoryLayout.DevThread.elements !=
        Active_DevLink_Count             +
        Unknown_Slot_DevLink_Count       +
        AWaiting_Login_DevLink_Count     +
        AWaiting_ADISC_DevLink_Count     +
        Slot_Searching_DevLink_Count     +
        Prev_Active_DevLink_Count        +
        Prev_Unknown_Slot_DevLink_Count  +
        DevSelf_NameServer_DevLink_Count +
        Free_DevLink_Count
      )
    {
            fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "Total Count Should be %d is %d",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCThread->Calculation.MemoryLayout.DevThread.elements,
                        Active_DevLink_Count             +
                        Unknown_Slot_DevLink_Count       +
                        Slot_Searching_DevLink_Count     +
                        Prev_Active_DevLink_Count        +
                        Prev_Unknown_Slot_DevLink_Count  +
                        Free_DevLink_Count               +
                        DevSelf_NameServer_DevLink_Count +
                        AWaiting_Login_DevLink_Count     +
                        AWaiting_ADISC_DevLink_Count,
                        0,0,0,0,0,0);

            fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s Count %d",
                            "Active_DevLink",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            Active_DevLink_Count,
                            0,0,0,0,0,0,0
                            );
            fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s Count %d",
                            "Unknown_Slot_DevLink",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            Unknown_Slot_DevLink_Count,
                            0,0,0,0,0,0,0
                            );
            fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s Count %d",
                            "Slot_Searching_DevLink",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            Slot_Searching_DevLink_Count,
                            0,0,0,0,0,0,0
                            );
            fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s Count %d",
                            "Prev_Active_DevLink",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            Prev_Active_DevLink_Count,
                            0,0,0,0,0,0,0
                            );
            fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s Count %d",
                            "Prev_Unknown_Slot_DevLink",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            Prev_Unknown_Slot_DevLink_Count,
                            0,0,0,0,0,0,0
                            );
            fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s Count %d",
                            "Free_DevLink",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            Free_DevLink_Count,
                            0,0,0,0,0,0,0
                            );
            fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s Count %d",
                            "DevSelf_NameServer_DevLink",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            DevSelf_NameServer_DevLink_Count,
                            0,0,0,0,0,0,0
                            );

            fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s Count %d",
                            "AWaiting_Login_DevLink",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            AWaiting_Login_DevLink_Count,
                            0,0,0,0,0,0,0
                            );
            fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s Count %d",
                            "AWaiting_ADISC_DevLink",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            AWaiting_ADISC_DevLink_Count,
                            0,0,0,0,0,0,0
                            );

        return agTRUE;
    }
    return agFALSE;

}

agBOOLEAN CFuncQuietShowWhereDevThreadsAre( agRoot_t * hpRoot)
{
    CThread_t     * pCThread    = CThread_ptr(hpRoot);

    os_bit32           Active_DevLink_Count             = 0;
    os_bit32           Unknown_Slot_DevLink_Count       = 0;
    os_bit32           AWaiting_Login_DevLink_Count     = 0;
    os_bit32           AWaiting_ADISC_DevLink_Count     = 0;
    os_bit32           Slot_Searching_DevLink_Count     = 0;
    os_bit32           Prev_Active_DevLink_Count        = 0;
    os_bit32           Prev_Unknown_Slot_DevLink_Count  = 0;
    os_bit32           DevSelf_NameServer_DevLink_Count = 0;
    os_bit32           Free_DevLink_Count               = 0;

    Active_DevLink_Count                = fiNumElementsOnList(&pCThread->Active_DevLink);
    Unknown_Slot_DevLink_Count          = fiNumElementsOnList(&pCThread->Unknown_Slot_DevLink);
    AWaiting_Login_DevLink_Count        = fiNumElementsOnList(&pCThread->AWaiting_Login_DevLink);
    AWaiting_ADISC_DevLink_Count        = fiNumElementsOnList(&pCThread->AWaiting_ADISC_DevLink);
    Slot_Searching_DevLink_Count        = fiNumElementsOnList(&pCThread->Slot_Searching_DevLink);
    Prev_Active_DevLink_Count           = fiNumElementsOnList(&pCThread->Prev_Active_DevLink);
    Prev_Unknown_Slot_DevLink_Count     = fiNumElementsOnList(&pCThread->Prev_Unknown_Slot_DevLink);
    DevSelf_NameServer_DevLink_Count    = fiNumElementsOnList(&pCThread->DevSelf_NameServer_DevLink);
    Free_DevLink_Count                  = fiNumElementsOnList(&pCThread->Free_DevLink);


    if( pCThread->Calculation.MemoryLayout.DevThread.elements !=
        Active_DevLink_Count             +
        Unknown_Slot_DevLink_Count       +
        AWaiting_Login_DevLink_Count     +
        AWaiting_ADISC_DevLink_Count     +
        Slot_Searching_DevLink_Count     +
        Prev_Active_DevLink_Count        +
        Prev_Unknown_Slot_DevLink_Count  +
        DevSelf_NameServer_DevLink_Count +
        Free_DevLink_Count
      )
    {
        return agTRUE;
    }
    return agFALSE;

}

os_bit32 CFuncCountFC4_Devices( agRoot_t * hpRoot )
{
    CThread_t     * pCThread      = CThread_ptr(hpRoot);
    DevThread_t   * pDevThread;
    os_bit32        Num_FC4_Devices = 0;
    fiList_t      * pDevList;

    pDevList = &pCThread->Active_DevLink;
    pDevList = pDevList->flink;

    while((&pCThread->Active_DevLink) != pDevList)
    {
        pDevThread = hpObjectBase(DevThread_t,
                              DevLink,pDevList );

        pDevList = pDevList->flink;
        if( pDevThread->DevInfo.DeviceType & agDevSCSITarget)
        {
            Num_FC4_Devices++;
        }

    }
return( Num_FC4_Devices );
}

void CFuncWhatStateAreDevThreads(agRoot_t   *    hpRoot )
{

    CThread_t                  *CThread                    = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *DevThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.DevThread);
    DevThread_t                *DevThread                  = DevThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr;
    os_bit32                    DevThread_size             = DevThread_MemoryDescriptor->elementSize;
    os_bit32                    total_DevThreads           = DevThread_MemoryDescriptor->elements;
    os_bit32                    DevThread_index;


    for (DevThread_index = 0;
         DevThread_index < total_DevThreads;
         DevThread_index++)
    {

        fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "DevThread %p State %d EL %3d  Cnt %d",
                (char *)agNULL,(char *)agNULL,
                DevThread,agNULL,
                DevThread->thread_hdr.currentState,
                fiNumElementsOnList(&DevThread->DevLink),
                DevThread_index,
                0,0,0,0,0);

        DevThread = (DevThread_t *)((os_bit8 *)DevThread + DevThread_size);
    }

}

agBOOLEAN CFuncShowWhereSFThreadsAre( agRoot_t * hpRoot)
{
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    os_bit32        Free_SFLink_Count;

    Free_SFLink_Count                = fiNumElementsOnList(&pCThread->Free_SFLink);

    if( pCThread->Calculation.MemoryLayout.SFThread.elements != Free_SFLink_Count)
    {
        fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "%s %s Count %d",
                        "CFuncShowWhereSFThreadsAre","Free_SFLink",
                        (void *)agNULL,(void *)agNULL,
                        Free_SFLink_Count,
                        0,0,0,0,0,0,0
                        );
        return agTRUE;
    }
    return agFALSE;

}

void CFuncWhatStateAreSFThreads(agRoot_t   *    hpRoot )
{

    CThread_t                  * CThread                    = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t * SFThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.SFThread);
    SFThread_t                 * SFThread                  = SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr;
    os_bit32                     SFThread_size             = SFThread_MemoryDescriptor->elementSize;
    os_bit32                     total_SFThreads           = SFThread_MemoryDescriptor->elements;
    os_bit32                     SFThread_index;


    for (SFThread_index = 0;
         SFThread_index < total_SFThreads;
         SFThread_index++)
    {
        if( SFThread->thread_hdr.currentState != SFStateFree || fiNumElementsOnList(&SFThread->SFLink) > total_SFThreads )
        {
            fiLogDebugString(hpRoot,
                       FCMainLogErrorLevel,
                       "%s SFThread %p State %d EL %3d  Cnt %d",
                       "CFuncWhatStateAreSFThreads",(char *)agNULL,
                       SFThread,agNULL,
                       SFThread->thread_hdr.currentState,
                       fiNumElementsOnList(&SFThread->SFLink),
                       SFThread_index,
                       0,0,0,0,0);

        }
        SFThread = (SFThread_t *)((os_bit8 *)SFThread + SFThread_size);
    }

}


void CFuncWhatStateAreCDBThreads(agRoot_t   *    hpRoot )
{

    CThread_t                  *CThread                    = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *CDBThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.CDBThread);
    CDBThread_t                *CDBThread                  = CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr;
    os_bit32                    CDBThread_size             = CDBThread_MemoryDescriptor->elementSize;
    os_bit32                    total_CDBThreads           = CDBThread_MemoryDescriptor->elements;
    os_bit32                    CDBThread_index;

    for (CDBThread_index = 0;
         CDBThread_index < total_CDBThreads;
         CDBThread_index++)
    {
        fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "CDBThread %p State %d EL %3d Index %X X_ID %3X",
                (char *)agNULL,(char *)agNULL,
                CDBThread,agNULL,
                CDBThread->thread_hdr.currentState,
                fiNumElementsOnList(&CDBThread->CDBLink),
                CDBThread_index,
                CDBThread->X_ID,
                0,0,0,0);

        CDBThread = (CDBThread_t *)((os_bit8 *)CDBThread + CDBThread_size);
    }

}



agBOOLEAN CFuncShowWhereTgtThreadsAre( agRoot_t * hpRoot)
{
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    os_bit32           Free_TgtLink_Count;

    Free_TgtLink_Count                = fiNumElementsOnList(&pCThread->Free_TgtLink);

    if( pCThread->Calculation.MemoryLayout.TgtThread.elements != Free_TgtLink_Count)
    {
        fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "%s Count %d",
                        "Free_TgtLink",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        Free_TgtLink_Count,
                        0,0,0,0,0,0,0
                        );
        return agTRUE;
    }
    return agFALSE;

}



agBOOLEAN CFuncShowWhereCDBThreadsAre( agRoot_t * hpRoot)
{
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    DevThread_t   * DevThread;
    fiList_t      * pDevList;

    os_bit32           Free_CDBLink_Count    =0;
    os_bit32           Initial_Free_CDBLink_Count    =0;

    os_bit32           Awaiting_Login_CDBLink_Count    =0;

    os_bit32           Send_IO_CDBLink_Count   =0;
    os_bit32           Active_CDBLink_0_Count  =0;
    os_bit32           Active_CDBLink_1_Count  =0;
    os_bit32           Active_CDBLink_2_Count  =0;
    os_bit32           Active_CDBLink_3_Count  =0;
    os_bit32           TimedOut_CDBLink_Count  =0;

    Initial_Free_CDBLink_Count                = fiNumElementsOnList(&pCThread->Free_CDBLink);

    pDevList = &pCThread->Active_DevLink;
    pDevList = pDevList->flink;

    while((&pCThread->Active_DevLink) != pDevList)
    {
        DevThread = hpObjectBase(DevThread_t,
                              DevLink,pDevList );
        if(fiListNotEmpty( &(DevThread->Send_IO_CDBLink) ))
        {
            Send_IO_CDBLink_Count   += fiNumElementsOnList(&DevThread->Send_IO_CDBLink);
        }

        if(fiListNotEmpty( &(DevThread->TimedOut_CDBLink) ))
        {
            TimedOut_CDBLink_Count  += fiNumElementsOnList(&DevThread->TimedOut_CDBLink);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_3)))
        {
            Active_CDBLink_3_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_3);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_2)))
        {
            Active_CDBLink_2_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_2);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_1)))
        {
            Active_CDBLink_1_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_1);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_0)))
        {
            Active_CDBLink_0_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_0);
        }

        if(fiListNotEmpty(&(DevThread->Awaiting_Login_CDBLink)))
        {
            Awaiting_Login_CDBLink_Count += fiNumElementsOnList(&DevThread->Awaiting_Login_CDBLink);
        }
        pDevList = pDevList->flink;
    }

    pDevList = &pCThread->AWaiting_Login_DevLink;
    pDevList = pDevList->flink;

    while((&pCThread->AWaiting_Login_DevLink) != pDevList)
    {
        DevThread = hpObjectBase(DevThread_t,
                              DevLink,pDevList );
        if(fiListNotEmpty( &(DevThread->Send_IO_CDBLink) ))
        {
            Send_IO_CDBLink_Count   += fiNumElementsOnList(&DevThread->Send_IO_CDBLink);
        }

        if(fiListNotEmpty( &(DevThread->TimedOut_CDBLink) ))
        {
            TimedOut_CDBLink_Count  += fiNumElementsOnList(&DevThread->TimedOut_CDBLink);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_3)))
        {
            Active_CDBLink_3_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_3);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_2)))
        {
            Active_CDBLink_2_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_2);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_1)))
        {
            Active_CDBLink_1_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_1);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_0)))
        {
            Active_CDBLink_0_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_0);
        }

        if(fiListNotEmpty(&(DevThread->Awaiting_Login_CDBLink)))
        {
            Awaiting_Login_CDBLink_Count += fiNumElementsOnList(&DevThread->Awaiting_Login_CDBLink);
        }
        pDevList = pDevList->flink;
    }

    pDevList = &pCThread->AWaiting_ADISC_DevLink;
    pDevList = pDevList->flink;

    while((&pCThread->AWaiting_ADISC_DevLink) != pDevList)
    {
        DevThread = hpObjectBase(DevThread_t,
                              DevLink,pDevList );
        if(fiListNotEmpty( &(DevThread->Send_IO_CDBLink) ))
        {
            Send_IO_CDBLink_Count   += fiNumElementsOnList(&DevThread->Send_IO_CDBLink);
        }

        if(fiListNotEmpty( &(DevThread->TimedOut_CDBLink) ))
        {
            TimedOut_CDBLink_Count  += fiNumElementsOnList(&DevThread->TimedOut_CDBLink);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_3)))
        {
            Active_CDBLink_3_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_3);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_2)))
        {
            Active_CDBLink_2_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_2);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_1)))
        {
            Active_CDBLink_1_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_1);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_0)))
        {
            Active_CDBLink_0_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_0);
        }

        if(fiListNotEmpty(&(DevThread->Awaiting_Login_CDBLink)))
        {
            Awaiting_Login_CDBLink_Count += fiNumElementsOnList(&DevThread->Awaiting_Login_CDBLink);
        }
        pDevList = pDevList->flink;
    }

    pDevList = &pCThread->Prev_Active_DevLink;
    pDevList = pDevList->flink;

    while((&pCThread->Prev_Active_DevLink) != pDevList)
    {
        DevThread = hpObjectBase(DevThread_t,
                              DevLink,pDevList );
        if(fiListNotEmpty( &(DevThread->Send_IO_CDBLink) ))
        {
            Send_IO_CDBLink_Count   += fiNumElementsOnList(&DevThread->Send_IO_CDBLink);
        }

        if(fiListNotEmpty( &(DevThread->TimedOut_CDBLink) ))
        {
            TimedOut_CDBLink_Count  += fiNumElementsOnList(&DevThread->TimedOut_CDBLink);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_3)))
        {
            Active_CDBLink_3_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_3);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_2)))
        {
            Active_CDBLink_2_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_2);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_1)))
        {
            Active_CDBLink_1_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_1);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_0)))
        {
            Active_CDBLink_0_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_0);
        }

        if(fiListNotEmpty(&(DevThread->Awaiting_Login_CDBLink)))
        {
            Awaiting_Login_CDBLink_Count += fiNumElementsOnList(&DevThread->Awaiting_Login_CDBLink);
        }
        pDevList = pDevList->flink;
    }

    pDevList = &pCThread->Unknown_Slot_DevLink;
    pDevList = pDevList->flink;

    while((&pCThread->Unknown_Slot_DevLink) != pDevList)
    {
        DevThread = hpObjectBase(DevThread_t,
                              DevLink,pDevList );
        if(fiListNotEmpty( &(DevThread->Send_IO_CDBLink) ))
        {
            Send_IO_CDBLink_Count   += fiNumElementsOnList(&DevThread->Send_IO_CDBLink);
        }

        if(fiListNotEmpty( &(DevThread->TimedOut_CDBLink) ))
        {
            TimedOut_CDBLink_Count  += fiNumElementsOnList(&DevThread->TimedOut_CDBLink);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_3)))
        {
            Active_CDBLink_3_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_3);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_2)))
        {
            Active_CDBLink_2_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_2);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_1)))
        {
            Active_CDBLink_1_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_1);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_0)))
        {
            Active_CDBLink_0_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_0);
        }

        if(fiListNotEmpty(&(DevThread->Awaiting_Login_CDBLink)))
        {
            Awaiting_Login_CDBLink_Count += fiNumElementsOnList(&DevThread->Awaiting_Login_CDBLink);
        }
        pDevList = pDevList->flink;
    }

    pDevList = &pCThread->Slot_Searching_DevLink;
    pDevList = pDevList->flink;

    while((&pCThread->Slot_Searching_DevLink) != pDevList)
    {
        DevThread = hpObjectBase(DevThread_t,
                              DevLink,pDevList );
        if(fiListNotEmpty( &(DevThread->Send_IO_CDBLink) ))
        {
            Send_IO_CDBLink_Count   += fiNumElementsOnList(&DevThread->Send_IO_CDBLink);
        }

        if(fiListNotEmpty( &(DevThread->TimedOut_CDBLink) ))
        {
            TimedOut_CDBLink_Count  += fiNumElementsOnList(&DevThread->TimedOut_CDBLink);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_3)))
        {
            Active_CDBLink_3_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_3);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_2)))
        {
            Active_CDBLink_2_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_2);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_1)))
        {
            Active_CDBLink_1_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_1);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_0)))
        {
            Active_CDBLink_0_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_0);
        }

        if(fiListNotEmpty(&(DevThread->Awaiting_Login_CDBLink)))
        {
            Awaiting_Login_CDBLink_Count += fiNumElementsOnList(&DevThread->Awaiting_Login_CDBLink);
        }
        pDevList = pDevList->flink;
    }
    pDevList = &pCThread->Prev_Unknown_Slot_DevLink;
    pDevList = pDevList->flink;

    while((&pCThread->Prev_Unknown_Slot_DevLink) != pDevList)
    {
        DevThread = hpObjectBase(DevThread_t,
                              DevLink,pDevList );
        if(fiListNotEmpty( &(DevThread->Send_IO_CDBLink) ))
        {
            Send_IO_CDBLink_Count   += fiNumElementsOnList(&DevThread->Send_IO_CDBLink);
        }

        if(fiListNotEmpty( &(DevThread->TimedOut_CDBLink) ))
        {
            TimedOut_CDBLink_Count  += fiNumElementsOnList(&DevThread->TimedOut_CDBLink);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_3)))
        {
            Active_CDBLink_3_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_3);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_2)))
        {
            Active_CDBLink_2_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_2);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_1)))
        {
            Active_CDBLink_1_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_1);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_0)))
        {
            Active_CDBLink_0_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_0);
        }

        if(fiListNotEmpty(&(DevThread->Awaiting_Login_CDBLink)))
        {
            Awaiting_Login_CDBLink_Count += fiNumElementsOnList(&DevThread->Awaiting_Login_CDBLink);
        }
        pDevList = pDevList->flink;
    }
    pDevList = &pCThread->DevSelf_NameServer_DevLink;
    pDevList = pDevList->flink;

    while((&pCThread->DevSelf_NameServer_DevLink) != pDevList)
    {
        DevThread = hpObjectBase(DevThread_t,
                              DevLink,pDevList );
        if(fiListNotEmpty( &(DevThread->Send_IO_CDBLink) ))
        {
            Send_IO_CDBLink_Count   += fiNumElementsOnList(&DevThread->Send_IO_CDBLink);
        }

        if(fiListNotEmpty( &(DevThread->TimedOut_CDBLink) ))
        {
            TimedOut_CDBLink_Count  += fiNumElementsOnList(&DevThread->TimedOut_CDBLink);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_3)))
        {
            Active_CDBLink_3_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_3);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_2)))
        {
            Active_CDBLink_2_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_2);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_1)))
        {
            Active_CDBLink_1_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_1);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_0)))
        {
            Active_CDBLink_0_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_0);
        }

        if(fiListNotEmpty(&(DevThread->Awaiting_Login_CDBLink)))
        {
            Awaiting_Login_CDBLink_Count += fiNumElementsOnList(&DevThread->Awaiting_Login_CDBLink);
        }
        pDevList = pDevList->flink;
    }
    pDevList = &pCThread->RSCN_Recieved_NameServer_DevLink;
    pDevList = pDevList->flink;

    while((&pCThread->RSCN_Recieved_NameServer_DevLink) != pDevList)
    {
        DevThread = hpObjectBase(DevThread_t,
                              DevLink,pDevList );
        if(fiListNotEmpty( &(DevThread->Send_IO_CDBLink) ))
        {
            Send_IO_CDBLink_Count   += fiNumElementsOnList(&DevThread->Send_IO_CDBLink);
        }

        if(fiListNotEmpty( &(DevThread->TimedOut_CDBLink) ))
        {
            TimedOut_CDBLink_Count  += fiNumElementsOnList(&DevThread->TimedOut_CDBLink);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_3)))
        {
            Active_CDBLink_3_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_3);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_2)))
        {
            Active_CDBLink_2_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_2);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_1)))
        {
            Active_CDBLink_1_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_1);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_0)))
        {
            Active_CDBLink_0_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_0);
        }

        if(fiListNotEmpty(&(DevThread->Awaiting_Login_CDBLink)))
        {
            Awaiting_Login_CDBLink_Count += fiNumElementsOnList(&DevThread->Awaiting_Login_CDBLink);
        }
        pDevList = pDevList->flink;
    }

    Free_CDBLink_Count                = fiNumElementsOnList(&pCThread->Free_CDBLink);

    if( Initial_Free_CDBLink_Count != Free_CDBLink_Count)
    {
        fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "%s Count Free count WRONG was %d IS now %d",
                        "CDBThread",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        Initial_Free_CDBLink_Count,
                        Free_CDBLink_Count,
                        0,0,0,0,0,0 );
    }

    if( pCThread->Calculation.MemoryLayout.CDBThread.elements !=
            Free_CDBLink_Count +
            Send_IO_CDBLink_Count +
            Active_CDBLink_0_Count +
            Active_CDBLink_1_Count +
            Active_CDBLink_2_Count +
            Active_CDBLink_3_Count +
            Awaiting_Login_CDBLink_Count +
            TimedOut_CDBLink_Count          )
    {
        fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "%s Count WRONG Should be %d IS %d",
                        "CDBThread",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCThread->Calculation.MemoryLayout.CDBThread.elements,
                        Free_CDBLink_Count +
                        Send_IO_CDBLink_Count +
                        Active_CDBLink_0_Count +
                        Active_CDBLink_1_Count +
                        Active_CDBLink_2_Count +
                        Active_CDBLink_3_Count +
                        Awaiting_Login_CDBLink_Count +
                        TimedOut_CDBLink_Count,
                        0,0,0,0,0,0
                        );

         fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "Free %x Send %x A0 %x A1 %x A2 %x A3 %x A login %x TO %x",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        Free_CDBLink_Count,
                        Send_IO_CDBLink_Count,
                        Active_CDBLink_0_Count,
                        Active_CDBLink_1_Count,
                        Active_CDBLink_2_Count,
                        Active_CDBLink_3_Count,
                        Awaiting_Login_CDBLink_Count,
                        TimedOut_CDBLink_Count );

         fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "Free %x Active %x Un %x Login %x ADISC %x SS %x PrevA login %x Prev Un %x",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        fiNumElementsOnList(&pCThread->Free_DevLink),
                        fiNumElementsOnList(&pCThread->Active_DevLink),
                        fiNumElementsOnList(&pCThread->Unknown_Slot_DevLink),
                        fiNumElementsOnList(&pCThread->AWaiting_Login_DevLink),
                        fiNumElementsOnList(&pCThread->AWaiting_ADISC_DevLink),
                        fiNumElementsOnList(&pCThread->Slot_Searching_DevLink),
                        fiNumElementsOnList(&pCThread->Prev_Active_DevLink),
                        fiNumElementsOnList(&pCThread->Prev_Unknown_Slot_DevLink) );



        return agTRUE;
    }
    return agFALSE;

}

/*+
  Function: CFuncCheckForTimeouts
   Purpose: Moves IO lists from ealier (start ) queues to later queues
            once an IO gets to TimedOut_CDBLink it is checked for timeouts
   Returns: Directly TimeOutDetected  Indirectly Sent_Abort if IO's were aborted
 Called By: 
     Calls: CFuncCheckActiveDuringLinkEvent
CFuncFC_Tape
fiListNotEmpty
fiListEnqueueListAtTailFast            
-*/
agBOOLEAN CFuncCheckForTimeouts(agRoot_t *hpRoot, fiList_t * pCheckDevList)
{
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    DevThread_t   * DevThread;
    fiList_t      * pDevList;
    agBOOLEAN returnvalue = agFALSE;
    agBOOLEAN SentAbort = agFALSE;

    pDevList = pCheckDevList;
    pDevList = pDevList->flink;

    while(pCheckDevList != pDevList)
    {
        DevThread = hpObjectBase(DevThread_t,
                              DevLink,pDevList );


        if(fiListNotEmpty( &(DevThread->TimedOut_CDBLink) ))
        {

            CFuncFC_Tape( hpRoot, &(DevThread->TimedOut_CDBLink) ,DevThread );
            returnvalue =  CFuncCheckActiveDuringLinkEvent( hpRoot, &(DevThread->TimedOut_CDBLink) ,&SentAbort,DevThread );

        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_3)))
        {

            CFuncFC_Tape( hpRoot, &(DevThread->Active_CDBLink_3),DevThread  );

            fiListEnqueueListAtTailFast( &(DevThread->Active_CDBLink_3), &(DevThread->TimedOut_CDBLink));
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_2)))
        {

/*
            fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s %s Not Empty ! ALPA %X Ccnt %x Dcnt %x EL %x",
                            "CFCFT","Active_CDBLink_2",
                            (void *)agNULL,(void *)agNULL,
                            DevThread->DevInfo.CurrentAddress.AL_PA,
                            pCThread->CDBpollingCount,
                            DevThread->pollingCount,
                            fiNumElementsOnList(&(DevThread->Active_CDBLink_2)),
                            0,0,0,0 );
*/
            CFuncFC_Tape( hpRoot, &(DevThread->Active_CDBLink_2) ,DevThread );
            fiListEnqueueListAtTailFast( &(DevThread->Active_CDBLink_2), &(DevThread->Active_CDBLink_3))
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_1)))
        {
/*
            fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s %s Not Empty ! ALPA %X Ccnt %x Dcnt %x EL %x",
                            "CFCFT","Active_CDBLink_1",
                            (void *)agNULL,(void *)agNULL,
                            DevThread->DevInfo.CurrentAddress.AL_PA,
                            pCThread->CDBpollingCount,
                            DevThread->pollingCount,
                            fiNumElementsOnList(&(DevThread->Active_CDBLink_1)),
                            0,0,0,0 );
*/
            CFuncFC_Tape( hpRoot, &(DevThread->Active_CDBLink_1) ,DevThread );

            fiListEnqueueListAtTailFast( &(DevThread->Active_CDBLink_1), &(DevThread->Active_CDBLink_2));
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_0)))
        {
/*
            fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s %s Not Empty ! ALPA %X Ccnt %x Dcnt %x EL %x",
                            "CFCFT","Active_CDBLink_0",
                            (void *)agNULL,(void *)agNULL,
                            DevThread->DevInfo.CurrentAddress.AL_PA,
                            pCThread->CDBpollingCount,
                            DevThread->pollingCount,
                            fiNumElementsOnList(&(DevThread->Active_CDBLink_0)),
                            0,0,0,0 );
*/
            fiListEnqueueListAtTailFast( &(DevThread->Active_CDBLink_0), &(DevThread->Active_CDBLink_1));
        }

        if(fiListNotEmpty(&(DevThread->Send_IO_CDBLink)))
        {

            fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s %s Not Empty ! ALPA %X Ccnt %x Dcnt %x EL %x",
                            "CFCFT","Send_IO_CDBLink",
                            (void *)agNULL,(void *)agNULL,
                            DevThread->DevInfo.CurrentAddress.AL_PA,
                            pCThread->CDBpollingCount,
                            DevThread->pollingCount,
                            fiNumElementsOnList(&(DevThread->Send_IO_CDBLink)),
                            0,0,0,0 );

            fiSendEvent( &(DevThread->thread_hdr), DevEventSendIO );
        }

        pDevList = pDevList->flink;
    }
/*
    CFuncShowWhereDevThreadsAre(hpRoot);
    CFuncShowWhereTgtThreadsAre(hpRoot);

    if( CFuncShowWhereSFThreadsAre(hpRoot))
    {
        CFuncWhatStateAreSFThreads(hpRoot);
    }
*/

    if(SentAbort)
    {
        fiLogString(hpRoot,
                        "%s %s agTRUE !",
                        "CFCFT","SentAbort",
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);

        fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "%s %s agTRUE !",
                        "CFCFT","SentAbort",
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0 );
    }
    return( returnvalue);
}

/*+
  Function: CFuncCheckActiveDuringLinkEvent
   Purpose: Checks ActiveDuringLinkEvent flag for given list on given device
            Only passed TimedOut_CDBLink If link is not empty a timeout is detected
   Returns: Directly TimeOutDetected  Indirectly Sent_Abort if IO's were aborted
 Called By: CFuncCheckForTimeouts
     Calls: CDBEventAlloc_Abort
            CDBEvent_PrepareforAbort
-*/
agBOOLEAN CFuncCheckActiveDuringLinkEvent( agRoot_t * hpRoot, fiList_t * pShowList,  agBOOLEAN * Sent_Abort , DevThread_t * DevThread )
{
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    CDBThread_t   * pCDBThread;
    fiList_t      * pCdbList;
    agBOOLEAN TimeOutDetected = agFALSE;

    pCdbList = pShowList;
    pCdbList = pCdbList->flink;

    while((pShowList) != pCdbList)
    {
        pCDBThread = hpObjectBase(CDBThread_t,
                                  CDBLink,pCdbList );

        pCdbList = pCdbList->flink;

        if(pCDBThread->thread_hdr.threadType == threadType_CDBThread)
        {
            fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "%s Dev %2X X_ID %3X State %d D %X Rd %d TAPE %x",
                            "CFCADLE",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            DevThread->DevInfo.CurrentAddress.AL_PA,
                            pCDBThread->X_ID,
                            pCDBThread->thread_hdr.currentState,
                            pCDBThread->CDBStartTimeBase.Lo - pCThread->LinkDownTime.Lo,
                            osTimeStamp(hpRoot) -  pCDBThread->TimeStamp,
                            DevThread->FC_TapeDevice,
                            0,0);

            TimeOutDetected = agTRUE;

            if( pCDBThread->ActiveDuringLinkEvent)
            {
               * Sent_Abort = agTRUE;
                pCDBThread->CompletionStatus = osIODevReset;
                fiSendEvent(&(pCDBThread->thread_hdr),CDBEvent_PrepareforAbort);
                if(! fiListElementOnList(  &(pCDBThread->CDBLink), &(pCThread->Free_CDBLink)))
                {
                    fiSendEvent(&(pCDBThread->thread_hdr),CDBEventAlloc_Abort);
                }
            }
            else
            {

                if(pCDBThread->CDBStartTimeBase.Hi == pCThread->LinkDownTime.Hi )
                {
                    if(pCDBThread->CDBStartTimeBase.Lo >= pCThread->LinkDownTime.Lo )
                    {
                        if(pCDBThread->CDBStartTimeBase.Lo - pCThread->LinkDownTime.Lo  < 11000000  )
                        {
                            * Sent_Abort = agTRUE;
                            pCDBThread->CompletionStatus = osIODevReset;
                            fiSendEvent(&(pCDBThread->thread_hdr),CDBEvent_PrepareforAbort);
                            if(! fiListElementOnList(  &(pCDBThread->CDBLink), &(pCThread->Free_CDBLink)))
                            {
                                fiSendEvent(&(pCDBThread->thread_hdr),CDBEventAlloc_Abort);
                            }
                        }
                    }
                }
                else
                {
                    fiLogDebugString(hpRoot,
                                    FCMainLogErrorLevel,
                                    "%s %s  ALPA %X Start %X Ldt %X EL %x",
                                    "CFCADLE","IO Taking long time",
                                    (void *)agNULL,(void *)agNULL,
                                    DevThread->DevInfo.CurrentAddress.AL_PA,
                                    pCDBThread->CDBStartTimeBase.Lo,
                                    pCThread->LinkDownTime.Lo,
                                    fiNumElementsOnList(&(DevThread->TimedOut_CDBLink)),
                                    0,0,0,0 );
                }
            }
        }
    }

return(TimeOutDetected);
}

void CFuncShowNonEmptyLists(agRoot_t *hpRoot, fiList_t * pCheckDevList)
{
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    DevThread_t   * DevThread;
    fiList_t      * pDevList;

    pDevList = pCheckDevList;
    pDevList = pDevList->flink;

    while(pCheckDevList != pDevList)
    {
        DevThread = hpObjectBase(DevThread_t,
                              DevLink,pDevList );

        if(fiListNotEmpty( &(DevThread->TimedOut_CDBLink) ))
        {
            fiLogString(hpRoot,
                    "%s %s ! ALPA %X Ccnt %x Dcnt %x EL %x A %d",
                    "CFSNEL","TimedOut",
                    (void *)agNULL,(void *)agNULL,
                    DevThread->DevInfo.CurrentAddress.AL_PA,
                    pCThread->CDBpollingCount,
                    DevThread->pollingCount,
                    fiNumElementsOnList(&(DevThread->TimedOut_CDBLink)),
                    pCThread->IOsActive,0,0,0 );
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_3)))
        {
            fiLogString(hpRoot,
                    "%s %s ! ALPA %X Ccnt %x Dcnt %x EL %x A %d",
                    "CFSNEL","CDBLink_3",
                    (void *)agNULL,(void *)agNULL,
                    DevThread->DevInfo.CurrentAddress.AL_PA,
                    pCThread->CDBpollingCount,
                    DevThread->pollingCount,
                    fiNumElementsOnList(&(DevThread->Active_CDBLink_3)),
                    pCThread->IOsActive,0,0,0 );
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_2)))
        {
            fiLogString(hpRoot,
                    "%s %s ! ALPA %X Ccnt %x Dcnt %x EL %x",
                    "CFSNEL","CDBLink_2",
                    (void *)agNULL,(void *)agNULL,
                    DevThread->DevInfo.CurrentAddress.AL_PA,
                    pCThread->CDBpollingCount,
                    DevThread->pollingCount,
                    fiNumElementsOnList(&(DevThread->Active_CDBLink_2)),
                    0,0,0,0 );
        }
        pDevList = pDevList->flink;
    }

}

void CFuncFC_Tape( agRoot_t * hpRoot, fiList_t * pShowList, DevThread_t * DevThread )
{

    CDBThread_t   * pCDBThread;
    fiList_t      * pCdbList;

    pCdbList = pShowList;
    pCdbList = pCdbList->flink;

    while(pShowList != pCdbList)
    {
        pCDBThread = hpObjectBase(CDBThread_t,
                                  CDBLink,pCdbList );

        pCdbList = pCdbList->flink;

        if(pCDBThread->thread_hdr.threadType == threadType_CDBThread)
        {
            if( DevThread->FC_TapeDevice)
            {
                fiLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "%s Dev %2X X_ID %3X State %d D %X Rd %d TAPE %x",
                                "CFuncFC_Tape",(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                DevThread->DevInfo.CurrentAddress.AL_PA,
                                pCDBThread->X_ID,
                                pCDBThread->thread_hdr.currentState,
                                pCDBThread->CDBStartTimeBase.Lo - CThread_ptr(hpRoot)->LinkDownTime.Lo,
                                osTimeStamp(hpRoot) -  pCDBThread->TimeStamp,
                                DevThread->FC_TapeDevice,
                                0,0);

                if( DevThread->FC_TapeDevice)
                {
                    if( pCDBThread->thread_hdr.currentState != CDBStateThreadFree)
                    {
                        fiLogString(hpRoot,
                                    "CDBThread currentState %02X  CDB Class %2X Type %2X State %2X Status %2X",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    (os_bit32)pCDBThread->thread_hdr.currentState,
                                    (os_bit32)pCDBThread->CDB_CMND_Class,
                                    (os_bit32)pCDBThread->CDB_CMND_Type,
                                    (os_bit32)pCDBThread->CDB_CMND_State,
                                    (os_bit32)pCDBThread->CDB_CMND_Status,
                                    0,0,0);

                        fiSendEvent(&(pCDBThread->thread_hdr),CDBEventREC_TOV);
                    }
                    continue;
                }
            }
        }
    }
}


agBOOLEAN IS_WITHIN(os_bit32 post, os_bit32 window, os_bit32 value, os_bit32 MAX)
{
    agBOOLEAN return_value = agFALSE;

    if( value == post)
    {
        return_value = agTRUE;
    }
    else
    {
        if( value > MAX )
        {
            return_value = agFALSE;
        }

        if( value > post)
        {
            if(value > post + window)
            {
                if(value + window >= MAX )
                {
                    if(post <= ((value + window) - MAX ))
                    {
                        return_value = agTRUE;
                    }
                    else /* post less than value plus window */
                    {
                        return_value = agFALSE;
                    }
                }
                else
                {
                    return_value = agFALSE;
                }
            }
            else /* value less than post plus window */
            {
                return_value = agTRUE;
            }
        }
        else /*  value less than  post */
        {
            if(value < post - window)
            {
                if( post + window >= MAX)
                {
                    if( value <= ((post + window) - MAX))
                    {
                        return_value = agTRUE;
                    }
                    else
                    {
                        return_value = agFALSE;
                    }
                }
                else
                {
                    if(post - value < window )
                    {
                        return_value = agTRUE;
                    }
                    else
                    {
                        return_value = agFALSE;
                    }
                }
            }
        }
    }
return(return_value);
}


os_bit32 CFuncShowActiveCDBThreadsOnQ( agRoot_t * hpRoot, fiList_t * pShowList, os_bit32 ERQ, os_bit32 Mode )
{
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    DevThread_t   * DevThread;
    fiList_t      * pDevList;
    os_bit32 NumActiveCDBThreads = 0;

    CDBThread_t   * CDBThread;
    fiList_t      * pCDBList;
    os_bit32           PlusMinus = 2;
    os_bit32           SearchOffset = 1;
    os_bit32           Max_ERQ     = pCThread->Calculation.MemoryLayout.ERQ.elements - 1;

/* Positive search offset
    if( ERQ + SearchOffset >= Max_ERQ )
    {
        ERQ = (( ERQ + SearchOffset) - Max_ERQ );
    }
    else
    {
        ERQ += SearchOffset;
    }
Positive search offset */

/* Negative search offset */
    if( ERQ < SearchOffset )
    {
        ERQ = Max_ERQ - ( SearchOffset - ERQ );
    }
    else
    {
        ERQ -= SearchOffset;
    }
/* Negative search offset */

    if( fiNumElementsOnList(pShowList) > 0xFFE)
    {
        fiLogString(hpRoot,
                        "List corrupt !!!!!!",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);

        fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "List corrupt !!!!!!",
                        (void *)agNULL,(void *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);
        /*Arbitrary number */
        NumActiveCDBThreads = 10000;
    }
    else
    {
        if(fiListNotEmpty((pShowList) ))
        {
            pDevList = pShowList;
            pDevList = pDevList->flink;

            while( pShowList!= pDevList)
            {
                DevThread = hpObjectBase(DevThread_t,
                                      DevLink,pDevList );
                if(fiListNotEmpty( &(DevThread->Send_IO_CDBLink) ))
                {
                    pCDBList= &(DevThread->Send_IO_CDBLink);
                    pCDBList= pCDBList->flink;
                    while((&(DevThread->Send_IO_CDBLink)) != pCDBList)
                    {
                        CDBThread = hpObjectBase(CDBThread_t,
                                              CDBLink, pCDBList);
                        if(IS_WITHIN(ERQ, PlusMinus, CDBThread->SentERQ, Max_ERQ) || Mode == ShowERQ )
                        {
                            if(!DevThread->FC_TapeDevice )
                            {
                                CDBThread->ActiveDuringLinkEvent = agTRUE;
                            }
                        }
                        if( Mode ==  ShowActive )
                        {
                            fiLogDebugString(hpRoot,
                                        FCMainLogErrorLevel,
                                        "%s %s Area %X ALPA %X  X_ID %3X AdLe %x State %d D %d ERQ %X SERQ %X",
                                        "CFSACDBs","Send CDB",
                                        (void *)agNULL,(void *)agNULL,
                                        DevThread->DevInfo.CurrentAddress.Area,
                                        DevThread->DevInfo.CurrentAddress.AL_PA,
                                        CDBThread->X_ID,
                                        CDBThread->ActiveDuringLinkEvent,
                                        CDBThread->thread_hdr.currentState,
                                        osTimeStamp(hpRoot) - CDBThread->TimeStamp,
                                        CFunc_Get_ERQ_Entry( hpRoot, CDBThread->X_ID ),
                                        CDBThread->SentERQ);
                        }
                        NumActiveCDBThreads += 1;
                        pCDBList= pCDBList->flink;
                    }
                }

                if(fiListNotEmpty( &(DevThread->TimedOut_CDBLink) ))
                {
                    pCDBList= &(DevThread->TimedOut_CDBLink);
                    pCDBList= pCDBList->flink;
                    while((&(DevThread->TimedOut_CDBLink)) != pCDBList)
                    {
                        CDBThread = hpObjectBase(CDBThread_t,
                                              CDBLink, pCDBList);

                        if(IS_WITHIN(ERQ, PlusMinus, CDBThread->SentERQ, Max_ERQ) || Mode ==  ShowERQ)
                        {
                            if(!DevThread->FC_TapeDevice )
                            {
                                CDBThread->ActiveDuringLinkEvent = agTRUE;
                            }
                        }

                        if( Mode ==  ShowActive )
                        {
                            fiLogDebugString(hpRoot,
                                        FCMainLogErrorLevel,
                                        "%s %s Area %X ALPA %X  X_ID %3X AdLe %x State %d D %d ERQ %X SERQ %X",
                                        "CFSACDBs","TOCDB",
                                        (void *)agNULL,(void *)agNULL,
                                        DevThread->DevInfo.CurrentAddress.Area,
                                        DevThread->DevInfo.CurrentAddress.AL_PA,
                                        CDBThread->X_ID,
                                        CDBThread->ActiveDuringLinkEvent,
                                        CDBThread->thread_hdr.currentState,
                                        osTimeStamp(hpRoot) - CDBThread->TimeStamp,
                                        CFunc_Get_ERQ_Entry( hpRoot, CDBThread->X_ID ),
                                        CDBThread->SentERQ);
                        }
                        NumActiveCDBThreads += 1;
                        pCDBList= pCDBList->flink;
                    }
                }
                if(fiListNotEmpty(&(DevThread->Active_CDBLink_3)))
                {
                    pCDBList= &(DevThread->Active_CDBLink_3);
                    pCDBList= pCDBList->flink;
                    while((&(DevThread->Active_CDBLink_3)) != pCDBList)
                    {
                        CDBThread = hpObjectBase(CDBThread_t,
                                              CDBLink, pCDBList);
                        if(IS_WITHIN(ERQ, PlusMinus, CDBThread->SentERQ, Max_ERQ) || Mode == ShowERQ )
                        {
                            if(!DevThread->FC_TapeDevice )
                            {
                                CDBThread->ActiveDuringLinkEvent = agTRUE;
                            }
                        }
                        if( Mode ==  ShowActive)
                        {
                            fiLogDebugString(hpRoot,
                                    FCMainLogErrorLevel,
                                    "%s %s Area %X ALPA %X  X_ID %3X AdLe %x State %d D %d ERQ %X SERQ %X",
                                    "CFSACDBs","CDBLink_3",
                                    (void *)agNULL,(void *)agNULL,
                                    DevThread->DevInfo.CurrentAddress.Area,
                                    DevThread->DevInfo.CurrentAddress.AL_PA,
                                    CDBThread->X_ID,
                                    CDBThread->ActiveDuringLinkEvent,
                                    CDBThread->thread_hdr.currentState,
                                    osTimeStamp(hpRoot) - CDBThread->TimeStamp,
                                    CFunc_Get_ERQ_Entry( hpRoot, CDBThread->X_ID ),
                                    CDBThread->SentERQ);
                        }

                        NumActiveCDBThreads += 1;
                        pCDBList= pCDBList->flink;
                    }
                }

                if(fiListNotEmpty(&(DevThread->Active_CDBLink_2)))
                {
                    pCDBList= &(DevThread->Active_CDBLink_2);
                    pCDBList= pCDBList->flink;
                    while((&(DevThread->Active_CDBLink_2)) != pCDBList)
                    {
                        CDBThread = hpObjectBase(CDBThread_t,
                                              CDBLink, pCDBList);

                        if(IS_WITHIN(ERQ, PlusMinus, CDBThread->SentERQ, Max_ERQ) || Mode == ShowERQ  )
                        {
                            if(!DevThread->FC_TapeDevice )
                            {
                                CDBThread->ActiveDuringLinkEvent = agTRUE;
                            }
                        }

                        if( Mode ==  ShowActive)
                        {
                            fiLogDebugString(hpRoot,
                                        FCMainLogErrorLevel,
                                        "%s %s Area %X ALPA %X  X_ID %3X AdLe %x State %d D %d ERQ %X SERQ %X",
                                        "CFSACDBs","CDBLink_2",
                                        (void *)agNULL,(void *)agNULL,
                                        DevThread->DevInfo.CurrentAddress.Area,
                                        DevThread->DevInfo.CurrentAddress.AL_PA,
                                        CDBThread->X_ID,
                                        CDBThread->ActiveDuringLinkEvent,
                                        CDBThread->thread_hdr.currentState,
                                        osTimeStamp(hpRoot) - CDBThread->TimeStamp,
                                        CFunc_Get_ERQ_Entry( hpRoot, CDBThread->X_ID ),
                                        CDBThread->SentERQ);
                        }
                        NumActiveCDBThreads += 1;
                        pCDBList= pCDBList->flink;
                    }
                }

                if(fiListNotEmpty(&(DevThread->Active_CDBLink_1)))
                {
                    pCDBList= &(DevThread->Active_CDBLink_1);
                    pCDBList= pCDBList->flink;
                    while((&(DevThread->Active_CDBLink_1)) != pCDBList)
                    {
                        CDBThread = hpObjectBase(CDBThread_t,
                                              CDBLink, pCDBList);

                        if(IS_WITHIN(ERQ, PlusMinus, CDBThread->SentERQ, Max_ERQ) || Mode ==  ShowERQ)
                        {
                            if(!DevThread->FC_TapeDevice )
                            {
                                CDBThread->ActiveDuringLinkEvent = agTRUE;
                            }
                        }

                        if( Mode ==  ShowActive )
                        {
                            fiLogDebugString(hpRoot,
                                        FCMainLogErrorLevel,
                                        "%s %s Area %X ALPA %X  X_ID %3X AdLe %x State %d D %d ERQ %X SERQ %X",
                                        "CFSACDBs","CDBLink_1",
                                        (void *)agNULL,(void *)agNULL,
                                        DevThread->DevInfo.CurrentAddress.Area,
                                        DevThread->DevInfo.CurrentAddress.AL_PA,
                                        CDBThread->X_ID,
                                        CDBThread->ActiveDuringLinkEvent,
                                        CDBThread->thread_hdr.currentState,
                                        osTimeStamp(hpRoot) - CDBThread->TimeStamp,
                                        CFunc_Get_ERQ_Entry( hpRoot, CDBThread->X_ID ),
                                        CDBThread->SentERQ);
                        }

                        NumActiveCDBThreads += 1;
                        pCDBList= pCDBList->flink;
                    }
                }
                if(fiListNotEmpty(&(DevThread->Active_CDBLink_0)))
                {
                    pCDBList= &(DevThread->Active_CDBLink_0);
                    pCDBList= pCDBList->flink;
                    while((&(DevThread->Active_CDBLink_0)) != pCDBList)
                    {
                        CDBThread = hpObjectBase(CDBThread_t,
                                              CDBLink, pCDBList);

                        if(IS_WITHIN(ERQ, PlusMinus, CDBThread->SentERQ, Max_ERQ) || Mode ==  ShowERQ)
                        {
                            if(!DevThread->FC_TapeDevice )
                            {
                                CDBThread->ActiveDuringLinkEvent = agTRUE;
                            }
                        }

                        if( Mode ==  ShowActive )
                        {
                            fiLogDebugString(hpRoot,
                                        FCMainLogErrorLevel,
                                        "%s %s Area %X ALPA %X  X_ID %3X AdLe %x State %d D %d ERQ %X SERQ %X",
                                        "CFSACDBs","CDBLink_0",
                                        (void *)agNULL,(void *)agNULL,
                                        DevThread->DevInfo.CurrentAddress.Area,
                                        DevThread->DevInfo.CurrentAddress.AL_PA,
                                        CDBThread->X_ID,
                                        CDBThread->ActiveDuringLinkEvent,
                                        CDBThread->thread_hdr.currentState,
                                        osTimeStamp(hpRoot) - CDBThread->TimeStamp,
                                        CFunc_Get_ERQ_Entry( hpRoot, CDBThread->X_ID ),
                                        CDBThread->SentERQ);
                        }
                        NumActiveCDBThreads += 1;
                        pCDBList= pCDBList->flink;
                    }
                }

                if(fiListNotEmpty(&(DevThread->Awaiting_Login_CDBLink)))
                {
                    pCDBList= &(DevThread->Awaiting_Login_CDBLink);
                    pCDBList= pCDBList->flink;
                    while((&(DevThread->Awaiting_Login_CDBLink)) != pCDBList)
                    {
                        CDBThread = hpObjectBase(CDBThread_t,
                                              CDBLink, pCDBList);

                        if(IS_WITHIN(ERQ, PlusMinus, CDBThread->SentERQ, Max_ERQ) || Mode == ShowERQ )
                        {
                            if(!DevThread->FC_TapeDevice )
                            {
                                CDBThread->ActiveDuringLinkEvent = agTRUE;
                            }
                        }
                        if( Mode ==  ShowActive )
                        {
                            fiLogDebugString(hpRoot,
                                        FCMainLogErrorLevel,
                                        "%s %s Area %X ALPA %X  X_ID %3X AdLe %x State %d D %d ERQ %X SERQ %X",
                                        "CFSACDBs","Awaiting_Login_CDBLink",
                                        (void *)agNULL,(void *)agNULL,
                                        DevThread->DevInfo.CurrentAddress.Area,
                                        DevThread->DevInfo.CurrentAddress.AL_PA,
                                        CDBThread->X_ID,
                                        CDBThread->ActiveDuringLinkEvent,
                                        CDBThread->thread_hdr.currentState,
                                        osTimeStamp(hpRoot) - CDBThread->TimeStamp,
                                        CFunc_Get_ERQ_Entry( hpRoot, CDBThread->X_ID ),
                                        CDBThread->SentERQ);
                        }
                        NumActiveCDBThreads += 1;
                        pCDBList= pCDBList->flink;
                    }
                }
                pDevList = pDevList->flink;
            }
        }
    }

    return(NumActiveCDBThreads);
}



os_bit32 CFuncShowActiveCDBThreads( agRoot_t * hpRoot, os_bit32 Mode)
{
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    os_bit32 ERQ = 0;
    os_bit32 NumActiveCDBThreads = 0;

    ERQ = osChipIOLoReadBit32(hpRoot, ChipIOLo_ERQ_Consumer_Index);

    fiLogDebugString(hpRoot,
                FCMainLogConsoleLevel,
                "%s CCnt %x ERQ %x",
                "CFuncShowActiveCDBThreads",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                pCThread->CDBpollingCount,
                ERQ,
                0,0,0,0,0,0);

    fiLogDebugString(hpRoot,
                FCMainLogConsoleLevel,
                "Now TimeBase %X %08X LinkDownTime %X %08X Delta %d",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                pCThread->TimeBase.Hi,
                pCThread->TimeBase.Lo,
                pCThread->LinkDownTime.Hi,
                pCThread->LinkDownTime.Lo,
                pCThread->TimeBase.Lo - pCThread->LinkDownTime.Lo,
                0,0,0);

    NumActiveCDBThreads += CFuncShowActiveCDBThreadsOnQ( hpRoot, (&pCThread->Active_DevLink), ERQ, Mode);

    fiLogDebugString(hpRoot,
                FCMainLogConsoleLevel,
                "%s OK",
                "Active_DevLink",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                0,0,0,0,0,0,0,0);

    NumActiveCDBThreads += CFuncShowActiveCDBThreadsOnQ( hpRoot, (&pCThread->AWaiting_Login_DevLink), ERQ, Mode);

    fiLogDebugString(hpRoot,
                FCMainLogConsoleLevel,
                "%s OK",
                "AWaiting_Login_DevLink",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                0,0,0,0,0,0,0,0);

    NumActiveCDBThreads += CFuncShowActiveCDBThreadsOnQ( hpRoot, (&pCThread->AWaiting_ADISC_DevLink), ERQ, Mode);

    fiLogDebugString(hpRoot,
                FCMainLogConsoleLevel,
                "%s OK",
                "AWaiting_ADISC_DevLink",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                0,0,0,0,0,0,0,0);

    NumActiveCDBThreads += CFuncShowActiveCDBThreadsOnQ( hpRoot, (&pCThread->Prev_Active_DevLink), ERQ, Mode);

    fiLogDebugString(hpRoot,
                FCMainLogConsoleLevel,
                "%s OK",
                "Prev_Active_DevLink",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                0,0,0,0,0,0,0,0);

    NumActiveCDBThreads += CFuncShowActiveCDBThreadsOnQ( hpRoot, (&pCThread->Unknown_Slot_DevLink), ERQ, Mode);

    fiLogDebugString(hpRoot,
                FCMainLogConsoleLevel,
                "%s OK",
                "Unknown_Slot_DevLink",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                0,0,0,0,0,0,0,0);

    NumActiveCDBThreads += CFuncShowActiveCDBThreadsOnQ( hpRoot, (&pCThread->Slot_Searching_DevLink), ERQ, Mode);

    fiLogDebugString(hpRoot,
                FCMainLogConsoleLevel,
                "%s OK",
                "Slot_Searching_DevLink",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                0,0,0,0,0,0,0,0);

    NumActiveCDBThreads += CFuncShowActiveCDBThreadsOnQ( hpRoot, (&pCThread->Prev_Unknown_Slot_DevLink), ERQ, Mode );

    fiLogDebugString(hpRoot,
                FCMainLogConsoleLevel,
                "%s OK",
                "Prev_Unknown_Slot_DevLink",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                0,0,0,0,0,0,0,0);

/*   NumActiveCDBThreads +=   CFuncShowActiveCDBThreadsOnQ( hpRoot, (&pCThread->DevSelf_NameServer_DevLink), ERQ, Mode );

    fiLogDebugString(hpRoot,
                FCMainLogConsoleLevel,
                "%s OK",
                "DevSelf_NameServer_DevLink",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                0,0,0,0,0,0,0,0);
*/
    NumActiveCDBThreads += CFuncShowActiveCDBThreadsOnQ( hpRoot, (&pCThread->RSCN_Recieved_NameServer_DevLink), ERQ, Mode);

    fiLogDebugString(hpRoot,
                FCMainLogConsoleLevel,
                "%s OK",
                "RSCN_Recieved_NameServer_DevLink",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                0,0,0,0,0,0,0,0);
    return(NumActiveCDBThreads);
}



os_bit32 CFunc_Get_ERQ_Entry( agRoot_t *hpRoot, os_bit32 Search_X_ID )
{
    CThread_t                  * pCThread= CThread_ptr(hpRoot);
    IRB_t                      * Base_ERQ_Entry;
    IRB_t                      * ERQ_Entry;
    X_ID_t                       X_ID;
    fiMemMapMemoryDescriptor_t * CDBThread_MemoryDescriptor = &pCThread->Calculation.MemoryLayout.CDBThread;
    fiMemMapMemoryDescriptor_t * ERQ_MemoryDescriptor = &pCThread->Calculation.MemoryLayout.ERQ;


    os_bit32 entry ;

    Base_ERQ_Entry = (IRB_t  *)pCThread->Calculation.MemoryLayout.ERQ.addr.DmaMemory.dmaMemoryPtr;

    for(entry = 0; entry < ERQ_MemoryDescriptor->elements; entry ++)
    {
        ERQ_Entry = Base_ERQ_Entry + entry;

        X_ID = (X_ID_t)(ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID & 0x00007fff);

        if(X_ID < CDBThread_MemoryDescriptor->elements)
        {

            if(X_ID == Search_X_ID)
            {
                break;
            }
        }
    }
    return( entry);
}

void CFuncWaitForFCP( agRoot_t *hpRoot )
{
    CThread_t                  * CThread= CThread_ptr(hpRoot);
    os_bit32 TimeOut = 1000;

    while(! CThread_ptr(hpRoot)->FCP_FROZEN)
    {
        osStallThread(hpRoot,1);
        CThread->FuncPtrs.Proccess_IMQ( hpRoot );
        TimeOut--;
        if(TimeOut== 0) break;

    }
    fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "%S LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x TimeOut %x",
                        "CFuncWaitForFCP",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        CThread_ptr(hpRoot)->LOOP_DOWN,
                        CThread_ptr(hpRoot)->IDLE_RECEIVED,
                        CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                        CThread_ptr(hpRoot)->ERQ_FROZEN,
                        CThread_ptr(hpRoot)->FCP_FROZEN,
                        CThread_ptr(hpRoot)->ProcessingIMQ,
                        TimeOut,0);
    CFunc_Always_Enable_Queues( hpRoot );

}

void CFuncFreezeFCP( agRoot_t *hpRoot )
{
    os_bit32 Value_To_Write;

    Value_To_Write = osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status );

    Value_To_Write |= ChipIOUp_TachLite_Control_FFA;

    CFuncWriteTL_ControlReg(hpRoot, Value_To_Write );
    fiLogDebugString(hpRoot,
                FCMainLogErrorLevel,
                "%s TL Status %08X",
                "CFuncFreezeFCP",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control),
                0,0,0,0,0,0);

}


void CFuncWriteTimeoutValues( agRoot_t *hpRoot, agTimeOutValue_t * TOV )
{

    fiLogString(hpRoot,
                    "%s Tov1 %X Tov2 %X",
                    "CFuncWriteTimeoutValues",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    Chip_Frame_Manager_TimeOut_Values_1(TOV->RT_Tov, TOV->ED_Tov),
                    Chip_Frame_Manager_TimeOut_Values_2(TOV->LP_Tov , TOV->AL_Time ),
                    0,0,0,0,0,0);

     osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_TimeOut_Values_1,
        Chip_Frame_Manager_TimeOut_Values_1(TOV->RT_Tov, TOV->ED_Tov));

     osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_TimeOut_Values_2,
        Chip_Frame_Manager_TimeOut_Values_2(TOV->LP_Tov , TOV->AL_Time ));

}

event_t CFuncProcessFcpRsp(agRoot_t * hpRoot, CDBThread_t * pCDBThread, event_t event_to_send )
{
    CThread_t               *  pCThread                      = CThread_ptr(hpRoot);

/**/
    os_bit8                 *  tmpptr;
    FC_FCP_RSP_Payload_t    *  fcprsp;
    os_bit32                   AdditionalSenseCode           = 0;
    os_bit32                   AdditionalSenseCodeQualifier  = 0;
    os_bit32                   SenseKey                      = 0;

    if(pCDBThread->FCP_RESP_Ptr)
    {
        fcprsp = (FC_FCP_RSP_Payload_t  * )(((os_bit8 *)pCDBThread->FCP_RESP_Ptr) + sizeof(FCHS_t));
        if( fcprsp->FCP_STATUS.SCSI_status_byte == 0x2 )
        {
            if( fcprsp->FCP_SNS_LEN)
            {
                if( event_to_send == CDBEventIoSuccess) /* off card response */
                {
                    event_to_send = CDBEventIoSuccessRSP;
                }


                tmpptr = (os_bit8 *)&fcprsp->FCP_SNS_LEN;
                tmpptr += 8;
                tmpptr += fcprsp->FCP_STATUS.ValidityStatusIndicators &
                            FC_FCP_RSP_FCP_STATUS_ValidityStatusIndicators_FCP_RSP_LEN_VALID ?
                            hpSwapBit32(fcprsp->FCP_RSP_LEN) : 0;


                SenseKey                     = (os_bit32)*(tmpptr+ SENSE_KEY_OFFSET) & 0xff;
                AdditionalSenseCode          = (os_bit32)*(tmpptr+ SENSE_ASC_OFFSET) & 0xff;
                AdditionalSenseCodeQualifier = (os_bit32)*(tmpptr+ SENSE_ASQ_OFFSET) & 0xff;

                fiLogDebugString(hpRoot,
                                CDBStateLogErrorLevel,
                                "%s SK %x ASC %x ASQ %x C %d @ %d X_ID %X",
                                "Check Condition",(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                SenseKey,
                                AdditionalSenseCode,
                                AdditionalSenseCodeQualifier,
                                pCThread->thread_hdr.currentState,
                                pCDBThread->TimeStamp,
                                pCDBThread->X_ID,0,0);

                if(SenseKey == 0x6 && AdditionalSenseCode   == POWER_ON_RESET_OR_BUS_DEVICE_RESET_OCCURRED )
                {

                    event_to_send = CDBEventIoSuccessRSP;

                    CFuncShowActiveCDBThreads( hpRoot,ShowERQ);
                    pCThread->LinkDownTime = pCThread->TimeBase;
/*
                    fiLogString(hpRoot,
                                        "%s SK %x ASC %x ASQ %x C %d @ %d",
                                        "Check Condition",(char *)agNULL,
                                        (void *)agNULL,(void *)agNULL,
                                        SenseKey,
                                        AdditionalSenseCode,
                                        AdditionalSenseCodeQualifier,
                                        pCThread->thread_hdr.currentState,
                                        pCDBThread->TimeStamp,0,0,0);

*/
                    return event_to_send;
                }
            }
        }
        else
        {
            if( fcprsp->FCP_STATUS.SCSI_status_byte )
            {

                if(pCDBThread->CDBRequest)
                fiLogDebugString(hpRoot,
                                CDBStateLogErrorLevel,
                                "%s %2X  @ %d",
                                "FCP_STATUS.SCSI_status_byte" ,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                (os_bit32)fcprsp->FCP_STATUS.SCSI_status_byte,
                                pCDBThread->TimeStamp,
                                0,0,0,0,0,0);

                event_to_send = CDBEventIoFailed;
            }
        }
#ifndef Performance_Debug
     fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    " %x scsi stat %x sense len %x",
                    "Good Completion valid",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)fcprsp->FCP_STATUS.ValidityStatusIndicators,
                    (os_bit32)fcprsp->FCP_STATUS.SCSI_status_byte,
                    (os_bit32)fcprsp->FCP_SNS_LEN,
                    0,0,0,0,0);
#endif /* Performance_Debug */
    }

    return event_to_send;
}


void internSingleThreadedEnter(agRoot_t   *    hpRoot,os_bit32  Caller )
{
    CThread_t *  pCThread;
    if( hpRoot ==  agNULL )
    {
        fiLogString(hpRoot,
                "%s hpRoot ==  agNULL Caller %d",
                "internSingleThreadedEnter",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                Caller,
                0,0,0,0,0,0,0);
        return;
    }
    pCThread = CThread_ptr(hpRoot);

    if( pCThread ==  agNULL )
    {
        fiLogString(hpRoot,
                "%s pCThread ==  agNULL Caller %d",
                "internSingleThreadedEnter",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                Caller,
                0,0,0,0,0,0,0);
        osSingleThreadedEnter( hpRoot );
        return;
    }

    if( pCThread->LastSingleThreadedEnterCaller != 0 )
    {
        fiLogString(hpRoot,
                "%s LastSingleThreadedEnterCaller(%d) != %d Should Be Zero Async %x",
                "internSingleThreadedEnter",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                Caller,
                pCThread->LastSingleThreadedEnterCaller,
                pCThread->LastAsyncSingleThreadedEnterCaller,
                0,0,0,0,0);
    }

    pCThread->LastSingleThreadedEnterCaller = Caller;

    osSingleThreadedEnter( hpRoot );

}
void internSingleThreadedLeave(agRoot_t   *    hpRoot,os_bit32  Caller )
{
    CThread_t *  pCThread;
    if( hpRoot ==  agNULL )
    {
        fiLogString(hpRoot,
                "%s hpRoot ==  agNULL Caller %d",
                "internSingleThreadedLeave",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                Caller,
                0,0,0,0,0,0,0);
        return;
    }
    pCThread = CThread_ptr(hpRoot);

    if( pCThread ==  agNULL )
    {
        fiLogString(hpRoot,
                "%s pCThread ==  agNULL Caller %d",
                "internSingleThreadedLeave",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                Caller,
                0,0,0,0,0,0,0);
        return;
    }

    if( pCThread->LastSingleThreadedEnterCaller != Caller )
    {
        fiLogString(hpRoot,
                "%s LastSingleThreadedEnterCaller(%d) != Last %d Async %d",
                "internSingleThreadedLeave",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                Caller,
                pCThread->LastSingleThreadedEnterCaller,
                pCThread->LastAsyncSingleThreadedEnterCaller,
                0,0,0,0,0);
    }
    pCThread->LastSingleThreadedEnterCaller = 0;

    osSingleThreadedLeave( hpRoot );

}

void internAsyncSingleThreadedLeave(agRoot_t   *    hpRoot,os_bit32  Caller )
{
    CThread_t *  pCThread;
    if( hpRoot ==  agNULL )
    {
        fiLogString(hpRoot,
                "%s hpRoot ==  agNULL Caller %d",
                "internAsyncSingleThreadedLeave",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                Caller,
                0,0,0,0,0,0,0);
        return;
    }
    pCThread = CThread_ptr(hpRoot);

    if( pCThread ==  agNULL )
    {
        fiLogString(hpRoot,
                "%s pCThread ==  agNULL Caller %d",
                "internAsyncSingleThreadedLeave",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                Caller,
                0,0,0,0,0,0,0);
        return;
    }

    if( pCThread->LastAsyncSingleThreadedEnterCaller != 0 )
    {
        fiLogString(hpRoot,
                "%s (%d)LastAsyncSingleThreadedEnteCaller != %d",
                "internAsyncSingleThreadedLeave",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                Caller,
                pCThread->LastAsyncSingleThreadedEnterCaller,
                0,0,0,0,0,0);
    }
    pCThread->LastSingleThreadedLeaveCaller = pCThread->LastSingleThreadedEnterCaller;

    pCThread->LastSingleThreadedEnterCaller = 0;

    pCThread->LastAsyncSingleThreadedEnterCaller = Caller;

    osSingleThreadedLeave( hpRoot );

}

void internAsyncSingleThreadedEnter(agRoot_t * hpRoot,os_bit32  Caller )
{
    CThread_t *  pCThread;
    if( hpRoot ==  agNULL )
    {
        fiLogString(hpRoot,
                "%s hpRoot ==  agNULL Caller %d",
                "internAsyncSingleThreadedEnter",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                Caller,
                0,0,0,0,0,0,0);
        return;
    }
    pCThread = CThread_ptr(hpRoot);

    if( pCThread ==  agNULL )
    {
        fiLogString(hpRoot,
                "%s pCThread ==  agNULL Caller %d",
                "internAsyncSingleThreadedEnter",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                Caller,
                0,0,0,0,0,0,0);
        return;
    }

    if( pCThread->LastAsyncSingleThreadedEnterCaller != Caller )
    {
        fiLogString(hpRoot,
                "%s LastAsyncSingleThreadedEnteCaller (%d)!= %d",
                "internAsyncSingleThreadedEnter",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                Caller,
                pCThread->LastAsyncSingleThreadedEnterCaller,
                0,0,0,0,0,0);
    }

    pCThread->LastSingleThreadedEnterCaller = pCThread->LastSingleThreadedLeaveCaller;

    pCThread->LastAsyncSingleThreadedEnterCaller=0;

    osSingleThreadedEnter( hpRoot );

}

/* #define disable_2gig disables 2 gig if defined */
/*+
  Function: CFuncDoLinkSpeedNegotiation
   Purpose: Checks if Two Gig link speed functions. Uses chip function
            ChipIOUp_Frame_Manager_Control_SAS.
   Returns: agTrue if Negotiation completes at Two Gig
 Called By: CFuncCheckCstate
            CActionInitFM
     Calls: osChipIOUpReadBit32
            osChipIOUpWriteBit32
            osStallThread
            fiTimerTick

-*/
agBOOLEAN CFuncDoLinkSpeedNegotiation(agRoot_t * hpRoot)
{
#ifndef disable_2gig
    CThread_t *  pCThread = CThread_ptr(hpRoot);

    os_bit32 Hard_Stall = ONE_SECOND;
    os_bit32 FM_Status = 0;

    if (pCThread->DEVID != ChipConfig_DEVID_TachyonXL2)
    {
        return  agFALSE;
    }

    fiLogDebugString(hpRoot,
            FCMainLogErrorLevel,
            "%s Link Started FM Cfg3 %08X FM Stat %08X  TL Stat %08X %x %x %x 2G %x LPS %x",
            "CFuncDoLinkSpeedNegotiation",(char *)agNULL,
            (void *)agNULL,(void *)agNULL,
            osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Configuration_3),
            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
            osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
            FM_Status,FRAMEMGR_LINK_DOWN,((FM_Status & FRAMEMGR_LINK_DOWN ) == FRAMEMGR_LINK_DOWN ),
            pCThread->TwoGigSuccessfull,
            pCThread->LoopPreviousSuccess);

    if(pCThread->LoopPreviousSuccess)
    {/* Only do negotiation if two gig succeeded before  */
        if( ! pCThread->TwoGigSuccessfull )
        {
            return  agFALSE;
        }
    }

    FM_Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );
    /* Enable auto nego */
    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration_3,  ChipIOUp_Frame_Manager_Configuration_3_EN_AutoSpeed_Nego );
    /* Start nego */
    osChipIOUpWriteBit32( hpRoot,ChipIOUp_Frame_Manager_Control , ChipIOUp_Frame_Manager_Control_SAS  );
    /* Nego finished when bit clear */

    while(  osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Configuration_3) & ChipIOUp_Frame_Manager_Configuration_3_AutoSpeed_Nego_In_Prog )
    {
        osStallThread( hpRoot, 1 );
        fiTimerTick( hpRoot, 1 );
        Hard_Stall--;

        if( Hard_Stall == 1)break;

    }

    if (Hard_Stall == 1 )
    {
        fiLogString(hpRoot,
                    "%s 2Gig Setting failed HS %x FM Cfg3 %08X",
                    "CFuncDoLinkSpeedNegotiation",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    Hard_Stall,
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Configuration_3),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    0,0,0,0,0);
        fiLogString(hpRoot,
                    "%s FM Stat %08X TL Stat %08X",
                    "CFuncDoLinkSpeedNegotiation",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    FM_Status,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    0,0,0,0,0,0);

        return agFALSE;
    }
    else
    {
        if( (osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Configuration_3) & \
            ( ChipIOUp_Frame_Manager_Configuration_3_2Gig_TXS   | ChipIOUp_Frame_Manager_Configuration_3_2Gig_RXS ) \
            ) == ( ChipIOUp_Frame_Manager_Configuration_3_2Gig_TXS |  ChipIOUp_Frame_Manager_Configuration_3_2Gig_RXS ))
        {

            fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "%s 2Gig Setting. HS %x FM Cfg3 %08X",
                        "CFuncDoLinkSpeedNegotiation",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        Hard_Stall,
                        osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Configuration_3),
                        0,0,0,0,0,0);

            fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "%s FM Stat %08X TL Stat %08X",
                        "CFuncDoLinkSpeedNegotiation",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        FM_Status,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        0,0,0,0,0,0);

            osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration_3,  ( ChipIOUp_Frame_Manager_Configuration_3_2Gig_TXS |  ChipIOUp_Frame_Manager_Configuration_3_2Gig_RXS ) );
        }
        else
        {
            fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "%s 1Gig Setting. HS %x FM Cfg3 %08X",
                        "CFuncDoLinkSpeedNegotiation",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        Hard_Stall,
                        osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Configuration_3),
                        0,0,0,0,0,0);
            fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "%s FM Stat %08X  TL Stat %08X in FM stat %08X",
                        "CFuncDoLinkSpeedNegotiation",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        FM_Status,
                        0,0,0,0,0);

            osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration_3,  0 );
        }
        return agTRUE;
    }
#else
        return agTRUE;

#endif /*  disable_2gig */

}

/*+
  Function: CFuncLoopMapRecieved
   Purpose: Evaluates LoopMap sets  LoopMapFabricFound and  LoopMapErrataFound flags.
   Returns: Number of devices found excluding fabric and the hba
 Called By:
     Calls: <none>
-*/
os_bit32 CFuncLoopMapRecieved(agRoot_t * hpRoot, agBOOLEAN Check_Active )
{
    CThread_t     * pCThread          = CThread_ptr(hpRoot);
    FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t * AL_PA_Position_Map = (FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t *)(CThread_ptr(hpRoot)->Calculation.MemoryLayout.LOOPDeviceMAP.addr.CachedMemory.cachedMemoryPtr);
    os_bit32        IndexIntoLoopMap  = 0;
    os_bit32        NumFoundDevices   = 0;

    pCThread->LoopMapNPortPossible = agFALSE;
#ifndef _BYPASSLOOPMAP
    fiLogString(hpRoot,
                "Index    0 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[0],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[1],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[2],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[3],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[4],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[5],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[6],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[7] );

   fiLogDebugString(hpRoot,
                CDBStateLogErrorLevel,
                "Index    8 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[8],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[9],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[10],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[11],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[12],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[13],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[14],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[15] );

   fiLogDebugString(hpRoot,
                CDBStateLogErrorLevel,
                "Index   16 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[16],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[17],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[18],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[19],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[20],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[21],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[22],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[23] );

   fiLogDebugString(hpRoot,
                CDBStateLogErrorLevel,
                "Index   24 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[24],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[25],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[26],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[27],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[28],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[29],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[30],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[31] );

   fiLogDebugString(hpRoot,
                CDBStateLogErrorLevel,
                "Index   32 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[32],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[33],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[34],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[35],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[36],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[37],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[38],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[39] );

   fiLogDebugString(hpRoot,
                CDBStateLogErrorLevel,
                "Index   40 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[40],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[41],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[42],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[43],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[44],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[45],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[46],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[47] );

   fiLogDebugString(hpRoot,
                CDBStateLogErrorLevel,
                "Index   48 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[48],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[49],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[50],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[51],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[52],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[53],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[54],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[55] );

   fiLogDebugString(hpRoot,
                CDBStateLogErrorLevel,
                "Index   56 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[56],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[57],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[58],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[59],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[60],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[61],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[62],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[63] );

   fiLogDebugString(hpRoot,
                CDBStateLogErrorLevel,
                "Index   64 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[64],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[65],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[66],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[67],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[68],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[69],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[70],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[71] );

   fiLogDebugString(hpRoot,
                CDBStateLogErrorLevel,
                "Index   72 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[72],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[73],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[74],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[75],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[76],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[77],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[78],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[79] );

   fiLogDebugString(hpRoot,
                CDBStateLogErrorLevel,
                "Index   80 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[80],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[81],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[82],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[83],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[84],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[85],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[86],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[87] );

   fiLogDebugString(hpRoot,
                CDBStateLogErrorLevel,
                "Index   88 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[88],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[89],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[90],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[91],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[92],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[93],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[94],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[95] );

   fiLogDebugString(hpRoot,
                CDBStateLogErrorLevel,
                "Index   96 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[ 96],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[ 97],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[ 98],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[ 99],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[100],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[101],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[102],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[103] );

   fiLogDebugString(hpRoot,
                CDBStateLogErrorLevel,
                "Index  104 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[104],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[105],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[106],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[107],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[108],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[109],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[110],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[111] );

   fiLogDebugString(hpRoot,
                CDBStateLogErrorLevel,
                "Index  112 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[112],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[113],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[114],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[115],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[116],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[117],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[118],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[119] );

   fiLogDebugString(hpRoot,
                CDBStateLogErrorLevel,
                "Index  120 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[120],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[121],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[122],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[123],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[124],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[125],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[126],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[127]);

#endif /*  _BYPASSLOOPMAP */

    for(IndexIntoLoopMap  =0; IndexIntoLoopMap < AL_PA_Position_Map->AL_PA_Index; IndexIntoLoopMap ++)
    {
        if( AL_PA_Position_Map->AL_PA_Slot[IndexIntoLoopMap] == pCThread->ChanInfo.CurrentAddress.AL_PA
         || AL_PA_Position_Map->AL_PA_Slot[IndexIntoLoopMap] == 0 /* Fabric */)
        {
            continue;
        }
        else
        {
            if(Check_Active)
            {
                FC_Port_ID_t  Port_ID;
                Port_ID.Struct_Form.reserved=0;
                Port_ID.Struct_Form.Domain=0;
                Port_ID.Struct_Form.Area =0;
                Port_ID.Struct_Form.AL_PA = AL_PA_Position_Map->AL_PA_Slot[IndexIntoLoopMap];

                if( ! CFuncCheckIfPortActive( hpRoot,   Port_ID))
                {
                    fiLogString(hpRoot,
                                "%s %s %X I %d",
                                "CFuncLoopMapRecieved","Device Missing",
                                (void *)agNULL,(void *)agNULL,
                                Port_ID.Bit32_Form,
                                IndexIntoLoopMap,
                                0,0,0,0,0,0);
                }
            }

            NumFoundDevices ++;
            if( AL_PA_Position_Map->AL_PA_Slot[IndexIntoLoopMap] == 0xff)
            {
                pCThread->LoopMapErrataFound = agTRUE;
                NumFoundDevices = 0;
                fiLogString(hpRoot,
                            "%s %s",
                            "CFuncLoopMapRecieved","LoopMapErrataFound",
                            (void *)agNULL,(void *)agNULL,
                            0,0,0,0,0,0,0,0);
                return(NumFoundDevices);

            }
        }

    }

    fiLogDebugString(hpRoot,
                FCMainLogErrorLevel,
                "%s NumFoundDevices %x",
                "CFuncLoopMapRecieved",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                NumFoundDevices,0,0,0,0,0,0,0);

    if(NumFoundDevices == 0)
    {
        if( AL_PA_Position_Map->AL_PA_Slot[0] == 0 /* Fabric */)
        {
            if( AL_PA_Position_Map->AL_PA_Slot[1] == pCThread->ChanInfo.CurrentAddress.AL_PA )
            {
                fiLogString(hpRoot,
                            "%s %s",
                            "CFuncLoopMapRecieved","LoopMapNPortPossible",
                            (void *)agNULL,(void *)agNULL,
                            0,0,0,0,0,0,0,0);

                pCThread->LoopMapNPortPossible = agTRUE;
            }
        }
    }
    return(NumFoundDevices);
}

/*+
  Function: CFuncCheckFabricMap
   Purpose: Returns number of decices in current fabric map
   Returns:
 Called By:
     Calls: <none>
-*/
os_bit32 CFuncCheckFabricMap(agRoot_t * hpRoot, agBOOLEAN Check_Active )
{
    CThread_t     * pCThread        = CThread_ptr(hpRoot);
    FC_Port_ID_t    Port_ID;
    os_bit32        NumFoundDevices = 0;
    os_bit32        AL_PA_Index     = 0;

    FC_NS_DU_GID_PT_FS_ACC_Payload_t * RegisteredEntries  = (FC_NS_DU_GID_PT_FS_ACC_Payload_t *)(CThread_ptr(hpRoot)->Calculation.MemoryLayout.FabricDeviceMAP.addr.CachedMemory.cachedMemoryPtr);

    do
    {
        if ( (RegisteredEntries->Control_Port_ID[AL_PA_Index].Port_ID[0] == pCThread->ChanInfo.CurrentAddress.Domain) &&
             (RegisteredEntries->Control_Port_ID[AL_PA_Index].Port_ID[1] == pCThread->ChanInfo.CurrentAddress.Area) &&
             (RegisteredEntries->Control_Port_ID[AL_PA_Index].Port_ID[2] == pCThread->ChanInfo.CurrentAddress.AL_PA) )
        {
            AL_PA_Index++;
            continue;
        }

        if(Check_Active)
        {
            Port_ID.Struct_Form.reserved = 0;
            Port_ID.Struct_Form.Domain = RegisteredEntries->Control_Port_ID[AL_PA_Index].Port_ID[0];
            Port_ID.Struct_Form.Area   = RegisteredEntries->Control_Port_ID[AL_PA_Index].Port_ID[1];
            Port_ID.Struct_Form.AL_PA  = RegisteredEntries->Control_Port_ID[AL_PA_Index].Port_ID[2];

            if( ! CFuncCheckIfPortActive( hpRoot,   Port_ID))
            {
                fiLogString(hpRoot,
                            "%s %s %X I %d",
                            "CFuncCheckFabricMap","Device Missing",
                            (void *)agNULL,(void *)agNULL,
                            Port_ID.Bit32_Form,
                            AL_PA_Index,
                            0,0,0,0,0,0);
            }
        }
        NumFoundDevices++;

        AL_PA_Index++;

    } while (RegisteredEntries->Control_Port_ID[AL_PA_Index - 1].Control != FC_NS_Control_Port_ID_Control_Last_Port_ID);


    return(NumFoundDevices);
}


/*+
  Function: CFuncDoADISC
   Purpose: Does ADISC to all devices on Prev_Active_DevLink. Does not work if inIMQ is agTRUE.
   Returns: none
 Called By: fcDelayedInterruptHandler
            fcStartIO
     Calls: CFuncInterruptPoll
            CFuncQuietShowWhereDevThreadsAre
            CFuncCompleteActiveCDBThreadsOnDevice
            DevEventAllocAdisc
            CFuncInterruptPoll
            CFuncCompleteActiveCDBThreadsOnDevice
            DevThreadFree
            CFuncShowWhereCDBThreadsAre
            CFuncWhatStateAreCDBThreads
            Proccess_IMQ
-*/
void CFuncDoADISC(agRoot_t * hpRoot)
{
    CThread_t     * pCThread            = CThread_ptr(hpRoot);
    DevThread_t   * pDevThread;
    fiList_t      * pDevList;


    while(fiListNotEmpty(&pCThread->Prev_Active_DevLink ))
    {

        if(pCThread->ADISC_pollingCount > pCThread->NumberOutstandingFindDevice )
        {/* This limits the stack depth */
            fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "%s pCThread->ADISC_pollingCount > NumberOutstandingFindDevice %x",
                        "Do ADISC",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCThread->NumberOutstandingFindDevice,
                        0,0,0,0,0,0,0 );


            if(CFuncInterruptPoll( hpRoot,&pCThread->ADISC_pollingCount ))
            {
                fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "LF Find Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                        0,0,0,0);
            }/* End ADISC_pollingCount Interrupt poll */

        }/* End NumberOutstandingFindDevice */

        fiListDequeueFromHead(&pDevList,
                                  &pCThread->Prev_Active_DevLink );
        pDevThread = hpObjectBase(DevThread_t,
                                  DevLink,pDevList );

        if( pDevThread->DevInfo.DeviceType & agDevSCSITarget )
        {

            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "%s %s %x",
                        "Do ADISC","Prev_Active_DevLink",
                        (void *)agNULL,(void *)agNULL,
                        fiNumElementsOnList(&pCThread->Prev_Active_DevLink),
                        0,0,0,0,0,0,0);

            fiSendEvent(&pDevThread->thread_hdr,DevEventAllocAdisc);
        }
        else
        {
            if(CFuncQuietShowWhereDevThreadsAre( hpRoot))
            {
                fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "%s %s ADISC cnt %d",
                            "Do ADISC","CFuncQuietShowWhereDevThreadsAre",
                            (void *)agNULL,(void *)agNULL,
                            pCThread->ADISC_pollingCount,
                            0,0,0,0,0,0,0);

            }

            CFuncCompleteActiveCDBThreadsOnDevice(pDevThread ,osIODevReset,  CDBEventIODeviceReset );

            DevThreadFree( hpRoot, pDevThread );

            if(CFuncQuietShowWhereDevThreadsAre( hpRoot))
            {
                fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "%s BB ADISC cnt %d",
                            "Do ADISC",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCThread->ADISC_pollingCount,
                            0,0,0,0,0,0,0);

            }
        }/*End else */
    }/*End fiListNotEmpty  */

    FinishAdisc:

    if(CFuncInterruptPoll( hpRoot,&pCThread->ADISC_pollingCount ))
    {

        fiLogString(hpRoot,
                "%s CFuncInterruptPoll Time out Cstate %d ADISC cnt %d",
                "Do ADISC",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                pCThread->thread_hdr.currentState,
                pCThread->ADISC_pollingCount,
                0,0,0,0,0,0 );

        fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "ADISC  Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                0,0,0,0);
    }

    fiLogString(hpRoot,
                "%s Free %d Active %d Un %d Login %d",
                "Do ADISC",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                fiNumElementsOnList(&pCThread->Free_DevLink),
                fiNumElementsOnList(&pCThread->Active_DevLink),
                fiNumElementsOnList(&pCThread->Unknown_Slot_DevLink),
                fiNumElementsOnList(&pCThread->AWaiting_Login_DevLink),
                0,0,0,0 );
    fiLogString(hpRoot,
                "%s ADISC %d SS %d PrevA login %d Prev Un %d",
                "Do ADISC",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                fiNumElementsOnList(&pCThread->AWaiting_ADISC_DevLink),
                fiNumElementsOnList(&pCThread->Slot_Searching_DevLink),
                fiNumElementsOnList(&pCThread->Prev_Active_DevLink),
                fiNumElementsOnList(&pCThread->Prev_Unknown_Slot_DevLink),
                0,0,0,0 );

    if(CFuncShowWhereDevThreadsAre( hpRoot))
    {
        CFuncWhatStateAreDevThreads( hpRoot );
    }

    if( CFuncShowWhereCDBThreadsAre(hpRoot))
    {
        CFuncWhatStateAreCDBThreads(hpRoot);
    }


    while(fiListNotEmpty(&pCThread->Prev_Unknown_Slot_DevLink ))
    {
        fiListDequeueFromHeadFast(&pDevList,
                                  &pCThread->Prev_Unknown_Slot_DevLink );
        pDevThread = hpObjectBase(DevThread_t,
                                  DevLink,pDevList );
        CFuncCompleteActiveCDBThreadsOnDevice(pDevThread ,osIODevReset,  CDBEventIODeviceReset );

        fiLogDebugString(hpRoot,
                        DevStateLogErrorLevel,
                        "In %s Device  ALPA %06X Failed",
                        "Do ADISC",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        fiComputeDevThread_D_ID(pDevThread),
                        0,0,0,0,0,0,0);

        DevThreadFree( hpRoot, pDevThread );
    }

    if(CFuncShowWhereDevThreadsAre( hpRoot))
    {
        CFuncWhatStateAreDevThreads( hpRoot );
    }


    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot (%p) Out %s - State = %d ADcnt %x Dev Self %p",
                    "Do ADISC",(char *)agNULL,
                    hpRoot,pCThread->DeviceSelf,
                    (os_bit32)pCThread->thread_hdr.currentState,
                    pCThread->ADISC_pollingCount,
                    0,0,0,0,0,0);


    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "FM Status %08X FM Config %08X TL Status %08X TL Control %08X Rec Alpa Reg %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0);

    fiLogString(hpRoot,
                "%s FM %08X TL %08X AC %x ADISC %d FDc %d",
                "Do ADISC",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                CFuncAll_clear( hpRoot ),
                pCThread->ADISC_pollingCount,
                pCThread->FindDEV_pollingCount,
                0,0,0);

    fiLogString(hpRoot,
                "End %s Free %d Active %d Un %d Login %d",
                "Do ADISC",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                fiNumElementsOnList(&pCThread->Free_DevLink),
                fiNumElementsOnList(&pCThread->Active_DevLink),
                fiNumElementsOnList(&pCThread->Unknown_Slot_DevLink),
                fiNumElementsOnList(&pCThread->AWaiting_Login_DevLink),
                0,0,0,0 );
    fiLogString(hpRoot,
                "End %s ADISC %d SS %d PrevA login %d Prev Un %d",
                "Do ADISC",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                fiNumElementsOnList(&pCThread->AWaiting_ADISC_DevLink),
                fiNumElementsOnList(&pCThread->Slot_Searching_DevLink),
                fiNumElementsOnList(&pCThread->Prev_Active_DevLink),
                fiNumElementsOnList(&pCThread->Prev_Unknown_Slot_DevLink),
                0,0,0,0 );

    if(pCThread->ADISC_pollingCount)
    {
        goto FinishAdisc;
    }
    pCThread->FuncPtrs.Proccess_IMQ(hpRoot);

}

/*+
  Function: CFunc_MAX_XL2_Payload
   Purpose: Deterimines if SFQ is large enough to hold a 2k frame
   Returns: Max XL2 receive payload
 Called By: CActionDoFlogi
            fiLinkSvcInit
     Calls: none
-*/
os_bit32 CFunc_MAX_XL2_Payload( agRoot_t *hpRoot )
{
    CThread_t *CThread = CThread_ptr(hpRoot);
    os_bit32   XL2_MaxFrameSize = TachyonXL_Max_Frame_Payload;

    if( CThread->Calculation.MemoryLayout.SFQ.objectSize <= TachyonXL_Max_Frame_Payload )
    {
        XL2_MaxFrameSize = 0x400;
    }

    return(XL2_MaxFrameSize);
}


/*+
  Function: CFuncReadBiosParms
   Purpose: Reads flashrom to allow BIOS settings to affect fclayer operation.
            Sets InitAsNport operation and Link Speed to either 1 or 2 gig
   Returns: none
 Called By: fcInitializeChannel
     Calls: fiFlashReadBit8
            fiFlashReadBit32
-*/
void CFuncReadBiosParms(agRoot_t * hpRoot)
{
    agBiosConfig_t      BConfig;
    CThread_t         * pCThread = CThread_ptr(hpRoot);

    BConfig.Valid       = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,Valid) );
    BConfig.Struct_Size = fiFlashReadBit32( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,Struct_Size) );
    BConfig.agBiosConfig_Version = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,agBiosConfig_Version) );

    BConfig.H_Domain    = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,H_Domain) );
    BConfig.H_Area      = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,H_Area) );
    BConfig.H_Alpa      = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,H_Alpa) );

    BConfig.B_Domain    = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,B_Domain) );
    BConfig.B_Area      = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,B_Area) );
    BConfig.B_Alpa      = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,B_Alpa) );

    BConfig.B_WWN[0]    = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,B_WWN)+0 );
    BConfig.B_WWN[1]    = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,B_WWN)+1 );
    BConfig.B_WWN[2]    = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,B_WWN)+2 );
    BConfig.B_WWN[3]    = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,B_WWN)+3 );
    BConfig.B_WWN[4]    = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,B_WWN)+4 );
    BConfig.B_WWN[5]    = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,B_WWN)+5 );
    BConfig.B_WWN[6]    = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,B_WWN)+6 );
    BConfig.B_WWN[7]    = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,B_WWN)+7 );

    BConfig.BackwardScan= fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,BackwardScan) );
    BConfig.BiosEnabled = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,BiosEnabled) );
    BConfig.MaxDevice   = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,MaxDevice) );
    BConfig.FLport      = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,FLport) );
    BConfig.Alpa_WWN    = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,Alpa_WWN) );
    BConfig.ToggleXL2   = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,ToggleXL2) );

    BConfig.RevMajor  = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,RevMajor) );
    BConfig.RevMinorL = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,RevMinorL) );
    BConfig.RevMinorH = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,RevMinorH) );
    BConfig.RevType   = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,RevType) );

    BConfig.End_Sig   = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,End_Sig) );

    if(BConfig.Valid == agBIOS_Config_VALID && BConfig.End_Sig == agBIOS_Config_EndSig )
    {

        if(fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + BConfig.Struct_Size - 1) != agBIOS_Config_EndSig)
        {
            fiLogString(hpRoot,
                        "End Sig mismatch %X %X %X",
                        "Bios Valid",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        BConfig.Struct_Size,
                        (os_bit32)fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + BConfig.Struct_Size - 1 ),
                        hpFieldOffset(agBiosConfig_t,End_Sig),
                        0,0,0,0,0 );
        }
        
        fiLogString(hpRoot,
                    "%s %x Hard Domain %X Area %X ALPA %X",
                    "Bios Valid",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)BConfig.Valid,
                    (os_bit32)BConfig.H_Domain,
                    (os_bit32)BConfig.H_Area,
                    (os_bit32)BConfig.H_Alpa ,
                    0,0,0,0 );

        fiLogString(hpRoot,
                    "BiosEnabled %x InitAsNport %x (%x)FLport %x Link Speed %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)BConfig.BiosEnabled,
                    CThread_ptr(hpRoot)->InitAsNport,
                    pCThread->Calculation.Parameters.InitAsNport,
                    (os_bit32)BConfig.FLport ,
                    (os_bit32)BConfig.ToggleXL2,
                    0,0,0 );

        /*Set InitAsNport */
        if( BConfig.FLport == agBIOS_FLport && pCThread->Calculation.Parameters.InitAsNport)
        {
            if( BConfig.BiosEnabled == agBIOS_Enabled )
            {
                fiLogString(hpRoot,
                            "%s InitAsNport Conflict with registry %x %x FM %08X",
                            "Bios ",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCThread->Calculation.Parameters.InitAsNport,
                            BConfig.FLport,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                            0,0,0,0,0);
            }
        }

        if( BConfig.BiosEnabled == agBIOS_Enabled )
        {
            if( BConfig.FLport == agBIOS_FLport )
            {
                fiLogString(hpRoot,
                            "%s InitAsNport set to Loop",
                            "Bios ",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCThread->Calculation.Parameters.InitAsNport,
                            BConfig.FLport,0,0,0,0,0,0);
                 pCThread->InitAsNport = agFALSE;
            }
            else
            {
                fiLogString(hpRoot,
                            "%s InitAsNport set to NPort",
                            "Bios",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCThread->Calculation.Parameters.InitAsNport,
                            BConfig.FLport,0,0,0,0,0,0);
                pCThread->InitAsNport = agTRUE;
            }
        }
        else
        {
            fiLogString(hpRoot,
                        "%s InitAsNport set from registry(%x) (%x)",
                        "Bios Disabled",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCThread->Calculation.Parameters.InitAsNport,
                        BConfig.FLport,0,0,0,0,0,0);
            pCThread->InitAsNport = pCThread->Calculation.Parameters.InitAsNport;
        }


        if( BConfig.ToggleXL2 == agBIOS_ToggleXL2_Link_Speed_2_gig )
        {
            fiLogString(hpRoot,
                        "%s Link Speed 2 Gig %x",
                        "Bios",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        BConfig.ToggleXL2,0,0,0,0,0,0,0 );
            pCThread->TwoGigSuccessfull = agTRUE;

            osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration_3,  ( ChipIOUp_Frame_Manager_Configuration_3_2Gig_TXS |  ChipIOUp_Frame_Manager_Configuration_3_2Gig_RXS ) );
        }
        else
        {
            fiLogString(hpRoot,
                        "%s Link Speed 1 Gig",
                        "Bios",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        BConfig.ToggleXL2,0,0,0,0,0,0,0 );
            pCThread->TwoGigSuccessfull = agFALSE;
            osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration_3,  0 );

        }

        fiLogString(hpRoot,
                    "%s Boot Domain %X Area %X ALPA %X",
                    "Bios",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)BConfig.B_Domain,
                    (os_bit32)BConfig.B_Area,
                    (os_bit32)BConfig.B_Alpa,
                    0,0,0,0,0 );

        fiLogString(hpRoot,
                    "%s WWN %X %X %X %X %X %X %X %X",
                    "Bios",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)BConfig.B_WWN[0],
                    (os_bit32)BConfig.B_WWN[1],
                    (os_bit32)BConfig.B_WWN[2],
                    (os_bit32)BConfig.B_WWN[3],
                    (os_bit32)BConfig.B_WWN[4],
                    (os_bit32)BConfig.B_WWN[5],
                    (os_bit32)BConfig.B_WWN[6],
                    (os_bit32)BConfig.B_WWN[7] );

        fiLogString(hpRoot,
                    "%s BackwardScan %X BiosEnabled %X MaxDevice %d",
                    "Bios",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)BConfig.BackwardScan,
                    (os_bit32)BConfig.BiosEnabled,
                    (os_bit32)BConfig.MaxDevice,
                    0,0,0,0,0);


        fiLogString(hpRoot,
                    "%s FLport %X Alpa_WWN %X ToggleXL2 %X",
                    "Bios",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)BConfig.FLport ,
                    (os_bit32)BConfig.Alpa_WWN ,
                    (os_bit32)BConfig.ToggleXL2,
                    0,0,0,0,0);
    }
    else
    {
        fiLogString(hpRoot,
                    "%s  %x Hard Domain %X Area %X ALPA %X",
                    "Bios INVALID",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)BConfig.Valid,
                    (os_bit32)BConfig.H_Domain,
                    (os_bit32)BConfig.H_Area,
                    (os_bit32)BConfig.H_Alpa ,
                    0,0,0,0 );

        fiLogString(hpRoot,
                    "%s InitAsNport set from registry",
                    "Bios INVALID",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

         pCThread->InitAsNport = pCThread->Calculation.Parameters.InitAsNport;

    }

}

/*+
  Function: Cfunc_c
   Purpose: When compiled updates browser info file for VC 5.0 / 6.0
   Returns: none
 Called By: none
     Calls: none
-*/
/*void Cfunc_c(void){} */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\cmntrans.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/CmnTrans.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 9/07/00 4:35p   $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures used by ../C/CmnTrans.C

--*/

#ifndef __CmnTrans_H__
#define __CmnTrans_H__

/* SF_CMND_Type(SF_CMND_Class==SFThread_SF_CMND_Class_CmnTrans) Declarations */

#define SFThread_SF_CMND_CT_Type_GA_NXT     0x01
#define SFThread_SF_CMND_CT_Type_GPN_ID     0x02
#define SFThread_SF_CMND_CT_Type_GNN_ID     0x03
#define SFThread_SF_CMND_CT_Type_GCS_ID     0x04
#define SFThread_SF_CMND_CT_Type_GFT_ID     0x05
#define SFThread_SF_CMND_CT_Type_GSPN_ID    0x06
#define SFThread_SF_CMND_CT_Type_GPT_ID     0x07
#define SFThread_SF_CMND_CT_Type_GIPP_ID    0x08
#define SFThread_SF_CMND_CT_Type_GID_PN     0x09
#define SFThread_SF_CMND_CT_Type_GIPP_PN    0x0A
#define SFThread_SF_CMND_CT_Type_GID_NN     0x0B
#define SFThread_SF_CMND_CT_Type_GIP_NN     0x0C
#define SFThread_SF_CMND_CT_Type_GIPA_NN    0x0E
#define SFThread_SF_CMND_CT_Type_GSNN_NN    0x0F
#define SFThread_SF_CMND_CT_Type_GNN_IP     0x10
#define SFThread_SF_CMND_CT_Type_GIPA_IP    0x11
#define SFThread_SF_CMND_CT_Type_GID_FT     0x12
#define SFThread_SF_CMND_CT_Type_GID_PT     0x13
#define SFThread_SF_CMND_CT_Type_GID_IPP    0x14
#define SFThread_SF_CMND_CT_Type_GPN_IPP    0x15
#define SFThread_SF_CMND_CT_Type_RPN_ID     0x16
#define SFThread_SF_CMND_CT_Type_RNN_ID     0x17
#define SFThread_SF_CMND_CT_Type_RCS_ID     0x18
#define SFThread_SF_CMND_CT_Type_RFT_ID     0x19
#define SFThread_SF_CMND_CT_Type_RPT_ID     0x1a
#define SFThread_SF_CMND_CT_Type_RIPP_ID    0x1b
#define SFThread_SF_CMND_CT_Type_RIP_NN     0x1c
#define SFThread_SF_CMND_CT_Type_RIPA_NN    0x1d
#define SFThread_SF_CMND_CT_Type_RSNN_NN    0x1e
#define SFThread_SF_CMND_CT_Type_IU_First   0x1f
#define SFThread_SF_CMND_CT_Type_IU_Last    0x20
#define SFThread_SF_CMND_CT_Type_RJT_IU     0x21
#define SFThread_SF_CMND_CT_Type_ACC_IU     0x22





/* SF_CMND_State(SF_CMND_Class==SFThread_SF_CMND_Class_CT,SF_CMND_Type==<any>) Declarations */

#define SFThread_SF_CMND_CT_State_Started  0x01
#define SFThread_SF_CMND_CT_State_Finished 0x02

/* SF_CMND_Status(SF_CMND_Class==SFThread_SF_CMND_Class_CT,SF_CMND_Type==<any>) Declarations */

#define SFThread_SF_CMND_CT_Status_Good 0x01
#define SFThread_SF_CMND_CT_Status_Bad  0x02
#define SFThread_SF_CMND_CT_Status_Confused 0x03

/* Function Prototypes */

osGLOBAL void fiCTInit(
                           agRoot_t *hpRoot
                         );

osGLOBAL os_bit32 fiFillInRFT_ID(
                             SFThread_t *SFThread

                           );

osGLOBAL os_bit32 fiFillInRFT_ID_OnCard(
                                    SFThread_t *SFThread
                                  );

osGLOBAL os_bit32 fiFillInRFT_ID_OffCard(
                                     SFThread_t *SFThread
                                   );
osGLOBAL os_bit32 fiFillInGID_FT(
                             SFThread_t *SFThread

                           );

osGLOBAL os_bit32 fiFillInGID_FT_OnCard(
                                    SFThread_t *SFThread
                                  );

osGLOBAL os_bit32 fiFillInGID_FT_OffCard(
                                     SFThread_t *SFThread
                                   );



osGLOBAL void fiCTProcess_RFT_ID_Response_OnCard(
                                                   SFThread_t *SFThread,
                                                   os_bit32       Frame_Length,
                                                   os_bit32       Offset_to_FCHS,
                                                   os_bit32       Offset_to_Payload,
                                                   os_bit32       Payload_Wrap_Offset,
                                                   os_bit32       Offset_to_Payload_Wrapped
                                                 );

osGLOBAL void fiCTProcess_RFT_ID_Response_OffCard(
                                                    SFThread_t          *SFThread,
                                                    os_bit32                Frame_Length,
                                                    FCHS_t              *FCHS,
                                                    FC_BA_ACC_Payload_t *Payload,
                                                    os_bit32                Payload_Wrap_Offset,
                                                    FC_BA_ACC_Payload_t *Payload_Wrapped
                                                  );

osGLOBAL void fiFillInCTFrameHeader_OnCard(
                                           SFThread_t *SFThread,
                                           os_bit32       D_ID,
                                           os_bit32       X_ID,
                                           os_bit32       F_CTL_Exchange_Context
                                         );

osGLOBAL void fiFillInCTFrameHeader_OffCard(
                                            SFThread_t *SFThread,
                                            os_bit32       D_ID,
                                            os_bit32       X_ID,
                                            os_bit32       F_CTL_Exchange_Context
                                          );
osGLOBAL void fiCTProcess_GID_FT_Response_OffCard(
                                              SFThread_t                 *SFThread,
                                              os_bit32                       Frame_Length,
                                              FCHS_t                     *FCHS,
                                              FC_CT_IU_HDR_t              *Payload,
                                              os_bit32                       Payload_Wrap_Offset,
                                              FC_CT_IU_HDR_t             *Payload_Wrapped
                                            );



#define fiCT_Cmd_Status_ACC              0x00000010
#define fiCT_Cmd_Status_RJT              0x00000011
#define fiCT_Cmd_Status_Confused         0x00000100

osGLOBAL os_bit32 fiCTProcessSFQ(
                                  agRoot_t        *hpRoot,
                                  SFQConsIndex_t   SFQConsIndex,
                                  os_bit32            Frame_Length,
                                  fi_thread__t       **Thread_to_return
                                );

osGLOBAL os_bit32 fiCTProcessSFQ_OnCard(
                                         agRoot_t        *hpRoot,
                                         SFQConsIndex_t   SFQConsIndex,
                                         os_bit32            Frame_Length,
                                         fi_thread__t       **Thread_to_return
                                       );

osGLOBAL os_bit32 fiCTProcessSFQ_OffCard(
                                          agRoot_t        *hpRoot,
                                          SFQConsIndex_t   SFQConsIndex,
                                          os_bit32            Frame_Length,
                                          fi_thread__t       **Thread_to_return
                                        );



#endif /* __CT_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\cmntrans.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/CmnTrans.C $

  $Revision:: 3               $
      $Date:: 9/24/01 9:54p   $ (Last Check-In)
   $Modtime:: 9/24/01 8:37p   $ (Last Modified)

Purpose:

  This file implements Common Transport protocol for the FC Layer.

--*/
#ifndef _New_Header_file_Layout_

#include "../h/globals.h"
#include "../h/state.h"
#include "../h/tgtstate.h"
#include "../h/memmap.h"
#include "../h/tlstruct.h"
#include "../h/fcmain.h"
#include "../h/queue.h"
#include "../h/cmntrans.h"
#include "../h/cfunc.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"
#include "tgtstate.h"
#include "memmap.h"
#include "tlstruct.h"
#include "fcmain.h"
#include "queue.h"
#include "cmntrans.h"
#include "cfunc.h"
#endif  /* _New_Header_file_Layout_ */

#ifdef NAME_SERVICES

void fiFillInCTFrameHeader_OnCard(
                                    SFThread_t *SFThread,
                                    os_bit32       D_ID,
                                    os_bit32       X_ID,
                                    os_bit32       F_CTL_Exchange_Context
                                  )
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t  *hpRoot            = SFThread->thread_hdr.hpRoot;
    CThread_t *CThread           = CThread_ptr(hpRoot);
    os_bit32      CT_Header_Offset  = SFThread->SF_CMND_Offset;
    os_bit32      R_CTL__D_ID;
    os_bit32      S_ID;
    os_bit32      TYPE__F_CTL;
    os_bit32      OX_ID__RX_ID;

    S_ID = fiComputeCThread_S_ID(
                                  CThread
                                );

    if (F_CTL_Exchange_Context == FC_Frame_Header_F_CTL_Exchange_Context_Originator)
    {
        R_CTL__D_ID = (  FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame
                       | FC_Frame_Header_R_CTL_Lo_Unsolicited_Control
                       | D_ID                                             );

        TYPE__F_CTL = (  FC_Frame_Header_TYPE_Fibre_Channel_Services
                       | FC_Frame_Header_F_CTL_Exchange_Context_Originator
                       | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                       | FC_Frame_Header_F_CTL_First_Sequence
                       | FC_Frame_Header_F_CTL_End_Sequence
                       | FC_Frame_Header_F_CTL_Sequence_Initiative_Transfer);

        OX_ID__RX_ID = (  (SFThread->X_ID << FCHS_OX_ID_SHIFT)
                        | (X_ID           << FCHS_RX_ID_SHIFT));
    }
    else /* F_CTL_Exchange_Context == FC_Frame_Header_F_CTL_Exchange_Context_Responder */
    {
        R_CTL__D_ID = (  FC_Frame_Header_TYPE_Fibre_Channel_Services
                       | FC_Frame_Header_R_CTL_Lo_Solicited_Control
                       | D_ID                                             );

        TYPE__F_CTL = (  FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame
                       | FC_Frame_Header_F_CTL_Exchange_Context_Responder
                       | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                       | FC_Frame_Header_F_CTL_Last_Sequence
                       | FC_Frame_Header_F_CTL_End_Sequence
                       | FC_Frame_Header_F_CTL_Sequence_Initiative_Transfer);

        OX_ID__RX_ID = (  (X_ID           << FCHS_OX_ID_SHIFT)
                        | (SFThread->X_ID << FCHS_RX_ID_SHIFT));
    }

    osCardRamWriteBit32(
                         hpRoot,
                         CT_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            MBZ1
                                                          ),
                         0
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         CT_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp
                                                          ),
                         (  FCHS_SOF_SOFi3
                          | FCHS_EOF_EOFn
                          | FCHS_CLS      )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         CT_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            R_CTL__D_ID
                                                          ),
                         R_CTL__D_ID
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         CT_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            CS_CTL__S_ID
                                                          ),
                         S_ID
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         CT_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            TYPE__F_CTL
                                                          ),
                         TYPE__F_CTL
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         CT_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            SEQ_ID__DF_CTL__SEQ_CNT
                                                          ),
                         FC_Frame_Header_DF_CTL_No_Device_Header
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         CT_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            OX_ID__RX_ID
                                                          ),
                         OX_ID__RX_ID
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         CT_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            RO
                                                          ),
                         0
                       );
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

void fiFillInCTFrameHeader_OffCard(
                                     SFThread_t *SFThread,
                                     os_bit32       D_ID,
                                     os_bit32       X_ID,
                                     os_bit32       F_CTL_Exchange_Context
                                   )
{
#ifndef __MemMap_Force_On_Card__
    agRoot_t  *hpRoot       = SFThread->thread_hdr.hpRoot;
    CThread_t *CThread      = CThread_ptr(hpRoot);
    FCHS_t    *CT_Header   = SFThread->SF_CMND_Ptr;
    os_bit32      R_CTL__D_ID;
    os_bit32      S_ID;
    os_bit32      TYPE__F_CTL;
    os_bit32      OX_ID__RX_ID;

    S_ID = fiComputeCThread_S_ID(
                                  CThread
                                );

    if (F_CTL_Exchange_Context == FC_Frame_Header_F_CTL_Exchange_Context_Originator)
    {
        R_CTL__D_ID = (  FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame
                       | FC_Frame_Header_R_CTL_Lo_Unsolicited_Control
                       | D_ID                                             );

        TYPE__F_CTL = (  FC_Frame_Header_TYPE_Fibre_Channel_Services
                       | FC_Frame_Header_F_CTL_Exchange_Context_Originator
                       | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                       | FC_Frame_Header_F_CTL_First_Sequence
                       | FC_Frame_Header_F_CTL_End_Sequence
                       | FC_Frame_Header_F_CTL_Sequence_Initiative_Transfer);

        OX_ID__RX_ID = (  (SFThread->X_ID << FCHS_OX_ID_SHIFT)
                        | (X_ID           << FCHS_RX_ID_SHIFT));
    }
    else /* F_CTL_Exchange_Context == FC_Frame_Header_F_CTL_Exchange_Context_Responder */
    {
        R_CTL__D_ID = (  FC_Frame_Header_TYPE_Fibre_Channel_Services
                       | FC_Frame_Header_R_CTL_Lo_Solicited_Control
                       | D_ID                                             );

        TYPE__F_CTL = (  FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame
                       | FC_Frame_Header_F_CTL_Exchange_Context_Responder
                       | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                       | FC_Frame_Header_F_CTL_Last_Sequence
                       | FC_Frame_Header_F_CTL_End_Sequence);

        OX_ID__RX_ID = (  (X_ID           << FCHS_OX_ID_SHIFT)
                        | (SFThread->X_ID << FCHS_RX_ID_SHIFT));
    }

    CT_Header->MBZ1                                        = 0;
    CT_Header->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp =   FCHS_SOF_SOFi3
                                                               | FCHS_EOF_EOFn
                                                               | FCHS_CLS;
    CT_Header->R_CTL__D_ID                                 = R_CTL__D_ID;
    CT_Header->CS_CTL__S_ID                                = S_ID;
    CT_Header->TYPE__F_CTL                                 = TYPE__F_CTL;
    CT_Header->SEQ_ID__DF_CTL__SEQ_CNT                     = FC_Frame_Header_DF_CTL_No_Device_Header;
    CT_Header->OX_ID__RX_ID                                = OX_ID__RX_ID;
    CT_Header->RO                                          = 0;
#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInRFT_ID(
                    SFThread_t *SFThread
                  )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInRFT_ID_OnCard(
                                    SFThread
                                  );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInRFT_ID_OffCard(
                                     SFThread
                                   );
    }
}


os_bit32 fiFillInRFT_ID_OnCard(
                             SFThread_t *SFThread
                           )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot                = SFThread->thread_hdr.hpRoot;
    os_bit32        CT_Header_Offset      = SFThread->SF_CMND_Offset;
    os_bit32        CT_Payload_Offset     = CT_Header_Offset + sizeof(FCHS_t);
    os_bit32        RFT_ID_Payload_Offset = CT_Payload_Offset + sizeof(FC_CT_IU_HDR_t);
    os_bit8         Bit8_Index;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_CT;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_CT_Type_RFT_ID;
    SFThread->SF_CMND_State = SFThread_SF_CMND_CT_State_Finished;

/*+
Fill in RFT_ID Frame Header
-*/

    fiFillInCTFrameHeader_OnCard(
                                   SFThread,
#ifdef BROCADE_BUG
                                   0xFFFC41,
#else /* BROCADE_BUG */
                                   FC_Well_Known_Port_ID_Directory_Server,
#endif /* BROCADE_BUG */
                                   0xFFFF,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                 );

/*+
Fill in RFT_ID Frame Payload
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         CT_Payload_Offset + hpFieldOffset(
                                                                FC_CT_IU_HDR_t,
                                                                Revision__IN_ID
                                                              ),
                         hpSwapBit32( FC_CT_IU_HDR_Revision_First_Revision )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         CT_Payload_Offset + hpFieldOffset(
                                                                FC_CT_IU_HDR_t,
                                                                FS_Type__FS_Subtype__Options
                                                              ),
                         hpSwapBit32( FC_CT_IU_HDR_FS_Type_Directory_Service_Application |
                                      FC_CT_IU_HDR_FS_Subtype_Directory_Name_Service   )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         CT_Payload_Offset + hpFieldOffset(
                                                                FC_CT_IU_HDR_t,
                                                                CommandResponse_Code__MaximumResidual_Size
                                                              ),
                         hpSwapBit32( FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_RFT_ID |
                                      FC_CT_IU_HDR_MaximumResidual_Size_FS_REQ_No_Maximum)
                       );

/*
   osCardRamWriteBit32(
                        hpRoot,
                        RFT_ID_Payload_Offset + 0,
                        hpSwapBit32(   ((CThread->ChanInfo.CurrentAddress.Domain << 16)
                                 | (CThread->ChanInfo.CurrentAddress.Area   <<  8)
                                 |  CThread->ChanInfo..CurrentAddress.AL_PA        )));




*/



/*

    osCardRamWriteBit8(
                        hpRoot,
                        RFT_ID_Payload_Offset + hpFieldOffset(
                                                                FC_NS_DU_RFT_ID_Payload_t,
                                                                Port_ID[0]
                                                                ),
                        hpSwapBit32(CThread->ChanInfo.CurrentAddress.Domain)
                      );



    osCardRamWriteBit8(
                        hpRoot,
                        RFT_ID_Payload_Offset + hpFieldOffset(
                                                                FC_NS_DU_RFT_ID_Payload_t,
                                                                Port_ID[1]
                                                             ),
                        hpSwapBit32(CThread->ChanInfo.CurrentAddress.Area)
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        RFT_ID_Payload_Offset + hpFieldOffset(
                                                                FC_NS_DU_RFT_ID_Payload_t,
                                                                Port_ID[2]
                                                                ),
                       hpSwapBit32(CThread->ChanInfo.CurrentAddress.AL_PA)
                       );

*/

    for ( Bit8_Index = 0;
            Bit8_Index < sizeof(FC_NS_FC_4_Types_t);
            Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            RFT_ID_Payload_Offset + hpFieldOffset(FC_NS_DU_RFT_ID_Payload_t,
                                                                  FC_4_Types[Bit8_Index]),
                            0x00
                            );
    }


     /* Set the SCSI-FCP bit */
     osCardRamWriteBit8(
                            hpRoot,
                            RFT_ID_Payload_Offset + hpFieldOffset(FC_NS_DU_RFT_ID_Payload_t,
                                                                  FC_4_Types[2]),
                            0x01
                        );

    /* May also need to set the FiberChannel Services bit */
    osCardRamWriteBit8(
                            hpRoot,
                            RFT_ID_Payload_Offset + hpFieldOffset(FC_NS_DU_RFT_ID_Payload_t,
                                                                  FC_4_Types[7]),
                            0x01
                        );

/*+
Return length of RFT_ID Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_CT_IU_HDR_t) + sizeof(FC_NS_DU_RFT_ID_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInRFT_ID_OffCard(
                              SFThread_t *SFThread
                              )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    agRoot_t                *hpRoot         = SFThread->thread_hdr.hpRoot;
    CThread_t               *CThread        = CThread_ptr(hpRoot);
    FCHS_t                  *RFT_ID_Header  = SFThread->SF_CMND_Ptr;
    FC_CT_IU_HDR_t          *CT_Header      = (FC_CT_IU_HDR_t *)((os_bit8 *)RFT_ID_Header + sizeof(FCHS_t));
    FC_NS_DU_RFT_ID_Payload_t *RFT_ID_Payload = (FC_NS_DU_RFT_ID_Payload_t *)((os_bit8 *)CT_Header + sizeof(FC_CT_IU_HDR_t));
    os_bit8                    Bit8_Index;
    os_bit32                 * pPayload = (os_bit32 *)CT_Header;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_CT;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_CT_Type_RFT_ID;
    SFThread->SF_CMND_State = SFThread_SF_CMND_CT_State_Finished;

/*+
Fill in RFT_ID Frame Header
-*/


    fiFillInCTFrameHeader_OffCard(
                                   SFThread,
#ifdef BROCADE_BUG
                                   0xFFFC41,
#else /* BROCADE_BUG */
                                   FC_Well_Known_Port_ID_Directory_Server,
#endif /* BROCADE_BUG */
                                   0xFFFF,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                 );

/*+
Fill in RFT_ID Frame Payload
-*/

    CT_Header->Revision__IN_ID                  =   hpSwapBit32(FC_CT_IU_HDR_Revision_First_Revision);

    CT_Header->FS_Type__FS_Subtype__Options     =  hpSwapBit32(FC_CT_IU_HDR_FS_Type_Directory_Service_Application |
                                                    FC_CT_IU_HDR_FS_Subtype_Directory_Name_Service);

    CT_Header->CommandResponse_Code__MaximumResidual_Size = hpSwapBit32(FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_RFT_ID |
                                                        FC_CT_IU_HDR_MaximumResidual_Size_FS_REQ_No_Maximum);

    CT_Header->Reason_Code__Reason_Code_Explanation__Vendor_Unique  =   0;

    RFT_ID_Payload->Port_ID.reserved =   0;
    RFT_ID_Payload->Port_ID.Domain  =   CThread->ChanInfo.CurrentAddress.Domain;
    RFT_ID_Payload->Port_ID.Area  =   CThread->ChanInfo.CurrentAddress.Area;
    RFT_ID_Payload->Port_ID.AL_PA  =   CThread->ChanInfo.CurrentAddress.AL_PA;


    for ( Bit8_Index = 0;
            Bit8_Index < sizeof(FC_NS_FC_4_Types_t);
            Bit8_Index++)
    {

        RFT_ID_Payload->FC_4_Types[Bit8_Index] = 0x0;
    }


/* Set the FC_4_Type to be FCP-SCSI */
    RFT_ID_Payload->FC_4_Types[2]   =   0x01;

/* May also need to set the FiberChannel Services bit */
    RFT_ID_Payload->FC_4_Types[7]   =   0x01;

    fiLogDebugString(
                      hpRoot,
                      CTLogConsoleLevelInfo,
                      "%s Size %X FC_CT_IU_HDR_t %X FC_NS_DU_RFT_ID_Payload_t %X",
                      "RFT_ID",
                      (char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      sizeof(FC_CT_IU_HDR_t) + sizeof(FC_NS_DU_RFT_ID_Payload_t),
                      sizeof(FC_CT_IU_HDR_t),
                      sizeof(FC_NS_DU_RFT_ID_Payload_t),
                      0,0,0,0,0 );

    fiLogDebugString(
                      hpRoot,
                      CTLogConsoleLevelInfo,
                      "%s %08X %08X %08X %08X %08X",
                      "OUT RFT_ID", (char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      hpSwapBit32( *(pPayload+0)),
                      hpSwapBit32( *(pPayload+1)),
                      hpSwapBit32( *(pPayload+2)),
                      hpSwapBit32( *(pPayload+3)),
                      hpSwapBit32( *(pPayload+4)),
                      0,0,0);

    fiLogDebugString(
                      hpRoot,
                      CTLogConsoleLevelInfo,
                      "%s %08X %08X %08X %08X %08X %08X %08X %08X",
                      "OUT RFT_ID",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      hpSwapBit32( *(pPayload+5)),
                      hpSwapBit32( *(pPayload+6)),
                      hpSwapBit32( *(pPayload+7)),
                      hpSwapBit32( *(pPayload+8)),
                      hpSwapBit32( *(pPayload+9)),
                      hpSwapBit32( *(pPayload+10)),
                      hpSwapBit32( *(pPayload+11)),
                      hpSwapBit32( *(pPayload+12)));

/*+
Return length of RFT_ID Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_CT_IU_HDR_t) + sizeof(FC_NS_DU_RFT_ID_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInGID_FT(
                    SFThread_t *SFThread
                  )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInGID_FT_OnCard(
                                    SFThread
                                  );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInGID_FT_OffCard(
                                     SFThread
                                   );
    }
}


os_bit32 fiFillInGID_FT_OnCard(
                             SFThread_t *SFThread
                           )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot                = SFThread->thread_hdr.hpRoot;
    os_bit32     CT_Header_Offset      = SFThread->SF_CMND_Offset;
    os_bit32     CT_Payload_Offset     = CT_Header_Offset + sizeof(FCHS_t);
    os_bit32     GID_FT_Payload_Offset = CT_Payload_Offset + sizeof(FC_CT_IU_HDR_t);

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_CT;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_CT_Type_GID_FT;
    SFThread->SF_CMND_State = SFThread_SF_CMND_CT_State_Finished;

/*+
Fill in GID_FT Frame Header
-*/

    fiFillInCTFrameHeader_OnCard(
                                   SFThread,
#ifdef BROCADE_BUG
                                   0xFFFC41,
#else /* BROCADE_BUG */
                                   FC_Well_Known_Port_ID_Directory_Server,
#endif /* BROCADE_BUG */
                                   0xFFFF,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                 );

/*+
Fill in GID_FT Frame Payload
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         CT_Payload_Offset + hpFieldOffset(
                                                                FC_CT_IU_HDR_t,
                                                                Revision__IN_ID
                                                              ),
                         hpSwapBit32( FC_CT_IU_HDR_Revision_First_Revision )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         CT_Payload_Offset + hpFieldOffset(
                                                                FC_CT_IU_HDR_t,
                                                                FS_Type__FS_Subtype__Options
                                                              ),
                         hpSwapBit32( FC_CT_IU_HDR_FS_Type_Directory_Service_Application |
                                      FC_CT_IU_HDR_FS_Subtype_Directory_Name_Service   )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         CT_Payload_Offset + hpFieldOffset(
                                                                FC_CT_IU_HDR_t,
                                                                CommandResponse_Code__MaximumResidual_Size
                                                              ),
                         hpSwapBit32( FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GID_FT |
                                      FC_CT_IU_HDR_MaximumResidual_Size_FS_REQ_No_Maximum)
                       );

    osCardRamWriteBit32(
                        hpRoot,
                        GID_FT_Payload_Offset + hpFieldOffset(
                                                                FC_NS_DU_GID_FT_Request_Payload_t,
                                                                FC_4_Type_Code
                                                                ),
                         hpSwapBit32(FC_Frame_Header_TYPE_SCSI_FCP >>
                                           FC_NS_DU_GID_FT_FC_Frame_Header_TYPE_SCSI_FCP_Shift)
                      );



/*+
Return length of GID_FT Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_CT_IU_HDR_t) + sizeof(FC_NS_DU_GID_FT_Request_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInGID_FT_OffCard(
                              SFThread_t *SFThread
                              )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    FCHS_t                              *GID_FT_Header  = SFThread->SF_CMND_Ptr;
    FC_CT_IU_HDR_t                      *CT_Header      = (FC_CT_IU_HDR_t *)((os_bit8 *)GID_FT_Header + sizeof(FCHS_t));
    FC_NS_DU_GID_FT_Request_Payload_t   *GID_FT_Payload = (FC_NS_DU_GID_FT_Request_Payload_t *)
                                                            ((os_bit8 *)CT_Header + sizeof(FC_CT_IU_HDR_t));

    os_bit32 * Payload =(os_bit32 *) GID_FT_Payload;
    os_bit32 * Header =(os_bit32 *) CT_Header;
    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_CT;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_CT_Type_GID_FT;
    SFThread->SF_CMND_State = SFThread_SF_CMND_CT_State_Finished;

/*+
Fill in GID_FT Frame Header
-*/


    fiFillInCTFrameHeader_OffCard(
                                   SFThread,
#ifdef BROCADE_BUG
                                   0xFFFC41,
#else /* BROCADE_BUG */
                                   FC_Well_Known_Port_ID_Directory_Server,
#endif /* BROCADE_BUG */
                                   0xFFFF,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                 );

/*+
Fill in GID_FT Frame Payload
-*/

    CT_Header->Revision__IN_ID                  =   hpSwapBit32(FC_CT_IU_HDR_Revision_First_Revision);

    CT_Header->FS_Type__FS_Subtype__Options     =  hpSwapBit32(FC_CT_IU_HDR_FS_Type_Directory_Service_Application |
                                                    FC_CT_IU_HDR_FS_Subtype_Directory_Name_Service);

    CT_Header->CommandResponse_Code__MaximumResidual_Size
                                                = hpSwapBit32(FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GID_FT |
                                                        FC_CT_IU_HDR_MaximumResidual_Size_FS_REQ_No_Maximum);

    CT_Header->Reason_Code__Reason_Code_Explanation__Vendor_Unique = hpSwapBit32(0);

    GID_FT_Payload->FC_4_Type_Code              =   hpSwapBit32(FC_Frame_Header_TYPE_SCSI_FCP >>
                                                    FC_NS_DU_GID_FT_FC_Frame_Header_TYPE_SCSI_FCP_Shift);

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "%s %08X %08X %08X %08X %s %08X",
                "CT_Header","GID_FT_Payload",
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(Header+0)),
                hpSwapBit32(*(Header+1)),
                hpSwapBit32(*(Header+2)),
                hpSwapBit32(*(Header+3)),
                hpSwapBit32(*(Payload+0)),
                0,0,0 );


/*+
Return length of GID_FT Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_CT_IU_HDR_t) + sizeof(FC_NS_DU_GID_FT_Request_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiCTProcessSFQ(
                           agRoot_t        *hpRoot,
                           SFQConsIndex_t   SFQConsIndex,
                           os_bit32            Frame_Length,
                           fi_thread__t       **Thread_to_return
                         )
{
    if (CThread_ptr(hpRoot)->Calculation.MemoryLayout.SFQ.memLoc == inCardRam)
    {
        return fiCTProcessSFQ_OnCard(
                                           hpRoot,
                                           SFQConsIndex,
                                           Frame_Length,
                                           Thread_to_return
                                         );
    }
    else /* CThread_ptr(hpRoot)->Calculation.MemoryLayout.SFQ.memLoc == inDmaMemory */
    {
        return fiCTProcessSFQ_OffCard(
                                            hpRoot,
                                            SFQConsIndex,
                                            Frame_Length,
                                            Thread_to_return
                                          );
    }
}



os_bit32 fiCTProcessSFQ_OnCard(
                                   agRoot_t        *hpRoot,
                                   SFQConsIndex_t   SFQConsIndex,
                                   os_bit32         Frame_Length,
                                   fi_thread__t   **Thread_to_return
                                 )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    CThread_t                  *CThread                    = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *SFQ_MemoryDescriptor       = &(CThread->Calculation.MemoryLayout.SFQ);
    os_bit32                       Offset_to_FCHS             = SFQ_MemoryDescriptor->addr.CardRam.cardRamOffset
                                                             + (SFQConsIndex * SFQ_MemoryDescriptor->elementSize);
    os_bit32                    Offset_to_Payload          = Offset_to_FCHS + sizeof(FCHS_t);
    os_bit32                    Payload_Wrap_Offset        = SFQ_MemoryDescriptor->objectSize
                                                             - (SFQConsIndex * SFQ_MemoryDescriptor->elementSize)
                                                             - sizeof(FCHS_t);
    os_bit32                    Offset_to_Payload_Wrapped  = Offset_to_Payload
                                                             - SFQ_MemoryDescriptor->objectSize;
    os_bit32                    R_CTL__D_ID;
    os_bit32                    TYPE__F_CTL;
    os_bit32                    Recv_CT_Type;
    os_bit32                    Recv_Command_Code;
    os_bit32                    Sent_CT_Type;
    X_ID_t                      OX_ID;
    X_ID_t                      RX_ID;

    fiMemMapMemoryDescriptor_t *CDBThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.CDBThread);
    os_bit32                       CDBThread_X_ID_Max         = CDBThread_MemoryDescriptor->elements - 1;
    fiMemMapMemoryDescriptor_t *SFThread_MemoryDescriptor  = &(CThread->Calculation.MemoryLayout.SFThread);
    os_bit32                    SFThread_X_ID_Offset       = CDBThread_X_ID_Max + 1;
    SFThread_t                 *SFThread;

    /* Note the assumption that the entire FCHS fits in the pointed to SFQ entry (i.e. it doesn't wrap) */

    OX_ID = (X_ID_t)(((osCardRamReadBit32(
                                           hpRoot,
                                           Offset_to_FCHS + hpFieldOffset(FCHS_t,OX_ID__RX_ID)
                                         ) & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);

    RX_ID = (X_ID_t)(((osCardRamReadBit32(
                                           hpRoot,
                                           Offset_to_FCHS + hpFieldOffset(FCHS_t,OX_ID__RX_ID)
                                         ) & FCHS_RX_ID_MASK) >> FCHS_RX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);

    R_CTL__D_ID = osCardRamReadBit32(
                                      hpRoot,
                                      Offset_to_FCHS + hpFieldOffset(FCHS_t,R_CTL__D_ID)
                                    );

    TYPE__F_CTL = osCardRamReadBit32(
                                      hpRoot,
                                      Offset_to_FCHS + hpFieldOffset(FCHS_t,TYPE__F_CTL)
                                    );


    if ((TYPE__F_CTL & FC_Frame_Header_TYPE_MASK) == FC_Frame_Header_TYPE_Fibre_Channel_Services)
    {
        /* Process FibreChannel Services frames   */

        if ( (TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK) != FC_Frame_Header_F_CTL_Exchange_Context_Responder )
        {
            /* Starting here, this function only understands Service Responses */

            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "fiCTProcessSFQ_OnCard(): Len %X",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              Frame_Length,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "    (TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK)",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "        != FC_Frame_Header_F_CTL_Exchange_Context_Responder",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "    TYPE__F_CTL==0x%08X",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              TYPE__F_CTL,
                              0,0,0,0,0,0,0
                              );

            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "    R_CTL__D_ID 0x%08X",
                              (void *)agNULL,(void *)agNULL,
                              (char *)agNULL,
                              (char *)agNULL,
                              R_CTL__D_ID,
                              0,0,0,0,0,0,0
                             );

            *Thread_to_return = (fi_thread__t *)agNULL;

            return fiCT_Cmd_Status_Confused;
        }


        Recv_CT_Type = R_CTL__D_ID & FC_Frame_Header_R_CTL_Lo_MASK;

        if (Recv_CT_Type != FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame)
        {


            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "fiCTProcessSFQ_OnCard():",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );


            *Thread_to_return = (fi_thread__t *)agNULL;

            return fiCT_Cmd_Status_Confused;
        }

       /* Now we will have to look into the IU unit and parse on
         * FS_Type to see if this is a ACC or RJT
         */

    if ((hpFieldOffset(FC_CT_IU_HDR_t,CommandResponse_Code__MaximumResidual_Size) + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        Recv_Command_Code = hpSwapBit32(osCardRamReadBit32(
                                                        hpRoot,
                                                        Offset_to_Payload + hpFieldOffset(FC_CT_IU_HDR_t,CommandResponse_Code__MaximumResidual_Size)
                                                      ));
    }
    else
    {
        Recv_Command_Code = hpSwapBit32(osCardRamReadBit32(
                                                        hpRoot,
                                                        Offset_to_Payload_Wrapped + hpFieldOffset(FC_CT_IU_HDR_t,CommandResponse_Code__MaximumResidual_Size)
                                                      ));
    }

    Recv_Command_Code = (Recv_Command_Code & FC_CT_IU_HDR_CommandResponse_Code_MASK);

     if (!(Recv_Command_Code == FC_CT_IU_HDR_CommandResponse_Code_FS_ACC_IU  ||
           Recv_Command_Code == FC_CT_IU_HDR_CommandResponse_Code_FS_RJT_IU ))

     {
            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "fiCTProcessSFQ_OnCard():",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "    Not ACC nor REJ",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0);


            *Thread_to_return = (fi_thread__t *)agNULL;

            return fiCT_Cmd_Status_Confused;
        }

        SFThread = (SFThread_t *)((os_bit8 *)SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                              + ((OX_ID - SFThread_X_ID_Offset) * SFThread_MemoryDescriptor->elementSize));

        *Thread_to_return = (fi_thread__t *)SFThread;

        Sent_CT_Type = SFThread->SF_CMND_Type;

        SFThread->SF_CMND_State = SFThread_SF_CMND_CT_State_Finished;
        switch(Sent_CT_Type)
        {
            case SFThread_SF_CMND_CT_Type_RFT_ID:
                /* Since we don't have to do anything, let's not call another function here.
                 * Just check to see if this an ACC or reject and return the right status.
                 */
                return ((Recv_Command_Code == FC_CT_IU_HDR_CommandResponse_Code_FS_ACC_IU) ? fiCT_Cmd_Status_ACC : fiCT_Cmd_Status_RJT);
             case SFThread_SF_CMND_CT_Type_GID_FT:
                /* Since we don't have to do anything, let's not call another function here.
                 * Just check to see if this an ACC or reject and return the right status.
                 */

                /* Copy the payload for now into the Cthread. It is unknown how this is going to
                   be presented to the device handles etc. */


                return ((Recv_Command_Code == FC_CT_IU_HDR_CommandResponse_Code_FS_ACC_IU) ? fiCT_Cmd_Status_ACC : fiCT_Cmd_Status_RJT);

            default:
            /* Unknown CT Command recorded in SFThread */

                    fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "fiCTProcessSFQ_OnCard(): Unknown CT Command [0x%02X] recorded in SFThread->SF_CMND_Type",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              Sent_CT_Type,
                              0,0,0,0,0,0,0
                            );

            return fiCT_Cmd_Status_Confused;
        }
    }

    return fiCT_Cmd_Status_Confused;
#endif   /* __MemMap_Force_Off_Card__ */
}



os_bit32 fiCTProcessSFQ_OffCard(
                                   agRoot_t        *hpRoot,
                                   SFQConsIndex_t   SFQConsIndex,
                                   os_bit32            Frame_Length,
                                   fi_thread__t       **Thread_to_return
                                 )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t                  *CThread                   = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *SFQ_MemoryDescriptor      = &(CThread->Calculation.MemoryLayout.SFQ);
    FCHS_t                     *FCHS                      = (FCHS_t *)((os_bit8 *)(SFQ_MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr)
                                                                        + (SFQConsIndex * SFQ_MemoryDescriptor->elementSize));
    FC_CT_IU_HDR_t              *Payload                  = (FC_CT_IU_HDR_t *)((os_bit8 *)FCHS + sizeof(FCHS_t));
    os_bit32                    Payload_Wrap_Offset       = SFQ_MemoryDescriptor->objectSize
                                                             - (SFQConsIndex * SFQ_MemoryDescriptor->elementSize)
                                                             - sizeof(FCHS_t);
    FC_CT_IU_HDR_t              *Payload_Wrapped          = (FC_CT_IU_HDR_t *)((os_bit8 *)Payload
                                                                                          - SFQ_MemoryDescriptor->objectSize);
    os_bit32                    R_CTL__D_ID               = FCHS->R_CTL__D_ID;
    os_bit32                    TYPE__F_CTL               = FCHS->TYPE__F_CTL;
    os_bit32                    Recv_Command_Code;
    os_bit32                    Recv_CT_Type;
    X_ID_t                      OX_ID;
    X_ID_t                      RX_ID;
    fiMemMapMemoryDescriptor_t *CDBThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.CDBThread);
    os_bit32                    CDBThread_X_ID_Max         = CDBThread_MemoryDescriptor->elements - 1;
    fiMemMapMemoryDescriptor_t *SFThread_MemoryDescriptor  = &(CThread->Calculation.MemoryLayout.SFThread);
    os_bit32                    SFThread_X_ID_Offset       = CDBThread_X_ID_Max + 1;
    SFThread_t                 *SFThread;
    os_bit32                    Sent_CT_Type;
    os_bit32                 * pPayload = (os_bit32 *)Payload;

    /* Note the assumption that the entire FCHS fits in the pointed to SFQ entry (i.e. it doesn't wrap) */

    OX_ID = (X_ID_t)(((FCHS->OX_ID__RX_ID & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);

    RX_ID = (X_ID_t)(((FCHS->OX_ID__RX_ID & FCHS_RX_ID_MASK) >> FCHS_RX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);


    if ((TYPE__F_CTL & FC_Frame_Header_TYPE_MASK) == FC_Frame_Header_TYPE_Fibre_Channel_Services)
    {
        /* Process FibreChannel Services frames   */

        if ( (TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK) != FC_Frame_Header_F_CTL_Exchange_Context_Responder )
        {
            /* Starting here, this function only understands Service Responses */

            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "fiCTProcessSFQ_OffCard():",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "    (TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK)",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "        != FC_Frame_Header_F_CTL_Exchange_Context_Responder",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "    TYPE__F_CTL==0x%08X",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              TYPE__F_CTL,
                              0,0,0,0,0,0,0
                              );

            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "    R_CTL__D_ID 0x%08X",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              R_CTL__D_ID,
                              0,0,0,0,0,0,0
                             );

            *Thread_to_return = (fi_thread__t *)agNULL;

            return fiCT_Cmd_Status_Confused;
        }


        Recv_CT_Type = R_CTL__D_ID & FC_Frame_Header_R_CTL_Hi_MASK;


        if (Recv_CT_Type != FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame)
        {


            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "fiCTProcessSFQ_OffCard():",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "    (Recv_CT_Type != FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame)",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "    Recv_CT_Type==0x%08X",
                              (void *)agNULL,(void *)agNULL,
                              (char *)agNULL,
                              (char *)agNULL,
                              Recv_CT_Type,
                              0,0,0,0,0,0,0
                            );

            *Thread_to_return = (fi_thread__t *)agNULL;

            return fiCT_Cmd_Status_Confused;
        }

       /* Now we will have to look into the IU unit and parse on
         * FS_Type to see if this is an ACC or RJT
         */

        Recv_Command_Code = hpSwapBit32(Payload->CommandResponse_Code__MaximumResidual_Size);
        Recv_Command_Code = (Recv_Command_Code & FC_CT_IU_HDR_CommandResponse_Code_MASK);

        if (!(Recv_Command_Code == FC_CT_IU_HDR_CommandResponse_Code_FS_ACC_IU  ||
              Recv_Command_Code == FC_CT_IU_HDR_CommandResponse_Code_FS_RJT_IU ))

        {
            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "fiCTProcessSFQ_OffCard():",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "    Not ACC nor REJ",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0);


            *Thread_to_return = (fi_thread__t *)agNULL;

            return fiCT_Cmd_Status_Confused;
        }

        SFThread = (SFThread_t *)((os_bit8 *)SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                              + ((OX_ID - SFThread_X_ID_Offset) * SFThread_MemoryDescriptor->elementSize));

        *Thread_to_return = (fi_thread__t *)SFThread;

        Sent_CT_Type = SFThread->SF_CMND_Type;

        SFThread->SF_CMND_State = SFThread_SF_CMND_CT_State_Finished;
        switch(Sent_CT_Type)
        {
            case SFThread_SF_CMND_CT_Type_RFT_ID:
                /* Since we don't have to do anything, let's not call another function here.
                 * Just check to see if this an ACC or reject and return the right status.
                 */
                        fiLogDebugString(
                                          hpRoot,
                                          CTLogConsoleLevelInfo,
                                          "%s %08X %08X %08X %08X",
                                          "IN RFT_ID",
                                          (char *)agNULL,
                                          (void *)agNULL,(void *)agNULL,
                                          hpSwapBit32( *(pPayload+0)),
                                          hpSwapBit32( *(pPayload+1)),
                                          hpSwapBit32( *(pPayload+2)),
                                          hpSwapBit32( *(pPayload+3)),
                                          0,0,0,0);


                return ((Recv_Command_Code == FC_CT_IU_HDR_CommandResponse_Code_FS_ACC_IU) ? fiCT_Cmd_Status_ACC : fiCT_Cmd_Status_RJT);

           case SFThread_SF_CMND_CT_Type_GID_FT:
                /* Since we don't have to do anything, let's not call another function here.
                 * Just check to see if this an ACC or reject and return the right status.
                 * Copy the payload into the right place.
                 */
                        fiLogDebugString(
                                          hpRoot,
                                          CTLogConsoleLevelInfo,
                                          "%s %08X %08X %08X %08X %08X %08X %08X %08X ",
                                          "GID_FT",
                                          (char *)agNULL,
                                          (void *)agNULL,(void *)agNULL,
                                          hpSwapBit32( *(pPayload+0)),
                                          hpSwapBit32( *(pPayload+1)),
                                          hpSwapBit32( *(pPayload+2)),
                                          hpSwapBit32( *(pPayload+3)),
                                          hpSwapBit32( *(pPayload+4)),
                                          hpSwapBit32( *(pPayload+5)),
                                          hpSwapBit32( *(pPayload+6)),
                                          hpSwapBit32( *(pPayload+7)));

                    fiCTProcess_GID_FT_Response_OffCard(
                                         SFThread,
                                         Frame_Length,
                                         FCHS,
                                         (FC_CT_IU_HDR_t *)Payload,
                                         Payload_Wrap_Offset,
                                         (FC_CT_IU_HDR_t *)Payload_Wrapped
                                       );

                return ((Recv_Command_Code == FC_CT_IU_HDR_CommandResponse_Code_FS_ACC_IU) ? fiCT_Cmd_Status_ACC : fiCT_Cmd_Status_RJT);

            default:
            /* Unknown CT Command recorded in SFThread */

                    fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "fiCTProcessSFQ_OffCard(): Unknown CT Command ",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            return fiCT_Cmd_Status_Confused;
        }

    } /*(TYPE__F_CTL & FC_Frame_Header_TYPE_MASK) == FC_Frame_Header_TYPE_Fibre_Channel_Services */

    return fiCT_Cmd_Status_Confused;
#endif    /* __MemMap_Force_Off_Card__ */
}


void fiCTProcess_GID_FT_Response_OffCard(
                                              SFThread_t                 *SFThread,
                                              os_bit32                    Frame_Length,
                                              FCHS_t                     *FCHS,
                                              FC_CT_IU_HDR_t              *Payload,
                                              os_bit32                    Payload_Wrap_Offset,
                                              FC_CT_IU_HDR_t             *Payload_Wrapped
                                            )
{

#ifndef __MemMap_Force_On_Card__
    agRoot_t                            *hpRoot             = SFThread->thread_hdr.hpRoot;
    CThread_t                           *pCThread           = CThread_ptr(hpRoot);
    FC_NS_DU_GID_FT_FS_ACC_Payload_t    *pGID_FT_Payload;
    os_bit32                             Bit8_Index         =0;
    os_bit32                             Bit32_Index        =0;
    os_bit32                             CurrentBit32_Index = pCThread->NS_CurrentBit32Index;
    os_bit32                             NumDevices         = pCThread->Calculation.Parameters.NumDevices;

    os_bit32                            *pPayload = (os_bit32 *)Payload;

    FC_NS_DU_GID_PT_FS_ACC_Payload_t * RegisteredEntries  = (FC_NS_DU_GID_PT_FS_ACC_Payload_t *)(CThread_ptr(hpRoot)->Calculation.MemoryLayout.FabricDeviceMAP.addr.CachedMemory.cachedMemoryPtr);

    /* Zero out old Fabric MAP for changes in Zoning */
    for(Bit8_Index=0;Bit8_Index < NumDevices; Bit8_Index++)
    {
        RegisteredEntries->Control_Port_ID[Bit8_Index].Control = 0;
        RegisteredEntries->Control_Port_ID[Bit8_Index].Port_ID[0] = 0;
        RegisteredEntries->Control_Port_ID[Bit8_Index].Port_ID[1] = 0;
        RegisteredEntries->Control_Port_ID[Bit8_Index].Port_ID[2] = 0;
    }

    Payload_Wrap_Offset = Payload_Wrap_Offset - sizeof(FC_CT_IU_HDR_t);

    fiLogDebugString( hpRoot,
                    CTLogConsoleLevel,
                    "%s Payload %p Payload_Wrapped %p FL %d",
                    "fiCTProcess_GID_FT_Response_OffCard",
                    (char *)agNULL,
                    (void *)Payload,(void *)Payload_Wrapped,
                    Frame_Length,
                    0,0,0,0,0,0,0 );

    fiLogDebugString( hpRoot,
                   CTLogConsoleLevel,
                    "%s %08X %08X %08X %08X %08X %08X %08X %08X",
                    "GID_FT",
                    (char *)agNULL,
                    FCHS,(void *)agNULL,
                    hpSwapBit32( *(pPayload+0)),
                    hpSwapBit32( *(pPayload+1)),
                    hpSwapBit32( *(pPayload+2)),
                    hpSwapBit32( *(pPayload+3)),
                    hpSwapBit32( *(pPayload+4)),
                    hpSwapBit32( *(pPayload+5)),
                    hpSwapBit32( *(pPayload+6)),
                    hpSwapBit32( *(pPayload+7)));

    fiLogDebugString( hpRoot,
                  CTLogConsoleLevel,
                  "%s %08X %08X %08X %08X %08X %08X %08X %08X",
                  "GID_FT",
                  (char *)agNULL,
                  (void *)agNULL,(void *)agNULL,
                  hpSwapBit32( *(pPayload+8)),
                  hpSwapBit32( *(pPayload+9)),
                  hpSwapBit32( *(pPayload+10)),
                  hpSwapBit32( *(pPayload+11)),
                  hpSwapBit32( *(pPayload+12)),
                  hpSwapBit32( *(pPayload+13)),
                  hpSwapBit32( *(pPayload+14)),
                  hpSwapBit32( *(pPayload+15)));

    if( Frame_Length > (FC_NS_DU_GID_PT_FS_ACC_Payload_t_SIZE + sizeof(FCHS_t) + sizeof(FC_CT_IU_HDR_t)) )
    {

        fiLogString(hpRoot,
                    "%s Frame (%x) To Large !(%X)",
                    "fiCTProcess_GID_FT_Response_OffCard",
                    (char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    Frame_Length,
                    FC_NS_DU_GID_PT_FS_ACC_Payload_t_SIZE + sizeof(FCHS_t) + sizeof(FC_CT_IU_HDR_t),
                    0,0,0,0,0,0 );

        fiLogDebugString( hpRoot,
                    CTLogConsoleLevel,
                    "%s Frame (%x) To Large !(%X)",
                    "fiCTProcess_GID_FT_Response_OffCard",
                    (char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    Frame_Length,
                    FC_NS_DU_GID_PT_FS_ACC_Payload_t_SIZE + sizeof(FCHS_t) + sizeof(FC_CT_IU_HDR_t),
                    0,0,0,0,0,0 );
        Frame_Length = (FC_NS_DU_GID_PT_FS_ACC_Payload_t_SIZE + sizeof(FCHS_t) + sizeof(FC_CT_IU_HDR_t));
    }

    while (Bit32_Index <= ((Frame_Length - sizeof(FCHS_t) - sizeof(FC_CT_IU_HDR_t))/sizeof(os_bit32)))
    {
        if ((hpFieldOffset(FC_NS_DU_GID_FT_FS_ACC_Payload_t,Control_Port_ID[Bit32_Index])
            + sizeof(os_bit32)) <= Payload_Wrap_Offset)
        {
            pGID_FT_Payload = (FC_NS_DU_GID_FT_FS_ACC_Payload_t *)((os_bit8 *)Payload + sizeof(FC_CT_IU_HDR_t));
            RegisteredEntries->Control_Port_ID[CurrentBit32_Index].Control = pGID_FT_Payload->Control_Port_ID[Bit32_Index].Control;

            for (Bit8_Index = 0;
                Bit8_Index < (FC_NS_Control_Port_ID_t_SIZE - 1);
                Bit8_Index++)
            {
                RegisteredEntries->Control_Port_ID[CurrentBit32_Index].Port_ID[Bit8_Index] = pGID_FT_Payload->Control_Port_ID[Bit32_Index].Port_ID[Bit8_Index];
            }
        }
        else
        {
            pGID_FT_Payload = (FC_NS_DU_GID_FT_FS_ACC_Payload_t *)((os_bit8 *)Payload_Wrapped + sizeof(FC_CT_IU_HDR_t));
            RegisteredEntries->Control_Port_ID[CurrentBit32_Index].Control = pGID_FT_Payload->Control_Port_ID[Bit32_Index].Control;

            for (Bit8_Index = 0;
                Bit8_Index < (FC_NS_Control_Port_ID_t_SIZE - 1);
                Bit8_Index++)
            {
                RegisteredEntries->Control_Port_ID[CurrentBit32_Index].Port_ID[Bit8_Index] = pGID_FT_Payload->Control_Port_ID[Bit32_Index].Port_ID[Bit8_Index];
            }
        }


       if (RegisteredEntries->Control_Port_ID[CurrentBit32_Index].Control == FC_NS_Control_Port_ID_Control_Last_Port_ID)
       {
            pCThread->ExpectMoreNSFrames = agFALSE;
            pCThread->NS_CurrentBit32Index = 0;
            fiLogDebugString( hpRoot,
                CTLogConsoleLevel,
                "fiCTProcessSFQ_OffCard(): Reached End of Name Server Database NumOfEntries %x ",
                (char *)agNULL,
                (char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                CurrentBit32_Index,
                0,0,0,0,0,0,0
                );

            break;
        }

        Bit32_Index++;
        CurrentBit32_Index++;
        if( CurrentBit32_Index == NumDevices)
        {   /* Dont go beyond number of devices */
            /* Set Last entry to indicate end   */
            RegisteredEntries->Control_Port_ID[CurrentBit32_Index].Control = FC_NS_Control_Port_ID_Control_Last_Port_ID;
            break;

        }
        pCThread->NS_CurrentBit32Index = CurrentBit32_Index;
    }
    pPayload = (os_bit32 *)RegisteredEntries;
    fiLogDebugString( hpRoot,
                    CTLogConsoleLevel,
                    "%s %08X %08X %08X %08X %08X %08X %08X %08X",
                    "Reg E",
                    (char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    hpSwapBit32( *(pPayload+0)),
                    hpSwapBit32( *(pPayload+1)),
                    hpSwapBit32( *(pPayload+2)),
                    hpSwapBit32( *(pPayload+3)),
                    hpSwapBit32( *(pPayload+4)),
                    hpSwapBit32( *(pPayload+5)),
                    hpSwapBit32( *(pPayload+6)),
                    hpSwapBit32( *(pPayload+7)));
    fiLogDebugString( hpRoot,
                    CTLogConsoleLevel,
                    "%s %08X %08X %08X %08X %08X %08X %08X %08X",
                    "Reg E",
                    (char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    hpSwapBit32( *(pPayload+8)),
                    hpSwapBit32( *(pPayload+9)),
                    hpSwapBit32( *(pPayload+10)),
                    hpSwapBit32( *(pPayload+11)),
                    hpSwapBit32( *(pPayload+12)),
                    hpSwapBit32( *(pPayload+13)),
                    hpSwapBit32( *(pPayload+14)),
                    hpSwapBit32( *(pPayload+15)));


#endif /* __MemMap_Force_On_Card__ was not defined */
}

#endif /* NAME_SERVICES */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\cdbstate.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/CDBSTATE.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 7/20/00 2:33p   $

Purpose:

  This file defines the macros, types, and data structures
  used by ../C/cdbState.C

--*/

#ifndef __CDBState_H__
#define __CDBState_H__

#define   CDBStateConfused                  0
#define   CDBStateThreadFree                1
#define   CDBStateInitialize                2
#define   CDBStateFillLocalSGL              3
#define   CDBStateAllocESGL                 4
#define   CDBStateFillESGL                  5
#define   CDBStateSendIo                    6
#define   CDBStateFcpCompleteSuccess        7
#define   CDBStateFcpCompleteSuccessRSP     8

#define   CDBStateFcpCompleteFail           9
#define   CDBStateFcpCompleteAbort          10    /* a */
#define   CDBStateFcpCompleteDeviceReset    11    /* b */
#define   CDBStateFcpCompleteOver           12    /* c */
#define   CDBStateOOOReceived               13    /* d */
#define   CDBStateOOOFixup                  14    /* e */
#define   CDBStateOOOSend                   15    /* f */

#define   CDBStateInitialize_DR             16    /* 10 */
#define   CDBStateFillLocalSGL_DR           17    /* 11 */
#define   CDBStateAllocESGL_DR              18    /* 12 */
#define   CDBStateFillESGL_DR               19    /* 13 */

#define   CDBStateInitialize_Abort          20    /* 14 */
#define   CDBStateFillLocalSGL_Abort        21    /* 15 */
#define   CDBStateAllocESGL_Abort           22    /* 16 */
#define   CDBStateFillESGL_Abort            23    /* 17 */

#define   CDBStateOOOReceived_Abort         24    /* 18 */
#define   CDBStateOOOReceived_DR            25    /* 19 */
#define   CDBStateOOOFixup_Abort            26    /* 1A */
#define   CDBStateOOOFixup_DR               27    /* 1B */

#define   CDBStateOutBoundError             28    /* 1C */
#define   CDBStateFailure_NO_RSP            29    /* 1D */

#define   CDBStateAlloc_Abort               30    /* 1E */
#define   CDBStateDo_Abort                  31    /* 1F */

#define   CDBStatePending_Abort             32    /* 20 */
#define   CDBStatePrepare_For_Abort         33    /* 21 */

#define   CDBStateBuild_CCC_IO              34    /* 22 */
#define   CDBStateSend_CCC_IO               35    /* 23 */
#define   CDBState_CCC_IO_Success           36    /* 24 */
#define   CDBState_CCC_IO_Fail              37    /* 25 */

#define   CDBStateSend_REC                  38    /* 26 */
#define   CDBStateSend_REC_Second           39    /* 27 */
#define   CDBStateSend_SRR                  40    /* 28 */
#define   CDBStateSend_SRR_Second           41    /* 29 */

#define   CDBState_REC_Success              42    /* 2A */
#define   CDBState_SRR_Success              43    /* 2B */
 
#define   CDBState_SRR_Fail                 44    /* 2C */
#define   CDBState_Alloc_REC                45    /* 2D */
#define   CDBStateDO_Nothing                46    /* 2E */
#define   CDBStateReSend_IO                 47    /* 2F */

#define   CdbStateMAXState      CDBStateReSend_IO                 


#define   CDBEventConfused        0
#define   CDBEventInitialize      1
#define   CDBEventLocalSGL        2
#define   CDBEventNeedESGL        3
#define   CDBEventGotESGL         4
#define   CDBEventESGLSendIo      5
#define   CDBEventLocalSGLSendIo  6
#define   CDBEventIoSuccess       7
#define   CDBEventIoFailed        8
#define   CDBEventIoAbort         9
#define   CDBEventIoOver         10
#define   CDBEventThreadFree     11
#define   CDBEventIODeviceReset  12

#define   CDBEventOOOReceived    13
#define   CDBEventOOOFixup       14
#define   CDBEventOOOSend        15

#define   CDBEventIoSuccessRSP   16

#define   CDBEventOutBoundError  17
#define   CDBEventFailNoRSP      18

#define   CDBEventAlloc_Abort     19
#define   CDBEventDo_Abort        20
#define   CDBEvent_Abort_Rejected 21

#define   CDBEvent_PrepareforAbort   22

#define   CDBEventDo_CCC_IO          23
#define   CDBEvent_CCC_IO_Built      24
#define   CDBEvent_CCC_IO_Success    25
#define   CDBEvent_CCC_IO_Fail       26

#define   CDBEventREC_TOV            27
#define   CDBEventSendREC_Success    28
#define   CDBEventSendREC_Fail       29
#define   CDBEventSendSRR            30
#define   CDBEventSendSRR_Success    31
#define   CDBEventSendSRR_Again      32

#define   CDBEvent_Got_REC           33
#define   CDBEvent_ResendIO          34
#define   CDBEventSendSRR_Fail       35

#define   CdbEventMAXEvent  CDBEventSendSRR_Fail

#define   CdbCompetionStatusReSendIO  0x0000FFFF


STATE_PROTO( CDBActionConfused               );                    /* 0  */
STATE_PROTO( CDBActionThreadFree             );                    /* 1  */
STATE_PROTO( CDBActionInitialize             );                    /* 2  */
STATE_PROTO( CDBActionFillLocalSGL           );                    /* 3  */
STATE_PROTO( CDBActionAllocESGL              );                    /* 4  */
STATE_PROTO( CDBActionFillESGL               );                    /* 5  */
STATE_PROTO( CDBActionSendIo                 );                    /* 6  */
STATE_PROTO( CDBActionFcpCompleteSuccess     );                    /* 7  */
STATE_PROTO( CDBActionFcpCompleteSuccessRSP  );                    /* 8  */
STATE_PROTO( CDBActionFcpCompleteFail        );                    /* 9  */
STATE_PROTO( CDBActionFcpCompleteAbort       );                    /* 10 */
STATE_PROTO( CDBActionFcpCompleteDeviceReset );                    /* 11 */
STATE_PROTO( CDBActionFcpCompleteOver        );                    /* 12 */
STATE_PROTO( CDBActionOOOReceived            );                    /* 13 */
STATE_PROTO( CDBActionOOOFixup               );                    /* 14 */
STATE_PROTO( CDBActionOOOSend                );                    /* 15 */
STATE_PROTO( CDBActionInitialize_DR          );                    /* 16 */
STATE_PROTO( CDBActionFillLocalSGL_DR        );                    /* 17 */
STATE_PROTO( CDBActionAllocESGL_DR           );                    /* 18 */
STATE_PROTO( CDBActionFillESGL_DR            );                    /* 19 */
STATE_PROTO( CDBActionInitialize_Abort       );                    /* 20 */
STATE_PROTO( CDBActionFillLocalSGL_Abort     );                    /* 21 */
STATE_PROTO( CDBActionAllocESGL_Abort        );                    /* 22 */
STATE_PROTO( CDBActionFillESGL_Abort         );                    /* 23 */

STATE_PROTO( CDBActionOOOReceived_Abort      );                    /* 24 */
STATE_PROTO( CDBActionOOOReceived_DR         );                    /* 25 */
STATE_PROTO( CDBActionOOOFixup_Abort         );                    /* 26 */
STATE_PROTO( CDBActionOOOFixup_DR            );                    /* 27 */

STATE_PROTO( CDBActionOutBoundError          );                    /* 28 */
STATE_PROTO( CDBActionFailure_NO_RSP         );                    /* 29 */

STATE_PROTO( CDBActionAlloc_Abort            );                    /* 30 */
STATE_PROTO( CDBActionDo_Abort               );                    /* 31 */

STATE_PROTO( CDBActionPending_Abort          );                    /* 32 */

STATE_PROTO( CDBActionPrepare_For_Abort      );                    /* 33 */

STATE_PROTO( CDBActionBuild_CCC_IO      );
STATE_PROTO( CDBActionSend_CCC_IO       );
STATE_PROTO( CDBAction_CCC_IO_Success   );
STATE_PROTO( CDBAction_CCC_IO_Fail      );

STATE_PROTO( CDBActionSend_REC       );
STATE_PROTO( CDBActionSend_REC_Second);
STATE_PROTO( CDBActionSend_SRR       );
STATE_PROTO( CDBActionSend_SRR_Second);
STATE_PROTO( CDBAction_REC_Success   );
STATE_PROTO( CDBAction_SRR_Success   );
STATE_PROTO( CDBAction_SRR_Fail      );
STATE_PROTO( CDBAction_Alloc_REC     );
STATE_PROTO( CDBActionDO_Nothing     );
STATE_PROTO( CDBActionReSend_IO      );

extern stateTransitionMatrix_t CDBStateTransitionMatrix;
extern stateActionScalar_t CDBStateActionScalar;

extern void fill_Loc_SGL_offCard(CDBThread_t * pCDBThread);
extern void fill_Loc_SGL_onCard(CDBThread_t * pCDBThread);

void fillptr_SEST_offCard_ESGL_offCard(CDBThread_t * pCDBThread);
void fillptr_SEST_offCard_ESGL_onCard(CDBThread_t * pCDBThread);
void fillptr_SEST_onCard_ESGL_offCard(CDBThread_t * pCDBThread);
void fillptr_SEST_onCard_ESGL_onCard(CDBThread_t * pCDBThread);

void fill_ESGL_onCard(CDBThread_t * pCDBThread);
void fill_ESGL_offCard(CDBThread_t * pCDBThread);

void CDBFuncIRB_onCardInit(CDBThread_t  * CDBThread );
void CDBFuncIRB_offCardInit(CDBThread_t  * CDBThread );

CDBThread_t *CCC_CdbThreadAlloc(
                             agRoot_t          *hpRoot,
                             DevThread_t       *DevThread,
                             os_bit32 Lun
                           );


#ifdef USESTATEMACROS

void testCDBthread( agRoot_t *hpRoot  );

#define CDBSTATE_FUNCTION_ACTION( x , Action) extern void x( fi_thread__t * thread, \
                 eventRecord_t * eventRecord ){         \
    agRoot_t * hpRoot=thread->hpRoot;                   \
    osLogDebugString(hpRoot,                            \
                      StateLogConsoleLevel,             \
                      "In %s - State = %d",             \
                      #x,(char *)agNULL,                \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)thread->currentState,   \
                      0,0,0,0,0,0,0);                   \
    osLogDebugString(thread->hpRoot,                    \
                      StateLogConsoleLevel,             \
                      "Sends event...%s %d",          \
                      #Action,(char *)agNULL,             \
                      (void * )agNULL,(void * )agNULL,  \
                      Action,0,0,0,0,0,0,0);            \
    fiSetEventRecord(eventRecord, thread, Action);   }  \

#define CDBSTATE_FUNCTION_TERMINATE(x) extern void x(fi_thread__t *thread,\
                                      eventRecord_t *eventRecord ){\
    agRoot_t * hpRoot=thread->hpRoot;                   \
    CThread_t  * pCThread=CThread_ptr(hpRoot);          \
    CDBThread_t * pCDBThread=(CDBThread_t * )thread;    \
    DevThread_t * pDevThread=pCDBThread->Device;        \
    osLogDebugString(hpRoot,                            \
                      StateLogConsoleLevel,             \
                      "In %s - State = %d",     \
                      #x,(char *)agNULL,                  \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)thread->currentState,      \
                      0,0,0,0,0,0,0);                   \
    osLogDebugString(thread->hpRoot,                    \
                      StateLogConsoleLevel,             \
                      "...simply returns",            \
                      (char *)agNULL,(char *)agNULL,        \
                      (void * )agNULL,(void * )agNULL,  \
                      0,0,0,0,0,0,0,0);                 \
    eventRecord->thread = agNULL;                         \
    }\

#define CDBSTATE_FUNCTION_MULTI_ACTION(x,Action0,Action1,Action2,Action3) extern void x( fi_thread__t *thread,\
                                      eventRecord_t *eventRecord ){ \
    agRoot_t * hpRoot = thread->hpRoot;               \
    os_bit8 WhichAction[4];                              \
    static  os_bit32 ActionCount=0;                      \
    WhichAction[0] = Action0;                         \
    WhichAction[1] = Action1;                         \
    WhichAction[2] = Action2;                         \
    WhichAction[3] = Action3;                         \
    osLogDebugString(thread->hpRoot,                  \
                      StateLogConsoleLevel,           \
                      "In %s - State = %d",           \
                      #x,(char *)agNULL,                \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)thread->currentState,    \
                      0,0,0,0,0,0,0);                 \
    osLogDebugString(thread->hpRoot,                  \
                      StateLogConsoleLevel,           \
                      "...returns event %s %d",       \
                      #Action0,#Action1,              \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)WhichAction[ActionCount],\
                      0,0,0,0,0,0,0);                 \
    osLogDebugString(thread->hpRoot,                  \
                      StateLogConsoleLevel,           \
                      "or %s  or %s",                 \
                      #Action2,#Action3,              \
                      (void * )agNULL,(void * )agNULL,  \
                      0,0,0,0,0,0,0,0);               \
    fiSetEventRecord(eventRecord,thread,WhichAction[ActionCount]);  \
    if(ActionCount<3)ActionCount++;                   \
    else ActionCount =0;                              \
    }                                                 \

#ifdef  TestCdbStateMachine

char * CdbStateString[]=
{

    "CDBStateConfused               ",
    "CDBStateThreadFree             ",
    "CDBStateInitialize             ",
    "CDBStateFillLocalSGL           ",
    "CDBStateAllocESGL              ",
    "CDBStateFillESGL               ",
    "CDBStateSendIo                 ",
    "CDBStateFcpCompleteSuccess     ",
    "CDBStateFcpCompleteSuccessRSP  ",
    "CDBStateFcpCompleteFail        ",
    "CDBStateFcpCompleteAbort       ",
    "CDBStateFcpCompleteDeviceReset ",
    "CDBStateFcpCompleteOver        ",
    "CDBStateOOOReceived            ",
    "CDBStateOOOFixup               ",
    "CDBStateOOOSend                ",
    "CDBStateInitialize_DR          ",
    "CDBStateFillLocalSGL_DR        ",
    "CDBStateAllocESGL_DR           ",
    "CDBStateFillESGL_DR            ",
    "CDBStateInitialize_Abort       ",
    "CDBStateFillLocalSGL_Abort     ",
    "CDBStateAllocESGL_Abort        ",
    "CDBStateFillESGL_Abort         ",
    "CDBStateOOOReceived_Abort      ",
    "CDBStateOOOReceived_DR         ",
    "CDBStateOOOFixup_Abort         ",
    "CDBStateOOOFixup_DR            ",
    "CDBStateOutBoundError          ",
    "CDBStateFailure_NO_RSP         ",
    "CDBStateAlloc_Abort            ",
    "CDBStateDo_Abort               ",
    "CDBStatePending_Abort          ",
    "CDBStatePrepare_For_Abort      ",
    "CDBStateBuild_CCC_IO           ",
    "CDBStateSend_CCC_IO            ",
    "CDBState_CCC_IO_Success        ",
    "CDBState_CCC_IO_Fail           ",
    "CDBStateSend_REC               ",
    "CDBStateSend_REC_Second        ",
    "CDBStateSend_SRR               ",
    "CDBStateSend_SRR_Second        ",
    "CDBState_REC_Success           ",
    "CDBState_SRR_Success           ",
    "CDBState_SRR_Fail              ",
    "CDBState_Alloc_REC             ",
    "CDBStateDO_Nothing             ",
    "CDBStateReSend_IO              ",
    agNULL
};


char * CdbEventString[]=
{

    "CDBEventConfused         ",
    "CDBEventInitialize       ",
    "CDBEventLocalSGL         ",
    "CDBEventNeedESGL         ",
    "CDBEventGotESGL          ",
    "CDBEventESGLSendIo       ",
    "CDBEventLocalSGLSendIo   ",
    "CDBEventIoSuccess        ",
    "CDBEventIoFailed         ",
    "CDBEventIoAbort          ",
    "CDBEventIoOver           ",
    "CDBEventThreadFree       ",
    "CDBEventIODeviceReset    ",
    "CDBEventOOOReceived      ",
    "CDBEventOOOFixup         ",
    "CDBEventOOOSend          ",
    "CDBEventIoSuccessRSP     ",
    "CDBEventOutBoundError    ",
    "CDBEventFailNoRSP        ",
    "CDBEventAlloc_Abort      ",
    "CDBEventDo_Abort         ",
    "CDBEvent_Abort_Rejected  ",
    "CDBEvent_PrepareforAbort ",
    "CDBEventDo_CCC_IO        ",
    "CDBEvent_CCC_IO_Built    ",
    "CDBEvent_CCC_IO_Success  ",
    "CDBEvent_CCC_IO_Fail     ",
    "CDBEventREC_TOV          ",
    "CDBEventSendREC_Success  ",
    "CDBEventSendREC_Fail     ",
    "CDBEventSendSRR          ",
    "CDBEventSendSRR_Success  ",
    "CDBEventSendSRR_Again    ",
    "CDBEvent_Got_REC         ",
    "CDBEvent_ResendIO        ",
    agNULL
};

#endif /* USESTATEMACROS was defined */

#endif /* USESTATEMACROS was defined */

#endif /*  __CDBState_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\cfimq.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/CFIMQ.C $

  $Revision:: 3               $
      $Date:: 7/16/01 2:07p   $
   $Modtime:: 7/16/01 2:03p   $

Purpose:

  This file implements IMQ functions called by the FC Layer Card State Machine.

--*/

#ifndef _New_Header_file_Layout_
#include "../h/globals.h"
#include "../h/fcstruct.h"
#include "../h/state.h"

#include "../h/tlstruct.h"
#include "../h/memmap.h"
#include "../h/fcmain.h"
#include "../h/linksvc.h"
#include "../h/cmntrans.h"
#ifdef _DvrArch_1_30_
#include "../h/ip.h"
#include "../h/ipstate.h"
#endif /* _DvrArch_1_30_ was defined */

#include "../h/flashsvc.h"
#include "../h/timersvc.h"

#include "../h/cstate.h"
#include "../h/cfunc.h"
#include "../h/devstate.h"
#include "../h/cdbstate.h"
#include "../h/sf_fcp.h"
#include "../h/sfstate.h"

#include "../h/queue.h"
#include "../h/cdbsetup.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "fcstruct.h"
#include "state.h"

#include "tlstruct.h"
#include "memmap.h"
#include "fcmain.h"
#include "linksvc.h"
#include "cmntrans.h"
#ifdef _DvrArch_1_30_
#include "ip.h"
#include "ipstate.h"
#endif /* _DvrArch_1_30_ was defined */

#include "flashsvc.h"
#include "timersvc.h"

#include "cstate.h"
#include "cfunc.h"
#include "devstate.h"
#include "cdbstate.h"
#include "sf_fcp.h"
#include "sfstate.h"

#include "queue.h"
#include "cdbsetup.h"
#endif  /* _New_Header_file_Layout_ */


#ifndef __State_Force_Static_State_Tables__
extern actionUpdate_t noActionUpdate;
#endif /* __State_Force_Static_State_Tables__ was not defined */

extern os_bit8 Alpa_Index[256];

/*+
  Function: CFuncInterruptPoll
   Purpose: Called when pollingCount number of events need to be completed.
 Called By: fiResetDevice
            CActionVerify_AL_PA
            CActionDoFlogi
            CActionNormal
            CActionLoopFail
            CActionFindDeviceUseAllALPAs
            CActionFindDeviceUseLoopMap
            CActionFindPtToPtDevice
            CActionFindDeviceUseNameServer
            CActionFindDeviceUseNameServer
            CActionExternalLogoutRecovery
            CActionDoExternalDeviceReset
            CActionDoRFT_ID
            CActionDoDiPlogi
            CActionDoGID_FT
            CActionDoSCR
            CActionSCRSuccess
            fcInitializeChannel
            fcStartIO

     Calls: CFunc_Always_Enable_Queues
            osChipIOUpReadBit32
            CFuncFMCompletion
            osStallThread
            fiTimerTick
            Proccess_IMQ
-*/
agBOOLEAN CFuncInterruptPoll(
                         agRoot_t *hpRoot,
                         os_bit32 * pollingCount
                       )
{
    CThread_t           * CThread         = CThread_ptr(hpRoot);
    os_bit32              PollingCalls    = 0;
    agBOOLEAN             TimeoutOccured  = agFALSE;    
    os_bit32              Original_CState = CThread->thread_hdr.currentState;

    fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "Enter pollingCount %x",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        *pollingCount,
                        0,0,0,0,0,0,0);


    while ( *pollingCount > 0)
    {
        PollingCalls++;
        if( CThread->thread_hdr.currentState == CStateLIPEventStorm         ||
            CThread->thread_hdr.currentState == CStateElasticStoreEventStorm   )
        {
            return(agTRUE);
        }

        if(Original_CState != CThread->thread_hdr.currentState  )
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "State Change during Poll Was %d Now %d FDCCnt %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    Original_CState,
                    CThread->thread_hdr.currentState ,
                    CThread->FindDEV_pollingCount,
                    0,0,0,0,0);
            return(agTRUE);
        }
/*
        if( (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ) &
                                        ChipIOUp_Frame_Manager_Status_LSM_MASK) ==
                                        ChipIOUp_Frame_Manager_Status_LSM_Loop_Fail )
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "LSM Loop Fail FM Status %08X FM Config %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0,0,0,0);

            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Loop Fail TL Status %08X TL Control %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0,0);
            return(agTRUE);
        }
*/
        if ( CFunc_Always_Enable_Queues(hpRoot ) )
        {
/*
            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) %s Loop Fail Queues Frozen after Enable",
                        "CFuncInterruptPoll",(char *)agNULL,
                        hpRoot,agNULL,
                        0,0,0,0,0,0,0,0);
*/
        }


        if(PollingCalls > 2 * ( SF_EDTOV / Interrupt_Polling_osStallThread_Parameter)){

               fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "PollingCalls  TIMEOUT Polling Count %x FM %08X InIMQ %x TL status %08X Qf %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    *pollingCount,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    CThread->ProcessingIMQ,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    CFunc_Queues_Frozen( hpRoot ),
                    0,0,0);

            PollingCalls=0;
            return(agTRUE);
        }

        if( ! PollingCalls > (100000 / Interrupt_Polling_osStallThread_Parameter) )
        {
            TimeoutOccured = agTRUE;
        }

        if( ! PollingCalls % 1000 )
        {

            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "PollingCalls  Queues FROZEN Polling Count %x FM %08X InIMQ %x TL status %08X Qf %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    *pollingCount,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    CThread->ProcessingIMQ,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    CFunc_Queues_Frozen( hpRoot ),
                    0,0,0);

            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "CFuncIMQ_Interrupt_Pending %x Int %08X  Hc IMQ Con %x IMQ Prod %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CFuncIMQ_Interrupt_Pending( hpRoot ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST ),
                    CThread->HostCopy_IMQConsIndex,
                    CThread->FuncPtrs.GetIMQProdIndex(hpRoot),
                    0,0,0,0);


           if(osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ) &
                   (~ ( ChipIOUp_Frame_Manager_Status_LP      |
                        ChipIOUp_Frame_Manager_Status_LSM_MASK   )) )
            {
                if (CThread->HostCopy_IMQConsIndex == CThread->FuncPtrs.GetIMQProdIndex(hpRoot))
                {
                    CFuncFMCompletion(hpRoot);
                }
                else
                {
                    continue;
                }
            }
            else
            {
                PollingCalls=0;
                return(agTRUE);
            }
        }

        osStallThread(
                       hpRoot,
                       Interrupt_Polling_osStallThread_Parameter
                     );

        fiTimerTick(
                       hpRoot,
                       Interrupt_Polling_osStallThread_Parameter
                     );

        if( !CThread->FuncPtrs.Proccess_IMQ(hpRoot))
        {
            if(osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ) &
                   (~ ( ChipIOUp_Frame_Manager_Status_LP      |
                        ChipIOUp_Frame_Manager_Status_LSM_MASK   )) )
            {
                if (CThread->HostCopy_IMQConsIndex == CThread->FuncPtrs.GetIMQProdIndex(hpRoot))
                {
                    CFuncFMCompletion(hpRoot);
                }
            }
        }
    }
    fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Leave pollingCount %x PollingCalls %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    *pollingCount,
                    PollingCalls,
                    0,0,0,0,0,0);
    if( TimeoutOccured )
    {
        fiLogString(hpRoot,
                    "%s Long Time %x PC %x",
                    "CFuncInterruptPoll",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    *pollingCount,
                    PollingCalls,
                    0,0,0,0,0,0);

    }

    return(agFALSE);

}


/*****************************************************************************************************************/

/*+
  Function: CFuncOffCardProcessIMQ
   Purpose: Proccess inbound message queue for inDmaMemory located message queue.
            Accessed via CThread->FuncPtrs.Proccess_IMQ
 Called By: CFuncInterruptPoll
            CFuncInteruptDelay
            CFuncLoopDownPoll
            CFuncFreezeQueuesPoll
            CFuncAll_clear
            CFuncTakeOffline
            CFuncWaitForFCP
            CActionInitFM
            CActionVerify_AL_PA
            CActionFreeSFthread
            CActionSuccess
            CActionLoopFail
            CActionReInitFM
            CActionInitializeFailed
            CActionFindDeviceUseAllALPAs
            DevActionDoPlogi
            DevActionDoPrli
            DevActionPrliDone
            DevActionLogout
            DevActionDeviceResetSoft
            DevActionDeviceResetHard
            fcDelayedInterruptHandler
            fcInitializeChannel
            fcResetDevice
            fcStartIO
            fcTimerTick
            SFActionDoPlogi
            SFActionDoPrli
     Calls: FuncPtrs.GetIMQProdIndex
            FuncPtrs.FCP_Completion
            CFuncFMCompletion
            CFuncOutBoundCompletion
            CFuncErrorIdle
            CFuncErrorFCP_Frozen
            osChipIOLoWriteBit
-*/
agBOOLEAN CFuncOffCardProcessIMQ(
                agRoot_t *hpRoot
                )
{
#ifndef __MemMap_Force_On_Card__
    /*
        Returns agTRUE if there was a problem  agFALSE if there was something to do

    */

    CThread_t  * pCThread = CThread_ptr(hpRoot);

    os_bit32 tempIMQProdIndex;
    os_bit32 tempCMType;
    os_bit32 tempCMWord1;

    os_bit32 num_IMQel;

    CM_Unknown_t * pGenericCM;

#ifdef OSLayer_Stub_USESTATEMACROS

    fiList_t            * pList;
    SFThread_Request_t  * pSFreq;
    SFThread_t          * pSFThread;

#endif /*OSLayer_Stub_USESTATEMACROS*/

    if (pCThread->ProcessingIMQ == agTRUE)
    {
        return agFALSE;
    }
    pCThread->ProcessingIMQ = agTRUE;

    tempIMQProdIndex= pCThread->FuncPtrs.GetIMQProdIndex(hpRoot);

    if (pCThread->HostCopy_IMQConsIndex == tempIMQProdIndex)
    {
#ifndef Performance_Debug
        fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "pCThread->HostCopy_IMQConsIndex == tempIMQProdIndex CDBCnt %x",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCThread->CDBpollingCount,
                        0,0,0,0,0,0,0);
#endif /* Performance_Debug */

        pCThread->ProcessingIMQ = agFALSE;
        return agFALSE;
    }

    /*
    ** an INT (IMQ entry received) interrupt occured. Interrupt cleared by
    ** updating the IMQ consumer index register.
    */

    /*
    ** while there are IMQ completion messages to process
    */

    num_IMQel = pCThread->Calculation.MemoryLayout.IMQ.elements;

    while (pCThread->HostCopy_IMQConsIndex != pCThread->FuncPtrs.GetIMQProdIndex(hpRoot))
    {
        /* Big_Endian_Code */
        AFTERIO(hpRoot);
        pGenericCM  = pCThread->Calculation.MemoryLayout.IMQ.addr.DmaMemory.dmaMemoryPtr;
        pGenericCM += pCThread->HostCopy_IMQConsIndex;
        tempCMType  = pGenericCM->INT__CM_Type & CM_Unknown_CM_Type_MASK;
       /*
       ** get the completion message type
       */

#ifndef Performance_Debug
       fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "tempCMType %08X IMQ Consumer %X Temp IMQ %X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    tempCMType,
                    pCThread->HostCopy_IMQConsIndex,
                    tempIMQProdIndex,0,0,0,0,0);
#endif /* Performance_Debug */

        switch (tempCMType) {

            case  CM_Unknown_CM_Type_Inbound_FCP_Exchange:
                tempCMWord1 = pGenericCM->Unused_DWord_1;
#ifndef Performance_Debug
                fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "hpRoot (%p) Inbound_FCP_Exchange %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        tempCMType,
                        tempCMWord1,
                        0,0,0,0,0,0);
#endif /* Performance_Debug */

#ifdef __FC_Layer_Loose_IOs
                pCThread->IOsTotalCompleted += 1;
#endif /*  __FC_Layer_Loose_IOs  */

                pCThread->FuncPtrs.FCP_Completion(hpRoot,tempCMWord1);
                break;

            case  CM_Unknown_CM_Type_Frame_Manager:
/*
                fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "hpRoot(%p) Frame_Manager %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        tempCMType,
                        pGenericCM->Unused_DWord_1,
                        0,0,0,0,0,0);
*/
                CFuncFMCompletion(hpRoot);
                break;

            case  CM_Unknown_CM_Type_Inbound:
                fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "hpRoot(%p) Inbound %08X  %08X %08X %08X HC %3x RI %3x",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        tempCMType,
                        pGenericCM->Unused_DWord_1,
                        pGenericCM->Unused_DWord_2,
                        pGenericCM->Unused_DWord_3,
                        pCThread->HostCopy_IMQConsIndex,
                        pCThread->FuncPtrs.GetIMQProdIndex(hpRoot),
                        0,0);

                CFuncInBoundCompletion(hpRoot,pGenericCM->Unused_DWord_1,pGenericCM->Unused_DWord_2,pGenericCM->Unused_DWord_3);

                break;

            case  CM_Unknown_CM_Type_Outbound:

                fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "hpRoot(%p) Outbound %08X  %08X %08X %08X HC %3x RI %3x",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        tempCMType,
                        pGenericCM->Unused_DWord_1,
                        pGenericCM->Unused_DWord_2,
                        pGenericCM->Unused_DWord_3,
                        pCThread->HostCopy_IMQConsIndex,
                        pCThread->FuncPtrs.GetIMQProdIndex(hpRoot),
                        0,0);

                CFuncOutBoundCompletion(hpRoot,
                        pGenericCM->Unused_DWord_2,
                        pGenericCM->Unused_DWord_3);

                /* Add SF Error code here */
                break;

            case  CM_Unknown_CM_Type_Error_Idle:

                fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "hpRoot(%p) Error_Idle %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        tempCMType,
                        pGenericCM->Unused_DWord_1,
                        0,0,0,0,0,0);

                CFuncErrorIdle(hpRoot);

                break;

            case  CM_Unknown_CM_Type_ERQ_Frozen:

                fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) ERQ_Frozen: %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        tempCMType,
                        pGenericCM->Unused_DWord_1,
                        0,0,0,0,0,0);

                CFuncErrorERQFrozen(hpRoot);

                break;

            case  CM_Unknown_CM_Type_FCP_Assists_Frozen:

                fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) FCP_Assists_Frozen %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        tempCMType,
                        pGenericCM->Unused_DWord_1,
                        0,0,0,0,0,0);

                CFuncErrorFCP_Frozen(hpRoot);

                break;

            case  CM_Unknown_CM_Type_Class_2_Frame_Header:

                fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "Class_2_Frame_Header %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        tempCMType,
                        pGenericCM->Unused_DWord_1,
                        0,0,0,0,0,0);
                break;

            case  CM_Unknown_CM_Type_Class_2_Sequence_Received:
                fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "Class_2_Sequence_Received %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        tempCMType,
                        pGenericCM->Unused_DWord_1,
                        0,0,0,0,0,0);
                break;

            default:    fiLogDebugString(hpRoot,
                            CStateLogConsoleLevel,
                            "Unknown IMQ Completion Type %08X %08X %08X %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            tempCMType,
                            pGenericCM->Unused_DWord_1,
                            pGenericCM->Unused_DWord_2,
                            pGenericCM->Unused_DWord_3,
                            pGenericCM->Unused_DWord_4,
                            0,0,0);
                        fiLogDebugString(hpRoot,
                            CStateLogConsoleLevel,
                            "IMQ Empty ? %X  Prod %X Cons %X ELM %X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            0 /* IMQ_EMPTY(pCThread->FuncPtrs.GetIMQProdIndex(hpRoot), pCThread->HostCopy_IMQConsIndex ,num_IMQel ) */,
                            pCThread->FuncPtrs.GetIMQProdIndex(hpRoot),
                            pCThread->HostCopy_IMQConsIndex ,
                            num_IMQel,
                            0,0,0,0);
                        /* Leave it alone since it is not reinitialized
                            pCThread->HostCopy_IMQConsIndex = pCThread->FuncPtrs.GetIMQProdIndex(hpRoot);
                        */
                        /*Prod index has a value  ? set consumer equal to producer ?*/
            }
            ROLL(pCThread->HostCopy_IMQConsIndex,num_IMQel);
        }
    osChipIOLoWriteBit32(hpRoot, ChipIOLo_IMQ_Consumer_Index, pCThread->HostCopy_IMQConsIndex);
    pCThread->ProcessingIMQ = agFALSE;

#ifdef ENABLE_INTERRUPTS_IN_IMQ
    if( ! (pCThread->thread_hdr.currentState == CStateLIPEventStorm         ||
            pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm   ))
    {
        CFuncEnable_Interrupts(hpRoot,ChipIOUp_INTEN_INT);
    }
#endif /* ENABLE_INTERRUPTS_IN_IMQ */
#endif /* __MemMap_Force_Off_Card__ was not defined */
    return agTRUE;

}

/*+
  Function: CFuncOnCardProcessIMQ
   Purpose: Proccess inbound message queue for inCardRam located message queue.
            Accessed via CThread->FuncPtrs.Proccess_IMQ
 Called By: CFuncInterruptPoll
            CFuncInteruptDelay
            CFuncLoopDownPoll
            CFuncFreezeQueuesPoll
            CFuncAll_clear
            CFuncTakeOffline
            CFuncWaitForFCP
            CActionInitFM
            CActionVerify_AL_PA
            CActionFreeSFthread
            CActionSuccess
            CActionLoopFail
            CActionReInitFM
            CActionInitializeFailed
            CActionFindDeviceUseAllALPAs
            DevActionDoPlogi
            DevActionDoPrli
            DevActionPrliDone
            DevActionLogout
            DevActionDeviceResetSoft
            DevActionDeviceResetHard
            fcDelayedInterruptHandler
            fcInitializeChannel
            fcResetDevice
            fcStartIO
            fcTimerTick
            SFActionDoPlogi
            SFActionDoPrli
     Calls: FuncPtrs.GetIMQProdIndex
            osCardRamReadBit32
            FuncPtrs.FCP_Completion
            CFuncFMCompletion
            CFuncOutBoundCompletion
            CFuncErrorIdle
            CFuncErrorFCP_Frozen
            osChipIOLoWriteBit
-*/
agBOOLEAN CFuncOnCardProcessIMQ(
                agRoot_t *hpRoot
                )
{
#ifndef __MemMap_Force_Off_Card__
    CThread_t  * pCThread = CThread_ptr(hpRoot);

    os_bit32 tempIMQProdIndex;
    os_bit32 tempCMType;
    os_bit32 tempCMWord1;

    os_bit32 num_IMQel;

    os_bit32 GenericCM_offset;

    if (pCThread->ProcessingIMQ == agTRUE)
    {
        return agFALSE;
    }
    pCThread->ProcessingIMQ = agTRUE;

    tempIMQProdIndex= pCThread->FuncPtrs.GetIMQProdIndex(hpRoot);

    if (pCThread->HostCopy_IMQConsIndex == tempIMQProdIndex)
    {
#ifndef Performance_Debug
        fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "pCThread->HostCopy_IMQConsIndex == tempIMQProdIndex CDBCnt %x",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCThread->CDBpollingCount,
                        0,0,0,0,0,0,0);
#endif /* Performance_Debug */
        pCThread->ProcessingIMQ = agFALSE;
        return agFALSE;
    }

    /*
    ** an INT (IMQ entry received) interrupt occured. Interrupt cleared by
    ** updating the IMQ consumer index register.
    */

    /*
    ** while there are IMQ completion messages to process
    */

    num_IMQel = pCThread->Calculation.MemoryLayout.IMQ.elements;

    while (pCThread->HostCopy_IMQConsIndex != pCThread->FuncPtrs.GetIMQProdIndex(hpRoot))
    {
        /* Big_Endian_Code */
        AFTERIO(hpRoot);
        GenericCM_offset = pCThread->Calculation.MemoryLayout.IMQ.addr.CardRam.cardRamOffset;
        GenericCM_offset += (pCThread->HostCopy_IMQConsIndex * sizeof(CM_Unknown_t));
        tempCMType  = osCardRamReadBit32(hpRoot,GenericCM_offset ) & CM_Unknown_CM_Type_MASK;

       /*
       ** get the completion message type
       */

        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "tempCMType %08X IMQ Consumer %X Temp IMQ %X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    tempCMType,
                    pCThread->HostCopy_IMQConsIndex,
                    pCThread->FuncPtrs.GetIMQProdIndex(hpRoot),0,0,0,0,0);


        switch (tempCMType) {

            case  CM_Unknown_CM_Type_Inbound_FCP_Exchange:
                tempCMWord1 = osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_1));
#ifndef Performance_Debug
                fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "hpRoot(%p) Inbound_FCP_Exchange %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        tempCMType,
                        tempCMWord1,
                        0,0,0,0,0,0);
#endif /* Performance_Debug */
                pCThread->FuncPtrs.FCP_Completion(hpRoot,tempCMWord1);
                break;
            case  CM_Unknown_CM_Type_Frame_Manager:
/*
                fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "hpRoot(%p) Frame_Manager %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        tempCMType,
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_1)),
                        0,0,0,0,0,0);
*/
                CFuncFMCompletion(hpRoot);
                break;

            case  CM_Unknown_CM_Type_Inbound:
                fiLogDebugString(hpRoot,
                        CSTATE_NOISE(hpRoot,CStateNormal),
                        "hpRoot(%p) Inbound %08X  %08X %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        tempCMType,
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_1)),
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_2)),
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_3)),
                        0,0,0,0);

                CFuncInBoundCompletion(hpRoot,
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_1)),
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_2)),
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_3)));

                break;
            case  CM_Unknown_CM_Type_Outbound:
                fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "hpRoot(%p) Outbound %08X   %08X %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        tempCMType,
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_1)),
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_2)),
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_3)),
                        0,0,0,0);

                CFuncOutBoundCompletion(hpRoot,
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_2)),
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_3)) );

                /* Add SF Error code here */

                break;
            case  CM_Unknown_CM_Type_Error_Idle:

                fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "hpRoot(%p) Error_Idle %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        tempCMType,
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_1)),
                        0,0,0,0,0,0);

                CFuncErrorIdle(hpRoot);

                break;

            case  CM_Unknown_CM_Type_ERQ_Frozen:

                  fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) ERQ_Frozen: %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        tempCMType,
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_1)),
                        0,0,0,0,0,0);

                CFuncErrorERQFrozen(hpRoot);

                break;
            case  CM_Unknown_CM_Type_FCP_Assists_Frozen:

                fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) FCP_Assists_Frozen %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        tempCMType,
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_1)),
                        0,0,0,0,0,0);

                CFuncErrorFCP_Frozen(hpRoot);

                break;
            case  CM_Unknown_CM_Type_Class_2_Frame_Header:

                fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "Class_2_Frame_Header CM type  %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        tempCMType,
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_1)),
                        0,0,0,0,0,0);
                break;
            case  CM_Unknown_CM_Type_Class_2_Sequence_Received:
                fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "Class_2_Sequence_Received CM type  %08X Dword_1 %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        tempCMType,
                        osCardRamReadBit32(hpRoot,
                            GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_1)),
                        0,0,0,0,0,0);

                break;
            default:
                fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "Unknown  CM type  %08X Dword_1 %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        tempCMType,
                        osCardRamReadBit32(hpRoot,
                           GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_1)),
                        0,0,0,0,0,0);

            }
            ROLL(pCThread->HostCopy_IMQConsIndex,num_IMQel);
        }
    osChipIOLoWriteBit32(hpRoot, ChipIOLo_IMQ_Consumer_Index, pCThread->HostCopy_IMQConsIndex);
    pCThread->ProcessingIMQ = agFALSE;

#ifdef ENABLE_INTERRUPTS_IN_IMQ
    if( ! (pCThread->thread_hdr.currentState == CStateLIPEventStorm         ||
            pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm   ))
    {
        CFuncEnable_Interrupts(hpRoot,ChipIOUp_INTEN_INT);
    }
#endif /* ENABLE_INTERRUPTS_IN_IMQ */

#endif /* __MemMap_Force_Off_Card__ was not defined */
    return agTRUE;
}

/*+
  Function: CFuncProcessNportFMCompletion
   Purpose: Handles Frame manager completion messages when chip is using port state machine.
            That is when InitAsNport is true.  
            If Link reset is required it is done in this routine (LF_1 of LF_2).

 Called By: CFuncFMCompletion.
     Calls: osChipIOUpReadBit32
            osChipIOUpWriteBit32
            CEventGoToInitializeFailed
            CEventAsyncLoopEventDetected
-*/
agBOOLEAN  CFuncProcessNportFMCompletion(agRoot_t * hpRoot, os_bit32 fmStatus)
{
    CThread_t * pCThread    = CThread_ptr(hpRoot);
    agBOOLEAN   Credit_Error= agFALSE;

    os_bit32    FMIntStatus = fmStatus & 0x00FFFF00;


    if (!((fmStatus & ChipIOUp_Frame_Manager_Status_LSM_MASK) == ChipMem_Frame_Manager_Status_LSM_Old_Port))
    {

        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) LSM is not Old Port, maybe Loop - In IMQ",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    0,0,0,0,0,0,0,0);
        return (agFALSE);

    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_CE)
    {
        Credit_Error = agTRUE;
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Credit Error (BB) FM cfg %08X FMIntStatus %08X FM Status %08X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    osChipIOUpReadBit32( hpRoot,ChipIOUp_Frame_Manager_Configuration ),
                    FMIntStatus,
                    fmStatus,
                    0,0,0,0,0);
    }


    if(((fmStatus & ChipIOUp_Frame_Manager_Status_PSM_MASK) ==
                                 ChipIOUp_Frame_Manager_Status_PSM_ACTIVE ))
    {
        /* The port state machine is going to be checked or has
           already been checked in the FM_DelayDone function. So, ignore
           this FM message */

 
        /* Apparently the BB_Credit is Zeroed ( a bug in tachlite), so need
         * to rewrite the BB Credit register.
         */

        /* BB Credit of 1 for NPORT */
        /* WAS          osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control, 0x00010000); 
        */

        if( osChipIOUpReadBit32( hpRoot,ChipIOUp_Frame_Manager_Configuration ) & pCThread->AquiredCredit_Shifted && (! Credit_Error))
        {
            osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, fmStatus);
            return (agTRUE);
        }
        else
        {
            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p)  PSM Active - In IMQ FMcfg %08X fmStatus %08X Credit %d",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        osChipIOUpReadBit32( hpRoot,ChipIOUp_Frame_Manager_Configuration ),
                        fmStatus,
                        Credit_Error,
                        0,0,0,0,0);

            osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration,
                              ChipIOUp_Frame_Manager_Configuration_NPI |
                             ChipIOUp_Frame_Manager_Configuration_ENP |
                              /* BB Credit of 1 for NPORT */
                              pCThread->AquiredCredit_Shifted);

            osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control, ChipIOUp_Frame_Manager_Control_CMD_Link_Reset); 

            osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, fmStatus);
                      

        return (agTRUE);

        }
    }

    fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "hpRoot(%p) LSM is IN Old Port, Nport Maybe...fmStatus %08X fmcfg %08X",
                (char *)agNULL,(char *)agNULL,
                hpRoot,agNULL,
                fmStatus,
                osChipIOUpReadBit32( hpRoot,ChipIOUp_Frame_Manager_Configuration ),
                0,0,0,0,0,0);

/* WAS     if (((fmStatus & fmStatus & ChipIOUp_Frame_Manager_Status_PSM_MASK) ==
                                (ChipIOUp_Frame_Manager_Status_PSM_LF1 | ChipIOUp_Frame_Manager_Status_PSM_LF2)))
*/
    if ( ( 
        ( ( fmStatus & ChipIOUp_Frame_Manager_Status_PSM_MASK) == ChipIOUp_Frame_Manager_Status_PSM_LF1 )
         || ( fmStatus & ChipIOUp_Frame_Manager_Status_PSM_MASK) == ChipIOUp_Frame_Manager_Status_PSM_LF2 ))

        {
        /* Clear the LF bit in the FM Control Register
         * and reread the FM Status register to check if the
         * Nport has come back up.
         */
        /* The port state machine is going to be checked or has
         * already been checked in the FM_DelayDone function. So, ignore
         * this FM message
         */

        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control, 
                                ChipIOUp_Frame_Manager_Control_CMD_Clear_LF );

        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p)  LF1 or LF2 Recvd while in OLD Port fmStatus:%08X fmcfg %08X CState %d Credit_Error %d",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    fmStatus,
                    osChipIOUpReadBit32( hpRoot,ChipIOUp_Frame_Manager_Configuration ),
                    pCThread->thread_hdr.currentState,
                    Credit_Error,0,0,0,0);

        if(( osChipIOUpReadBit32( hpRoot,ChipIOUp_Frame_Manager_Configuration ) & \
                pCThread->AquiredCredit_Shifted ) && (! Credit_Error))
        {
            osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control, ChipIOUp_Frame_Manager_Control_CMD_Link_Reset); 

            osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, fmStatus);
            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "  LF1 or LF2 Update credit fmStatus:%08X fmcfg %08X CState %d",
                        (char *)agNULL,(char *)agNULL,
                        agNULL,agNULL,
                        fmStatus,
                        osChipIOUpReadBit32( hpRoot,ChipIOUp_Frame_Manager_Configuration ),
                        pCThread->thread_hdr.currentState,
                        0,0,0,0,0);

        }


        /*WAS  pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded; */
        if( CThread_ptr(hpRoot)->thread_hdr.currentState   != CStateInitFM  )
        {
            if( fmStatus & ChipIOUp_Frame_Manager_Status_OS)
            {
                fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "Sending Event CEventGoToInitializeFailed fmStatus:%08X fmcfg %08X CState %d",
                            (char *)agNULL,(char *)agNULL,
                            agNULL,agNULL,
                            fmStatus,
                            osChipIOUpReadBit32( hpRoot,ChipIOUp_Frame_Manager_Configuration ),
                            pCThread->thread_hdr.currentState,
                            0,0,0,0,0);
                pCThread->Loop_Reset_Event_to_Send = CEventDoInitalize;
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventGoToInitializeFailed);
            }
            else
            {
               fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) NOT OS  LF1 or LF2 Recvd fmStatus:%08X fmcfg %08X CState %d",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            fmStatus,
                            osChipIOUpReadBit32( hpRoot,ChipIOUp_Frame_Manager_Configuration ),
                            pCThread->thread_hdr.currentState,
                            0,0,0,0,0);

                osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control, 
                                        ChipIOUp_Frame_Manager_Control_CMD_Clear_LF );

                osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, fmStatus);
                pCThread->Loop_Reset_Event_to_Send = CEventDoInitalize;
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventAsyncLoopEventDetected);
            }
        }
        else
        {
                osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control, 
                                        ChipIOUp_Frame_Manager_Control_CMD_Clear_LF );

                osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, fmStatus);
        }

        return (agTRUE);

    }

    /* Take care of the NOS/OLS and the link failure in the NPORT case.
     *
     */
    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_OLS)
    {


        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) NPort OLS/NOS received FMcfg %08X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    osChipIOUpReadBit32( hpRoot,ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0,0,0,0,0);

        /* was pCThread->Loop_Reset_Event_to_Send = CEventLoopNeedsReinit;
        */
         osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration,
                              ChipIOUp_Frame_Manager_Configuration_NPI |
                             ChipIOUp_Frame_Manager_Configuration_ENP |
                              /* BB Credit of 1 for NPORT */
                              pCThread->AquiredCredit_Shifted);

        if(pCThread->ChanInfo.NOSCountLower + 1 < pCThread->ChanInfo.NOSCountLower )
        {
            pCThread->ChanInfo.NOSCountUpper ++;
        }
        pCThread->ChanInfo.NOSCountLower += 1;


        pCThread->Loop_Reset_Event_to_Send = CEventLoopNeedsReinit;
        /* pCThread->Loop_Reset_Event_to_Send = CEventDoInitalize;
        */
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                     "hpRoot(%p) OLS/NOS Reinit as Nport Loop_Reset_Event_to_Send %d FMcfg %08X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    pCThread->Loop_Reset_Event_to_Send,
                    osChipIOUpReadBit32( hpRoot,ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0,0,0,0);


        /* if inimq and in reset needed don't clear nos/los */

        if( pCThread->ProcessingIMQ )
        {        

            if( pCThread->thread_hdr.currentState   == CStateResetNeeded )
            {
                FMIntStatus &= ~ChipIOUp_Frame_Manager_Status_OLS;
            }
        }

        if (((fmStatus & ChipIOUp_Frame_Manager_Status_PSM_MASK) & (ChipIOUp_Frame_Manager_Status_PSM_LF1 | ChipIOUp_Frame_Manager_Status_PSM_LF2)))
        {
            fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) LF detected %08X FMcfg %08X",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            fmStatus,
                            osChipIOUpReadBit32( hpRoot,ChipIOUp_Frame_Manager_Configuration ),
                            0,0,0,0,0,0);

      
            osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control, ChipIOUp_Frame_Manager_Control_CMD_Clear_LF );
        }

        /* WAS osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, FMIntStatus);*/
        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status,0xffffffff );

        /* Take the Cthread to ResetIfNeeded State waiting for the Reinit during the
         * the timer tick.
         */

/*WAS         if( pCThread->thread_hdr.currentState == CStateInitFM                   ||
            pCThread->thread_hdr.currentState == CStateInitFM_DelayDone         ||
            pCThread->thread_hdr.currentState == CStateDoFlogi                     )
WAS */
        if( pCThread->thread_hdr.currentState == CStateInitFM_DelayDone         ||
            pCThread->thread_hdr.currentState == CStateDoFlogi                     )
        {

        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                     "hpRoot(%p)Sending CEventAsyncLoopEventDetected LRES %d FMStatus %08X CState %d",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    pCThread->Loop_Reset_Event_to_Send,
                    FMIntStatus,
                    pCThread->thread_hdr.currentState,0,0,0,0,0);

            fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventAsyncLoopEventDetected);
        }

        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status,0xffffffff );

        return (agTRUE);
    }


    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_LF)
    {

        if( pCThread->Link_Failures_In_tick < FC_MAX_LINK_FAILURES_ALLOWED )
        {

            if(!(FMIntStatus & ChipIOUp_Frame_Manager_Status_LPF))
            {
                /* This shouldn't be the mechanism to tell us that an NPORT
                 * is connected but currently this is what Tachlite
                 * sometimes does - instead of setting NOS/OLS bit.
                 * They should set both NOS/OLS bit and Link Failure
                 * bit when we are NPort and we had initialized as
                 * LPORT. We also check to see if LIPf was recieved for yet another
                 * indication that we are connected to loop.
                 */

                pCThread->Loop_Reset_Event_to_Send = CEventLoopNeedsReinit;

                fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Sending Reinit event from Link Failure to initialize as NPORT () CState %d",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            pCThread->Loop_Reset_Event_to_Send,
                            pCThread->thread_hdr.currentState,0,0,0,0,0,0);


                osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, FMIntStatus);

                /* Take the Cthread to ResetIfNeeded State waiting for the Reinit during the
                 * the timer tick.
                 */
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventAsyncLoopEventDetected);
                return (agTRUE);
            }

           fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) Link Failure with LipF set ....",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        pCThread->Loop_Reset_Event_to_Send,
                        0,0,0,0,0,0,0);

           return (agFALSE); /* In Case of LF with a LipF recvd set */
        }
        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status,0xffffffff );
        return (agTRUE);
    }

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status,0xffffffff );
    return (agTRUE);
}

/*+
  Function: CFuncFMCompletion
   Purpose: Handles Frame manager completion messages when chip is using loop state machine.
            That is when InitAsNport is false. Channel ALPA  change is detected in this routine. 
            LinkDownTime is set in this routine - used to determine if timedout IO's may have failed.       
 Called By: CFuncInterruptPoll
            CFuncLoopDownPoll
            CFuncFreezeQueuesPoll
            CFuncTakeOffline

     Calls: osChipIOUpReadBit32
            CFuncProcessNportFMCompletion
            osStallThread
            CEventInitalizeFailure
            CFuncShowActiveCDBThreads
            CFuncMatchALPAtoThread
            DevThreadFree
            CEventLoopNeedsReinit
            CEventResetIfNeeded
            CFuncQuietShowWhereDevThreadsAre
            CEventDoInitalize
            CEventAsyncLoopEventDetected
-*/
void CFuncFMCompletion(agRoot_t * hpRoot)
{
    os_bit32    fmStatus;
    agBOOLEAN   ResetLOOP           = agFALSE;
    agBOOLEAN   LOOP_Cameback       = agFALSE;
    agBOOLEAN   Credit_Error        = agFALSE;

    os_bit32    FMIntStatus;
    os_bit32    LoopStatus;
    os_bit32    LoopStateMachine;

    os_bit32        ClearInt        = 0;
    os_bit32        Link_UP_AL_PA   = 0;
    FC_Port_ID_t    Port_ID;
    CThread_t      *pCThread        = CThread_ptr(hpRoot);
/*
    DevThread_t       *pDevThread;
*/
    SFThread_t    * pSFThread;
    fiList_t      * pList;
    fiList_t      * pDevList;

    pCThread->From_IMQ_Frame_Manager_Status = fmStatus = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );


#ifdef NPORT_STUFF
    if (pCThread->InitAsNport)
    {
        CFuncProcessNportFMCompletion(hpRoot, fmStatus);

        return;
    }
#endif /* NPORT_STUFF */

    /* From here on, We are probably in a Loop topology */
    if(fmStatus & ~(ChipIOUp_Frame_Manager_Status_BA | ChipIOUp_Frame_Manager_Status_LP | ChipIOUp_Frame_Manager_Status_OS) )
    {
        if( (fmStatus & FRAMEMGR_LINK_DOWN) != FRAMEMGR_LINK_DOWN)
        {
            if(!( pCThread->thread_hdr.currentState == CStateInitFM   ) )
            {
                if(pCThread->Last_IMQ_Frame_Manager_Status_Message != fmStatus)
                {
                    pCThread->Last_IMQ_Frame_Manager_Status_Message = fmStatus;
                    fiLogString(hpRoot,
                                  "%s FM %08X St %d",
                                  "CFuncFMCompletion",(char *)agNULL,
                                  (void *)agNULL,(void *)agNULL,
                                  pCThread->From_IMQ_Frame_Manager_Status,
                                  pCThread->thread_hdr.currentState,
                                  0,0,0,0,0,0);
                }
            }
        }
    }

    LoopStatus  = fmStatus & 0xFF000000;

    FMIntStatus  = fmStatus & 0x00FFFF00;

    LoopStateMachine = fmStatus & ChipIOUp_Frame_Manager_Status_LSM_MASK;

    if(LoopStateMachine < 80 )
    {

        if(FMIntStatus & ChipIOUp_Frame_Manager_Status_LUP || FMIntStatus & ChipIOUp_Frame_Manager_Status_LDN)
        {
            Link_UP_AL_PA = ((osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA )  &
                                              ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK) >>
                                               ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_SHIFT);

            if(  Link_UP_AL_PA !=  pCThread->ChanInfo.CurrentAddress.AL_PA)
            {
                fiLogDebugString(hpRoot,
                                CFuncLogConsoleERROR,
                                "G F * Self ALPA %x  FM cfg %08X",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                pCThread->ChanInfo.CurrentAddress.AL_PA,
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                                0,0,0,0,0,0);
            }
        }
    }

    Link_UP_AL_PA = ((osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA )  &
                                      ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK) >>
                                       ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_SHIFT);

    if(  Link_UP_AL_PA !=  0 &&  Link_UP_AL_PA !=  pCThread->ChanInfo.CurrentAddress.AL_PA)
    {
        if( pCThread->ChanInfo.CurrentAddress.AL_PA != 0xff && Link_UP_AL_PA != 0xff )
        {
            fiLogString(hpRoot,
                            "ALPA Change MY ALPA %X New ALPA %X FM cfg %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCThread->ChanInfo.CurrentAddress.AL_PA,
                            Link_UP_AL_PA,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                            0,0,0,0,0);
        }
    }
    /* Take care of the NOS/OLS. We shouldn't be getting this if we are not
     * in an NPort mode but the fabric may have not yet transitioned....
     */

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_OLS)
    {
        if(pCThread->ChanInfo.NOSCountLower + 1 < pCThread->ChanInfo.NOSCountLower )
        {
            pCThread->ChanInfo.NOSCountUpper ++;
        }
        pCThread->ChanInfo.NOSCountLower += 1;

        ResetLOOP=agTRUE;
        ClearInt |= ChipIOUp_Frame_Manager_Status_OLS;
        osStallThread(hpRoot, 2000);

    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_LF)
    {

        if( pCThread->Link_Failures_In_tick < FC_MAX_LINK_FAILURES_ALLOWED )
        {
            ClearInt |= ChipIOUp_Frame_Manager_Status_LF ;
/*
            if( ! pCThread->Link_Failures_In_tick )
            {
                fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Link Failure LSM %X FMIntStatus %X",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,FMIntStatus,0,0,0,0,0,0);
            }

            pCThread->Link_Failures_In_tick++;
*/
        }
        else
        {

            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ) )
            {
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventInitalizeFailure);
            }

            ResetLOOP=agFALSE;

        }

    }


    if(LoopStatus & ChipIOUp_Frame_Manager_Status_LP )
    {

        ClearInt |= ChipIOUp_Frame_Manager_Status_LP;

        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "hpRoot(%p) Loop Good LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,
                    0,0,0,0,0,0,0);
    }

    if(LoopStatus & ChipIOUp_Frame_Manager_Status_TP )
    {
        CFuncShowActiveCDBThreads( hpRoot,ShowERQ);
        pCThread->LinkDownTime = pCThread->TimeBase;
        ResetLOOP=agTRUE;
        ClearInt |=  ChipIOUp_Frame_Manager_Status_TP ;
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Transmit PE LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,0,0,0,0,0,0,0);
/*
        if( pCThread->Transmit_PE_In_tick < FC_MAX_TRANSMIT_PE_ALLOWED )
        {
            ResetLOOP=agTRUE;
            ClearInt |=  ChipIOUp_Frame_Manager_Status_TP ;
            if( ! pCThread->Transmit_PE_In_tick )
            {
                fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Transmit PE LSM %X",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,0,0,0,0,0,0,0);
            }

            pCThread->Transmit_PE_In_tick++;
        }
        else
        {
            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ) )
            {
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventElasticStoreEventStorm);
            }

            ResetLOOP=agFALSE;

        }
*/
    }

    if(LoopStatus & ChipIOUp_Frame_Manager_Status_NP )
    {
        ClearInt |= ChipIOUp_Frame_Manager_Status_NP;
        ResetLOOP=agTRUE;
        osStallThread(hpRoot, 200 );
        if(pCThread->Last_IMQ_Frame_Manager_Status_Message != fmStatus)
        {
            fiLogString(hpRoot,
                            "NP MY ALPA %X New ALPA %X FM cfg %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCThread->ChanInfo.CurrentAddress.AL_PA,
                            Link_UP_AL_PA,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                            0,0,0,0,0);

        }
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p)fmStatus %08X Non Particapating LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    fmStatus,
                    LoopStateMachine,
                    0,0,0,0,0,0);
    }

    if(LoopStatus & ChipIOUp_Frame_Manager_Status_BYP)
    {
        ResetLOOP=agTRUE;
        ClearInt |= ChipIOUp_Frame_Manager_Status_BYP;
        fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Node Bypassed LSM %X",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,0,0,0,0,0,0,0);
/*
        if( pCThread->Node_By_Passed_In_tick < FC_MAX_NODE_BY_PASSED_ALLOWED )
        {
            ClearInt |= ChipIOUp_Frame_Manager_Status_BYP;
            ResetLOOP=agTRUE;
            if( ! pCThread->Node_By_Passed_In_tick )
            {
                fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Node Bypassed LSM %X",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,0,0,0,0,0,0,0);
            }

            pCThread->Node_By_Passed_In_tick++;
        }
        else
        {

            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ) )
            {
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventElasticStoreEventStorm);
            }

            ResetLOOP=agFALSE;

        }
*/
    }

    if(LoopStatus & ChipIOUp_Frame_Manager_Status_FLT)
    {
        CFuncShowActiveCDBThreads( hpRoot,ShowERQ);
        pCThread->LinkDownTime = pCThread->TimeBase;
        ClearInt |=  ChipIOUp_Frame_Manager_Status_FLT;
        ResetLOOP=agTRUE;
/*
        if( pCThread->Lost_sync_In_tick < FC_MAX_LINK_FAULTS_ALLOWED )
        {
            ClearInt |=  ChipIOUp_Frame_Manager_Status_FLT;
            ResetLOOP=agTRUE;
            if( ! pCThread->Link_Fault_In_tick )
            {
                fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Link Fault LSM %X",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,0,0,0,0,0,0,0);
            }

            pCThread->Link_Fault_In_tick++;
        }
        else
        {

            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ) )
            {
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventElasticStoreEventStorm);
            }

            ResetLOOP=agFALSE;

        }
*/
    }
    if(LoopStatus & ChipIOUp_Frame_Manager_Status_OS )
    {
        CFuncShowActiveCDBThreads( hpRoot,ShowERQ);
        pCThread->LinkDownTime = pCThread->TimeBase;
        ClearInt |=  ChipIOUp_Frame_Manager_Status_OS;
        ResetLOOP=agTRUE;

        if( (fmStatus & FRAMEMGR_LINK_DOWN) != FRAMEMGR_LINK_DOWN)
        {
            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) Loop Out of Sync LSM %X",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        LoopStateMachine,0,0,0,0,0,0,0);
        }

/*
        if( pCThread->Lost_sync_In_tick < FC_MAX_LOSE_OF_SYNC_ALLOWED )
        {
            ClearInt |=  ChipIOUp_Frame_Manager_Status_OS;
            ResetLOOP=agTRUE;
            if( ! pCThread->Lost_sync_In_tick )
            {
                fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Loop Out of Sync LSM %X",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,0,0,0,0,0,0,0);
            }

            pCThread->Lost_sync_In_tick++;
        }
        else
        {

            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ) )
            {
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventElasticStoreEventStorm);
            }
            ResetLOOP=agFALSE;

        }
*/

    }

    if(LoopStatus & ChipIOUp_Frame_Manager_Status_LS )
    {
        CFuncShowActiveCDBThreads( hpRoot,ShowERQ);
        pCThread->LinkDownTime = pCThread->TimeBase;
        ClearInt |=  ChipIOUp_Frame_Manager_Status_LS;
        ResetLOOP=agTRUE;
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Loop Lost Signal LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,0,0,0,0,0,0,0);
/*
        if( pCThread->Lost_Signal_In_tick < FC_MAX_LOST_SIGNALS_ALLOWED )
        {
            ClearInt |=  ChipIOUp_Frame_Manager_Status_LS;
            ResetLOOP=agTRUE;
            if( ! pCThread->Lost_Signal_In_tick )
            {
                fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Loop Lost Signal LSM %X",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,0,0,0,0,0,0,0);
            }

            pCThread->Lost_Signal_In_tick++;
        }
        else
        {

            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ) )
            {
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventElasticStoreEventStorm);
            }
            ResetLOOP=agFALSE;

        }
*/

    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_LPE)
    {
        /* ResetLOOP=agTRUE; */
        /* Ignore LPE */
        ClearInt |=ChipIOUp_Frame_Manager_Status_LPE;
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) LPE received LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,0,0,0,0,0,0,0);
    }


    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_LPB)
    {
        ClearInt |= ChipIOUp_Frame_Manager_Status_LPB;
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Loop ByPass Primitive received LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,0,0,0,0,0,0,0);
    }


    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_LST)
    {
        CFuncShowActiveCDBThreads( hpRoot,ShowERQ);
        pCThread->LinkDownTime = pCThread->TimeBase;
        ClearInt |= ChipIOUp_Frame_Manager_Status_LST;
        ResetLOOP = agTRUE;
        fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) Loop State Timeout received LSM %X Cstate %d FMIntStatus %X TL Status %08X",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        LoopStateMachine,
                        pCThread->thread_hdr.currentState,
                        FMIntStatus,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        0,0,0,0);
/*
        pCThread->Loop_State_TimeOut_In_tick++;
        if( pCThread->Loop_State_TimeOut_In_tick < FC_MAX_LST_ALLOWED )
        {
            if( ! pCThread->Loop_State_TimeOut_In_tick )
            {
                fiLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "hpRoot(%p) Loop State Timeout received LSM %X Cstate %d FMIntStatus %X TL Status %08X",
                                (char *)agNULL,(char *)agNULL,
                                hpRoot,agNULL,
                                LoopStateMachine,
                                pCThread->thread_hdr.currentState,
                                FMIntStatus,
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                                0,0,0,0);
            }

        }
        else
        {
*/
            /* ResetLOOP = agTRUE; */
/*
            fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "Loop State Timeout Cstate %d FMIntStatus %X TL Status %08X LST count %d",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCThread->thread_hdr.currentState,
                            FMIntStatus,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                            pCThread->Loop_State_TimeOut_In_tick,
                            0,0,0,0);

            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ))
            {
                if( pCThread->thread_hdr.currentState == CStateNormal  )
                {
                    pCThread->Loop_Reset_Event_to_Send = CEventInitalizeFailure;
                    fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventLoopEventDetected);
                }
                else
                {
                    if( pCThread->thread_hdr.currentState == CStateInitializeFailed  )
                    {
                        ResetLOOP=agFALSE;
                    }
                    else
                    {
                        fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventElasticStoreEventStorm);
                        return;
                    }
                }
            }
            else
            {
                ResetLOOP=agFALSE;
            }
        }
*/
    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_LPF)
    {
        CFuncShowActiveCDBThreads( hpRoot,ShowERQ);
        pCThread->LinkDownTime = pCThread->TimeBase;
        ResetLOOP=agTRUE;
        ClearInt |= ChipIOUp_Frame_Manager_Status_LPF;

        fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) LIPf received LSM %X Rec ALPA Reg %08X Cstate %d FMIntStatus %X",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        LoopStateMachine,
                        osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                        pCThread->thread_hdr.currentState,
                        FMIntStatus,0,0,0,0);

/*
        if( pCThread->Lip_F7_In_tick < FC_MAX_LIP_F7_ALLOWED )
        {
            if( ! pCThread->Lip_F7_In_tick )
            {
                fiLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "hpRoot(%p) LIPf received LSM %X Rec ALPA Reg %08X Cstate %d FMIntStatus %X",
                                (char *)agNULL,(char *)agNULL,
                                hpRoot,agNULL,
                                LoopStateMachine,
                                osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                                pCThread->thread_hdr.currentState,
                                FMIntStatus,0,0,0,0);
            }

            if( 0xF7 ==  (osChipIOUpReadBit32(hpRoot,
                                            ChipIOUp_Frame_Manager_Received_ALPA) &
                                  ChipIOUp_Frame_Manager_Received_ALPA_LIPf_ALPA_MASK ))
            {
                ClearInt |= ChipIOUp_Frame_Manager_Status_LPF;
            }

            ClearInt |= ChipIOUp_Frame_Manager_Status_LPF;

            pCThread->Lip_F7_In_tick++;
        }
        else
        {

            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateInitFM_DelayDone        ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ) )
            {
                    fiLogDebugString(hpRoot,
                                    CFuncCheckCstateErrorLevel,
                                    "%s sends %s FM_Status %08X FM_IMQ_Status %08X ",
                                    "CFuncFMCompletion","CEventLIPEventStorm",
                                    (void *)agNULL,(void *)agNULL,
                                    FMIntStatus,
                                    pCThread->From_IMQ_Frame_Manager_Status,
                                    0,0,0,0,0,0);

                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventLIPEventStorm);
            }

            ResetLOOP=agFALSE;

         }
*/


    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_BA)
    {
        ClearInt |= ChipIOUp_Frame_Manager_Status_BA;

        if(pCThread->thread_hdr.currentState == CStateNormal)
        {
            FC_Port_ID_t  BadAL_PA;
            BadAL_PA.Struct_Form.AL_PA = 0;
            BadAL_PA.Struct_Form.Area = 0;
            BadAL_PA.Struct_Form.Domain = 0;
            BadAL_PA.Struct_Form.reserved = 0;

            BadAL_PA.Struct_Form.AL_PA = (os_bit8)((osChipIOUpReadBit32(hpRoot,
                                ChipIOUp_Frame_Manager_Received_ALPA)  >>
                                ChipIOUp_Frame_Manager_Received_ALPA_Bad_ALPA_SHIFT) &
                                0x000000FF);

            if(BadAL_PA.Bit32_Form )
            {
                DevThread_t   * pDevThread = agNULL;
                pDevThread = CFuncMatchALPAtoThread(hpRoot, BadAL_PA );
                if( pDevThread != agNULL )
                {
                    fiLogString(hpRoot,
                                    "%s %x",
                                    "Status_BA",(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    BadAL_PA.Bit32_Form,
                                    0,0,0,0,0,0,0);
                    fiSendEvent(&(pDevThread->thread_hdr),DevEvent_Device_Gone);
                }
                ResetLOOP=agTRUE;
            }
        }
    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_PRX)
    {
        ClearInt |= ChipIOUp_Frame_Manager_Status_PRX;

        pCThread->PrimitiveReceived = agTRUE;

        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Primitive received LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,0,0,0,0,0,0,0);
    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_PTX)
    {
        ClearInt |= ChipIOUp_Frame_Manager_Status_PTX;
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Primitive Sent LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,0,0,0,0,0,0,0);
    }


    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_LG)
    {
        pCThread->FabricLoginRequired = agTRUE;
        ClearInt |= ChipIOUp_Frame_Manager_Status_LG ;
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) FLOGi Required LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,0,0,0,0,0,0,0);

        if (!(FMIntStatus & ~ChipIOUp_Frame_Manager_Status_LG))
        {
            /* We are not acting on this since it is not a reliable mechanism
             * of detecting a fabric yet.
             */
           osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status,ClearInt);
           return;
        }
    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_CE)
    {
        Credit_Error = agTRUE;
        ResetLOOP=agTRUE;
        ClearInt |= ChipIOUp_Frame_Manager_Status_CE;
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Credit Error (BB) LSM %X FMIntStatus %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,FMIntStatus,0,0,0,0,0,0);
    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_EW)
    {
        CFuncShowActiveCDBThreads( hpRoot,ShowERQ);
        pCThread->LinkDownTime = pCThread->TimeBase;
        if( pCThread->Elastic_Store_ERROR_Count < FC_MAX_ELASTIC_STORE_ERRORS_ALLOWED )
        {
            ClearInt |= ChipIOUp_Frame_Manager_Status_EW;
            pCThread->Elastic_Store_ERROR_Count++;
        }
        else
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Elastic Store Error LSM %X FMIntStatus %X Cstate %d Count %d",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,FMIntStatus,
                    pCThread->thread_hdr.currentState,
                    pCThread->Elastic_Store_ERROR_Count,0,0,0,0);


                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventInitalizeFailure);
    
                ResetLOOP=agTRUE;

                pCThread->Elastic_Store_ERROR_Count=0;

        }

    }

    if( FMIntStatus & ChipIOUp_Frame_Manager_Status_LDN )
    {
        pCThread->LOOP_DOWN = agTRUE;
        pCThread->ChanInfo.LinkUp = agFALSE;
        pCThread->IDLE_RECEIVED = agFALSE;

        fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "F HostCopy ERQ_PROD %x ERQ Cons %x ",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osChipIOLoReadBit32(hpRoot, ChipIOLo_ERQ_Producer_Index),
                        osChipIOLoReadBit32(hpRoot, ChipIOLo_ERQ_Consumer_Index),
                        0,0,0,0,0,0);
        CFuncShowActiveCDBThreads( hpRoot,ShowERQ);
        pCThread->LinkDownTime = pCThread->TimeBase;

        osChipIOLoWriteBit32(hpRoot,ChipIOLo_ERQ_Consumer_Index , 
                        osChipIOLoReadBit32(hpRoot,ChipIOLo_ERQ_Producer_Index ));

        ResetLOOP = agTRUE; /* If this is not here after a lip we will not be logged in */

        ClearInt |= ChipIOUp_Frame_Manager_Status_LDN;

        fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) Link Down LSM %X Cstate %d CDBCnt %x",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        LoopStateMachine,
                        pCThread->thread_hdr.currentState,
                        pCThread->CDBpollingCount,
                        0,0,0,0,0);


        fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "TimeBase %8X %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCThread->TimeBase.Hi,
                        pCThread->TimeBase.Lo,
                        0,0,0,0,0,0);

    }

    if( FMIntStatus & ChipIOUp_Frame_Manager_Status_LUP )
    {
        LOOP_Cameback = agTRUE;
        ResetLOOP = agTRUE; /* If this is not here after a lip we will not be logged in */
        ClearInt |= ChipIOUp_Frame_Manager_Status_LUP;
        fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Link Up LSM %X Cstate %d LD %x IR %x CDBCnt %x",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,
                            pCThread->thread_hdr.currentState,
                            pCThread->LOOP_DOWN,
                            pCThread->IDLE_RECEIVED,
                            pCThread->CDBpollingCount,
                            0,0,0);
        if ( pCThread->FM_pollingCount > 0 )  pCThread->FM_pollingCount --;
        pCThread->LOOP_DOWN = agFALSE;
        pCThread->ChanInfo.LinkUp = agTRUE;
/************************************/
        pCThread->LoopMapLIRP_Received = agFALSE;
        pCThread->DeviceDiscoveryMethod = DDiscoveryScanAllALPAs;


        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Loop Good LSM %X ALPA %x Self ALPA %x CFG %08X Rec AL_PA %08X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,
                    Link_UP_AL_PA,
                    pCThread->ChanInfo.CurrentAddress.AL_PA,
                    (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ) & 0xFFFFFF) |
                        ( Link_UP_AL_PA <<  ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA ),
                    0,0,0);

        if( (Link_UP_AL_PA !=  pCThread->ChanInfo.CurrentAddress.AL_PA) || (pCThread->DeviceSelf == agNULL))
        {

            if(pCThread->DeviceSelf == agNULL)
            {
                fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s hpRoot(%p) LSM %X ALPA %x Self ALPA %x CFG %08X",
                            "DeviceSelf == agNULL",(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,
                            Link_UP_AL_PA,
                            pCThread->ChanInfo.CurrentAddress.AL_PA,
                            (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ) & 0xFFFFFF) |
                                ( Link_UP_AL_PA <<  ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ),
                            0,0,0,0);
            }
            else
            {
                pCThread->ALPA_Changed_OnLinkEvent = agTRUE;
                fiLogDebugString(hpRoot,
                                FCMainLogErrorLevel,
                                "hpRoot(%p) Self %p LSM %X ALPA %x Self ALPA %x CFG %08X",
                                (char *)agNULL,(char *)agNULL,
                                hpRoot,pCThread->DeviceSelf,
                                LoopStateMachine,
                                Link_UP_AL_PA,
                                pCThread->ChanInfo.CurrentAddress.AL_PA,
                                (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ) & 0xFFFFFF) |
                                    ( Link_UP_AL_PA <<  ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ),
                                0,0,0,0);
            }

            if(Link_UP_AL_PA  != 0 && Link_UP_AL_PA != 0xff)
            {
                osChipIOUpWriteBit32( hpRoot, ChipIOUp_My_ID, Link_UP_AL_PA);

                osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration,
                        (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ) & 0xFFFFFF) |
                        ( Link_UP_AL_PA <<  ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ));

                fiLogDebugString(hpRoot,
                                CFuncLogConsoleERROR,
                                "AF * Self ALPA %x  FM cfg %08X",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                pCThread->ChanInfo.CurrentAddress.AL_PA,
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                                0,0,0,0,0,0);
                if(pCThread->DeviceSelf != agNULL)
                {

                    fiLogDebugString(hpRoot,
                                    CFuncLogConsoleERROR,
                                    "pCThread->DeviceSelf != agNULL Empty ? %x On list ? %x",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    fiListNotEmpty(&pCThread->DevSelf_NameServer_DevLink ),
                                    fiListElementOnList(&(pCThread->DevSelf_NameServer_DevLink), &(pCThread->DeviceSelf->DevLink)), 
                                    0,0,0,0,0,0);

                    if(fiListNotEmpty(&pCThread->DevSelf_NameServer_DevLink ))
                    {
                        fiListDequeueFromHead(&pDevList, &pCThread->DevSelf_NameServer_DevLink );
                    }
                    fiListDequeueThis(&(pCThread->DeviceSelf->DevLink));
                    DevThreadFree(hpRoot,pCThread->DeviceSelf);
                    pCThread->DeviceSelf = agNULL;
                    CFuncQuietShowWhereDevThreadsAre( hpRoot);

                }

                Port_ID.Struct_Form.reserved = 0;
                Port_ID.Struct_Form.Domain = 0;
                Port_ID.Struct_Form.Area   = 0;
                Port_ID.Struct_Form.AL_PA  = (os_bit8)Link_UP_AL_PA;

                pCThread->DeviceSelf = DevThreadAlloc( hpRoot,Port_ID );

				if (pCThread->DeviceSelf)
				{
					pCThread->DeviceSelf->DevSlot = DevThreadFindSlot(hpRoot,
                                                            Port_ID.Struct_Form.Domain,
                                                            Port_ID.Struct_Form.Area,
                                                            Port_ID.Struct_Form.AL_PA,
                                                           (FC_Port_Name_t *)(&pCThread->ChanInfo.PortWWN));

					fiListDequeueThis(&(pCThread->DeviceSelf->DevLink));
					fiListEnqueueAtTail(&(pCThread->DeviceSelf->DevLink),&pCThread->DevSelf_NameServer_DevLink);
				}
				else
				{
					fiLogString(hpRoot,
									"%s LUP pCThread->DeviceSelf = 0",
									"CFuncFMCompletion",(char *)agNULL,
									(void *)agNULL,(void *)agNULL,
									0,0,0,0,0,0,0,0);

				}

                pCThread->ChanInfo.CurrentAddress.AL_PA = (os_bit8)Link_UP_AL_PA;

                ResetLOOP=agTRUE;

                fiLogDebugString(hpRoot,
                                CFuncLogConsoleERROR,
                                " F * Self ALPA %x  FM cfg %08X",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                pCThread->ChanInfo.CurrentAddress.AL_PA,
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                                0,0,0,0,0,0);

            }
        }


/*****************************************/
        if(pCThread->IDLE_RECEIVED)
        {

            if( CFunc_Always_Enable_Queues(hpRoot ))
            {
                fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) FM Queues Frozen after enable !",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        0,0,0,0,0,0,0,0);

            }
            else
            {

                pCThread->IDLE_RECEIVED = agFALSE;
                if(fiListNotEmpty(&pCThread->QueueFrozenWaitingSFLink))
                {
                    fiListDequeueFromHeadFast(&pList,
                                        &pCThread->QueueFrozenWaitingSFLink );
                    pSFThread = hpObjectBase(SFThread_t,
                                              SFLink,pList );
                    fiLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    "hpRoot(%p) Starting frozen SFThread %p Event %d",
                                    (char *)agNULL,(char *)agNULL,
                                    hpRoot,pSFThread,
                                    pSFThread->QueuedEvent,
                                    0,0,0,0,0,0,0);

                    if(pSFThread->QueuedEvent )
                    {
                        fiSendEvent(&pSFThread->thread_hdr,(event_t)pSFThread->QueuedEvent);
                    }
                }
            }
        }
    }

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status,ClearInt);

    if( pCThread->thread_hdr.currentState == CStateInitFM                   ||
        pCThread->thread_hdr.currentState == CStateInitFM_DelayDone         ||
        pCThread->thread_hdr.currentState == CStateResetNeeded              ||
        pCThread->thread_hdr.currentState == CStateLIPEventStorm            ||
        pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm   ||
        pCThread->thread_hdr.currentState == CStateInitializeFailed         ||
        pCThread->thread_hdr.currentState == CStateReInitFM                 ||
        pCThread->thread_hdr.currentState == CStateSendPrimitive                )
    {

        if( ! ( pCThread->thread_hdr.currentState == CStateInitializeFailed &&
                LOOP_Cameback == agTRUE                                           ))
        {
                ResetLOOP = agFALSE;
        }


    }

    if( pCThread->thread_hdr.currentState == CStateInitializeFailed )
    {

        if( (fmStatus & FRAMEMGR_LINK_DOWN) == FRAMEMGR_LINK_DOWN)
        {
                ResetLOOP = agFALSE;
        }

    }

    if (ResetLOOP)
    {
        fmStatus = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );

        fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "About to ResetLOOP FM Status %08X TL Status %08X CState %d",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        fmStatus,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        pCThread->thread_hdr.currentState,
                        0,0,0,0,0);


        if(pCThread->LoopPreviousSuccess)
        {
            if (Credit_Error)
            {
                pCThread->Loop_Reset_Event_to_Send = CEventLoopNeedsReinit;
            }
            else
            {
                pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
            }

        }
        else
        {
            if( CFuncAll_clear( hpRoot ) )
            {
                pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;

                fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) ResetLOOP LSM %X Cstate %d sends %s (%d)",
                        "CEventLoopNeedsReinit",(char *)agNULL,
                        hpRoot,agNULL,
                        LoopStateMachine,
                        pCThread->thread_hdr.currentState,
                        CEventAsyncLoopEventDetected,0,0,0,0,0);

            }
            else
            {
                if( pCThread->thread_hdr.currentState == CStateLoopFailedReInit )
                {

                    pCThread->Loop_Reset_Event_to_Send = CEventDoInitalize;
                }
                else
                {
                    /* WAS pCThread->Loop_Reset_Event_to_Send = CEventLoopNeedsReinit; */
                    pCThread->Loop_Reset_Event_to_Send = CEventLoopEventDetected;

                    fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) ResetLOOP LSM %X Cstate %d sends %s (%d)",
                            "CEventLoopNeedsReinit",(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,
                            pCThread->thread_hdr.currentState,
                            CEventLoopNeedsReinit,0,0,0,0,0);
                }
            }
        }

        fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) ResetLOOP LSM %X Cstate %d sends (%d) Event to send %d",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        LoopStateMachine,
                        pCThread->thread_hdr.currentState,
                        CEventAsyncLoopEventDetected,
                        pCThread->Loop_Reset_Event_to_Send,
                        0,0,0,0);

        fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventAsyncLoopEventDetected);

    }
}

/*+
  Function: CFuncSEST_offCard_FCPCompletion
   Purpose: Handles  inDMAmemory FCP completions
     
 Called By: FuncPtrs.FCP_Completion

     Calls: osChipIOUpReadBit32
            CFuncProcessNportFMCompletion
            osStallThread
            CEventInitalizeFailure
            CFuncShowActiveCDBThreads
            CFuncMatchALPAtoThread
            DevThreadFree
            CEventLoopNeedsReinit
            CEventResetIfNeeded
            CFuncQuietShowWhereDevThreadsAre
            CEventDoInitalize
            CEventAsyncLoopEventDetected
-*/
void CFuncSEST_offCard_FCPCompletion(agRoot_t * hpRoot,os_bit32 status)
{
    CDBThread_t             * pCDBThread;
    fiMemMapMemoryDescriptor_t * CDBThread_MemoryDescriptor = &(CThread_ptr(hpRoot)->Calculation.MemoryLayout.CDBThread);
    X_ID_t                    X_ID;
    USE_t                   * SEST;
    FCHS_t                  * pFCHS;
    event_t                   event_to_send                 = CDBEventIoSuccess;
    FC_FCP_RSP_Payload_t    * fcprsp;
    os_bit32                  error;

    agIORequestBody_t       * hpRequestBody;


#ifdef __FC_Layer_Loose_IOs
    if(pCThread->IOsTotalCompleted  > 100000 )
    {
        pCThread->IOsFailedCompeted += 1;
        if(pCThread->IOsFailedCompeted  > 45 )
        {
            pCThread->IOsFailedCompeted = 0;
            pCThread->IOsTotalCompleted = 0;
        }
        else
        {
            return;
        }

    }

#endif /*  __FC_Layer_Loose_IOs  */

    X_ID =(X_ID_t)( status & CM_Inbound_FCP_Exchange_SEST_Index_MASK);

    error = status & ~CM_Inbound_FCP_Exchange_SEST_Index_MASK;


    pCDBThread = (CDBThread_t *)((os_bit8 *)(CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                 + (X_ID * CDBThread_MemoryDescriptor->elementSize));

    if (!(pCDBThread->ExchActive))
    {
        fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Found a cbdthread that is not active... %p State %d Status %08X",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread,agNULL,
                    pCDBThread->thread_hdr.currentState,
                    status,
                    0,0,0,0,0,0);

/*
         fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                    (os_bit32)pCDBThread->CDB_CMND_Class,
                    (os_bit32)pCDBThread->CDB_CMND_Type,
                    (os_bit32)pCDBThread->CDB_CMND_State,
                    (os_bit32)pCDBThread->CDB_CMND_Status,
                    0,0,0);
*/
        return;
    }


/*
    if (pCDBThread->FC_Tape_Active)
    {
        fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Found a FC_Tape_Active cbdthread ... %p State %d Status %08X",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread,agNULL,
                    pCDBThread->thread_hdr.currentState,
                    status,
                    0,0,0,0,0,0);

         fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                    (os_bit32)pCDBThread->CDB_CMND_Class,
                    (os_bit32)pCDBThread->CDB_CMND_Type,
                    (os_bit32)pCDBThread->CDB_CMND_State,
                    (os_bit32)pCDBThread->CDB_CMND_Status,
                    0,0,0);
    }
*/
    hpRequestBody =(agIORequestBody_t *)&pCDBThread->CDBRequest;

    SEST = (USE_t *)pCDBThread->SEST_Ptr;

#ifndef Performance_Debug
    if(SEST)
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Sest DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    SEST->Bits,
                    SEST->Unused_DWord_1,
                    SEST->Unused_DWord_2,
                    SEST->Unused_DWord_3,
                    SEST->LOC,
                    SEST->Unused_DWord_5,
                    SEST->Unused_DWord_6,
                    SEST->Unused_DWord_7);

        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Sest DWORD 8 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    SEST->Unused_DWord_8,
                    SEST->Unused_DWord_9,
                    SEST->First_SG.U32_Len,
                    SEST->First_SG.L32,
                    SEST->Second_SG.U32_Len,
                    SEST->Second_SG.L32,
                    SEST->Third_SG.U32_Len,
                    SEST->Third_SG.L32);
    }
    else
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Sest Pointer BAD",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
    }
#endif /* Performance_Debug */

    if(error & CM_Inbound_FCP_Exchange_LKF)
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "InboundLink Failure %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    error,0,0,0,0,0,0,0);
        event_to_send = CDBEventFailNoRSP;
    }

    if(error & CM_Inbound_FCP_Exchange_CNT)
    {

        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Count Error %08X Byte Count %08X Exp %08X %s",
                    pCDBThread->ReadWrite ? "Write" : "Read",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    error,
                    SEST->Unused_DWord_7,
                    SEST->Unused_DWord_9,
                    0,0,0,0,0);
        event_to_send = CDBEventIoOver;
    }

    if(error & CM_Inbound_FCP_Exchange_CNT && error & CM_Inbound_FCP_Exchange_OVF)
    {

        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "OVF Count Error %08X Byte Count %08X Exp %08X %s",
                    pCDBThread->ReadWrite ? "Write" : "Read",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    error,
                    SEST->Unused_DWord_7,
                    SEST->Unused_DWord_9,
                    pCDBThread->ReadWrite,
                    0,0,0,0);
        event_to_send = CDBEventIoFailed;
    }

    if( error & CM_Inbound_FCP_Exchange_RPC && error & CM_Inbound_FCP_Exchange_OVF )
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Overflow %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    error,0,0,0,0,0,0,0);
        event_to_send = CDBEventIoFailed;

        }

    if(error & CM_Inbound_FCP_Exchange_RPC)
    {

#ifndef Performance_Debug
        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Response Phase Complete %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    error,0,0,0,0,0,0,0);
#endif /* Performance_Debug */

        /* If Response detect is enabled and we have an XL controller, send a success
           right away, else wait for the SFQ to deliver the response buffer.
         */
#ifdef __TACHYON_XL_NO_RSP
        if (pCThread->ResponseDetectEnabled) && 
            (!pCDBThread->WaitForFcpRsp) )
        {
            if (!(error & CM_Inbound_FCP_Exchange_FEE))
            {

#ifndef Performance_Debug
                fiLogDebugString(hpRoot,
                            CStateLogConsoleLevel,
                            StateLogTraceLevel,
                            "Response Detect Enabled, No Errors %08X",
                            (char *)NULL,(char *)NULL,
                            error,0,0,0,0,0,0,0);
#endif /* Performance_Debug */
                fiSendEvent(&pCDBThread->thread_hdr, CDBEventIoSuccess);
                return;
            }
            else
            {
                fiLogDebugString(hpRoot,
                            CStateLogConsoleLevel,
                            StateLogTraceLevel,
                            "Response Detect Enabled, Error Exists Wait for message %08X",
                            (char *)NULL,(char *)NULL,
                            error,0,0,0,0,0,0,0);
                /*FEE set, wait for an unassisted frame to give the response buffer */
                pCDBThread->WaitForFcpRsp = agTRUE;
                return;
            }

        }

        else
#endif /* __TACHYON_XL_NO_RSP */
        {
            event_to_send = CFuncProcessFcpRsp(hpRoot, pCDBThread, event_to_send);
            fcprsp = (FC_FCP_RSP_Payload_t  * )(((os_bit8 *)pCDBThread->FCP_RESP_Ptr) + sizeof(FCHS_t));
        } /* Non XL or XL without RDE Enabled */
    }

    if(event_to_send == CDBEventIoOver )
    {

        if( pCDBThread->DataLength == 0 )
        {   
            /* Complete Datalength Zero commands with good status ??? Why does chip report CNT error ? */
            fiLogDebugString(hpRoot,
                                FCMainLogErrorLevel,
                                "X_ID %X BC %X Ex %X L %X %s stat %X",
                                pCDBThread->ReadWrite == CDBThread_Read ? "Write" :"Read" ,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                pCDBThread->X_ID,
                                pCDBThread->SEST_Ptr->IRE.Byte_Count,
                                pCDBThread->SEST_Ptr->IRE.Exp_Byte_Cnt,
                                pCDBThread->DataLength,
                                status,
                                0,0,0);
            fiSendEvent(&pCDBThread->thread_hdr, CDBEventIoSuccess);
            return;
        }


#ifdef FULL_FC_TAPE_DBG

        if (pCDBThread->ReadWrite == CDBThread_Read)
        {
            fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "CDBEventIoOver X_ID %X BC %08X E %08X L %08X %s stat %X",
                        "Read",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCDBThread->X_ID,
                        pCDBThread->SEST_Ptr->IRE.Byte_Count,
                        pCDBThread->SEST_Ptr->IRE.Exp_Byte_Cnt,
                        pCDBThread->DataLength,
                        status,
                        0,0,0);
        }
        else
        {
            fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "Over BC %08X Exp %08X Len %08X %s stat %X",
                        "Write",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCDBThread->SEST_Ptr->IWE.Data_Len,
                        pCDBThread->SEST_Ptr->IWE.Exp_Byte_Cnt,
                        pCDBThread->DataLength,
                        status,
                        0,0,0,0);

        }

        fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "Before ValidityStatusIndicators %x scsi stat %x sense len %x resid %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)fcprsp->FCP_STATUS.ValidityStatusIndicators,
                    (os_bit32)fcprsp->FCP_STATUS.SCSI_status_byte,
                    (os_bit32)fcprsp->FCP_SNS_LEN,
                    (os_bit32)fcprsp->FCP_RESID,
                    0,0,0,0);

#endif /* FULL_FC_TAPE_DBG */

        /* Copy and compare errors under NT */
        /* We got underrun completion but response buffer empty fill in underrun  */
        fcprsp = (FC_FCP_RSP_Payload_t  * )(((os_bit8 *)pCDBThread->FCP_RESP_Ptr) + sizeof(FCHS_t));
        if( fcprsp->FCP_STATUS.ValidityStatusIndicators == 0 )
        {
            if( fcprsp->FCP_STATUS.SCSI_status_byte == 0 )
            {
                if( fcprsp->FCP_RESID == 0   )
                {
                    pFCHS = ( FCHS_t * )pCDBThread->FCP_RESP_Ptr;
                    if (pCDBThread->ReadWrite == CDBThread_Read)
                    {

                        fiLogDebugString(hpRoot,
                                    FCMainLogErrorLevel,
                                    "Before ValidityStatusIndicators %x scsi stat %x sense len %x resid %08X",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    (os_bit32)fcprsp->FCP_STATUS.ValidityStatusIndicators,
                                    (os_bit32)fcprsp->FCP_STATUS.SCSI_status_byte,
                                    (os_bit32)fcprsp->FCP_SNS_LEN,
                                    (os_bit32)fcprsp->FCP_RESID,
                                    0,0,0,0);

                        /* Check for negative value*/
                        if(  pCDBThread->SEST_Ptr->IRE.Exp_Byte_Cnt > pCDBThread->SEST_Ptr->IRE.Byte_Count )
                        {
                            fcprsp->FCP_RESID = hpSwapBit32((pCDBThread->SEST_Ptr->IRE.Exp_Byte_Cnt- pCDBThread->SEST_Ptr->IRE.Byte_Count ));
                            fcprsp->FCP_STATUS.ValidityStatusIndicators = FC_FCP_RSP_FCP_STATUS_ValidityStatusIndicators_FCP_RESID_UNDER;
                        }
                        else
                        {
                            /* */
                            fcprsp->FCP_RESID = hpSwapBit32((pCDBThread->SEST_Ptr->IRE.Exp_Byte_Cnt));
                            fcprsp->FCP_STATUS.ValidityStatusIndicators = FC_FCP_RSP_FCP_STATUS_ValidityStatusIndicators_FCP_RESID_OVER;
                        }


                        fiLogDebugString(hpRoot,
                                    FCMainLogErrorLevel,
                                    "pFCHS %08X %08X %08X %08X %08X %08X %08X",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    pFCHS->CS_CTL__S_ID,
                                    pFCHS->MBZ1,
                                    pFCHS->OX_ID__RX_ID,
                                    pFCHS->R_CTL__D_ID,
                                    pFCHS->RO,
                                    pFCHS->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp,
                                    pFCHS->TYPE__F_CTL,
                                    0 );
                    }
                    else /* CDBThread_Write */
                    {
                        /* Check for negative value*/
                        if( pCDBThread->DataLength > pCDBThread->SEST_Ptr->IWE.Exp_Byte_Cnt  )
                        {
                            fcprsp->FCP_RESID = hpSwapBit32((pCDBThread->DataLength - pCDBThread->SEST_Ptr->IWE.Exp_Byte_Cnt ));
                            fcprsp->FCP_STATUS.ValidityStatusIndicators = FC_FCP_RSP_FCP_STATUS_ValidityStatusIndicators_FCP_RESID_UNDER;
                        }
                        else
                        {
                            /* */
                            fcprsp->FCP_RESID = hpSwapBit32((pCDBThread->DataLength));
                            fcprsp->FCP_STATUS.ValidityStatusIndicators = FC_FCP_RSP_FCP_STATUS_ValidityStatusIndicators_FCP_RESID_OVER;
                        }
                        fiLogDebugString(hpRoot,
                                    FCMainLogErrorLevel,
                                    "status %08X Byte Count %08X Exp %08X %s DataLength %X",
                                    "Write",(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    status,
                                    pCDBThread->SEST_Ptr->IWE.Data_Len,
                                    pCDBThread->SEST_Ptr->IWE.Exp_Byte_Cnt,
                                    pCDBThread->DataLength,
                                    0,0,0,0);
                    } /* End CDBThread_Write */
                } /* fcprsp->FCP_RESID != 0 */
            }/*fcprsp->FCP_STATUS.SCSI_status_byte != 0 */

        
         fiLogDebugString(hpRoot,
                        CStateLogConsoleErrorOverRun,
                        "After valid %x scsi stat %x sense len %x resid %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        (os_bit32)fcprsp->FCP_STATUS.ValidityStatusIndicators,
                        (os_bit32)fcprsp->FCP_STATUS.SCSI_status_byte,
                        (os_bit32)fcprsp->FCP_SNS_LEN,
                        (os_bit32)fcprsp->FCP_RESID,
                        0,0,0,0);

        }

        if( fcprsp->FCP_STATUS.ValidityStatusIndicators == 0    &&
            fcprsp->FCP_RESID != 0                               )
        {
            fcprsp->FCP_STATUS.ValidityStatusIndicators =
                            FC_FCP_RSP_FCP_STATUS_ValidityStatusIndicators_FCP_RESID_UNDER;

             fiLogDebugString(hpRoot,
                            CStateLogConsoleErrorOverRun,
                            "After valid %x scsi stat %x sense len %x resid %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            (os_bit32)fcprsp->FCP_STATUS.ValidityStatusIndicators,
                            (os_bit32)fcprsp->FCP_STATUS.SCSI_status_byte,
                            (os_bit32)fcprsp->FCP_SNS_LEN,
                            (os_bit32)fcprsp->FCP_RESID,
                            0,0,0,0);

        }
    }

    if(event_to_send != CDBEventIoSuccess )
    {
        fcprsp = (FC_FCP_RSP_Payload_t  * )(((os_bit8 *)pCDBThread->FCP_RESP_Ptr) + sizeof(FCHS_t));
        fiLogDebugString(hpRoot,
                            CStateLogConsoleErrorOverRun,
                            "CDBEvent Error Event %x Byte Count %08X Exp %08X %s status %08X",
                            pCDBThread->ReadWrite ? "Write" : "Read",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            event_to_send,
                            SEST->Unused_DWord_7,
                            SEST->Unused_DWord_9,
                            status,
                            0,0,0,0);

         fiLogDebugString(hpRoot,
                            CStateLogConsoleErrorOverRun,
                            "Before valid %x scsi stat %x sense len %x resid %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            (os_bit32)fcprsp->FCP_STATUS.ValidityStatusIndicators,
                            (os_bit32)fcprsp->FCP_STATUS.SCSI_status_byte,
                            (os_bit32)fcprsp->FCP_SNS_LEN,
                            (os_bit32)fcprsp->FCP_RESID,
                            0,0,0,0);

    }

    fiSendEvent(&pCDBThread->thread_hdr, event_to_send);

}

void CFuncSEST_onCard_FCPCompletion(agRoot_t * hpRoot,os_bit32 status)
{
#ifndef __MemMap_Force_Off_Card__
    CDBThread_t                * pCDBThread;
    fiMemMapMemoryDescriptor_t * CDBThread_MemoryDescriptor = &(CThread_ptr(hpRoot)->Calculation.MemoryLayout.CDBThread);
    X_ID_t                       X_ID;
    event_t                      event_to_send              = CDBEventIoSuccess;
    os_bit32                     SEST_Offset;

    os_bit32                     error;

    X_ID =(X_ID_t)( status & CM_Inbound_FCP_Exchange_SEST_Index_MASK);

    error = status & ~CM_Inbound_FCP_Exchange_SEST_Index_MASK;

    pCDBThread = (CDBThread_t *)((os_bit8 *)(CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                 + (X_ID * CDBThread_MemoryDescriptor->elementSize));

    if (!(pCDBThread->ExchActive))
    {
        fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Found a cbdthread that is not active... %p State %d Status %08X",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread,agNULL,
                    pCDBThread->thread_hdr.currentState,
                    status,
                    0,0,0,0,0,0);
/*
         fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                    (os_bit32)pCDBThread->CDB_CMND_Class,
                    (os_bit32)pCDBThread->CDB_CMND_Type,
                    (os_bit32)pCDBThread->CDB_CMND_State,
                    (os_bit32)pCDBThread->CDB_CMND_Status,
                    0,0,0);
*/
        return;
    }
/*
    if (pCDBThread->FC_Tape_Active)
    {
        fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Found a FC_Tape_Active cbdthread ... %p X_ID %X State %d Status %08X",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread,agNULL,
                    X_ID,                    
                    pCDBThread->thread_hdr.currentState,
                    status,
                    0,0,0,0,0);

         fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                    (os_bit32)pCDBThread->CDB_CMND_Class,
                    (os_bit32)pCDBThread->CDB_CMND_Type,
                    (os_bit32)pCDBThread->CDB_CMND_State,
                    (os_bit32)pCDBThread->CDB_CMND_Status,
                    0,0,0);
    }
*/
    SEST_Offset = pCDBThread->SEST_Offset;

    fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "SEST_Offset %08X X_ID %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    SEST_Offset,
                    X_ID,
                    0,0,0,0,0,0);


    fiLogDebugString(hpRoot,
                    CStateLogConsoleShowSEST,
                    "Sest DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Bits))),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_1))),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_2))),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_3))),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,LOC))),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_5))),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_6))),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_7))));


    fiLogDebugString(hpRoot,
                    CStateLogConsoleShowSEST,
                    "Sest DWORD 8 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_8))),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_9))),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,First_SG))),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,First_SG))+4),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Second_SG))),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Second_SG))+4),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Third_SG))),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Third_SG))+4));


    if(error & CM_Inbound_FCP_Exchange_LKF)
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Inbound Link Failure %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    error,0,0,0,0,0,0,0);
        event_to_send = CDBEventFailNoRSP;
    }

    if(error & CM_Inbound_FCP_Exchange_CNT)
    {

        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Inbound Count Error %08X Byte Count %08X Exp %08X %s",
                    pCDBThread->ReadWrite ? "Write" : "Read",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    error,
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_7))),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_9))),
                    0,0,0,0,0);
        event_to_send = CDBEventIoOver;
    }

    if(error & CM_Inbound_FCP_Exchange_CNT && error & CM_Inbound_FCP_Exchange_OVF)
    {

        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Count Error %08X Byte Count %08X Exp %08X %s",
                    pCDBThread->ReadWrite ? "Write" : "Read",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    error,
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_7))),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_9))),
                    pCDBThread->ReadWrite,
                    0,0,0,0);
        event_to_send = CDBEventIoFailed;
    }

    if( error & CM_Inbound_FCP_Exchange_RPC && error & CM_Inbound_FCP_Exchange_OVF )
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Overflow %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    error,0,0,0,0,0,0,0);
        event_to_send = CDBEventIoFailed;

    }

    if(error & CM_Inbound_FCP_Exchange_RPC)
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Response Phase Complete %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    error,0,0,0,0,0,0,0);
    }

    fiSendEvent(&pCDBThread->thread_hdr, event_to_send);
#endif /* __MemMap_Force_Off_Card__ was not defined */

}


void CFuncInBoundCompletion(agRoot_t * hpRoot,os_bit32 SFQ_Index,os_bit32 Frame_Len, os_bit32 type)
{
    CThread_t       *   pCThread            = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *    SFQ_MemoryDescriptor = &(pCThread->Calculation.MemoryLayout.SFQ);

    os_bit32 SFQ_Num_entry;
    os_bit32 SFQ_Start_index;


    if(Frame_Len % 64) SFQ_Num_entry = (Frame_Len / 64) + 1;
    else SFQ_Num_entry = (Frame_Len / 64);

    SFQ_Start_index = SFQ_Index - SFQ_Num_entry;

    if (SFQ_Start_index > SFQ_MemoryDescriptor->elements)
                SFQ_Start_index += SFQ_MemoryDescriptor->elements;

    SFQ_Index &= CM_Inbound_SFQ_Prod_Index_MASK;
    fiLogDebugString(hpRoot,
                        DEVSTATE_NOISE(hpRoot,CStateNormal),
                        "InBoundCompletion SFQ_Index %08X,Frame_len %X, type %X  Queues %x LD %x IR %x",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        SFQ_Index,Frame_Len,
                        type,
                        CFunc_Queues_Frozen( hpRoot ),
                        pCThread->LOOP_DOWN,
                        pCThread->IDLE_RECEIVED,
                        0,0);


    if(type & CM_Inbound_LKF)
    {
        fiLogDebugString(hpRoot,
            CStateLogConsoleERROR,
            "Inbound Link Failure !",
            (char *)agNULL,(char *)agNULL,
            (void *)agNULL,(void *)agNULL,
            0,0,0,0,0,0,0,0);
    }

    type &= CM_Inbound_Type_MASK;
    switch(type)
    {
        /* DR ?? */
        case CM_Inbound_Type_Unassisted_FCP:
            fiLogDebugString(hpRoot,
                CStateLogConsoleHideInboundErrors,
                "CM_Inbound_Type_Unassisted_FCP ! SFQ_Index %x SFQ start %x TL %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                SFQ_Index,
                SFQ_Start_index,
                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                0,0,0,0,0);

/*
            fiLogString(hpRoot,
                          "%s",
                          "CM_Inbound_Type_Unassisted_FCP",(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0);
*/

            CFuncReadSFQ(hpRoot,Frame_Len, SFQ_Index);

            break;
        case CM_Inbound_Type_Bad_FCP:
            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "CM_Inbound_Type_Bad_FCP ! SFQ_Index %x SFQ start %x TL Status %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        SFQ_Index,
                        SFQ_Start_index,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        0,0,0,0,0);

/*
            fiLogString(hpRoot,
                          "%s Len %X",
                          "CM_Inbound_Type_Bad_FCP",(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          Frame_Len,0,0,0,0,0,0,0
                        );

*/
            CFuncReadSFQ(hpRoot,Frame_Len, SFQ_Index);
/*
            fiLogString(hpRoot,
                          "%s Len %X",
                          "CM_Inbound_Type_Bad_FCP",(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          Frame_Len,0,0,0,0,0,0,0
                        );
*/
            break;
        case CM_Inbound_Type_Unknown_Frame:
            fiLogDebugString(hpRoot,
                DEVSTATE_NOISE(hpRoot,CStateNormal),
                "CM_Inbound_Type_Unknown_Frame ! TL Status %08X CCnt %x SFCnt %x",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                pCThread->CDBpollingCount,
                pCThread->SFpollingCount,
                0,0,0,0,0);

/*
            fiLogString(hpRoot,
                          "%s SF Thread ?",
                          "CM_Inbound_Type_Unknown_Frame",(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );
*/
            CFuncReadSFQ(hpRoot,Frame_Len, SFQ_Index);

            break;

        default:
            fiLogDebugString(hpRoot,
                  CStateLogConsoleERROR,
                  "Unknown Type !",
                  (char *)agNULL,(char *)agNULL,
                  (void *)agNULL,(void *)agNULL,
                  0,0,0,0,0,0,0,0);

    }


    osChipIOLoWriteBit32(hpRoot, ChipIOLo_SFQ_Consumer_Index, SFQ_Index);

}

void  CFuncReadSFQ(agRoot_t * hpRoot, os_bit32 Frame_Len, os_bit32 SFQ_Index )
{

    SFThread_t                  * pSFThread             =( SFThread_t *) agNULL;
    CDBThread_t                 * pCDBThread            =( CDBThread_t *) agNULL;
    CThread_t                   * pCThread              = CThread_ptr(hpRoot);
    DevThread_t                 * pDevThread;

    fiMemMapMemoryDescriptor_t  *   SFQ_MemoryDescriptor = &(pCThread->Calculation.MemoryLayout.SFQ);
    os_bit32  fi_status;
    os_bit32 SFQ_Num_entry;
    os_bit32 SFQ_Start_index;
    os_bit32 ELS_Status;
    os_bit32 CT_Status;

    if(Frame_Len % 64) SFQ_Num_entry = (Frame_Len / 64) + 1;
    else SFQ_Num_entry = (Frame_Len / 64);

    SFQ_Start_index = SFQ_Index - SFQ_Num_entry;

    if (SFQ_Start_index > SFQ_MemoryDescriptor->elements)
                SFQ_Start_index += SFQ_MemoryDescriptor->elements;


    fi_status =  Find_SF_Thread( hpRoot, SFQ_Start_index, Frame_Len, &pSFThread );
    if( fi_status ==  0xBAD0BAD1)
    {
        return;
    }
    pCDBThread = ( CDBThread_t *)pSFThread;

    if(pSFThread != ( SFThread_t *)agNULL)
    {

        if( pSFThread->thread_hdr.threadType == threadType_SFThread)
        {

            fiLogDebugString(hpRoot,
                        CStateLogConsoleLevelLip,
                        "Find_SF_Thread Thread %p fi_status %x  SF_CMND_Class %x Type %x State %x",
                        (char *)agNULL,(char *)agNULL,
                        pSFThread,agNULL,
                        fi_status,
                        pSFThread->SF_CMND_Class,
                        pSFThread->SF_CMND_Type,
                        pSFThread->SF_CMND_State,
                        0,0,0,0);
#ifdef NAME_SERVICES
            /* Check for the CMD_Class CT. Find_SF_Thread does all the processing
             * and returns the SF Thread. This part of the code is just to send the
             * the appropriate events to the SF thread based on the results */

            if (pSFThread->SF_CMND_Class    == SFThread_SF_CMND_Class_CT)
            {
                CT_Status = pSFThread->SF_CMND_State;
                switch(pSFThread->SF_CMND_Type)

                {
                    case SFThread_SF_CMND_CT_Type_RFT_ID:

                           fiLogDebugString(hpRoot,
                                    CStateLogConsoleLevelLip -  2,
                                    "RFT_ID SF_CMND_State %x SFQ_Index %x fi_status %x",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    CT_Status,
                                    SFQ_Start_index,
                                    fi_status,
                                    0,0,0,0,0);

                            switch(fi_status)
                            {
                                case fiCT_Cmd_Status_ACC:
                                    fiSendEvent(&pSFThread->thread_hdr,SFEventRFT_IDAccept);
                                    break;
                                case fiCT_Cmd_Status_RJT:
                                    fiSendEvent(&pSFThread->thread_hdr,SFEventRFT_IDRej);
                                    break;
                                default:
                                    fiLogDebugString(hpRoot,
                                            CFuncLogConsoleERROR,
                                            "Unknown Status %x",
                                            (char *)agNULL,(char *)agNULL,
                                            (void *)agNULL,(void *)agNULL,
                                            fi_status,
                                            0,0,0,0,0,0,0);

                            }
                    break;

                    case  SFThread_SF_CMND_CT_Type_GID_FT:

                           fiLogDebugString(hpRoot,
                                    CStateLogConsoleLevelLip -  2,
                                    "GID_FT SF_CMND_State %x SFQ_Index %x fi_status %x",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    CT_Status,
                                    SFQ_Start_index,
                                    fi_status,
                                    0,0,0,0,0);

                            switch(fi_status)
                            {
                                case fiCT_Cmd_Status_ACC:
                                    if (!(pCThread->ExpectMoreNSFrames))
                                        fiSendEvent(&pSFThread->thread_hdr,SFEventGID_FTAccept);
                                    else
                                    {
                                        fiLogDebugString(hpRoot,
                                        CStateLogConsoleLevelLip -  2,
                                        "More Name Server database frames to follow !!!",
                                        (char *)agNULL,(char *)agNULL,
                                        (void *)agNULL,(void *)agNULL,
                                        0,0,0,0,0,0,0,0);
                                   }
                                    break;
                                case fiCT_Cmd_Status_RJT:
                                    fiSendEvent(&pSFThread->thread_hdr,SFEventGID_FTRej);
                                    break;
                                default:
                                    fiLogDebugString(hpRoot,
                                            CFuncLogConsoleERROR,
                                            "Unknown Status %x",
                                            (char *)agNULL,(char *)agNULL,
                                            (void *)agNULL,(void *)agNULL,
                                            fi_status,
                                            0,0,0,0,0,0,0);

                            }
                    break;

                    default:
                            fiLogDebugString(hpRoot,
                                        CFuncLogConsoleERROR,
                                        "Unknown Sent CT Command  ",
                                        (char *)agNULL, (char *)agNULL,
                                        (void *)agNULL,(void *)agNULL,
                                         0,0,0,0,0,0,0,0);
                }
            }
#endif  /* NAME_SERVICES */

            if(pSFThread->SF_CMND_Class == SFThread_SF_CMND_Class_LinkSvc)
            {
                ELS_Status = pSFThread->SF_CMND_State;
                switch(pSFThread->SF_CMND_Type)

                {
                    case SFThread_SF_CMND_LinkSvc_Type_PLOGI:
                           fiLogDebugString(hpRoot,
                                    CStateLogConsoleLevelLip,
                                    "FC_ELS_Type_PLOGI SF_CMND_State %x SFQ_Index %x fi_status %x",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    ELS_Status,
                                    SFQ_Start_index,
                                    fi_status,
                                    0,0,0,0,0);

                            switch(fi_status)
                            {
                                case fiLinkSvc_Cmd_Status_ACC:
                                    fiSendEvent(&pSFThread->thread_hdr,SFEventPlogiAccept);
                                    break;
                                case fiLinkSvc_Cmd_Status_RJT:
                                    fiSendEvent(&pSFThread->thread_hdr,SFEventPlogiRej);
                                    break;
                                case fiLinkSvc_Cmd_Status_PLOGI_From_Self:
                                    fiSendEvent(&pSFThread->thread_hdr,SFEventPlogiAccept);
                                    break;

                                default:
                                    fiLogDebugString(hpRoot,
                                            CFuncLogConsoleERROR,
                                            "Unknown Status %x",
                                            (char *)agNULL,(char *)agNULL,
                                            (void *)agNULL,(void *)agNULL,
                                            fi_status,
                                            0,0,0,0,0,0,0);

                           }
                           break;

                    case SFThread_SF_CMND_LinkSvc_Type_FLOGI:
                           fiLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    "FC_ELS_Type_FLOGI ELS_Status %x",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    ELS_Status ,0,0,0,0,0,0,0);
                            if( fi_status == fiLinkSvc_Cmd_Status_RJT )
                            fiSendEvent(&pSFThread->thread_hdr,SFEventFlogiRej);
                            else
                            fiSendEvent(&pSFThread->thread_hdr,SFEventFlogiAccept);
                            break;

                    case SFThread_SF_CMND_LinkSvc_Type_ABTS:
                           fiLogDebugString(hpRoot,
                                    CDBStateAbortPathLevel,
                                    "FC_ELS_Type_ABTS ELS_Status %x",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    ELS_Status ,0,0,0,0,0,0,0);
                            if( fi_status == fiLinkSvc_Cmd_Status_RJT )
                            fiSendEvent(&pSFThread->thread_hdr,SFEventAbortRej);
                            else
                            fiSendEvent(&pSFThread->thread_hdr,SFEventAbortAccept);
                            break;

                    case SFThread_SF_CMND_LinkSvc_Type_LOGO:
                           fiLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    "FC_ELS_Type_LOGO ELS_Status %x",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    ELS_Status ,0,0,0,0,0,0,0);
                            if( fi_status == fiLinkSvc_Cmd_Status_RJT )
                            fiSendEvent(&pSFThread->thread_hdr,SFEventLogoRej);
                            else
                            fiSendEvent(&pSFThread->thread_hdr,SFEventLogoAccept);
                            break;
                    case SFThread_SF_CMND_LinkSvc_Type_SRR:
                           fiLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    "FC_ELS_Type_SRR ELS_Status %x",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    ELS_Status ,0,0,0,0,0,0,0);

                            if( fi_status == fiLinkSvc_Cmd_Status_RJT )
                            fiSendEvent(&pSFThread->thread_hdr,SFEventSRRRej);
                            else
                            fiSendEvent(&pSFThread->thread_hdr,SFEventSRRAccept);
                            break;

                    case SFThread_SF_CMND_LinkSvc_Type_REC:
                           fiLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    "FC_ELS_Type_REC ELS_Status %x",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    ELS_Status ,0,0,0,0,0,0,0);

                            if( fi_status == fiLinkSvc_Cmd_Status_RJT )
                            fiSendEvent(&pSFThread->thread_hdr,SFEventRECRej);
                            else
                            fiSendEvent(&pSFThread->thread_hdr,SFEventRECAccept);
                            break;

                    case SFThread_SF_CMND_LinkSvc_Type_PRLI:
                           fiLogDebugString(hpRoot,
                                    CStateLogConsoleLevelLip,
                                    "FC_ELS_Type_PRLI ELS_Status %x SFQ_Index %x",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    ELS_Status ,SFQ_Start_index,0,0,0,0,0,0);
                            if( fi_status == fiLinkSvc_Cmd_Status_RJT )
                            fiSendEvent(&pSFThread->thread_hdr,SFEventPrliRej);
                            else
                            fiSendEvent(&pSFThread->thread_hdr,SFEventPrliAccept);
                            break;
                    case SFThread_SF_CMND_LinkSvc_Type_PRLO:
                           fiLogDebugString(hpRoot,
                                    CStateLogConsoleLevelLip -  2,
                                    "FC_ELS_Type_PRLO ELS_Status %x",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    ELS_Status ,0,0,0,0,0,0,0);
                            if( fi_status == fiLinkSvc_Cmd_Status_RJT )
                            fiSendEvent(&pSFThread->thread_hdr,SFEventPrloRej);
                            else
                            fiSendEvent(&pSFThread->thread_hdr,SFEventPrloAccept);
                            break;
                    case SFThread_SF_CMND_LinkSvc_Type_ADISC:
                           fiLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    "FC_ELS_Type_ADISC ELS_Status %x",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    ELS_Status ,0,0,0,0,0,0,0);
                            if( fi_status == fiLinkSvc_Cmd_Status_RJT )
                            fiSendEvent(&pSFThread->thread_hdr,SFEventAdiscRej);
                            else
                            fiSendEvent(&pSFThread->thread_hdr,SFEventAdiscAccept);
                            break;
                   case SFThread_SF_CMND_LinkSvc_Type_SCR:
                           fiLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    "FC_ELS_Type_SCR ELS_Status %x",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    ELS_Status ,0,0,0,0,0,0,0);
                            if( fi_status == fiLinkSvc_Cmd_Status_RJT )
                            fiSendEvent(&pSFThread->thread_hdr,SFEventSCRRej);
                            else
                            fiSendEvent(&pSFThread->thread_hdr,SFEventSCRAccept);
                            break;

#ifdef _DvrArch_1_30_
                   case SFThread_SF_CMND_LinkSvc_Type_FARP_REQ:
                           fiLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    "FC_ELS_Type_FARP_REQ ELS_Status %x",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    ELS_Status ,0,0,0,0,0,0,0);
                            if( fi_status == fiLinkSvc_Cmd_Status_ACC )
                                fiSendEvent(&pSFThread->thread_hdr,SFEventFarpReplied);
                            break;
#endif /* _DvrArch_1_30_ was defined */

                    default:
                        fiLogDebugString(hpRoot,
                            CFuncLogConsoleERROR,
                            "UnKnown ELS type %x",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pSFThread->SF_CMND_Type,
                            0,0,0,0,0,0,0);
                    }

            }
            else
            {
                if( pSFThread->SF_CMND_Type == SFThread_SF_CMND_SF_FCP_Type_TargetReset)
                {
                    if(fi_status ==  fiSF_FCP_Cmd_Status_Success)
                    {
                        fiSendEvent(&pSFThread->thread_hdr,SFEventResetDeviceAccept);
                    }
                    else
                    {
                        fiSendEvent(&pSFThread->thread_hdr,SFEventResetDeviceRej);
                    }

                }
            }
        }
        else /* CDB THREAD */
        {
             pDevThread = pCDBThread->Device;

            if( pCDBThread->thread_hdr.currentState != CDBStateThreadFree)
            {
                fiLogString(hpRoot,
                            "%s CDB %p X_ID %X CDBa %X state %d",
                            "CFuncReadSFQ",(char *)agNULL,
                            pCDBThread,agNULL,
                            pCDBThread->X_ID,
                            pCDBThread->ExchActive,
                            pCDBThread->thread_hdr.currentState,
                            0,0,0,0,0);
            }

/*
             fiLogString(hpRoot,
                        "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                        pCDBThread->CDB_CMND_Class,
                        pCDBThread->CDB_CMND_Type,
                        pCDBThread->CDB_CMND_State,
                        pCDBThread->CDB_CMND_Status,
                        0,0,0);
*/
            if(pCDBThread->CDB_CMND_Class == SFThread_SF_CMND_Class_FC_Tape)
            {
                if( pCDBThread->CDB_CMND_Type == SFThread_SF_CMND_Type_CDB_FC_Tape)
                {
                    if( pCDBThread->CDB_CMND_State == SFThread_SF_CMND_State_CDB_FC_Tape_ReSend)
                    {
/*
                         fiLogString(hpRoot,
                                    "%s Device %02X %s IO X_ID %X",
                                    "CFuncReadSFQ","CDBEventREC_TOV",
                                    (void *)agNULL,(void *)agNULL,
                                    pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                                    pCDBThread->X_ID,
                                    0,0,0,0,0,0);
*/
                        fiSendEvent(&pCDBThread->thread_hdr,CDBEventREC_TOV);
                    }
                    if( pCDBThread->CDB_CMND_State == SFThread_SF_CMND_State_CDB_FC_Tape_GotXRDY)
                    {
                        if( pCDBThread->CDB_CMND_Status == SFThread_SF_CMND_Status_CDB_FC_TapeInitiatorReSend_Data)
                        {
                            if(! fiListElementOnList(  &(pCDBThread->CDBLink), &(pCThread->Free_CDBLink)))
                            {
/*
                                 fiLogString(hpRoot,
                                            "Device %02X Resend IO X_ID %X",
                                            (char *)agNULL,(char *)agNULL,
                                            (void *)agNULL,(void *)agNULL,
                                            pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                                            pCDBThread->X_ID,
                                            0,0,0,0,0,0);
*/
                                fiSendEvent(&(pCDBThread->thread_hdr),CDBEvent_ResendIO);
                            }
                            else
                            {
/*
                                 fiLogDebugString(hpRoot,
                                            CDBStateLogErrorLevel,
                                            "Not Free !! Device %02X Resend IO X_ID %X",
                                            (char *)agNULL,(char *)agNULL,
                                            (void *)agNULL,(void *)agNULL,
                                            pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                                            pCDBThread->X_ID,
                                            0,0,0,0,0,0);
*/
                            }
                        }

                    }

                }
                else /* pCDBThread->CDB_CMND_Type != SFThread_SF_CMND_Type_CDB_FC_Tape */
                {

                    if((pCDBThread->thread_hdr.currentState == CDBStateSendIo) && (pCDBThread->ExchActive))
                    {
                        pCThread->LinkDownTime = pCThread->TimeBase;
                        CFuncShowActiveCDBThreads( hpRoot,ShowERQ);

                        fiLogDebugString(hpRoot,
                                        FCMainLogErrorLevel,
                                        "%s CDB %X  Start %X Ldt %X",
                                        "CFuncReadSFQ",(char *)agNULL,
                                        (void *)agNULL,(void *)agNULL,
                                        pCDBThread->X_ID,
                                        pCDBThread->CDBStartTimeBase.Lo,
                                        pCThread->LinkDownTime.Lo,
                                        0,0,0,0,0);

                        pCDBThread->CompletionStatus = osIOAborted;
                        fiSendEvent(&(pCDBThread->thread_hdr),CDBEvent_PrepareforAbort);
                        if(! fiListElementOnList(  &(pCDBThread->CDBLink), &(pCThread->Free_CDBLink)))
                        {
                            fiSendEvent(&(pCDBThread->thread_hdr),CDBEventAlloc_Abort);
                        }
                    }

                    fiLogDebugString(hpRoot,
                                CStateLogConsoleHideInboundErrors,
                                "AL_PA %X  FC_Tape %X",
                                (char *)agNULL,(char *)agNULL,
                                agNULL,agNULL,
                                fiComputeDevThread_D_ID(pDevThread),
                                pDevThread->FC_TapeDevice,
                                0,0,0,0,0,0);


                }
            }/* end fctape */
            else /* pCDBThread->CDB_CMND_Class != SFThread_SF_CMND_Class_FC_Tape */
            {
                if(! fiListElementOnList(  &(pCDBThread->CDBLink), &(pCThread->Free_CDBLink)))
                {
                    fiSendEvent(&(pCDBThread->thread_hdr),CDBEventIODeviceReset);
                }
                else
                {
                    if( pCDBThread->thread_hdr.currentState != CDBStateThreadFree)
                    {
                        fiLogString(hpRoot,
                                        "%s X_ID %X IO Failed Device %X On Free %x State %d",
                                        "CFuncReadSFQ",(char *)agNULL,
                                        (void *)agNULL,(void *)agNULL,
                                        pCDBThread->X_ID,
                                        fiComputeDevThread_D_ID(pDevThread),
                                        fiListElementOnList(  &(pCDBThread->CDBLink), &(pCThread->Free_CDBLink)),
                                        pCDBThread->thread_hdr.currentState,
                                        0,0,0,0);
                    }
                }
            }
        }/* End CDB THREAD */
    }
    else /* No thread associated with this entry  */
    {
       switch ( fi_status )
	{
          case fiLinkSvc_Cmd_Status_PLOGI_From_Twin:
            fiLogDebugString(hpRoot,
                        CFuncLogConsoleERROR,
                        "PLOGI With same AL_PA !!!!",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);

            fiLogString(hpRoot,
                            "PLOGI With same AL_PA !!!!",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            0,0,0,0,0,0,0,0);

            fiSendEvent(&pCThread->thread_hdr,CEventAsyncLoopEventDetected);


            break;

          case fiLinkSvc_Cmd_Status_PLOGI_From_Other:
           fiLogDebugString(hpRoot,
                        CStateLogConsoleLevelLip,
                        "PLOGI from someone  !!!!",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);

            break;

          case fiLinkSvc_Cmd_Status_Position_Map:
            {
                FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t * AL_PA_Position_Map   = (FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t *)(CThread_ptr(hpRoot)->Calculation.MemoryLayout.LOOPDeviceMAP.addr.CachedMemory.cachedMemoryPtr);
    
                pCThread->LoopMapLIRP_Received = agTRUE;
                pCThread->DeviceDiscoveryMethod = DDiscoveryLoopMapReceived;
                CFuncLoopMapRecieved(hpRoot,agFALSE);

                fiLogDebugString(hpRoot,
                            CFuncLogConsoleERROR,
                            "%s Flags %8X Index %02X",
                            "fiLinkSvc_Cmd_Status_Position_Map",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            AL_PA_Position_Map->Code_Flags,
                            (os_bit32)AL_PA_Position_Map->AL_PA_Index,
                            0,0,0,0,0,0);

                break;
            }
#ifdef _DvrArch_1_30_
          case fiLinkSvc_Cmd_Status_FARP_From_Twin:
            fiLogDebugString(hpRoot,
                        CFuncLogConsoleERROR,
                        "FARP With same AL_PA !!!!",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);

            fiLogString(hpRoot,
                            "FARP With same AL_PA !!!!",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            0,0,0,0,0,0,0,0);

            fiSendEvent(&pCThread->thread_hdr,CEventAsyncLoopEventDetected);


            break;

          case fiLinkSvc_Cmd_Status_FARP_From_Other:
            fiLogDebugString(hpRoot,
                        CStateLogConsoleLevelLip,
                        "FARP from someone  !!!!",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);

            break;

          case fiIP_Cmd_Status_Incoming:
           fiLogDebugString(hpRoot,
                        CStateLogConsoleLevelLip,
                        "IP Data from someone  !!!!",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);
	   break;

#endif /* _DvrArch_1_30_ was defined */

        }
    }
}

os_bit32     Find_SF_Thread(  agRoot_t        *hpRoot,
                           SFQConsIndex_t   SFQConsIndex,
                           os_bit32            Frame_Length,
                           SFThread_t     **SFThread_to_return
                         )
{
    os_bit32 fi_status;
    CDBThread_t * pCDBThread;

#ifdef _DvrArch_1_30_
    fi_status = fiIPProcessSFQ( hpRoot, SFQConsIndex, Frame_Length, (fi_thread__t **) SFThread_to_return );
    if(fi_status != fiIP_Cmd_Status_Confused)
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevelLip,
                    "Find_SF_Thread IP match ! fi_status %x thread %p",
                    (char *)agNULL,(char *)agNULL,
                    *SFThread_to_return,agNULL,
                    fi_status,
                    0,0,0,0,0,0,0);

        return fi_status;
    }
#endif /* _DvrArch_1_30_ was defined */

#ifdef NAME_SERVICES

    fi_status= fiCTProcessSFQ( hpRoot, SFQConsIndex, Frame_Length, (fi_thread__t **)SFThread_to_return );
    if(fi_status != fiCT_Cmd_Status_Confused)
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevelLip,
                    "Find_SF_Thread CT match ! fi_status %x thread %p",
                    (char *)agNULL,(char *)agNULL,
                    *SFThread_to_return,agNULL,
                    fi_status,
                    0,0,0,0,0,0,0);

        return fi_status;
    }
#endif  /* NAME_SERVICES */

    fi_status= fiLinkSvcProcessSFQ( hpRoot, SFQConsIndex, Frame_Length, (fi_thread__t **)SFThread_to_return );

    if(fi_status != fiLinkSvc_Cmd_Status_Confused)
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevelLip,
                    "Find_SF_Thread LinkSvc match ! fi_status %x thread %p",
                    (char *)agNULL,(char *)agNULL,
                    *SFThread_to_return,agNULL,
                    fi_status,
                    0,0,0,0,0,0,0);

        return fi_status;
    }

    fi_status = fiSF_FCP_ProcessSFQ( hpRoot, SFQConsIndex, Frame_Length, (fi_thread__t **)SFThread_to_return );

    if(fi_status != fiSF_FCP_Cmd_Status_Confused)
    {
        pCDBThread = (CDBThread_t *) *SFThread_to_return;
        if(pCDBThread)
        {
            fiLogDebugString(hpRoot,
                        CStateLogConsoleLevelLip,
                        "Find_SF_Thread SF_FCP match ! fi_status %x thread %p State %d X_ID %X @ %d",
                        (char *)agNULL,(char *)agNULL,
                        *SFThread_to_return,agNULL,
                        fi_status,
                        (os_bit32)pCDBThread->thread_hdr.currentState,
                        pCDBThread->X_ID,
                        pCDBThread->TimeStamp,
                        0,0,0,0);
        }
        else
        {
            fiLogDebugString(hpRoot,
                        CStateLogConsoleLevelLip,
                        "Find_SF_Thread SF_FCP match ! fi_status %x thread %p",
                        (char *)agNULL,(char *)agNULL,
                        *SFThread_to_return,agNULL,
                        fi_status,
                        0,0,0,0,0,0,0);
        }
        return fi_status;
    }

    fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Find_SF_Thread Failed to match !",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fi_status,0,0,0,0,0,0,0);


    return 0xBAD0BAD1;

}

void CFuncOutBoundCompletion(agRoot_t * hpRoot,
         os_bit32 Bits__SEST_Index__Trans_ID,
         os_bit32 More_Bits
)
{
    CThread_t       *  pCThread     = CThread_ptr(hpRoot);
    CDBThread_t     *  pCDBThread;
    SFThread_t      *  pSFThread;
    os_bit32          X_ID;
    USE_t           * SEST;
    event_t           event_to_send = 0;

#ifdef _DvrArch_1_30_
    os_bit32       X_ID_Offset;
    PktThread_t     *pPktThread;

    fiMemMapMemoryDescriptor_t * PktThread_MemoryDescriptor = &(CThread_ptr(hpRoot)->Calculation.MemoryLayout.PktThread);
#endif /* _DvrArch_1_30_ was defined */

    fiMemMapMemoryDescriptor_t * CDBThread_MemoryDescriptor = &(CThread_ptr(hpRoot)->Calculation.MemoryLayout.CDBThread);
    fiMemMapMemoryDescriptor_t * SFThread_MemoryDescriptor  = &(CThread_ptr(hpRoot)->Calculation.MemoryLayout.SFThread);

    X_ID =(Bits__SEST_Index__Trans_ID  & CM_Outbound_SEST_Index_MASK);

#ifdef _DvrArch_1_30_
    X_ID_Offset = (X_ID_t)(CDBThread_MemoryDescriptor->elements + SFThread_MemoryDescriptor->elements);
    if( X_ID >= X_ID_Offset)
    {
        X_ID -= (X_ID_t)(X_ID_Offset);
        pPktThread = (PktThread_t *)((os_bit8 *)(PktThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                 + (X_ID * sizeof(PktThread_t)));
	pPktThread->status = FC_CMND_STATUS_SUCCESS;
        pCThread->IP->CompletedPkt = pPktThread;
        fiSendEvent(&(pCThread->IP->thread_hdr),IPEventOutgoingComplete);
	return;
    }
    else
#endif /* _DvrArch_1_30_ was defined */
    if( X_ID >= CDBThread_MemoryDescriptor->elements)
    {

        X_ID -= (X_ID_t)(CDBThread_MemoryDescriptor->elements);

        pSFThread = (SFThread_t *)((os_bit8 *)(SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                 + (X_ID * sizeof(SFThread_t)));

        if(pSFThread->SF_CMND_Class == SFThread_SF_CMND_Class_LinkSvc)
        {

            switch(pSFThread->SF_CMND_Type)
            {

/*
                case SFThread_SF_CMND_LinkSvc_Type_BA_RJT:
                    event_to_send = ;
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_RRQ:
                    event_to_send = ;
                    break;
*/
                case SFThread_SF_CMND_LinkSvc_Type_ABTS:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoAbort )
                    {
                        event_to_send = SFStateAbortRej;
                    }
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_PLOGI:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoPlogi )
                    {
                        event_to_send = SFEventPlogiBadALPA;
                    }
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_FLOGI:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoFlogi )
                    {
                        if(More_Bits & CM_Outbound_FTO )
                        {
                            event_to_send = SFEventFlogiBadALPA;
                        }
                        else
                        {
                            event_to_send = SFEventFlogiRej;
                        }
                    }
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_LOGO:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoLogo )
                    {
                        event_to_send = SFEventLogoRej;
                    }
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_SRR:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoSRR )
                    {
                        event_to_send = SFEventSRRRej;
                    }
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_REC:
                    fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "Outbound SF %s Bits %8X X_ID %08X",
                            "SFEventRECRej",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            More_Bits,
                            Bits__SEST_Index__Trans_ID,
                            0,0,0,0,0,0);

                    if ( pSFThread->thread_hdr.currentState == SFStateDoREC )
                    {
                        event_to_send = SFEventRECRej;
                    }
                    break;

               case SFThread_SF_CMND_LinkSvc_Type_PRLI:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoPrli )
                    {
                        pSFThread->parent.Device->PRLI_rejected = agTRUE;
                    }
                    event_to_send = SFEventPrliRej;
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_PRLO:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoPrlo )
                    {
                        event_to_send = SFEventPrloRej;
                    }
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_ADISC:
                    if ( pSFThread->thread_hdr.currentState ==  SFStateDoAdisc)
                    {
                        event_to_send = SFEventAdiscRej;
                    }
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_SCR:
                    if ( pSFThread->thread_hdr.currentState ==  SFStateDoSCR)
                    {
                        event_to_send = SFEventSCRRej;
                    }
                    break;
                /* Target Mode response */

                case SFThread_SF_CMND_LinkSvc_Type_LS_RJT:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoLS_RJT )
                    {
                        event_to_send = SFEventLS_RJT_Done;
                    }
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_PLOGI_ACC:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoPlogiAccept )
                    {
                        event_to_send = SFEventPlogiAccept_Done;
                    }
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_PRLI_ACC:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoPrliAccept )
                    {
                        event_to_send = SFEventPrliAccept_Done;
                    }
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_ELS_ACC:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoELSAccept )
                    {
                        event_to_send = SFEventELSAccept_Done;
                    }
                    break;
                case SFThread_SF_CMND_LinkSvc_Type_ADISC_ACC:
                    if ( pSFThread->thread_hdr.currentState == SFEventDoADISCAccept )
                    {
                        event_to_send = SFEventADISCAccept_Done;
                    }
                    break;
#ifdef _DvrArch_1_30_
                case SFThread_SF_CMND_LinkSvc_Type_FARP_REPLY:
                    if ( pSFThread->thread_hdr.currentState == SFEventDoFarpReply )
                    {
                        event_to_send = SFEventFarpReplyDone;
                    }
                    break;
#endif /* _DvrArch_1_30_ was defined */

                default:
                    event_to_send = 0;
                /* ELS Command == 0 Reset device SFthread */
            }
        }
        else
        {
            switch(pSFThread->SF_CMND_Type)
            {

                case SFThread_SF_CMND_SF_FCP_Type_FCP_RSP_IU:
                    event_to_send = SFStateFCP_DR_ACC_Reply_Done;
                    break;

                case SFThread_SF_CMND_SF_FCP_Type_TargetReset:
                    event_to_send = SFEventResetDeviceBadALPA;
                    break;

                default:
                    event_to_send = 0;
            }


        }

        if(More_Bits & CM_Outbound_LKF)
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Outbound SF Link Failure  Bits %8X X_ID %08X Event %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    More_Bits,
                    Bits__SEST_Index__Trans_ID,
                    event_to_send,
                    0,0,0,0,0);

           if( !(pCThread->thread_hdr.currentState == CStateInitFM            ||
                 pCThread->thread_hdr.currentState == CStateInitFM_DelayDone  ||
                 pCThread->thread_hdr.currentState == CStateResetNeeded       ||
                 pCThread->thread_hdr.currentState == CStateReInitFM            ))
            {
                if ((pCThread->DEVID == ChipConfig_DEVID_TachyonTL) && (pCThread->REVID < ChipConfig_REVID_2_2))
                {
                    fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventAsyncLoopEventDetected);
                }
            }
        }

        if(More_Bits & CM_Outbound_HPE)
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Outbound SF Host Programing Error  Bits %8X X_ID %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    More_Bits,
                    Bits__SEST_Index__Trans_ID,
                    0,0,0,0,0,0);

            if( !(pCThread->thread_hdr.currentState == CStateInitFM            ||
                  pCThread->thread_hdr.currentState == CStateInitFM_DelayDone  ||
                  pCThread->thread_hdr.currentState == CStateResetNeeded       ||
                  pCThread->thread_hdr.currentState == CStateReInitFM             ))
            {
/*
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventAsyncLoopEventDetected);
*/            }
        }

        if(More_Bits & CM_Outbound_ASN)
        {
            fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "Outbound SF Abort Sequence Notification Bits %8X X_ID %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            More_Bits,
                            Bits__SEST_Index__Trans_ID,
                            0,0,0,0,0,0);
            fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "ASN Failed FM %08X TL status %08X Qf %d CState %d",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                            CFunc_Queues_Frozen( hpRoot ),
                            pCThread->thread_hdr.currentState,
                            0,0,0,0);

            fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            CThread_ptr(hpRoot)->LOOP_DOWN,
                            CThread_ptr(hpRoot)->IDLE_RECEIVED,
                            CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                            CThread_ptr(hpRoot)->ERQ_FROZEN,
                            CThread_ptr(hpRoot)->FCP_FROZEN,
                            CThread_ptr(hpRoot)->ProcessingIMQ,
                            0,0);


            if( !(pCThread->thread_hdr.currentState == CStateInitFM            ||
                  pCThread->thread_hdr.currentState == CStateInitFM_DelayDone  ||
                  pCThread->thread_hdr.currentState == CStateResetNeeded       ||
                  pCThread->thread_hdr.currentState == CStateReInitFM             ))
            {
                if( pCThread->thread_hdr.currentState == CStateInitializeFailed  )
                {
                    return;
                }
                else
                {
/*
                    fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventAsyncLoopEventDetected);
*/
                }
            }

        }

        if(More_Bits & CM_Outbound_FTO)
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Outbound SF Frame TimeOut Bits %8X X_ID %08X Class %X Type %X State %X Thread State %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    More_Bits,
                    Bits__SEST_Index__Trans_ID,
                    pSFThread->SF_CMND_Class,
                    pSFThread->SF_CMND_Type,
                    pSFThread->SF_CMND_State,
                    pSFThread->thread_hdr.currentState,
                    0,0);
/*
            if( !(pCThread->thread_hdr.currentState == CStateInitFM            ||
                  pCThread->thread_hdr.currentState == CStateInitFM_DelayDone  ||
                  pCThread->thread_hdr.currentState == CStateResetNeeded       ||
                  pCThread->thread_hdr.currentState == CStateReInitFM             ))
            {
                if ((pCThread->DEVID == ChipConfig_DEVID_TachyonTL) && (pCThread->REVID < ChipConfig_REVID_2_2))
                {
                    fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventAsyncLoopEventDetected);
                }
            }
*/
        }
        if(event_to_send != 0)
        {
            fiSendEvent(&pSFThread->thread_hdr, event_to_send);
        }
        else
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "SF Frame Thread %p NOT VALID Bits %8x X_ID %08X Class %X Type %X CmdState %X SFState %d",
                    (char *)agNULL,(char *)agNULL,
                    pSFThread,agNULL,
                    More_Bits,
                    Bits__SEST_Index__Trans_ID,
                    pSFThread->SF_CMND_Class,
                    pSFThread->SF_CMND_Type,
                    pSFThread->SF_CMND_State,
                    pSFThread->thread_hdr.currentState,
                    0,0);
            /* fiSendEvent(&pSFThread->thread_hdr, SFEventReset);
               pCThread->SFpollingCount--;
            */
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "%s Cleared SF Thread  SFState %d CCnt %x",
                    "CFuncOutBoundCompletion",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pSFThread->thread_hdr.currentState,
                    pCThread->SFpollingCount,
                    0,0,0,0,0,0);
 
        }
    }
    else
    {
        event_to_send = CDBEventIODeviceReset;

        pCDBThread = (CDBThread_t *)((os_bit8 *)(CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                  + (X_ID * CDBThread_MemoryDescriptor->elementSize));

        SEST = (USE_t *)pCDBThread->SEST_Ptr;

        if(SEST)
        {
            fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "Sest DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        SEST->Bits,
                        SEST->Unused_DWord_1,
                        SEST->Unused_DWord_2,
                        SEST->Unused_DWord_3,
                        SEST->LOC,
                        SEST->Unused_DWord_5,
                        SEST->Unused_DWord_6,
                        SEST->Unused_DWord_7);

            fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "Sest DWORD 8 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        SEST->Unused_DWord_8,
                        SEST->Unused_DWord_9,
                        SEST->First_SG.U32_Len,
                        SEST->First_SG.L32,
                        SEST->Second_SG.U32_Len,
                        SEST->Second_SG.L32,
                        SEST->Third_SG.U32_Len,
                        SEST->Third_SG.L32);
        }

        if(More_Bits & CM_Outbound_LKF)
        {
            fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "Outbound CDB Link Failure %08X %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            More_Bits,Bits__SEST_Index__Trans_ID,0,0,0,0,0,0);

            /*event_to_send = CDBEventIODeviceReset;*/
        }

        if(More_Bits & CM_Outbound_HPE)
        {
            fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "Outbound CDB Host Programing Error %08X %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            More_Bits,Bits__SEST_Index__Trans_ID,0,0,0,0,0,0);
            /*event_to_send = CDBEventFailNoRSP;*/
        }

        if(More_Bits & CM_Outbound_ASN)
        {
            pCThread->Loop_State_TimeOut_In_tick++;
            fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "Outbound CDB Abort Sequence Notification %08X %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            More_Bits,Bits__SEST_Index__Trans_ID,0,0,0,0,0,0);
            /*event_to_send = CDBEventIODeviceReset;*/
        }

        if(More_Bits & CM_Outbound_FTO)
        {
            pCThread->Loop_State_TimeOut_In_tick++;
            fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "Outbound CDB Frame TimeOut %08X %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            More_Bits,Bits__SEST_Index__Trans_ID,0,0,0,0,0,0);
            /*event_to_send = CDBEventIODeviceReset;*/
        }
/*
        fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "Outbound CDB Sends event %d X_ID %X State %d",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        event_to_send,
                        X_ID,
                        pCDBThread->thread_hdr.currentState,
                        0,0,0,0,0);
*/
        if( pCDBThread->thread_hdr.currentState == CDBStateSendIo )
        {
            if (!(pCDBThread->ExchActive))
            {
                fiLogDebugString(hpRoot,
                            CFuncLogConsoleERROR,
                            "Outbound Found a cbdthread that is not active... %p State %d",
                            (char *)agNULL,(char *)agNULL,
                            pCDBThread,agNULL,
                            pCDBThread->thread_hdr.currentState,0,0,0,0,0,0,0);
/*
                 fiLogDebugString(hpRoot,
                            CFuncLogConsoleERROR,
                            "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            (os_bit32)pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                            (os_bit32)pCDBThread->CDB_CMND_Class,
                            (os_bit32)pCDBThread->CDB_CMND_Type,
                            (os_bit32)pCDBThread->CDB_CMND_State,
                            (os_bit32)pCDBThread->CDB_CMND_Status,
                            0,0,0);
*/
                return;
            }
            if(! pCDBThread->ActiveDuringLinkEvent)
            {
                fiSendEvent(&pCDBThread->thread_hdr, event_to_send);
            }
        }
    }

    if(! pCThread->LOOP_DOWN )
    {
       /* Clear IDLE_RECEIVED if we clear Queues
        */
        if ( CFunc_Always_Enable_Queues(hpRoot ) )
        {
            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) OB Queues Frozen after enable !",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        0,0,0,0,0,0,0,0);
        }
    }
    else
    {
        pCThread->OUTBOUND_RECEIVED = agTRUE;
    }


    if(CFunc_Queues_Frozen( hpRoot ))
    {
        fiLogDebugString(hpRoot,
                        CSTATE_NOISE(hpRoot,CStateFindDevice),
                        "Outbound CFunc_Queues_Frozen LD %x IR %x",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCThread->LOOP_DOWN,
                        pCThread->IDLE_RECEIVED,
                        0,0,0,0,0,0);

    }

}

void CFunc_LOGO_Completion(agRoot_t * hpRoot,  os_bit32 X_ID)
{
    CThread_t       *  pCThread     = CThread_ptr(hpRoot);
    CDBThread_t     *  pCDBThread;
    SFThread_t      *  pSFThread;
    USE_t           * SEST;
    event_t           event_to_send = 0;

    fiMemMapMemoryDescriptor_t * CDBThread_MemoryDescriptor = &(CThread_ptr(hpRoot)->Calculation.MemoryLayout.CDBThread);
    fiMemMapMemoryDescriptor_t * SFThread_MemoryDescriptor  = &(CThread_ptr(hpRoot)->Calculation.MemoryLayout.SFThread);

    fiLogString(hpRoot,
            "%s Cleared X_ID %X CDBCnt %x",
            "CFunc_LOGO_Completion",(char *)agNULL,
            (void *)agNULL,(void *)agNULL,
            X_ID,
            pCThread->CDBpollingCount,
            0,0,0,0,0,0);

    if( X_ID >= CDBThread_MemoryDescriptor->elements)
    {

        if( X_ID >= CDBThread_MemoryDescriptor->elements + SFThread_MemoryDescriptor->elements)
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "%s X_ID Invalid !!!! %x",
                    "CFunc_LOGO_Completion",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    X_ID,
                    0,0,0,0,0,0,0);
            return;
        }

        X_ID -= (CDBThread_MemoryDescriptor->elements);

        pSFThread = (SFThread_t *)((os_bit8 *)(SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                 + (X_ID * sizeof(SFThread_t)));

        if(pSFThread->SF_CMND_Class == SFThread_SF_CMND_Class_LinkSvc)
        {

            switch(pSFThread->SF_CMND_Type)
            {

/*
                case SFThread_SF_CMND_LinkSvc_Type_BA_RJT:
                    event_to_send = ;
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_RRQ:
                    event_to_send = ;
                    break;
*/
                case SFThread_SF_CMND_LinkSvc_Type_ABTS:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoAbort )
                    event_to_send = SFStateAbortRej;
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_PLOGI:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoPlogi )
                    event_to_send = SFEventPlogiBadALPA;
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_FLOGI:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoFlogi )
                     event_to_send = SFEventFlogiRej;
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_LOGO:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoLogo )
                    event_to_send = SFEventLogoRej;
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_SRR:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoSRR )
                    event_to_send = SFEventSRRRej;
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_REC:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoREC )
                    event_to_send = SFEventRECRej;
                    break;

               case SFThread_SF_CMND_LinkSvc_Type_PRLI:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoPrli )
                    event_to_send = SFEventPrliRej;
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_PRLO:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoPrlo )
                    event_to_send = SFEventPrloRej;
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_ADISC:
                    if ( pSFThread->thread_hdr.currentState ==  SFStateDoAdisc)
                    event_to_send = SFEventAdiscRej;
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_SCR:
                    if ( pSFThread->thread_hdr.currentState ==  SFStateDoSCR)
                    event_to_send = SFEventSCRRej;
                    break;
                /* Target Mode response */

                case SFThread_SF_CMND_LinkSvc_Type_LS_RJT:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoLS_RJT )
                    event_to_send = SFEventLS_RJT_Done;
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_PLOGI_ACC:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoPlogiAccept )
                    event_to_send = SFEventPlogiAccept_Done;
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_PRLI_ACC:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoPrliAccept )
                    event_to_send = SFEventPrliAccept_Done;
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_ELS_ACC:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoELSAccept )
                    event_to_send = SFEventELSAccept_Done;
                    break;

                default:
                    event_to_send = 0;
                /* ELS Command == 0 Reset device SFthread */
            }
        }
        else
        {
            switch(pSFThread->SF_CMND_Type)
            {

                case SFThread_SF_CMND_SF_FCP_Type_FCP_RSP_IU:
                    event_to_send = SFStateFCP_DR_ACC_Reply_Done;
                    break;

                case SFThread_SF_CMND_SF_FCP_Type_TargetReset:
                    event_to_send = SFEventResetDeviceBadALPA;
                    break;

                default:
                    event_to_send = 0;
            }


        }

        if(event_to_send != 0)
        {
            fiSendEvent(&pSFThread->thread_hdr, event_to_send);
            return;
        }
        else
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "SF Frame Thread %p NOT VALID X_ID %08X Class %X Type %X CmdState %X SFState %d",
                    (char *)agNULL,(char *)agNULL,
                    pSFThread,agNULL,
                    X_ID,
                    pSFThread->SF_CMND_Class,
                    pSFThread->SF_CMND_Type,
                    pSFThread->SF_CMND_State,
                    pSFThread->thread_hdr.currentState,
                    0,0,0);
            fiSendEvent(&pSFThread->thread_hdr, SFEventReset);

            /* pCThread->CDBpollingCount--; */

            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "%s Cleared SF Thread  SFState %d CCnt %x",
                    "CFunc_LOGO_Completion",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pSFThread->thread_hdr.currentState,
                    pCThread->CDBpollingCount,
                    0,0,0,0,0,0);
 
        }
    }
    else
    {
        event_to_send = CDBEventIODeviceReset;

        pCDBThread = (CDBThread_t *)((os_bit8 *)(CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                  + (X_ID * CDBThread_MemoryDescriptor->elementSize));

        SEST = (USE_t *)pCDBThread->SEST_Ptr;

        if(SEST)
        {
            fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "Sest DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        SEST->Bits,
                        SEST->Unused_DWord_1,
                        SEST->Unused_DWord_2,
                        SEST->Unused_DWord_3,
                        SEST->LOC,
                        SEST->Unused_DWord_5,
                        SEST->Unused_DWord_6,
                        SEST->Unused_DWord_7);

            fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "Sest DWORD 8 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        SEST->Unused_DWord_8,
                        SEST->Unused_DWord_9,
                        SEST->First_SG.U32_Len,
                        SEST->First_SG.L32,
                        SEST->Second_SG.U32_Len,
                        SEST->Second_SG.L32,
                        SEST->Third_SG.U32_Len,
                        SEST->Third_SG.L32);
        }


        if( pCDBThread->thread_hdr.currentState == CDBStateSendIo )
        {
            if (!(pCDBThread->ExchActive))
            {
                fiLogDebugString(hpRoot,
                            CFuncLogConsoleERROR,
                            "CFunc_LOGO_Completion Found a cbdthread that is not active... %p State %d",
                            (char *)agNULL,(char *)agNULL,
                            pCDBThread,agNULL,
                            pCDBThread->thread_hdr.currentState,0,0,0,0,0,0,0);
/*
                 fiLogDebugString(hpRoot,
                            CFuncLogConsoleERROR,
                            "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                            pCDBThread->CDB_CMND_Class,
                            pCDBThread->CDB_CMND_Type,
                            pCDBThread->CDB_CMND_State,
                            pCDBThread->CDB_CMND_Status,
                            0,0,0);
*/
                return;
            }

            fiSendEvent(&pCDBThread->thread_hdr, event_to_send);
        }
    }
}


void CFuncErrorERQFrozen(agRoot_t * hpRoot)
{
    CThread_t  * pCThread = CThread_ptr(hpRoot);

    pCThread->ERQ_FROZEN = agTRUE;

    fiLogDebugString(hpRoot,
                      CStateLogConsoleLevelLip,
                      "ERQ Frozen Status %08X",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                      0,0,0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(hpRoot)->LOOP_DOWN,
                    CThread_ptr(hpRoot)->IDLE_RECEIVED,
                    CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                    CThread_ptr(hpRoot)->ERQ_FROZEN,
                    CThread_ptr(hpRoot)->FCP_FROZEN,
                    CThread_ptr(hpRoot)->ProcessingIMQ,
                    0,0);

}


void CFuncErrorIdle(agRoot_t * hpRoot)
{
    CThread_t  * pCThread = CThread_ptr(hpRoot);

    osStallThread(hpRoot, 200 );

    pCThread->IDLE_RECEIVED = agTRUE;

    if(( ! pCThread->LOOP_DOWN ) )
    {
        if( CFunc_Always_Enable_Queues(hpRoot ) )
        {
            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) IDLE Queues Frozen after enable !",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        0,0,0,0,0,0,0,0);

            if( pCThread->thread_hdr.currentState != CStateResetNeeded  )
            {
                if(pCThread->LoopPreviousSuccess)
                {
                    fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "IDLE Previous hpRoot(%p) ResetLOOP Cstate %d sends %s (%d)",
                            "CEventAsyncLoopEventDetected",(char *)agNULL,
                            hpRoot,agNULL,
                            pCThread->thread_hdr.currentState,
                            CEventAsyncLoopEventDetected,0,0,0,0,0,0);

                    fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventAsyncLoopEventDetected);
                }
                else
                {
                    fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "IDLE hpRoot(%p) ResetLOOP Cstate %d sends %s (%d)",
                            "CEventLoopNeedsReinit",(char *)agNULL,
                            hpRoot,agNULL,
                            pCThread->thread_hdr.currentState,
                            CEventLoopNeedsReinit,0,0,0,0,0,0);

                    fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventLoopNeedsReinit);
                }
            }

        }
    }
}

void CFuncErrorFCP_Frozen(agRoot_t * hpRoot)
{
    CThread_t  * pCThread = CThread_ptr(hpRoot);

    pCThread->FCP_FROZEN = agTRUE;

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "CFuncErrorFCP_Frozen Status %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    0,0,0,0,0,0,0);
    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(hpRoot)->LOOP_DOWN,
                    CThread_ptr(hpRoot)->IDLE_RECEIVED,
                    CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                    CThread_ptr(hpRoot)->ERQ_FROZEN,
                    CThread_ptr(hpRoot)->FCP_FROZEN,
                    CThread_ptr(hpRoot)->ProcessingIMQ,
                    0,0);

}


/*+
  Function: cfimq
   Purpose: When compiled updates browser info file for VC 5.0 / 6.0
   Returns: none
 Called By: none
     Calls: none
-*/
/* void cfimq(void){} */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\control.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Module Name:

    Control.c

Abstract:

    This is the miniport driver for the Agilent
    PCI to Fibre Channel Host Bus Adapter (HBA). This module is specific to the NT 5.0 
    PnP and Power Management Support.

Authors:
    IW - Ie Wei Njoo
 
Environment:

    kernel mode only

Version Control Information:

    $Archive: /Drivers/Win2000/Trunk/OSLayer/C/CONTROL.C $

Revision History:

    $Revision: 5 $
    $Date: 10/23/00 5:35p $
    $Modtime::  $

Notes:

--*/


#include "buildop.h"

#include "osflags.h"
#include "TLStruct.H"

#ifdef HP_NT50

#ifdef _DEBUG_EVENTLOG_
extern PVOID      gDriverObject;
#endif

/*++

Routine Description:

    Support routines to perform synchronous operation to control the state
    or behavior of the HBA, such as for the PnP and power management (NT 5.0).

Arguments:

    pCard-  Points to the miniport driver's per-HBA storage area. 
    ControlType - Specifies the adapter-control operations. 
    Parameters -  If ControlType is ScsiStopAdapter, ScsiSetBootConfig, 
              ScsiSetRunningConfig, or ScsiRestartAdapter, Parameters is NULL. 

              If ControlType is ScsiQuerySupportedControlTypes, Parameters 
              points to a caller-allocated SCSI_SUPPORTED_CONTROL_TYPE_LIST 
              structure, 

Return Value:

    ScsiAdapterControlSuccess - The miniport completed the requested operation
    successfully. Currently, this routine must return this value for all
    control types.

    ScsiAdapterControlUnsuccessful - Reserved for future NT 5.0 use.

--*/
SCSI_ADAPTER_CONTROL_STATUS
HPAdapterControl(
    IN PCARD_EXTENSION pCard,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
    IN PVOID Parameters
    )
{
    agRoot_t * phpRoot = &pCard->hpRoot;
    PSCSI_SUPPORTED_CONTROL_TYPE_LIST pControlTypeList;
    ULONG return_value;

    switch(ControlType) 
    {
        case ScsiQuerySupportedControlTypes: 
        {
            pControlTypeList = (PSCSI_SUPPORTED_CONTROL_TYPE_LIST) Parameters;
            pControlTypeList->SupportedTypeList[ScsiQuerySupportedControlTypes] = TRUE;   
            pControlTypeList->SupportedTypeList[ScsiStopAdapter]           = TRUE;  
            pControlTypeList->SupportedTypeList[ScsiRestartAdapter]           = TRUE;  
            osDEBUGPRINT((ALWAYS_PRINT, "HPAdapterControl: ScsiQuerySupportedControlTypes called.\n"));
            break;
        }

        case ScsiStopAdapter: 
        {
            //
            // Shut down all interrupts on the adapter.  They'll get re-enabled
            // by the initialization routines.
            //
    
            pCard->inDriver = TRUE;    // Make sure the timer routine will be idle

         
            fcShutdownChannel(phpRoot);
            osDEBUGPRINT((ALWAYS_PRINT, "HPAdapterControl: ScsiStopAdapter called.\n"));
            
            #ifdef _DEBUG_EVENTLOG_
            LogEvent(   pCard, 
                  NULL,
                  HPFC_MSG_ADAPTERCONTROL_STOP,
                  NULL, 
                  0, 
                  NULL);
         
            if (pCard->EventLogBufferIndex < MAX_CARDS_SUPPORTED)
            {
                StopEventLogTimer(gDriverObject, (PVOID) pCard);
                ReleaseEventLogBuffer(gDriverObject, (PVOID) pCard);
                }
            #endif
            break;
        }

        case ScsiRestartAdapter: 
        {
            //
            // Enable all the interrupts on the adapter while port driver call
            // for power up an HBA that was shut down for power management
            //

            return_value = fcInitializeChannel(  phpRoot,
                                                fcSyncInit,
                                                agTRUE, // sysIntsActive
                                                pCard->cachedMemoryPtr,
                                                pCard->cachedMemoryNeeded,
                                                pCard->dmaMemoryUpper32,
                                                pCard->dmaMemoryLower32,
                                                pCard->dmaMemoryPtr,
                                                pCard->dmaMemoryNeeded,
                                                pCard->nvMemoryNeeded,
                                                pCard->cardRamUpper,
                                                pCard->cardRamLower,
                                                pCard->RamLength ,
                                                pCard->cardRomUpper,
                                                pCard->cardRomLower,
                                                pCard->RomLength,
                                                pCard->usecsPerTick );

            if (return_value != fcInitializeSuccess) 
            {
                osDEBUGPRINT((ALWAYS_PRINT, "HPAdapterControl: fcInitializeChannel FAILED.\n"));
                #ifdef _DEBUG_EVENTLOG_
                LogEvent(   pCard, 
                  NULL,
                  HPFC_MSG_ADAPTERCONTROL_RESTARTFAILED,
                  NULL, 
                  0, 
                  NULL);
                #endif
            }
            else
            {
                osDEBUGPRINT((ALWAYS_PRINT, "HPAdapterControl: ScsiRestartAdapter OK.\n"));
                pCard->inDriver = FALSE;      // The timer routine could now do usefull work
            }
         
            #ifdef _DEBUG_EVENTLOG_
            {
                ULONG    ix;
         
                ix = AllocEventLogBuffer(gDriverObject, (PVOID) pCard);
                if (ix < MAX_CARDS_SUPPORTED)
                {
                pCard->EventLogBufferIndex = ix;                      /* store it */
                StartEventLogTimer(gDriverObject,pCard);
                }
            
                LogHBAInformation(pCard);
            }
            #endif

            break;
        }

        default: 
        {
            #ifdef _DEBUG_EVENTLOG_
            LogEvent(   pCard, 
                  NULL,
                  HPFC_MSG_ADAPTERCONTROL_UNSUPPORTEDCOMMAND,
                  NULL, 
                  0, 
                  "%x", ControlType);
            #endif
            osDEBUGPRINT((ALWAYS_PRINT, "HPAdapterControl: ScsiAdapterControlUnsuccessful.\n"));
            return ScsiAdapterControlUnsuccessful;
        }
    }

    return ScsiAdapterControlSuccess;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\cstate.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/CSTATE.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 10/27/00 6:31p  $

Purpose:

  This file implements the FC Layer State Machine.

--*/

#ifndef _New_Header_file_Layout_
#include "../h/globals.h"
#include "../h/fcstruct.h"
#include "../h/state.h"

#include "../h/tlstruct.h"
#include "../h/memmap.h"
#include "../h/fcmain.h"
#include "../h/linksvc.h"
#include "../h/cmntrans.h"
#include "../h/flashsvc.h"
#include "../h/timersvc.h"

#include "../h/cstate.h"
#include "../h/cfunc.h"
#include "../h/devstate.h"
#include "../h/cdbstate.h"
#include "../h/sfstate.h"

#include "../h/queue.h"
#include "../h/cdbsetup.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "fcstruct.h"
#include "state.h"

#include "tlstruct.h"
#include "memmap.h"
#include "fcmain.h"
#include "linksvc.h"
#include "cmntrans.h"
#include "flashsvc.h"
#include "timersvc.h"

#include "cstate.h"
#include "cfunc.h"
#include "devstate.h"
#include "cdbstate.h"
#include "sfstate.h"

#include "queue.h"
#include "cdbsetup.h"
#endif  /* _New_Header_file_Layout_ */

extern stateTransitionMatrix_t  DevStateTransitionMatrix;
extern stateActionScalar_t      DevStateActionScalar;
extern stateTransitionMatrix_t  SFstateTransitionMatrix;
extern stateActionScalar_t      SFstateActionScalar;


stateTransitionMatrix_t CStateTransitionMatrix = {
    /* Event/State 0        State 1          State 2...             */
    CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
      CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
        CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
          CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
            CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
              CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
                CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
                  CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
                    CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
                      CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
                        CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
                          CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
                            CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
    CStateShutdown,
      CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
        CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
          CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
            CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
              CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
                CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 1  CEventDoInitalize                                           */
    CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
      CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
        CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
          CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
            CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
              CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
                CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
                  CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
                    CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
                      CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
                        CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
                          CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
                            CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
    CStateInitialize,
      CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
        CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
          CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
            CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
              CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
                CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 2  CEventInitChipSuccess                                                    */
    0,0,CStateInitFM,0,0,
      0,0,0,0,0,
        0,0,CStateNormal,0,0,
#ifdef NPORT_STUFF
          CStateInitFM,CStateInitFM,0,0,0,
#else /* NPORT_STUFF */
          0,CStateInitFM,0,0,0,
#endif /* NPORT_STUFF */
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,

    0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 3  CEventInitalizeFailure                                                    */
    0,0,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,
      0,0,CStateInitializeFailed,0,0,
        CStateInitializeFailed,0,CStateResetNeeded,CStateInitializeFailed,CStateInitializeFailed,
          CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,CStateResetNeeded,CStateInitializeFailed,
            CStateInitializeFailed,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 4  CEventInitFMSuccess                                                    */
    0,0,0,CStateInitDataStructs,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,CStateLoopFailedReInit,CStateInitDataStructs,0,CStateElasticStoreEventStorm,
            CStateLIPEventStorm,0,0,0,0,
              0,CStateInitDataStructs,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 5  CEventInitFMFailure                                                    */
    0,0,0,CStateInitializeFailed,0,
      0,0,0,0,0,
        0,0,0,CStateInitializeFailed,0,
          0,0,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,
            CStateInitializeFailed,0,0,0,0,
              0,CStateInitializeFailed,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 6   CEventDataInitalizeSuccess                         */
    0,0,0,0,CStateVerify_AL_PA,
      0,0,0,0,0,
        0,0,0,CStateVerify_AL_PA,0,
          0,0,CStateLoopFailedReInit,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 7   CEventAllocFlogiThread                             */
    0,0,0,0,0,
      CStateAllocFlogiThread,0,0,0,0,
        0,0,0,CStateResetNeeded,0,
          0,CStateAllocFlogiThread,CStateLoopFailedReInit,0,CStateElasticStoreEventStorm,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 8   CEventGotFlogiThread                               */
    0,0,0,0,0,
      0,CStateDoFlogi,CStateDoFlogi,0,0,
        0,CStateResetNeeded,0,CStateResetNeeded,0,
          0,0,CStateLoopFailedReInit,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 9    CEventFlogiSuccess                                */
    0,0,0,0,0,
      0,0,CStateFlogiSuccess,0,0,
        0,0,0,CStateResetNeeded,0,
          0,0,CStateLoopFailedReInit,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 10  A CEventFlogiFail                                  */
    0,0,0,0,0,
      0,0,CStateFreeSFthread,0,0,
        0,0,0,CStateFreeSFthread,0,
          0,0,CStateLoopFailedReInit,0,CStateElasticStoreEventStorm,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 11  B  CEventSameALPA                                  */
    0,0,0,0,0,
      0,CStateSuccess,0,CStateSuccess,0,
        CStateSuccess,0,0,CStateLoopFailedReInit,0,
          0,0,CStateLoopFailedReInit,0,0,
            0,0,0,0,0,
              0,CStateSuccess,0,0,0,
                0,0,0,0,0,
                  CStateSuccess,0,0,0,0,
                    CStateSuccess,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 12  C  CEventChangedALPA                               */
    0,0,0,0,0, 0,0,0,CStateALPADifferent,0,         0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 13  D  CEventInitalizeSuccess                          */
    0,0,0,0,0,
      0,0,0,0,0,
        CStateResetNeeded,CStateFindDevice,0,CStateResetNeeded,CStateInitialize,
          CStateInitialize,CStateInitialize,CStateInitialize,CStateSuccess,0,
            CStateResetNeeded,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,CStateFindDevice,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 14  E  CEventAsyncLoopEventDetected                    */
    CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,
      CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,
        CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,
          CStateResetNeeded,CStateResetNeeded,CStateLoopFailedReInit,CStateResetNeeded,CStateResetNeeded,
            CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,
              CStateResetNeeded,CStateResetNeeded,0,CStateResetNeeded,0,
                CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,
                  0,CStateResetNeeded,CStateResetNeeded,0,CStateResetNeeded,
                    CStateResetNeeded,CStateResetNeeded,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 15  F  CEventResetDetected                             */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,CStateLoopFail,CStateLoopFail,0,
          0,CStateLoopFailedReInit,0,0,0,
            0,0,0,0,0,
              CStateLoopFail,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 16  10  CEventResetNotNeeded                           */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 17  11  CEventResetIfNeeded                            */
    CStateInitialize,0,0,0,0,
      0,0,0,0,0,
        0,0,CStateNormal,CStateLoopFail,CStateLoopFail,
          CStateInitialize,CStateInitialize,CStateInitialize,0,0,
            CStateInitialize,0,CStateExternalLogoutRecovery,0,0,
              0,CStateInitialize,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 18  12  CEventLoopEventDetected                        */
    0,CStateResetNeeded,CStateResetNeeded,0,CStateLoopFail,
      CStateResetNeeded,0,0,0,0,
        0,0,CStateResetNeeded,CStateLoopFail,0,
          0,CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,
            CStateResetNeeded,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,CStateResetNeeded,CStateResetNeeded,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 19  13  CEventLoopConditionCleared                     */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateInitDataStructs,CStateInitDataStructs,
          0,0,CStateResetNeeded,0,CStateElasticStoreEventStorm,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 20  14  CEventLoopNeedsReinit                          */
    0,0,0,CStateLoopFailedReInit,CStateResetNeeded,
      CStateLoopFailedReInit,0,CStateLoopFailedReInit,0,0,
        CStateLoopFailedReInit,CStateResetNeeded,CStateLoopFailedReInit,CStateLoopFailedReInit,CStateReInitFM,
          CStateLoopFailedReInit,CStateLoopFailedReInit,CStateResetNeeded,CStateLoopFailedReInit,CStateElasticStoreEventStorm,
            CStateLIPEventStorm,CStateLoopFailedReInit,0,0,0,
              CStateLoopFailedReInit,CStateLoopFailedReInit,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 21  15   CEventReInitFMSuccess                         */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,CStateInitDataStructs,0, CStateInitDataStructs,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 22  16   CEventReInitFMFailure                         */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateInitialize,0,
          CStateInitialize,0,CStateLoopFailedReInit,0,CStateInitialize,
            CStateInitialize,0,CStateLoopFailedReInit,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 23  17   CEventNextDevice                              */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,CStateSuccess,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 24  18    CEventDeviceListEmpty                        */
    0,0,0,0,0,
      0,0,0,CStateResetNeeded,0,
        CStateNormal,0,CStateResetNeeded,CStateResetNeeded,0,
          0,0,CStateNormal,CStateNormal,CStateNormal,
            CStateNormal,0,0,CStateNormal,CStateNormal,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,CStateNormal,CStateNormal,0,0,
                    0,CStateNormal,CStateNormal,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 25   19     CEventElasticStoreEventStorm               */
    CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,
      CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,
        CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,
          CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,
            CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,
              CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,
                0,CStateElasticStoreEventStorm,0,0,0,
                  0,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 26   1A     CEventLIPEventStorm                        */
    CStateLIPEventStorm,CStateLIPEventStorm,CStateLIPEventStorm,CStateLIPEventStorm,CStateLIPEventStorm,
      CStateLIPEventStorm,CStateLIPEventStorm,CStateLIPEventStorm,CStateLIPEventStorm,CStateLIPEventStorm,
        CStateLIPEventStorm,CStateLIPEventStorm,CStateLIPEventStorm,CStateLIPEventStorm,CStateLIPEventStorm,
          CStateLIPEventStorm,CStateLIPEventStorm,CStateLIPEventStorm,CStateLIPEventStorm,CStateLIPEventStorm,
            CStateLIPEventStorm,CStateLIPEventStorm,CStateLIPEventStorm,CStateLIPEventStorm,CStateLIPEventStorm,
              0,CStateLIPEventStorm,0,0,0,
                0,0,0,0,0,
                  0,CStateLIPEventStorm,CStateLIPEventStorm,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 27   1B  CEvent_AL_PA_BAD                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 28   1B     CEventExternalDeviceReset                 */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,CStateExternalDeviceReset,0,0,
          0,0,CStateLoopFailedReInit,CStateResetNeeded,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 29 CEventExternalLogout                                */
    0,0,0,0,0,
      CStateVerify_AL_PA,0,0,0,0,
        0,0,CStateExternalLogout,0,0,
          0,0,0,CStateResetNeeded,0,
            0,0,0,0,0,
              0,0,0,0,CStateResetNeeded,
                0,0,0,0,0,
                  0,CStateResetNeeded,CStateResetNeeded,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 30  CEventDoExternalDeviceReset                                                   */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,CStateDoExternalDeviceReset,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 31  CEventSendPrimitive                                                   */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateLoopFail,0,
          0,CStateSendPrimitive,CStateSendPrimitive,0,CStateSendPrimitive,
            CStateSendPrimitive,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 32 CEventDelay_for_FM_init         32           */
    0,0,0,CStateInitFM_DelayDone,0,
      0,0,0,0,0,
        0,0,0,CStateResetNeeded,0,
          CStateInitFM_DelayDone,CStateInitializeFailed,CStateInitFM_DelayDone,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 33   CEventAllocRFT_IDThread                                                  */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateResetNeeded,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,CStateAllocRFT_IDThread,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 34 CEventDoRFT_ID                                                   */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateResetNeeded,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,CStateDoRFT_ID,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 35 CEventRFT_IDSuccess                                                   */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateResetNeeded,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,CStateRFT_IDSuccess,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 36 CEventRFT_IDFail                                                   */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateResetNeeded,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,CStateFreeSFthread,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 37   CEventAllocDiPlogiThread                                                  */
    0,0,0,0,0,
      0,0,0,CStateAllocDiPlogiThread,0,
        0,0,CStateAllocDiPlogiThread,CStateResetNeeded,CStateResetNeeded,
          0,0,CStateInitialize,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,CStateAllocDiPlogiThread,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 38 CEventDoDiPlogi                                                    */
    0,0,0,0,0,
      0,0,0,CStateDoDiPlogi,0,
        0,0,0,CStateResetNeeded,CStateResetNeeded,
          0,0,CStateInitialize,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                CStateDoDiPlogi,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 39 CEventDiPlogiSuccess                                                   */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateResetNeeded,CStateResetNeeded,
          0,0,CStateInitialize,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,CStateDiPlogiSuccess,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 40 CEventDoDiFailed                                                   */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateResetNeeded,CStateResetNeeded,
          0,CStateResetNeeded,CStateInitialize,0,CStateElasticStoreEventStorm,
            0,0,0,0,0,
              0,0,0,0,0,
                0,CStateFreeSFthread,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 41 CEventAllocGID_FTThread */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateResetNeeded,CStateResetNeeded,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,CStateAllocGID_FTThread,
                0,0,0,0,0, /* State 32 CStateDiPlogiSuccess*/
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
     /* Event 42 CEventDoGID_FT    */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateResetNeeded,CStateResetNeeded,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,CStateDoGID_FT,0,  /* State 33 CStateAllocGID_FTThread */
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 43 CEventGID_FTSuccess     */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateResetNeeded,CStateResetNeeded,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,CStateGID_FTSuccess,    /* State 34 CStateDoGID_FT */
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 44 CEventGID_FTFail        */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateResetNeeded,CStateResetNeeded,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,CStateFreeSFthread,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 45 CEventFindDeviceUseNameServer                                                  */
    0,0,0,0,0,
      0,0,0,0,0,
        0,CStateFindDeviceUseNameServer,0,CStateResetNeeded,CStateResetNeeded,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 46 CEventFindDeviceUseLoopMap                                                     */
    0,0,0,0,0,
      0,0,0,0,0,
        0,CStateFindDeviceUseLoopMap,0,CStateResetNeeded,CStateResetNeeded,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,CStateFindDeviceUseLoopMap,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 47 CEventAllocSCRThread */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateResetNeeded,CStateResetNeeded,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  CStateAllocSCRThread,0,0,0,0,/* State 35 CStateGID_FTSuccess*/
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
 /* Event 48 CEventDoSCR    */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateResetNeeded,CStateResetNeeded,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,CStateDoSCR,0,/* State 38 CStateDoSCRThread */
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 49 CEventSCRSuccess     */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateResetNeeded,CStateResetNeeded,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,CStateSCRSuccess,/* State 39 CStateDoSCR */
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 50 CEventSCRFail        */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateResetNeeded,CStateResetNeeded,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,CStateFreeSFthread,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 51 CEventRSCNErrorBackIOs */
    0,0,0,0,0,
      0,0,0,CStateRSCNErrorBackIOs,0,
        0,0,CStateRSCNErrorBackIOs,CStateResetNeeded,CStateResetNeeded,
          0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
            0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 52 CEventFindPtToPtDevice                                                  */
    0,0,0,0,0,
      0,0,0,0,0,
        CStateFindPtToPtDevice,0,0,CStateResetNeeded,CStateResetNeeded,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 53   CEventClearHardwareFoulup                     */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateInitializeFailed,0,
          0,0,0,0,CStateVerify_AL_PA,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 54 CEventFlipNPortState                             */
    0,0,0,0,0, 
      0,0,0,0,0, 
        0,0,CStateFlipNPortState,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 55   CEventGoToInitializeFailed                     */
    0,0,0,0,0, 
      0,0,CStateInitializeFailed,0,0, 
        0,0,CStateResetNeeded,CStateInitializeFailed,CStateInitializeFailed,
          CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,
            CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,
              CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,
                CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,
                  CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,
                    CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,
                      CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 56                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 57                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 58                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 59                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 60                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 61                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 62                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 63                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 64                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 65                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 66                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 67                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 68                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 69                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 70                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 71                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 72                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 73                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 74                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 75                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 76                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 77                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 78                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 79                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 80                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 81                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 82                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 83                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 84                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 85                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 86                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 87                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 88                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 89                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 90                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 91                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 92                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 93                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 94                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 95                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 96                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 97                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 98                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 99                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 100                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 101                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 102                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 103                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 104                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 105                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 106                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 107                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 108                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 109                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 110                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 111                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 112                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 113                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 114                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 115                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 116                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 117                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 118                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 119                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 120                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 121                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 122                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 123                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 124                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 125                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 126                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 127                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    };

/*
stateTransitionMatrix_t copiedCStateTransitionMatrix;
*/
stateActionScalar_t CStateActionScalar = {
    &CActionConfused,                /*   CStateConfused              0      */
    &CActionShutdown,                /*   CStateShutdown              1      */
    &CActionInitialize,              /*   CStateInitialize            2      */
    &CActionInitFM,                  /*   CStateInitFM                3      */
    &CActionInitDataStructs,         /*   CStateInitDataStructs       4      */
    &CActionVerify_AL_PA,            /*   CStateVerify_AL_PA          5      */
    &CActionAllocFlogiThread,        /*   CStateAllocFlogiThread      6      */
    &CActionDoFlogi,                 /*   CStateDoFlogi               7      */
    &CActionFlogiSuccess,            /*   CStateFlogiSuccess          8      */
    &CActionALPADifferent,           /*   CStateALPADifferent         9      */
    &CActionFreeSFthread,            /*   CStateFreeSFthread          10     */
    &CActionSuccess,                 /*   CStateSuccess               11     */
    &CActionNormal,                  /*   CStateNormal                12     */
    &CActionResetNeeded,             /*   CStateResetNeeded           13     */
    &CActionLoopFail,                /*   CStateLoopFail              14     */
    &CActionReInitFM,                /*   CStateReInitFM              15     */
    &CActionInitializeFailed,        /*   CStateInitializeFailed      16     */
    &CActionLoopFailedReInit,
    &CActionFindDeviceUseAllALPAs,
    &CActionElasticStoreEventStorm,
    &CActionLIPEventStorm,
    &CActionExternalDeviceReset,
    &CActionExternalLogout,
    &CActionExternalLogoutRecovery,
    &CActionDoExternalDeviceReset,
    &CActionSendPrimitive,
    &CActionInitFM_DelayDone,
    &CActionAllocRFT_IDThread,    /* CStateAllocRFT_ID   27      */
    &CActionDoRFT_ID,             /* CStateDoRFT_ID      28      */
    &CActionRFT_IDSuccess,        /* CStateRFT_IDSuccess 29      */
    &CActionAllocDiPlogiThread,
    &CActionDoDiPlogi,
    &CActionDiPlogiSuccess,
    &CActionAllocGID_FTThread,    /* CStateAllocGID_FT   33      */
    &CActionDoGID_FT,             /* CStateDoGID_FT      34      */
    &CActionGID_FTSuccess,        /* CStateGID_FTSuccess 35      */
    &CActionFindDeviceUseNameServer,
    &CActionFindDeviceUseLoopMap,
    &CActionAllocSCRThread,     /* CStateAllocSCRThread 38      */
    &CActionDoSCR,              /* CStateDoSCR          39      */
    &CActionSCRSuccess,         /* CStateSCRSuccess     40      */
    &CActionRSCNErrorBackIOs,   /* CStateRSCNErrorBackIOs 41    */
    &CActionFindPtToPtDevice,
    &CActionFlipNPortState,
    &CActionConfused,
    &CActionConfused,
    &CActionConfused,
    &CActionConfused,
    };

/*
stateActionScalar_t copiedCStateActionScalar;
*/
#define testCompareBase 0x00000110

#ifndef __State_Force_Static_State_Tables__
extern actionUpdate_t noActionUpdate;
#endif /* __State_Force_Static_State_Tables__ was not defined */

extern os_bit8 Alpa_Index[256];

#ifndef __State_Force_Static_State_Tables__
actionUpdate_t testCActionUpdate[] = {
                              0,          0,      agNULL,                 agNULL
                     };
#endif /* __State_Force_Static_State_Tables__ was not defined */

#ifndef USESTATEMACROS
/*+
  Function: CActionConfused
   Purpose: Terminating State for error detection 
 Called By: Any State/Event pair that does not have an assigned action.
            This function is called only in programming error condtions.
     Calls: CFuncYellowLed to indicate link down
-*/
/*CStateConfused      0 */
extern void CActionConfused( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogString(thread->hpRoot,
                    "CActionConfused",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p)In %s - State = %d",
                    "CActionConfused",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: CActionShutdown
   Purpose: Terminating State shutdown condtion.
 Called By: Any State/Event pair that does not have an assigned action.
            This function is called only in programming error condtions.
     Calls: CFuncYellowLed to indicate link down
-*/
/* CStateShutdown              1*/
extern void CActionShutdown( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    agRoot_t  *hpRoot  = thread->hpRoot;

    CFuncYellowLed(hpRoot, agFALSE);

    faSingleThreadedLeave( hpRoot, CStateShutdown  );

    osFCLayerAsyncEvent( hpRoot, osFCLinkDown );

    faSingleThreadedEnter( hpRoot , CStateShutdown  );

    CFuncCompleteAllActiveCDBThreads( hpRoot,osIOFailed,CDBEventIODeviceReset );

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) In %s - State = %d",
                    "CActionShutdown",(char *)agNULL,
                    hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiLogString(hpRoot,
                    "%s FM Stat %08X LPS %x",
                    "CActionShutdown",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    CThread_ptr(hpRoot)->LoopPreviousSuccess,
                    0,0,0,0,0,0);
    /* CThread->sysIntsActive = agFALSE; */

    osChipIOUpWriteBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration,
            (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ) | 
                                 ChipIOUp_Frame_Manager_Configuration_ELB     ));

    osStallThread(hpRoot, 200);

    osChipIOUpWriteBit32(hpRoot, ChipIOUp_Frame_Manager_Control,
                  ChipIOUp_Frame_Manager_Control_CMD_Offline );


    osChipIOUpWriteBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration,
            (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ) & 
                                 ~ChipIOUp_Frame_Manager_Configuration_ELB     )); 
    

    CFuncDisable_Interrupts(hpRoot,ChipIOUp_INTEN_MASK);

    fiSetEventRecordNull(eventRecord);
}
/*+
  Function: CActionInitialize
   Purpose: Begining of Channel Initialation brings data structures to a known state.
            Resets Chip.
 Called By: CEventDoInitalize
     Calls: CFuncYellowLed to indicate link down
            fiTimerSvcInit
            PktThreadsInitializeFreeList
            TgtThreadsInitializeFreeList
            DevThreadsInitializeFreeList
            CDBThreadsInitializeFreeList
            SFThreadsInitializeFreeList
            ESGLInitializeFreeList
            CFuncInit_DevLists
            CFuncInit_Threads
            osFCLayerAsyncEvent
            CFuncSoftResetAdapterNoStall
            CFuncInitFM_Registers
            fiTimerStart
            CEventInitChipSuccess
            osStallThread
            fiTimerTick

-*/
/*CStateInitialize            2*/
extern void CActionInitialize( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    agRoot_t   *    hpRoot          = thread->hpRoot;
    CThread_t  *    pCThread        = CThread_ptr(hpRoot);

#ifdef OSLayer_NT
     os_bit32           Hard_Stall      = 0;
#endif /* OSLayer_NT */

    pCThread->Flogi_AllocDone = agFALSE;
/*
    pCThread->InitAsNport = pCThread->Calculation.Parameters.InitAsNport;
    pCThread->RelyOnLossSyncStatus = pCThread->Calculation.Parameters.RelyOnLossSyncStatus;
*/
    pCThread->FlogiRcvdFromTarget = agFALSE;
    pCThread->FoundActiveDevicesBefore = agFALSE;
    pCThread->ALPA_Changed_OnLinkEvent = agFALSE;
    pCThread->FlogiTimedOut = agFALSE;
    pCThread->ReScanForDevices = agFALSE;
    pCThread->DirectoryServicesFailed = agFALSE;
    pCThread->NumberOfPlogiTimeouts = 0;
    pCThread->NumberOfFLOGITimeouts = 0;
    pCThread->RSCNreceived = agFALSE;

    fiLogString( hpRoot,
                    "%p %s St %d InIMQ %x InitAsNport %x MY_ID %X",
                    "CAI",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->ProcessingIMQ,
                    pCThread->InitAsNport,
                    (os_bit32)fiComputeCThread_S_ID(pCThread),
                    0,0,0,0);

    if(pCThread->ProcessingIMQ)
    {
        pCThread->Loop_Reset_Event_to_Send = CEventDoInitalize;
        fiSetEventRecord(eventRecord,thread, CEventLoopEventDetected );
        return;
    }

    CFuncYellowLed(hpRoot, agFALSE);
    if( pCThread->LoopPreviousSuccess)
    {
        CFuncCompleteAllActiveCDBThreads( hpRoot,osIOAborted,CDBEventIODeviceReset );
    }
    /*+
    +  CFuncReadGBICSerEprom( hpRoot);
    +*/
    if( pCThread->DeviceSelf != agNULL)
    {
        DevThreadFree(hpRoot,pCThread->DeviceSelf);
        pCThread->DeviceSelf = (DevThread_t *)agNULL;
        CFuncQuietShowWhereDevThreadsAre( hpRoot);

        fiLogString(hpRoot,
                    "I DevThreadFree Was %X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeCThread_S_ID(pCThread),
                    0,0,0,0,0,0,0);

    }

    pCThread->FindDEV_pollingCount = 0;
    pCThread->ADISC_pollingCount   = 0;
    pCThread->DEVReset_pollingCount= 0;

    pCThread->DeviceDiscoveryMethod = DDiscoveryMethodInvalid;

    fiTimerSvcInit(hpRoot);

#ifdef _DvrArch_1_30_
    PktThreadsInitializeFreeList( hpRoot );
#endif /* _DvrArch_1_30_ was defined */

    TgtThreadsInitializeFreeList( hpRoot );

    DevThreadsInitializeFreeList( hpRoot );

    CDBThreadsInitializeFreeList( hpRoot );

    SFThreadsInitializeFreeList( hpRoot );

    ESGLInitializeFreeList( hpRoot );

    CFuncInit_DevLists( hpRoot );

    CFuncInit_Threads( hpRoot );

    faSingleThreadedLeave( hpRoot ,CStateInitialize );

    osFCLayerAsyncEvent( hpRoot, osFCLinkDown );

    faSingleThreadedEnter( hpRoot ,CStateInitialize );

    CFuncSoftResetAdapterNoStall(hpRoot);

    if( pCThread->TwoGigSuccessfull )
    {
        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration_3,  ( ChipIOUp_Frame_Manager_Configuration_3_2Gig_TXS |  ChipIOUp_Frame_Manager_Configuration_3_2Gig_RXS ) );
    }

    CFuncInitFM_Registers( hpRoot , agFALSE);

    if( pCThread->NoStallTimerTickActive )
    {
        if(! fiListElementOnList( (fiList_t *)(&(pCThread->Timer_Request)),
                                       &(pCThread->TimerQ)))
        {
            fiLogDebugString( hpRoot,
                                CStateLogConsoleERROR,
                                "hpRoot %p Soft Stall In %s - State = %d InIMQ %x",
                                "CActionInitialize",(char *)agNULL,
                                thread->hpRoot,(void *)agNULL,
                                (os_bit32)thread->currentState,
                                pCThread->ProcessingIMQ,
                                0,0,0,0,0,0);

            fiSetEventRecordNull(eventRecord);

            fiTimerSetDeadlineFromNow(thread->hpRoot, &pCThread->Timer_Request, CResetChipDelay);

            pCThread->Timer_Request.eventRecord_to_send.thread= thread;
            pCThread->Timer_Request.eventRecord_to_send.event = CEventInitChipSuccess;

            fiTimerStart(thread->hpRoot,&pCThread->Timer_Request);
            return;
        }
    }
    else
    {
        CFuncDisable_Interrupts(thread->hpRoot,ChipIOUp_INTEN_MASK); /*DRL*/

/*
        Hard_Stall = ( CResetChipDelay / Interrupt_Polling_osStallThread_Parameter ) * Interrupt_Polling_osStallThread_Parameter;
        fiLogDebugString( hpRoot,
                                CStateLogConsoleERROR,
                                "hpRoot %p Hard Stall %d In %s - State = %d InIMQ %x",
                                "CActionInitialize",(char *)agNULL,
                                thread->hpRoot,(void *)agNULL,
                                Hard_Stall,
                                (os_bit32)thread->currentState,
                                pCThread->ProcessingIMQ,
                                0,0,0,0,0);
*/
#ifndef OSLayer_NT

            osStallThread( hpRoot, CResetChipDelay );

            fiTimerTick(hpRoot,CResetChipDelay );

#else /* ~OSLayer_NT */
        Hard_Stall = ( CResetChipDelay / Interrupt_Polling_osStallThread_Parameter ) * Interrupt_Polling_osStallThread_Parameter;
        while( Hard_Stall > Interrupt_Polling_osStallThread_Parameter )
        {
            osStallThread( hpRoot,Interrupt_Polling_osStallThread_Parameter);

            fiTimerTick( hpRoot,Interrupt_Polling_osStallThread_Parameter );
            Hard_Stall-=Interrupt_Polling_osStallThread_Parameter;
        }
#endif /* ~OSLayer_NT */

        fiSetEventRecord(eventRecord,thread, CEventInitChipSuccess );
    }

    fiLogString(hpRoot,
                    "Out %p %s FM Stat %08X LPS %x MY_ID %x",
                    "CAI",(char *)agNULL,
                    pCThread->DeviceSelf,(void *)agNULL,
                    (os_bit32)osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    pCThread->LoopPreviousSuccess,
                    (os_bit32)fiComputeCThread_S_ID(pCThread),
                    0,0,0,0,0);


}

/*+
  Function: CActionInitFM
   Purpose: Initializes chip and Frame manager pCThread->LaserEnable flag set
            to turn on transitter. InitAsNport evalulated to determine chip 
            configuration.Phyical expected to be up on exit for this function.
            Unless NoStallTimerTickActive is set.
            For XL2 link speed set.
            
 Called By: CEventInitChipSuccess
     Calls: CFuncYellowLed to indicate link down
            CFuncInitChip
            osFCLayerAsyncEvent
            CFuncInitFM_Registers
            fiTimerStart
            osStallThread
            fiTimerTick
            CFuncDoLinkSpeedNegotiation
            CEventInitalizeFailure
            CEventDelay_for_FM_init
-*/

/*CStateInitFM                3*/
extern void CActionInitFM( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t   * hpRoot    = thread->hpRoot;
    CThread_t  * pCThread  = CThread_ptr(hpRoot);
    os_bit32    Hard_Stall = 0;
    os_bit32    FM_Status  = 0;

    agBOOLEAN Success = agFALSE;

    CFuncYellowLed(hpRoot, agFALSE);

    faSingleThreadedLeave( hpRoot , CStateInitFM);

    osFCLayerAsyncEvent( hpRoot, osFCLinkDown );

    faSingleThreadedEnter( hpRoot , CStateInitFM);

    fiLogDebugString( hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p Begin %s - State = %d InIMQ %x",
                    "CAIFM",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->ProcessingIMQ,
                    0,0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "A %s HA %x CA %x",
                    "CAIFM",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)(pCThread->ChanInfo.HardAddress.AL_PA),
                    (os_bit32)(pCThread->ChanInfo.CurrentAddress.AL_PA),
                    0,0,0,0,0,0);


#ifdef NPORT_STUFF
    /* Make sure, we turn off the ConnectedToNportOrFPort flag to agFALSE since
     * We are initing FM.
     */

    pCThread->ConnectedToNportOrFPort = agFALSE;
#endif   /* NPORT_STUFF */
    pCThread->FlogiSucceeded          = agFALSE;
    pCThread->Loop_Reset_Event_to_Send = CEventDoInitalize;

    if(!CFuncInitChip( hpRoot ))
    {
        fiSetEventRecord(eventRecord,thread, CEventInitalizeFailure );
        return;
    }

    pCThread->Flogi_AllocDone = agFALSE;

    pCThread->FM_pollingCount = 0;

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After In %s - State = %d FM %08X",
                    "CAIFM",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0,0,0,0);

    if(fiListElementOnList( (fiList_t *)(&(pCThread->Timer_Request)),
                                   &(pCThread->TimerQ)))
    {
        fiTimerStop(&pCThread->Timer_Request);
    }


    if( ! pCThread->LaserEnable )
    {
        pCThread->LaserEnable = agTRUE;
    
        fiLogDebugString(hpRoot,
                            CFuncLogConsoleERROR,
                            "%s %s Now",
                            "CAIFM","LaserEnable",
                            (void *)agNULL,(void *)agNULL,
                            0,0,0,0,0,0,0,0);
    }

    fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "B %s HA %x CA %x",
                    "CAIFM",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)(pCThread->ChanInfo.HardAddress.AL_PA),
                    (os_bit32)(pCThread->ChanInfo.CurrentAddress.AL_PA),
                    0,0,0,0,0,0);

    CFuncYellowLed( hpRoot, agFALSE);

    faSingleThreadedLeave( hpRoot , CStateInitFM );

    osFCLayerAsyncEvent( hpRoot, osFCLinkDown );

    faSingleThreadedEnter( hpRoot, CStateInitFM );

    osStallThread( hpRoot, 10 );
/*
    pCThread->TwoGigSuccessfull = CFuncDoLinkSpeedNegotiation( hpRoot);
*/
    pCThread->LoopPreviousSuccess = agFALSE;

    CFuncInitFM_Registers( hpRoot , agTRUE);

/**/
    if (pCThread->InitAsNport)
    {
        Hard_Stall = Init_FM_NPORT_Delay_Count;
        while( Hard_Stall > 1  )
        {
            FM_Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );
        
            if( (FM_Status & ChipIOUp_Frame_Manager_Status_PSM_MASK) ==
                                     ChipIOUp_Frame_Manager_Status_PSM_ACTIVE )
            {
                Success = agTRUE;
                break;        
            }

            if( (FM_Status & \
                ( ChipIOUp_Frame_Manager_Status_NP | ChipIOUp_Frame_Manager_Status_OS | ChipIOUp_Frame_Manager_Status_LS )\
                 ) == \
                ( ChipIOUp_Frame_Manager_Status_NP | ChipIOUp_Frame_Manager_Status_OS | ChipIOUp_Frame_Manager_Status_LS )  )
            {

                if( (FM_Status & ChipIOUp_Frame_Manager_Status_PSM_MASK) == ChipIOUp_Frame_Manager_Status_PSM_LF2  )
                {

                    break;        
                }
            }


            pCThread->FuncPtrs.Proccess_IMQ(hpRoot); /* */
            osStallThread( hpRoot, 1 );
            fiTimerTick( hpRoot, 1 );
            Hard_Stall--;

            if(! (Hard_Stall % 1000))
            {
                if( (FM_Status & ChipIOUp_Frame_Manager_Status_PSM_MASK) == ChipIOUp_Frame_Manager_Status_PSM_Offline  )
                {
                    break;        
                }
                if(! (Hard_Stall % 4000))
                {
 
                    if( (FM_Status & ChipIOUp_Frame_Manager_Status_PSM_MASK) ==  ChipIOUp_Frame_Manager_Status_PSM_LF1 )
                    {
                        break;        
                    }
                    if( (FM_Status & ChipIOUp_Frame_Manager_Status_PSM_MASK) ==  ChipIOUp_Frame_Manager_Status_PSM_LF2 )
                    {
                        break;        
                    }
/*
                    if( (FM_Status & ChipIOUp_Frame_Manager_Status_PSM_MASK) ==  ChipIOUp_Frame_Manager_Status_PSM_OL1 )
                    {
                        break;        
                    }
*/
                }
            }
        }

        osChipIOUpWriteBit32(hpRoot, ChipIOUp_Frame_Manager_Status, 0xffffffff );

        fiLogDebugString(hpRoot,
                        CFuncLogConsoleERROR,
                        "%s %s FM Status %08X HS %d FM Cfg %08X FM Cfg3 %08X",
                        "CAIFM","InitAsNport",
                        (void *)agNULL,(void *)agNULL,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        Hard_Stall,
                        osChipIOUpReadBit32( hpRoot,ChipIOUp_Frame_Manager_Configuration ),
                        osChipIOUpReadBit32( hpRoot,ChipIOUp_Frame_Manager_Configuration_3 ),
                        0,0,0,0);

        if( Success == agTRUE)
        {

            fiSetEventRecord(eventRecord,thread, CEventDelay_for_FM_init );
        }
        else
        {
            fiLogString( hpRoot,
                            "%s InitAsNport %x MY_ID %x FM %08X HS %d",
                            "CAIFM",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCThread->InitAsNport,
                            (os_bit32)fiComputeCThread_S_ID(pCThread),
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                            Hard_Stall,0,0,0,0);

            fiSetEventRecord(eventRecord,thread, CEventInitalizeFailure );
        }
        return;
    }/* End InitAsNport */
 
    if( pCThread->NoStallTimerTickActive )
    {
        if(! fiListElementOnList( (fiList_t *)(&(pCThread->Timer_Request)),
                                       &(pCThread->TimerQ)))
        {
            fiLogDebugString( hpRoot,
                                CStateLogConsoleERROR,
                                "hpRoot %p Soft Stall In %s - State = %d InIMQ %x",
                                "CAIFM",(char *)agNULL,
                                thread->hpRoot,(void *)agNULL,
                                (os_bit32)thread->currentState,
                                pCThread->ProcessingIMQ,
                                0,0,0,0,0,0);

            fiSetEventRecordNull(eventRecord);

            fiTimerSetDeadlineFromNow(hpRoot, &pCThread->Timer_Request, CInitFM_Delay );

            pCThread->Timer_Request.eventRecord_to_send.thread= thread;
            pCThread->Timer_Request.eventRecord_to_send.event = CEventDelay_for_FM_init;

            fiTimerStart(hpRoot,&pCThread->Timer_Request);

            CFuncEnable_Interrupts(
                                    thread->hpRoot,
                                    (  ChipIOUp_INTEN_MPE
                                     | ChipIOUp_INTEN_CRS
                                     | ChipIOUp_INTEN_INT
                                     | ChipIOUp_INTEN_DER
                                     | ChipIOUp_INTEN_PER)
                                  );
           return;
        }
    }
    else
    {
        CFuncDisable_Interrupts(hpRoot,ChipIOUp_INTEN_MASK);/*DRL*/
        Hard_Stall = Init_FM_Delay_Count;
        while( Hard_Stall > 1  )
        {
			FM_Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );
			if(FM_Status & ChipIOUp_Frame_Manager_Status_LS)
			{
				break;
			}
            pCThread->FuncPtrs.Proccess_IMQ(hpRoot);
            if ( pCThread->DeviceSelf != agNULL)
            {
                fiLogDebugString(hpRoot,
                                CFuncLogConsoleERROR,
                                "PASS %s HA %x CA %x Hard_Stall %d",
                                "CAIFM",(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                (os_bit32)(pCThread->ChanInfo.HardAddress.AL_PA),
                                (os_bit32)(pCThread->ChanInfo.CurrentAddress.AL_PA),
                                Hard_Stall,
                                0,0,0,0,0);
                Success = agTRUE;

                break;
            }
            osStallThread( hpRoot, 1 );
            fiTimerTick( hpRoot, 1 );
            Hard_Stall--;
        }

        if ( pCThread->DeviceSelf == agNULL)
        {
        
                fiLogDebugString(hpRoot,
                                CFuncLogConsoleERROR,
                                "FAIL %s HA %x CA %x Hard_Stall %d",
                                "CAIFM",(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                (os_bit32)(pCThread->ChanInfo.HardAddress.AL_PA),
                                (os_bit32)(pCThread->ChanInfo.CurrentAddress.AL_PA),
                                Hard_Stall,
                                0,0,0,0,0);
            fiSetEventRecord(eventRecord,thread, CEventInitalizeFailure );

        }
        else
        {
            fiSetEventRecord(eventRecord,thread, CEventDelay_for_FM_init );
        }
    }

    fiLogString(hpRoot,
                "SELF %p %s My_ID %08X Success %x %d",
                "CAIFM",(char *)agNULL,
                pCThread->DeviceSelf,(void *)agNULL,
                (os_bit32)Success,
                fiComputeCThread_S_ID(pCThread),
                Hard_Stall,
                0,0,0,0,0);

    CFuncShowWhereDevThreadsAre( hpRoot );

}

/*+
  Function: CActionInitDataStructs
   Purpose: Sets chip ChipIOUp_My_ID register
            
 Called By: CEventDelay_for_FM_init
     Calls: CFuncYellowLed to indicate link down
            osChipIOUpWriteBit32
            CFuncAll_clear
-*/
/*CStateInitDataStructs       4*/
extern void CActionInitDataStructs( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    agRoot_t   *    hpRoot          = thread->hpRoot;
    CThread_t  *    pCThread        = CThread_ptr(hpRoot);
    os_bit32        My_ID           = 0;

    CFuncYellowLed(thread->hpRoot, agFALSE);

    pCThread->Loop_Reset_Event_to_Send = CEventDoInitalize;
    My_ID = fiComputeCThread_S_ID(pCThread); 

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "SELF %p In %s My_ID %08X LD %x IR %x CCnt %x InIMQ %x",
                    "CAIDS",(char *)agNULL,
                    pCThread->DeviceSelf,(void *)agNULL,
                    My_ID,
                    pCThread->LOOP_DOWN,
                    pCThread->IDLE_RECEIVED,
                    pCThread->FindDEV_pollingCount,
                    pCThread->ProcessingIMQ,
                    0,0,0);

    /* Write aquired AL_PA */
    osChipIOUpWriteBit32( hpRoot, ChipIOUp_My_ID, My_ID  );


    fiLogString(hpRoot,
                    "SELF %p %s FM %08X LPS %x AC %x My_ID %X",
                    "CAIDS",(char *)agNULL,
                    pCThread->DeviceSelf,(void *)agNULL,
                    (os_bit32)osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    pCThread->LoopPreviousSuccess,
                    CFuncAll_clear(hpRoot ),
                    (os_bit32)My_ID,
                    0,0,0,0);


#ifdef NPORT_STUFF
    if (pCThread->InitAsNport)
    {
       pCThread->ConnectedToNportOrFPort = agTRUE;
       fiSetEventRecord(eventRecord,thread, CEventDataInitalizeSuccess );
       return;
    }
#endif

    if( CFuncAll_clear(hpRoot ) )
    {
        fiSetEventRecord(eventRecord,thread, CEventDataInitalizeSuccess );
    }
    else
    {
        pCThread->Loop_Reset_Event_to_Send = CEventDoInitalize;
        fiSetEventRecord(eventRecord,thread, CEventLoopEventDetected );
    }
}

/*+
  Function: CActionVerify_AL_PA
   Purpose: Verifies chip can "talk" to it self if loop. Open and PLOGI sent, Received payload examined
            WWN is used to make sure we do not have ALPA conflict.
            Bails out if pCThread->DeviceSelf agNULL
            Bails out if NPORT
            Bails out if verify fails
            
 Called By: CEventDelay_for_FM_init
     Calls: CFuncYellowLed to indicate link down
            CFuncInterruptPoll
            DevEventLogin
            CEventAllocFlogiThread
            osChipIOUpWriteBit32
            CFuncAll_clear
            CEventAllocFlogiThread
-*/
/*CStateVerify_AL_PA             5 */
extern void CActionVerify_AL_PA( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    agRoot_t   *    hpRoot         = thread->hpRoot;
    CThread_t     * pCThread       = CThread_ptr(hpRoot);
    DevThread_t   * pDevThread     = pCThread->DeviceSelf;


    CFuncYellowLed(thread->hpRoot, agFALSE);

    faSingleThreadedLeave( hpRoot, CStateVerify_AL_PA );

    osFCLayerAsyncEvent( hpRoot, osFCLinkDown );

    faSingleThreadedEnter( hpRoot , CStateVerify_AL_PA);

/*
    pCThread->FuncPtrs.Proccess_IMQ(hpRoot);
*/
    if( pDevThread == (DevThread_t *)agNULL )
    {

        pCThread->Loop_Reset_Event_to_Send = CEventDoInitalize;

        fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "DevSelf agNULL hpRoot %p  %s - State = %d Dev State %d Loop_Reset_Event_to_Send %d",
                    "CAVA",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->Loop_Reset_Event_to_Send,
                    0,0,0,0,0,0);

        fiSetEventRecord(eventRecord,thread,CEventLoopEventDetected);
        return;
    }

#ifdef NPORT_STUFF
    if (pCThread->ConnectedToNportOrFPort)
    {
#endif   /* NPORT_STUFF */
#ifdef NAME_SERVICES
        fiSetEventRecord(eventRecord,thread,CEventAllocFlogiThread);
        fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "About to Alloc FLOGI In %s My_ID %08X",
                    "CAVA",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeCThread_S_ID(pCThread),
                    0,0,0,0,0,0,0);

        return;
#endif   /* NAME_SERVICES */
#ifdef NPORT_STUFF
    }
#endif   /* NPORT_STUFF */

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p  %s - State = %d Dev State %d Self %p FDCnt %x",
                    "CAVA",(char *)agNULL,
                    thread->hpRoot,pDevThread,
                    (os_bit32)thread->currentState,
                    pDevThread->thread_hdr.currentState,
                    pCThread->FindDEV_pollingCount,
                    0,0,0,0,0);

    pDevThread->Plogi_Reason_Code = PLOGI_REASON_VERIFY_ALPA;

    fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);

    if(CFuncInterruptPoll( hpRoot,&pCThread->FindDEV_pollingCount ))
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Find Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "In %s - State = %d   ALPA %X FDCCnt %x",
                    "CAVA",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCThread->FindDEV_pollingCount,0,0,0,0,0);

    }


    if(pDevThread->thread_hdr.currentState == DevStateDoPlogi )
    {
        fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "DEV STATE WRONG",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
    }


    if(pDevThread->thread_hdr.currentState == DevStateAL_PA_Self_OK  ||
       pDevThread->thread_hdr.currentState == DevStateHandleAvailable  )
    {
        pCThread->PreviouslyAquiredALPA = agTRUE;

        fiSetEventRecord(eventRecord,thread,CEventAllocFlogiThread);
    }
    else
    {

        fiLogString(hpRoot,
                    "%s FM %08X CFG %08X Dev S %d AC %x",
                    "CAVA",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    (os_bit32)osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    pDevThread->thread_hdr.currentState,
                    CFuncAll_clear(hpRoot ),
                    0,0,0,0);

        fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "DEV STATE WRONG %d Reinit !!!",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pDevThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);
        pCThread->PreviouslyAquiredALPA = agFALSE;

        DevThreadFree(hpRoot,pCThread->DeviceSelf);
        pCThread->DeviceSelf = (DevThread_t *)agNULL;
        fiLogString(hpRoot,
                    "V DevThreadFree %X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeCThread_S_ID(pCThread),
                    0,0,0,0,0,0,0);

        pCThread->Loop_Reset_Event_to_Send = CEventDoInitalize;
        fiSetEventRecord(eventRecord,thread,CEventLoopEventDetected);
    }
    CFuncQuietShowWhereDevThreadsAre( hpRoot);

/*
    CFuncShowWhereDevThreadsAre( hpRoot, agTRUE );
*/
    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After %s - State = %d Dev State %d Self %p",
                    "CAVA",(char *)agNULL,
                    thread->hpRoot,
                    pDevThread,
                    (os_bit32)thread->currentState,
                    pDevThread->thread_hdr.currentState,
                    0,0,0,0,0,0);

    fiLogString(hpRoot,
                    "SELF %p %s FM %08X LPS %x AC %x E %d",
                    "CAVA",(char *)agNULL,
                    pCThread->DeviceSelf,(void *)agNULL,
                    (os_bit32)osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    pCThread->LoopPreviousSuccess,
                    CFuncAll_clear(hpRoot ),
                    eventRecord->event,
                    0,0,0,0);


}


/*+
  Function: CActionAllocFlogiThread
   Purpose: Allocates recource for Fabric Login. Release old SFThread if still in use
            Proceddes to next state when sfthread is allocated.
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            SFThreadFree
            CEventSameALPA
            CEventGotFlogiThread
            CFuncDisable_Interrupts
            SFThreadAlloc

-*/
/* CStateAllocFlogiThread      6*/
extern void CActionAllocFlogiThread( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t *hpRoot= thread->hpRoot;

    CThread_t  * pCThread = CThread_ptr( hpRoot);

    SFThread_t  * pSFThread = pCThread->SFThread_Request.SFThread;

    /* If an FLOGI was already in progress and we reinit the loop,
     * we need to free the old SFThread and get a new one. */
    CFuncYellowLed(thread->hpRoot, agFALSE);

    pCThread->FLOGI_pollingCount  = 0;
    pCThread->Fabric_pollingCount = 0;

    if(pSFThread != (SFThread_t *) agNULL)
    {
        if( pCThread->SFThread_Request.State == SFThread_Request_Granted)
        {
            fiLogDebugString(thread->hpRoot,
                CStateLogConsoleERROR,
                "pCThread %p Freeing SFThread in %s ",
                "CActionAllocFlogiThread",(char *)agNULL,
                pCThread,(void *)agNULL,
                0,0,0,0,0,0,0,0);

            SFThreadFree( hpRoot, &pCThread->SFThread_Request );
            pCThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;
        }
    }


#ifdef Tachlite_works
    if(!(pCThread->FabricLoginRequired))
        fiSetEventRecord(eventRecord,thread,CEventSameALPA);

    else
    {
#endif   /* Tachlite_works */

        pCThread->SFThread_Request.eventRecord_to_send.event = CEventGotFlogiThread;
        pCThread->SFThread_Request.eventRecord_to_send.thread = thread;



        fiLogDebugString(thread->hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot %p After In %s - State = %d My_ID %08X",
                        "CActionAllocFlogiThread",(char *)agNULL,
                        thread->hpRoot,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        fiComputeCThread_S_ID(pCThread),
                        0,0,0,0,0,0);

        fiSetEventRecordNull(eventRecord);

        CFuncDisable_Interrupts(thread->hpRoot,ChipIOUp_INTEN_MASK);

        SFThreadAlloc( hpRoot,&pCThread->SFThread_Request );

#ifdef Tachlite_works
    }
#endif   /* Tachlite_works */

}

/*+
  Function: CActionDoFlogi
   Purpose: Executes fabric login. This action determines what type of driver - loop or fabric.
            If we are on a loop Flogi fails with bad ALPA otherwise any other response
            indicates a switch is connected. 
            SFStateFlogiAccept   Good switch response continue 
            SFStateFlogiRej      Good switch response Adjust paramaters and retry FLOGI
            SFStateDoFlogi:      Bad response retry FLOGI
            SFStateFlogiTimedOut Bad response retry FLOGI
            SFStateFlogiBadALPA  Good loop response continue

 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncShowWhereDevThreadsAre
            SFEventDoFlogi
            CFuncInterruptPoll
            CEventFlogiSuccess
            CEventGotFlogiThread
            CEventFlogiFail
            CEventAsyncLoopEventDetected
-*/
/*CStateDoFlogi               7*/
extern void CActionDoFlogi( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t  * hpRoot   = thread->hpRoot;
    CThread_t * pCThread = CThread_ptr( hpRoot);
    os_bit32 SFthreadState = 0;
    SFThread_t  * pSFThread = pCThread->SFThread_Request.SFThread;
    pSFThread->parent.Device= (DevThread_t *)agNULL;

    CFuncYellowLed(thread->hpRoot, agFALSE);


    fiLogString(thread->hpRoot,
                "SELF %p In %s Fpc %x inIMQ %x AC %x SF %p",
                "CADF",(char *)agNULL,
                pCThread->DeviceSelf,pSFThread,
                pCThread->FLOGI_pollingCount,
                pCThread->ProcessingIMQ,
                CFuncAll_clear( thread->hpRoot ),
                0,0,0,0,0);


    pCThread->DirectoryServicesStarted = agFALSE;

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p Before %s - State = %d InIMQ %x My_ID %08X",
                    "CADF",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->ProcessingIMQ,
                    fiComputeCThread_S_ID(pCThread),
                    0,0,0,0,0);

    /* DRL find dev thread*/
    CFuncShowWhereDevThreadsAre( hpRoot);

    fiSetEventRecordNull(eventRecord);

    fiSendEvent(&pSFThread->thread_hdr,SFEventDoFlogi);

    if(CFuncInterruptPoll( hpRoot,&pCThread->FLOGI_pollingCount ))
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Flogi Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0);
        fiLogString(thread->hpRoot,
                    "DoFlogi TimeOut FM %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    0,0,0,0,0,0,0);
    }

    SFthreadState = pSFThread->thread_hdr.currentState;

    switch(SFthreadState)
    {
        case SFStateFlogiAccept:
                            fiSetEventRecord(eventRecord,thread,CEventFlogiSuccess);
                            break;

        case SFStateFlogiRej:
                            fiLogString(hpRoot,
                                            "Do Flogi Fail REJ SF %d Retry %d Rea %x Exp %x",
                                            (char *)agNULL,(char *)agNULL,
                                            (void *)agNULL,(void *)agNULL,
                                            SFthreadState,
                                            (os_bit32)pSFThread->SF_REJ_RETRY_COUNT,
                                            (os_bit32)pSFThread->RejectReasonCode,
                                            (os_bit32)pSFThread->RejectExplanation,
                                            0,0,0,0);
                switch(pSFThread->RejectReasonCode )
                    {
                        case FC_ELS_LS_RJT_Shifted_Logical_Error:
                            if(pSFThread->RejectExplanation == FC_ELS_LS_RJT_Shifted_Invalid_Common_Service_Parameters)
                            {
                                pCThread->ChanInfo.N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size = 0;
                                if (CThread_ptr(hpRoot)->DEVID == ChipConfig_DEVID_TachyonXL2)
                                {
                                    pCThread->ChanInfo.N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size
                                        =   FC_N_Port_Common_Parms_Continuously_Increasing_Supported
                                          | FC_N_Port_Common_Parms_N_Port
                                          /* MacData | FC_N_Port_Common_Parms_Alternate_BB_Credit_Management */ 
                                          | (CFunc_MAX_XL2_Payload(hpRoot) << FC_N_Port_Common_Parms_BB_Recv_Data_Field_Size_SHIFT);

                                }
                                else
                                {
                                    pCThread->ChanInfo.N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size
                                        =   FC_N_Port_Common_Parms_Continuously_Increasing_Supported
                                          | FC_N_Port_Common_Parms_N_Port
                                          /* MacData | FC_N_Port_Common_Parms_Alternate_BB_Credit_Management */ 
                                          | (TachyonTL_Max_Frame_Payload << FC_N_Port_Common_Parms_BB_Recv_Data_Field_Size_SHIFT);

                                }

                                fiLogString(hpRoot,
                                                "McData Switch Detected Rej Rea %x Exp %x",
                                                (char *)agNULL,(char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                pSFThread->RejectReasonCode,
                                                pSFThread->RejectExplanation,
                                                0,0,0,0,0,0);

                                fiSetEventRecord(eventRecord,thread,CEventGotFlogiThread);
                                return;
                            }
                            fiLogString(hpRoot,
                                            "%s %s ! Rej Rea %x Exp %x",
                                            "FC_ELS_LS_RJT_Shifted_Logical_Error","Not Coded",
                                            (void *)agNULL,(void *)agNULL,
                                            pSFThread->RejectReasonCode,
                                            pSFThread->RejectExplanation,
                                            0,0,0,0,0,0);
                            break;

                        case FC_ELS_LS_RJT_Shifted_Command_Not_Supported:
                                    if(pSFThread->RejectExplanation == (FC_ELS_LS_RJT_Shifted_No_Additional_Explanation ))
                                    {/* We get this reject from Brocade */
                                        if(pSFThread->SF_REJ_RETRY_COUNT < MAX_FLOGI_RETRYS )
                                        {  
                                            pSFThread->SF_REJ_RETRY_COUNT += 1;
                                            fiSetEventRecord(eventRecord,thread,CEventGotFlogiThread);
                                            return;
                                        }
                                        else
                                        {
                                            fiLogString(hpRoot,
                                                            "%s %s ! Retry %d",
                                                            "FC_ELS_LS_RJT_Shifted_Command_Not_Supported","Give it up",
                                                            (void *)agNULL,(void *)agNULL,
                                                            pSFThread->SF_REJ_RETRY_COUNT,
                                                            0,0,0,0,0,0,0);
                                        }
                                    }

                                    fiSetEventRecord(eventRecord,thread,CEventFlogiFail);
                                    pCThread->FlogiSucceeded = agFALSE;

                                    if(pCThread->InitAsNport)
                                    {  
                                        pCThread->DeviceDiscoveryMethod = DDiscoveryMethodInvalid;
                                    }
                                    else
                                    {
                                        if(pCThread->LoopMapLIRP_Received )
                                        {
                                            pCThread->DeviceDiscoveryMethod = DDiscoveryLoopMapReceived;
                                        }
                                        else
                                        {
                                            pCThread->DeviceDiscoveryMethod = DDiscoveryScanAllALPAs;
                                        }
                                    }

                                    break;

                        case FC_ELS_LS_RJT_Shifted_Invalid_LS_Command_Code:
                            fiLogString(hpRoot,
                                            "%s %s Rej Rea %x Exp %x",
                                            "FC_ELS_LS_RJT_Shifted_Invalid_LS_Command_Code","Not Coded",
                                            (void *)agNULL,(void *)agNULL,
                                            pSFThread->RejectReasonCode,
                                            pSFThread->RejectExplanation,
                                            0,0,0,0,0,0);
                                    break;

                        case FC_ELS_LS_RJT_Shifted_Logical_Busy:
                            fiLogString(hpRoot,
                                            "%s %s Rej Rea %x Exp %x",
                                            "FC_ELS_LS_RJT_Shifted_Logical_Busy","Not Coded",
                                            (void *)agNULL,(void *)agNULL,
                                            pSFThread->RejectReasonCode,
                                            pSFThread->RejectExplanation,
                                            0,0,0,0,0,0);
                                    break;
                        case FC_ELS_LS_RJT_Shifted_Protocol_Error:
                            fiLogString(hpRoot,
                                            "%s %s Rej Rea %x Exp %x",
                                            "FC_ELS_LS_RJT_Shifted_Protocol_Error","Not Coded",
                                            (void *)agNULL,(void *)agNULL,
                                            pSFThread->RejectReasonCode,
                                            pSFThread->RejectExplanation,
                                            0,0,0,0,0,0);
                                    break;
                        case FC_ELS_LS_RJT_Shifted_Unable_to_perform_command_request:
                            /*flogi to brocade with old port address */
                            fiLogString(hpRoot,
                                            "%s %s Rej Rea %x Exp %x",
                                            "FC_ELS_LS_RJT_Shifted_Unable_to_perform_command_request","Not Coded",
                                            (void *)agNULL,(void *)agNULL,
                                            pSFThread->RejectReasonCode,
                                            pSFThread->RejectExplanation,
                                            0,0,0,0,0,0);
                                    break;
                        case FC_ELS_LS_RJT_Shifted_Vendor_Unique_Error:
                            fiLogString(hpRoot,
                                            "%s %s Rej Rea %x Exp %x",
                                            "FC_ELS_LS_RJT_Shifted_Vendor_Unique_Error","Not Coded",
                                            (void *)agNULL,(void *)agNULL,
                                            pSFThread->RejectReasonCode,
                                            pSFThread->RejectExplanation,
                                            0,0,0,0,0,0);
                                    break;
                        default:
                                if(pSFThread->SF_REJ_RETRY_COUNT < MAX_FLOGI_RETRYS )
                                {  
                                    pSFThread->SF_REJ_RETRY_COUNT += 1;
                                    fiSetEventRecord(eventRecord,thread,CEventGotFlogiThread);
                                    return;
                                }
                                else
                                {
                                    fiLogString(hpRoot,
                                                    "Unknown FLOGI Reason   SF %d Retry %d Reason %X Explanation %X",
                                                    (char *)agNULL,(char *)agNULL,
                                                    (void *)agNULL,(void *)agNULL,
                                                    SFthreadState,
                                                    (os_bit32)pSFThread->SF_REJ_RETRY_COUNT,
                                                    (os_bit32)pSFThread->RejectReasonCode,
                                                    (os_bit32)pSFThread->RejectExplanation,
                                                    0,0,0,0);
                                }

                        }

                        fiSetEventRecord(eventRecord,thread,CEventFlogiFail);
                        pCThread->FlogiSucceeded = agFALSE;
                        if(pCThread->InitAsNport)
                        {  
                            pCThread->DeviceDiscoveryMethod = DDiscoveryMethodInvalid;
                        }
                        else
                        {
                            if(pCThread->LoopMapLIRP_Received )
                            {
                                pCThread->DeviceDiscoveryMethod = DDiscoveryLoopMapReceived;
                            }
                            else
                            {
                                pCThread->DeviceDiscoveryMethod = DDiscoveryScanAllALPAs;
                            }
                        }
                        break;

                   case SFStateFlogiBadALPA:
                            {
                               fiSetEventRecord(eventRecord,thread,CEventFlogiFail);

                                if(pCThread->InitAsNport)
                                {  
                                    pCThread->DeviceDiscoveryMethod = DDiscoveryMethodInvalid;
                                }
                                else
                                {

                                    pCThread->ChanInfo.CurrentAddress.Domain = 0;
                                    pCThread->ChanInfo.CurrentAddress.Area   = 0;
                                    osChipIOUpWriteBit32( hpRoot, ChipIOUp_My_ID, (fiComputeCThread_S_ID(pCThread) ));
                                    if(pCThread->LoopMapLIRP_Received )
                                    {
                                        pCThread->DeviceDiscoveryMethod = DDiscoveryLoopMapReceived;
                                    }
                                    else
                                    {
                                        pCThread->DeviceDiscoveryMethod = DDiscoveryScanAllALPAs;
                                    }
                                }
                                pCThread->FlogiSucceeded = agFALSE;

                                fiLogString(hpRoot,
                                                "Flogi Bad ALPA SF %d R %d Reas %X Exp %X DM %x",
                                                (char *)agNULL,(char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                SFthreadState,
                                                (os_bit32)pSFThread->SF_REJ_RETRY_COUNT,
                                                (os_bit32)pSFThread->RejectReasonCode,
                                                (os_bit32)pSFThread->RejectExplanation,
                                                pCThread->DeviceDiscoveryMethod,
                                                0,0,0);

                                fiLogString(hpRoot,
                                                "MY_ID %X MY dev ID %X",
                                                (char *)agNULL,(char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                fiComputeCThread_S_ID(pCThread),
                                                fiComputeDevThread_D_ID(pCThread->DeviceSelf),
                                                0,0,0,0,0,0);

  
                            }

                           break;
        case SFStateDoFlogi:
        case SFStateFlogiTimedOut:
                            if(pCThread->FlogiTimedOut)
                            {
                                pCThread->FlogiSucceeded = agFALSE;
                                if(pCThread->NumberOfFLOGITimeouts < MAX_FLOGI_TIMEOUTS )
                                {
                                    pCThread->NumberOfFLOGITimeouts ++;
                                    pCThread->FlogiTimedOut = agFALSE;
                                    fiSetEventRecord(eventRecord,thread,CEventGotFlogiThread);
                                    return;
                                }
                                fiLogString(hpRoot,
                                                "Do Flogi Timedout SF %d Timouts %d",
                                                (char *)agNULL,(char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                SFthreadState,
                                                pCThread->NumberOfFLOGITimeouts,
                                                0,0,0,0,0,0);

                                /* fiSetEventRecord(eventRecord,thread,CEventFlogiFail);*/
                                if(pCThread->FlogiRcvdFromTarget )
                                {
                                    fiSetEventRecord(eventRecord,thread,CEventGoToInitializeFailed);
                                }
                                else
                                {
                                    fiSetEventRecord(eventRecord,thread,CEventDoInitalize);
                                }
                                break;
                            }
                            else
                            {
                                pCThread->NumberOfFLOGITimeouts ++;
                                pCThread->FlogiTimedOut = agTRUE;
                                fiSetEventRecord(eventRecord,thread,CEventGotFlogiThread);
                                return;
                            }
                            pCThread->ReScanForDevices = agTRUE;
        default:
                            {
                                fiLogString(hpRoot,
                                                "Do Flogi Invalid SF %d",
                                                (char *)agNULL,(char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                SFthreadState,
                                                0,0,0,0,0,0,0);

                                pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
                                fiSetEventRecord(eventRecord,thread,CEventAsyncLoopEventDetected);
                            }

    }



    fiLogString(thread->hpRoot,
                "SELF %p Out %s Fpc %x inIMQ %x AC %x SF %d",
                "CADF",(char *)agNULL,
                pCThread->DeviceSelf,(void *)agNULL,
                pCThread->FLOGI_pollingCount,
                pCThread->ProcessingIMQ,
                CFuncAll_clear( thread->hpRoot ),
                SFthreadState,
                0,0,0,0);
/*
    CFuncShowWhereDevThreadsAre( hpRoot, agTRUE );
*/
    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After  %s - State = %d SFThread %p FDcnt %x",
                    "CADF",(char *)agNULL,
                    hpRoot,pSFThread,
                    (os_bit32)thread->currentState,
                    pCThread->FindDEV_pollingCount,
                    0,0,0,0,0,0);


}

/*+
  Function: CActionFlogiSuccess
   Purpose: Checks for running timers either set a timer to continue talking to switch
            or does so immediatly if timers are not running
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CEventDoDiPlogi
            fiTimerStart
-*/
/* CStateFlogiSuccess          8 */
extern void CActionFlogiSuccess( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    CThread_t  * pCThread = CThread_ptr(thread->hpRoot);

    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p In %s - State = %d InIMQ %x",
                    "CActionFlogiSuccess",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->ProcessingIMQ,
                    0,0,0,0,0,0);

#ifdef Do_Not_USE_Flogi_SFThread
    SFThreadFree(thread->hpRoot, & pCThread->SFThread_Request );
    pCThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;
#endif/* Do_Not_USE_Flogi_SFThread */
    /* Update the EDTOV register with the right EDTOV value gotten from the fabric */

   /* osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_TimeOut_Values_1,
                                (pCThread->F_Port_Common_Parms.E_D_TOV<<ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_SHIFT)); */

    pCThread->FlogiSucceeded = agTRUE;
    if (pCThread->TimerTickActive)
    {

        fiSetEventRecordNull(eventRecord);
        fiLogDebugString(thread->hpRoot,
                CStateLogConsoleERROR,
                "%s hproot %p Need to go through RSCN after timeout",
                "CActionFlogiSuccess",(char *)agNULL,
                thread->hpRoot,(void *)agNULL,
                0,0,0,0,0,0,0,0);

       if(! fiListElementOnList( (fiList_t *)(&(pCThread->Timer_Request)),
                                       &(pCThread->TimerQ)))
       {
            fiLogDebugString(thread->hpRoot,
                        CStateLogConsoleERROR,
                        "%s Setting Timer for RSCN",
                        "CActionFlogiSuccess",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);
            fiTimerSetDeadlineFromNow(thread->hpRoot, &pCThread->Timer_Request, CWaitAfterFlogi);

            pCThread->Timer_Request.eventRecord_to_send.thread= thread;

            pCThread->Timer_Request.eventRecord_to_send.event = CEventDoDiPlogi;
/*
            pCThread->Timer_Request.eventRecord_to_send.event = CEventAllocDiPlogiThread;
*/
            fiTimerStart(thread->hpRoot,&pCThread->Timer_Request);

       }
    } /* RSCN Pending */
    else
    {
#ifdef NAME_SERVICES
/*
        fiSetEventRecord(eventRecord, thread, CEventAllocDiPlogiThread);
*/
        fiSetEventRecord(eventRecord, thread, CEventDoDiPlogi);
#else /* NAME_SERVICES */
        fiSetEventRecord(eventRecord,thread,CEventSameALPA);
#endif/* NAME_SERVICES */
    }/*No RSCN Pending */
}

/*+
  Function: CActionALPADifferent
   Purpose: Was expected to "fix up" channel if switch changed our ALPA. This is handled when 
            FLOGI payload is parsed
 Called By: NONE
     Calls: CFuncYellowLed to indicate link down
            Terminating State
-*/
/* CStateALPADifferent         9 */
extern void CActionALPADifferent( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After In %s - State = %d",
                    "CActionALPADifferent",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: CActionFreeSFthread
   Purpose: Releases FLOGI/Switch SFThread. Does fine tuning of device discovery method.
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncShowWhereDevThreadsAre
            SFThreadFree
            Proccess_IMQ
            CEventSameALPA
            CEventInitalizeFailure
            CEventFindPtToPtDevice
            CEventAsyncLoopEventDetected
            CEventInitalizeSuccess

-*/
/* CStateFreeSFthread          10 */
extern void CActionFreeSFthread( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    CThread_t  * pCThread = CThread_ptr(thread->hpRoot);

    event_t  Event_To_Send    = CEventInitalizeSuccess;

    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After In %s - State = %d InIMQ %x",
                    "CActionFreeSFthread",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->ProcessingIMQ,
                    0,0,0,0,0,0);
    /* DRL find dev thread*/
    CFuncShowWhereDevThreadsAre( thread->hpRoot);


    SFThreadFree(thread->hpRoot, & pCThread->SFThread_Request );
    pCThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;

    /* Clear Bad ALPA from FLOGI Failure */

    if( ! pCThread->ProcessingIMQ )
    {
        pCThread->FuncPtrs.Proccess_IMQ(thread->hpRoot);
    }


    if (!(pCThread->FlogiSucceeded )) 
    {
        if (!(pCThread->InitAsNport))
        {
            Event_To_Send = CEventSameALPA;
        }
        else
        {
#ifdef NPORT_NOT_SUPPORTED
           /* We may be in an NPort to Nport Mode. Currently not supported */
           fiLogDebugString(thread->hpRoot,
                CStateLogConsoleERROR,
                "hpRoot %08X Possible NPort Connect In %s - State = %d",
                "CActionFreeSFthread",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)thread->hpRoot,
                (os_bit32)thread->currentState,
                0,0,0,0,0,0);
            Event_To_Send = CEventInitalizeFailure;
#else /* NPORT_NOT_SUPPORTED */
            Event_To_Send = CEventFindPtToPtDevice;
            pCThread->DeviceDiscoveryMethod  =  DDiscoveryPtToPtConnection;
        
#endif /* NPORT_NOT_SUPPORTED */
        }
    }
    else
    {
           /*In this case we are sure we are connected to FL/FPort, FLOGI
            succeeded but directory services failes, we do not want to treat this like a
            private loop and scan all the devices. Take it Initialize failed. */
            fiLogDebugString(thread->hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot %P Out %s - State = %d Sending event %s FlogiSucceeded",
                            "CActionFreeSFthread","CEventInitalizeFailure",
                            thread->hpRoot,(void *)agNULL,
                            (os_bit32)thread->currentState,
                            0,0,0,0,0,0,0);
            fiLogString(thread->hpRoot,
                            "Directory Fail DSFRy %d",
                            (char *)NULL,(char *)NULL,
                            (void *)agNULL,(void *)agNULL,
                            pCThread->DirectoryServicesFailed,
                            0,0,0,0,0,0,0);

            /* Try again if we got to failed then we link down and errors occur */
/* WAS
            fiSetEventRecord(eventRecord,thread, CEventInitalizeFailure );
*/
            /* WAS pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;*/
            /* WAS fiSetEventRecord(eventRecord,thread, CEventAsyncLoopEventDetected );*/
            if( ! pCThread->DirectoryServicesFailed)
            {
                pCThread->DirectoryServicesFailed = agTRUE;
                pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
                fiSetEventRecord(eventRecord,thread, CEventAsyncLoopEventDetected );
            }
            else
            {
                fiSetEventRecord(eventRecord,thread, CEventDeviceListEmpty );
            }
            return;

    }

    if(pCThread->DirectoryServicesStarted )
    {
          fiLogDebugString(thread->hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot %P Out %s - State = %d Sending event %s FlogiSucceeded",
                            "CActionFreeSFthread","CEventAsyncLoopEventDetected",
                            thread->hpRoot,(void *)agNULL,
                            (os_bit32)thread->currentState,
                            0,0,0,0,0,0,0);
            fiLogString(thread->hpRoot,
                            "Directory sevice Fail Retrying",
                            (char *)NULL,(char *)NULL,
                            (void *)agNULL,(void *)agNULL,
                            0,0,0,0,0,0,0,0);

            pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
            fiSetEventRecord(eventRecord,thread, CEventAsyncLoopEventDetected );
            return;
    }

    fiSetEventRecord(eventRecord,thread,Event_To_Send);
    pCThread->Flogi_AllocDone = agTRUE;

}

/*+
  Function: CActionSuccess
   Purpose: If we get to this point all channel setup has been successful. Do some double checking before
            device discovery. Sets next event to proper device device discovery method.
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncShowWhereDevThreadsAre
            SFThreadFree
            CFuncEnable_Interrupts
            Proccess_IMQ
            CFunc_Queues_Frozen
            CEventFindDeviceUseNameServer
            CEventFindDeviceUseLoopMap
            CEventInitalizeSuccess
-*/
/* CStateSuccess               11 */
extern void CActionSuccess( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    CThread_t  * pCThread           = CThread_ptr(thread->hpRoot);
    event_t      Initialized_event  = CEventInitalizeSuccess;
    SFThread_t * pSFThread          = pCThread->SFThread_Request.SFThread;

    CFuncYellowLed(thread->hpRoot, agFALSE);

    if(pSFThread != (SFThread_t *) agNULL)
    {
       if( pCThread->SFThread_Request.State == SFThread_Request_Granted)
        {
            fiLogDebugString(thread->hpRoot,
                CStateLogConsoleERROR,
                "pCThread %p Freeing SFThread in %s ",
                "CActionSuccess",(char *)agNULL,
                pCThread,(void *)agNULL,
                0,0,0,0,0,0,0,0);

            SFThreadFree( thread->hpRoot, &pCThread->SFThread_Request );
            pCThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;
        }
    }

    CFuncEnable_Interrupts(
                            thread->hpRoot,
                            (  ChipIOUp_INTEN_MPE
                             | ChipIOUp_INTEN_CRS
                             | ChipIOUp_INTEN_INT
                             | ChipIOUp_INTEN_DER
                             | ChipIOUp_INTEN_PER)
                          );


    faSingleThreadedLeave( thread->hpRoot ,CStateSuccess );

    osFCLayerAsyncEvent( thread->hpRoot, osFCLinkDown );

    faSingleThreadedEnter( thread->hpRoot ,CStateSuccess );

    if(thread->currentState != CStateSuccess )
    {

        fiLogDebugString(thread->hpRoot,
                            CSTATE_NOISE(thread->hpRoot,CStateSuccess),
                            "hpRoot %p After In %s - State = %d Wrong not %d - Event %d InIMQ %x",
                            "CActionSuccess",(char *)agNULL,
                            thread->hpRoot,(void *)agNULL,
                            (os_bit32)thread->currentState,
                            CStateSuccess,
                            Initialized_event,
                            0,0,0,0,0);


        if(pCThread->LoopPreviousSuccess)
        {

            pCThread->Loop_Reset_Event_to_Send = CEventDoInitalize;
            Initialized_event = CEventAsyncLoopEventDetected;
        }
        else
        {
            Initialized_event = CEventLoopNeedsReinit;
        }

        fiLogDebugString(thread->hpRoot,
                    CSTATE_NOISE(thread->hpRoot,CStateSuccess),
                    "hpRoot %p In %s - State = %d - Event %d Queues %x LD %x IR %x InIMQ %x",
                    "CActionSuccess",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    Initialized_event,
                    CFunc_Queues_Frozen( thread->hpRoot ),
                    pCThread->LOOP_DOWN,
                    pCThread->IDLE_RECEIVED,
                    pCThread->ProcessingIMQ,0,0);

    }


    if(CFunc_Queues_Frozen( thread->hpRoot ))
    {

        if(! pCThread->ProcessingIMQ)
        {
            pCThread->FuncPtrs.Proccess_IMQ(thread->hpRoot);
        }
        else
        {
            fiLogDebugString(thread->hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot %p In %s - State = %d - Event %d Queues %x LD %x IR %x InIMQ %x",
                        "CActionSuccess",(char *)agNULL,
                        thread->hpRoot,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        Initialized_event,
                        CFunc_Queues_Frozen( thread->hpRoot ),
                        pCThread->LOOP_DOWN,
                        pCThread->IDLE_RECEIVED,
                        pCThread->ProcessingIMQ,0,0);
        }
    }

    if(ERQ_FULL(pCThread->HostCopy_ERQProdIndex,
                pCThread->FuncPtrs.GetERQConsIndex(thread->hpRoot),
                pCThread->Calculation.MemoryLayout.ERQ.elements     ))
    {
        fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "ERQ FULL ERQ_PROD %d Cons INDEX %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->HostCopy_ERQProdIndex,
                    pCThread->FuncPtrs.GetERQConsIndex(thread->hpRoot ),
                    0,0,0,0,0,0);
        Initialized_event = CEventLoopNeedsReinit;

    }

    fiLogDebugString(thread->hpRoot,
                    /* CSTATE_NOISE(thread->hpRoot,CStateSuccess),*/
                    CStateLogConsoleERROR,
                    "hpRoot %p In %s - State = %d - Event %d Queues %x LD %x IR %x InIMQ %x FDcnt %x",
                    "CActionSuccess",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    Initialized_event,
                    CFunc_Queues_Frozen( thread->hpRoot ),
                    pCThread->LOOP_DOWN,
                    pCThread->IDLE_RECEIVED,
                    pCThread->ProcessingIMQ,
                    pCThread->FindDEV_pollingCount,0);


    if(!  CFuncAll_clear( thread->hpRoot ) )
    {
        Initialized_event = CEventLoopNeedsReinit;

        fiLogDebugString(thread->hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot %p In %s - State = %d - Event %d Queues %x LD %x IR %x InIMQ %x",
                        "CActionSuccess",(char *)agNULL,
                        thread->hpRoot,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        Initialized_event,
                        CFunc_Queues_Frozen( thread->hpRoot ),
                        pCThread->LOOP_DOWN,
                        pCThread->IDLE_RECEIVED,
                        pCThread->ProcessingIMQ,0,0);
    }

    if(Initialized_event == CEventInitalizeSuccess)
    {
        switch (pCThread->DeviceDiscoveryMethod){

        case DDiscoveryQueriedNameService:
            fiSetEventRecord(eventRecord,thread,CEventFindDeviceUseNameServer);
            break;

        case DDiscoveryLoopMapReceived:
            fiSetEventRecord(eventRecord,thread,CEventFindDeviceUseLoopMap);
            break;

        case DDiscoveryMethodInvalid:
            fiSetEventRecord(eventRecord,thread,CEventGoToInitializeFailed);
            break;

        /* The default is the brute force method */
        default:
            fiSetEventRecord(eventRecord,thread,Initialized_event);
            break;
        }

        fiLogString(thread->hpRoot,
                        "%s DeviceDiscoveryMethod %X",
                        "CActionSuccess",(char *)NULL,
                        (void *)agNULL,(void *)agNULL,
                        pCThread->DeviceDiscoveryMethod,
                        0,0,0,0,0,0,0);
        return;
    }



    fiSetEventRecord(eventRecord,thread,Initialized_event);
}

/*+
  Function: CActionNormal
   Purpose: If we get to this point everything has been successful. All devices have been found.
            Indicate handles are available by setting osFCLinkUp. This is the only state that
            the osLayer is allowed to send IO to devices. At all other times it is invalid.
 Called By: 
     Calls: Terminating State
            CFuncYellowLed to indicate link up
            CFuncShowWhereDevThreadsAre
            CFuncInterruptPoll
            fiTimerStop
            CFuncCheckForDuplicateDevThread
-*/
/* CStateNormal                12 */
extern void CActionNormal( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    CThread_t  * pCThread    = CThread_ptr(thread->hpRoot);
    agRoot_t   * hpRoot      = thread->hpRoot;

    pCThread->DirectoryServicesFailed = agFALSE;
    pCThread->NumberOfPlogiTimeouts =0;

    fiLogString(hpRoot,
                "%d %s MY_ID %X DM %X",
                "CAN",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)thread->currentState,
                fiComputeCThread_S_ID(pCThread),
                pCThread->DeviceDiscoveryMethod,
                0,0,0,0,0 );

    if( pCThread->FindDEV_pollingCount )
    {

        fiLogString(hpRoot,
                    "%d %s Free %d Active %d Un %d Login %d",
                    "CAN",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
			        fiNumElementsOnList(&pCThread->Free_DevLink),
			        fiNumElementsOnList(&pCThread->Active_DevLink),
			        fiNumElementsOnList(&pCThread->Unknown_Slot_DevLink),
			        fiNumElementsOnList(&pCThread->AWaiting_Login_DevLink),
                    0,0,0 );
        fiLogString(hpRoot,
                    "Fdcnt %d %s ADISC %d SS %d PrevA login %d Prev Un %d",
                    "CAN",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->FindDEV_pollingCount, 
			        fiNumElementsOnList(&pCThread->AWaiting_ADISC_DevLink),
			        fiNumElementsOnList(&pCThread->Slot_Searching_DevLink),
			        fiNumElementsOnList(&pCThread->Prev_Active_DevLink),
			        fiNumElementsOnList(&pCThread->Prev_Unknown_Slot_DevLink),
                    0,0,0 );

        if(CFuncInterruptPoll( hpRoot,&pCThread->FindDEV_pollingCount ))
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "%s Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                    "CAN",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0);
            pCThread->FindDEV_pollingCount = 0;
        }

    }
    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "In - %s FM Status %08X TL Status %08X Ints %08X sysInts-Act %x Log %x",
                    "CAN",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST ),
                    CThread_ptr(hpRoot)->sysIntsActive,
                    CThread_ptr(hpRoot)->sysIntsLogicallyEnabled,
                    0,0,0);

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(hpRoot)->LOOP_DOWN,
                    CThread_ptr(hpRoot)->IDLE_RECEIVED,
                    CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                    CThread_ptr(hpRoot)->ERQ_FROZEN,
                    CThread_ptr(hpRoot)->FCP_FROZEN,
                    CThread_ptr(hpRoot)->ProcessingIMQ,
                    0,0);

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "pCThread->HostCopy_IMQConsIndex %X  IMQProdIndex %X FDcnt %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->HostCopy_IMQConsIndex,
                    pCThread->FuncPtrs.GetIMQProdIndex(hpRoot),
                    pCThread->FindDEV_pollingCount,
                    0,0,0,0,0);


#ifdef NPORT_STUFF

    if (pCThread->ConnectedToNportOrFPort)
    {

        fiSetEventRecordNull(eventRecord);

        if(fiListElementOnList( (fiList_t *)(&(pCThread->Timer_Request)),
                                       &(pCThread->TimerQ)))
        {
            if(pCThread->Timer_Request.eventRecord_to_send.event != CEventAllocDiPlogiThread)
            {
                fiTimerStop(&pCThread->Timer_Request);
            }
        }

        fiLogDebugString(thread->hpRoot,
                        CStateLogConsoleLevel,
                        "hpRoot %p NPort Out %s",
                        "CAN",(char *)agNULL,
                        thread->hpRoot,(void *)agNULL,
                        0,0,0,0,0,0,0,0);

        if(pCThread->FindDEV_pollingCount)
        {
            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "%s Ccnt Non Zero FDcnt %x",
                        "CAN",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCThread->FindDEV_pollingCount,
                        0,0,0,0,0,0,0);
        }

        CFuncYellowLed(hpRoot, agTRUE );
        if(pCThread->ChanInfo.LIPCountLower + 1 < pCThread->ChanInfo.LIPCountUpper )
        {
            pCThread->ChanInfo.LIPCountUpper ++;
        }
        pCThread->ChanInfo.LIPCountLower += 1;

        faSingleThreadedLeave( thread->hpRoot,CStateNormal  );

        osFCLayerAsyncEvent( thread->hpRoot, osFCLinkUp );

        faSingleThreadedEnter( thread->hpRoot,CStateNormal );

        return;
    }
#endif    /* NPORT_STUFF */


#ifdef FLIP_NportState
    if(! fiListElementOnList( (fiList_t *)(&(pCThread->Timer_Request)),
                                   &(pCThread->TimerQ)))
    {
        fiTimerSetDeadlineFromNow(thread->hpRoot, &pCThread->Timer_Request, CFlipNportTOV);

        pCThread->Timer_Request.eventRecord_to_send.thread= thread;

        pCThread->Timer_Request.eventRecord_to_send.event = CEventFlipNPortState;

        fiTimerStart(thread->hpRoot,&pCThread->Timer_Request);

    }

#endif /* FLIP_NportState */

    fiSetEventRecordNull(eventRecord);

    if(fiListElementOnList( (fiList_t *)(&(pCThread->Timer_Request)),
                                   &(pCThread->TimerQ)))
    {
        fiLogString(thread->hpRoot,
                        "%s %s Event %d",
                        "CAN","Timer set",
                        (void *)agNULL,(void *)agNULL,
                        pCThread->Timer_Request.eventRecord_to_send.event,
                        0,0,0,0,0,0,0);

        if(pCThread->Timer_Request.eventRecord_to_send.event != CEventAllocDiPlogiThread)
        {
            fiTimerStop(&pCThread->Timer_Request);
        }
    }

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleLevel,
                    "hpRoot %p Out %s",
                    "CAN",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    if( pCThread->Loop_Reset_Event_to_Send == CEventDoInitalize )
    {   /* The Loop came up good Initalize causes LIP.... */
        if (! pCThread->InitAsNport)
        {
            pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
        }
    }

    fiLogString(hpRoot,
                    "%s FM Stat %08X LPS %x LRES %d AC %x Num Dev %d",
                    "CAN",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    pCThread->LoopPreviousSuccess,
                    pCThread->Loop_Reset_Event_to_Send,
                    CFuncAll_clear(hpRoot ),
                    CFuncCountFC4_Devices(hpRoot),
                    0,0,0);
    fiLogString(hpRoot,
                    "%s Active %x ADISC %d FDcnt %d",
                    "CAN",(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
				    CFuncShowActiveCDBThreads( hpRoot, ShowActive),
                    pCThread->ADISC_pollingCount,
                    pCThread->FindDEV_pollingCount,
                    0,0,0,0,0);

    CFuncYellowLed(hpRoot, agTRUE );

    CFuncCheckForDuplicateDevThread( thread->hpRoot );

    faSingleThreadedLeave( thread->hpRoot,CStateNormal  );

    osFCLayerAsyncEvent( thread->hpRoot, osFCLinkUp );

    faSingleThreadedEnter( thread->hpRoot,CStateNormal );


}

/*+
  Function: CActionResetNeeded
   Purpose: When ever link event occurs this state is called. If chip is bypassed
            reinitialize.
 Called By: 
     Calls: Terminating State
            CFuncYellowLed to indicate link down
-*/
/*CStateResetNeeded           13*/
extern void CActionResetNeeded( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t      * hpRoot  = thread->hpRoot;
    CFuncYellowLed(hpRoot, agFALSE);

    faSingleThreadedLeave( hpRoot, CStateResetNeeded );

    osFCLayerAsyncEvent( hpRoot, osFCLinkDown );

    faSingleThreadedEnter( hpRoot, CStateResetNeeded);

    if( osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ) & ChipIOUp_Frame_Manager_Status_BYP )
    {
        fiSetEventRecord(eventRecord,thread,CEventDoInitalize);

        fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "In %s with ChipIOUp_Frame_Manager_Status_BYP event %d",
                            "CARN",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            CEventDoInitalize,
                            0,0,0,0,0,0,0);
        return;
    }


    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p Out %s FDcnt %x InIMQ %x",
                    "CARN",(char *)agNULL,
                    hpRoot,(void *)agNULL,
                    CThread_ptr(hpRoot)->FindDEV_pollingCount,
                    CThread_ptr(hpRoot)->ProcessingIMQ,
                    0,0,0,0,0,0);

    fiLogString(hpRoot,
                    "%s TL %08X LDT %X",
                    "CARN",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    CThread_ptr(hpRoot)->LinkDownTime.Lo,
                    0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);

}

/*+
  Function: CActionLoopFail
   Purpose: This state sends ADISC to all targets.
            Exit this state if currently processing the IMQ
            If ALPA changed kill all outstanding IO's
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CEventLoopNeedsReinit
            CEventAsyncLoopEventDetected
            CFuncFreezeQueuesPoll
            CFuncCompleteAllActiveCDBThreads
            CFuncShowWhereDevThreadsAre
            CFuncWhatStateAreDevThread
            CFunc_Always_Enable_Queues
            CFuncAll_clear
            CEventAsyncLoopEventDetected
            DevEventAllocAdisc
            CFuncInterruptPoll
            CFuncCompleteActiveCDBThreadsOnDevice
            DevThreadFree
            CEventLoopEventDetected
            CEventLoopConditionCleared
-*/
/* CStateLoopFail              14 */
extern void CActionLoopFail( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    event_t         Initialized_event  = CEventLoopNeedsReinit;
    agRoot_t      * hpRoot             = thread->hpRoot;
    CThread_t     * pCThread           = CThread_ptr(hpRoot);

    CFuncYellowLed(hpRoot, agFALSE);

    fiLogString(thread->hpRoot,
                "In %s Fpc %x inIMQ %x AC %x ADISC %d FDcnt %d Lrets %d",
                "CALF",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                pCThread->FLOGI_pollingCount,
                pCThread->ProcessingIMQ,
                CFuncAll_clear( thread->hpRoot ),
                pCThread->ADISC_pollingCount,
                pCThread->FindDEV_pollingCount,
                pCThread->Loop_Reset_Event_to_Send,
                0,0);

    fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "%s 0 FDcnt % InIMQ %x",
                "CALF",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                pCThread->FindDEV_pollingCount,
                pCThread->ProcessingIMQ,
                0,0,0,0,0,0);

    if( pCThread->DeviceSelf ==(DevThread_t *) agNULL )
    {
        if (! pCThread->InitAsNport)
        {
            Initialized_event    = CEventLoopNeedsReinit;
            fiSetEventRecord(eventRecord,thread,Initialized_event);

            fiLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "In %s with agNULL SELF ! event %d",
                                "CALF",(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                CEventLoopNeedsReinit,
                                0,0,0,0,0,0,0);
            return;
        }
    }

    if( pCThread->ProcessingIMQ )
    {
        /* If we are in IMQ bail because we can't get any work done */
        pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
        fiSetEventRecord(eventRecord,thread,CEventAsyncLoopEventDetected);
        return;
    }


    if( pCThread->LOOP_DOWN )
    {
/*
        if (pCThread->InitAsNport)
        {
            fiSetEventRecord(eventRecord,thread, CEventInitalizeFailure );
            return;
        }
*/
        if(! CFuncLoopDownPoll(hpRoot))
        {
            if (!pCThread->InitAsNport)
            {

                if( (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ) &
                                                    ChipIOUp_Frame_Manager_Status_LSM_MASK) )
                {

                    fiLogString(hpRoot,
                                "Out %s reinit Fpc %x inIMQ %x AC %x ADISC %d FDcnt %d Lrets %d",
                                "CALF",(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                pCThread->FLOGI_pollingCount,
                                pCThread->ProcessingIMQ,
                                CFuncAll_clear( thread->hpRoot ),
                                pCThread->ADISC_pollingCount,
                                pCThread->FindDEV_pollingCount,
                                pCThread->Loop_Reset_Event_to_Send,
                                0,0);
                    fiSetEventRecord(eventRecord,thread,CEventInitalizeFailure);
                    return;


                }
            }

            if( pCThread->thread_hdr.currentState == CStateLIPEventStorm         ||
                pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm   )
            {

                fiLogString(hpRoot,
                                "%s sends %s FM_Status %08X FM_IMQ_Status %08X",
                                "CALF","CEventLIPEventStorm",
                                (void *)agNULL,(void *)agNULL,
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                                pCThread->From_IMQ_Frame_Manager_Status,
                                0,0,0,0,0,0);

                fiSetEventRecord(eventRecord,thread,CEventLIPEventStorm);
                return;

            }
        }    
    }
    if( pCThread->ProcessingIMQ )
    {
        /* If we are in IMQ bail because we can't get any work done */
        /* CFuncLoopDownPoll might put us in IMQ ??? */
        pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
        fiSetEventRecord(eventRecord,thread,CEventAsyncLoopEventDetected);
        return;
    }

    if( CFuncFreezeQueuesPoll( hpRoot))
    {
        if( pCThread->thread_hdr.currentState == CStateLIPEventStorm         ||
            pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm   )
        {
            fiLogDebugString(hpRoot,
                            CFuncCheckCstateErrorLevel,
                            "A %s sends %s FM_Status %08X FM_IMQ_Status %08X",
                            "CALF","CEventLIPEventStorm",
                            (void *)agNULL,(void *)agNULL,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                            pCThread->From_IMQ_Frame_Manager_Status,
                            0,0,0,0,0,0);

            fiSetEventRecord(eventRecord,thread,CEventLIPEventStorm);
            return;

        }
    }

    if(pCThread->ALPA_Changed_OnLinkEvent )
    {

        fiLogString(thread->hpRoot,
                    "In %s %s CurrentAddress %X",
                    "CALF","ALPA_Changed_OnLinkEvent",
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)(pCThread->ChanInfo.CurrentAddress.AL_PA),
                    0,0,0,0,0,0,0);

        fiLogString(thread->hpRoot,
                    "Fpc %x inIMQ %x AC %x ADISC %d FDcnt %d Lrets %d",
                    (char *)agNULL,(char  *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->FLOGI_pollingCount,
                    pCThread->ProcessingIMQ,
                    CFuncAll_clear( thread->hpRoot ),
                    pCThread->ADISC_pollingCount,
                    pCThread->FindDEV_pollingCount,
                    pCThread->Loop_Reset_Event_to_Send,
                    0,0);

        CFuncCompleteAllActiveCDBThreads( hpRoot, osIODevReset,CDBEventIODeviceReset );
        pCThread->ALPA_Changed_OnLinkEvent = agFALSE;
    }


    if( CFuncShowWhereCDBThreadsAre(hpRoot))
    {
        CFuncWhatStateAreCDBThreads(hpRoot);
    }

    if( osChipIOLoReadBit32(hpRoot, ChipIOLo_ERQ_Producer_Index) != 
                        osChipIOLoReadBit32(hpRoot, ChipIOLo_ERQ_Consumer_Index))
    {
        if( osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ) & ChipIOUp_TachLite_Status_EQF )
        osChipIOLoWriteBit32(hpRoot,ChipIOLo_ERQ_Consumer_Index , 
                        osChipIOLoReadBit32(hpRoot,ChipIOLo_ERQ_Producer_Index ));
    }

    if(CFuncShowWhereDevThreadsAre( hpRoot)) 
    {
        CFuncWhatStateAreDevThreads( hpRoot );
    }

    faSingleThreadedLeave( hpRoot ,CStateLoopFail );

    osFCLayerAsyncEvent( hpRoot, osFCLinkDown );

    faSingleThreadedEnter( hpRoot ,CStateLoopFail);

    /* Reinit without lip ???  */

    if ( CFunc_Always_Enable_Queues(hpRoot ) )
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Loop Fail Queues Frozen after Enable",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
    }


    if( CFuncAll_clear( hpRoot ))
    {
        if( pCThread->DeviceSelf !=(DevThread_t *) agNULL )
        {
            Initialized_event    = CEventLoopConditionCleared;
        }
    }

    CFuncShowWhereDevThreadsAre( hpRoot);

    if( thread->currentState != CStateLoopFail )
    {
        pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
        fiSetEventRecord(eventRecord,thread,CEventAsyncLoopEventDetected);
        return;
    }

    fiListEnqueueListAtTail(&pCThread->Active_DevLink,&pCThread->Prev_Active_DevLink);

    CFuncDoADISC( hpRoot);

    /* See if Link event occured */
    if( thread->currentState != CStateLoopFail)
    {
        Initialized_event = CEventLoopEventDetected;
    }

    fiLogString(hpRoot,
                    "%s FM %08X TL %08X AC %x ADISC %d FDcnt %d",
                    "CALF",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    CFuncAll_clear( hpRoot ),
                    pCThread->ADISC_pollingCount,
                    pCThread->FindDEV_pollingCount,
                    0,0,0);



    fiSetEventRecord(eventRecord,thread,Initialized_event);

}

/*+
  Function: CActionReInitFM
   Purpose: This state will generate LIP without reinitializing channel data for LOOP only NPORT goes to CActionInitFM.
            via CEventInitChipSuccess.
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CEventInitChipSuccess
            CFunc_Queues_Frozen
            CFunc_Always_Enable_Queues
            CFuncLoopDownPoll
            CFuncAll_clear
            CFuncQuietShowWhereDevThreadsAre
            CFuncInitFM_Registers
            CFuncDisable_Interrupts
            Proccess_IMQ
            osStallThread
            fiTimerTick
            CEventInitalizeFailure
            CEventAsyncLoopEventDetected
            CEventReInitFMSuccess
-*/
/*CStateReInitFM                15 */
extern void CActionReInitFM( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t *hpRoot= thread->hpRoot;
    CThread_t  *    pCThread        = CThread_ptr(hpRoot);
    os_bit32        Hard_Stall=0;
    event_t  Initialized_event   = CEventReInitFMSuccess;
    agBOOLEAN Success = agFALSE;
    fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "In %s with event %d Current State %x (%x) InIMQ %x",
                        "CARIFM",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        Initialized_event,
                        thread->currentState,
                        CStateReInitFM,
                        pCThread->ProcessingIMQ,
                        0,0,0,0);


    fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "%s FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                        "CARIFM",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                        0,0,0,0);



    CFuncYellowLed( hpRoot, agFALSE);
#ifdef NPORT_STUFF

    /* Unlike the loop case, we are combining the ReinitFM with InitFM.
     * So, transition here directly to Init FM.
     */
    if (pCThread->InitAsNport)
    {
        fiSetEventRecord(eventRecord,thread, CEventInitChipSuccess );
        return;
    }

#endif   /* NPORT_STUFF */
    if(CFunc_Queues_Frozen(hpRoot))
    {
        CFunc_Always_Enable_Queues(hpRoot );
    }

    if( pCThread->LOOP_DOWN )
    {
        CFuncLoopDownPoll(hpRoot);
    }

    if( CFuncAll_clear( hpRoot ) && ( pCThread->DeviceSelf != (DevThread_t *)agNULL ))
    {
        Initialized_event    = CEventLoopConditionCleared;
        Success = agTRUE;
    }
    else
    {
        /*
            CFuncInit_Threads( hpRoot );
            Put Self back on list ????????
        */
        if( pCThread->DeviceSelf != (DevThread_t *)agNULL )
        {
            fiLogString(hpRoot,
                    "%s DevThreadFree Was %X",
                    "CARIFM",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeCThread_S_ID(pCThread),
                    0,0,0,0,0,0,0);

            pCThread->ChanInfo.CurrentAddress.Domain = 0;
            pCThread->ChanInfo.CurrentAddress.Area   = 0;

            DevThreadFree(hpRoot,pCThread->DeviceSelf);
            pCThread->DeviceSelf = (DevThread_t *)agNULL;
        }

        fiLogString(hpRoot,
                    "%s DeviceSelf %X FM %X",
                    "CARIFM",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeCThread_S_ID(pCThread),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    0,0,0,0,0,0);

        CFuncQuietShowWhereDevThreadsAre( hpRoot);
        CFuncInitFM_Registers( hpRoot, agTRUE );
        if( pCThread->NoStallTimerTickActive )
        {
            if(! fiListElementOnList( (fiList_t *)(&(pCThread->Timer_Request)),
                                           &(pCThread->TimerQ)))
            {
                fiLogDebugString( hpRoot,
                                    CStateLogConsoleERROR,
                                    "hpRoot %p Soft Stall In %s - State = %d InIMQ %x",
                                    "CAIFM",(char *)agNULL,
                                    thread->hpRoot,(void *)agNULL,
                                    (os_bit32)thread->currentState,
                                    pCThread->ProcessingIMQ,
                                    0,0,0,0,0,0);

                fiSetEventRecordNull(eventRecord);

                fiTimerSetDeadlineFromNow(hpRoot, &pCThread->Timer_Request, CInitFM_Delay );

                pCThread->Timer_Request.eventRecord_to_send.thread= thread;
                pCThread->Timer_Request.eventRecord_to_send.event = CEventDelay_for_FM_init;

                fiTimerStart(hpRoot,&pCThread->Timer_Request);

                CFuncEnable_Interrupts(
                                        thread->hpRoot,
                                        (  ChipIOUp_INTEN_MPE
                                         | ChipIOUp_INTEN_CRS
                                         | ChipIOUp_INTEN_INT
                                         | ChipIOUp_INTEN_DER
                                         | ChipIOUp_INTEN_PER)
                                      );
               return;
            }
        }
        else
        {

            CFuncInitFM_Registers( hpRoot, agTRUE );

            CFuncDisable_Interrupts(thread->hpRoot,ChipIOUp_INTEN_MASK);/*DRL*/

            Hard_Stall = Init_FM_Delay_Count;
            while( Hard_Stall > 1 )
            {
                pCThread->FuncPtrs.Proccess_IMQ(hpRoot);
                if ( pCThread->DeviceSelf != agNULL)
                {
                    fiLogDebugString(hpRoot,
                                    CFuncLogConsoleERROR,
                                    "PASS %s HA %x CA %x Hard_Stall %x",
                                    "CARIFM",(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    (os_bit32)(pCThread->ChanInfo.HardAddress.AL_PA),
                                    (os_bit32)(pCThread->ChanInfo.CurrentAddress.AL_PA),
                                    Hard_Stall,
                                    0,0,0,0,0);
                    Success = agTRUE;
                    break;
                }
                osStallThread( hpRoot, 1 );
                fiTimerTick( hpRoot, 1 );
                Hard_Stall--;
            }
        }
        if ( pCThread->DeviceSelf == agNULL)
        {
            Initialized_event = CEventInitalizeFailure;
            fiLogDebugString(hpRoot,
                            CFuncLogConsoleERROR,
                            "FAIL %s HA %x CA %x Hard_Stall %d",
                            "CARIFM",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            (os_bit32)(pCThread->ChanInfo.HardAddress.AL_PA),
                            (os_bit32)(pCThread->ChanInfo.CurrentAddress.AL_PA),
                            Hard_Stall,
                            0,0,0,0,0);
        }
        else
        {
            Initialized_event = CEventReInitFMSuccess;
        }
 
    }

    if( Initialized_event != CEventReInitFMSuccess)
    {
        if( (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ) &
                                            ChipIOUp_Frame_Manager_Status_LSM_MASK) ==
                                            ChipIOUp_Frame_Manager_Status_LSM_Loop_Fail )
        {
            pCThread->Loop_Reset_Event_to_Send = Initialized_event;
            Initialized_event = CEventInitalizeFailure;

        }
        else
        {
            pCThread->Loop_Reset_Event_to_Send = Initialized_event;
            Initialized_event = CEventGoToInitializeFailed;
        }
    }

    fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "Out %s with event %d Current State %d should be %d",
                        "CARIFM",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        Initialized_event,
                        thread->currentState,
                        CStateReInitFM,
                        0,0,0,0,0);

    fiLogString(hpRoot,
                "%s Success %x %d FM %X(%X)",
                "CARIFM",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)Success,
                Hard_Stall,
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                fiComputeCThread_S_ID(pCThread),
                0,0,0,0);


    fiSetEventRecord(eventRecord,thread, Initialized_event );

}

/*+
  Function: CActionInitializeFailed
   Purpose: This state where you end up if the cable is pulled out or never attached. Loop attempts
            to recover one more time. Terminate until some external action is taken.
 Called By: 
     Calls: CFuncYellowLed to indicate link dead
            fiTimerStop
            CFuncDisable_Interrupts
            osChipIOUpReadBit32
            Proccess_IMQ
            osStallThread
            fiTimerTick
            CEventAsyncLoopEventDetected
            CFuncEnable_Interrupts
-*/
/*  CStateInitializeFailed 16 */
extern void CActionInitializeFailed( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    agRoot_t   *    hpRoot      = thread->hpRoot;
    CThread_t  *    pCThread    = CThread_ptr(hpRoot);
    agBOOLEAN       Success     = agFALSE;
    os_bit32        Hard_Stall  = 0;
    os_bit32        FM_Status  = 0;

    pCThread->NumberOfPlogiTimeouts =0;

    CFuncYellowLed(hpRoot, agFALSE);

    faSingleThreadedLeave( hpRoot , CStateInitializeFailed );

    osFCLayerAsyncEvent( hpRoot, osFCLinkDown );

    faSingleThreadedEnter( hpRoot, CStateInitializeFailed);

    if(fiListElementOnList( (fiList_t *)(&(pCThread->Timer_Request)),
                                   &(pCThread->TimerQ)))
    {
        fiTimerStop(&pCThread->Timer_Request);
    }

    fiLogString( hpRoot,
                    "%s InitAsNport %x MY_ID %x",
                    "CAIF",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->InitAsNport,
                    (os_bit32)fiComputeCThread_S_ID(pCThread),
                    0,0,0,0,0,0);

    if (! pCThread->InitAsNport)
    {
        if(pCThread->TimerTickActive != agTRUE)
        {
            CFuncDisable_Interrupts(hpRoot,ChipIOUp_INTEN_MASK);/*DRL*/
            Hard_Stall = Init_FM_Delay_Count;
            while( Hard_Stall > 1  )
            {
			    FM_Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );
			    if(FM_Status & ChipIOUp_Frame_Manager_Status_LS)
			    {
				    break;
			    }
			    if(FM_Status & ChipIOUp_Frame_Manager_Status_EW)
			    {
				    break;
			    }
                pCThread->FuncPtrs.Proccess_IMQ(hpRoot);
                if ( pCThread->DeviceSelf != agNULL)
                {
                    fiLogDebugString(hpRoot,
                                    CFuncLogConsoleERROR,
                                    "PASS %s HA %x CA %x Hard_Stall %d",
                                    "CAIF",(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    (os_bit32)(pCThread->ChanInfo.HardAddress.AL_PA),
                                    (os_bit32)(pCThread->ChanInfo.CurrentAddress.AL_PA),
                                    Hard_Stall,
                                    0,0,0,0,0);
                    Success = agTRUE;
                    break;
                }
                osStallThread( hpRoot, 1 );
                fiTimerTick( hpRoot, 1 );
                Hard_Stall--;
            }
            if( Success )
            {
                pCThread->Loop_Reset_Event_to_Send = CStateResetNeeded;
                fiSetEventRecord(eventRecord,thread,CEventAsyncLoopEventDetected);
                return;
            }

        }
    }
    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot (%p) In %s - State = %d",
                    "CAIF",(char *)agNULL,
                    hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "FM Status %08X FM Config %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "TL Status %08X TL Control %08X Rec Alpa Reg %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0,0);

    CFuncEnable_Interrupts(
                            hpRoot,
                            (  ChipIOUp_INTEN_MPE
                             | ChipIOUp_INTEN_CRS
                             | ChipIOUp_INTEN_INT
                             | ChipIOUp_INTEN_DER
                             | ChipIOUp_INTEN_PER)
                          );


    faSingleThreadedLeave( hpRoot, CStateInitializeFailed );

    if(thread->currentState == CStateInitializeFailed )
    {
        osFCLayerAsyncEvent( hpRoot, osFCLinkDead );
    }

    faSingleThreadedEnter( hpRoot, CStateInitializeFailed );

    pCThread->ChanInfo.CurrentAddress.Domain = 0;
    pCThread->ChanInfo.CurrentAddress.Area   = 0;
    osChipIOUpWriteBit32( hpRoot, ChipIOUp_My_ID, (fiComputeCThread_S_ID(pCThread)));

    fiLogString(hpRoot,
                    "CAIF FM %08X TL %08X FiFMS %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    pCThread->From_IMQ_Frame_Manager_Status,0,0,0,0,0);

    CFuncYellowLed(hpRoot, agFALSE);

    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: CActionLoopFailedReInit
   Purpose: Terminate until some external action is taken. All outstanding IOs killed.
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncCompleteActiveCDBThreadsOnDevice
-*/
/*  CStateLoopFailedReInit 17 */
extern void CActionLoopFailedReInit( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    agRoot_t      * hpRoot      = thread->hpRoot;
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    DevThread_t   * pDevThread;
    fiList_t      * pDevList;

    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot (%p) In %s - State = %d",
                    "CALFRI",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "FM Status %08X FM Config %08X TL Status %08X TL Control %08X Rec Alpa Reg %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0);

    pDevList = &pCThread->Active_DevLink;
    pDevList = pDevList->flink;

    while((&pCThread->Active_DevLink) != pDevList)
    {
        pDevThread = hpObjectBase(DevThread_t,
                              DevLink,pDevList );

        pDevList = pDevList->flink;

        CFuncCompleteActiveCDBThreadsOnDevice(pDevThread ,osIODevReset,  CDBEventIODeviceReset );

    }

    if(pCThread->CDBpollingCount)
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "%s Ccnt Non Zero Ccnt %x",
                    "CALFRI",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->CDBpollingCount,
                    0,0,0,0,0,0,0);
    }

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot (%p) Out %s - State = %d",
                    "CALFRI",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(hpRoot)->LOOP_DOWN,
                    CThread_ptr(hpRoot)->IDLE_RECEIVED,
                    CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                    CThread_ptr(hpRoot)->ERQ_FROZEN,
                    CThread_ptr(hpRoot)->FCP_FROZEN,
                    CThread_ptr(hpRoot)->ProcessingIMQ,
                    0,0);
    if( pCThread->LoopPreviousSuccess )
    {
        pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
    }

    fiLogString(hpRoot,
                    "%s FM Stat %08X LPS %x",
                    "CALFRI",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    pCThread->LoopPreviousSuccess,
                    0,0,0,0,0,0);


    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: CActionFindDeviceUseAllALPAs
   Purpose: Find devices using open to all valid ALPAs. Does not login to a device if 
            already has devthread. Bails out if link event. Does DevThreadAlloc until
            stack depth reached then polls to free up resources.
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncAll_clear
            CFuncCheckIfPortActive
            DevThreadAlloc
            DevEventLogin
            CFuncCompleteActiveCDBThreadsOnDevice
            DevThreadFree
            CFuncQuietShowWhereDevThreadsAre
            CFuncInterruptPoll

-*/
/* CStateFindDevice       18 */
extern void CActionFindDeviceUseAllALPAs( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t      * hpRoot      = thread->hpRoot;
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    DevThread_t   * pDevThread;
    FC_Port_ID_t    Port_ID;
    fiList_t      * pDevList;

    os_bit32         AL_PA_Index=0;

    CFuncYellowLed(hpRoot, agFALSE);
    /* DRL find dev thread*/
    CFuncShowWhereDevThreadsAre( hpRoot);

    fiLogString(hpRoot,
                "IN %s FM %08X TL %08X AC %x ADISC Cnt %d FDcnt %d",
                "CAFDAll",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                CFuncAll_clear( hpRoot ),
                pCThread->ADISC_pollingCount,
                pCThread->FindDEV_pollingCount,
                0,0,0);

    fiLogString(hpRoot,
                "%d IN %s Free %d Active %d Un %d Login %d",
                "CAFDAll",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)thread->currentState,
				fiNumElementsOnList(&pCThread->Free_DevLink),
				fiNumElementsOnList(&pCThread->Active_DevLink),
				fiNumElementsOnList(&pCThread->Unknown_Slot_DevLink),
				fiNumElementsOnList(&pCThread->AWaiting_Login_DevLink),
                0,0,0 );

    fiLogString(hpRoot,
                "IN %s ADISC %d SS %d PrevA login %d Prev Un %d",
                "CAFDAll",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
				fiNumElementsOnList(&pCThread->AWaiting_ADISC_DevLink),
				fiNumElementsOnList(&pCThread->Slot_Searching_DevLink),
				fiNumElementsOnList(&pCThread->Prev_Active_DevLink),
				fiNumElementsOnList(&pCThread->Prev_Unknown_Slot_DevLink),
                0,0,0,0 );

    fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "hpRoot %p Before %s - State = %d CCnt %x Dev %d FDcnt %x InIMQ %x",
                "CAFDAll",(char *)agNULL,
                thread->hpRoot,(void *)agNULL,
                (os_bit32)thread->currentState,
                pCThread->CDBpollingCount,
                fiNumElementsOnList(&pCThread->Active_DevLink),
                pCThread->FindDEV_pollingCount,
                pCThread->ProcessingIMQ,
                0,0,0);

    if( CFuncAll_clear( hpRoot ) )
    {

        if( fiListElementOnList( (fiList_t *)(&(pCThread->Timer_Request)),
                                       &(pCThread->TimerQ)))
        {   /* If timer is active kill it things should be ok */
            fiTimerStop( &(pCThread->Timer_Request));
        }
        AL_PA_Index = sizeof(Alpa_Index);

        while(AL_PA_Index--)
        {
            if(pCThread->FindDEV_pollingCount > pCThread->NumberOutstandingFindDevice )
            {/* This limits the stack depth */
                fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s pCThread->FindDEV_pollingCount > NumberOutstandingFindDevice %x",
                            "CAFDAll",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCThread->NumberOutstandingFindDevice,
                            0,0,0,0,0,0,0 );


                if(CFuncInterruptPoll( hpRoot,&pCThread->FindDEV_pollingCount ))
                {
                    fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "%s Find Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                            "CAFDAll",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                            osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                            0,0,0,0);
                }

            }
            if( ! CFuncAll_clear( hpRoot ) )
            {
                  break;
            }

            if( CFuncShowWhereDevThreadsAre( hpRoot))
            {
                fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "%s AL_PA_Index %X AL_PA %X FDnt %x",
                            "CFuncShowWhereDevThreadsAre",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            AL_PA_Index,
                            Alpa_Index[AL_PA_Index],
                            pCThread->FindDEV_pollingCount,
                            0,0,0,0,0);

            } /*if( CFuncShowWhereDevThreadsAre( hpRoot)) */

            if(  Alpa_Index[AL_PA_Index] != 0xFF           )
            {
                if( AL_PA_Index == pCThread->ChanInfo.CurrentAddress.AL_PA ||
                    AL_PA_Index == 0                                           )
                {
                    continue;
                }

                Port_ID.Struct_Form.reserved = 0;
                Port_ID.Struct_Form.Domain = 0;
                Port_ID.Struct_Form.Area   = 0;
                Port_ID.Struct_Form.AL_PA = (os_bit8)AL_PA_Index;

            }
            else
            {
                continue;
            }

            if( CFuncCheckIfPortActive( hpRoot,  Port_ID))
            {
                continue;
            }

            if( thread->currentState != CStateFindDevice )
            {
                fiSetEventRecord(eventRecord,thread,CEventLoopEventDetected);
                return;
            }

            pDevThread = DevThreadAlloc( hpRoot,Port_ID );

            if(pDevThread != (DevThread_t *)agNULL )
            {
                pDevThread->Plogi_Reason_Code = PLOGI_REASON_DEVICE_LOGIN;

                fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);
            }
            else
            {
                fiLogDebugString(thread->hpRoot,
                        CStateLogConsoleERROR,
                        "In %s - State = %d  CCnt %x FDcnt %x Ran out of DEVTHREADs !!!!!!!",
                        "CAFDAll",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        pCThread->CDBpollingCount,
                        pCThread->FindDEV_pollingCount,
                        0,0,0,0,0);

                fiLogString(hpRoot,
                            "%s (DT) Free %d Active %d Un %d Login %d",
                            "CAFDAll",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
				            fiNumElementsOnList(&pCThread->Free_DevLink),
				            fiNumElementsOnList(&pCThread->Active_DevLink),
				            fiNumElementsOnList(&pCThread->Unknown_Slot_DevLink),
				            fiNumElementsOnList(&pCThread->AWaiting_Login_DevLink),
                            0,0,0,0 );
                fiLogString(hpRoot,
                            "%s (DT) ADISC %d SS %d PrevA login %d Prev Un %d",
                            "CAFDAll",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
				            fiNumElementsOnList(&pCThread->AWaiting_ADISC_DevLink),
				            fiNumElementsOnList(&pCThread->Slot_Searching_DevLink),
				            fiNumElementsOnList(&pCThread->Prev_Active_DevLink),
				            fiNumElementsOnList(&pCThread->Prev_Unknown_Slot_DevLink),
                            0,0,0,0 );

                /* We Must poll now becase threads are awaiting processing */
                if(CFuncInterruptPoll( hpRoot,&pCThread->FindDEV_pollingCount ))
                {
                    fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "FDA1 Find Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Received_ALPA),
                            0,0,0,0);
                }

                if(  fiListNotEmpty(&pCThread->Unknown_Slot_DevLink ) )
                {
                    while(  fiListNotEmpty(&pCThread->Unknown_Slot_DevLink ) )
                    {
                        fiListDequeueFromHeadFast(&pDevList,
                                                  &pCThread->Unknown_Slot_DevLink );
                        pDevThread = hpObjectBase(DevThread_t,
                                                  DevLink,pDevList );

                        if(pDevThread->thread_hdr.currentState == DevStateLoginFailed)
                        {

                            CFuncCompleteActiveCDBThreadsOnDevice(pDevThread ,osIODevReset,  CDBEventIODeviceReset );
                            DevThreadFree(hpRoot,pDevThread);
                            CFuncQuietShowWhereDevThreadsAre( hpRoot);
                        }
                        else
                        {
                            fiLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    "Unknown_Slot_DevLink Dev %p Alpa %X FDcnt %x",
                                    (char *)agNULL,(char *)agNULL,
                                    pDevThread,(void *)agNULL,
                                    Alpa_Index[AL_PA_Index],
                                    pCThread->FindDEV_pollingCount,
                                    0,0,0,0,0,0);

                            fiListEnqueueAtHead(&pDevList,
                                                &pCThread->Unknown_Slot_DevLink );
                            break;
                        }

                    }
                }

            }/*End DevThreadAlloc fail*/
            pCThread->FuncPtrs.Proccess_IMQ(thread->hpRoot);

            if( thread->currentState != CStateFindDevice )
            {
                fiSetEventRecord(eventRecord,thread,CEventLoopEventDetected);
                return;
            }

            if(  fiListNotEmpty(&pCThread->Unknown_Slot_DevLink ) )
            {
                if(CFuncShowWhereDevThreadsAre( hpRoot)) CFuncWhatStateAreDevThreads( hpRoot );

                fiListDequeueFromHeadFast(&pDevList,
                                          &pCThread->Unknown_Slot_DevLink );
                
                pDevThread = hpObjectBase(DevThread_t,
                                          DevLink,pDevList );
                if(pDevThread->thread_hdr.currentState == DevStateLoginFailed)
                {
                    CFuncCompleteActiveCDBThreadsOnDevice(pDevThread ,osIODevReset,  CDBEventIODeviceReset );
                    DevThreadFree(hpRoot,pDevThread);
                    CFuncQuietShowWhereDevThreadsAre( hpRoot);

                }
                else
                {
                    fiListEnqueueAtHead(&pDevList,
                                        &pCThread->Unknown_Slot_DevLink );

                }
            }

        }/* End while(AL_PA_Index--) */

        if(CFuncShowWhereDevThreadsAre( hpRoot)) CFuncWhatStateAreDevThreads( hpRoot );

        /* We Must poll now becase bad ALPA / FTO will freeze the chip */
        if(CFuncInterruptPoll( hpRoot,&pCThread->FindDEV_pollingCount ))
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "FDA2 Find Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0);
        }

        if(CFuncShowWhereDevThreadsAre( hpRoot)) CFuncWhatStateAreDevThreads( hpRoot );
        if(CFuncInterruptPoll( hpRoot,&pCThread->FindDEV_pollingCount ))

        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "FDA3 Find Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0);
            fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "In %s - State = %d   ALPA %X CCnt %x",
                    "CAFDAll",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0xbad,
                    pCThread->CDBpollingCount,0,0,0,0,0);
        }

        if(CFuncShowWhereDevThreadsAre( hpRoot)) CFuncWhatStateAreDevThreads( hpRoot );

        if(  fiListNotEmpty(&pCThread->Unknown_Slot_DevLink ) )
        {
            while(  fiListNotEmpty(&pCThread->Unknown_Slot_DevLink ) )
            {
                if(CFuncShowWhereDevThreadsAre( hpRoot)) CFuncWhatStateAreDevThreads( hpRoot );
                  
                fiListDequeueFromHead(&pDevList,
                                          &pCThread->Unknown_Slot_DevLink );


                pDevThread = hpObjectBase(DevThread_t,
                                          DevLink,pDevList );

                if(pDevThread->thread_hdr.currentState == DevStateLoginFailed)
                {

                    CFuncCompleteActiveCDBThreadsOnDevice(pDevThread ,osIODevReset,  CDBEventIODeviceReset );
                    DevThreadFree(hpRoot,pDevThread);
                    CFuncQuietShowWhereDevThreadsAre( hpRoot);

                }
                else
                {
                    fiListEnqueueAtHead(&pDevList,
                                        &pCThread->Unknown_Slot_DevLink );
                    break;
                }
            }
        }

        if(CFuncShowWhereDevThreadsAre( hpRoot)) CFuncWhatStateAreDevThreads( hpRoot );

        fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot %p After %s - State = %d CCnt %x EL %d FDcnt %x",
                        "CAFDAll",(char *)agNULL,
                        thread->hpRoot,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        pCThread->CDBpollingCount,
                        fiNumElementsOnList(&pCThread->Active_DevLink),
                        pCThread->FindDEV_pollingCount,
                        0,0,0,0);


        pCThread->LoopPreviousSuccess = agTRUE;

        if(CFuncShowWhereDevThreadsAre( hpRoot)) CFuncWhatStateAreDevThreads( hpRoot );

        fiSetEventRecord(eventRecord,thread,CEventDeviceListEmpty);
    }
    else /* Not CFuncAll_clear */
    {
        if( CFuncAll_clear( hpRoot ) )/*Free version gets here reaction !*/
        {
            pCThread->LoopPreviousSuccess = agTRUE;
            /*+ Check This DRL  -*/
            fiSetEventRecord(eventRecord,thread,CEventDeviceListEmpty);
        }
        else
        {
        }
    }

    pCThread->FuncPtrs.Proccess_IMQ(hpRoot);
    /* See if Link event occured */
    if( thread->currentState != CStateFindDevice)
    {
        fiSetEventRecord(eventRecord,thread,CEventLoopEventDetected);
    }

    if( CThread_ptr(thread->hpRoot)->ReScanForDevices )
    {
            pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
            fiSetEventRecord(eventRecord,thread,CEventLoopEventDetected);
            fiLogString(hpRoot,
                        "%s %s",
                        "CAFDAll","ReScanForDevices",
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0 );
            CThread_ptr(thread->hpRoot)->ReScanForDevices = agFALSE;

    }

    fiLogString(hpRoot,
                "%d End %s Free %d Active %d Un %d Login %d",
                "CAFDAll",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)thread->currentState,
				fiNumElementsOnList(&pCThread->Free_DevLink),
				fiNumElementsOnList(&pCThread->Active_DevLink),
				fiNumElementsOnList(&pCThread->Unknown_Slot_DevLink),
				fiNumElementsOnList(&pCThread->AWaiting_Login_DevLink),
                0,0,0 );
    fiLogString(hpRoot,
                "End %s ADISC %d SS %d PrevA login %d Prev Un %d",
                "CAFDAll",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
				fiNumElementsOnList(&pCThread->AWaiting_ADISC_DevLink),
				fiNumElementsOnList(&pCThread->Slot_Searching_DevLink),
				fiNumElementsOnList(&pCThread->Prev_Active_DevLink),
				fiNumElementsOnList(&pCThread->Prev_Unknown_Slot_DevLink),
                0,0,0,0 );

    

}

/*+
  Function: CActionFindDeviceUseLoopMap
   Purpose: Find devices using open to all ALPAs in loopmap. Does not login to a device if 
            already has devthread. Bails out if link event. Does DevThreadAlloc until
            stack depth reached then polls to free up resources. Logins into devices in ALPA
            order not LOOPMAP order.
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncAll_clear
            CFuncCheckIfPortActive
            DevThreadAlloc
            DevEventLogin
            CFuncCompleteActiveCDBThreadsOnDevice
            DevThreadFree
            CFuncQuietShowWhereDevThreadsAre
            CFuncInterruptPoll
-*/
/* CStateFindDeviceUseLoopMap         37 */
extern void CActionFindDeviceUseLoopMap( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t      * hpRoot      = thread->hpRoot;
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t * AL_PA_Position_Map        = (FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t *)(CThread_ptr(hpRoot)->Calculation.MemoryLayout.LOOPDeviceMAP.addr.CachedMemory.cachedMemoryPtr);
    DevThread_t   * pDevThread = (DevThread_t *)agNULL;
    FC_Port_ID_t    Port_ID;
    os_bit32        AL_PA_Index   = sizeof(Alpa_Index);
    os_bit32        IndexIntoLoopMap = 0;
/*  os_bit8         LoopMap_Index =0;*/
    agBOOLEAN Found = agFALSE;

    CFuncYellowLed(hpRoot, agFALSE);

    fiLogString(hpRoot,
                    "%p %s State %d InIMQ %x",
                    "CAFDLM",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->ProcessingIMQ,
                    0,0,0,0,0,0);


    if(thread->currentState == CStateFindDeviceUseLoopMap  )
    {
        while(AL_PA_Index--)
        {
            if( CFuncAll_clear( hpRoot ) )
            {
                if(pCThread->FindDEV_pollingCount > pCThread->NumberOutstandingFindDevice )
                {/* This limits the stack depth */
                    fiLogDebugString(hpRoot,
                                FCMainLogErrorLevel,
                                "%s pCThread->FindDEV_pollingCount > NumberOutstandingFindDevice %x",
                                "CAFDLM",(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                pCThread->NumberOutstandingFindDevice,
                                0,0,0,0,0,0,0 );


                    if(CFuncInterruptPoll( hpRoot,&pCThread->FindDEV_pollingCount ))
                    {
                        fiLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "FDA Find Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                                osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                                0,0,0,0);
                    }
                }

                if(  Alpa_Index[AL_PA_Index] != 0xFF )
                {
                    if( AL_PA_Index == pCThread->ChanInfo.CurrentAddress.AL_PA ||
                        AL_PA_Index == 0                                           )
                    {
                        continue;
                    }

                    Port_ID.Struct_Form.reserved = 0;
                    Port_ID.Struct_Form.Domain = 0;
                    Port_ID.Struct_Form.Area   = 0;
                    Port_ID.Struct_Form.AL_PA = (os_bit8)AL_PA_Index;

                }
                else /* Invalid Alpa_Index[AL_PA_Index] */
                {
                    continue;
                }

                if( CFuncCheckIfPortActive( hpRoot,  Port_ID))
                {
                    continue;
                }
                for(IndexIntoLoopMap  =0; IndexIntoLoopMap < AL_PA_Position_Map->AL_PA_Index; IndexIntoLoopMap ++)
                {
                    pDevThread = NULL;
                    Found = agFALSE;
                    if( Port_ID.Struct_Form.AL_PA == AL_PA_Position_Map->AL_PA_Slot[IndexIntoLoopMap])
                    {
                        Found = agTRUE;
                        pDevThread = DevThreadAlloc( hpRoot,Port_ID );
                        break;
                    }
                    else /* AL_PA not in loopmap */
                    {
                        continue;
                    }
                }

                if(pDevThread != (DevThread_t *)agNULL)
                {
                    pDevThread->Plogi_Reason_Code = PLOGI_REASON_DEVICE_LOGIN;
                    fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);
                }
                else
                {
                    if( Found )
                    {
                        fiLogDebugString(thread->hpRoot,
                                CStateLogConsoleERROR,
                                "In %s - State = %d  CCnt %x Ran out of DEVTHREADs !!!!!!!",
                                "CAFDLM",(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                (os_bit32)thread->currentState,
                                pCThread->CDBpollingCount,0,0,0,0,0,0);
                    }
                }
            }
            else/* Not CFuncAll_clear */
            {
                fiSetEventRecord(eventRecord,thread,CEventLoopEventDetected);
                break;
            }
        }/* AL_PA_Index */
    }
    else /*  currentState Not CStateFindDeviceUseLoopMap */
    {
        fiSetEventRecord(eventRecord,thread,CEventLoopEventDetected);
        return;
    }


    
    /* we know ALPA is there Poll after all are sent  */
    /* Some will be done by time we get there         */

    if(CFuncInterruptPoll( hpRoot,&pCThread->FindDEV_pollingCount ))
    {
        fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "FDL Find Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                CStateLogConsoleERROR,
                "In %s - State = %d  FDcnt %x",
                "CAFDLM",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)thread->currentState,
                pCThread->FindDEV_pollingCount,0,0,0,0,0,0);
    }
    if( CFuncAll_clear( hpRoot ) )
    {
        fiLogString(hpRoot,
                        "%p %s State %d InIMQ %x EL %d LM %d",
                        "CAFDLM",(char *)agNULL,
                        thread->hpRoot,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        pCThread->ProcessingIMQ,
                        fiNumElementsOnList(&pCThread->Active_DevLink),
                        CFuncLoopMapRecieved(hpRoot,agTRUE),
                        0,0,0,0);

        pCThread->LoopPreviousSuccess = agTRUE;
        fiSetEventRecord(eventRecord,&pCThread->thread_hdr,CEventDeviceListEmpty);
    }
    else
    {
        fiSetEventRecord(eventRecord,thread,CEventLoopEventDetected);
    }

}

/*+
  Function: CActionFindPtToPtDevice
   Purpose: Attempts to login to device 0. We have not had a point to point device available.
            Doubtful this works.
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncAll_clear
            CFuncCheckIfPortActive
            DevThreadAlloc
            DevEventLogin
            CFuncInterruptPoll
            CEventDeviceListEmpty
-*/
/* CStateFindPtToPtDevice      42 */
extern void CActionFindPtToPtDevice (fi_thread__t *thread, eventRecord_t *eventRecord)
{
    agRoot_t      * hpRoot      = thread->hpRoot;
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    DevThread_t   * pDevThread;
    FC_Port_ID_t    Port_ID;

    CFuncYellowLed(hpRoot, agFALSE);

    Port_ID.Struct_Form.reserved = 0;
    Port_ID.Struct_Form.Domain = 0;
    Port_ID.Struct_Form.Area   = 0;
    Port_ID.Struct_Form.AL_PA  = 0;

    pDevThread = DevThreadAlloc( hpRoot,Port_ID );

    if(pDevThread != (DevThread_t *)agNULL )
    {
        pDevThread->Plogi_Reason_Code = PLOGI_REASON_DEVICE_LOGIN;

        fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);
    }
    else
    {
        fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "In %s - State = %d  FDCnt %x Ran out of DEVTHREADs !!!!!!!",
                "CAFDPT",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)thread->currentState,
                pCThread->FindDEV_pollingCount,0,0,0,0,0,0);

    }

    if(CFuncInterruptPoll( hpRoot, &pCThread->FindDEV_pollingCount ))
    {
        fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "FDP Find Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status),
                osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                CStateLogConsoleERROR,
                "In %s - State = %d FDCnt %x",
                "CAFDPT",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)thread->currentState,
                pCThread->FindDEV_pollingCount,0,0,0,0,0,0);
    }
    pCThread->LoopPreviousSuccess = agTRUE;
    fiSetEventRecord(eventRecord,&pCThread->thread_hdr,CEventDeviceListEmpty);

}

/*+
  Function: CActionFindDeviceUseNameServer
   Purpose: Uses name server information to login to devices.  Does not login to a device if 
            already has devthread. Bails out if link event. Does DevThreadAlloc until
            stack depth reached then polls to free up resources. Removes device if no longer
            in the name server.
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncAll_clear
            CFuncCheckIfPortActive
            DevThreadAlloc
            DevEventLogin
            CFuncCompleteActiveCDBThreadsOnDevice
            DevThreadFree
            CFuncQuietShowWhereDevThreadsAre
            CFuncInterruptPoll

 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncAll_clear
            CFuncCheckIfPortActive
            DevThreadAlloc
            DevEventLogin
            CFuncInterruptPoll
            CEventDeviceListEmpty
-*/
/* CStateFindDeviceUseNameServer      36 */
extern void CActionFindDeviceUseNameServer( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t      * hpRoot      = thread->hpRoot;
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    DevThread_t   * pDevThread;
    FC_Port_ID_t    Port_ID;
    os_bit8         AL_PA_Index=0;
    fiList_t      * pDevList;

    FC_NS_DU_GID_PT_FS_ACC_Payload_t * RegisteredEntries  = (FC_NS_DU_GID_PT_FS_ACC_Payload_t *)(CThread_ptr(hpRoot)->Calculation.MemoryLayout.FabricDeviceMAP.addr.CachedMemory.cachedMemoryPtr);

    CFuncYellowLed(hpRoot, agFALSE);

    if(!(pCThread->DeviceDiscoveryMethod == DDiscoveryQueriedNameService ))
    {
        if(pCThread->InitAsNport)
        {  
            fiSetEventRecord(eventRecord,&pCThread->thread_hdr,CEventGoToInitializeFailed);
            return;
        }
        else
        {
            if(pCThread->LoopMapLIRP_Received )
            {
                fiSetEventRecord(eventRecord,&pCThread->thread_hdr,CEventFindDeviceUseLoopMap);
                return;
            }
            else
            {
                fiSetEventRecord(eventRecord,&pCThread->thread_hdr,CEventInitalizeSuccess);
                return;
            }
        }
    }

    if( fiListElementOnList( (fiList_t *)(&(pCThread->Timer_Request)),
                                   &(pCThread->TimerQ)))
    {   /* If timer is active kill it things should be ok */
        fiTimerStop( &(pCThread->Timer_Request));
    }


    if(CFuncInterruptPoll( hpRoot,&pCThread->FindDEV_pollingCount ))
    {
        fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "CA_UNS Find Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                0,0,0,0);
    }

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p In %s - State = %d InIMQ %x FDCnt %d",
                    "CA_UNS",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->ProcessingIMQ,
                    pCThread->FindDEV_pollingCount,
                    0,0,0,0,0);

    fiLogString(thread->hpRoot,
                "In %s Fpc %x inIMQ %x AC %x",
                "CA_UNS",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                pCThread->FLOGI_pollingCount,
                pCThread->ProcessingIMQ,
                CFuncAll_clear( thread->hpRoot ),
                0,0,0,0,0);

    fiLogString(hpRoot,
                "%d %s Free %d Active %d Un %d Login %d",
                "CA_UNS",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)thread->currentState,
			    fiNumElementsOnList(&pCThread->Free_DevLink),
			    fiNumElementsOnList(&pCThread->Active_DevLink),
			    fiNumElementsOnList(&pCThread->Unknown_Slot_DevLink),
			    fiNumElementsOnList(&pCThread->AWaiting_Login_DevLink),
                0,0,0 );
    fiLogString(hpRoot,
                "   %s ADISC %d SS %d PrevA login %d Prev Un %d",
                "CA_UNS",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
			    fiNumElementsOnList(&pCThread->AWaiting_ADISC_DevLink),
			    fiNumElementsOnList(&pCThread->Slot_Searching_DevLink),
			    fiNumElementsOnList(&pCThread->Prev_Active_DevLink),
			    fiNumElementsOnList(&pCThread->Prev_Unknown_Slot_DevLink),
                0,0,0,0 );

    if(pCThread->Loop_Reset_Event_to_Send == CEventDoInitalize )
    {
        pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
    }


/*
    CFuncShowWhereDevThreadsAre( hpRoot );
*/
    if(  fiListNotEmpty(&pCThread->Unknown_Slot_DevLink ) )
    {
        while(  fiListNotEmpty(&pCThread->Unknown_Slot_DevLink ) )
        {
            fiListDequeueFromHeadFast(&pDevList,
                                  &pCThread->Unknown_Slot_DevLink );

            pDevThread = hpObjectBase(DevThread_t,
                                      DevLink, pDevList);

            if(pDevThread->thread_hdr.currentState == DevStateLoginFailed)
            {
                CFuncCompleteActiveCDBThreadsOnDevice(pDevThread ,osIODevReset,  CDBEventIODeviceReset );
                DevThreadFree(hpRoot,pDevThread);
                CFuncQuietShowWhereDevThreadsAre( hpRoot);

            }
            else
            {
                fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "Unknown_Slot_DevLink Dev %p Alpa %X FDcnt %x",
                        (char *)agNULL,(char *)agNULL,
                        pDevThread,(void *)agNULL,
                        Alpa_Index[AL_PA_Index],
                        pCThread->FindDEV_pollingCount,
                        0,0,0,0,0,0);

                fiListEnqueueAtHead(&pDevList,
                                    &pCThread->Unknown_Slot_DevLink );
                break;
            }
        }
    }
/*
            CFuncShowWhereDevThreadsAre( hpRoot, agTRUE );
*/

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p Before SCAN %s - State = %d InIMQ %x",
                    "CA_UNS",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->ProcessingIMQ,
                    0,0,0,0,0,0);

    if(  fiListNotEmpty(&pCThread->Active_DevLink ) )
    {
        fiListEnqueueListAtTailFast(&pCThread->Active_DevLink,&pCThread->Prev_Active_DevLink);
    }

    if(thread->currentState ==  CStateFindDeviceUseNameServer )
    {
       do
        {
            if ( (RegisteredEntries->Control_Port_ID[AL_PA_Index].Port_ID[0] == pCThread->ChanInfo.CurrentAddress.Domain) &&
                 (RegisteredEntries->Control_Port_ID[AL_PA_Index].Port_ID[1] == pCThread->ChanInfo.CurrentAddress.Area) &&
                 (RegisteredEntries->Control_Port_ID[AL_PA_Index].Port_ID[2] == pCThread->ChanInfo.CurrentAddress.AL_PA) )
            {
                AL_PA_Index++;
                continue;
            }

            if(pCThread->FindDEV_pollingCount > pCThread->NumberOutstandingFindDevice )
            {/* This limits the stack depth */
                fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s pCThread->FindDEV_pollingCount > NumberOutstandingFindDevice %x",
                            "CA_UNS",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCThread->NumberOutstandingFindDevice,
                            0,0,0,0,0,0,0 );


                if(CFuncInterruptPoll( hpRoot,&pCThread->FindDEV_pollingCount ))
                {
                    fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "CA_UNS Find Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                            osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                            0,0,0,0);
                }

            }
            Port_ID.Struct_Form.reserved = 0;
            Port_ID.Struct_Form.Domain = RegisteredEntries->Control_Port_ID[AL_PA_Index].Port_ID[0];
            Port_ID.Struct_Form.Area   = RegisteredEntries->Control_Port_ID[AL_PA_Index].Port_ID[1];
            Port_ID.Struct_Form.AL_PA  = RegisteredEntries->Control_Port_ID[AL_PA_Index].Port_ID[2];

            /* This port_id is on name server and is on prev active list put it on active */
            if( CFuncCheckIfPortPrev_Active( hpRoot,  Port_ID))
            {

                pDevThread = CFuncMatchALPAtoThread( hpRoot, Port_ID);
                fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "CA_UNS (%p)Port_ID %X found in database",
                        (char *)agNULL,(char *)agNULL,
                        pDevThread,(void *)agNULL,
                        Port_ID.Bit32_Form,
                        0,0,0,0,0,0,0);


                if(fiListElementOnList(&pDevThread->DevLink,&pCThread->Prev_Active_DevLink ))
                {
                    fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "CA_UNS (%p)Port_ID %X put on active list",
                            (char *)agNULL,(char *)agNULL,
                            pDevThread,(void *)agNULL,
                            Port_ID.Bit32_Form,
                            0,0,0,0,0,0,0);

                    fiListDequeueThis(&pDevThread->DevLink );
                    fiListEnqueueAtTail(&pDevThread->DevLink,&pCThread->Active_DevLink );
                    AL_PA_Index++;
                    continue;
                }
                else
                {
                    fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "CA_UNS (%p)Port_ID %X  NOT FOUND !",
                            (char *)agNULL,(char *)agNULL,
                            pDevThread,(void *)agNULL,
                            Port_ID.Bit32_Form,
                            0,0,0,0,0,0,0);


                }

            }

            pDevThread = DevThreadAlloc( hpRoot,Port_ID );

            if(pDevThread != (DevThread_t *)agNULL )
            {
                pDevThread->Plogi_Reason_Code = PLOGI_REASON_DEVICE_LOGIN;

                fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);
            }
            else
            {
                fiLogDebugString(thread->hpRoot,
                        CStateLogConsoleERROR,
                        "In %s - State = %d  FDCnt %x Ran out of DEVTHREADs !!!!!!!",
                        "CA_UNS",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        pCThread->FindDEV_pollingCount,0,0,0,0,0,0);

                if(CFuncInterruptPoll( hpRoot,&pCThread->FindDEV_pollingCount ))
                {
                    fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "Find Dev CA_UNS Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                            osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                            0,0,0,0);
                }

            }

            /* we know ALPA is there Poll after all are sent  */
            /* Some will be done by time we get there         */
            if(CFuncInterruptPoll( hpRoot,&pCThread->FindDEV_pollingCount ))
            {
                fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "CA_UNS Find Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status),
                        osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                        0,0,0,0);
                fiLogDebugString(thread->hpRoot,
                        CStateLogConsoleERROR,
                        "In %s - State = %d  CDBCnt %x FDCnt %x",
                        "CA_UNS",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        pCThread->CDBpollingCount,
                        pCThread->FindDEV_pollingCount,0,0,0,0,0);
            }
            AL_PA_Index++;

        } while (RegisteredEntries->Control_Port_ID[AL_PA_Index - 1].Control != FC_NS_Control_Port_ID_Control_Last_Port_ID);

        fiLogString(hpRoot,
                    "%d %s Free %d Active %d Un %d Login %d",
                    "1 CA_UNS",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
			        fiNumElementsOnList(&pCThread->Free_DevLink),
			        fiNumElementsOnList(&pCThread->Active_DevLink),
			        fiNumElementsOnList(&pCThread->Unknown_Slot_DevLink),
			        fiNumElementsOnList(&pCThread->AWaiting_Login_DevLink),
                    0,0,0 );
        fiLogString(hpRoot,
                    "   %s ADISC %d SS %d PrevA login %d Prev Un %d",
                    "1 CA_UNS",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
			        fiNumElementsOnList(&pCThread->AWaiting_ADISC_DevLink),
			        fiNumElementsOnList(&pCThread->Slot_Searching_DevLink),
			        fiNumElementsOnList(&pCThread->Prev_Active_DevLink),
			        fiNumElementsOnList(&pCThread->Prev_Unknown_Slot_DevLink),
                    0,0,0,0 );

        if(  fiListNotEmpty(&pCThread->Prev_Active_DevLink ) )
        {
            while(  fiListNotEmpty(&pCThread->Prev_Active_DevLink ) )
            {
                fiListDequeueFromHeadFast(&pDevList,
                                      &pCThread->Prev_Active_DevLink );

                pDevThread = hpObjectBase(DevThread_t,
                                          DevLink, pDevList);

                fiSendEvent(&pDevThread->thread_hdr,DevEvent_Device_Gone);

            }
        }

        fiLogString(hpRoot,
                    "%d %s Free %d Active %d Un %d Login %d",
                    "2 CA_UNS",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
			        fiNumElementsOnList(&pCThread->Free_DevLink),
			        fiNumElementsOnList(&pCThread->Active_DevLink),
			        fiNumElementsOnList(&pCThread->Unknown_Slot_DevLink),
			        fiNumElementsOnList(&pCThread->AWaiting_Login_DevLink),
                    0,0,0 );
        fiLogString(hpRoot,
                    "   %s ADISC %d SS %d PrevA login %d Prev Un %d",
                    "2 CA_UNS",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
			        fiNumElementsOnList(&pCThread->AWaiting_ADISC_DevLink),
			        fiNumElementsOnList(&pCThread->Slot_Searching_DevLink),
			        fiNumElementsOnList(&pCThread->Prev_Active_DevLink),
			        fiNumElementsOnList(&pCThread->Prev_Unknown_Slot_DevLink),
                    0,0,0,0 );

        fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot %p After SCAN %s - State = %d InIMQ %x",
                        "CA_UNS",(char *)agNULL,
                        thread->hpRoot,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        pCThread->ProcessingIMQ,
                        0,0,0,0,0,0);


        if(CFuncInterruptPoll( hpRoot,&pCThread->FindDEV_pollingCount ))
        {

            fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "In %s - State = %d  CDBCnt %x",
                    "CA_UNS",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->CDBpollingCount,
                    0,0,0,0,0,0);

            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "FDNS Find Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0);
        }

        pCThread->LoopPreviousSuccess = agTRUE;
        if( fiNumElementsOnList(&pCThread->Active_DevLink) == 0 )
        {

            fiLogString(thread->hpRoot,
                            "CA_UNS - Empty Fadb %d Cfm %d",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            (os_bit32)pCThread->FoundActiveDevicesBefore,
                            CFuncCheckFabricMap(thread->hpRoot,agFALSE),0,0,0,0,0,0);
            if(pCThread->FoundActiveDevicesBefore)
            {
                pCThread->FoundActiveDevicesBefore = agFALSE; /*So we don't do this forever... */
                fiSetEventRecord(eventRecord,&pCThread->thread_hdr,CEventLoopEventDetected);
                return;
            }
        }
        else
        {
            if( fiNumElementsOnList(&pCThread->Active_DevLink) != CFuncCheckFabricMap( thread->hpRoot,agTRUE) )
            {
                fiLogString(thread->hpRoot,
                                "CA_UNS - EL %d != CFM %d",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                fiNumElementsOnList(&pCThread->Active_DevLink),
                                CFuncCheckFabricMap( thread->hpRoot,agFALSE),
                                0,0,0,0,0,0);
            }
            if( CFuncCountFC4_Devices(thread->hpRoot) == 0)
            {
                fiLogString(thread->hpRoot,
                            "Just nonFC4 Devices %d Fadb %d",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            fiNumElementsOnList(&pCThread->Active_DevLink),
                            (os_bit32)pCThread->FoundActiveDevicesBefore,
                            0,0,0,0,0,0);
                if( CThread_ptr(thread->hpRoot)->ReScanForDevices )
                {
                        pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
                        fiSetEventRecord(eventRecord,thread,CEventLoopEventDetected);
                        fiLogString(hpRoot,
                                    "%s %s",
                                    "CA_UNS","ReScanForDevices",
                                    (void *)agNULL,(void *)agNULL,
                                    0,0,0,0,0,0,0,0 );
                        CThread_ptr(thread->hpRoot)->ReScanForDevices = agFALSE;
                        return;
                }
                if(pCThread->FoundActiveDevicesBefore)
                {
                    pCThread->FoundActiveDevicesBefore = agFALSE; /*So we don't do this forever... */

                    fiSetEventRecord(eventRecord,&pCThread->thread_hdr,CEventLoopEventDetected);
                    return;
                }
            }
            else
            {
                if( CThread_ptr(thread->hpRoot)->ReScanForDevices )
                {
                        pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
                        fiSetEventRecord(eventRecord,thread,CEventLoopEventDetected);
                        fiLogString(hpRoot,
                                    "%s %s",
                                    "CA_UNS","ReScanForDevices",
                                    (void *)agNULL,(void *)agNULL,
                                    0,0,0,0,0,0,0,0 );
                        CThread_ptr(thread->hpRoot)->ReScanForDevices = agFALSE;
                        return;
                }
            }
        }

        fiLogString(thread->hpRoot,
                    "Out %s FDpc %x inIMQ %x AC %x",
                    "CA_UNS",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->FindDEV_pollingCount,
                    pCThread->ProcessingIMQ,
                    CFuncAll_clear( thread->hpRoot ),
                    0,0,0,0,0);

        fiLogDebugString(thread->hpRoot,
                        CStateLogConsoleERROR,
                        "In %s - State = %d  CCnt %x FC4 Devices %d ReScanForDevices %d",
                        "CA_UNS",(char *)NULL,
                        (void *)agNULL,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        pCThread->FindDEV_pollingCount,
                        CFuncCountFC4_Devices(thread->hpRoot),
                        CThread_ptr(thread->hpRoot)->ReScanForDevices,
                        0,0,0,0);
 
        if( CFuncCountFC4_Devices(thread->hpRoot) != 0)
        {
            pCThread->FoundActiveDevicesBefore = agTRUE;
        }
        fiSetEventRecord(eventRecord,&pCThread->thread_hdr,CEventDeviceListEmpty);
    }
    else /* if(thread->currentState !=  CStateFindDeviceUseNameServer ) */
    {
           fiLogString(thread->hpRoot,
                    "Out %s State Change FDpc %x inIMQ %x AC %x CState %d",
                    "CA_UNS",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->FindDEV_pollingCount,
                    pCThread->ProcessingIMQ,
                    CFuncAll_clear( thread->hpRoot ),
                    thread->currentState,
                    0,0,0,0);
        if(pCThread->Loop_Reset_Event_to_Send == CEventDoInitalize )
        {
            pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
        }

        fiSetEventRecord(eventRecord,thread,CEventLoopEventDetected);
    }

    if(pCThread->Loop_Reset_Event_to_Send == CEventDoInitalize )
    {
        pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
    }
    /* Clean up list after completion */
    while(fiListNotEmpty(&pCThread->Prev_Unknown_Slot_DevLink ))
    {
        fiListDequeueFromHeadFast(&pDevList,
                                  &pCThread->Prev_Unknown_Slot_DevLink );
        pDevThread = hpObjectBase(DevThread_t,
                                  DevLink,pDevList );

        DevThreadFree( hpRoot, pDevThread );
    }

    fiLogString(thread->hpRoot,
                "Bottom %s FDpc %x inIMQ %x AC %x CState %d LRES %d",
                "CA_UNS",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                pCThread->FindDEV_pollingCount,
                pCThread->ProcessingIMQ,
                CFuncAll_clear( thread->hpRoot ),
                thread->currentState,
                pCThread->Loop_Reset_Event_to_Send,
                0,0,0);


}

/*+
  Function: CActionElasticStoreEventStorm
   Purpose: If timer running ignore everything, reinitialize channel after timeout period.
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncCompleteAllActiveCDBThreads
            CFuncDisable_Interrupts
            fiTimerStart
            CEventDoInitalize
-*/
/* CStateElasticStoreEventStorm           19 */
extern void CActionElasticStoreEventStorm( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    CThread_t       * pCThread = CThread_ptr(thread->hpRoot);

    CFuncYellowLed(thread->hpRoot, agFALSE);

    faSingleThreadedLeave( thread->hpRoot, CStateElasticStoreEventStorm );

    osFCLayerAsyncEvent( thread->hpRoot, osFCLinkDown );

    faSingleThreadedEnter( thread->hpRoot, CStateElasticStoreEventStorm);

    CFuncCompleteAllActiveCDBThreads( thread->hpRoot,osIOAborted,CDBEventIODeviceReset );

    CFuncDisable_Interrupts(thread->hpRoot,ChipIOUp_INTEN_MASK);

    fiLogString(thread->hpRoot,
                    "%s",
                    "CActionElasticStoreEventStorm",(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p Out %s",
                    "CActionElasticStoreEventStorm",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    if( pCThread->TimerTickActive )
    {
        if(! fiListElementOnList( (fiList_t *)(&(pCThread->Timer_Request)),
                                       &(pCThread->TimerQ)))
        {
            if (!(pCThread->InitAsNport))
                fiTimerSetDeadlineFromNow(thread->hpRoot, &pCThread->Timer_Request, CLipStormQueisingTOV);
            else
                fiTimerSetDeadlineFromNow(thread->hpRoot, &pCThread->Timer_Request, CReinitNportAfterFailureDetectionTOV);

            pCThread->Timer_Request.eventRecord_to_send.thread= thread;

            pCThread->Timer_Request.eventRecord_to_send.event = CEventDoInitalize;

            fiTimerStart(thread->hpRoot,&pCThread->Timer_Request);

        }

        fiSetEventRecordNull(eventRecord);
    }
    else
    {
        fiSetEventRecord(eventRecord,thread,CEventDoInitalize);
    }

    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: CActionLIPEventStorm
   Purpose: If timer running ignore everything, reinitialize channel after timeout period.
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncCompleteAllActiveCDBThreads
            CFuncDisable_Interrupts
            fiTimerStart
            CEventDoInitalize
-*/
/* CStateLIPEventStorm          20 */
extern void CActionLIPEventStorm( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    CThread_t       * pCThread = CThread_ptr(thread->hpRoot);

    CFuncYellowLed(thread->hpRoot, agFALSE);
    CFuncDisable_Interrupts(thread->hpRoot,ChipIOUp_INTEN_MASK);

    fiLogString(thread->hpRoot,
                    "%s",
                    "CActionLIPEventStorm",(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p In %s",
                    "CActionLIPEventStorm",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

        /* Code to start a timer to reinit the card after 10 seconds... */
    faSingleThreadedLeave( thread->hpRoot, CStateLIPEventStorm );

    osFCLayerAsyncEvent( thread->hpRoot, osFCLinkDown );

    faSingleThreadedEnter( thread->hpRoot, CStateLIPEventStorm);

    CFuncCompleteAllActiveCDBThreads( thread->hpRoot,osIOAborted,CDBEventIODeviceReset );

    if( pCThread->TimerTickActive )
    {
        if(! fiListElementOnList( (fiList_t *)(&(pCThread->Timer_Request)),
                                       &(pCThread->TimerQ)))
        {
            fiTimerSetDeadlineFromNow(thread->hpRoot, &pCThread->Timer_Request, CLipStormQueisingTOV);

            pCThread->Timer_Request.eventRecord_to_send.thread= thread;
            pCThread->Timer_Request.eventRecord_to_send.event = CEventDoInitalize;

            fiTimerStart(thread->hpRoot,&pCThread->Timer_Request);

        }

        fiSetEventRecordNull(eventRecord);
    }
    else
    {
        fiSetEventRecord(eventRecord,thread,CEventDoInitalize);
    }
}

/*+
  Function: CActionExternalLogout
   Purpose: Old code for LOGO recovery, no longer implemented this way.
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncCompleteAllActiveCDBThreads
-*/
/* CStateExternalLogout          22 */
extern void CActionExternalLogout( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    CThread_t       * pCThread = CThread_ptr(thread->hpRoot);

    DevThread_t     * pDevThread;
    fiList_t        * pDevList;

    /*+ Check This DRL  -*/
    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogString(thread->hpRoot,
                    "%s",
                    "CActionExternalLogout",(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p In %s - State = %d Prev_Unknown_Slot_DevLink %x EL %d",
                    "CActionExternalLogout",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiListNotEmpty(&pCThread->Prev_Unknown_Slot_DevLink),
                    fiNumElementsOnList(&pCThread->Active_DevLink),
                    0,0,0,0,0);

    faSingleThreadedLeave( thread->hpRoot, CStateExternalLogout );

    osFCLayerAsyncEvent( thread->hpRoot, osFCLinkDown );

    faSingleThreadedEnter( thread->hpRoot, CStateExternalLogout);


    pDevList = &pCThread->Active_DevLink;
    pDevList = pDevList->flink;

    while((&pCThread->Active_DevLink) != pDevList)
    {
        pDevThread = (DevThread_t *)hpObjectBase(DevThread_t, DevLink,pDevList );

       if( pDevThread->DevInfo.LoggedIn == agFALSE )
        {
/* */
            fiLogDebugString(thread->hpRoot,
                        CStateLogConsoleERROR,
                        "%s Completing Active IO's Device %X CDBcnt %x",
                        "CActionExternalLogout",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        fiComputeDevThread_D_ID(pDevThread),
                        pCThread->CDBpollingCount,
                        0,0,0,0,0,0);
            CFuncCompleteActiveCDBThreadsOnDevice(pDevThread ,osIODevReset,  CDBEventIODeviceReset );
        }
        pDevList = pDevList->flink;
    }

    if(pCThread->CDBpollingCount)
    {
        fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "%s Ccnt Non Zero CDBcnt %x",
                    "CActionExternalLogout",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->CDBpollingCount,
                    0,0,0,0,0,0,0);
    }

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p Out %s - State = %d Prev_Unknown_Slot_DevLink %x EL %d",
                    "CActionExternalLogout",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiListNotEmpty(&pCThread->Prev_Unknown_Slot_DevLink),
                    fiNumElementsOnList(&pCThread->Active_DevLink),
                    0,0,0,0,0);
    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->LOOP_DOWN,
                    pCThread->IDLE_RECEIVED,
                    pCThread->OUTBOUND_RECEIVED,
                    pCThread->ERQ_FROZEN,
                    pCThread->FCP_FROZEN,
                    pCThread->ProcessingIMQ,
                    0,0);

    pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;

    fiSetEventRecordNull(eventRecord);

}


/*+
  Function: CActionExternalLogoutRecovery
   Purpose: Old code for LOGO recovery, no longer implemented this way.
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncInterruptPoll
            CFuncCompleteAllActiveCDBThreads
-*/
/* CStateExternalLogout          23 */
extern void CActionExternalLogoutRecovery( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    agRoot_t      * hpRoot      = thread->hpRoot;

    CThread_t       * pCThread = CThread_ptr(thread->hpRoot);

    DevThread_t     * pDevThread;
    fiList_t        * pList;

    fiLogString(hpRoot,
                    "%s",
                    "CActionExternalLogoutRecovery",(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    CFuncYellowLed(thread->hpRoot, agFALSE);
/*+ Check This DRL  -*/
    if(pCThread->ProcessingIMQ)
    {
        pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;

        fiSetEventRecord(eventRecord,thread,CEventResetIfNeeded);
        return;
    }

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p In %s - State = %d Prev_Unknown_Slot_DevLink %x EL %d",
                    "CActionExternalLogoutRecovery",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiListNotEmpty(&pCThread->Prev_Unknown_Slot_DevLink),
                    fiNumElementsOnList(&pCThread->Active_DevLink),
                    0,0,0,0,0);
    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->LOOP_DOWN,
                    pCThread->IDLE_RECEIVED,
                    pCThread->OUTBOUND_RECEIVED,
                    pCThread->ERQ_FROZEN,
                    pCThread->FCP_FROZEN,
                    pCThread->ProcessingIMQ,
                    0,0);

    pList = &pCThread->Active_DevLink;
    pList = pList->flink;

    while((&pCThread->Active_DevLink) != pList)
    {
        pDevThread = (DevThread_t *)hpObjectBase(DevThread_t, DevLink,pList );

        if( pDevThread->DevInfo.LoggedIn == agFALSE )
        {
           fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);
        }

        if(CFuncInterruptPoll( hpRoot,&pDevThread->pollingCount ))
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "EXLO Find Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0);
            fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "In %s - State = %d   ALPA %X CDBCnt %x",
                    "CActionExternalLogoutRecovery",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCThread->CDBpollingCount,0,0,0,0,0);
        }

        pList = pList->flink;
    }
    if(pCThread->CDBpollingCount)
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "%s Ccnt Non Zero Ccnt %x",
                    "CActionExternalLogoutRecovery",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->CDBpollingCount,
                    0,0,0,0,0,0,0);
/*
        CFuncCompleteAllActiveCDBThreads( thread->hpRoot,osIOAborted,CDBEventIODeviceReset );
*/

    }

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p Out %s - State = %d Prev_Unknown_Slot_DevLink %x EL %d",
                    "CActionExternalLogoutRecovery",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiListNotEmpty(&pCThread->Prev_Unknown_Slot_DevLink),
                    fiNumElementsOnList(&pCThread->Active_DevLink),
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,thread,CEventDeviceListEmpty);

}

/*+
  Function: CActionExternalDeviceReset
   Purpose: If we get an task management function reset other devices have as well
            High likelyhood of IO timeouts.
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
-*/
/* CStateExternalDeviceReset          21 */
extern void CActionExternalDeviceReset( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    CFuncYellowLed(thread->hpRoot, agFALSE);
/*+ Check This DRL  Mark ADLE -*/
    fiLogString(thread->hpRoot,
                    "%s",
                    "CActionExternalDeviceReset",(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    faSingleThreadedLeave( thread->hpRoot, CStateExternalDeviceReset );

    osFCLayerAsyncEvent( thread->hpRoot, osFCLinkDown );

    faSingleThreadedEnter( thread->hpRoot, CStateExternalDeviceReset);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p Out %s",
                    "CActionDoExternalDeviceReset",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: CActionDoExternalDeviceReset
   Purpose: This is the recovery action to CActionExternalDeviceReset
            Returns to CActionNormal on completion
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncCompleteAllActiveCDBThreads
            CFuncFreezeQueuesPoll
            CFunc_Always_Enable_Queues
            DevEventExternalDeviceReset
            CFuncInterruptPoll
            CEventDeviceListEmpty
-*/
/* CStateDoExternalDeviceReset          24 */
extern void CActionDoExternalDeviceReset( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t   *    hpRoot          = thread->hpRoot;
    CThread_t  * pCThread = CThread_ptr(hpRoot);

    DevThread_t   * pDevThread;
    fiList_t      * pList;

    fiLogString(hpRoot,
                    "%s",
                    "CActionDoExternalDeviceReset",(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

/*+ Check This DRL  -*/
    CFuncYellowLed(hpRoot, agFALSE);

    faSingleThreadedLeave( thread->hpRoot , CStateDoExternalDeviceReset  );

    osFCLayerAsyncEvent( thread->hpRoot, osFCLinkDown );

    faSingleThreadedEnter( thread->hpRoot, CStateDoExternalDeviceReset );

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p In %s",
                    "CActionExternalDeviceReset",(char *)agNULL,
                    hpRoot,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    CFuncFreezeQueuesPoll(hpRoot);

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "LD %x IR %x OR %x ERQ %x FCP %x Queues %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->LOOP_DOWN,
                    pCThread->IDLE_RECEIVED,
                    pCThread->OUTBOUND_RECEIVED,
                    pCThread->ERQ_FROZEN,
                    pCThread->FCP_FROZEN,
                    CFunc_Queues_Frozen( hpRoot ),
                    0,0);

    if ( CFunc_Always_Enable_Queues(hpRoot ) )
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p)EXT Loop Fail Queues Frozen after Enable",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
    }



    pList = &pCThread->Active_DevLink;
    pList = pList->flink;

    while((&pCThread->Active_DevLink) != pList)
    {
        pDevThread = (DevThread_t *)hpObjectBase(DevThread_t, DevLink,pList );
        pList = pList->flink;

        if( pDevThread->DevInfo.DeviceType & agDevSCSITarget)
        {

           fiSendEvent(&pDevThread->thread_hdr,DevEventExternalDeviceReset);

        }
    }

    if(CFuncInterruptPoll( hpRoot,&pCThread->DEVReset_pollingCount ))
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "EDR Find Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0);
/*
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "In %s - State = %d   ALPA %X CCnt %x DCnt %x",
                    "CActionExternalDeviceReset",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCThread->CDBpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0);
*/
    }

    fiSetEventRecord(eventRecord,thread,CEventDeviceListEmpty);
}

/*+
  Function: CActionSendPrimitive
   Purpose: This action used to send a primitive sequence does not any longer
            Just brings the Loop down.
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncTakeOffline
            CEventResetDetected
            CEventDoInitalize
-*/
/*  CStateSendPrimitive  25 */
extern void CActionSendPrimitive( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    agRoot_t  *hpRoot  = thread->hpRoot;
    CThread_t  *    pCThread        = CThread_ptr(hpRoot);

    fiLogString(hpRoot,
                    "%s",
                    "CActionSendPrimitive",(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    CFuncYellowLed(hpRoot, agFALSE);
/*+ Check This DRL  -*/
    if (!(pCThread->InitAsNport))
    {
        CFuncTakeOffline(thread->hpRoot);
    }



    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) In %s - State = %d SendPrimativeSuccess %x",
                    "CActionSendPrimitive",(char *)agNULL,
                    hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->PrimitiveReceived,
                    0,0,0,0,0,0);

    if(pCThread->PrimitiveReceived)
    {
        fiSetEventRecord(eventRecord,thread,CEventResetDetected);
    }
    else
    {
        fiSetEventRecord(eventRecord,thread,CEventDoInitalize);

    }

}

/*+
  Function: CActionInitFM_DelayDone
   Purpose: This action is used to bring the loop up without stalling
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncNewInitFM
            CEventInitFMFailure
            CEventInitFMSuccess
-*/
/*  CStateInitFM_DelayDone   26 */
extern void CActionInitFM_DelayDone( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    agRoot_t  *hpRoot  = thread->hpRoot;

    event_t  Initialized_Event    = CEventInitFMSuccess;

    CFuncYellowLed(hpRoot, agFALSE);

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) In %s - State = %d FM Cfg %08x FM Cfg3 %08x",
                    "CAIFM_DD",(char *)agNULL,
                    hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration_3 ),
                    0,0,0,0,0);

    fiLogString(hpRoot,
                    "%s FM %08X TL %08X",
                    "CAIFM_DD",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    0,0,0,0,0,0);


    if(!CFuncNewInitFM( hpRoot ))
    {
        fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "%s failed FM Status %08X FM Config %08X",
                        "CAIFM_DD",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                        0,0,0,0,0,0);

        fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "TL Status %08X TL Control %08X Rec Alpa Reg %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control ),
                        osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                        0,0,0,0,0);


        Initialized_Event = CEventInitFMFailure;
    }


#ifdef WASBEFORE

    if(!CFuncInitFM_Clear_FM( hpRoot ))
    {
        fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "%s failed FM Status %08X FM Config %08X",
                        "CAIFM_DD",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                        0,0,0,0,0,0);

        fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "TL Status %08X TL Control %08X Rec Alpa Reg %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control ),
                        osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                        0,0,0,0,0);
/*
#ifdef NPORT_STUFF */
        /* Failure in initializing FM means we will have to go back
         * to initializing as a LOOP first before retrying NPORT.
         */
 /*       pCThread->InitAsNport = agFALSE;
        pCThread->ConnectedToNportOrFPort = agFALSE;
#endif  */  /* NPORT_STUFF */

        Initialized_Event = CEventInitFMFailure;
    }

#endif
    /* DRL find dev thread*/
    if( CFuncShowWhereDevThreadsAre( hpRoot))
    {
        Initialized_Event = CEventInitFMFailure;
    }

    fiSetEventRecord(eventRecord,thread, Initialized_Event);

}


#ifdef NAME_SERVICES

/*+
  Function: CActionAllocRFT_IDThread
   Purpose: This action used to allocate a SFThread for doing a RFT_ID
            now the previously allocated FLOGI SFThread is used
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CEventDoRFT_ID
-*/
/* CStateAllocRFT_IDThread      27 */
extern void CActionAllocRFT_IDThread( fi_thread__t *thread,eventRecord_t *eventRecord )
{
#ifdef Do_Not_USE_Flogi_SFThread
    agRoot_t *hpRoot= thread->hpRoot;

    CThread_t  * pCThread = CThread_ptr( hpRoot);
    SFThread_t  * pSFThread = pCThread->SFThread_Request.SFThread;

    if(pSFThread != (SFThread_t *) agNULL)
    {
       if( pCThread->SFThread_Request.State == SFThread_Request_Granted)
        {
            fiLogDebugString(thread->hpRoot,
                CStateLogConsoleERROR,
                "pCThread %p Freeing SFThread in %s ",
                "CActionRFT_IDThread",(char *)agNULL,
                pCThread,(void *)agNULL,
                0,0,0,0,0,0,0,0);

            SFThreadFree( hpRoot, &pCThread->SFThread_Request );
            pCThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;
        }
    }

    pCThread->SFThread_Request.eventRecord_to_send.event = CEventDoRFT_ID;
    pCThread->SFThread_Request.eventRecord_to_send.thread = thread;


    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After In %s - State = %d",
                    "CActionAllocRFT_IDThread",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    CFuncDisable_Interrupts(thread->hpRoot,ChipIOUp_INTEN_MASK);
    fiSetEventRecordNull(eventRecord);
    SFThreadAlloc( hpRoot,&pCThread->SFThread_Request );
#endif/* Do_Not_USE_Flogi_SFThread */

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After In %s - State = %d",
                    "CActionAllocRFT_IDThread",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);
    fiSetEventRecord(eventRecord,thread, CEventDoRFT_ID);


}

/*+
  Function: CActionDoRFT_ID
   Purpose: This action  does the RFT_ID
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            fiSendEvent
            CFuncInterruptPoll
            CEventRFT_IDSuccess 
            CEventRFT_IDFail           
-*/
/* CStateDoRFT_ID               28 */
extern void CActionDoRFT_ID( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t *hpRoot= thread->hpRoot;
    CThread_t  * pCThread = CThread_ptr( hpRoot);


    SFThread_t  * pSFThread = pCThread->SFThread_Request.SFThread;
#ifdef Do_Not_USE_Flogi_SFThread
    pSFThread->parent.Device= (DevThread_t *)agNULL;
#endif/* Do_Not_USE_Flogi_SFThread */

    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p Before %s - State = %d",
                    "CActionDoRFT_ID",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);


    fiSetEventRecordNull(eventRecord);

    fiSendEvent(&pSFThread->thread_hdr,SFEventDoRFT_ID);
    if(CFuncInterruptPoll( hpRoot,&pCThread->Fabric_pollingCount ))
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "RFT_ID Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X ",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    0,0,0,0,0);

        fiSetEventRecord(eventRecord,thread,CEventRFT_IDFail);
    }
    else
    {
        if( pSFThread->thread_hdr.currentState == SFStateRFT_IDAccept)
        {
          fiSetEventRecord(eventRecord,thread,CEventRFT_IDSuccess);
        }
        else
        {
          fiSetEventRecord(eventRecord,thread,CEventRFT_IDFail);
        }

    }
    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After  %s - State = %d SFThread %p SFState %d",
                    "CActionDoRFT_ID",(char *)agNULL,
                    thread->hpRoot,pSFThread,
                    (os_bit32)thread->currentState,
                    (os_bit32)pSFThread->thread_hdr.currentState,
                    0,0,0,0,0,0);


}

/*+
  Function: CActionRFT_IDSuccess
   Purpose: This action used to free the SFThread after RFT_ID
            Now does nothing but move to the next state
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CEventAllocGID_FTThread
-*/
/* CStateRFT_IDSuccess          29 */
extern void CActionRFT_IDSuccess( fi_thread__t *thread,eventRecord_t *eventRecord )
{
#ifdef Do_Not_USE_Flogi_SFThread
    SFThreadFree(thread->hpRoot, & pCThread->SFThread_Request );
    pCThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;
#endif/* Do_Not_USE_Flogi_SFThread */
    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After In %s - State = %d",
                    "CActionRFT_IDSuccess",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord, thread, CEventAllocGID_FTThread);
}

/*+
  Function: CActionAllocDiPlogiThread
   Purpose: Allocates PLOGI to the directory server 
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            SFThreadFree
            CFuncShowActiveCDBThreads
            CFuncDisable_Interrupts
            SFThreadAlloc            
-*/
/* CStateAllocDiPlogiThread      30 */
extern void CActionAllocDiPlogiThread( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t *hpRoot= thread->hpRoot;

    CThread_t  * pCThread = CThread_ptr( hpRoot);
    SFThread_t  * pSFThread = pCThread->SFThread_Request.SFThread;
    pCThread->DirectoryServicesStarted = agTRUE;


    if(pSFThread != (SFThread_t *) agNULL)
    {
        if( pCThread->SFThread_Request.State == SFThread_Request_Granted)
        {
            fiLogDebugString(thread->hpRoot,
                CStateLogConsoleERROR,
                "pCThread %p Freeing SFThread in %s ",
                "CActionAllocDiPlogiThread",(char *)agNULL,
                pCThread,(void *)agNULL,
                0,0,0,0,0,0,0,0);

            SFThreadFree( hpRoot, &pCThread->SFThread_Request );
            pCThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;
        }
    }

/*
    pCThread->LinkDownTime = pCThread->TimeBase;
    CFuncShowActiveCDBThreads( hpRoot,ShowERQ);
*/
    pCThread->SFThread_Request.eventRecord_to_send.event = CEventDoDiPlogi;
    pCThread->SFThread_Request.eventRecord_to_send.thread = thread;


    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After In %s - State = %d",
                    "CActionAllocDiPlogiThread",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);

    CFuncDisable_Interrupts(thread->hpRoot,ChipIOUp_INTEN_MASK);

    SFThreadAlloc( hpRoot,&pCThread->SFThread_Request );

}

/*+
  Function: CActionDoDiPlogi
   Purpose: Does PLOGI to the directory server 
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            SFEventDoPlogi
            CFuncInterruptPoll
            CEventDiPlogiSuccess
            CEventDiPlogiFail
-*/
/*CStateDoDiPlogi               31 */
extern void CActionDoDiPlogi( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t *hpRoot= thread->hpRoot;
    CThread_t  * pCThread = CThread_ptr( hpRoot);
    DevThread_t * pDevThread = (DevThread_t *)(&(pCThread->DirDevThread));

    SFThread_t  * pSFThread = pCThread->SFThread_Request.SFThread;
    pSFThread->parent.Device= pDevThread;

    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p Before %s - State = %d",
                    "CActionDoDiPlogi",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);


    fiSetEventRecordNull(eventRecord);

    pDevThread->Plogi_Reason_Code = PLOGI_REASON_DIR_LOGIN;
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPlogi);

    if(CFuncInterruptPoll( hpRoot,&pCThread->Fabric_pollingCount ))
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Dir Plogi Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0);

        fiSetEventRecord(eventRecord,thread,CEventDiPlogiFail);
    }
    else
    {
        if( pSFThread->thread_hdr.currentState == SFStatePlogiAccept)
        {
          fiSetEventRecord(eventRecord,thread,CEventDiPlogiSuccess);
        }
        else
        {
          fiSetEventRecord(eventRecord,thread,CEventDiPlogiFail);
        }

    }
    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After  %s - State = %d SFThread %p SFState %d",
                    "CActionDoDiPlogi",(char *)agNULL,
                    thread->hpRoot,pSFThread,
                    (os_bit32)thread->currentState,
                    (os_bit32)pSFThread->thread_hdr.currentState,
                    0,0,0,0,0,0);


}

/*+
  Function: CActionDiPlogiSuccess
   Purpose: Sets event record to CEventAllocRFT_IDThread
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CEventAllocRFT_IDThread
-*/
/* CStateDiPlogiSuccess         32 */
extern void CActionDiPlogiSuccess( fi_thread__t *thread,eventRecord_t *eventRecord )
{

#ifdef Do_Not_USE_Flogi_SFThread
    SFThreadFree(thread->hpRoot, & pCThread->SFThread_Request );
    pCThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;
#endif/* Do_Not_USE_Flogi_SFThread */
    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After In %s - State = %d",
                    "CActionDiPlogiSuccess",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);


    fiSetEventRecord(eventRecord, thread, CEventAllocRFT_IDThread);

}

/*+
  Function: CActionAllocGID_FTThread
   Purpose: Sets event record to CEventDoGID_FT
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CEventDoGID_FT
-*/
/* CStateAllocGID_FTThread      33 */
extern void CActionAllocGID_FTThread( fi_thread__t *thread,eventRecord_t *eventRecord )
{
#ifdef Do_Not_USE_Flogi_SFThread
    agRoot_t *hpRoot= thread->hpRoot;

    CThread_t  * pCThread = CThread_ptr( hpRoot);
    SFThread_t  * pSFThread = pCThread->SFThread_Request.SFThread;

    if(pSFThread != (SFThread_t *) agNULL)
    {
        if( pCThread->SFThread_Request.State == SFThread_Request_Granted)
        {
            fiLogDebugString(thread->hpRoot,
                CStateLogConsoleERROR,
                "pCThread %p Freeing SFThread in %s ",
                "CActionAllocGID_FTThread",(char *)agNULL,
                pCThread,(void *)agNULL,
                0,0,0,0,0,0,0,0);

            SFThreadFree( hpRoot, &pCThread->SFThread_Request );
            pCThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;
        }
    }

    pCThread->SFThread_Request.eventRecord_to_send.event = CEventDoGID_FT;
    pCThread->SFThread_Request.eventRecord_to_send.thread = thread;


    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After In %s - State = %d",
                    "CActionAllocGID_FTThread",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
    CFuncDisable_Interrupts(thread->hpRoot,ChipIOUp_INTEN_MASK);
    SFThreadAlloc( hpRoot,&pCThread->SFThread_Request );

#endif/* Do_Not_USE_Flogi_SFThread */
    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After In %s - State = %d",
                    "CActionAllocGID_FTThread",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);
    fiSetEventRecord(eventRecord, thread,CEventDoGID_FT );

}

/*+
  Function: CActionDoGID_FT
   Purpose: Does GID_FT
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            fiSendEvent
            CFuncInterruptPoll
            CEventGID_FTFail
            CEventGID_FTSuccess
-*/
/*CStateDoGID_FT               34 */
extern void CActionDoGID_FT( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t *hpRoot= thread->hpRoot;
    CThread_t  * pCThread = CThread_ptr( hpRoot);

    SFThread_t  * pSFThread = pCThread->SFThread_Request.SFThread;

#ifdef Do_Not_USE_Flogi_SFThread
    pSFThread->parent.Device= (DevThread_t *)agNULL;
#endif/* Do_Not_USE_Flogi_SFThread */

    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p Before %s - State = %d",
                    "CActionDoGID_FT",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);


    fiSetEventRecordNull(eventRecord);

    fiSendEvent(&pSFThread->thread_hdr,SFEventDoGID_FT);
    if(CFuncInterruptPoll( hpRoot,&pCThread->Fabric_pollingCount ))
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "GID_FT Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X ",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    0,0,0,0,0);

        fiSetEventRecord(eventRecord,thread,CEventGID_FTFail);
    }
    else
    {
        if( pSFThread->thread_hdr.currentState == SFStateGID_FTAccept)
        {
          fiSetEventRecord(eventRecord,thread,CEventGID_FTSuccess);
        }
        else
        {
          fiSetEventRecord(eventRecord,thread,CEventGID_FTFail);
        }

    }
    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After  %s - State = %d SFThread %p SFState %d",
                    "CActionDoGID_FT",(char *)agNULL,
                    thread->hpRoot,pSFThread,
                    (os_bit32)thread->currentState,
                    (os_bit32)pSFThread->thread_hdr.currentState,
                    0,0,0,0,0,0);


}

/*+
  Function: CActionGID_FTSuccess
   Purpose: Sets eventRecord to CEventAllocSCRThread
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CEventAllocSCRThread
-*/
/* CStateGID_FTSuccess          35  */
extern void CActionGID_FTSuccess( fi_thread__t *thread,eventRecord_t *eventRecord )
{
#ifdef Do_Not_USE_Flogi_SFThread
    CThread_t  * pCThread = CThread_ptr(thread->hpRoot);
    SFThreadFree(thread->hpRoot, & pCThread->SFThread_Request );
    pCThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;
#endif/* Do_Not_USE_Flogi_SFThread */
    CFuncYellowLed(thread->hpRoot, agFALSE);
    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After In %s - State = %d",
                    "CActionGID_FTSuccess",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    CThread_ptr(thread->hpRoot)->DeviceDiscoveryMethod = DDiscoveryQueriedNameService;

    fiSetEventRecord(eventRecord, thread, CEventAllocSCRThread);
}

/*+
  Function: CActionAllocSCRThread
   Purpose: Sets eventRecord to CEventDoSCR
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CEventDoSCR
-*/
/* CStateAllocSCRThread      38 */
extern void CActionAllocSCRThread( fi_thread__t *thread,eventRecord_t *eventRecord )
{
#ifdef Do_Not_USE_Flogi_SFThread
/*
    agRoot_t *hpRoot= thread->hpRoot;

    CThread_t  * pCThread = CThread_ptr( hpRoot);
    SFThread_t  * pSFThread = pCThread->SFThread_Request.SFThread;

    if(pSFThread != (SFThread_t *) agNULL)
    {
        if( pCThread->SFThread_Request.State == SFThread_Request_Granted)
        {
            fiLogDebugString(thread->hpRoot,
                CStateLogConsoleERROR,
                "pCThread %p Freeing SFThread in %s ",
                "CActionAllocSCRThread",(char *)agNULL,
                pCThread,(void *)agNULL,
                0,0,0,0,0,0,0,0);

            SFThreadFree( hpRoot, &pCThread->SFThread_Request );
            pCThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;
        }
    }

    pCThread->SFThread_Request.eventRecord_to_send.event = CEventDoSCR;
    pCThread->SFThread_Request.eventRecord_to_send.thread = thread;

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After In %s - State = %d",
                    "CActionAllocSCRThread",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
    CFuncDisable_Interrupts(thread->hpRoot,ChipIOUp_INTEN_MASK);

    SFThreadAlloc( hpRoot,&pCThread->SFThread_Request );
*/
#endif/* Do_Not_USE_Flogi_SFThread */
    CFuncYellowLed(thread->hpRoot, agFALSE);
    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After In %s - State = %d",
                    "CActionAllocSCRThread",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord, thread, CEventDoSCR);


}

/*+
  Function: CActionDoSCR
   Purpose: Does SCR
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            SFEventDoSCR
            CFuncInterruptPoll
            CEventSCRFail
            CEventSCRSuccess            
-*/
/*CStateDoSCR               39 */
extern void CActionDoSCR( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t *hpRoot= thread->hpRoot;
    CThread_t  * pCThread = CThread_ptr( hpRoot);


    SFThread_t  * pSFThread = pCThread->SFThread_Request.SFThread;
    pSFThread->parent.Device= (DevThread_t *)agNULL;

    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p Before %s - State = %d",
                    "CActionDoSCR",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);


    fiSetEventRecordNull(eventRecord);

    fiSendEvent(&pSFThread->thread_hdr,SFEventDoSCR);
    if(CFuncInterruptPoll( hpRoot,&pCThread->Fabric_pollingCount ))
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "SCR Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X ",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    0,0,0,0,0);

        fiSetEventRecord(eventRecord,thread,CEventSCRFail);
    }
    else
    {
        if( pSFThread->thread_hdr.currentState == SFStateSCRAccept)
        {
          fiSetEventRecord(eventRecord,thread,CEventSCRSuccess);
        }
        else
        {
          fiSetEventRecord(eventRecord,thread,CEventSCRFail);
        }

    }
    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After  %s - State = %d SFThread %p SFState %d",
                    "CActionDoSCR",(char *)agNULL,
                    thread->hpRoot,pSFThread,
                    (os_bit32)thread->currentState,
                    (os_bit32)pSFThread->thread_hdr.currentState,
                    0,0,0,0,0,0);


}

/*+
  Function: CActionSCRSuccess
   Purpose: Does ADISC for all SCSI targets
            frees devthread for initiators
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            DevEventAllocAdisc
            CFuncInterruptPoll
            CEventSameALPA
-*/
/* CStateSCRSuccess          40  */
extern void CActionSCRSuccess( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    CThread_t     * pCThread  = CThread_ptr(thread->hpRoot);
    agRoot_t      * hpRoot    = thread->hpRoot;
    DevThread_t   * pDevThread;
    fiList_t      * pDevList;

    CFuncYellowLed(thread->hpRoot, agFALSE);

    pCThread->DirectoryServicesStarted = agFALSE;
#ifdef Do_Not_USE_Flogi_SFThread
    SFThreadFree(thread->hpRoot, & pCThread->SFThread_Request );
    pCThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;
#endif/* Do_Not_USE_Flogi_SFThread */

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After In %s - State = %d",
                    "CActionSCRSuccess",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    while(fiListNotEmpty(&pCThread->Prev_Active_DevLink ))
    {
        fiListDequeueFromHead(&pDevList,
                                  &pCThread->Prev_Active_DevLink );
        pDevThread = hpObjectBase(DevThread_t,
                                  DevLink,pDevList );

        if( pDevThread->DevInfo.DeviceType & agDevSCSITarget )
        {
            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "%s %s %x",
                        "CActionSCRSuccess","Prev_Active_DevLink",
                        (void *)agNULL,(void *)agNULL,
                        fiNumElementsOnList(&pCThread->Prev_Active_DevLink),
                        0,0,0,0,0,0,0);

            fiSendEvent(&pDevThread->thread_hdr,DevEventAllocAdisc);
        }
        else
        {/*+ Check This DRL  -*/
            if(CFuncQuietShowWhereDevThreadsAre( hpRoot))
            {
                fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "%s AA CCnt %x",
                            "CActionSCRSuccess",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCThread->CDBpollingCount,
                            0,0,0,0,0,0,0);
            
            }
            /*+ Check This DRL  -*/
            CFuncCompleteActiveCDBThreadsOnDevice(pDevThread ,osIODevReset,  CDBEventIODeviceReset );

            DevThreadFree( hpRoot, pDevThread );

            if(CFuncQuietShowWhereDevThreadsAre( hpRoot))
            {
                fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "%s BB CCnt %x",
                            "CActionSCRSuccess",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCThread->CDBpollingCount,
                            0,0,0,0,0,0,0);
            
            }
        }

    }

    if(CFuncInterruptPoll( hpRoot,&pCThread->ADISC_pollingCount ))
    {
        fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "SCR ADISC  Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                0,0,0,0);
    }

    if(CFuncShowWhereDevThreadsAre( hpRoot)) CFuncWhatStateAreDevThreads( hpRoot );

    pCThread->DeviceDiscoveryMethod = DDiscoveryQueriedNameService;

    fiSetEventRecord(eventRecord, thread, CEventSameALPA);
}


/*+
  Function: CActionRSCNErrorBackIOs
   Purpose: Sets timer to get directory server information
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncShowActiveCDBThreads
            fiTimerStart
-*/
/* CStateRSCNErrorBackIOs              41 */
extern void CActionRSCNErrorBackIOs( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t      * hpRoot             = thread->hpRoot;
    CThread_t     * pCThread           = CThread_ptr(hpRoot);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p In %s - State = %d",
                    "CActionRSCNErrorBackIOs",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiLogString(hpRoot,
                    "In %s Active IO %x",
                    "CActionRSCNErrorBackIOs",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
    				CFuncShowActiveCDBThreads( hpRoot, ShowActive),
                    0,0,0,0,0,0,0);

    pCThread->InterruptsDelayed = agFALSE;
    CFuncInteruptDelay(hpRoot, agFALSE);

    faSingleThreadedLeave( hpRoot , CStateRSCNErrorBackIOs);

    osFCLayerAsyncEvent( hpRoot, osFCLinkDown );

    faSingleThreadedEnter( hpRoot , CStateRSCNErrorBackIOs);

    if(pCThread->CDBpollingCount)
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "%s Ccnt Non Zero Ccnt %x",
                    "CActionRSCNErrorBackIOs",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->CDBpollingCount,
                    0,0,0,0,0,0,0);
    }


    CFuncShowActiveCDBThreads( hpRoot,ShowERQ);

    fiListEnqueueListAtTail(&pCThread->Active_DevLink,&pCThread->Prev_Active_DevLink);
    pCThread->RSCNreceived = agTRUE;

    if(! fiListElementOnList( (fiList_t *)(&(pCThread->Timer_Request)),
                                   &(pCThread->TimerQ)))
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "%s Setting Timer",
                    "CActionRSCNErrorBackIOs",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
        fiTimerSetDeadlineFromNow(thread->hpRoot, &pCThread->Timer_Request, pCThread->Calculation.Parameters.R_A_TOV);

        pCThread->Timer_Request.eventRecord_to_send.thread= thread;
        pCThread->Timer_Request.eventRecord_to_send.event = CEventAllocDiPlogiThread;

        fiTimerStart(thread->hpRoot,&pCThread->Timer_Request);

    }
    else
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "%s Timer not SET ",
                    "CActionRSCNErrorBackIOs",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    }
    fiSetEventRecordNull(eventRecord);

}

/*+
  Function: CActionFlipNPortState
   Purpose: Flips channel between NPORT and LOOP
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CEventDoInitalize

-*/
/* CStateFlipNPortState          43 */
extern void CActionFlipNPortState( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    agRoot_t   *    hpRoot          = thread->hpRoot;
    CThread_t  * pCThread           = CThread_ptr(hpRoot);

    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogString(hpRoot,
                    "%s",
                    "CActionFlipNPortState",(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p)In %s - State = %d",
                    "CActionFlipNPortState",(char *)agNULL,
                    hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration,
            (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ) | 
                                     ChipIOUp_Frame_Manager_Configuration_ELB     ));

    if(pCThread->Calculation.Parameters.InitAsNport)
    {
        pCThread->Calculation.Parameters.InitAsNport = 0;
    }
    else
    {
        pCThread->Calculation.Parameters.InitAsNport = 1;
    }
    fiSetEventRecord(eventRecord, thread, CEventDoInitalize);

}

#endif   /* NAME_SERVICES */

#endif /* NOT DEF USESTATEMACROS */

/* void cstate_c(void){} */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\cstring.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Module Name:

   string.h

Abstract:

   This is the reset bus enty point for the Agilent
   PCI to Fibre Channel Host Bus Adapter (HBA).

Authors:

   Leopold Purwadihardja

Environment:

   kernel mode only

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/H/cstring.h $

Revision History:

   $Revision: 1 $
   $Date: 10/23/00 6:26p $
   $Modtime:: 10/19/00 3:26p        $

Notes:


--*/


#ifndef __SSTRING_H_inc__
#define __SSTRING_H_inc__

extern int C_isspace(char a);
extern int C_isdigit(char a);
extern int C_isxdigit(char a);
extern int C_islower(char a);
extern char C_toupper(char a);
extern char *C_stristr(const char *String, const char *Pattern);
extern char *C_strncpy (char *destStr,char *sourceStr,int   count);
extern char *C_strcpy (char *destStr, char *sourceStr);
extern int C_sprintf(char *buffer, const char *format, ...);
extern int C_vsprintf(char *buffer, const char *format, void *va_list);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\cstate.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/CSTATE.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 7/24/00 1:47p   $

Purpose:

  This file defines the macros, types, and data structures
  used by ../C/CState.C

--*/

#ifndef __CState_H__
#define __CState_H__

#define CSTATE_NOISE( hpRoot, State ) (CThread_ptr(hpRoot)->thread_hdr.currentState == State ?  CStateLogConsoleLevel : CStateLogConsoleERROR)




#define CStateConfused              0
#define CStateShutdown              1
#define CStateInitialize            2
#define CStateInitFM                3
#define CStateInitDataStructs       4
#define CStateVerify_AL_PA          5
#define CStateAllocFlogiThread      6
#define CStateDoFlogi               7
#define CStateFlogiSuccess          8
#define CStateALPADifferent         9
#define CStateFreeSFthread          10
#define CStateSuccess               11
#define CStateNormal                12
#define CStateResetNeeded           13
#define CStateLoopFail              14
#define CStateReInitFM              15
#define CStateInitializeFailed      16
#define CStateLoopFailedReInit      17
#define CStateFindDevice            18 /**/

#define CStateElasticStoreEventStorm 19
#define CStateLIPEventStorm          20

#define CStateExternalDeviceReset     21

#define CStateExternalLogout          22
#define CStateExternalLogoutRecovery  23

#define CStateDoExternalDeviceReset   24
#define CStateSendPrimitive           25

#define CStateInitFM_DelayDone        26

#define CStateAllocRFT_IDThread       27
#define CStateDoRFT_ID                28
#define CStateRFT_IDSuccess           29
#define CStateAllocDiPlogiThread      30
#define CStateDoDiPlogi               31
#define CStateDiPlogiSuccess          32
#define CStateAllocGID_FTThread       33
#define CStateDoGID_FT                34
#define CStateGID_FTSuccess           35

#define CStateFindDeviceUseNameServer 36
#define CStateFindDeviceUseLoopMap    37

#define CStateAllocSCRThread          38
#define CStateDoSCR                   39
#define CStateSCRSuccess              40

#define CStateRSCNErrorBackIOs        41
#define CStateFindPtToPtDevice        42

#define CStateFlipNPortState          43

#define CStateMAXState  CStateFlipNPortState



#define CEventShutdown                  0
#define CEventDoInitalize               1
#define CEventInitChipSuccess           2
#define CEventInitalizeFailure          3
#define CEventInitFMSuccess             4
#define CEventInitFMFailure             5
#define CEventDataInitalizeSuccess      6
#define CEventAllocFlogiThread          7
#define CEventGotFlogiThread            8
#define CEventFlogiSuccess              9
#define CEventFlogiFail                 10
#define CEventSameALPA                  11
#define CEventChangedALPA               12
#define CEventInitalizeSuccess          13
#define CEventAsyncLoopEventDetected    14
#define CEventResetDetected             15
#define CEventResetNotNeeded            16   /* 10 */
#define CEventResetIfNeeded             17   /* 11 */

#define CEventLoopEventDetected         18   /* 12 */

#define CEventLoopConditionCleared      19   /* 13 */
#define CEventLoopNeedsReinit           20   /* 14 */
#define CEventReInitFMSuccess           21   /* 15 */
#define CEventReInitFMFailure           22   /* 16 */

#define CEventNextDevice                23   /* 17 */
#define CEventDeviceListEmpty           24   /* 18 */
#define CEventElasticStoreEventStorm    25   /* 19 */
#define CEventLIPEventStorm             26   /* 1A */

#define CEvent_AL_PA_BAD                27

#define CEventExternalDeviceReset       28

#define CEventExternalLogout            29

#define CEventDoExternalDeviceReset     30

#define CEventSendPrimitive             31

#define CEventDelay_for_FM_init         32

#define CEventAllocRFT_IDThread         33
#define CEventDoRFT_ID                  34
#define CEventRFT_IDSuccess             35
#define CEventRFT_IDFail                36



#define CEventAllocDiPlogiThread        37
#define CEventDoDiPlogi                 38
#define CEventDiPlogiSuccess            39
#define CEventDiPlogiFail               40

#define CEventAllocGID_FTThread         41
#define CEventDoGID_FT                  42
#define CEventGID_FTSuccess             43
#define CEventGID_FTFail                44


#define CEventFindDeviceUseNameServer   45
#define CEventFindDeviceUseLoopMap      46

#define CEventAllocSCRThread            47
#define CEventDoSCR                     48
#define CEventSCRSuccess                49
#define CEventSCRFail                   50
#define CEventRSCNErrorBackIOs          51
#define CEventFindPtToPtDevice          52
#define CEventClearHardwareFoulup       53

#define CEventFlipNPortState            54

#define CEventGoToInitializeFailed      55 

#define CEventMAXEvent  CEventGoToInitializeFailed

STATE_PROTO(CActionConfused          );
STATE_PROTO(CActionShutdown          );
STATE_PROTO(CActionInitialize        );
STATE_PROTO(CActionInitFM            );
STATE_PROTO(CActionInitDataStructs   );
STATE_PROTO(CActionVerify_AL_PA      );
STATE_PROTO(CActionAllocFlogiThread  );
STATE_PROTO(CActionDoFlogi           );
STATE_PROTO(CActionFlogiSuccess      );
STATE_PROTO(CActionALPADifferent     );
STATE_PROTO(CActionFreeSFthread      );
STATE_PROTO(CActionSuccess           );
STATE_PROTO(CActionNormal            );
STATE_PROTO(CActionResetNeeded       );
STATE_PROTO(CActionLoopFail          );
STATE_PROTO(CActionReInitFM          );
STATE_PROTO(CActionInitializeFailed  );
STATE_PROTO(CActionLoopFailedReInit  );
STATE_PROTO(CActionFindDevice        );
STATE_PROTO(CActionFindDeviceUseAllALPAs  );
STATE_PROTO(CActionFindDeviceUseLoopMap   );
STATE_PROTO(CActionFindDeviceUseNameServer);
STATE_PROTO(CActionFindPtToPtDevice);


STATE_PROTO(CActionElasticStoreEventStorm);
STATE_PROTO(CActionLIPEventStorm         );
STATE_PROTO(CActionExternalDeviceReset   );

STATE_PROTO(CActionExternalLogout        );
STATE_PROTO(CActionExternalLogoutRecovery);

STATE_PROTO(CActionDoExternalDeviceReset);

STATE_PROTO(CActionSendPrimitive);
STATE_PROTO(CActionInitFM_DelayDone);
STATE_PROTO(CActionFlipNPortState);

/* Begin: Big_Endian_Code */
#ifdef hpMustSwapDmaMem
#define SENDIO(hpRoot,CThread,Thread,Func) CFuncSwapDmaMemBeforeIoSent(Thread,Func)
#define AFTERIO(hpRoot) CFuncSwapDmaMemAfterIoDone(hpRoot)
#else /* hpMustSwapDmaMem */
#define SENDIO(hpRoot,CThread,Thread,Func) osChipIOLoWriteBit32(hpRoot,ChipIOLo_ERQ_Producer_Index,(os_bit32)CThread->HostCopy_ERQProdIndex)
#define AFTERIO(hpRoot); 
#endif /* hpMustSwapDmaMem */

#define DoFuncCdbCmnd  0
#define DoFuncSfCmnd   1
/* End: Big_Endian_Code */


STATE_PROTO(CActionAllocRFT_IDThread);
STATE_PROTO(CActionDoRFT_ID);
STATE_PROTO(CActionRFT_IDSuccess);
STATE_PROTO(CActionAllocDiPlogiThread);
STATE_PROTO(CActionDoDiPlogi);
STATE_PROTO(CActionDiPlogiSuccess);
STATE_PROTO(CActionAllocGID_FTThread);
STATE_PROTO(CActionDoGID_FT);
STATE_PROTO(CActionGID_FTSuccess);
STATE_PROTO(CActionAllocSCRThread);
STATE_PROTO(CActionDoSCR);
STATE_PROTO(CActionSCRSuccess);

STATE_PROTO(CActionRSCNErrorBackIOs);
STATE_PROTO(CActionRSCNErrorBackIOsOther);

#define CSubStateInitialized            0
#define CSubStateNormal                 1
#define CSubStateResettingDevices       2

/*
#define ROLL(index, end)    index=((index+1) & (end-1))
*/
#define ROLL(index, end)   (index++ < (end-1) ?  index : (index = 0))


#define FULL(index,end) (index == end ? agTRUE : agFALSE)
#define NEXT_INDEX(index, end)    ((index+1) & (end-1))

#define CLipStormQueisingTOV        (5 * 1000000)  /* 5 Seconds*/
#define CResetChipDelay             (4 * 100000 )  /* 400 MilliSeconds*/
#define CInitFM_Delay               (1 * 100000 )  /* 100 MilliSeconds*/
#define CReinitNportAfterFailureDetectionTOV (50 * 1000000) /* 50 seconds */
#define CFlipNportTOV             (150 * 1000000) /* 150 seconds */
#define CWaitAfterRATOV            (10 * 1000000) /* 10 Seconds */
#define CWaitAfterFlogi             (2 * 1000000) /* 2 Seconds */

extern stateTransitionMatrix_t CStateTransitionMatrix;
extern stateActionScalar_t     CStateActionScalar;


#ifdef USESTATEMACROS

void testCthread( agRoot_t *hpRoot  );

#define CSTATE_FUNCTION_ACTION( x , Action) extern void x( fi_thread__t * thread, \
                 eventRecord_t * eventRecord ){         \
    agRoot_t * hpRoot=thread->hpRoot;                   \
    osLogDebugString(hpRoot,                            \
                      StateLogConsoleLevel,             \
                      "In %s - State = %d",             \
                      #x,(char *)agNULL,                  \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)thread->currentState,      \
                      0,0,0,0,0,0,0);                   \
    osLogDebugString(thread->hpRoot,                    \
                      StateLogConsoleLevel,             \
                      "Sends event...%s %d",          \
                      #Action,(char *)agNULL,             \
                      (void * )agNULL,(void * )agNULL,  \
                      Action,0,0,0,0,0,0,0);            \
    fiSetEventRecord(eventRecord, thread, Action);   }  \

#define CSTATE_FUNCTION_TERMINATE(x) extern void x(fi_thread__t *thread,\
                                      eventRecord_t *eventRecord ){\
    agRoot_t * hpRoot=thread->hpRoot;                            \
    CThread_t  * pCThread=CThread_ptr(hpRoot);                   \
    CDBThread_t * pCDBThread=(CDBThread_t * )thread;             \
    DevThread_t * pDevThread=pCDBThread->Device;                 \
    osLogDebugString(hpRoot,                            \
                      StateLogConsoleLevel,             \
                      "In %s - State = %d",     \
                      #x,(char *)agNULL,                  \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)thread->currentState,      \
                      0,0,0,0,0,0,0);                   \
    osLogDebugString(thread->hpRoot,                    \
                      StateLogConsoleLevel,             \
                      "...simply returns",            \
                      (char *)agNULL,(char *)agNULL,        \
                      (void * )agNULL,(void * )agNULL,  \
                      0,0,0,0,0,0,0,0);                 \
    eventRecord->thread = agNULL;                         \
    }\


#define CSTATE_FUNCTION_MULTI_ACTION(x,Action0,Action1,Action2,Action3) extern void x( fi_thread__t *thread,\
                                      eventRecord_t *eventRecord ){ \
    agRoot_t * hpRoot = thread->hpRoot;                            \
    CThread_t  * pCThread = CThread_ptr(hpRoot);                   \
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;             \
    DevThread_t * pDevThread = pCDBThread->Device;                 \
    os_bit8 WhichAction[4];                                            \
    static  os_bit32 ActionCount=0;                                    \
    WhichAction[0] = Action0;                                       \
    WhichAction[1] = Action1;                                       \
    WhichAction[2] = Action2;                                       \
    WhichAction[3] = Action3;                                       \
    osLogDebugString(hpRoot,                            \
                      StateLogConsoleLevel,             \
                      "In %s - State = %d ALPA %X",     \
                      #x,(char *)agNULL,                  \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)thread->currentState,      \
                      0,0,0,0,0,0,0);                    \
    osLogDebugString(thread->hpRoot,                    \
                      StateLogConsoleLevel,             \
                      "...returns event %s %d",       \
                      #Action0,#Action1,                \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)WhichAction[ActionCount],  \
                      0,0,0,0,0,0,0);                   \
    osLogDebugString(thread->hpRoot,                    \
                      StateLogConsoleLevel,             \
                      "or %s  or %s",                  \
                      (void * )agNULL,(void * )agNULL,  \
                      #Action2,#Action3,                \
                      0,0,0,0,0,0,0,0);                 \
    fiSetEventRecord(eventRecord,thread,WhichAction[ActionCount]);  \
    if(ActionCount<3)ActionCount++;                              \
    else ActionCount =0;                                            \
    }                                                               \

#ifdef TestCStateMachine

char * CStateString[]=
{
    "CStateConfused                ",
    "CStateShutdown                ",
    "CStateInitialize              ",
    "CStateInitFM                  ",
    "CStateInitDataStructs         ",
    "CStateVerify_AL_PA            ",
    "CStateAllocFlogiThread        ",
    "CStateDoFlogi                 ",
    "CStateFlogiSuccess            ",
    "CStateALPADifferent           ",
    "CStateFreeSFthread            ",
    "CStateSuccess                 ",
    "CStateNormal                  ",
    "CStateResetNeeded             ",
    "CStateLoopFail                ",
    "CStateReInitFM                ",
    "CStateInitializeFailed        ",
    "CStateLoopFailedReInit        ",
    "CStateFindDevice              ",
    "CStateElasticStoreEventStorm  ",
    "CStateLIPEventStorm           ",
    "CStateExternalDeviceReset     ",
    "CStateExternalLogout          ",
    "CStateExternalLogoutRecovery  ",
    "CStateDoExternalDeviceReset   ",
    "CStateSendPrimitive           ",
    "CStateInitFM_DelayDone        ",
    "CStateAllocRFT_IDThread       ",
    "CStateDoRFT_ID                ",
    "CStateRFT_IDSuccess           ",
    "CStateAllocDiPlogiThread      ",
    "CStateDoDiPlogi               ",
    "CStateDiPlogiSuccess          ",
    "CStateAllocGID_FTThread       ",
    "CStateDoGID_FT                ",
    "CStateGID_FTSuccess           ",
    "CStateFindDeviceUseNameServer ",
    "CStateFindDeviceUseLoopMap    ",
    "CStateAllocSCRThread          ",
    "CStateDoSCR                   ",
    "CStateSCRSuccess              ",
    "CStateRSCNErrorBackIOs        ",
    "CStateFindPtToPtDevice        ",
    "CStateFlipNPortState          ",
    agNULL
};

char * CEventString[]=
{
    "CEventShutdown                  ",
    "CEventInitalize                 ",
    "CEventInitChipSuccess           ",
    "CEventInitalizeFailure          ",
    "CEventInitFMSuccess             ",
    "CEventInitFMFailure             ",
    "CEventDataInitalizeSuccess      ",
    "CEventAllocFlogiThread          ",
    "CEventGotFlogiThread            ",
    "CEventFlogiSuccess              ",
    "CEventFlogiFail                 ",
    "CEventSameALPA                  ",
    "CEventChangedALPA               ",
    "CEventInitalizeSuccess          ",
    "CEventAsyncLoopEventDetected    ",
    "CEventResetDetected             ",
    "CEventResetNotNeeded            ",
    "CEventResetIfNeeded             ",
    "CEventLoopEventDetected         ",
    "CEventLoopConditionCleared      ",
    "CEventLoopNeedsReinit           ",
    "CEventReInitFMSuccess           ",
    "CEventReInitFMFailure           ",
    "CEventNextDevice                ",
    "CEventDeviceListEmpty           ",
    "CEventElasticStoreEventStorm    ",
    "CEventLIPEventStorm             ",
    "CEvent_AL_PA_BAD                ",
    "CEventExternalDeviceReset       ",
    "CEventExternalLogout            ",
    "CEventDoExternalDeviceReset     ",
    "CEventSendPrimitive             ",
    "CEventDelay_for_FM_init         ",
    "CEventAllocRFT_IDThread         ",
    "CEventDoRFT_ID                  ",
    "CEventRFT_IDSuccess             ",
    "CEventRFT_IDFail                ",
    "CEventAllocDiPlogiThread        ",
    "CEventDoDiPlogi                 ",
    "CEventDiPlogiSuccess            ",
    "CEventDiPlogiFail               ",
    "CEventAllocGID_FTThread         ",
    "CEventDoGID_FT                  ",
    "CEventGID_FTSuccess             ",
    "CEventGID_FTFail                ",
    "CEventFindDeviceUseNameServer   ",
    "CEventFindDeviceUseLoopMap      ",
    "CEventAllocSCRThread            ",
    "CEventDoSCR                     ",
    "CEventSCRSuccess                ",
    "CEventSCRFail                   ",
    "CEventRSCNErrorBackIOs          ",
    "CEventFindPtToPtDevice          ",
    "CEventClearHardwareFoulup       ",
    "CEventFlipNPortState            ",
    agNULL
};


#endif /*  TestCStateMachine was defined */

#endif /* USESTATEMACROS was defined */

#endif /*  __CState_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\cstring.c ===
/*++

Copyright (c) 2000 Agilent Technologies

Module Name:

    csprintf.c

Abstract:

    This is source contains String utility functions

Authors:

    
Environment:

    kernel mode only

Notes:

Version Control Information:

    $Archive: /Drivers/Win2000/MSE/OSLayer/C/cstring.c $


Revision History:

    $Revision: 4 $
    $Date: 12/07/00 1:35p $
    $Modtime:: 12/07/00 1:35p           $

Notes:


--*/

#include <stdarg.h>

#ifndef NULL
#define NULL 0
#endif

/*++

Routine Description:

    Check for white spaces
   
Arguments:
    c           - character
    
Return Value:

    1 = white space
    0 = anythingelse

--*/
int C_isspace (char c) 
{
    return (c == '\t' || c == '\n' || c == ' ');
}

/*
 * Cstrlen
 */
int C_strlen(const char *str)
{
    int count;
    if( !str )
    {
        return 0;
    }
    for (count = 0; *str; str++,count++);

    return count;
}


int C_strnlen(const char *str, int maxLen)
{
    int count;
    if( !str )
    {
        return 0;
    }
    for (count = 0; *str && ((unsigned) count <= (unsigned)maxLen); str++,count++);

    return count;
}

int C_isxdigit(char a)
{
   return ( ((a >= 'a') && (a <= 'z')) ||
            ((a >= 'A') && (a <= 'Z')) ||
            ((a >= '0') && (a <= '9')) );
}

int C_isdigit(char a)
{
   return ( ((a >= '0') && (a <= '9')) );
}

int C_islower(char a)
{
   return ( ((a >= 'a') && (a <= 'z')) );
}

int C_isupper(char a)
{
   return ( ((a >= 'A') && (a <= 'Z')) );
}

char C_toupper(char a)
{
   if (C_islower (a) )
      return (a - 'a' + 'A' );
   else
      return a;
}

char *C_stristr(const char *String, const char *Pattern)
{
   char           *pptr, *sptr, *start;
   unsigned int   slen, plen;

   if(!String || !Pattern)
   {
        return(NULL);
   }
   for (start = (char *)String,
        pptr  = (char *)Pattern,
        slen  = C_strlen(String),
        plen  = C_strlen(Pattern);
        /* while string length not shorter than pattern length */
        slen >= plen;
        start++, slen--)
   {
      /* find start of pattern in string */
      while (C_toupper(*start) != C_toupper(*Pattern))
      {
         start++;
         slen--;

         /* if pattern longer than string */

         if (slen < plen)
            return(NULL);
      }

      sptr = start;
      pptr = (char *)Pattern;

      while (C_toupper(*sptr) == C_toupper(*pptr))
      {
         sptr++;
         pptr++;

         /* if end of pattern then pattern was found */

         if ('\0' == *pptr)
            return (start);
      }
   }
   return(NULL);
}


char *C_strncpy (
   char *destStr,
   char *sourceStr,
   int   count)
{
    if( !destStr || !sourceStr )
    {
        return NULL;
    }
   while (count--) 
   {
      *destStr = *sourceStr;
      if (*sourceStr == '\0')
         break;
      destStr++;
      sourceStr++;
   }
   return destStr;

}

char *C_strcpy (
   char *destStr,
   char *sourceStr)
{
   return C_strncpy (destStr,sourceStr,-1) ;
}



long C_strtoul(const char *cp,char **endp,unsigned int base)
{
    unsigned long result = 0,value;
    if (!base) 
    {
        base = 10;
        if (*cp == '0') 
        {
            base = 8;
            cp++;
            if ((*cp == 'x') && C_isxdigit(cp[1])) 
            {
                cp++;
                base = 16;
            }
        }
    }
    while (C_isxdigit(*cp) && (value = C_isdigit(*cp) ? *cp-'0' : (C_islower(*cp)
        ? C_toupper(*cp) : *cp)-'A'+10) < base) 
    {
        result = result*base + value;
        cp++;
    }
    if (endp)
        *endp = (char *)cp;
    return result;
}

long C_strtol(const char *cp,char **endp,unsigned int base)
{
    if(*cp=='-')
        return -C_strtoul(cp+1,endp,base);
    return C_strtoul(cp,endp,base);
}


static int skip_atoi(const char **s)
{
    int i=0;

    while (C_isdigit(**s))
        i = i*10 + *((*s)++) - '0';
    return i;
}

#define ZEROPAD 1       /* pad with zero */
#define SIGN    2       /* unsigned/signed long */
#define PLUS    4       /* show plus */
#define SPACE   8       /* space if plus */
#define LEFT    16      /* left justified */
#define SPECIAL 32      /* 0x */
#define LARGE   64      /* use 'ABCDEF' instead of 'abcdef' */

long do_div(long *n,int base) 
{ 
    long __res; 

    __res = ((unsigned long) *n) % (unsigned) base; 
    *n = ((unsigned long) *n) / (unsigned) base; 

    return __res; 
}

static char * number(char * str,
                     long num, 
                     int base, 
                     int size, 
                     int precision,
                     int type)
{
    char c,sign,tmp[66];
    const char *digits="0123456789abcdefghijklmnopqrstuvwxyz";
    int i;

    if (type & LARGE)
        digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";

    if (type & LEFT)
        type &= ~ZEROPAD;

    if (base < 2 || base > 36)
        return 0;

    c = (type & ZEROPAD) ? '0' : ' ';
    sign = 0;

    if (type & SIGN) 
    {
        if (num < 0) 
        {
            sign = '-';
            num = -num;
            size--;
        } 
        else 
        {   
            if (type & PLUS) 
            {
            sign = '+';
            size--;
            } 
            else 
            {   
                if (type & SPACE) 
                {
                sign = ' ';
                size--;
                }
            }
        }
    }

    if (type & SPECIAL) 
    {
        if (base == 16)
            size -= 2;
        else 
            if (base == 8)
            size--;
    }

    i = 0;
    if (num == 0)
        tmp[i++]='0';
    else 
    {   
        while (num != 0)
            tmp[i++] = digits[do_div(&num,base)];
    }

    if (i > precision)
        precision = i;

    size -= precision;
    if (!(type&(ZEROPAD+LEFT)))
    {
        while(size-->0)
            *str++ = ' ';
    }

    if (sign)
        *str++ = sign;
    if (type & SPECIAL) 
    {
        if (base==8)
            *str++ = '0';
        else 
        {
            if (base==16) 
            {
                *str++ = '0';
                *str++ = digits[33];
            }
        }
    }

    if (!(type & LEFT))
        while (size-- > 0)
            *str++ = c;
    while (i < precision--)
        *str++ = '0';
    while (i-- > 0)
        *str++ = tmp[i];
    while (size-- > 0)
        *str++ = ' ';
    return str;
}

/* 
 * Limited functionality vsprintf
 */
int C_vsprintf(char *buf, const char *fmt, va_list args)
{
    long len;
    unsigned long num;
    int i;
    int base;
    char * str;
    const char *s;

    int flags;      /* flags to number() */

    int field_width;    /* width of output field */
    int precision;      /* min. # of digits for integers; max
                   number of chars for from string */
    int qualifier;      /* 'h', 'l', or 'L' for integer fields */
    if( !buf || !fmt )
    {
        return 0;
    }
    for (str=buf ; *fmt ; ++fmt) 
    {
        if (*fmt != '%') 
        {
            *str++ = *fmt;
            continue;
        }
            
        /* process flags */
        flags = 0;
        
repeat:
        ++fmt;      /* this also skips first '%' */
        switch (*fmt) 
        {
            case '-': flags |= LEFT; goto repeat;
            case '+': flags |= PLUS; goto repeat;
            case ' ': flags |= SPACE; goto repeat;
            case '#': flags |= SPECIAL; goto repeat;
            case '0': flags |= ZEROPAD; goto repeat;
        }
        
        /* get field width */
        field_width = -1;
        if (C_isdigit(*fmt))
            field_width = skip_atoi(&fmt);
        else 
        {
            if (*fmt == '*') 
            {
                ++fmt;
                /* it's the next argument */
                field_width = va_arg(args, int);
                if (field_width < 0) 
                {
                    field_width = -field_width;
                    flags |= LEFT;
                }
            }
        }
        
        /* get the precision */
        precision = -1;
        if (*fmt == '.') 
        {
            ++fmt;  
            if (C_isdigit(*fmt))
                precision = skip_atoi(&fmt);
            else if (*fmt == '*') 
            {
                ++fmt;
                /* it's the next argument */
                precision = va_arg(args, int);
            }
            if (precision < 0)
                precision = 0;
        }

        /* get the conversion qualifier */
        qualifier = -1;
        if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L') 
        {
            qualifier = *fmt;
            ++fmt;
        }

        /* default base */
        base = 10;

        switch (*fmt) 
        {
            case 'c':
                if (!(flags & LEFT))
                    while (--field_width > 0)
                        *str++ = ' ';
                *str++ = (unsigned char) va_arg(args, int);
                while (--field_width > 0)
                    *str++ = ' ';
                continue;

            case 's':
                s = va_arg(args, char *);
                if (!s)
                    s = "<NULL>";

                len = C_strnlen(s, precision);

                if (!(flags & LEFT))
                    while (len < field_width--)
                        *str++ = ' ';
                for (i = 0; i < len; ++i)
                    *str++ = *s++;
                while (len < field_width--)
                    *str++ = ' ';
                continue;

            case '%':
                *str++ = '%';
                continue;

            /* integer number formats - set up the flags and "break" */
            case 'o':
                base = 8;
                break;

            case 'X':
                flags |= LARGE;
            case 'x':
                base = 16;
                break;

            case 'd':
            case 'i':
                flags |= SIGN;
            case 'u':
                break;

            default:
                *str++ = '%';
                if (*fmt)
                    *str++ = *fmt;
                else
                    --fmt;
                continue;
            }

        if (qualifier == 'l')
            num = va_arg(args, unsigned long);
        else 
            if (qualifier == 'h') 
            {
                num = (unsigned short) va_arg(args, int);
                if (flags & SIGN)
                    num = (short) num;
            } 
            else 
                if (flags & SIGN)
                    num = va_arg(args, int);
                else
                    num = va_arg(args, unsigned int);
            str = number(str, num, base, field_width, precision, flags);
    }

    *str = '\0';
    return ((int) (str-buf));
}

int C_sprintf(char * buf, const char *fmt, ...)
{
    va_list args;
    int i;

    va_start(args, fmt);
    i=C_vsprintf(buf,fmt,args);
    va_end(args);
    return i;
}

#ifdef TESTING_MODE
int main(int argc, char* argv[])
{

    char test[512];

    C_sprintf (test,"%s=%x\n", "hello mam", 12);

    C_sprintf (test,"%-10s said %s\n", "Mommie", "yes");
    
    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\cstest.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/CSTEST.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 7/20/00 2:33p   $

Purpose:

  This file Tests the FC Layer State Machine.

--*/

#include <stdio.h>
#include <stdlib.h>
#include "../h/globals.h"
#include "../h/fcstruct.h"
#include "../h/state.h"

#include "../h/tlstruct.h"
#include "../h/memmap.h"
#include "../h/fcmain.h"
#include "../h/linksvc.h"
#include "../h/flashsvc.h"
#include "../h/timersvc.h"

#include "../h/cstate.h"
#include "../h/cfunc.h"
#include "../h/devstate.h"
#include "../h/cdbstate.h"
#include "../h/sfstate.h"
#include "../h/tgtstate.h"

#include "../h/queue.h"
#include "../h/cdbsetup.h"

extern stateTransitionMatrix_t  DevStateTransitionMatrix;
extern stateActionScalar_t      DevStateActionScalar;
extern stateTransitionMatrix_t  SFstateTransitionMatrix;
extern stateActionScalar_t      SFstateActionScalar;

/*
extern actionUpdate_t CDBTestActionUpdate[];
extern actionUpdate_t DevTestActionUpdate[];
extern actionUpdate_t SFtestActionUpdate[];
*/
#ifdef USESTATEMACROS

CSTATE_FUNCTION_TERMINATE(CActionConfused );
CSTATE_FUNCTION_TERMINATE(CActionShutdown );

CSTATE_FUNCTION_TERMINATE(CActionInitializeFailed);
CSTATE_FUNCTION_TERMINATE(CActionALPADifferent   );

CSTATE_FUNCTION_MULTI_ACTION(CActionInitialize  ,CEventInitChipSuccess, CEventInitChipSuccess,CEventInitChipSuccess,CEventInitalizeFailure );
CSTATE_FUNCTION_MULTI_ACTION(CActionInitFM      ,CEventInitFMSuccess   ,CEventInitFMSuccess,   CEventInitFMSuccess  , CEventInitFMFailure  );
CSTATE_FUNCTION_ACTION(CActionInitDataStructs,CEventDataInitalizeSuccess );


CSTATE_FUNCTION_MULTI_ACTION(CActionDoFlogi     ,CEventFlogiFail ,CEventFlogiFail  ,CEventFlogiSuccess ,CEventFlogiSuccess   );
CSTATE_FUNCTION_MULTI_ACTION(CActionFlogiSuccess,CEventSameALPA        ,CEventChangedALPA  , CEventSameALPA     ,     CEventChangedALPA       );
CSTATE_FUNCTION_MULTI_ACTION(CActionLoopFail    ,CEventLoopConditionCleared,CEventLoopNeedsReinit,  CEventLoopConditionCleared,CEventLoopConditionCleared,  );
CSTATE_FUNCTION_MULTI_ACTION(CActionReInitFM    ,CEventReInitFMSuccess, CEventReInitFMSuccess, CEventReInitFMSuccess, CEventReInitFMFailure     );


CSTATE_FUNCTION_ACTION(CActionNonFaALPA        ,CEventAllocFlogiThread);
CSTATE_FUNCTION_ACTION(CActionAllocFlogiThread ,CEventGotFlogiThread  );
CSTATE_FUNCTION_ACTION(CActionFreeSFthread     ,CEventSameALPA  );
CSTATE_FUNCTION_ACTION(CActionSuccess  ,CEventInitalizeSuccess );

CSTATE_FUNCTION_TERMINATE(CActionNormal );
CSTATE_FUNCTION_TERMINATE(CActionResetNeeded );
CSTATE_FUNCTION_TERMINATE(CActionFindPtToPtDevice );
CSTATE_FUNCTION_TERMINATE(CActionRSCNErrorBackIOs );
CSTATE_FUNCTION_TERMINATE(CActionSCRSuccess );
CSTATE_FUNCTION_TERMINATE(CActionAllocSCRThread );
CSTATE_FUNCTION_TERMINATE(CActionFindDeviceUseLoopMap );
CSTATE_FUNCTION_TERMINATE(CActionFindDeviceUseNameServer );
CSTATE_FUNCTION_TERMINATE(CActionGID_FTSuccess );
CSTATE_FUNCTION_TERMINATE(CActionDoGID_FT );
CSTATE_FUNCTION_TERMINATE(CActionAllocGID_FTThread );
CSTATE_FUNCTION_TERMINATE(CActionDiPlogiSuccess );
CSTATE_FUNCTION_TERMINATE(CActionDoDiPlogi );
CSTATE_FUNCTION_TERMINATE(CActionAllocDiPlogiThread );
CSTATE_FUNCTION_TERMINATE(CActionRFT_IDSuccess );
CSTATE_FUNCTION_TERMINATE(CActionDoRFT_ID );
CSTATE_FUNCTION_TERMINATE(CActionInitFM_DelayDone );
CSTATE_FUNCTION_TERMINATE(CActionSendPrimitive );
CSTATE_FUNCTION_TERMINATE(CActionDoExternalDeviceReset );
CSTATE_FUNCTION_TERMINATE(CActionExternalLogoutRecovery );
CSTATE_FUNCTION_TERMINATE(CActionExternalLogout );
CSTATE_FUNCTION_TERMINATE(CActionExternalDeviceReset );
CSTATE_FUNCTION_TERMINATE(CActionLIPEventStorm );
CSTATE_FUNCTION_TERMINATE(CActionElasticStoreEventStorm);
CSTATE_FUNCTION_TERMINATE(CActionFindDeviceUseAllALPAs );
CSTATE_FUNCTION_TERMINATE(CActionLoopFailedReInit );
CSTATE_FUNCTION_TERMINATE(CActionVerify_AL_PA );
CSTATE_FUNCTION_TERMINATE(CActionFlipNPortState );

CSTATE_FUNCTION_TERMINATE(CActionDoSCR );
CSTATE_FUNCTION_TERMINATE(CActionAllocRFT_IDThread );

CDBSTATE_FUNCTION_TERMINATE( CDBActionConfused       );
CDBSTATE_FUNCTION_TERMINATE( CDBActionThreadFree     );
CDBSTATE_FUNCTION_TERMINATE( CDBActionInitialize     );
CDBSTATE_FUNCTION_TERMINATE( CDBActionFillLocalSGL   );
CDBSTATE_FUNCTION_TERMINATE( CDBActionAllocESGL      );
CDBSTATE_FUNCTION_TERMINATE( CDBActionFillESGL       );
CDBSTATE_FUNCTION_TERMINATE( CDBActionSendIo         );
CDBSTATE_FUNCTION_TERMINATE( CDBActionSend_REC_Second         );

CDBSTATE_FUNCTION_ACTION(    CDBActionFcpCompleteSuccess,     CDBEventThreadFree );
CDBSTATE_FUNCTION_ACTION(    CDBActionFcpCompleteSuccessRSP,  CDBEventThreadFree );
CDBSTATE_FUNCTION_ACTION(    CDBActionFcpCompleteFail,        CDBEventThreadFree );
CDBSTATE_FUNCTION_ACTION(    CDBActionFcpCompleteAbort,       CDBEventThreadFree );
CDBSTATE_FUNCTION_ACTION(    CDBActionFcpCompleteDeviceReset, CDBEventThreadFree );
CDBSTATE_FUNCTION_ACTION(    CDBActionFcpCompleteOver,        CDBEventThreadFree );

CDBSTATE_FUNCTION_TERMINATE( CDBActionOOOReceived,                          );
CDBSTATE_FUNCTION_TERMINATE( CDBActionOOOFixup                              );
CDBSTATE_FUNCTION_TERMINATE( CDBActionOOOSend                               );

CDBSTATE_FUNCTION_ACTION(    CDBActionInitialize_DR,       CDBEventThreadFree );
CDBSTATE_FUNCTION_ACTION(    CDBActionFillESGL_DR,         CDBEventThreadFree );
CDBSTATE_FUNCTION_ACTION(    CDBActionAllocESGL_DR,        CDBEventThreadFree );
CDBSTATE_FUNCTION_ACTION(    CDBActionFillLocalSGL_DR,     CDBEventThreadFree );

CDBSTATE_FUNCTION_ACTION(    CDBActionInitialize_Abort  ,CDBEventThreadFree );
CDBSTATE_FUNCTION_ACTION(    CDBActionFillLocalSGL_Abort,CDBEventThreadFree );
CDBSTATE_FUNCTION_ACTION(    CDBActionAllocESGL_Abort   ,CDBEventThreadFree );
CDBSTATE_FUNCTION_ACTION(    CDBActionFillESGL_Abort    ,CDBEventThreadFree );


CDBSTATE_FUNCTION_ACTION( CDBActionOOOReceived_Abort   ,CDBEventThreadFree    );                    /* 24 */
CDBSTATE_FUNCTION_ACTION( CDBActionOOOReceived_DR      ,CDBEventThreadFree    );                    /* 25 */
CDBSTATE_FUNCTION_ACTION( CDBActionOOOFixup_Abort      ,CDBEventThreadFree    );                    /* 26 */
CDBSTATE_FUNCTION_ACTION( CDBActionOOOFixup_DR         ,CDBEventThreadFree    );                    /* 27 */

CDBSTATE_FUNCTION_TERMINATE(CDBAction_SRR_Fail);
CDBSTATE_FUNCTION_TERMINATE(CDBAction_SRR_Success );
CDBSTATE_FUNCTION_TERMINATE(CDBAction_REC_Success );
CDBSTATE_FUNCTION_TERMINATE(CDBActionSend_SRR_Second );
CDBSTATE_FUNCTION_TERMINATE(CDBActionSend_SRR );
CDBSTATE_FUNCTION_TERMINATE(CDBActionSend_REC );
CDBSTATE_FUNCTION_TERMINATE(CDBAction_CCC_IO_Fail );
CDBSTATE_FUNCTION_TERMINATE(CDBAction_CCC_IO_Success );
CDBSTATE_FUNCTION_TERMINATE(CDBActionSend_CCC_IO );
CDBSTATE_FUNCTION_TERMINATE(CDBActionBuild_CCC_IO );
CDBSTATE_FUNCTION_TERMINATE(CDBActionPrepare_For_Abort );
CDBSTATE_FUNCTION_TERMINATE(CDBActionPending_Abort);
CDBSTATE_FUNCTION_TERMINATE(CDBActionDo_Abort );
CDBSTATE_FUNCTION_TERMINATE(CDBActionAlloc_Abort);
CDBSTATE_FUNCTION_TERMINATE(CDBActionFailure_NO_RSP );
CDBSTATE_FUNCTION_TERMINATE(CDBActionOutBoundError );
CDBSTATE_FUNCTION_TERMINATE(CDBActionReSend_IO );
CDBSTATE_FUNCTION_TERMINATE(CDBActionDO_Nothing );
CDBSTATE_FUNCTION_TERMINATE(CDBAction_Alloc_REC );

#define __State_Force_Static_State_Tables__

#ifdef SkipThisStuff 
void main(void)
{
agRoot_t rhpRoot;
agRoot_t * hpRoot = &rhpRoot;

hpRoot->fcData = agNULL;
testCDBthread( hpRoot  );
}


void testCthread( agRoot_t * hpRoot  ){
    CThread_t  * pCThread = CThread_ptr(hpRoot);

    fiInitializeThread(&pCThread->thread_hdr,
        hpRoot,
        threadType_CThread,
        CStateShutdown,
#ifdef __State_Force_Static_State_Tables__
        &CStateTransitionMatrix,
        &CStateActionScalar
#else /* __State_Force_Static_State_Tables__ was not defined */
        pCThread->Calculation.MemoryLayout.CTransitions.addr.CachedMemory.cachedMemoryPtr,
        pCThread->Calculation.MemoryLayout.CActions.addr.CachedMemory.cachedMemoryPtr
#endif /* __State_Force_Static_State_Tables__ was not defined */
        );

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "0 ******************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Initial state = %1x",
                    (char *)agNULL,(char *)agNULL,
                    pCThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);



    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventShutdown ...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    fiSendEvent(&pCThread->thread_hdr,CEventShutdown);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Shutdown Final state = %1x",
                    (char *)agNULL,(char *)agNULL,
                    pCThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "1 ****************************************** Ends on CStateShutdown",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventInitalize...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventInitalize);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "2 ****************************************** Ends on CStateNormal",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventResetIfNeeded...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventResetIfNeeded);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "3 ****************************************** Ends on CStateNormal",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "Sending event CEventAsyncLoopEventDetected...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventAsyncLoopEventDetected);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "4 ****************************************** Ends on CStateResetNeeded",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventAsyncLoopEventDetected...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventAsyncLoopEventDetected);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "5 ******************************************Ends on CStateResetNeeded",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventResetIfNeeded...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventResetIfNeeded);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "6 ****************************************** Ends on CStateNormal",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventAsyncLoopEventDetected...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventAsyncLoopEventDetected);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "7 ******************************************Ends on CStateResetNeeded",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventResetIfNeeded...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventResetIfNeeded);




    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "8 ****************************************** Ends on CStateNormal",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventAsyncLoopEventDetected...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventAsyncLoopEventDetected);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "9 ******************************************Ends on CStateResetNeeded",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventResetIfNeeded...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventResetIfNeeded);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "10 ****************************************** Ends on CStateALPADifferent",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventInitalize...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventInitalize);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "11 ****************************************** Ends on CStateNormal",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventAsyncLoopEventDetected...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventAsyncLoopEventDetected);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "12 ******************************************Ends on CStateResetNeeded",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventResetIfNeeded...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventResetIfNeeded);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "13 ****************************************** Ends on CStateNormal",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventAsyncLoopEventDetected...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventAsyncLoopEventDetected);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "14 ******************************************Ends on CStateResetNeeded",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventResetIfNeeded...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventResetIfNeeded);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "15 ****************************************** Ends on CStateNormal",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventAsyncLoopEventDetected...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventAsyncLoopEventDetected);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "16 ******************************************Ends on CStateResetNeeded",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventResetIfNeeded...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventResetIfNeeded);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "17 ******************************************Ends on CStateALPADifferent",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventInitalize...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventInitalize);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "18 ****************************************** Ends on CStateNormal",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventAsyncLoopEventDetected...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventAsyncLoopEventDetected);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "19 ******************************************Ends on CStateResetNeeded",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventResetIfNeeded...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventResetIfNeeded);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "20 ****************************************** Ends on CStateNormal",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventAsyncLoopEventDetected...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventAsyncLoopEventDetected);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "21 ******************************************Ends on CStateResetNeeded",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventResetIfNeeded...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventResetIfNeeded);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "22 ******************************************Ends on CStateNormal",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventResetIfNeeded...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventResetIfNeeded);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "23 ****************************************** Ends on CStateNormal",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventAsyncLoopEventDetected...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventAsyncLoopEventDetected);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "24 ******************************************Ends on CStateResetNeeded",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventResetIfNeeded...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventResetIfNeeded);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "25 ******************************************Ends on CStateALPADifferent",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "Sending event CEventInitalize...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventInitalize);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "26 ****************************************** Ends on CStateInitializeFailed",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "Sending event CEventInitalize...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventInitalize);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "27 ****************************************** Ends on CStateInitializeFailed",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "Sending event CEventInitalize...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventInitalize);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "28 ****************************************** Ends on CStateNormal",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "Sending event CEventAsyncLoopEventDetected...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventAsyncLoopEventDetected);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "29 ******************************************Ends on CStateResetNeeded",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "Sending event CEventResetIfNeeded...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventResetIfNeeded);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "30 ****************************************** Ends on CStateNormal",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "Sending event CEventAsyncLoopEventDetected...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventAsyncLoopEventDetected);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "31 ******************************************Ends on CStateResetNeeded",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "Sending event CEventResetIfNeeded...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventResetIfNeeded);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "32 ******************************************Ends on CStateNormal",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "Sending event CEventResetIfNeeded...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventResetIfNeeded);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "33 ****************************************** Ends on CStateNormal",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "Sending event CEventAsyncLoopEventDetected...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventAsyncLoopEventDetected);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "34 ******************************************Ends on CStateResetNeeded",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "Sending event CEventResetIfNeeded...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventResetIfNeeded);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "35 ******************************************Ends on CStateALPADifferent",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);



}

/* CDB Test functions *************************************************************************************
*/



void testCDBthread( agRoot_t * hpRoot ){

    CThread_t   * pCThread   = CThread_ptr(hpRoot);
    CDBThread_t * pCDBThread  = pCThread->Calculation.MemoryLayout.CDBThread.addr.CachedMemory.cachedMemoryPtr;
    DevThread_t * pDevThread = pCThread->Calculation.MemoryLayout.DevThread.addr.CachedMemory.cachedMemoryPtr;


     pCDBThread->Device = pDevThread;
    /* CDBThread */
    if(1)
        {

        fiInitializeThread(&pCDBThread->thread_hdr,
            hpRoot,
            threadType_CDBThread,
            CDBStateThreadFree,
#ifdef __State_Force_Static_State_Tables__
            &CDBStateTransitionMatrix,
            &CDBStateActionScalar
#else /* __State_Force_Static_State_Tables__ was not defined */
            pCThread->Calculation.MemoryLayout.CDBTransitions.addr.CachedMemory.cachedMemoryPtr,
            pCThread->Calculation.MemoryLayout.CDBActions.addr.CachedMemory.cachedMemoryPtr
#endif /* __State_Force_Static_State_Tables__ was not defined */
            );

        }

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "1 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventLocalSGL);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventLocalSGLSendIo );

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "Should be in Send IO  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoSuccess);


    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "2 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventNeedESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventGotESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventESGLSendIo );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoSuccess);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "3 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventNeedESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventGotESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventESGLSendIo );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOReceived );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOFixup );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOSend );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOReceived );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOFixup );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOSend );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoSuccess);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "4 Start Reset Device ***************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIODeviceReset);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "4 Should be in ThreadFree  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "5 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventLocalSGL);

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIODeviceReset);


    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "6 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoAbort);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "Should be in ThreadFree IO  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventLocalSGL);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventLocalSGLSendIo );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIODeviceReset);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "7 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventNeedESGL );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIODeviceReset);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "Should be in ThreadFree IO  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);
    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "8 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventNeedESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventGotESGL );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIODeviceReset);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "Should be in ThreadFree IO  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);

     osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "9 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventLocalSGL);

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoAbort);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "10 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventNeedESGL);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoAbort);
 
   osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "Should be in ThreadFree IO  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "11 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventLocalSGL);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventLocalSGLSendIo );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoAbort);
    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "12 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventLocalSGL);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventLocalSGLSendIo );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIODeviceReset);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "Should be in ThreadFree IO  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "13 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventNeedESGL);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventGotESGL);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoAbort);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "Should be in ThreadFree IO  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);
    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "14 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventNeedESGL);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventGotESGL);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIODeviceReset);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "15 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventNeedESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventGotESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventESGLSendIo );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOReceived );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOFixup );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOSend );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOReceived );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIODeviceReset);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "Should be in ThreadFree IO  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);
    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "16 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventNeedESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventGotESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventESGLSendIo );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOReceived );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOFixup );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOSend );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOReceived );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOFixup );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoAbort);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "Should be in ThreadFree IO  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);
    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "17 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoAbort);

        osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "18 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventNeedESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventGotESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventESGLSendIo );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOReceived );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOFixup );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOSend );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoAbort);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "Should be in ThreadFree IO  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "19 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventNeedESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventGotESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventESGLSendIo );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOReceived );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOFixup );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOSend );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOReceived );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOFixup );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOSend );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoOver);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "Should be in ThreadFree IO  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "20 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventNeedESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventGotESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventESGLSendIo );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOReceived );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOFixup );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOSend );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOReceived );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOFixup );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOSend );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoFailed);



    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "Should be in ThreadFree IO  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "21 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventNeedESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventGotESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventESGLSendIo );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOReceived );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOFixup );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOSend );
    
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOReceived );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOFixup );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOSend );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoSuccess);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "Should be in ThreadFree IO  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "22 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventNeedESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventGotESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventESGLSendIo );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOReceived );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOFixup );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOSend );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOReceived );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOFixup );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOSend );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoSuccessRSP);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "Should be in ThreadFree IO  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);
    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "23 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventNeedESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventGotESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventESGLSendIo );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoSuccessRSP);



    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "Should be in ThreadFree IO  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);

}

#endif /* SkipThisStuff  */


DEVSTATE_FUNCTION_TERMINATE(DevActionConfused);
DEVSTATE_FUNCTION_TERMINATE(DevActionAvailable );
DEVSTATE_FUNCTION_TERMINATE(DevActionLoginFailed );

DEVSTATE_FUNCTION_MULTI_ACTION(DevActionDoPlogi       ,DevEventPlogiSuccess, DevEventPlogiFailed, DevEventPlogiSuccess, DevEventPlogiSuccess );
DEVSTATE_FUNCTION_MULTI_ACTION(DevActionDoPrli        ,DevEventPrliSuccess,  DevEventPrliFailed,  DevEventPrliSuccess,  DevEventPrliSuccess );
DEVSTATE_FUNCTION_MULTI_ACTION(DevActionMatchWWN      ,DevEventMatchWWN,     DevEventNoMatchWWN,  DevEventMatchWWN,     DevEventNoMatchWWN  );


DEVSTATE_FUNCTION_ACTION(DevActionHandleEmpty,   DevEventLogin );
DEVSTATE_FUNCTION_ACTION(DevActionAllocSFThread ,DevEventGotSFThread  );
DEVSTATE_FUNCTION_ACTION(DevActionPlogiDone     ,DevEventDoPrli    );
DEVSTATE_FUNCTION_ACTION(DevActionPrliDone      ,DevEventCheckWWN  );
DEVSTATE_FUNCTION_ACTION(DevActionSlotNew       ,DevEventAvailable );
DEVSTATE_FUNCTION_ACTION(DevActionSlotKnown     ,DevEventAvailable );
DEVSTATE_FUNCTION_ACTION(DevActionLogout        ,DevEventLoggedOut );


DEVSTATE_FUNCTION_ACTION(DevActionAllocDeviceResetSoft, DevEventDeviceResetSoft);
DEVSTATE_FUNCTION_ACTION(DevActionAllocDeviceResetHard, DevEventDeviceResetHard);

DEVSTATE_FUNCTION_ACTION(DevActionDeviceResetSoft, DevEventDeviceResetDone);
DEVSTATE_FUNCTION_ACTION(DevActionDeviceResetHard, DevEventDeviceResetDone);
DEVSTATE_FUNCTION_TERMINATE(DevActionDeviceResetDone);

DEVSTATE_FUNCTION_TERMINATE(DevAction_IO_Sent);
DEVSTATE_FUNCTION_TERMINATE(DevAction_IO_Ready);
DEVSTATE_FUNCTION_TERMINATE(DevActionTickGotSFThread);
DEVSTATE_FUNCTION_TERMINATE(DevActionExternalDeviceReset);
DEVSTATE_FUNCTION_TERMINATE(DevActionTickVerifyALPA);
DEVSTATE_FUNCTION_TERMINATE(DevActionAdiscDone_FAIL);
DEVSTATE_FUNCTION_TERMINATE(DevActionAdiscDone_OK);
DEVSTATE_FUNCTION_TERMINATE(DevActionAdisc);
DEVSTATE_FUNCTION_TERMINATE(DevActionAL_PA_Self_BAD);
DEVSTATE_FUNCTION_TERMINATE(DevActionAL_PA_Self_OK);
DEVSTATE_FUNCTION_TERMINATE(DevActionAllocAdisc);
DEVSTATE_FUNCTION_TERMINATE(DevActionDeviceResetDoneFAIL);
DEVSTATE_FUNCTION_TERMINATE(DevActionAdiscDone_FAIL_ReLogin);
DEVSTATE_FUNCTION_TERMINATE(DevActionAdiscDone_FAIL_No_Device);
DEVSTATE_FUNCTION_TERMINATE(DevAction_FC_TAPE_Recovery);



SFSTATE_FUNCTION_TERMINATE(SFActionDoLS_RJT);
SFSTATE_FUNCTION_TERMINATE(SFActionLS_RJT_Done );

SFSTATE_FUNCTION_TERMINATE(SFActionDoPlogiAccept);
SFSTATE_FUNCTION_TERMINATE(SFActionPlogiAccept_Done);

SFSTATE_FUNCTION_TERMINATE(SFActionDoPrliAccept);
SFSTATE_FUNCTION_TERMINATE(SFActionPrliAccept_Done);

SFSTATE_FUNCTION_TERMINATE(SFActionDoELSAccept);
SFSTATE_FUNCTION_TERMINATE(SFActionELSAccept_Done);

SFSTATE_FUNCTION_TERMINATE(SFActionDoFCP_DR_ACC_Reply);
SFSTATE_FUNCTION_TERMINATE(SFActionFCP_DR_ACC_Reply_Done);


SFSTATE_FUNCTION_TERMINATE(SFActionLS_RJT_TimeOut );
SFSTATE_FUNCTION_TERMINATE(SFActionPlogiAccept_TimeOut);
SFSTATE_FUNCTION_TERMINATE(SFActionPrliAccept_TimeOut);
SFSTATE_FUNCTION_TERMINATE(SFActionELSAccept_TimeOut);
SFSTATE_FUNCTION_TERMINATE(SFActionFCP_DR_ACC_Reply_TimeOut);
SFSTATE_FUNCTION_TERMINATE(SFActionDoRFT_ID);
SFSTATE_FUNCTION_TERMINATE(SFActionRFT_IDAccept);
SFSTATE_FUNCTION_TERMINATE(SFActionRFT_IDRej);
SFSTATE_FUNCTION_TERMINATE(SFActionRFT_IDBadALPA);
SFSTATE_FUNCTION_TERMINATE(SFActionRFT_IDTimedOut);
SFSTATE_FUNCTION_TERMINATE(SFActionDoGID_FT);
SFSTATE_FUNCTION_TERMINATE(SFActionGID_FTAccept);
SFSTATE_FUNCTION_TERMINATE(SFActionGID_FTRej);
SFSTATE_FUNCTION_TERMINATE(SFActionGID_FTBadALPA);
SFSTATE_FUNCTION_TERMINATE(SFActionGID_FTTimedOut);

SFSTATE_FUNCTION_TERMINATE(SFActionDoSCR);
SFSTATE_FUNCTION_TERMINATE(SFActionSCRAccept);
SFSTATE_FUNCTION_TERMINATE(SFActionSCRRej);
SFSTATE_FUNCTION_TERMINATE(SFActionSCRBadALPA);
SFSTATE_FUNCTION_TERMINATE(SFActionSCRTimedOut);

SFSTATE_FUNCTION_TERMINATE(SFActionDoSRR);
SFSTATE_FUNCTION_TERMINATE(SFActionSRRAccept);
SFSTATE_FUNCTION_TERMINATE(SFActionSRRRej);
SFSTATE_FUNCTION_TERMINATE(SFActionSRRBadALPA);
SFSTATE_FUNCTION_TERMINATE(SFActionSRRTimedOut);

SFSTATE_FUNCTION_TERMINATE(SFActionDoREC);
SFSTATE_FUNCTION_TERMINATE(SFActionRECAccept);
SFSTATE_FUNCTION_TERMINATE(SFActionRECRej);
SFSTATE_FUNCTION_TERMINATE(SFActionRECBadALPA);
SFSTATE_FUNCTION_TERMINATE(SFActionRECTimedOut);


SFSTATE_FUNCTION_TERMINATE(SFActionLogoTimedOut);
SFSTATE_FUNCTION_TERMINATE(SFActionLogoBadALPA);
SFSTATE_FUNCTION_TERMINATE(SFActionLogoRej);
SFSTATE_FUNCTION_TERMINATE(SFActionLogoAccept);
SFSTATE_FUNCTION_TERMINATE(SFActionDoLogo);


TgtSTATE_FUNCTION_TERMINATE(TgtActionELSAcc);
TgtSTATE_FUNCTION_TERMINATE(TgtActionFCP_DR_ACC_ReplyDone);
TgtSTATE_FUNCTION_TERMINATE(TgtActionFCP_DR_ACC_Reply);
TgtSTATE_FUNCTION_TERMINATE(TgtActionELS_ACC_ReplyDone);
TgtSTATE_FUNCTION_TERMINATE(TgtActionLOGO_ACC_Reply);
TgtSTATE_FUNCTION_TERMINATE(TgtActionPRLI_ACC_ReplyDone);
TgtSTATE_FUNCTION_TERMINATE(TgtActionPRLI_ACC_Reply);
TgtSTATE_FUNCTION_TERMINATE(TgtActionPLOGI_ACC_ReplyDone);
TgtSTATE_FUNCTION_TERMINATE(TgtActionPLOGI_ACC_Reply);
TgtSTATE_FUNCTION_TERMINATE(TgtActionPLOGI_RJT_ReplyDone);
TgtSTATE_FUNCTION_TERMINATE(TgtActionPLOGI_RJT_Reply);
TgtSTATE_FUNCTION_TERMINATE(TgtActionIncoming);
TgtSTATE_FUNCTION_TERMINATE(TgtActionIdle);
TgtSTATE_FUNCTION_TERMINATE(TgtActionADISCAcc_ReplyDone);
TgtSTATE_FUNCTION_TERMINATE(TgtActionADISCAcc_Reply);

#ifdef SkipThisStuff  

void testDevthread(  agRoot_t * hpRoot ){
    CThread_t  * pCThread = CThread_ptr(hpRoot);
    DevThread_t  * pDevThread;
    pDevThread = pCThread->Calculation.MemoryLayout.DevThread.addr.CachedMemory.cachedMemoryPtr;

    /* Dev Thread */
    if(1){
    fiInitializeThread(&pDevThread->thread_hdr,
            hpRoot,
            threadType_DevThread,
            DevStateHandleEmpty,
#ifdef __State_Force_Static_State_Tables__
            &DevStateTransitionMatrix,
            &DevStateActionScalar
#else /* __State_Force_Static_State_Tables__ was not defined */
            pCThread->Calculation.MemoryLayout.DevTransitions.addr.CachedMemory.cachedMemoryPtr,
            pCThread->Calculation.MemoryLayout.DevActions.addr.CachedMemory.cachedMemoryPtr
#endif /* __State_Force_Static_State_Tables__ was not defined */
            );


        osLogDebugString(pDevThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "1 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

        fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);

        osLogDebugString(pDevThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "2 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

        fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);

        osLogDebugString(pDevThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "3 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);
        fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);

        osLogDebugString(pDevThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "4 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);
        fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);

        osLogDebugString(pDevThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "5 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);
        fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);

        osLogDebugString(pDevThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "6 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);
        fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);

        osLogDebugString(pDevThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "7 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);
        fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);

        osLogDebugString(pDevThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "8 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);
        fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);

        osLogDebugString(pDevThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "9 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);
        fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);

        osLogDebugString(pDevThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "10 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);
        fiSendEvent(&pDevThread->thread_hdr,DevEventAllocDeviceResetSoft);

        osLogDebugString(pDevThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "11 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);
        fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);

        osLogDebugString(pDevThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "12 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);
        fiSendEvent(&pDevThread->thread_hdr,DevEventAllocDeviceResetHard);

        osLogDebugString(pDevThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "13 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);
        fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);



    }
    }

#endif /* SkipThisStuff  */

SFSTATE_FUNCTION_TERMINATE(SFActionConfused);
SFSTATE_FUNCTION_TERMINATE(SFActionReset);

SFSTATE_FUNCTION_TERMINATE(SFActionDoPdisc       );
SFSTATE_FUNCTION_ACTION(SFActionPdiscTimedOut , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionPdiscAccept  , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionPdiscRej     , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionPdiscBadALPA , SFEventReset );

SFSTATE_FUNCTION_TERMINATE(SFActionDoAbort       );
SFSTATE_FUNCTION_ACTION(SFActionAbortTimedOut , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionAbortBadALPA  , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionAbortRej      , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionAbortAccept   , SFEventReset );

SFSTATE_FUNCTION_TERMINATE(SFActionDoPlogi       );
SFSTATE_FUNCTION_ACTION(SFActionPlogiTimedOut , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionPlogiAccept  , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionPlogiRej     , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionPlogiBadALPA , SFEventReset );

SFSTATE_FUNCTION_TERMINATE(SFActionDoPrli        );
SFSTATE_FUNCTION_ACTION(SFActionPrliTimedOut  , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionPrliAccept   , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionPrliRej      , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionPrliBadALPA  , SFEventReset );

SFSTATE_FUNCTION_TERMINATE(SFActionDoFlogi       );
SFSTATE_FUNCTION_ACTION(SFActionFlogiTimedOut , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionFlogiAccept  , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionFlogiRej     , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionFlogiBadALPA , SFEventReset );


SFSTATE_FUNCTION_TERMINATE(SFActionDoPlogo       );
SFSTATE_FUNCTION_ACTION(SFActionPlogoTimedOut , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionPlogoAccept  , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionPlogoRej     , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionPlogoBadALPA , SFEventReset );

SFSTATE_FUNCTION_TERMINATE(SFActionDoPrlo        );
SFSTATE_FUNCTION_ACTION(SFActionPrloTimedOut , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionPrloAccept   , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionPrloRej      , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionPrloBadALPA  , SFEventReset );

SFSTATE_FUNCTION_TERMINATE(SFActionDoAdisc       );
SFSTATE_FUNCTION_ACTION(SFActionAdiscTimedOut, SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionAdiscAccept  , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionAdiscRej     , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionAdiscBadALPA , SFEventReset );

SFSTATE_FUNCTION_TERMINATE(SFActionDoResetDevice);
SFSTATE_FUNCTION_ACTION(SFActionResetDeviceAccept,   SFEventReset);
SFSTATE_FUNCTION_ACTION(SFActionResetDeviceRej,      SFEventReset);
SFSTATE_FUNCTION_ACTION(SFActionResetDeviceBadALPA , SFEventReset);
SFSTATE_FUNCTION_ACTION(SFActionResetDeviceTimedOut, SFEventReset);

SFSTATE_FUNCTION_TERMINATE(SFActionADISCAccept_TimeOut);
SFSTATE_FUNCTION_TERMINATE(SFActionADISCAccept_Done);
SFSTATE_FUNCTION_TERMINATE(SFActionDoADISCAccept);



#ifdef  SkipThisStuff 

void testSFthread( agRoot_t * hpRoot ){
    CThread_t  * pCThread = CThread_ptr(hpRoot);

    SFThread_t   * pSFThread = pCThread->Calculation.MemoryLayout.SFThread.addr.CachedMemory.cachedMemoryPtr;

    /* SF Thread */
    if(1){

        fiInitializeThread(&pSFThread->thread_hdr,
            hpRoot,
            threadType_SFThread,
            SFStateFree,
#ifdef __State_Force_Static_State_Tables__
            &SFStateTransitionMatrix,
            &SFStateActionScalar
#else /* __State_Force_Static_State_Tables__ was not defined */
            pCThread->Calculation.MemoryLayout.SFTransitions.addr.CachedMemory.cachedMemoryPtr,
            pCThread->Calculation.MemoryLayout.SFActions.addr.CachedMemory.cachedMemoryPtr
#endif /* __State_Force_Static_State_Tables__ was not defined */
            );


    /* printf("Sending event SFEventDoPlogi...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPlogi);
    /* printf("Sending event SFEventPlogiAccept...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventPlogiAccept);

    /* printf("Sending event SFEventDoPlogi...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPlogi);
    /* printf("Sending event SFEventPlogiRej...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventPlogiRej);


    /* printf("Sending event SFEventDoPlogi...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPlogi);
    /* printf("Sending event SFEventPlogiBadALPA...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventPlogiBadALPA);

    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPlogi);
    /* printf("Sending event SFEventPlogiBadALPA...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventPlogiTimedOut);

    /* printf("Sending event SFEventDoFlogi...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoFlogi);
    /* printf("Sending event SFEventFlogiAccept...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventFlogiAccept);


    /* printf("Sending event SFEventDoFlogi...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoFlogi);
    /* printf("Sending event SFEventFlogiRej...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventFlogiRej);

    /* printf("Sending event SFEventDoFlogi...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoFlogi);
    /* printf("Sending event SFEventFlogiBadALPA...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventFlogiBadALPA);

    /* printf("Sending event SFEventDoPrli...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPrli);
    /* printf("Sending event SFEventPrliAccept...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventPrliAccept);

    /* printf("Sending event SFEventDoPrli...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPrli);
    /* printf("Sending event SFEventPrliRej...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventPrliRej);

    /* printf("Sending event SFEventDoPrli...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPrli);
    /* printf("Sending event SFEventPrliBadALPA...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventPrliBadALPA);

    /* printf("Sending event SFEventDoPdisc...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPdisc);
    /* printf("Sending event SFEventPdiscAccept...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventPdiscAccept);

    /* printf("Sending event SFEventDoPdisc...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPdisc);
    /* printf("Sending event SFEventPdiscRej...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventPdiscRej);

    /* printf("Sending event SFEventDoPdisc...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPdisc);
    /* printf("Sending event SFEventPdiscBadALPA...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventPdiscBadALPA);

    /* printf("Sending event SFEventDoPdisc...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPdisc);
    /* printf("Sending event SFEventPdiscBadALPA...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventPdiscTimedOut);


    /* printf("Sending event SFEventDoAbort...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoAbort);
    /* printf("Sending event SFEventAbortBadALPA...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventAbortTimedOut);

    /* printf("Sending event SFEventDoAdisc...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoAdisc);
    /* printf("Sending event SFEventAdiscBadALPA...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventAdiscTimedOut);

    /* printf("Sending event SFEventDoFlogi...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoFlogi);
    /* printf("Sending event SFEventFlogiBadALPA...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventFlogiBadALPA);

    /* printf("Sending event SFEventDoPlogi...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPlogi);
    /* printf("Sending event SFEventPlogiAccept...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventPlogiAccept);
    /* printf("Sending event SFEventDoPrli...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPrli);
    /* printf("Sending event SFEventPrliAccept...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventPrliAccept);
    /* printf("Sending event SFEventDoAdisc...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoAdisc);
    /* printf("Sending event SFEventAdiscBadALPA...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventAdiscAccept);
    /* printf("Sending event SFEventDoPdisc...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPdisc);
    /* printf("Sending event SFEventPdiscAccept...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventPdiscAccept);
    /* printf("Sending event SFEventDoAbort...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoAbort);
    /* printf("Sending event SFEventAbortBadALPA...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventAbortAccept);
    /* printf("Sending event SFEventDoPlogo...\n"); */

    fiSendEvent(&pSFThread->thread_hdr,SFEventDoResetDevice);
    fiSendEvent(&pSFThread->thread_hdr,SFEventResetDeviceAccept);

    fiSendEvent(&pSFThread->thread_hdr,SFEventDoResetDevice);
    fiSendEvent(&pSFThread->thread_hdr,SFEventResetDeviceRej);

    fiSendEvent(&pSFThread->thread_hdr,SFEventDoResetDevice);
    fiSendEvent(&pSFThread->thread_hdr,SFEventResetDeviceBadALPA);

    fiSendEvent(&pSFThread->thread_hdr,SFEventDoResetDevice);
    fiSendEvent(&pSFThread->thread_hdr,SFEventResetDeviceTimedOut);

    }
    return;



}

#endif /* SkipThisStuff  */

#endif /* USESTATEMACROS */

#ifdef  SkipThisStuff 


void CFunc_Check_SEST(agRoot_t * hpRoot){
    CThread_t  * pCThread = CThread_ptr(hpRoot);
    os_bit32 num_sest_entry = pCThread->Calculation.MemoryLayout.SEST.elements - 1;
    os_bit32 x;
    os_bit32 sest_offset;
    USE_t                     *SEST;


    if(pCThread->Calculation.MemoryLayout.SEST.memLoc ==  inDmaMemory)
    {
        SEST = (USE_t *)pCThread->Calculation.MemoryLayout.SEST.addr.DmaMemory.dmaMemoryPtr;
        for(x= 0; x < num_sest_entry; x++, SEST++)
        {
            if(SEST->Bits & USE_VAL )
            {
                osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            
                            "X_ID %3X Bits %08X Link %08X",
                            (char *)agNULL,(char *)agNULL,
                            x,
                            SEST->Bits,
                            SEST->Unused_DWord_5,
                            0,0,0,0,0);

    
/*
                osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            
                            "Sest DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                            (char *)agNULL,(char *)agNULL,
                            SEST->Bits,
                            SEST->Unused_DWord_1,
                            SEST->Unused_DWord_2,
                            SEST->Unused_DWord_3,
                            SEST->LOC,
                            SEST->Unused_DWord_5,
                            SEST->Unused_DWord_6,
                            SEST->Unused_DWord_7);

                osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            
                            "Sest DWORD 8 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                            (char *)agNULL,(char *)agNULL,
                            SEST->Unused_DWord_8,
                            SEST->Unused_DWord_9,
                            SEST->First_SG.U32_Len,
                            SEST->First_SG.L32,
                            SEST->Second_SG.U32_Len,
                            SEST->Second_SG.L32,
                            SEST->Third_SG.U32_Len,
                            SEST->Third_SG.L32);
*/
            }

        }


    }
    else
    {   /* inCardRam */
            osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "SEST.memLoc OnCard",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

             sest_offset  = pCThread->Calculation.MemoryLayout.SEST.addr.CardRam.cardRamOffset;

        for(x= 0; x < num_sest_entry; x++ )
        {

            osCardRamWriteBit32(
                                 hpRoot,
                                 sest_offset + (sizeof(USE_t) * x),
                                 0);

        }

    }

}


void CFunc_OLD_Check_ERQ_RegistersOld( agRoot_t *hpRoot )
{
    CThread_t                  * pCThread= CThread_ptr(hpRoot);
    IRB_t                      * Base_ERQ_Entry;
    IRB_t                      * ERQ_Entry;
    X_ID_t                       X_ID;
    DevThread_t                * pDevThread;
    CDBThread_t                * pCDBThread;
    fiMemMapMemoryDescriptor_t * CDBThread_MemoryDescriptor = &pCThread->Calculation.MemoryLayout.CDBThread;

    os_bit32 Producer_Index;
    os_bit32 Consumer_Index;
    os_bit32 entry ;

    os_bit32 Max_ERQ = pCThread->Calculation.MemoryLayout.ERQ.elements - 1;

    Producer_Index = osChipIOLoReadBit32(hpRoot, ChipIOLo_ERQ_Producer_Index);
    Consumer_Index = osChipIOLoReadBit32(hpRoot, ChipIOLo_ERQ_Consumer_Index);

    if(pCThread->Calculation.MemoryLayout.ERQ.memLoc == inDmaMemory)
    {
        Base_ERQ_Entry = (IRB_t  *)pCThread->Calculation.MemoryLayout.ERQ.addr.DmaMemory.dmaMemoryPtr;
        osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    
                    "Base_ERQ_Entry %08X P %4X  C %4X",
                    (char *)agNULL,(char *)agNULL,
                    (os_bit32)Base_ERQ_Entry,
                    Producer_Index,
                    Consumer_Index,
                    0,0,0,0,0);
    }



    if( Consumer_Index == Producer_Index )
    {
        ERQ_Entry = Base_ERQ_Entry + (Consumer_Index -1);
        X_ID = ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID & 0x00007fff;

        if(X_ID < CDBThread_MemoryDescriptor->elements)
        {
            pCDBThread = (CDBThread_t *)((os_bit8 *)(CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                         + (X_ID * CDBThread_MemoryDescriptor->elementSize));

            if (!(pCDBThread->ExchActive))
            {
                osLogDebugString(hpRoot,
                            CFuncLogConsoleERROR,
                            
                            "Equal Prior Found a cbdthread that is not active... %x State %d",
                            (char *)agNULL,(char *)agNULL,
                            (os_bit32) pCDBThread,
                            pCDBThread->thread_hdr.currentState,0,0,0,0,0,0);

                 osLogDebugString(hpRoot,
                            CFuncLogConsoleERROR,
                            
                            "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                            (char *)agNULL,(char *)agNULL,
                            (os_bit32)pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                            (os_bit32)pCDBThread->CDB_CMND_Class,
                            (os_bit32)pCDBThread->CDB_CMND_Type,
                            (os_bit32)pCDBThread->CDB_CMND_State,
                            (os_bit32)pCDBThread->CDB_CMND_Status,
                            0,0,0);
            }
            else
            {
                pCThread->pollingCount--;
                pDevThread = pCDBThread->Device; 
                osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            
                            "Equal Prior Device %2X SEST Entry %3X",
                            (char *)agNULL,(char *)agNULL,
                            pDevThread->DevInfo.CurrentAddress.AL_PA,
                            ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID ,
                            0,0,0,0,0,0);
            }
        }

        ERQ_Entry = Base_ERQ_Entry + Consumer_Index;
        X_ID = ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID & 0x00007fff;

        if(X_ID < CDBThread_MemoryDescriptor->elements)
        {
            pCDBThread = (CDBThread_t *)((os_bit8 *)(CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                         + (X_ID * CDBThread_MemoryDescriptor->elementSize));

            if (!(pCDBThread->ExchActive))
            {
                osLogDebugString(hpRoot,
                            CFuncLogConsoleERROR,
                            
                            "Equal Found a cbdthread that is not active... %x State %d",
                            (char *)agNULL,(char *)agNULL,
                            (os_bit32) pCDBThread,
                            pCDBThread->thread_hdr.currentState,0,0,0,0,0,0);

                 osLogDebugString(hpRoot,
                            CFuncLogConsoleERROR,
                            
                            "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                            (char *)agNULL,(char *)agNULL,
                            pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                            pCDBThread->CDB_CMND_Class,
                            pCDBThread->CDB_CMND_Type,
                            pCDBThread->CDB_CMND_State,
                            pCDBThread->CDB_CMND_Status,
                            0,0,0);
            }
            else
            {
                pDevThread = pCDBThread->Device; 
                pCThread->pollingCount--;
                osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            
                            "Equal Device %2X SEST Entry %3X",
                            (char *)agNULL,(char *)agNULL,
                            pDevThread->DevInfo.CurrentAddress.AL_PA,
                            ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID ,
                            0,0,0,0,0,0);
            }
        }
    }
    else /* Consumer_Index != Producer_Index  */
    {
        if( Consumer_Index < Producer_Index )
        {
            ERQ_Entry = Base_ERQ_Entry + (Consumer_Index -1);
            pCThread->pollingCount--;
            X_ID = ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID & 0x00007fff;

            if(X_ID < CDBThread_MemoryDescriptor->elements)
            {
                pCDBThread = (CDBThread_t *)((os_bit8 *)(CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                             + (X_ID * CDBThread_MemoryDescriptor->elementSize));

                if (!(pCDBThread->ExchActive))
                {
                    osLogDebugString(hpRoot,
                                CFuncLogConsoleERROR,
                                
                                "Less Prior Found a cbdthread that is not active... %x State %d",
                                (char *)agNULL,(char *)agNULL,
                                (os_bit32) pCDBThread,
                                pCDBThread->thread_hdr.currentState,0,0,0,0,0,0);

                     osLogDebugString(hpRoot,
                                CFuncLogConsoleERROR,
                                
                                "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                                (char *)agNULL,(char *)agNULL,
                                pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                                pCDBThread->CDB_CMND_Class,
                                pCDBThread->CDB_CMND_Type,
                                pCDBThread->CDB_CMND_State,
                                pCDBThread->CDB_CMND_Status,
                                0,0,0);
                }
                else
                {
                    pDevThread = pCDBThread->Device; 
                    pCThread->pollingCount--;
                    osLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                
                                "Less Prior Device %2X SEST Entry %3X",
                                (char *)agNULL,(char *)agNULL,
                                pDevThread->DevInfo.CurrentAddress.AL_PA,
                                ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID ,
                                0,0,0,0,0,0);
                }
            }
        
            for(entry = Consumer_Index; entry < Producer_Index; entry ++)
            {
                ERQ_Entry = Base_ERQ_Entry + entry;

                X_ID = ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID & 0x00007fff;

                if(X_ID < CDBThread_MemoryDescriptor->elements)
                {
                    pCDBThread = (CDBThread_t *)((os_bit8 *)(CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                                 + (X_ID * CDBThread_MemoryDescriptor->elementSize));

                    if (!(pCDBThread->ExchActive))
                    {
                        osLogDebugString(hpRoot,
                                    CFuncLogConsoleERROR,
                                    
                                    "Less Found a cbdthread that is not active... %x State %d",
                                    (char *)agNULL,(char *)agNULL,
                                    (os_bit32) pCDBThread,
                                    pCDBThread->thread_hdr.currentState,0,0,0,0,0,0);

                         osLogDebugString(hpRoot,
                                    CFuncLogConsoleERROR,
                                    
                                    "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                                    (char *)agNULL,(char *)agNULL,
                                    pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                                    pCDBThread->CDB_CMND_Class,
                                    pCDBThread->CDB_CMND_Type,
                                    pCDBThread->CDB_CMND_State,
                                    pCDBThread->CDB_CMND_Status,
                                    0,0,0);
                    }
                    else
                    {
                        pDevThread = pCDBThread->Device; 
                        pCThread->pollingCount--;
                        osLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    
                                    "Less Device %2X SEST Entry %3X",
                                    (char *)agNULL,(char *)agNULL,
                                    pDevThread->DevInfo.CurrentAddress.AL_PA,
                                    ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID ,
                                    0,0,0,0,0,0);
                    }
                }
            }
            
        }
        else /* ( Consumer_Index > Producer_Index ) */
        {
            ERQ_Entry = Base_ERQ_Entry + (Consumer_Index -1);
            X_ID = ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID & 0x00007fff;

            if(X_ID < CDBThread_MemoryDescriptor->elements)
            {
                pCDBThread = (CDBThread_t *)((os_bit8 *)(CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                             + (X_ID * CDBThread_MemoryDescriptor->elementSize));

                if (!(pCDBThread->ExchActive))
                {
                    osLogDebugString(hpRoot,
                                CFuncLogConsoleERROR,
                                
                                "Wrap Prior Found a cbdthread that is not active... %x State %d",
                                (char *)agNULL,(char *)agNULL,
                                (os_bit32) pCDBThread,
                                pCDBThread->thread_hdr.currentState,0,0,0,0,0,0);

                     osLogDebugString(hpRoot,
                                CFuncLogConsoleERROR,
                                
                                "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                                (char *)agNULL,(char *)agNULL,
                                pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                                pCDBThread->CDB_CMND_Class,
                                pCDBThread->CDB_CMND_Type,
                                pCDBThread->CDB_CMND_State,
                                pCDBThread->CDB_CMND_Status,
                                0,0,0);
                }
                else
                {
                    pDevThread = pCDBThread->Device; 
                    pCThread->pollingCount--;
                    osLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                
                                "Wrap Prior Device %2X SEST Entry %3X",
                                (char *)agNULL,(char *)agNULL,
                                pDevThread->DevInfo.CurrentAddress.AL_PA,
                                ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID ,
                                0,0,0,0,0,0);
                }
            }


            for(entry = Consumer_Index; entry < Max_ERQ; entry ++)
            {
                ERQ_Entry = Base_ERQ_Entry + entry;
                X_ID = ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID & 0x00007fff;

                if(X_ID < CDBThread_MemoryDescriptor->elements)
                {
                    pCDBThread = (CDBThread_t *)((os_bit8 *)(CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                                 + (X_ID * CDBThread_MemoryDescriptor->elementSize));

                    if (!(pCDBThread->ExchActive))
                    {
                        osLogDebugString(hpRoot,
                                    CFuncLogConsoleERROR,
                                    
                                    "Wrap Found a cbdthread that is not active... %x State %d",
                                    (char *)agNULL,(char *)agNULL,
                                    (os_bit32) pCDBThread,
                                    pCDBThread->thread_hdr.currentState,0,0,0,0,0,0);

                         osLogDebugString(hpRoot,
                                    CFuncLogConsoleERROR,
                                    
                                    "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                                    (char *)agNULL,(char *)agNULL,
                                    pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                                    pCDBThread->CDB_CMND_Class,
                                    pCDBThread->CDB_CMND_Type,
                                    pCDBThread->CDB_CMND_State,
                                    pCDBThread->CDB_CMND_Status,
                                    0,0,0);
                    }
                    else
                    {
                        pDevThread = pCDBThread->Device; 
                        pCThread->pollingCount--;
                        osLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    
                                    "Wrap Device %2X SEST Entry %3X",
                                    (char *)agNULL,(char *)agNULL,
                                    pDevThread->DevInfo.CurrentAddress.AL_PA,
                                    ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID ,
                                    0,0,0,0,0,0);
                    }
                }
            }

            for(entry = 0; entry < Producer_Index; entry ++)
            {
                ERQ_Entry = Base_ERQ_Entry + entry;
                X_ID = ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID & 0x00007fff;

                if(X_ID < CDBThread_MemoryDescriptor->elements)
                {
                    pCDBThread = (CDBThread_t *)((os_bit8 *)(CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                                 + (X_ID * CDBThread_MemoryDescriptor->elementSize));

                    if (!(pCDBThread->ExchActive))
                    {
                        osLogDebugString(hpRoot,
                                    CFuncLogConsoleERROR,
                                    
                                    "Wrap Found a cbdthread that is not active... %x State %d",
                                    (char *)agNULL,(char *)agNULL,
                                    (os_bit32) pCDBThread,
                                    pCDBThread->thread_hdr.currentState,0,0,0,0,0,0);

                         osLogDebugString(hpRoot,
                                    CFuncLogConsoleERROR,
                                    
                                    "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                                    (char *)agNULL,(char *)agNULL,
                                    pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                                    pCDBThread->CDB_CMND_Class,
                                    pCDBThread->CDB_CMND_Type,
                                    pCDBThread->CDB_CMND_State,
                                    pCDBThread->CDB_CMND_Status,
                                    0,0,0);
                    }
                    else
                    {
                        pDevThread = pCDBThread->Device; 
                        pCThread->pollingCount--;
                        osLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    
                                    "Wrap Device %2X SEST Entry %3X",
                                    (char *)agNULL,(char *)agNULL,
                                    pDevThread->DevInfo.CurrentAddress.AL_PA,
                                    ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID ,
                                    0,0,0,0,0,0);
                    }
                }
            }
        }
    }
}

void CFunc_Check_ERQ_Registers( agRoot_t *hpRoot )
{
    CThread_t                  * pCThread= CThread_ptr(hpRoot);
    IRB_t                      * Base_ERQ_Entry;
    IRB_t                      * ERQ_Entry;
    X_ID_t                       X_ID;
    DevThread_t                * pDevThread;
    CDBThread_t                * pCDBThread;
    fiMemMapMemoryDescriptor_t * CDBThread_MemoryDescriptor = &pCThread->Calculation.MemoryLayout.CDBThread;
    fiMemMapMemoryDescriptor_t * ERQ_MemoryDescriptor = &pCThread->Calculation.MemoryLayout.ERQ;

    USE_t                     *SEST;

    os_bit32 Producer_Index;
    os_bit32 Consumer_Index;
    os_bit32 entry ;

    os_bit32 Max_ERQ = pCThread->Calculation.MemoryLayout.ERQ.elements - 1;

return;
    Producer_Index = osChipIOLoReadBit32(hpRoot, ChipIOLo_ERQ_Producer_Index);
    Consumer_Index = osChipIOLoReadBit32(hpRoot, ChipIOLo_ERQ_Consumer_Index);

    if(pCThread->Calculation.MemoryLayout.ERQ.memLoc == inDmaMemory)
    {
        Base_ERQ_Entry = (IRB_t  *)pCThread->Calculation.MemoryLayout.ERQ.addr.DmaMemory.dmaMemoryPtr;
        osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    
                    "Base_ERQ_Entry %08X P %4X  C %4X",
                    (char *)agNULL,(char *)agNULL,
                    (os_bit32)Base_ERQ_Entry,
                    Producer_Index,
                    Consumer_Index,
                    0,0,0,0,0);
    }
            
    for(entry = 0; entry < ERQ_MemoryDescriptor->elements; entry ++)
    {
        ERQ_Entry = Base_ERQ_Entry + entry;

        X_ID = ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID & 0x00007fff;

        if(X_ID < CDBThread_MemoryDescriptor->elements)
        {
            pCDBThread = (CDBThread_t *)((os_bit8 *)(CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                         + (X_ID * CDBThread_MemoryDescriptor->elementSize));

            if (!(pCDBThread->ExchActive))
            {

/*
                osLogDebugString(hpRoot,
                            CFuncLogConsoleERROR,
                            
                            "Less Found a cbdthread that is not active... %x State %d",
                            (char *)agNULL,(char *)agNULL,
                            (os_bit32) pCDBThread,
                            pCDBThread->thread_hdr.currentState,0,0,0,0,0,0);

                 osLogDebugString(hpRoot,
                            CFuncLogConsoleERROR,
                            
                            "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                            (char *)agNULL,(char *)agNULL,
                            pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                            pCDBThread->CDB_CMND_Class,
                            pCDBThread->CDB_CMND_Type,
                            pCDBThread->CDB_CMND_State,
                            pCDBThread->CDB_CMND_Status,
                            0,0,0);
*/
            }
            else
            {
                SEST = (USE_t *)pCDBThread->SEST_Ptr;
                pDevThread = pCDBThread->Device; 
                pCThread->pollingCount--;

                 osLogDebugString(hpRoot,
                            CFuncLogConsoleERROR,
                            
                            "F %x Send %x TO %x A3 %x A2 %x A1 %x A0 %x A login %x",
                            (char *)agNULL,(char *)agNULL,
                            fiListElementOnList(&pCThread->Free_CDBLink,       &pCDBThread->CDBLink),
                            fiListElementOnList(&pDevThread->Send_IO_CDBLink,  &pCDBThread->CDBLink),
                            fiListElementOnList(&pDevThread->TimedOut_CDBLink, &pCDBThread->CDBLink),
                            fiListElementOnList(&pDevThread->Active_CDBLink_3, &pCDBThread->CDBLink),
                            fiListElementOnList(&pDevThread->Active_CDBLink_2, &pCDBThread->CDBLink),
                            fiListElementOnList(&pDevThread->Active_CDBLink_1, &pCDBThread->CDBLink),
                            fiListElementOnList(&pDevThread->Active_CDBLink_0, &pCDBThread->CDBLink),
                            fiListElementOnList(&pDevThread->Awaiting_Login_CDBLink,&pCDBThread->CDBLink) );

                pCDBThread->TimeStamp = 0;

                if(! fiListElementOnList(&pDevThread->Awaiting_Login_CDBLink,&pCDBThread->CDBLink) )
                {
                    fiListDequeueThis( &pCDBThread->CDBLink );

                    fiListEnqueueAtHead( &pCDBThread->CDBLink, &(pDevThread->Awaiting_Login_CDBLink) );
                }



                osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            
                            "ERQ %X Device %2X %08X CCnt %x SEST Entry %3X Bits %08X State %d",
                            (char *)agNULL,(char *)agNULL,
                            entry,
                            pDevThread->DevInfo.CurrentAddress.AL_PA,
                            pCDBThread->CDBStartTimeBase.Lo,
                            pCThread->pollingCount,
                            ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID,
                            pCDBThread->SEST_Ptr->USE.Bits,
                            pCDBThread->thread_hdr.currentState,
                            0);
                osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            
                            "Sest DWORD 7 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                            (char *)agNULL,(char *)agNULL,
                            SEST->Unused_DWord_7,
                            SEST->Unused_DWord_8,
                            SEST->Unused_DWord_9,
                            SEST->First_SG.U32_Len,
                            SEST->First_SG.L32,
                            SEST->Second_SG.U32_Len,
                            SEST->Second_SG.L32,
                            SEST->Third_SG.U32_Len);


            }
        }
    }

}


#endif /* SkipThisStuff  */

osGLOBAL void osLogString(
                           agRoot_t *agRoot,
                           char     *formatString,
                           char     *firstString,
                           char     *secondString,
                           void     *firstPtr,
                           void     *secondPtr,
                           os_bit32  firstBit32,
                           os_bit32  secondBit32,
                           os_bit32  thirdBit32,
                           os_bit32  fourthBit32,
                           os_bit32  fifthBit32,
                           os_bit32  sixthBit32,
                           os_bit32  seventhBit32,
                           os_bit32  eighthBit32
                         )
{
}


#ifdef OBSOLETE_FUNCTIONS 
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/CSTEST.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 7/20/00 2:33p   $

Purpose:

  This file implements Initialize functions called by the FC Layer Card
  State Machine.

--*/

#include <stdio.h>
#include <stdlib.h>
#include "../h/globals.h"
#include "../h/fcstruct.h"
#include "../h/state.h"

#include "../h/tlstruct.h"
#include "../h/memmap.h"
#include "../h/fcmain.h"
#include "../h/linksvc.h"
#include "../h/cmntrans.h"
#include "../h/sf_fcp.h"
#include "../h/flashsvc.h"
#include "../h/timersvc.h"

#include "../h/cstate.h"
#include "../h/cfunc.h"
#include "../h/devstate.h"
#include "../h/cdbstate.h"
#include "../h/sfstate.h"
#include "../h/tgtstate.h"

#include "../h/queue.h"
#include "../h/cdbsetup.h"


#ifndef __State_Force_Static_State_Tables__
extern actionUpdate_t noActionUpdate;
#endif /* __State_Force_Static_State_Tables__ was not defined */

extern os_bit8 Alpa_Index[256];

agBOOLEAN CFuncInitFM_Clear_FM( agRoot_t *hpRoot )
{
    CThread_t  * pCThread = CThread_ptr(hpRoot);
    agFCChanInfo_t *Self_info = &(pCThread->ChanInfo);
    os_bit32 stall_count = 0;
    os_bit32 FM_Status = 0;
#ifdef NPORT_STUFF
    os_bit32 Acquired_Alpa = 0xFF;
#else /* NPORT_STUFF */
    os_bit32 Acquired_Alpa = 0;
#endif /* NPORT_STUFF */

    os_bit32 Received_ALPA = 0;

    FC_Port_ID_t    Port_ID;

    os_bit32 Frame_Manager_Config =0;

#ifdef NPORT_STUFF
    /* If we are trying to connect to an NPort, Check the Port State Machine
     * to be active. The ALPA in this case is Zero. Note: This is the only place
     * that the check is made to determine if the link is UP or not.
     */
    if (pCThread->InitAsNport)
    {
        FM_Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );
        

        if( (FM_Status & ChipIOUp_Frame_Manager_Status_PSM_MASK) ==
                                 ChipIOUp_Frame_Manager_Status_PSM_ACTIVE )
        {
            pCThread->ChanInfo.CurrentAddress.AL_PA = 0;

            Port_ID.Struct_Form.Domain = pCThread->ChanInfo.CurrentAddress.Domain;
            Port_ID.Struct_Form.Area   = pCThread->ChanInfo.CurrentAddress.Area;
            Port_ID.Struct_Form.AL_PA  = pCThread->ChanInfo.CurrentAddress.AL_PA;

            if (FM_Status & ChipIOUp_Frame_Manager_Status_LF ||
                    FM_Status & ChipIOUp_Frame_Manager_Status_OLS)
            {
                    osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "Detected NOS/OLS or Link Failure %08X FM Config %08X ALPA %08X",
                            (char *)agNULL,(char *)agNULL,
                            agNULL,agNULL,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                            osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                            0,0,0,0,0);

                    /* Since we are not going to be polling and reading the IMQ, we better
                       clear the FM status register so that when we do read the frame manager
                       as a result of the interrupt, we do not process this LF or OLS again.
                     */

                    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, (ChipIOUp_Frame_Manager_Status_LF | ChipIOUp_Frame_Manager_Status_OLS));
                    
           }


            Received_ALPA = (( Acquired_Alpa &
                            ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK) >>
                       ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_SHIFT);

            pCThread->DeviceSelf =  DevThreadAlloc( hpRoot,Port_ID );
            osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Clear FM DevSelf %x FM_Status %x",
                    (char *)agNULL,(char *)agNULL,
                    agNULL,agNULL,
                    (os_bit32)Self_info->CurrentAddress.AL_PA,
                    FM_Status,
                    0,
                    0,0,0,0,0);

            pCThread->DeviceSelf->DevSlot = DevThreadFindSlot(hpRoot,
                                                      Self_info->CurrentAddress.Domain,
                                                      Self_info->CurrentAddress.Area,
                                                      Self_info->CurrentAddress.AL_PA,
                                                      (FC_Port_Name_t *)(&Self_info->PortWWN));

            fiListDequeueThis(&(pCThread->DeviceSelf->DevLink));
            fiListEnqueueAtTail(&(pCThread->DeviceSelf->DevLink),&pCThread->DevSelf_NameServer_DevLink);

            return (agTRUE);
        }

        return (agFALSE);
    }

#endif /* NPORT_STUFF */

    if( CFuncClearFrameManager( hpRoot,&Acquired_Alpa ))
    {
        Received_ALPA = (( Acquired_Alpa &
                       ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK) >>
                       ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_SHIFT);

        if(Received_ALPA != 0  &&  Received_ALPA != 0xFF )
        {
            /* Write aquired AL_PA */
            osLogDebugString(hpRoot,
                        CFuncLogConsoleERROR,
                        "Clear FM Failed Self ALPA %x  Received_ALPA %x Acquired_Alpa %08X",
                        (char *)agNULL,(char *)agNULL,
                        agNULL,agNULL,
                        (os_bit32)Self_info->CurrentAddress.AL_PA,
                        Received_ALPA,
                        Acquired_Alpa,
                        0,0,0,0,0);

            osChipIOUpWriteBit32( hpRoot, ChipIOUp_My_ID, Received_ALPA);
        }

        if( pCThread->LOOP_DOWN )
        {
            if( CFuncLoopDownPoll(hpRoot))
            {
                osLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "%s NOT %s  ...Failed",
                                "CFuncInitFM_ClearFM","CFuncLoopDownPoll",
                                (void *)agNULL,(void *)agNULL,
                                0,0,0,0,0,0,0,0);

                return agFALSE;
            }

        }

    }

#ifdef OSLayer_Stub

    Port_ID.Struct_Form.Domain = pCThread->ChanInfo.CurrentAddress.Domain;
    Port_ID.Struct_Form.Area   = pCThread->ChanInfo.CurrentAddress.Area;
    Port_ID.Struct_Form.AL_PA  = 0xEF;
    pCThread->DeviceSelf = DevThreadAlloc( hpRoot,Port_ID );

    fiListDequeueThis(&(pCThread->DeviceSelf->DevLink));
    fiListEnqueueAtTail(&(pCThread->DeviceSelf->DevLink),&pCThread->DevSelf_NameServer_DevLink);


#else /* OSLayer_Stub */


    Port_ID.Struct_Form.Domain = pCThread->ChanInfo.CurrentAddress.Domain;
    Port_ID.Struct_Form.Area   = pCThread->ChanInfo.CurrentAddress.Area;
    Port_ID.Struct_Form.AL_PA  = pCThread->ChanInfo.CurrentAddress.AL_PA;

    Received_ALPA = (( Acquired_Alpa &
                       ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK) >>
                       ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_SHIFT);


     osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Clear FM OK  Self_info AL_PA %x Received_ALPA %x Acquired_Alpa %08X Port ID %08X",
                    (char *)agNULL,(char *)agNULL,
                    agNULL,agNULL,
                    (os_bit32)Self_info->CurrentAddress.AL_PA,
                    Received_ALPA,
                    Acquired_Alpa,
                    Port_ID.Bit32_Form,
                    0,0,0,0);



    if(Received_ALPA == 0)
    {
#ifdef NPORT_STUFF
        /* When we first initialize as LPORT when really connected to
         * the NPORT, we get here and bail out.
         */
#endif /* NPORT_STUFF */
/*        return agFALSE;*/
    }

    pCThread->DeviceSelf = DevThreadAlloc( hpRoot,Port_ID );
    fiListDequeueThis(&(pCThread->DeviceSelf->DevLink));
    fiListEnqueueAtTail(&(pCThread->DeviceSelf->DevLink),&pCThread->DevSelf_NameServer_DevLink);


#ifdef _BYPASSLOOPMAP
    Frame_Manager_Config |= ChipIOUp_Frame_Manager_Configuration_BLM;
#endif /* _BYPASSLOOPMAP */

#endif  /* OSLayer_Stub */

    Frame_Manager_Config |= (Received_ALPA <<
                            ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT);


    if( Received_ALPA == 0xFF || pCThread->DeviceSelf == ( DevThread_t *)agNULL  )
    {
        osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "(%p)Received_ALPA  %08X or pCThread->DeviceSelf == agNULL %p",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,pCThread->DeviceSelf,
                    Received_ALPA,
                    0,0,0,0,0,0,0);

            return agFALSE;
    }


    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration, Frame_Manager_Config | ChipIOUp_Frame_Manager_Configuration_AQ);

    osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "hpRoot %p Frame Manager Status %08X Thread %p SELF AL_PA %X A %08X B %08X ",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,pCThread->DeviceSelf,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status),
                    Received_ALPA,
                    Frame_Manager_Config,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0,0);



    pCThread->DeviceSelf->DevSlot = DevThreadFindSlot(hpRoot,
                                                      Self_info->CurrentAddress.Domain,
                                                      Self_info->CurrentAddress.Area,
                                                      Self_info->CurrentAddress.AL_PA,
                                                      (FC_Port_Name_t *)(&Self_info->PortWWN));

    fiListDequeueThis(&(pCThread->DeviceSelf->DevLink));
    fiListEnqueueAtTail(&(pCThread->DeviceSelf->DevLink),&pCThread->DevSelf_NameServer_DevLink);

    /* Write aquired AL_PA */
    osChipIOUpWriteBit32( hpRoot, ChipIOUp_My_ID, pCThread->ChanInfo.CurrentAddress.AL_PA);

    osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "A * Self ALPA %x  Received_ALPA %x Acquired_Alpa %08X Info Alpa %x FM cfg %08X",
                    (char *)agNULL,(char *)agNULL,
                    agNULL,agNULL,
                    (os_bit32)Self_info->CurrentAddress.AL_PA,
                    Received_ALPA,
                    Acquired_Alpa,
                    pCThread->ChanInfo.CurrentAddress.AL_PA,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0);


    return agTRUE;



}


void CFuncInitFM_Initialize( agRoot_t *hpRoot )
{
    CThread_t  * pCThread = CThread_ptr(hpRoot);

    agFCChanInfo_t *Self_info = &(pCThread->ChanInfo);

    /* Frame Manager Initialize */

    osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Frame Manager Initialize FM Cfg %08X FM Stat %08X  TL Stat %08X Self ALPA %x",
                    (char *)agNULL,(char *)agNULL,
                    agNULL,agNULL,
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Configuration),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    (os_bit32)Self_info->CurrentAddress.AL_PA,
                    0,0,0,0);

    osChipIOUpWriteBit32( hpRoot,ChipIOUp_Frame_Manager_Status, osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ));

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control, ChipIOUp_Frame_Manager_Control_CMD_Initialize );

}



agBOOLEAN CFuncInitFM( agRoot_t *hpRoot ){
    CThread_t  * pCThread = CThread_ptr(hpRoot);
    agFCChanInfo_t *Self_info = &(pCThread->ChanInfo);
    os_bit32 stall_count = 0;
    os_bit32 FM_Status = 0;
    os_bit32 Acquired_Alpa = 0;
    os_bit32 Received_ALPA = 0;
    FC_Port_ID_t    Port_ID;

    os_bit32 Init_FM_Value = 0;
    os_bit32 Frame_Manager_Config =0;

    CFuncGetHaInfoFromNVR(hpRoot);
    fiLinkSvcInit(hpRoot);

    osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "CFuncInitFM Frame Manager Status %08X",
                    (char *)agNULL,(char *)agNULL,
                    agNULL,agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status),
                    0,0,0,0,0,0,0);

    osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "%s HA %x CA %x",
                    "CFuncInitFM",(char *)agNULL,
                    agNULL,agNULL,
                    (os_bit32)(Self_info->HardAddress.AL_PA),
                    (os_bit32)(Self_info->CurrentAddress.AL_PA),
                    0,0,0,0,0,0);


    if (Self_info->CurrentAddress.AL_PA == fiFlash_Card_Unassigned_Loop_Address)
    {
#ifdef _BYPASSLOOPMAP
        if(pCThread->PreviouslyAquiredALPA)
        {
        Init_FM_Value = (  ChipIOUp_Frame_Manager_Configuration_AQ  |
                           ChipIOUp_Frame_Manager_Configuration_BLM |
                           ( ((os_bit32)(Self_info->HardAddress.AL_PA))
                              << ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ) ); 
        }
        else
        {
        Init_FM_Value = (  ChipIOUp_Frame_Manager_Configuration_SA  |
                           ChipIOUp_Frame_Manager_Configuration_BLM |
                           ( ((os_bit32)(Self_info->HardAddress.AL_PA))
                              << ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ) ); 
        }
#else /* _BYPASSLOOPMAP */
        if(pCThread->PreviouslyAquiredALPA)
        {
        Init_FM_Value  = ChipIOUp_Frame_Manager_Configuration_AQ    |
                           ( ((os_bit32)(Self_info->HardAddress.AL_PA))
                              << ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ) ); 
        }
        else
        {
        Init_FM_Value  = ChipIOUp_Frame_Manager_Configuration_SA    |
                           ( ((os_bit32)(Self_info->HardAddress.AL_PA))
                              << ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ) ); 
        }
#endif /* _BYPASSLOOPMAP */

        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration, Init_FM_Value );

        osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "A %s Frame Manager Configuration %08X",
                    "CFuncInitFM",(char *)agNULL,
                    agNULL,agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration),
                    0,0,0,0,0,0,0);

    }
    else /* Self_info->CurrentAddress.AL_PA != fiFlash_Card_Unassigned_Loop_Address */
    {

#ifdef _BYPASSLOOPMAP
        Init_FM_Value = (  ChipIOUp_Frame_Manager_Configuration_HA  |
                           ChipIOUp_Frame_Manager_Configuration_BLM );
#else /* _BYPASSLOOPMAP */
        Init_FM_Value  = ChipIOUp_Frame_Manager_Configuration_HA;
#endif /* _BYPASSLOOPMAP */
        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration,
                             (  ( ((os_bit32)(Self_info->CurrentAddress.AL_PA))
                                  << ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ) |
                                     Init_FM_Value                                        ) );
        osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "B %s Frame Manager Configuration %08X",
                    "CFuncInitFM",(char *)agNULL,
                    agNULL,agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration),
                    0,0,0,0,0,0,0);

    }

    /* Frame Manager WWN */

    CFuncDisable_Interrupts(hpRoot,ChipIOUp_INTEN_INT);

    osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Writing High WWN %08X to %X",
                    (char *)agNULL,(char *)agNULL,
                    agNULL,agNULL,
                    hpSwapBit32(*(os_bit32*) &(Self_info->PortWWN[0])),
                    ChipIOUp_Frame_Manager_World_Wide_Name_High,
                    0,0,0,0,0,0);


    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_World_Wide_Name_High, hpSwapBit32(*(os_bit32*) &(Self_info->PortWWN[0])));

    osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Writing Low  WWN %08X to %X",
                    (char *)agNULL,(char *)agNULL,
                    agNULL,agNULL,
                    hpSwapBit32(*(os_bit32*)&(Self_info->PortWWN[4])),
                    ChipIOUp_Frame_Manager_World_Wide_Name_Low,
                    0,0,0,0,0,0);


    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_World_Wide_Name_Low, hpSwapBit32(*(os_bit32*) &(Self_info->PortWWN[4])));

    /* Frame Manager Initialize */

    osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Frame Manager Initialize FM Cfg %08X FM Stat %08X  TL Stat %08X Self ALPA %x",
                    (char *)agNULL,(char *)agNULL,
                    agNULL,agNULL,
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Configuration),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    (os_bit32)Self_info->CurrentAddress.AL_PA,
                    0,0,0,0);

    osChipIOUpWriteBit32( hpRoot,ChipIOUp_Frame_Manager_Status, osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ));

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control, ChipIOUp_Frame_Manager_Control_CMD_Initialize );

    /* Wait for Initialize to complete */

#ifndef OSLayer_Stub

    for( stall_count=0; stall_count < 1000; stall_count++)
    {
        osStallThread(hpRoot,100);
    }

    osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Init FM LARGE TIME DELAY !!!",
                    (char *)agNULL,(char *)agNULL,
                    agNULL,agNULL,
                    0,0,0,0,0,0,0,0);
/**/
    if( CFuncClearFrameManager( hpRoot,&Acquired_Alpa ))
    {

        Received_ALPA = (( Acquired_Alpa &
                           ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK) >>
                           ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_SHIFT);

        if(Received_ALPA != 0  &&  Received_ALPA != 0xFF )
        {

        /* Write aquired AL_PA */
        osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Clear FM Failed Self ALPA %x  Received_ALPA %x Acquired_Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    agNULL,agNULL,
                    (os_bit32)Self_info->CurrentAddress.AL_PA,
                    Received_ALPA,
                    Acquired_Alpa,
                    0,0,0,0,0);


        osChipIOUpWriteBit32( hpRoot, ChipIOUp_My_ID, Received_ALPA);

        }
        if( pCThread->LOOP_DOWN )
        {
            if( CFuncLoopDownPoll(hpRoot))
            {

                osLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    "%s %s Failed",
                                    "CFuncInitFM","CFuncLoopDownPoll",
                                    (void *)agNULL,(void *)agNULL,
                                    0,0,0,0,0,0,0,0);
                return agFALSE;
            }

        }

    }
#endif  /* OSLayer_Stub */
    /* MULTI for( stall_count=0; stall_count < 10000; stall_count++)
                        osStallThread(hpRoot,100);
    */

    /* Get aquired AL_PA */


#ifdef OSLayer_Stub

    Port_ID.Struct_Form.Domain = pCThread->ChanInfo.CurrentAddress.Domain;
    Port_ID.Struct_Form.Area   = pCThread->ChanInfo.CurrentAddress.Area;
    Port_ID.Struct_Form.AL_PA  = pCThread->ChanInfo.CurrentAddress.AL_PA;
    pCThread->DeviceSelf = DevThreadAlloc( hpRoot,Port_ID );
    fiListDequeueThis(&(pCThread->DeviceSelf->DevLink));
    fiListEnqueueAtTail(&(pCThread->DeviceSelf->DevLink),&pCThread->DevSelf_NameServer_DevLink);

#else /* OSLayer_Stub */


    Received_ALPA = (( Acquired_Alpa &
                       ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK) >>
                       ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_SHIFT);

    osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Clear FM OK  Self_info AL_PA %x Received_ALPA %x Acquired_Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    agNULL,agNULL,
                    (os_bit32)Self_info->CurrentAddress.AL_PA,
                    Received_ALPA,
                    Acquired_Alpa,
                    0,0,0,0,0);



    if(Received_ALPA == 0)
    {
        osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "%s %s Failed",
                            "CFuncInitFM","Received_ALPA 0",
                            (void *)agNULL,(void *)agNULL,
                            0,0,0,0,0,0,0,0);

        return agFALSE;
    }

    Port_ID.Struct_Form.Domain = 0;
    Port_ID.Struct_Form.Area   = 0;
    Port_ID.Struct_Form.AL_PA  = (os_bit8)Received_ALPA;
    pCThread->DeviceSelf = DevThreadAlloc( hpRoot,Port_ID );
    fiListDequeueThis(&(pCThread->DeviceSelf->DevLink));
    fiListEnqueueAtTail(&(pCThread->DeviceSelf->DevLink),&pCThread->DevSelf_NameServer_DevLink);

    osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Set Self %p Domain %x Area %x AL_PA %x",
                    (char *)agNULL,(char *)agNULL,
                    pCThread->DeviceSelf,agNULL,
                    Port_ID.Struct_Form.Domain,
                    Port_ID.Struct_Form.Area,
                    Port_ID.Struct_Form.AL_PA,
                    0,0,0,0,0);


#ifdef _BYPASSLOOPMAP
    Frame_Manager_Config |= ChipIOUp_Frame_Manager_Configuration_BLM;
#endif /* _BYPASSLOOPMAP */

#endif  /* OSLayer_Stub */

    Frame_Manager_Config |= (Received_ALPA <<
                            ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT);


    if( Received_ALPA == 0xFF || pCThread->DeviceSelf == (DevThread_t *)agNULL  )
    {
        osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "(%p)Received_ALPA  %08X or pCThread->DeviceSelf == agNULL %p",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,pCThread->DeviceSelf,
                    Received_ALPA,
                    0,0,0,0,0,0,0);

            return agFALSE;
    }


    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration,
                           ( ChipIOUp_Frame_Manager_Configuration_BLM |
                             ChipIOUp_Frame_Manager_Configuration_AQ  |
                             Frame_Manager_Config                       ));

    osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "hpRoot %p Frame Manager Status %08X Thread %p SELF AL_PA %X A %08X B %08X ",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,pCThread->DeviceSelf,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status),
                    Received_ALPA,
                    Frame_Manager_Config,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0,0);



    pCThread->DeviceSelf->DevSlot = DevThreadFindSlot(hpRoot,
                                                      Self_info->CurrentAddress.Domain,
                                                      Self_info->CurrentAddress.Area,
                                                      (os_bit8)Received_ALPA,
                                                      (FC_Port_Name_t *)(&Self_info->PortWWN));

    fiListDequeueThis(&(pCThread->DeviceSelf->DevLink));
    fiListEnqueueAtTail(&(pCThread->DeviceSelf->DevLink),&pCThread->DevSelf_NameServer_DevLink);

    /* Write aquired AL_PA */
    osChipIOUpWriteBit32( hpRoot, ChipIOUp_My_ID, pCThread->ChanInfo.CurrentAddress.AL_PA);

    osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "* Self ALPA %x  Received_ALPA %x Acquired_Alpa %08X Info Alpa %x FM cfg %08X",
                    (char *)agNULL,(char *)agNULL,
                    agNULL,agNULL,
                    (os_bit32)Self_info->CurrentAddress.AL_PA,
                    Received_ALPA,
                    Acquired_Alpa,
                    pCThread->ChanInfo.CurrentAddress.AL_PA,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0);


    return agTRUE;

}

agBOOLEAN  CFuncClearFrameManager( agRoot_t *hpRoot, os_bit32 * Acquired_Alpa )
{
    /* Returns True if  a problem was detected  */
    CThread_t  * pCThread = CThread_ptr(hpRoot);

    os_bit32 FM_Status;
    os_bit32 State_ON_entry    = pCThread->thread_hdr.currentState;
    os_bit32 ALPA              =   0xff;
    agBOOLEAN Received_ALPA = agFALSE;

    FM_Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );
    FM_Status &= ~ChipIOUp_Frame_Manager_Status_OLS;
    FM_Status &= ~ChipIOUp_Frame_Manager_Status_BA;
    /* If Loss of Sync is detected, just bail out */
    if (FM_Status & ChipIOUp_Frame_Manager_Status_LS)
    {
       osLogDebugString(hpRoot,
            CStateLogConsoleERROR,
            "Detected Loss of Sync  %08X FM Config %08X ALPA %08X",
            (char *)agNULL,(char *)agNULL,
            (void *)agNULL,(void *)agNULL,
            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
            0,0,0,0,0,0,0);

       return agTRUE;
    }  
    /* If the loop circuit has been established and the frame manager is
       participating, get the ALPA */

    if( FM_Status & ChipIOUp_Frame_Manager_Status_LP &&
        !( FM_Status & ChipIOUp_Frame_Manager_Status_NP    ))
    {
        ALPA =  osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA )  &
                      ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK;
        * Acquired_Alpa = ALPA;
        ALPA = ALPA >>  ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_SHIFT;
        pCThread->ChanInfo.CurrentAddress.AL_PA = (os_bit8)ALPA;
        Received_ALPA = agTRUE;
    }
    else
    {
        osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Can't Acquire ALPA FM Status %08X FM Config %08X ALPA %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0,0);
    }

#ifdef AUTO_DETECT_NPORT
#ifdef NPORT_STUFF

    /* Need to remove the LF check once Tachlite gets its act together
     * and makes sure only the NOS/OLS is set when connected to an
     * NPORT and not the LF bit. LF bit should be used truely for
     * Link failures.
     */
    if (FM_Status & ChipIOUp_Frame_Manager_Status_LF ||
        FM_Status & ChipIOUp_Frame_Manager_Status_OLS)
    {
        osLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "Detected NOS/OLS or Link Failure %08X FM Config %08X ALPA %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                0,0,0,0,0);

        /* Since we are not going to be polling and reading the IMQ, we better
           clear the FM status register so that when we do read the frame manager
           as a result of the interrupt, we do not process this LF or OS again.
         */

        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, (ChipIOUp_Frame_Manager_Status_LF | ChipIOUp_Frame_Manager_Status_OLS));
        pCThread->InitAsNport = agTRUE;
        return agFALSE;
    }

#endif  /* NPORT_STUFF */
#endif /* AUTODETECT NPORT */
    if(FM_Status == ChipIOUp_Frame_Manager_Status_LP)
    {
        osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "(%p)CFuncClearFrameManager Good FM Status %08X FM Config %08X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0,0,0,0);

      osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "TL Status %08X TL Control %08X Alpa %08X Acq %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    * Acquired_Alpa,
                    0,0,0,0);

    return(agFALSE);
    }

    osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "(%p)In CFuncClearFrameManager FM Status %08X FM Config %08X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0,0,0,0);

    osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "TL Status %08X TL Control %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0,0);

    while(FM_Status != ChipIOUp_Frame_Manager_Status_LP)
    {
        if( pCThread->thread_hdr.currentState == CStateLIPEventStorm         ||
            pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm   ) return(agTRUE);

        if ( FM_Status & ChipIOUp_Frame_Manager_Status_OS )
        {
            osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "%s Out of Sync FM Status %08X FM Config %08X",
                    "CFuncClearFrameManager",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0,0,0,0);
            return(agTRUE);
        }


        if( FM_Status & ChipIOUp_Frame_Manager_Status_LS )
        {
            osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "%s Loss of SIGNAL FM Status %08X FM Config %08X",
                    "CFuncClearFrameManager",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0,0,0,0);
            return(agTRUE);
        }


        pCThread->FM_pollingCount = 1;
        if(CFuncInterruptPoll( hpRoot,&pCThread->FM_pollingCount ))
        {
            osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0);

            FM_Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );

            if( FM_Status & ChipIOUp_Frame_Manager_Status_LP &&
                !(FM_Status & ChipIOUp_Frame_Manager_Status_NP  ))
            {
                if( ! ( * Acquired_Alpa & ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK) )
                {

                    ALPA =  osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA )  &
                                 ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK;
                    /* * Acquired_Alpa = ALPA; */
                    ALPA = ALPA >>  ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_SHIFT;
                    pCThread->ChanInfo.CurrentAddress.AL_PA = (os_bit8)ALPA;
                    Received_ALPA = agTRUE;
                }
            }
            else
            {
                osLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "Can't Acquire ALPA FM Status %08X FM Config %08X ALPA %08X",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                                osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                                0,0,0,0,0);
            }

            return(agTRUE);
        }


        FM_Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );


        if( (FM_Status & ChipIOUp_Frame_Manager_Status_LSM_MASK) ==
                                 ChipIOUp_Frame_Manager_Status_LSM_Loop_Fail )
        {
            osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "LSM Loop Fail FM Status %08X FM Config %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0,0,0,0);

            osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Loop Fail TL Status %08X TL Control %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0,0);
            return(agTRUE);
        }

        if( State_ON_entry != pCThread->thread_hdr.currentState )
        {
            osLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "%s NOT %s  ...Failed",
                                "State_ON_entry","currentState",
                                (void *)agNULL,(void *)agNULL,
                                0,0,0,0,0,0,0,0);

            return(agTRUE);
        }

    }

    FM_Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );

    if( FM_Status & ChipIOUp_Frame_Manager_Status_LP &&
        FM_Status & ~ChipIOUp_Frame_Manager_Status_NP    )
    {
        if( ! ( * Acquired_Alpa & ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK) )
        {
            ALPA =  osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA )  &
                           ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK;
            /* * Acquired_Alpa = ALPA; */
            ALPA = ALPA >>  ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_SHIFT;
            pCThread->ChanInfo.CurrentAddress.AL_PA = (os_bit8)ALPA;
            Received_ALPA = agTRUE;
        }
    }
    else
    {
        osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "Can't Acquire ALPA FM Status %08X FM Config %08X ALPA %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                            osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                            0,0,0,0,0);
    }


    ALPA =  osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA )  &
                   ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK;

    ALPA = ALPA >>  ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_SHIFT;
    if(ALPA)
    {
            pCThread->ChanInfo.CurrentAddress.AL_PA = (os_bit8)ALPA;
            /* * Acquired_Alpa = ALPA; */
            Received_ALPA = agTRUE;
    }
    osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "(%p)Out CFuncClearFrameManager Loop Good FM Status %08X FM Config %08X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0,0,0,0);

    osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "TL Status %08X TL Control %08X Rec Alpa %08X Acq %08X Received_ALPA %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    * Acquired_Alpa,
                    Received_ALPA,
                    0,0,0);

    return(! Received_ALPA);
}

void CFuncFMCompletion(agRoot_t * hpRoot)
{
    os_bit32 fmStatus;
    agBOOLEAN ResetLOOP       = agFALSE;
    agBOOLEAN LOOP_Cameback   = agFALSE;
    agBOOLEAN Credit_Error    = agFALSE;

    os_bit32 FMIntStatus;
    os_bit32 LoopStatus;
    os_bit32 LoopStateMachine;

    os_bit32 ClearInt = 0;
    os_bit32 BadAL_PA = 0;
    os_bit32 Link_UP_AL_PA = 0;
    FC_Port_ID_t    Port_ID;
    CThread_t         *pCThread = CThread_ptr(hpRoot);
/*
    DevThread_t       *pDevThread;
*/
    SFThread_t        *pSFThread;
    fiList_t      * pList;
    fiList_t      * pDevList;

    pCThread->From_IMQ_Frame_Manager_Status = fmStatus = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );

#ifdef NPORT_STUFF
    if (pCThread->InitAsNport)
    {
        CFuncProcessNportFMCompletion(hpRoot, fmStatus);

        return;
    }
#endif /* NPORT_STUFF */

    /* From here on, We are probably in a Loop topology */

    LoopStatus  = fmStatus & 0xFF000000;

    FMIntStatus  = fmStatus & 0x00FFFF00;

    LoopStateMachine = fmStatus & ChipIOUp_Frame_Manager_Status_LSM_MASK;

    if(LoopStateMachine < 80 )
    {

        if(FMIntStatus & ChipIOUp_Frame_Manager_Status_LUP || FMIntStatus & ChipIOUp_Frame_Manager_Status_LDN)
        {
            Link_UP_AL_PA = ((osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA )  &
                                              ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK) >>
                                               ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_SHIFT);

            if(  Link_UP_AL_PA !=  pCThread->ChanInfo.CurrentAddress.AL_PA)
            {
                osLogDebugString(hpRoot,
                                CFuncLogConsoleERROR,
                                "G F * Self ALPA %x  FM cfg %08X",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                pCThread->ChanInfo.CurrentAddress.AL_PA,
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                                0,0,0,0,0,0);
            }
        }
    }

    /* Take care of the NOS/OLS. We shouldn't be getting this if we are not
     * in an NPort mode but the fabric may have not yet transitioned....
     */

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_OLS)
    {

        /* osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, FMIntStatus); */

        /* Take the Cthread to ResetIfNeeded State waiting for the Reinit during the
         * the timer tick.
         */
#ifndef DONT_ACT_ON_OLS
        if(pCThread->thread_hdr.currentState == CStateInitializeFailed)
        {
            pCThread->NOS_DetectedInIMQ++;
            FMIntStatus &= ~ChipIOUp_Frame_Manager_Status_OLS;
            osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, FMIntStatus);
            return;
        }
        else
        {
//#ifdef DONT_ACT_ON_OLS
            if(pCThread->thread_hdr.currentState != CStateInitFM_DelayDone &&
               pCThread->thread_hdr.currentState != CStateInitFM    )
            {
                if(pCThread->thread_hdr.currentState == CStateLoopFailedReInit)
                {
                   ClearInt |= ChipIOUp_Frame_Manager_Status_OLS;
                }
                else
                {
                    if(pCThread->thread_hdr.currentState == CStateResetNeeded)
                    {
                       ClearInt |= ChipIOUp_Frame_Manager_Status_OLS;
                    }
                    else
                    {

                        osLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    "hpRoot(%p) LOOP OLS/NOS received CState %d",
                                    (char *)agNULL,(char *)agNULL,
                                    hpRoot,agNULL,
                                    pCThread->thread_hdr.currentState,
                                    0,0,0,0,0,0,0);

                        osLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                     "hpRoot(%p) OLS/NOS Reinit the loop, Loop_Reset_Event_to_Send %d",
                                    (char *)agNULL,(char *)agNULL,
                                    hpRoot,agNULL,
                                    pCThread->Loop_Reset_Event_to_Send,
                                    0,0,0,0,0,0,0);
                        /*
                        pCThread->Loop_Reset_Event_to_Send = CEventLoopNeedsReinit;
                        fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventAsyncLoopEventDetected);
                        */
                        FMIntStatus &= ~ChipIOUp_Frame_Manager_Status_OLS;
                        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, FMIntStatus);
                        pCThread->Loop_Reset_Event_to_Send = CEventLoopNeedsReinit;
                        fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventLoopNeedsReinit);
                        return;
                    }
                }
            }
#endif /* DONT_ACT_ON_OLS */
        }

       ResetLOOP=agTRUE;
 
       ClearInt |= ChipIOUp_Frame_Manager_Status_OLS;
    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_LF)
    {

        if( pCThread->Link_Failures_In_tick < FC_MAX_LINK_FAILURES_ALLOWED )
        {
            ClearInt |= ChipIOUp_Frame_Manager_Status_LF ;

            if( ! pCThread->Link_Failures_In_tick )
            {
                osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Link Failure LSM %X FMIntStatus %X",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,FMIntStatus,0,0,0,0,0,0);
            }

            pCThread->Link_Failures_In_tick++;
        }
        else
        {

            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ) )
            {
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventElasticStoreEventStorm);
            }

            ResetLOOP=agFALSE;

        }

    }


    if(LoopStatus & ChipIOUp_Frame_Manager_Status_LP )
    {

        ClearInt |= ChipIOUp_Frame_Manager_Status_LP;

        osLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "hpRoot(%p) Loop Good LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,
                    0,0,0,0,0,0,0);
    }

    if(LoopStatus & ChipIOUp_Frame_Manager_Status_TP )
    {
        if( pCThread->Transmit_PE_In_tick < FC_MAX_TRANSMIT_PE_ALLOWED )
        {
            ResetLOOP=agTRUE;
            ClearInt |=  ChipIOUp_Frame_Manager_Status_TP ;
            if( ! pCThread->Transmit_PE_In_tick )
            {
                osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Transmit PE LSM %X",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,0,0,0,0,0,0,0);
            }

            pCThread->Transmit_PE_In_tick++;
        }
        else
        {
            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ) )
            {
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventElasticStoreEventStorm);
            }

            ResetLOOP=agFALSE;

        }
    }

    if(LoopStatus & ChipIOUp_Frame_Manager_Status_NP )
    {
        ClearInt |= ChipIOUp_Frame_Manager_Status_NP;
        ResetLOOP=agTRUE;
        osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p)fmStatus %08X Non Particapating LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    fmStatus,
                    LoopStateMachine,
                    0,0,0,0,0,0);
    }

    if(LoopStatus & ChipIOUp_Frame_Manager_Status_BYP)
    {
        if( pCThread->Node_By_Passed_In_tick < FC_MAX_NODE_BY_PASSED_ALLOWED )
        {
            ClearInt |= ChipIOUp_Frame_Manager_Status_BYP;
            ResetLOOP=agTRUE;
            if( ! pCThread->Node_By_Passed_In_tick )
            {
                osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Node Bypassed LSM %X",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,0,0,0,0,0,0,0);
            }

            pCThread->Node_By_Passed_In_tick++;
        }
        else
        {

            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ) )
            {
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventElasticStoreEventStorm);
            }

            ResetLOOP=agFALSE;

        }

    }

    if(LoopStatus & ChipIOUp_Frame_Manager_Status_FLT)
    {
        if( pCThread->Lost_sync_In_tick < FC_MAX_LINK_FAULTS_ALLOWED )
        {
            ClearInt |=  ChipIOUp_Frame_Manager_Status_FLT;
            ResetLOOP=agTRUE;
            if( ! pCThread->Link_Fault_In_tick )
            {
                osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Link Fault LSM %X",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,0,0,0,0,0,0,0);
            }

            pCThread->Link_Fault_In_tick++;
        }
        else
        {

            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ) )
            {
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventElasticStoreEventStorm);
            }

            ResetLOOP=agFALSE;

        }

    }
    if(LoopStatus & ChipIOUp_Frame_Manager_Status_OS )
    {

        if( pCThread->Lost_sync_In_tick < FC_MAX_LOSE_OF_SYNC_ALLOWED )
        {
            ClearInt |=  ChipIOUp_Frame_Manager_Status_OS;
            ResetLOOP=agTRUE;
            if( ! pCThread->Lost_sync_In_tick )
            {
                osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Loop Out of Sync LSM %X",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,0,0,0,0,0,0,0);
            }

            pCThread->Lost_sync_In_tick++;
        }
        else
        {

            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ) )
            {
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventElasticStoreEventStorm);
            }
            ResetLOOP=agFALSE;

        }


    }

    if(LoopStatus & ChipIOUp_Frame_Manager_Status_LS )
    {

        if( pCThread->Lost_Signal_In_tick < FC_MAX_LOST_SIGNALS_ALLOWED )
        {
            ClearInt |=  ChipIOUp_Frame_Manager_Status_LS;
            ResetLOOP=agTRUE;
            if( ! pCThread->Lost_Signal_In_tick )
            {
                osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Loop Lost Signal LSM %X",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,0,0,0,0,0,0,0);
            }

            pCThread->Lost_Signal_In_tick++;
        }
        else
        {

            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ) )
            {
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventElasticStoreEventStorm);
            }
            ResetLOOP=agFALSE;

        }


    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_LPE)
    {
        /* ResetLOOP=agTRUE; */
        /* Ignore LPE */
        ClearInt |=ChipIOUp_Frame_Manager_Status_LPE;
        osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) LPE received LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,0,0,0,0,0,0,0);
    }


    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_LPB)
    {
        ClearInt |= ChipIOUp_Frame_Manager_Status_LPB;
        osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Loop ByPass Primitive received LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,0,0,0,0,0,0,0);
    }


    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_LST)
    {
        pCThread->Loop_State_TimeOut_In_tick++;
        ClearInt |= ChipIOUp_Frame_Manager_Status_LST;
        if( pCThread->Loop_State_TimeOut_In_tick < FC_MAX_LST_ALLOWED )/* Always zero */
        {
            if( ! pCThread->Loop_State_TimeOut_In_tick )
            {
                osLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "hpRoot(%p) Loop State Timeout received LSM %X Cstate %d FMIntStatus %X TL Status %08X",
                                (char *)agNULL,(char *)agNULL,
                                hpRoot,agNULL,
                                LoopStateMachine,
                                pCThread->thread_hdr.currentState,
                                FMIntStatus,
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                                0,0,0,0);
            }

        }
        else
        {
            /* ResetLOOP = agTRUE; */
            osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "Loop State Timeout Cstate %d FMIntStatus %X TL Status %08X LST count %d",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCThread->thread_hdr.currentState,
                            FMIntStatus,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                            pCThread->Loop_State_TimeOut_In_tick,
                            0,0,0,0);

            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ))
            {
                if( pCThread->thread_hdr.currentState == CStateNormal  )
                {
                    pCThread->Loop_Reset_Event_to_Send = CEventInitalizeFailure;
                    fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventLoopEventDetected);
                }
                else
                {
                    if( pCThread->thread_hdr.currentState == CStateInitializeFailed  )
                    {
                        ResetLOOP=agFALSE;
                    }
                    else
                    {
                        fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventElasticStoreEventStorm);
                        return;
                    }
                }
            }
            else
            {
                ResetLOOP=agFALSE;
            }
        }
    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_LPF)
    {
        ResetLOOP=agTRUE;
        if( pCThread->Lip_F7_In_tick < FC_MAX_LIP_F7_ALLOWED )
        {
            if( ! pCThread->Lip_F7_In_tick )
            {
                osLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "hpRoot(%p) LIPf received LSM %X Rec ALPA Reg %08X Cstate %d FMIntStatus %X",
                                (char *)agNULL,(char *)agNULL,
                                hpRoot,agNULL,
                                LoopStateMachine,
                                osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                                pCThread->thread_hdr.currentState,
                                FMIntStatus,0,0,0,0);
            }

            if( 0xF7 ==  (osChipIOUpReadBit32(hpRoot,
                                            ChipIOUp_Frame_Manager_Received_ALPA) &
                                  ChipIOUp_Frame_Manager_Received_ALPA_LIPf_ALPA_MASK ))
            {
                ClearInt |= ChipIOUp_Frame_Manager_Status_LPF;
            }

            ClearInt |= ChipIOUp_Frame_Manager_Status_LPF;

            pCThread->Lip_F7_In_tick++;
        }
        else
        {

            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateInitFM_DelayDone        ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ) )
            {
                    osLogDebugString(hpRoot,
                                    CFuncCheckCstateErrorLevel,
                                    "%s sends %s FM_Status %08X FM_IMQ_Status %08X ",
                                    "CFuncFMCompletion","CEventLIPEventStorm",
                                    (void *)agNULL,(void *)agNULL,
                                    FMIntStatus,
                                    pCThread->From_IMQ_Frame_Manager_Status,
                                    0,0,0,0,0,0);

                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventLIPEventStorm);
            }

            ResetLOOP=agFALSE;
        }

    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_BA)
    {
        ClearInt |= ChipIOUp_Frame_Manager_Status_BA;

#ifdef DONT_USE_THIS_ANYMORE
        ClearInt |= ChipIOUp_Frame_Manager_Status_BA;
        BadAL_PA = (osChipIOUpReadBit32(hpRoot,
                            ChipIOUp_Frame_Manager_Received_ALPA)  >>
                            ChipIOUp_Frame_Manager_Received_ALPA_Bad_ALPA_SHIFT) &
                            0xFF;

        if(BadAL_PA )
        {

            osLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "hpRoot(%p) Bad ALPA received %8X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    BadAL_PA,
                    0,0,0,0,0,0,0);

            pDevThread = CFuncMatchALPAtoThread( hpRoot,
                                           (os_bit32)BadAL_PA);
            if(pDevThread != (DevThread_t *)agNULL )
            {
#ifdef MYLEXFAILOVER
                if(pCThread->thread_hdr.currentState == CStateNormal)
                {
                   osFCLayerAsyncEvent( hpRoot, osFCLinkBadALPAFailover );
                }
#endif /* MYLEXFAILOVER */
                if(pDevThread->thread_hdr.currentState == DevStateDoPlogi  )
                {
                    pSFThread = pDevThread->SFThread_Request.SFThread;

                    osLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "pSFThread %p Bad AL_PA",
                        (char *)agNULL,(char *)agNULL,
                        pSFThread,agNULL,
                        0,0,0,0,0,0,0,0);

                    if ((pCThread->DEVID == ChipConfig_DEVID_TachyonTL) && (pCThread->REVID < ChipConfig_REVID_2_2))
                    {
                        fiSendEvent(&pSFThread->thread_hdr,SFEventPlogiBadALPA);
                    }
                }
                else
                {
                ResetLOOP=agTRUE;
                }
            }
            else
            {
                osLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "hpRoot(%p)DevThread agNULL ! Really Bad ALPA received %X",
                                (char *)agNULL,(char *)agNULL,
                                hpRoot,agNULL,
                                BadAL_PA,
                                0,0,0,0,0,0,0);
            }
        }
        else
        {
            /* Flogi Type */

            if(pCThread->thread_hdr.currentState == CStateDoFlogi  )
            {

                if ((pCThread->DEVID == ChipConfig_DEVID_TachyonTL) && (pCThread->REVID < ChipConfig_REVID_2_2))
                {

                    pSFThread = pCThread->Calculation.MemoryLayout.SFThread.addr.CachedMemory.cachedMemoryPtr;
                    fiSendEvent(&pSFThread->thread_hdr,SFEventFlogiBadALPA);
                }
            }
            else
            {


                pDevThread = CFuncMatchALPAtoThread( hpRoot,
                                               (os_bit32)BadAL_PA);
                if(pDevThread != (DevThread_t *)agNULL )
                {
                    osLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    "hpRoot(%p)DevThread %p ! Really Bad ALPA received %X",
                                    (char *)agNULL,(char *)agNULL,
                                    pDevThread,hpRoot,
                                    BadAL_PA,
                                    0,0,0,0,0,0,0);

                }
                else
                {
                    osLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    "hpRoot(%p)DevThread agNULL ! Really Bad ALPA received %X",
                                    (char *)agNULL,(char *)agNULL,
                                    hpRoot,agNULL,
                                    BadAL_PA,
                                    0,0,0,0,0,0,0);
                }
                ResetLOOP=agTRUE;
            }
        }
#endif /* DONT_USE_THIS_ANYMORE */
    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_PRX)
    {
        ClearInt |= ChipIOUp_Frame_Manager_Status_PRX;

        pCThread->PrimitiveReceived = agTRUE;

        osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Primitive received LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,0,0,0,0,0,0,0);
    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_PTX)
    {
        ClearInt |= ChipIOUp_Frame_Manager_Status_PTX;
        osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Primitive Sent LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,0,0,0,0,0,0,0);
    }


    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_LG)
    {
        pCThread->FabricLoginRequired = agTRUE;
        ClearInt |= ChipIOUp_Frame_Manager_Status_LG ;
        osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) FLOGi Required LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,0,0,0,0,0,0,0);

        if (!(FMIntStatus & ~ChipIOUp_Frame_Manager_Status_LG))
        {
            /* We are not acting on this since it is not a reliable mechanism
             * of detecting a fabric yet.
             */
           osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status,ClearInt);
           return;
        }
    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_CE)
    {
        Credit_Error = agTRUE;
        ResetLOOP=agTRUE;
        ClearInt |= ChipIOUp_Frame_Manager_Status_CE;
        osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Credit Error (BB) LSM %X FMIntStatus %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,FMIntStatus,0,0,0,0,0,0);
    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_EW)
    {
        if( pCThread->Elastic_Store_ERROR_Count < FC_MAX_ELASTIC_STORE_ERRORS_ALLOWED )
        {
            ClearInt |= ChipIOUp_Frame_Manager_Status_EW;
            pCThread->Elastic_Store_ERROR_Count++;
        }
        else
        {
            osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Elastic Store Error LSM %X FMIntStatus %X Cstate %d Count %x",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,FMIntStatus,
                    pCThread->thread_hdr.currentState,
                    pCThread->Elastic_Store_ERROR_Count,0,0,0,0);

            if(!(pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm   ||
                 pCThread->thread_hdr.currentState == CStateInitializeFailed         ||
                 pCThread->thread_hdr.currentState == CStateSendPrimitive                ))
            {

                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventElasticStoreEventStorm);
    
                ResetLOOP=agTRUE;

                pCThread->Elastic_Store_ERROR_Count=0;
            }

        }

    }

    if( FMIntStatus & ChipIOUp_Frame_Manager_Status_LDN )
    {
        pCThread->LOOP_DOWN = agTRUE;
        pCThread->ChanInfo.LinkUp = agFALSE;
        pCThread->IDLE_RECEIVED = agFALSE;

#ifdef  USE_ADISC_FOR_RECOVERY 
        osLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "F HostCopy ERQ_PROD %x ERQ Cons %x ",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osChipIOLoReadBit32(hpRoot, ChipIOLo_ERQ_Producer_Index),
                        osChipIOLoReadBit32(hpRoot, ChipIOLo_ERQ_Consumer_Index),
                        0,0,0,0,0,0);
        CFuncShowActiveCDBThreads( hpRoot,ShowERQ);

        osChipIOLoWriteBit32(hpRoot,ChipIOLo_ERQ_Consumer_Index , 
                        osChipIOLoReadBit32(hpRoot,ChipIOLo_ERQ_Producer_Index ));

/*
        CFunc_Check_ERQ_Registers( hpRoot );
*/
#endif /* USE_ADISC_FOR_RECOVERY  */

        ResetLOOP = agTRUE; /* If this is not here after a lip we will not be logged in */

        ClearInt |= ChipIOUp_Frame_Manager_Status_LDN;

        osLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) Link Down LSM %X Cstate %d CDBCnt %x",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        LoopStateMachine,
                        pCThread->thread_hdr.currentState,
                        pCThread->CDBpollingCount,
                        0,0,0,0,0);

        pCThread->LinkDownTime = pCThread->TimeBase;

        osLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "TimeBase %8X %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCThread->TimeBase.Hi,
                        pCThread->TimeBase.Lo,
                        0,0,0,0,0,0);

    }

    if( FMIntStatus & ChipIOUp_Frame_Manager_Status_LUP )
    {
        LOOP_Cameback = agTRUE;
        ResetLOOP = agTRUE; /* If this is not here after a lip we will not be logged in */
        ClearInt |= ChipIOUp_Frame_Manager_Status_LUP;
        osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Link Up LSM %X Cstate %d LD %x IR %x CDBCnt %x",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,
                            pCThread->thread_hdr.currentState,
                            pCThread->LOOP_DOWN,
                            pCThread->IDLE_RECEIVED,
                            pCThread->CDBpollingCount,
                            0,0,0);
        if ( pCThread->FM_pollingCount > 0 )  pCThread->FM_pollingCount --;
        pCThread->LOOP_DOWN = agFALSE;
        pCThread->ChanInfo.LinkUp = agTRUE;
/************************************/

        osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Loop Good LSM %X ALPA %x Self ALPA %x CFG %08X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,
                    Link_UP_AL_PA,
                    pCThread->ChanInfo.CurrentAddress.AL_PA,
                    (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ) & 0xFFFFFF) |
                        ( Link_UP_AL_PA <<  ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ),
                    0,0,0,0);

        if(  Link_UP_AL_PA !=  pCThread->ChanInfo.CurrentAddress.AL_PA)
        {

            pCThread->ALPA_Changed_OnLinkEvent = agTRUE;
            if(Link_UP_AL_PA  != 0 || Link_UP_AL_PA != 0xff)
            {
                osChipIOUpWriteBit32( hpRoot, ChipIOUp_My_ID, Link_UP_AL_PA);

                osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration,
                        (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ) & 0xFFFFFF) |
                        ( Link_UP_AL_PA <<  ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ));

                osLogDebugString(hpRoot,
                                CFuncLogConsoleERROR,
                                "AF * Self ALPA %x  FM cfg %08X",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                pCThread->ChanInfo.CurrentAddress.AL_PA,
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                                0,0,0,0,0,0);
                if(pCThread->DeviceSelf != agNULL)
                {

                    osLogDebugString(hpRoot,
                                    CFuncLogConsoleERROR,
                                    "pCThread->DeviceSelf != agNULL Empty ? %x On list ? %x",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    fiListNotEmpty(&pCThread->DevSelf_NameServer_DevLink ),
                                    fiListElementOnList(&(pCThread->DevSelf_NameServer_DevLink), &(pCThread->DeviceSelf->DevLink)), 
                                    0,0,0,0,0,0);

                    if(fiListNotEmpty(&pCThread->DevSelf_NameServer_DevLink ))
                    {
                        fiListDequeueFromHead(&pDevList, &pCThread->DevSelf_NameServer_DevLink );
                    }
                    fiListDequeueThis(&(pCThread->DeviceSelf->DevLink));
                    DevThreadFree(hpRoot,pCThread->DeviceSelf);
                    pCThread->DeviceSelf = agNULL;
                }

                Port_ID.Struct_Form.Domain = 0;
                Port_ID.Struct_Form.Area   = 0;
                Port_ID.Struct_Form.AL_PA  = (os_bit8)Link_UP_AL_PA;

                pCThread->DeviceSelf = DevThreadAlloc( hpRoot,Port_ID );

                pCThread->DeviceSelf->DevSlot = DevThreadFindSlot(hpRoot,
                                                            Port_ID.Struct_Form.Domain,
                                                            Port_ID.Struct_Form.Area,
                                                            Port_ID.Struct_Form.AL_PA,
                                                           (FC_Port_Name_t *)(&pCThread->ChanInfo.PortWWN));

                fiListDequeueThis(&(pCThread->DeviceSelf->DevLink));
                fiListEnqueueAtTail(&(pCThread->DeviceSelf->DevLink),&pCThread->DevSelf_NameServer_DevLink);

                pCThread->ChanInfo.CurrentAddress.AL_PA = Link_UP_AL_PA;

                ResetLOOP=agTRUE;

                osLogDebugString(hpRoot,
                                CFuncLogConsoleERROR,
                                " F * Self ALPA %x  FM cfg %08X",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                pCThread->ChanInfo.CurrentAddress.AL_PA,
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                                0,0,0,0,0,0);

            }
        }

/*****************************************/
        if(pCThread->IDLE_RECEIVED)
        {

            if( CFunc_Always_Enable_Queues(hpRoot ))
            {
                osLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) FM Queues Frozen after enable !",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        0,0,0,0,0,0,0,0);

            }
            else
            {

                pCThread->IDLE_RECEIVED = agFALSE;
                if(fiListNotEmpty(&pCThread->QueueFrozenWaitingSFLink))
                {
                    fiListDequeueFromHeadFast(&pList,
                                        &pCThread->QueueFrozenWaitingSFLink );
                    pSFThread = hpObjectBase(SFThread_t,
                                              SFLink,pList );
                    osLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    "hpRoot(%p) Starting frozen SFThread %p Event %d",
                                    (char *)agNULL,(char *)agNULL,
                                    hpRoot,pSFThread,
                                    pSFThread->QueuedEvent,
                                    0,0,0,0,0,0,0);

                    if(pSFThread->QueuedEvent )
                    {
                        fiSendEvent(&pSFThread->thread_hdr,(event_t)pSFThread->QueuedEvent);
                    }
                }
            }
        }
    }

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status,ClearInt);

    if( pCThread->thread_hdr.currentState == CStateInitFM                   ||
        pCThread->thread_hdr.currentState == CStateInitFM_DelayDone         ||
        pCThread->thread_hdr.currentState == CStateResetNeeded              ||
        pCThread->thread_hdr.currentState == CStateLIPEventStorm            ||
        pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm   ||
        pCThread->thread_hdr.currentState == CStateInitializeFailed         ||
        pCThread->thread_hdr.currentState == CStateReInitFM                 ||
        pCThread->thread_hdr.currentState == CStateSendPrimitive                )
    {

        if( ! ( pCThread->thread_hdr.currentState == CStateInitializeFailed &&
                LOOP_Cameback == agTRUE                                           ))
        {
                ResetLOOP = agFALSE;
        }


    }


    if (ResetLOOP)
    {
        fmStatus = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );

        osLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "About to ResetLOOP FM Status %08X TL Status %08X CState %d",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        fmStatus,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        pCThread->thread_hdr.currentState,
                        0,0,0,0,0);


        if(pCThread->LoopPreviousSuccess)
        {
            if (Credit_Error)
            {
                pCThread->Loop_Reset_Event_to_Send = CEventLoopNeedsReinit;
            }
            else
            {
                pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
            }

        }
        else
        {
            if( CFuncAll_clear( hpRoot ) )
            {
                pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;

                osLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) ResetLOOP LSM %X Cstate %d sends %s (%d)",
                        "CEventLoopNeedsReinit",(char *)agNULL,
                        hpRoot,agNULL,
                        LoopStateMachine,
                        pCThread->thread_hdr.currentState,
                        CEventAsyncLoopEventDetected,0,0,0,0,0);

            }
            else
            {
                if( pCThread->thread_hdr.currentState == CStateLoopFailedReInit )
                {

                    pCThread->Loop_Reset_Event_to_Send = CEventInitalize;
                }
                else
                {
                    /* WAS pCThread->Loop_Reset_Event_to_Send = CEventLoopNeedsReinit; */
                    pCThread->Loop_Reset_Event_to_Send = CEventLoopEventDetected;

                    osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) ResetLOOP LSM %X Cstate %d sends %s (%d)",
                            "CEventLoopNeedsReinit",(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,
                            pCThread->thread_hdr.currentState,
                            CEventLoopNeedsReinit,0,0,0,0,0);
                }
            }
        }

        osLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) ResetLOOP LSM %X Cstate %d sends (%d) Event to send %d",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        LoopStateMachine,
                        pCThread->thread_hdr.currentState,
                        CEventAsyncLoopEventDetected,
                        pCThread->Loop_Reset_Event_to_Send,
                        0,0,0,0);

        fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventAsyncLoopEventDetected);

    }
}

/*CStateDoFlogi               7*/
extern void CActionDoFlogi( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t *hpRoot= thread->hpRoot;
    CThread_t  * pCThread = CThread_ptr( hpRoot);


    SFThread_t  * pSFThread = pCThread->SFThread_Request.SFThread;
    pSFThread->parent.Device= (DevThread_t *)agNULL;

    CFuncYellowLed(thread->hpRoot, agFALSE);

    osLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p Before %s - State = %d",
                    "CActionDoFlogi",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    /* DRL find dev thread*/
    CFuncShowWhereDevThreadsAre( hpRoot);

    fiSetEventRecordNull(eventRecord);

    fiSendEvent(&pSFThread->thread_hdr,SFEventDoFlogi);

    if(CFuncInterruptPoll( hpRoot,&pCThread->FLOGI_pollingCount ))
    {
        osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Flogi Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0);
        osLogString(thread->hpRoot,
                    "DoFLogi TimeOut FMStatus %X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    0,0,0,0,0,0,0);
        if( CFunc_Queues_Frozen(hpRoot ))
        {
            /* WAS */
            fiSetEventRecord(eventRecord,thread,CEventFlogiFail);
        }
        else
        {

            SFThreadFree(thread->hpRoot, & pCThread->SFThread_Request );
            pCThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;
            pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
            fiSetEventRecord(eventRecord,thread,CEventAsyncLoopEventDetected);
        }

    }
    else
    {
        /* SFState is Set in the SF State machine */
        if( pSFThread->thread_hdr.currentState == SFStateFlogiAccept)
        {
            fiSetEventRecord(eventRecord,thread,CEventFlogiSuccess);
        }
        else
        {
            if( pSFThread->thread_hdr.currentState == SFStateFlogiBadALPA )
            {
                osLogString(thread->hpRoot,
                                "Do FLogi Fail Bad ALPA",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                0,0,0,0,0,0,0,0);

                fiSetEventRecord(eventRecord,thread,CEventFlogiFail);
                pCThread->FlogiSucceeded = agFALSE;
                pCThread->DeviceDiscoveryMethod = ScanAllALPAs;
            }
            else
            {

                if( pSFThread->thread_hdr.currentState == SFStateFlogiRej )
                {
                    osLogString(thread->hpRoot,
                                    "Do FLogi Fail %s",
                                    "SFStateFlogiRej",(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    0,0,0,0,0,0,0,0);
                    fiSetEventRecord(eventRecord,thread,CEventFlogiFail);
                    pCThread->FlogiSucceeded = agFALSE;

                    if (pCThread->InitAsNport)
                    {
                       fiSetEventRecord(eventRecord,thread, CEventInitalizeFailure );
                       return;
                    }

                    pCThread->DeviceDiscoveryMethod = ScanAllALPAs;
                }
                else
                {
                    osLogString(thread->hpRoot,
                                    "Do FLogi Failed SFstate %d",
                                    (char *)agNULL,(char *)agNULL,

                                    (void *)agNULL,(void *)agNULL,
                                    (os_bit32)pSFThread->thread_hdr.currentState,
                                    0,0,0,0,0,0,0);
            
                    SFThreadFree(thread->hpRoot, & pCThread->SFThread_Request );
                    pCThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;

                    pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
                    fiSetEventRecord(eventRecord,thread,CEventAsyncLoopEventDetected);
    /*
                  fiSetEventRecord(eventRecord,thread,CEventFlogiFail);
    */                
                }
            }
        }

    }
/*
    CFuncShowWhereDevThreadsAre( hpRoot, agTRUE );
*/
    osLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After  %s - State = %d SFThread %p SFState %d FDcnt %x",
                    "CActionDoFlogi",(char *)agNULL,
                    thread->hpRoot,pSFThread,
                    (os_bit32)thread->currentState,
                    (os_bit32)pSFThread->thread_hdr.currentState,
                    pCThread->FindDEV_pollingCount,
                    0,0,0,0,0);


}


agBOOLEAN CFuncSearchOffCardIMQ( agRoot_t *hpRoot, os_bit32 X_ID  )
{
#ifndef __MemMap_Force_On_Card__
    /*
        Returns agTRUE if X_ID Found agFALSE if not

    */

    CThread_t  * pCThread = CThread_ptr(hpRoot);

    agBOOLEAN Found = agFALSE;

    os_bit32 tempIMQProdIndex;
    os_bit32 tempCMType;

    os_bit32 num_IMQel;
    os_bit32 Sest_Index;

    CM_Unknown_t                * pGenericCM;
    CM_Inbound_FCP_Exchange_t   * pInbound_FCP_Exchange;
    CM_Outbound_t               * pOutbound;
    CM_Inbound_t                * pInbound;

    num_IMQel = pCThread->Calculation.MemoryLayout.IMQ.elements;

    while (tempIMQProdIndex < num_IMQel)
    {
        pGenericCM  = pCThread->Calculation.MemoryLayout.IMQ.addr.DmaMemory.dmaMemoryPtr;
        pGenericCM += tempIMQProdIndex;
        tempCMType  = pGenericCM->INT__CM_Type & CM_Unknown_CM_Type_MASK;
       /*
       ** get the completion message type
       */

        switch (tempCMType) {

            case  CM_Unknown_CM_Type_Inbound_FCP_Exchange:
                    pInbound_FCP_Exchange = (CM_Inbound_FCP_Exchange_t    *)pGenericCM;
                    Sest_Index = pInbound_FCP_Exchange->Bits__SEST_Index & CM_Inbound_FCP_Exchange_SEST_Index_MASK;
                    if( X_ID == Sest_Index)
                    {
                        osLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "%s Inbound_FCP_Exchange IMQ Entry %X",
                                "CFuncSearchOffCardIMQ",(char *)agNULL,
                                agNULL,agNULL,
                                tempIMQProdIndex,
                                0,0,0,0,0,0,0);
                        Found = agTRUE;
                    }
                break;


            case  CM_Unknown_CM_Type_Inbound:
                    pInbound  = ( CM_Inbound_t   *)pGenericCM;
                    Sest_Index = pInbound->SFQ_Prod_Index & CM_Inbound_SFQ_Prod_Index_MASK;

                    if( X_ID == Sest_Index)
                    {

                        osLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "%s Inbound IMQ Entry %X",
                                "CFuncSearchOffCardIMQ",(char *)agNULL,
                                agNULL,agNULL,
                                tempIMQProdIndex,0,0,0,0,0,0,0);
                        Found = agTRUE;
                    }

                    break;

            case  CM_Unknown_CM_Type_Outbound:
                    pOutbound = ( CM_Outbound_t   *)pGenericCM;
                    Sest_Index = pOutbound->Bits__SEST_Index__Trans_ID & CM_Outbound_SEST_Index_MASK;
                    if( X_ID == Sest_Index)
                    {
                        osLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "%s Outbound %08X  %08X %08X %08X IMQ Entry %X",
                                "CFuncSearchOffCardIMQ",(char *)agNULL,
                                agNULL,agNULL,
                                tempIMQProdIndex,0,0,0,0,0,0,0);
                        Found = agTRUE;
                    }
                break;

            case  CM_Unknown_CM_Type_Frame_Manager:
                break;
            case  CM_Unknown_CM_Type_Error_Idle:
                break;
            case  CM_Unknown_CM_Type_ERQ_Frozen:
                break;
            case  CM_Unknown_CM_Type_FCP_Assists_Frozen:
                break;
            case  CM_Unknown_CM_Type_Class_2_Frame_Header:
                break;
            case  CM_Unknown_CM_Type_Class_2_Sequence_Received:
                break;
            default:
                osLogDebugString(hpRoot,
                            CStateLogConsoleLevel,
                            "Unknown IMQ Completion Type %08X %08X %08X %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            tempCMType,
                            pGenericCM->Unused_DWord_1,
                            pGenericCM->Unused_DWord_2,
                            pGenericCM->Unused_DWord_3,
                            pGenericCM->Unused_DWord_4,
                            0,0,0);
            }
            ROLL(tempIMQProdIndex,num_IMQel);
        }

    return (Found);

#endif

}


#endif /* OBSOLETE_FUNCTIONS  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\dbgsport.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Module Name:

    Dbgsport.c

Abstract:

    Use to debug Scsiport Calls

Authors:

    LP - Leopold Purwadihardja

Environment:

    kernel mode only

Version Control Information:

    $Archive: /Drivers/Win2000/Trunk/OSLayer/C/dbgsport.c $

Revision History:

    $Revision: 4 $
    $Date: 10/23/00 5:36p $
    $Modtime:: 10/18/00 $

--*/


#include "buildop.h"       //LP021100 build switches

#include "osflags.h"
#include "hhba5100.ver"

#include "stdarg.h"

#ifdef _DEBUG_SCSIPORT_NOTIFICATION_

/*++

Routine Description:

    For debugging purpose, If enabled, it'll be used to trap all calls to SP
    the call is defined as
    VOID 
    ScsiPortNotification(
    IN SCSI_NOTIFICATION_TYPE NotificationType,
    IN PVOID HwDeviceExtension,
      // Additional parameters, as required by the given NotificationType 
      // for RequestComplete add: 
    IN PSCSI_REQUEST_BLOCK Srb
      // for NextLuRequest add:  
    IN UCHAR PathId, 
    IN UCHAR TargetId, 
    IN UCHAR Lun 
      // for CallEnableInterrupts or CallDisableInterrupts add:  
    IN PHW_INTERRUPT  HwScsiXxxInterruptsCallback
      // for RequestTimerCall add:  
    IN PHW_TIMER  HwScsiTimer,
    IN ULONG MiniportTimerValue
      // for BusChangeDetected add:  
    IN UCHAR PathId
      // for WMIEvent add:  
    IN PVOID WMIEvent,
    IN UCHAR PathID,
      // if PathId != 0xFF also add: 
    IN UCHAR TargetId,
    IN UCHAR Lun
      // for WMIReregister, add: 
    IN UCHAR PathId,
      // if PathId != 0xFF also add: 
    IN UCHAR TargetId
    IN UCHAR Lun

Arguments:

Return Value:
++*/

#undef  ScsiPortNotification                 /* must be undefined, otherwise it'll recurse */
VOID
Local_ScsiPortNotification(
    IN SCSI_NOTIFICATION_TYPE NotificationType,
    IN PVOID HwDeviceExtension,
    ...
    )
{
    va_list           ap;
   
    va_start(ap, HwDeviceExtension);
    switch (NotificationType)
    {
        case NextRequest:
        {
            #ifdef DBGPRINT_IO
            if (gDbgPrintIo & DBGPRINT_SCSIPORT_NextRequest)
            {
                static   count;
                UCHAR    *uptr;
                osDEBUGPRINT((ALWAYS_PRINT, "SPReq(%-4d) %d.%d.%d- NextRequest on %x\n",
                    count++,
                    0,0,0,
                    HwDeviceExtension));
            }
            #endif   
            ScsiPortNotification(NotificationType, HwDeviceExtension);
            break;
        }
           
        case ResetDetected:
        {
            #ifdef DBGPRINT_IO
            if (gDbgPrintIo & DBGPRINT_SCSIPORT_ResetDetected)
            {
                static   count;
                UCHAR    *uptr;
         
                osDEBUGPRINT((ALWAYS_PRINT, "SPRst(%-4d) %d.%d.%d- Reset On %x\n",
                    count++,
                    0,0,0,
                    HwDeviceExtension));
            }
            #endif   
            ScsiPortNotification(NotificationType, HwDeviceExtension);
            break;
        }
        
         
        case RequestComplete:
        {
            PSCSI_REQUEST_BLOCK     pSrb;
      
            pSrb = va_arg(ap, void *);

            #ifdef DBGPRINT_IO
            if (gDbgPrintIo & DBGPRINT_SCSIPORT_RequestComplete)
            {
                static   count;
                UCHAR    *uptr;
         
                osDEBUGPRINT((ALWAYS_PRINT, "SPCom(%-4d) %d.%d.%d-%02x%02x%02x%02x %02x%02x%02x%02x %02x%02x Srb=%x Sta=%x.%x\n",
                    count++,
                    pSrb->PathId,
                    pSrb->TargetId,
                    pSrb->Lun,
                    pSrb->Cdb[0],pSrb->Cdb[1],pSrb->Cdb[2],pSrb->Cdb[3],pSrb->Cdb[4],
                    pSrb->Cdb[5],pSrb->Cdb[6],pSrb->Cdb[7],pSrb->Cdb[8],pSrb->Cdb[9], 
                    pSrb,
                    pSrb->SrbStatus,
                    pSrb->ScsiStatus));
            }
            #endif   
            ScsiPortNotification(NotificationType, HwDeviceExtension, pSrb);
            break;
        }
                 
        case NextLuRequest: 
        {
            UCHAR PathId; 
            UCHAR TargetId; 
            UCHAR Lun;
         
            PathId = va_arg(ap, UCHAR); 
            TargetId = va_arg(ap, UCHAR); 
            Lun = va_arg(ap, UCHAR);
            
            #ifdef DBGPRINT_IO
            if (gDbgPrintIo & DBGPRINT_SCSIPORT_NextLuRequest)
            {
                static   count;
                UCHAR    *uptr;
                osDEBUGPRINT((ALWAYS_PRINT, "SPxLu(%-4d) %d.%d.%d- Next Lu request\n",
                    count++,
                    PathId,
                    TargetId,
                    Lun));
            }
            #endif   
            ScsiPortNotification(NotificationType, HwDeviceExtension, PathId, TargetId, Lun);
            break;
        }
        
          
        case CallEnableInterrupts:
        case CallDisableInterrupts: 
        {
            PHW_INTERRUPT  HwScsiXxxInterruptsCallback;
         
            HwScsiXxxInterruptsCallback = va_arg(ap, PHW_INTERRUPT); 
         
            ScsiPortNotification(NotificationType, HwDeviceExtension, HwScsiXxxInterruptsCallback);
            break;
        }
        
      
        case RequestTimerCall:
        {
            PHW_TIMER  HwScsiTimer;
            ULONG MiniportTimerValue;
   
            HwScsiTimer = va_arg(ap, PHW_TIMER);
            MiniportTimerValue = va_arg(ap, ULONG);
   
            ScsiPortNotification(NotificationType, HwDeviceExtension, HwScsiTimer, MiniportTimerValue);
            break;
        }
      
    #ifdef HP_NT50    
        case BusChangeDetected:
        {
            UCHAR PathId;
         
            PathId = va_arg(ap, UCHAR); 
         
            ScsiPortNotification(NotificationType, HwDeviceExtension, PathId);
         
            break;
        }
        
         
        case WMIEvent:
        {
            PVOID WMIEvent;
            UCHAR PathId;
         
            /* if PathId != 0xFF also add: */
            UCHAR TargetId;
            UCHAR Lun;
         
            WMIEvent = va_arg(ap, PVOID); 
            PathId = va_arg(ap, UCHAR);
            if (PathId != 0xff)
            {
                TargetId = va_arg(ap, UCHAR);
                Lun = va_arg(ap, UCHAR);
                ScsiPortNotification(NotificationType, HwDeviceExtension, PathId, TargetId, Lun);
            }
            else
            {
                ScsiPortNotification(NotificationType, HwDeviceExtension, PathId);
            }
            break;
        }
      
         
        case WMIReregister:
        {
            UCHAR PathId;
            /* if PathId != 0xFF also add: */
            UCHAR TargetId;
            UCHAR Lun;

            PathId = va_arg(ap, UCHAR);
            if (PathId != 0xff)
            {
                TargetId = va_arg(ap, UCHAR);
                Lun = va_arg(ap, UCHAR);
                ScsiPortNotification(NotificationType, HwDeviceExtension, PathId, TargetId, Lun);
            }
            else
            {
                ScsiPortNotification(NotificationType, HwDeviceExtension, PathId);
            }
            break;
        }
      
    #endif
    }
    va_end(ap);
}

#endif



#ifdef _DEBUG_REPORT_LUNS_
void PrintReportLunData(PSCSI_REQUEST_BLOCK pSrb)
{
    UCHAR *ptr;
    ULONG count;

    count = pSrb->DataTransferLength/8;
    ptr = (UCHAR*) pSrb->DataBuffer;
    if (!ptr)
        return;
    osDEBUGPRINT((ALWAYS_PRINT,"PrintReportLunData: Buffer = %x Length = %d\n", ptr, pSrb->DataTransferLength));
            
    for (count = 0; count < pSrb->DataTransferLength/8; count++)
    {
        osDEBUGPRINT((ALWAYS_PRINT,"%02x%02x%02x%02x %02x%02x%02x%02x -",
            ptr[0],ptr[1],ptr[2],ptr[3],ptr[4],ptr[5],ptr[6],ptr[7]));
            ptr += 8;
        if (!(count % 4)) 
            osDEBUGPRINT((ALWAYS_PRINT,"\n"));
            
    }
    osDEBUGPRINT((ALWAYS_PRINT,"\n"));
         
}

#undef ScsiPortCompleteRequest
VOID 
Local_ScsiPortCompleteRequest(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN UCHAR SrbStatus
    )
{
    #ifdef DBGPRINT_IO
    if (gDbgPrintIo & DBGPRINT_SCSIPORT_ScsiportCompleteRequest)
    {
        static   count;
        osDEBUGPRINT((ALWAYS_PRINT, "SPAll(%-4d) %d.%d.%d- ScsiportCompleteRequest status = %xx\n",
            count++,
            PathId,
            TargetId,
            Lun,
            (ULONG) SrbStatus));
    }
    #endif   
   
    ScsiPortCompleteRequest(HwDeviceExtension, PathId, TargetId, Lun, SrbStatus);
    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\devstate.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/DEVSTATE.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 10/27/00 1:15p  $

Purpose:

  This file implements the FC Layer State Machine.

--*/

#ifndef _New_Header_file_Layout_
#include "../h/globals.h"
#include "../h/state.h"

#include "../h/tlstruct.h"
#include "../h/memmap.h"
#include "../h/fcmain.h"

#include "../h/cstate.h"
#include "../h/devstate.h"
#include "../h/cdbstate.h"
#include "../h/sfstate.h"
#include "../h/flashsvc.h"
#include "../h/timersvc.h"
#include "../h/queue.h"
#include "../h/cfunc.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"

#include "tlstruct.h"
#include "memmap.h"
#include "fcmain.h"

#include "cstate.h"
#include "devstate.h"
#include "cdbstate.h"
#include "sfstate.h"
#include "flashsvc.h"
#include "timersvc.h"
#include "queue.h"
#include "cfunc.h"
#endif  /* _New_Header_file_Layout_ */

extern os_bit8 Alpa_Index[256];

stateTransitionMatrix_t DevStateTransitionMatrix = {
    /* Event/State 0        State 1          State 2...             */
    0,0,0,0,0,    0,0,0,0,0,    0,0,0,0,0,    0,0,0,0,0,    0,0,0,0,0,    0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 1 DevEventLogin                                                     */
    DevStateHandleEmpty, DevStateAllocSFThread, DevStateHandleEmpty, DevStateHandleEmpty,DevStateHandleEmpty,
     DevStateHandleEmpty,DevStateHandleEmpty, DevStateHandleEmpty, DevStateHandleEmpty, DevStateHandleEmpty,
      DevStateHandleEmpty, DevStateHandleEmpty, DevStateHandleEmpty, DevStateHandleEmpty, DevStateHandleEmpty,
       DevStateHandleEmpty, DevStateHandleEmpty, DevStateHandleEmpty,DevStateHandleEmpty, DevStateHandleEmpty,
        DevStateHandleEmpty, DevStateHandleEmpty, DevStateHandleEmpty, DevStateHandleEmpty, DevStateHandleEmpty,
         DevStateHandleEmpty, DevStateHandleEmpty, DevStateHandleEmpty, DevStateHandleEmpty, DevStateHandleEmpty,   0,0,0,0,0, 0,0,0,0,0 ,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
         0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 2 DevEventGotSFThread                                                     */
    0,0,DevStateDoPlogi,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                DevStateDoPlogi,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 3 DevEventPlogiSuccess                                                     */
    0,0,0,DevStatePlogiDone,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,   0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 4 DevEventDoPrli                                                     */
    0,0,0,0,DevStateDoPrli, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 5 DevEventPrliSuccess                                                     */
    0,0,0,0,0,
      DevStatePrliDone,0,0,0,0, /* 5 */
        DevStatePrliDone,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,DevStatePrliDone,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 6  DevEventCheckWWN                                                    */
    0,0,0,0,0, 0,DevStateMatchWWN,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 7  DevEventNoMatchWWN                                                    */
    0,0,0,0,0, 0,0,DevStateSlotNew,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 8  DevEventMatchWWN                                                    */
    0,0,0,0,0, 0,0,DevStateSlotKnown,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 9  DevEventAvailable                                                    */
    0,0,0,0,0,
      0,0,0,DevStateHandleAvailable,DevStateHandleAvailable,
        0,0,0,0,0,
          0,0,DevStateHandleAvailable,0,0,
            0,0,0,DevStateHandleAvailable,0,
              0,DevStateHandleAvailable,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 10 a DevEventPlogiFailed*/
    0,0,0,DevStateLoginFailed,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,DevStateLoginFailed, /* 20 */
              0,0,0,0,0, /* 25 */
                0,DevStateLoginFailed,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 11 b DevEventPrliFailed*/
    0,0,0,0,0, DevStateLogout,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0 ,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 12 c DevEventLoggedOut*/
    0,0,0,0,0, 0,0,0,0,0, 0,0,DevStateLoginFailed,0,0, 0,0,0,0,0 ,0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0 ,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 13 d DevEventAllocDeviceResetSoft*/
    0,0,0,0,0,
      0,0,0,0,0,
        DevStateAllocDeviceResetSoft,0,0,0,0,
          0,0,0,0,0,
            DevStateAllocDeviceResetSoft,0,0,0,0,
              0,0,0,DevStateAllocDeviceResetSoft,DevStateAllocDeviceResetSoft,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 14 e DevEventAllocDeviceResetHard */
    0,0,0,0,0,
      0,0,0,0,0,
        DevStateAllocDeviceResetHard,DevStateAllocDeviceResetSoft,0,0,DevStateAllocDeviceResetHard,
          0,0,DevStateAllocDeviceResetHard,0,0,
            DevStateAllocDeviceResetHard,0,0,0,0,
              0,DevStateAllocDeviceResetHard,0,DevStateAllocDeviceResetHard,DevStateAllocDeviceResetHard,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 15 f DevEventDeviceResetHard */
    0,0,0,0,0, 
      0,0,0,0,0, 
        0,0,0,DevStateDeviceResetSoft,0, 
          0,0,0,0,0,
            0,0,0,0,0,
              DevStateDeviceResetSoft,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 16 0x10 DevEventDeviceResetHard */
    0,0,0,0,0, 
      0,0,0,0,0,
        0,0,0,0,DevStateDeviceResetHard,
          0,0,0,0,0,
            0,0,0,0,0,
              DevStateDeviceResetHard,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 17 0x11 DevEventDeviceResetDone */
    0,0,0,0,0, 0,DevStateMatchWWN,0,0,0, 0,0,0,0,0, DevStateDeviceResetDone,DevStateDeviceResetDone,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 18 0x12 DevEventAL_PA_Self_OK   */
    0,0,0,DevStateAL_PA_Self_OK,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,DevStateHandleAvailable,0,
            0,0,0,0,0,
              0,0,DevStateAL_PA_Self_OK,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 19 0x13 DevEventAL_PA_Self_BAD  */
    0,0,0,DevStateAL_PA_Self_BAD,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,DevStateAL_PA_Self_BAD,
            0,0,0,0,0,
              0,0,DevStateAL_PA_Self_BAD,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 20  DevEventDeviceResetDoneFail */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, DevEventDeviceResetDoneFail,DevEventDeviceResetDoneFail,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 21  DevEventAllocAdisc          */
    0,0,0,0,0,  
      0,0,0,0,0, /* 5 */
        DevStateAllocAdisc,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            DevStateAllocAdisc,0,0,0,0, /* 20 */
              0,0,0,DevStateAllocAdisc,DevStateAllocAdisc, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 22  DevEventAdisc   */
    0,0,0,0,0,  
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,DevStateAdisc,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 23  DevEventAdiscDone_OK        */
    0,0,0,0,0,  
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,DevStateAdiscDone_OK,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 24  DevEventAdiscDone_FAIL_No_Device      */
    0,0,0,0,0,  
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,DevStateAdiscDone_FAIL_No_Device,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 25  DevEventDoTickVerifyALPA    */
    0,DevStateTickVerifyALPA,0,0,0,
      0,0,0,0,0,
        DevStateTickVerifyALPA,0,0,0,0,
          0,0,0,DevStateTickVerifyALPA,DevStateTickVerifyALPA,
            0,0,0,0,0,
                DevStateTickVerifyALPA,0,DevStateTickVerifyALPA,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 26  DevEventExternalDeviceReset    */
    0,0,0,0,0,
      0,0,0,0,0,
        DevStateExternalDeviceReset,0,0,0,0,
          0,0,DevStateExternalDeviceReset,0,0,
            0,0,0,0,0,
              0,DevStateExternalDeviceReset,DevStateExternalDeviceReset,DevStateExternalDeviceReset,DevStateExternalDeviceReset,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 27 DevEventTickGotSFThread     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, DevStateTickGotSFThread,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 28 DevEventExternalLogout     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 29 DevEventSendIO     */
    0,0,0,0,0,
      0,0,0,0,0,
        DevState_IO_Ready,DevStateNoDevice,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,DevState_IO_Ready,DevState_FC_TAPE_Recovery,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 30 DevEvent_FC_TAPE_Recovery */
    0,0,0,0,0,
      0,0,0,0,0,
        DevState_FC_TAPE_Recovery,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,DevState_FC_TAPE_Recovery,DevState_FC_TAPE_Recovery,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 31 DevEventAdiscDone_FAIL_ReLogin */
    0,0,0,0,0,  
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,DevStateAdiscDone_FAIL_ReLogin,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0, /* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 32 DevEvent_Device_Gone  */
    0,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,
      DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,
        DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,
          DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,
            DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,
              DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,
                DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,
                  DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,0,
                              0,0,0,0,0,
                                0,0,0,0,0,
                                  0,0,0,0,0,
                                    0,0,0,0,0,
                                      0,0,0,0,0,
                                        0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 33                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 34                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 35                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 36                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 37                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 38                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 39                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 40                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 41                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 42                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 43                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 44                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 45                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 46                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 47                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 48                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 49                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 50                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 51                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 52                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 53                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 54                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 55                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 56                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 57                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 58                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 59                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 60                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 61                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 62                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 63                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 64                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 65                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 66                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 67                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 68                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 69                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 70                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 71                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 72                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 73                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 74                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 75                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 76                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 77                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 78                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 79                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 80                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 81                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 82                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 83                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 84                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 85                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 86                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 87                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 88                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 89                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 90                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 91                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 92                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 93                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 94                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 95                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 96                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 97                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 98                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 99                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 100                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 101                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 102                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 103                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 104                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 105                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 106                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 107                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 108                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 109                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 110                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 111                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 112                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 113                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 114                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 115                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 116                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 117                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 118                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 119                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 120                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 121                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 122                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 123                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 124                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 125                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 126                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 127                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    };

/*
stateTransitionMatrix_t copiedDevStateTransitionMatrix;
*/
stateActionScalar_t DevStateActionScalar = {
    &DevActionConfused,                       /*  0 */
    &DevActionHandleEmpty,                    /*  1 */
    &DevActionAllocSFThread,                  /*  2 */
    &DevActionDoPlogi,                        /*  3 */
    &DevActionPlogiDone,                      /*  4 */
    &DevActionDoPrli,                         /*  5 */
    &DevActionPrliDone,                       /*  6 */
    &DevActionMatchWWN,                       /*  7 */
    &DevActionSlotNew,                        /*  8 */
    &DevActionSlotKnown,                      /*  9 */
    &DevActionAvailable,                      /* 10 */
    &DevActionLoginFailed,                    /* 11 */
    &DevActionLogout,                         /* 12 */
    &DevActionAllocDeviceResetSoft,           /* 13 */
    &DevActionAllocDeviceResetHard,           /* 14 */
    &DevActionDeviceResetSoft,                /* 15 */
    &DevActionDeviceResetHard,                /* 16 */
    &DevActionDeviceResetDone,                /* 17 */
    &DevActionAL_PA_Self_OK,                  /* 18 */
    &DevActionAL_PA_Self_BAD,                 /* 19 */
    &DevActionDeviceResetDoneFAIL,            /* 20 */
    &DevActionAllocAdisc,                     /* 21 */
    &DevActionAdisc,                          /* 22 */
    &DevActionAdiscDone_OK,                   /* 23 */
    &DevActionAdiscDone_FAIL_No_Device,       /* 24 */
    &DevActionTickVerifyALPA,                 /* 25 */
    &DevActionExternalDeviceReset,            /* 26 */
    &DevActionTickGotSFThread,                /* 27 */
    &DevAction_IO_Ready,                      /* 28 */
    &DevAction_FC_TAPE_Recovery,               /* 29 */
    &DevActionAdiscDone_FAIL_ReLogin,         /* 30 */
    &DevActionNoDevice,                       /* 31 */
    &DevActionConfused,
    &DevActionConfused,
    &DevActionConfused,
    &DevActionConfused,
    &DevActionConfused
    };

/* 
stateActionScalar_t copiedDevStateActionScalar;
*/

#define testDevCompareBase 0x00000110

#ifndef __State_Force_Static_State_Tables__
actionUpdate_t DevTestActionUpdate[] = {
                              0,          0,      agNULL,                 agNULL
                     };
#endif /* __State_Force_Static_State_Tables__ was not defined */


#ifndef USESTATEMACROS
/*+
  Function: DevActionConfused
   Purpose: Terminating State for error detection 
 Called By: Any State/Event pair that does not have an assigned action.
            This function is called only in programming error condtions.
     Calls: None
-*/
/* DevStateConfused                      0    */
extern void DevActionConfused( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    DevThread_t     * pDevThread = ( DevThread_t  * )thread;

    fiLogString(thread->hpRoot,
                    "DevActionConfused",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    CFuncWhatStateAreDevThreads( thread->hpRoot );
    fiLogDebugString(thread->hpRoot,
                    DevStateLogErrorLevel,
                    "In %s - State = %d AL_PA %X",
                    "DevActionConfused",
                    (char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: DevActionHandleEmpty
   Purpose: Initial state for devthread. Completes all outstanding IO's on this device.
 Called By: DevEventLogin
     Calls: CFuncCompleteActiveCDBThreadsOnDevice
            DevEventLogin
-*/
/* DevStateHandleEmpty                   1    */
extern void DevActionHandleEmpty( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t     * pDevThread = (DevThread_t     *)thread;

    fiListDequeueThis(&pDevThread->DevLink);
    /*+ Check This DRL  -*/
    if( pDevThread->Plogi_Reason_Code != PLOGI_REASON_DEVICE_LOGIN)
    {
        fiListEnqueueAtTail(&pDevThread->DevLink,
                            &CThread_ptr(thread->hpRoot)->AWaiting_Login_DevLink);
    }
    CFuncCompleteActiveCDBThreadsOnDevice(pDevThread ,osIOAborted,  CDBEventIODeviceReset );

    fiLogDebugString(thread->hpRoot,
                    DevStateLogConsoleLevel,
                    "In %s - State = %d",
                    "DevActionHandleEmpty",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);


    fiSetEventRecord(eventRecord,thread,DevEventLogin);
}

/*+
  Function: DevActionAllocSFThread
   Purpose: Begins login process for devthread. Checks for active device reset. If device reset active
            device reset has failed.
 Called By: DevEventLogin
     Calls: SFThreadFree
            SFThreadAlloc
            DevEventGotSFThread
-*/
/* DevStateAllocSFThread                 2    */
extern void DevActionAllocSFThread( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t     * pDevThread = ( DevThread_t  * )thread;
    SFThread_t      * pSFThread  = pDevThread->SFThread_Request.SFThread;

    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount ++;

    pDevThread->SFThread_Request.eventRecord_to_send.event = DevEventGotSFThread;
    pDevThread->SFThread_Request.eventRecord_to_send.thread = thread;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogConsoleLevel,
                    "In %s - State = %d SF Request State %x",
                    "DevActionAllocSFThread",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pDevThread->SFThread_Request.State,
                    0,0,0,0,0,0);

    if(pSFThread != (SFThread_t *) agNULL)
    {
        if(! fiListElementOnList(  &(pSFThread->SFLink),
                                   &(CThread_ptr(thread->hpRoot)->Free_SFLink)))
        {
            if (pSFThread->thread_hdr.currentState == SFStateDoResetDevice)
            {
                fiLogDebugString(thread->hpRoot,
                    DevStateLogConsoleLevel,
                    "In %s - State = %d Reset had failed, bump reset cnt",
                    "DevActionAllocSFThread",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

                pDevThread->Failed_Reset_Count++;
            }
            

            SFThreadFree( thread->hpRoot, &pDevThread->SFThread_Request );
        }
    }

    if( pDevThread->SFThread_Request.State)
    {
            fiLogString(thread->hpRoot,
                        "In %s - State = %d   ALPA %X  FDCnt %x SFThread req state  %08X Wrong !",
                        "DevActionAllocSFThread",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        fiComputeDevThread_D_ID(pDevThread),
                        CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                        pDevThread->SFThread_Request.State,
                        0,0,0,0);
    }
    fiSetEventRecordNull(eventRecord);
    SFThreadAlloc( thread->hpRoot, & pDevThread->SFThread_Request );

}

/*+
  Function: DevActionDoPlogi
   Purpose: Sends event to sfthread to do PLOGI.
            
 Called By: DevActionAllocSFThread
     Calls: Proccess_IMQ
            SFEventDoPlogi
-*/
/* DevStateDoPlogi                       3    */
extern void DevActionDoPlogi( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;
    SFThread_t   * pSFThread  = pDevThread->SFThread_Request.SFThread;

    pSFThread->parent.Device = pDevThread;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogConsoleLevel,
                    "In %s - State = %d   ALPA %X FDCnt %x",
                    "DevActionDoPlogi",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,0,0,0,0,0);

    CThread_ptr(thread->hpRoot)->FuncPtrs.Proccess_IMQ(thread->hpRoot);

    pSFThread->SF_REJ_RETRY_COUNT =0;

    if( pDevThread->Prev_Active_Device_FLAG == agDevSCSITarget)
    {
        fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleLevelLip,
                    "Previous Login Succsess  NOW relogin State = %d ALPA %X Type %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pDevThread->DevInfo.DeviceType,
                    0,0,0,0,0);
    }

    fiSetEventRecord(eventRecord,&pSFThread->thread_hdr,SFEventDoPlogi);

}

/*+
  Function: DevActionPlogiDone
   Purpose: Successfull PLOGI completion.
            
 Called By: SFActionPlogiAccept,DevEventPlogiSuccess
     Calls: Proccess_IMQ
            SFEventDoPlogi
-*/
/* DevStatePlogiDone                     4    */
extern void DevActionPlogiDone( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t     * pDevThread = ( DevThread_t  * )thread;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogConsoleLevel,
                    "In %s - State = %d ALPA %X FDCnt %x",
                    "DevActionPlogiDone",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,thread,DevEventDoPrli);
}

/*+
  Function: DevActionDoPrli
   Purpose: Sends event to sfthread to do PRLI.
            
 Called By: DevEventDoPrli
     Calls: Proccess_IMQ
            SFEventDoPrli
-*/
/* DevStateDoPrli                        5    */
extern void DevActionDoPrli( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;
    SFThread_t   * pSFThread  = pDevThread->SFThread_Request.SFThread;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogConsoleLevel,
                    "In %s - State = %d  ALPA %X",
                    "DevActionDoPrli",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);

    CThread_ptr(thread->hpRoot)->FuncPtrs.Proccess_IMQ(thread->hpRoot);

    fiSetEventRecordNull(eventRecord);
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPrli);
}

/*+
  Function: DevActionPrliDone
   Purpose: Successfull PRLI completion.
            
 Called By: SFActionPrliAccept,DevEventPrliSuccess
     Calls: Proccess_IMQ
            DevEventCheckWWN
-*/
/* DevStatePrliDone                      6    */
extern void DevActionPrliDone( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;
    SFThread_t * pSFThread = pDevThread->SFThread_Request.SFThread;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogErrorLevel,
                    "In %s - State = %d   ALPA %X FDCnt %x",
                    "DevActionPrliDone",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                    0,0,0,0,0);

    pSFThread->parent.Device = pDevThread;

    pDevThread->Prev_Active_Device_FLAG = pDevThread->DevInfo.DeviceType;

    fiSetEventRecord(eventRecord,thread,DevEventCheckWWN);

}

/*+
  Function: DevActionMatchWWN
   Purpose: Device has been successfuly accessed for login. Now find its slot in handle array.
            
 Called By: DevEventCheckWWN
     Calls: DevThreadFindSlot
            DevEventMatchWWN
-*/
/* DevStateMatchWWN                      7    */
extern void DevActionMatchWWN( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t    * pDevThread = ( DevThread_t  * )thread;
    FC_Port_Name_t * pwwn       = &(pDevThread->DevInfo.PortWWN);

    if(CThread_ptr(thread->hpRoot)->FindDEV_pollingCount) CThread_ptr(thread->hpRoot)->FindDEV_pollingCount --;

    pDevThread->DevSlot = DevThreadFindSlot(thread->hpRoot,
                                            pDevThread->DevInfo.CurrentAddress.Domain,
                                            pDevThread->DevInfo.CurrentAddress.Area,
                                            pDevThread->DevInfo.CurrentAddress.AL_PA,
                                            pwwn);

    fiSetEventRecord(eventRecord,thread,DevEventMatchWWN);

}

/*+
  Function: DevActionSlotNew
   Purpose: Move device linked list to Active_DevLink.
            
 Called By: DevEventMatchWWN
     Calls: DevEventAvailable
            
-*/
/* DevStateSlotNew                       8    */
extern void DevActionSlotNew( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t     * pDevThread = ( DevThread_t  * )thread;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogConsoleLevel,
                    "In %s - State = %d",
                    "DevActionSlotNew",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiListDequeueThis(&pDevThread->DevLink);

    fiListEnqueueAtTail(&pDevThread->DevLink,
                        &CThread_ptr(thread->hpRoot)->Active_DevLink );

    fiSetEventRecord(eventRecord,thread,DevEventAvailable);
}

/*+
  Function: DevActionSlotKnown
   Purpose: Move device linked list to Active_DevLink.
            
 Called By: DevEventMatchWWN
     Calls: DevEventAvailable
            
-*/
/* DevStateSlotKnown                     9    */
extern void DevActionSlotKnown( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t   * pDevThread = (DevThread_t   * )thread;
    CThread_t     * pCThread = CThread_ptr(thread->hpRoot);

    fiLogDebugString(thread->hpRoot,
                    DevStateLogConsoleLevel,
                    "In %s - State = %d",
                    "DevActionSlotKnown",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiListDequeueThis(&pDevThread->DevLink);

    fiListEnqueueAtTail(&pDevThread->DevLink,
                        &pCThread->Active_DevLink );

    fiSetEventRecord(eventRecord,thread,DevEventAvailable);
}

/*+
  Function: DevActionAvailable
   Purpose: Frees any allocated recources. Moves any IO's that were queued during login
            to the send list. This is the end of the successful device discovery proccess.
            
 Called By: DevActionSlotKnown
     Calls: SFThreadFree
-*/
/* DevStateHandleAvailable               10   */
extern void DevActionAvailable( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;
    SFThread_t   * pSFThread  = pDevThread->SFThread_Request.SFThread;

    if(pSFThread != (SFThread_t *) agNULL)
    {
        if(! fiListElementOnList(  &(pSFThread->SFLink),
                                   &(CThread_ptr(thread->hpRoot)->Free_SFLink)))
        {
            SFThreadFree( thread->hpRoot, &pDevThread->SFThread_Request );
        }
    }
    /* else _asm nop; */

    fiLogDebugString(thread->hpRoot,
                    DevStateLogConsoleLevel,
                    "In %s - State = %d",
                    "DevActionAvailable",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);


    if( CFuncShowWhereCDBThreadsAre(thread->hpRoot))
    {
        CFuncWhatStateAreCDBThreads(thread->hpRoot);
    }

    /* Start ADISC  Recovery */

/*
    fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "%s %s %x AL_PA %X",
                    "DevActionAvailable","Awaiting_Login_CDBLink",
                    (void *)agNULL,(void *)agNULL,
                    fiNumElementsOnList(&pDevThread->Awaiting_Login_CDBLink),
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);
*/
    if( fiListNotEmpty(&pDevThread->Awaiting_Login_CDBLink))
    {
        fiListEnqueueListAtTailFast( &(pDevThread->Awaiting_Login_CDBLink), (&pDevThread->Send_IO_CDBLink));
    }

    if( CFuncShowWhereCDBThreadsAre(thread->hpRoot))
    {
        CFuncWhatStateAreCDBThreads(thread->hpRoot);
    }
    /* End ADISC  Recovery */

    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: DevActionLoginFailed
   Purpose: Frees any allocated resources. Completes any queued IOs with failed status. If a device
            was found before with this devthread the login process is repeated once. Otherwise this 
            is the end of the failed device discovery proccess.
            
 Called By: 
     Calls: SFThreadFree
-*/
/* DevStateLoginFailed                   11   */
extern void DevActionLoginFailed( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;
    SFThread_t   * pSFThread  = pDevThread->SFThread_Request.SFThread;

    if(CThread_ptr(thread->hpRoot)->FindDEV_pollingCount) CThread_ptr(thread->hpRoot)->FindDEV_pollingCount --;

    if(pSFThread != (SFThread_t *) agNULL)
    {
        if(! fiListElementOnList(  &(pSFThread->SFLink),
                                   &(CThread_ptr(thread->hpRoot)->Free_SFLink)))
        {
            SFThreadFree( thread->hpRoot, &pDevThread->SFThread_Request );
        }
    }
    /* else _asm nop; */

    fiLogDebugString(thread->hpRoot,
                    DevStateLogConsoleLevel,
                    "In %s - State = %d ALPA %X Type %X",
                    "DevActionLoginFailed",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pDevThread->DevInfo.DeviceType,
                    0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);

    if( pDevThread->Prev_Active_Device_FLAG == agDevSCSITarget )
    {
        fiLogDebugString(thread->hpRoot,
                    DevStateLogErrorLevel,
                    "Previous Login Succsess  NOW FAILED In %s - State = %d ALPA %X type %x",
                    "DevActionLoginFailed",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pDevThread->DevInfo.DeviceType,
                    0,0,0,0,0);


        pDevThread->Prev_Active_Device_FLAG = agFALSE;

        fiListDequeueThis(&pDevThread->DevLink);

        fiListEnqueueAtTail(&pDevThread->DevLink,
                            &CThread_ptr(thread->hpRoot)->Prev_Unknown_Slot_DevLink);

    }
    else
    {

        fiListDequeueThis(&pDevThread->DevLink);

        fiListEnqueueAtTail(&pDevThread->DevLink,
                            &CThread_ptr(thread->hpRoot)->Unknown_Slot_DevLink );
    }

    CFuncCompleteAwaitingLoginCDBThreadsOnDevice(pDevThread ,osIOAborted,  CDBEventIODeviceReset );

}

/*+
  Function: DevActionLogout
   Purpose: Does LOGO to device
 Called By: 
     Calls: Proccess_IMQ
            SFEventDoLogo
-*/
/* DevStateLogout                        12   */
extern void DevActionLogout( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;
    SFThread_t * pSFThread = pDevThread->SFThread_Request.SFThread;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogErrorLevel,
                    "In %s - State = %d",
                    "DevActionLogout",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    CThread_ptr(thread->hpRoot)->FuncPtrs.Proccess_IMQ(thread->hpRoot);

    fiSetEventRecordNull(eventRecord);
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoLogo);
}

/*+
  Function: DevActionAllocDeviceResetSoft
   Purpose: Begins "soft" reset process of PLOGI/Prli. This does not break scsi reserves.
 Called By: 
     Calls: DevEventDeviceResetSoft
            
-*/
/* DevStateAllocDeviceResetSoft               13   */
extern void DevActionAllocDeviceResetSoft( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;

    CThread_ptr(thread->hpRoot)->DEVReset_pollingCount ++;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogErrorLevel,
                    "In %s - State = %d   ALPA %X FDCnt %x",
                    "DevActionAllocDeviceResetSoft",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                    0,0,0,0,0);

    pDevThread->Plogi_Reason_Code = PLOGI_REASON_SOFT_RESET;

    pDevThread->SFThread_Request.eventRecord_to_send.event = DevEventDeviceResetSoft;
    pDevThread->SFThread_Request.eventRecord_to_send.thread = thread;

    fiSetEventRecordNull(eventRecord);

    SFThreadAlloc( thread->hpRoot, & pDevThread->SFThread_Request );

}

/*+
  Function: DevActionAllocDeviceResetSoft
   Purpose: Begins "Hard" reset process of Task managment reset. This does break scsi reserves.
 Called By: 
     Calls: DevEventDeviceResetSoft
            
-*/
/* DevStateAllocDeviceResetHard               14   */
extern void DevActionAllocDeviceResetHard( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;

    CThread_ptr(thread->hpRoot)->DEVReset_pollingCount ++;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogErrorLevel,
                    "In %s - State = %d   ALPA %X FDCnt %x",
                    "DevActionAllocDeviceResetHard",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,0,0,0,0,0);

    pDevThread->SFThread_Request.eventRecord_to_send.event = DevEventDeviceResetHard;
    pDevThread->SFThread_Request.eventRecord_to_send.thread = thread;

    fiSetEventRecordNull(eventRecord);

    SFThreadAlloc( thread->hpRoot, & pDevThread->SFThread_Request );

}

/*+
  Function: DevActionDeviceResetSoft
   Purpose: Does PLOGI for soft reset.
 Called By: 
     Calls: Proccess_IMQ
            SFEventDoPlogi

-*/
/* DevStateDeviceResetSoft               15   */
extern void DevActionDeviceResetSoft( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;
    SFThread_t * pSFThread = pDevThread->SFThread_Request.SFThread;

    pSFThread->parent.Device = pDevThread;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogErrorLevel,
                    "In %s - State = %d   ALPA %X FDCnt %x",
                    "DevActionDeviceResetSoft",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,0,0,0,0,0);

    /*+ Check This DRL Do I need to set plogi type here ? -*/
    CThread_ptr(thread->hpRoot)->FuncPtrs.Proccess_IMQ(thread->hpRoot);

    fiSetEventRecordNull(eventRecord);
    /* Send event to SFthreads */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPlogi);

}

/*+
  Function: DevActionDeviceResetHard
   Purpose: Does hard reset.
 Called By: 
     Calls: Proccess_IMQ
            SFEventDoResetDevice

-*/
/* DevStateDeviceResetHard               16   */
extern void DevActionDeviceResetHard( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;
    SFThread_t * pSFThread = pDevThread->SFThread_Request.SFThread;

    pSFThread->parent.Device = pDevThread;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogErrorLevel,
                    "In %s - State = %d   ALPA %X FDCnt %x",
                    "DevActionDeviceResetHard",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                    0,0,0,0,0);

    CThread_ptr(thread->hpRoot)->FuncPtrs.Proccess_IMQ(thread->hpRoot);

    fiSetEventRecordNull(eventRecord);

    fiSendEvent(&pSFThread->thread_hdr,SFEventDoResetDevice);

}

/*+
  Function: DevActionDeviceResetDone
   Purpose: Completion state for successful device reset. Frees resources. Completes all IO's 
            on device.
 Called By: 
     Calls: CFuncCompleteActiveCDBThreadsOnDevice
            SFThreadFree
            DevEventAvailable
-*/
/* DevStateDeviceResetDone               17   */
extern void DevActionDeviceResetDone( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;
    SFThread_t   * pSFThread  = pDevThread->SFThread_Request.SFThread;
/*
    CDBThread_t * pCDBThread;
    fiList_t      * pCdbList;
*/
    if(CThread_ptr(thread->hpRoot)->DEVReset_pollingCount) CThread_ptr(thread->hpRoot)->DEVReset_pollingCount--;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogErrorLevel,
                    "In %s - State = %d   ALPA %X DevResetCnt %x SFThread %p",
                    "DevActionDeviceResetDone",(char *)agNULL,
                    pSFThread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->DEVReset_pollingCount,
                    0,0,0,0,0);

    CFuncCompleteActiveCDBThreadsOnDevice(pDevThread, osIODevReset, CDBEventIODeviceReset );

    if(pSFThread != (SFThread_t *) agNULL)
    {
        if(! fiListElementOnList(  &(pSFThread->SFLink),
                                   &(CThread_ptr(thread->hpRoot)->Free_SFLink)))
        {
            SFThreadFree( thread->hpRoot, &pDevThread->SFThread_Request );
        }
    }
    /* else _asm nop; */

    pDevThread->Failed_Reset_Count              = 0;
    fiSetEventRecord(eventRecord,thread,DevEventAvailable);


}

/*+
  Function: DevActionAL_PA_Self_OK
   Purpose: Completion state for verifing ALPA successful. Frees resources. 
 Called By: 
     Calls: SFThreadFree
-*/
/* DevStateAL_PA_Self_OK               18   */
extern void DevActionAL_PA_Self_OK( fi_thread__t *thread,eventRecord_t *eventRecord ){
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;
    SFThread_t   * pSFThread  = pDevThread->SFThread_Request.SFThread;

    if(CThread_ptr(thread->hpRoot)->FindDEV_pollingCount) CThread_ptr(thread->hpRoot)->FindDEV_pollingCount --;

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleLevelLip,
                    "In %s - State = %d   ALPA %X FDCnt %x SFThread %p",
                    "DevActionAL_PA_Self_OK",(char *)agNULL,
                    pSFThread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                    0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
    if(pSFThread != (SFThread_t *) agNULL)
    {
        if(! fiListElementOnList(  &(pSFThread->SFLink),
                                   &(CThread_ptr(thread->hpRoot)->Free_SFLink)))
        {
            SFThreadFree( thread->hpRoot, &pDevThread->SFThread_Request );
        }
        else
        {
            fiLogDebugString(thread->hpRoot,
                        DevStateLogErrorLevel,
                        "In %s - State = %d   ALPA %X  FDCnt %x SFThread %p SF on free list Wrong !",
                        "DevActionAL_PA_Self_OK",(char *)agNULL,
                        pSFThread,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        fiComputeDevThread_D_ID(pDevThread),
                        CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                        0,0,0,0,0);

        }

    }
    /* else _asm nop; */
    pDevThread->In_Verify_ALPA_FLAG = agFALSE;

}

/*+
  Function: DevActionAL_PA_Self_BAD
   Purpose: Completion state for verifing ALPA failure. Frees resources. 
 Called By: 
     Calls: SFThreadFree
-*/
/* DevStateAL_PA_Self_BAD               19   */
extern void DevActionAL_PA_Self_BAD( fi_thread__t *thread,eventRecord_t *eventRecord ){
    agRoot_t     * hpRoot     = thread->hpRoot;
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;
    SFThread_t   * pSFThread  = pDevThread->SFThread_Request.SFThread;

    if(CThread_ptr(thread->hpRoot)->FindDEV_pollingCount) CThread_ptr(thread->hpRoot)->FindDEV_pollingCount --;

    fiLogDebugString(hpRoot,
                    DevStateLogErrorLevel,
                    "In %s - State = %d   ALPA %X FDCnt %x SFThread %p",
                    "DevActionAL_PA_Self_BAD",(char *)agNULL,
                    pSFThread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                    0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "%s FM %08X TL status %08X Qf %d",
                    "DevActionAL_PA_Self_BAD",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    CFunc_Queues_Frozen( hpRoot ),
                    0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(hpRoot)->LOOP_DOWN,
                    CThread_ptr(hpRoot)->IDLE_RECEIVED,
                    CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                    CThread_ptr(hpRoot)->ERQ_FROZEN,
                    CThread_ptr(hpRoot)->FCP_FROZEN,
                    CThread_ptr(hpRoot)->ProcessingIMQ,
                    0,0);

    fiSetEventRecordNull(eventRecord);
    if(pSFThread != (SFThread_t *) agNULL)
    {
        if(! fiListElementOnList(  &(pSFThread->SFLink),
                                   &(CThread_ptr(hpRoot)->Free_SFLink)))
        {
            SFThreadFree( hpRoot, &pDevThread->SFThread_Request );
        }
        else
        {
            fiLogDebugString(hpRoot,
                        DevStateLogErrorLevel,
                        "In %s - State = %d   ALPA %X FDCnt %x SFThread %p SF on free list Wrong !",
                        "DevActionAL_PA_Self_BAD",(char *)agNULL,
                        pSFThread,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        fiComputeDevThread_D_ID(pDevThread),
                        CThread_ptr(hpRoot)->FindDEV_pollingCount,
                        0,0,0,0,0);

        }
    }
    /* else _asm nop; */
    CFunc_Always_Enable_Queues(hpRoot);
    pDevThread->In_Verify_ALPA_FLAG = agFALSE;

}

/*+
  Function: DevActionDeviceResetDoneFAIL
   Purpose: Completion state for device reset failure. Frees resources. 
 Called By: 
     Calls: CFuncCompleteActiveCDBThreadsOnDevice
            SFThreadFree
-*/
/* DevStateDeviceResetDoneFAIL               20   */
extern void DevActionDeviceResetDoneFAIL( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;
    SFThread_t   * pSFThread  = pDevThread->SFThread_Request.SFThread;
/*
    CDBThread_t * pCDBThread;
    fiList_t      * pCdbList;
*/

    if(CThread_ptr(thread->hpRoot)->DEVReset_pollingCount) CThread_ptr(thread->hpRoot)->DEVReset_pollingCount--;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogErrorLevel,
                    "In %s - State = %d   ALPA %X FDCnt %x SFThread %p DevCnt %x",
                    "DevActionDeviceResetDoneFAIL",(char *)agNULL,
                    pSFThread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                    CThread_ptr(thread->hpRoot)->DEVReset_pollingCount,
                    0,0,0,0);

    CFuncCompleteActiveCDBThreadsOnDevice(pDevThread, osIODevReset, CDBEventIODeviceReset );

    fiSetEventRecordNull(eventRecord);
    pDevThread->Failed_Reset_Count              = 0;
    if(pSFThread != (SFThread_t *) agNULL)
    {
        if(! fiListElementOnList(  &(pSFThread->SFLink),
                                   &(CThread_ptr(thread->hpRoot)->Free_SFLink)))
        {
            SFThreadFree( thread->hpRoot, &pDevThread->SFThread_Request );
        }
    }
    /* else _asm nop; */

}

/*+
  Function: DevActionAllocAdisc
   Purpose: Begins ADISC recovery process 
 Called By: 
     Calls: SFThreadAlloc
            
-*/
/*  DevStateAllocAdisc              21   */
extern void DevActionAllocAdisc( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;

    CThread_ptr(thread->hpRoot)->ADISC_pollingCount ++;

    fiListEnqueueAtTail(&pDevThread->DevLink,
                        &CThread_ptr(thread->hpRoot)->AWaiting_ADISC_DevLink);

    fiLogDebugString(thread->hpRoot,
                    DevStateLogErrorLevel,
                    "(%p )In %s - State = %d ALPA %X FDCnt %x",
                    "DevActionAllocAdisc",(char *)agNULL,
                    thread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                    0,0,0,0,0);

    pDevThread->SFThread_Request.eventRecord_to_send.event = DevEventAdisc;
    pDevThread->SFThread_Request.eventRecord_to_send.thread = thread;

    fiSetEventRecordNull(eventRecord);

    SFThreadAlloc( thread->hpRoot, & pDevThread->SFThread_Request );

}

/*+
  Function: DevActionAllocAdisc
   Purpose: Sends ADISC recovery process 
 Called By: DevActionAllocAdisc
     Calls: SFEventDoAdisc
            
-*/
/* DevStateAdisc               22   */
extern void DevActionAdisc( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * DevThread = ( DevThread_t  * )thread;
    SFThread_t   * pSFThread = DevThread->SFThread_Request.SFThread;

    pSFThread->parent.Device = DevThread;

    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount ++;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogErrorLevel,
                    "In %s - State = %d ALPA %X  FDCnt %x",
                    "DevActionAdisc",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    DevThread->DevInfo.CurrentAddress.AL_PA,
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,0,0,0,0,0);

    if( CFuncShowWhereCDBThreadsAre(thread->hpRoot))
    {
        CFuncWhatStateAreCDBThreads(thread->hpRoot);
    }

    fiSetEventRecordNull(eventRecord);

    fiSendEvent(&pSFThread->thread_hdr,SFEventDoAdisc);

}

/*+
  Function: DevActionAllocAdisc
   Purpose: Successful ADISC completion 
 Called By: SFActionAdiscAccept,DevEventAdiscDone_OK 
     Calls: DevEventPrliSuccess
            
-*/
/* DevStateAdisc_OK             23   */
extern void DevActionAdiscDone_OK( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;
    SFThread_t   * pSFThread  = pDevThread->SFThread_Request.SFThread;

    CThread_ptr(thread->hpRoot)->ADISC_pollingCount --;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogErrorLevel,
                    "In %s - State = %d   ALPA %X FDCnt %x SFThread %p",
                    "DevActionAdisc_OK",(char *)agNULL,
                    pSFThread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,thread,DevEventPrliSuccess);

}

/*+
  Function: DevActionAdiscDone_FAIL_No_Device
   Purpose: ADISC completion failed because device missing
 Called By: SFActionAdiscBadALPA,DevEventAdiscDone_FAIL_No_Device 
     Calls: DevEventPlogiFailed
            
-*/
/* DevStateAdiscDone_FAIL_No_Device    24   */
extern void DevActionAdiscDone_FAIL_No_Device( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;
    SFThread_t   * pSFThread  = pDevThread->SFThread_Request.SFThread;

    CThread_ptr(thread->hpRoot)->ADISC_pollingCount--;

    CFuncCompleteActiveCDBThreadsOnDevice(pDevThread ,osIODevReset, CDBEventIODeviceReset );

    fiLogDebugString(thread->hpRoot,
                    DevStateLogErrorLevel,
                    "In %s - State = %d   ALPA %X FDCnt %x SFThread %p",
                    "DevActionAdiscDone_FAIL_No_Device",(char *)agNULL,
                    pSFThread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,thread,DevEventPlogiFailed);
}

/*+
  Function: DevActionTickVerifyALPA
   Purpose: Heartbeat function sends PLOGI to self every timertick.
 Called By:  
     Calls: SFThreadAlloc
            
-*/
/* DevStateDoTickVerifyALPA             25 */
extern void DevActionTickVerifyALPA( fi_thread__t *thread,eventRecord_t *eventRecord  )
{
    DevThread_t  * pDevThread   = ( DevThread_t  * )thread;
    SFThread_t * pSFThread      = pDevThread->SFThread_Request.SFThread;

    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount ++;

    fiLogDebugString(thread->hpRoot,
                    DEVSTATE_NOISE(thread->hpRoot,CStateNormal),
                    "In %s - State = %d   ALPA %X  FDCnt %x SFThread %p",
                    "DevActionTickVerifyALPA",(char *)agNULL,
                    pSFThread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                    0,0,0,0,0);

    pDevThread->Plogi_Reason_Code = PLOGI_REASON_HEART_BEAT;

    pDevThread->SFThread_Request.eventRecord_to_send.event = DevEventTickGotSFThread;
    pDevThread->SFThread_Request.eventRecord_to_send.thread = thread;
    if(pDevThread->SFThread_Request.State != SFThread_Request_InActive)
    {   /*+ Check This DRL why proceed if sfthread is active ? -*/
        fiLogDebugString(thread->hpRoot,
                        DevStateLogErrorLevel,
                        "In %s - State = %d   ALPA %X FDCnt %x SFThread %p SF req State Wrong !",
                        "DevActionTickVerifyALPA",(char *)agNULL,
                        pSFThread,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        fiComputeDevThread_D_ID(pDevThread),
                        CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                        0,0,0,0,0);
    }

    pDevThread->In_Verify_ALPA_FLAG = agTRUE;
    fiSetEventRecordNull(eventRecord);
    SFThreadAlloc( thread->hpRoot, & pDevThread->SFThread_Request );
}

/*+
  Function: DevActionExternalDeviceReset
   Purpose: Aborts all IO's if external device reset recieved. This is where a second
            host did a task mangement reset. Most likely IO's to this device will timeout
 Called By:  
     Calls: CFuncCompleteActiveCDBThreadsOnDevice
            CDBEvent_PrepareforAbort
            CDBEventAlloc_Abort
-*/
/*   DevStateExternalDeviceReset            26 */
extern void DevActionExternalDeviceReset( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    DevThread_t  * pDevThread = ( DevThread_t  * )thread;

    fiLogDebugString(thread->hpRoot,
                    DEVSTATE_NOISE(thread->hpRoot,CStateNormal),
                    "In %s - State = %d   ALPA %X  FDCnt %x",
                    "DevActionExternalDeviceReset",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                    0,0,0,0,0);
    /*+ Check This DRL Could mark these with ADLE and only abort the IOs that Timed out  -*/
    CFuncCompleteActiveCDBThreadsOnDevice(pDevThread ,osIOAborted, CDBEvent_PrepareforAbort);
    CFuncCompleteActiveCDBThreadsOnDevice(pDevThread, osIODevReset, CDBEventAlloc_Abort);

    fiSetEventRecord(eventRecord,thread,DevEventAvailable);
}

/*+
  Function: DevActionExternalDeviceReset
   Purpose: Does PLOGI for Heartbeat function
 Called By:  
     Calls: SFEventDoPlogi
-*/
/* DevStateTickGotSFThread             27 */
extern void DevActionTickGotSFThread( fi_thread__t *thread,eventRecord_t *eventRecord  )
{
    DevThread_t  * pDevThread   = ( DevThread_t  * )thread;
    SFThread_t * pSFThread      = pDevThread->SFThread_Request.SFThread;

    pSFThread->parent.Device = pDevThread;

    fiLogDebugString(thread->hpRoot,
                    DEVSTATE_NOISE(thread->hpRoot,CStateNormal),
                    "In %s - State = %d   ALPA %X  FDCnt %x SFThread %p",
                    "DevActionTickVerifyALPA",(char *)agNULL,
                    pSFThread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                    0,0,0,0,0);


    fiSetEventRecordNull(eventRecord);
    /* Send event to SFthread */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPlogi);

}

/*+
  Function: DevAction_IO_Ready
   Purpose: This is the default state for sending IO's. Moves queued IOs from Send_IO_CDBLink
            to Active_CDBLink_0
 Called By: DevEventSendIO 
     Calls: CDBEventInitialize
-*/
/*  DevState_IO_Ready            28 */
extern void DevAction_IO_Ready( fi_thread__t *thread,eventRecord_t *eventRecord  )
{
    DevThread_t  * pDevThread   = ( DevThread_t  * )thread;
    CDBThread_t  * pCDBThread;
    fiList_t    *  pCdbList = agNULL;

#ifndef Performance_Debug

    fiLogDebugString(thread->hpRoot,
                    DevStateLogConsoleLevel,
                    "In %s - State = %d   ALPA %X FDCnt %x Link %p",
                    "DevAction_IO_Ready",(char *)agNULL,
                    pCdbList,NULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                    0,0,0,0,0);

#endif /* Performance_Debug was not defined */
    
    Device_IO_Throttle_Increment

    while(fiListNotEmpty( &pDevThread->Send_IO_CDBLink  ))
    {
        fiListDequeueFromHeadFast(&pCdbList,
                                  &pDevThread->Send_IO_CDBLink );

        pCDBThread = hpObjectBase(CDBThread_t,
                                  CDBLink, pCdbList);

        fiListEnqueueAtTail(pCdbList,
                           &(pDevThread->Active_CDBLink_0));

        /* Send event to CDB thread */
        fiSendEvent( &(pCDBThread->thread_hdr), CDBEventInitialize );
    }

    fiSetEventRecordNull(eventRecord);


}

/*+
  Function: DevAction_FC_TAPE_Recovery
   Purpose: Used in FC TAPE Recovery

 Called By: DevEventSendIO DevEvent_FC_TAPE_Recovery
     Calls: CDBEventInitialize
-*/
/*  DevState_FC_TAPE_Recovery            29 */
extern void DevAction_FC_TAPE_Recovery( fi_thread__t *thread,eventRecord_t *eventRecord  )
{

    DevThread_t  * pDevThread   = ( DevThread_t  * )thread;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogConsoleLevel,
                    "In %s - State = %d   ALPA %X FDCnt %x",
                    "DevAction_FC_TAPE_Recovery",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                    0,0,0,0,0);


    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: DevActionAdiscDone_FAIL_ReLogin
   Purpose: When ADISC to the device responded with reject, relogin to device.
            ADISC rejects occur if it takes to long to send ADISC or a loop state timeout
            conditions existed to the device.

 Called By: SFActionAdiscRej,DevEventAdiscDone_FAIL_ReLogin 
     Calls: DevEventGotSFThread
-*/
/* DevStateAdiscDone_FAIL_ReLogin        30     */
extern void DevActionAdiscDone_FAIL_ReLogin( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t     * hpRoot     = thread->hpRoot;
    CThread_t    * pCThread   = CThread_ptr(hpRoot);
    DevThread_t  * DevThread = ( DevThread_t  * )thread;

    pCThread->ADISC_pollingCount--;

    CFuncCompleteActiveCDBThreadsOnDevice(DevThread ,osIODevReset, CDBEventIODeviceReset );

    fiLogDebugString(thread->hpRoot,
                    DevStateLogErrorLevel,
                    "In %s - State = %d   ALPA %X FDCnt %x",
                    "DevActionAdiscDone_FAIL_ReLogin",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    DevThread->DevInfo.CurrentAddress.AL_PA,
                    pCThread->FindDEV_pollingCount,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,thread,DevEventGotSFThread);
}

/*+
  Function: DevActionNoDevice
   Purpose: If device goes missing.

 Called By: DevEvent_Device_Gone 
            CActionFindDeviceUseNameServer 
            CFuncCompleteActiveCDBThreadsOnDevice
            CFuncFMCompletion

     Calls: DevEventPlogiFailed
-*/
/*  DevStateNoDevice       31     */
extern void DevActionNoDevice( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t     * hpRoot     = thread->hpRoot;
    CThread_t    * pCThread   = CThread_ptr(hpRoot);
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;

    fiLogString(thread->hpRoot,
                    "In %s - State = %d ALPA %X FDCnt %x",
                    "DevActionNoDevice",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCThread->FindDEV_pollingCount,
                    0,0,0,0,0);

    pDevThread->Prev_Active_Device_FLAG = 0;
    /*+ Check This DRL Does this function complete all queues -*/
    CFuncCompleteActiveCDBThreadsOnDevice(pDevThread ,osIODevReset, CDBEventIODeviceReset );

    fiSetEventRecord(eventRecord,thread,DevEventPlogiFailed);
}



#endif /* USESTATEMACROS */

/*+
  Function: DevState_c
   Purpose: When compiled updates browser info file for VC 5.0 / 6.0
   Returns: none
 Called By: none
     Calls: none
-*/
/*void DevState_c(void){}  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\err_code.h ===
/*++

Copyright (c) 2000 Agilent Technologies

Module Name:

   dupntdef.c

Abstract:

Authors:

Environment:

   kernel mode only

Notes:

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/H/ERR_CODE.H $


Revision History:

   $Revision: 2 $
   $Date: 9/07/00 11:14a $
   $Modtime:: 8/31/00 3:34p            $

Notes:


--*/

#ifndef __ERR_CODE_H__
#define __ERR_CODE_H__

#define ERR_VALIDATE_IOLBASE    0x00400000
#define ERR_MAP_IOLBASE         0x00300000
#define ERR_MAP_IOUPBASE        0x00200000
#define ERR_MAP_MEMIOBASE       0x00100000

#define ERR_UNCACHED_EXTENSION  0xe0000000
#define ERR_CACHED_EXTENSION    0xd0000000
#define ERR_RESET_FAILED        0xc0000000
#define ERR_ALIGN_QUEUE_BUF     0xb0000000
#define ERR_ACQUIRED_ALPA       0xa0000000
#define ERR_RECEIVED_LIPF_ALPA  0x90000000
#define ERR_RECEIVED_BAD_ALPA   0x80000000
#define ERR_CM_RECEIVED         0x70000000
#define ERR_INT_STATUS          0x60000000
#define ERR_FM_STATUS           0x50000000
#define ERR_PLOGI               0x40000000
#define ERR_PDISC               0x30000000
#define ERR_ADISC               0x20000000
#define ERR_PRLI                0x10000000

#define ERR_ERQ_FULL            0x0f000000
#define ERR_INVALID_LUN_EXT     0x0e000000
#define ERR_SEST_INVALIDATION   0x0d000000
#define ERR_SGL_ADDRESS         0x0c000000

#endif // __ERR_CODE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\fcciimpl.h ===
/*++

Copyright (c) 2000 Agilent Technologies

Module Name:

   fcciimpl.c

Abstract:

Authors:

Environment:

   kernel mode only

Notes:

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/H/fcciimpl.h $


Revision History:

   $Revision: 3 $
   $Date: 9/07/00 11:55a $
   $Modtime:: 9/07/00 11:54a           $

Notes:


--*/

#ifndef _FCCI_IMPL_H 
#define _FCCI_IMPL_H

#include "hhba5100.ver"

#define PORT_COUNT 1
#define PRODUCT_NAME  L"HHBA5100"
#define MODEL_NAME    L"HHBA5100"
#define SERIAL_NUMBER L"HHBA5100"
#define FCCI_MAX_BUS  8
#if _WIN32_WINNT >= 0x500
  #define FCCI_MAX_TGT  128
#else
  #define FCCI_MAX_TGT  32
#endif
#define FCCI_MAX_LUN  256

typedef struct _AGILENT_IMP_FCCI_DRIVER_INFO_OUT 
{
   // lengths of each character field (number of WCHARs)
   USHORT    DriverNameLength;
   USHORT    DriverDescriptionLength;
   USHORT    DriverVersionLength;
   USHORT    DriverVendorLength;

   // character fields (lengths just previous) follow in this order
   WCHAR          DriverName[(sizeof(LDRIVER_NAME) / sizeof(WCHAR))];
   WCHAR          DriverDescription[(sizeof(LDRIVER_DESCRIPTION) / sizeof(WCHAR))];
   WCHAR          DriverVersion[(sizeof(LDRIVER_VERSION_STR) / sizeof(WCHAR))] ;
   WCHAR          DriverVendor[(sizeof(LVER_COMPANYNAME_STR) / sizeof(WCHAR))];
} AFCCI_DRIVER_INFO_OUT, *PAFCCI_DRIVER_INFO_OUT;

typedef union _AGILENT_IMP_FCCI_DRIVER_INFO 
{       
   // no inbound data
   AFCCI_DRIVER_INFO_OUT    out;
} AFCCI_DRIVER_INFO, *PAFCCI_DRIVER_INFO;

/*----- FCCI_SRBCTL_GET_ADAPTER_INFO - data structures and defines -----------*/
typedef struct _AGILENT_IMP_FCCI_ADAPTER_INFO_OUT 
{
   ULONG     PortCount;               // How many ports on adapter?
                                      // The number should reflect the number of
                                      // ports this "miniport" device object controls
                                      // not necessarily the true number of
                                      // of ports on the adapter.

   ULONG     BusCount;           // How many virtual buses on adapter?
   ULONG     TargetsPerBus;      // How many targets supported per bus?
   ULONG     LunsPerTarget;      // How many LUNs supported per target?

   // lengths of each character field (number of WCHARs)
   USHORT    VendorNameLength;
   USHORT    ProductNameLength;
   USHORT    ModelNameLength;
   USHORT    SerialNumberLength;

   // character fields (lengths just previous) follow in this order
   WCHAR          VendorName[sizeof(LVER_COMPANYNAME_STR) / sizeof(WCHAR)];
   WCHAR          ProductName[sizeof(PRODUCT_NAME) / sizeof(WCHAR)];
   WCHAR          ModelName[sizeof(MODEL_NAME) / sizeof(WCHAR)];
   WCHAR          SerialNumber[sizeof(SERIAL_NUMBER) / sizeof(WCHAR)];
} AFCCI_ADAPTER_INFO_OUT, *PAFCCI_ADAPTER_INFO_OUT;


// !!! IMPORTANT !!!
// If the supplied buffer is not large enough to hold the variable length data
// fill in the non variable length fields and return the request
// with a ResultCode of FCCI_RESULT_INSUFFICIENT_BUFFER.

typedef union _AGILENT_IMP_FCCI_ADAPTER_INFO 
{       
   // no inbound data
   AFCCI_ADAPTER_INFO_OUT   out;
} AFCCI_ADAPTER_INFO, *PAFCCI_ADAPTER_INFO;

typedef struct _AGILENT_IMP_FCCI_DEVICE_INFO_OUT
{
   ULONG     TotalDevices;       // set to total number of device the adapter
                                      // knows of.

   ULONG     OutListEntryCount;  // set to number of device entries being 
                                      // returned in list (see comment below).

   FCCI_DEVICE_INFO_ENTRY  entryList[NUMBER_OF_BUSES * MAXIMUM_TID];
} AFCCI_DEVICE_INFO_OUT, *PAFCCI_DEVICE_INFO_OUT;

typedef union _AGILENT_IMPL_FCCI_DEVICE_INFO
{       
   // no inbound data
   AFCCI_DEVICE_INFO_OUT    out;
} AFCCI_DEVICE_INFO, *PAFCCI_DEVICE_INFO;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\devstate.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/DEVSTATE.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 7/28/00 3:47p   $

Purpose:

  This file defines the macros, types, and data structures
  used by ../C/DevState.C

--*/

#ifndef __DevState_H__
#define __DevState_H__

#define  PLOGI_REASON_VERIFY_ALPA  1
#define  PLOGI_REASON_DEVICE_LOGIN 2
#define  PLOGI_REASON_SOFT_RESET   3
#define  PLOGI_REASON_HEART_BEAT   4
#define  PLOGI_REASON_DIR_LOGIN    5

#define  DevStateConfused                      0
#define  DevStateHandleEmpty                   1
#define  DevStateAllocSFThread                 2
#define  DevStateDoPlogi                       3
#define  DevStatePlogiDone                     4
#define  DevStateDoPrli                        5
#define  DevStatePrliDone                      6
#define  DevStateMatchWWN                      7
#define  DevStateSlotNew                       8
#define  DevStateSlotKnown                     9
#define  DevStateHandleAvailable               10 /**/
#define  DevStateLoginFailed                   11
#define  DevStateLogout                        12
#define  DevStateAllocDeviceResetSoft          13
#define  DevStateAllocDeviceResetHard          14
#define  DevStateDeviceResetSoft               15
#define  DevStateDeviceResetHard               16
#define  DevStateDeviceResetDone               17

#define  DevStateAL_PA_Self_OK                 18
#define  DevStateAL_PA_Self_BAD                19

#define  DevStateDeviceResetDoneFAIL           20

#define  DevStateAllocAdisc                    21
#define  DevStateAdisc                         22
#define  DevStateAdiscDone_OK                  23
#define  DevStateAdiscDone_FAIL_No_Device      24
#define  DevStateAdiscDone_FAIL_ReLogin        30

#define  DevStateTickVerifyALPA                25
#define  DevStateExternalDeviceReset           26
#define  DevStateTickGotSFThread               27

#define  DevState_IO_Ready                     28 /**/
#define  DevState_FC_TAPE_Recovery             29 /**/
#define  DevStateNoDevice                      31 /**/

#define  DevStateMAXState  DevStateNoDevice

#define  DevEventConfused                     0
#define  DevEventLogin                        1
#define  DevEventGotSFThread                  2
#define  DevEventPlogiSuccess                 3
#define  DevEventDoPrli                       4
#define  DevEventPrliSuccess                  5
#define  DevEventCheckWWN                     6
#define  DevEventNoMatchWWN                   7
#define  DevEventMatchWWN                     8
#define  DevEventAvailable                    9

#define  DevEventPlogiFailed                  10
#define  DevEventPrliFailed                   11
#define  DevEventLoggedOut                    12

#define  DevEventAllocDeviceResetSoft         13
#define  DevEventAllocDeviceResetHard         14
#define  DevEventDeviceResetSoft              15
#define  DevEventDeviceResetHard              16

#define  DevEventDeviceResetDone              17
#define  DevEventDeviceResetDoneFail          20


#define  DevEventAL_PA_Self_OK                18
#define  DevEventAL_PA_Self_BAD               19

#define  DevEventAllocAdisc                   21
#define  DevEventAdisc                        22
#define  DevEventAdiscDone_OK                 23
#define  DevEventAdiscDone_FAIL_No_Device     24
#define  DevEventAdiscDone_FAIL_ReLogin       31

#define  DevEventDoTickVerifyALPA             25
#define  DevEventTickGotSFThread              27

#define  DevEventExternalDeviceReset          26

#define  DevEventExternalLogout               28
#define  DevEventSendIO                       29
#define  DevEvent_FC_TAPE_Recovery            30
#define  DevEvent_Device_Gone                 32

#define  DevEventMAXEvent  DevEvent_Device_Gone


STATE_PROTO(DevActionConfused       );
STATE_PROTO(DevActionHandleEmpty    );
STATE_PROTO(DevActionAllocSFThread  );
STATE_PROTO(DevActionDoPlogi        );
STATE_PROTO(DevActionPlogiDone      );
STATE_PROTO(DevActionDoPrli         );
STATE_PROTO(DevActionPrliDone       );
STATE_PROTO(DevActionMatchWWN       );
STATE_PROTO(DevActionSlotNew        );
STATE_PROTO(DevActionSlotKnown      );
STATE_PROTO(DevActionAvailable      );

STATE_PROTO(DevActionLoginFailed    );
STATE_PROTO(DevActionLogout         );

STATE_PROTO(DevActionAllocDeviceResetSoft );
STATE_PROTO(DevActionAllocDeviceResetHard );

STATE_PROTO(DevActionDeviceResetSoft );
STATE_PROTO(DevActionDeviceResetHard );
STATE_PROTO(DevActionDeviceResetDone );
STATE_PROTO(DevActionDeviceResetDoneFAIL );


STATE_PROTO(DevActionAL_PA_Self_OK   );
STATE_PROTO(DevActionAL_PA_Self_BAD  );

STATE_PROTO(DevActionAllocAdisc    );
STATE_PROTO(DevActionAdisc          );
STATE_PROTO(DevActionAdiscDone_OK   );
STATE_PROTO(DevActionAdiscDone_FAIL_No_Device );
STATE_PROTO(DevActionAdiscDone_FAIL_ReLogin );

STATE_PROTO(DevActionTickVerifyALPA  );
STATE_PROTO(DevActionTickGotSFThread );

STATE_PROTO(DevActionExternalDeviceReset   );
STATE_PROTO(DevAction_IO_Ready );
STATE_PROTO(DevAction_FC_TAPE_Recovery  );
STATE_PROTO(DevActionNoDevice );
 


#define DEVSTATE_NOISE( hpRoot, State ) (CThread_ptr(hpRoot)->thread_hdr.currentState == State ? DevStateLogConsoleLevel : DevStateLogErrorLevel )

extern stateTransitionMatrix_t DevStateTransitionMatrix;
extern stateActionScalar_t DevStateActionScalar;

#ifdef USESTATEMACROS

void testDevthread( agRoot_t *hpRoot  );

#define DEVSTATE_FUNCTION_ACTION( x , Action) extern void x( fi_thread__t * thread, \
                 eventRecord_t * eventRecord ){         \
    agRoot_t * hpRoot=thread->hpRoot;                   \
    osLogDebugString(hpRoot,                            \
                      StateLogConsoleLevel,             \
                      "In %s - State = %d",             \
                      #x,(char *)agNULL,                  \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)thread->currentState,      \
                      0,0,0,0,0,0,0);                   \
    osLogDebugString(thread->hpRoot,                    \
                      StateLogConsoleLevel,             \
                      "Sends event...%s %d",            \
                      #Action,(char *)agNULL,             \
                      (void * )agNULL,(void * )agNULL,  \
                      Action,0,0,0,0,0,0,0);            \
    fiSetEventRecord(eventRecord, thread, Action);   }  \

#define DEVSTATE_FUNCTION_TERMINATE(x) extern void x(fi_thread__t *thread,\
                                      eventRecord_t *eventRecord ){\
    agRoot_t * hpRoot=thread->hpRoot;                   \
    CThread_t  * pCThread=CThread_ptr(hpRoot);          \
    CDBThread_t * pCDBThread=(CDBThread_t * )thread;    \
    DevThread_t * pDevThread=pCDBThread->Device;        \
    osLogDebugString(hpRoot,                            \
                      StateLogConsoleLevel,             \
                      "In %s - State = %d",     \
                      #x,(char *)agNULL,                  \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)thread->currentState,      \
                      0,0,0,0,0,0,0);                   \
    osLogDebugString(thread->hpRoot,                    \
                      StateLogConsoleLevel,             \
                      "...simply returns",            \
                      (char *)agNULL,(char *)agNULL,        \
                      (void * )agNULL,(void * )agNULL,  \
                      0,0,0,0,0,0,0,0);                 \
    eventRecord->thread = agNULL;                         \
    }\

#define DEVSTATE_FUNCTION_MULTI_ACTION(x,Action0,Action1,Action2,Action3) extern void x( fi_thread__t *thread,\
                                      eventRecord_t *eventRecord ){ \
    agRoot_t * hpRoot = thread->hpRoot;               \
    os_bit8 WhichAction[4];                              \
    static  os_bit32 ActionCount=0;                      \
    WhichAction[0] = Action0;                         \
    WhichAction[1] = Action1;                         \
    WhichAction[2] = Action2;                         \
    WhichAction[3] = Action3;                         \
    osLogDebugString(thread->hpRoot,                  \
                      StateLogConsoleLevel,           \
                      "In %s - State = %d",           \
                      #x,(char *)agNULL,                \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)thread->currentState,    \
                      0,0,0,0,0,0,0);                 \
    osLogDebugString(thread->hpRoot,                  \
                      StateLogConsoleLevel,           \
                      "...returns event %s %d",       \
                      #Action0,#Action1,              \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)WhichAction[ActionCount],\
                      0,0,0,0,0,0,0);                 \
    osLogDebugString(thread->hpRoot,                  \
                      StateLogConsoleLevel,           \
                      "or %s  or %s",                 \
                      #Action2,#Action3,              \
                      (void * )agNULL,(void * )agNULL,  \
                      0,0,0,0,0,0,0,0);               \
    fiSetEventRecord(eventRecord,thread,WhichAction[ActionCount]);  \
    if(ActionCount<3)ActionCount++;                   \
    else ActionCount =0;                              \
    }                                                 \

#ifdef TestDevStateMachine

char * DevStateString[]=
{

    "DevStateConfused                 ",
    "DevStateHandleEmpty              ",
    "DevStateAllocSFThread            ",
    "DevStateDoPlogi                  ",
    "DevStatePlogiDone                ",
    "DevStateDoPrli                   ",
    "DevStatePrliDone                 ",
    "DevStateMatchWWN                 ",
    "DevStateSlotNew                  ",
    "DevStateSlotKnown                ",
    "DevStateHandleAvailable          ",
    "DevStateLoginFailed              ",
    "DevStateLogout                   ",
    "DevStateAllocDeviceResetSoft     ",
    "DevStateAllocDeviceResetHard     ",
    "DevStateDeviceResetSoft          ",
    "DevStateDeviceResetHard          ",
    "DevStateDeviceResetDone          ",
    "DevStateAL_PA_Self_OK            ",
    "DevStateAL_PA_Self_BAD           ",
    "DevStateDeviceResetDoneFAIL      ",
    "DevStateAllocAdisc               ",
    "DevStateAdisc                    ",
    "DevStateAdiscDone_OK             ",
    "DevStateAdiscDone_FAIL_No_Device ",
    "DevStateAdiscDone_FAIL_ReLogin   ",
    "DevStateTickVerifyALPA           ",
    "DevStateExternalDeviceReset      ",
    "DevStateTickGotSFThread          ",
    "DevState_IO_Ready                ",
    "DevState_FC_TAPE_Recovery        ",
    "DevStateNoDevice                 ",
    agNULL

};

char * DevEventString[]=
{
    "DevEventConfused                 ",
    "DevEventLogin                    ",
    "DevEventGotSFThread              ",
    "DevEventPlogiSuccess             ",
    "DevEventDoPrli                   ",
    "DevEventPrliSuccess              ",
    "DevEventCheckWWN                 ",
    "DevEventNoMatchWWN               ",
    "DevEventMatchWWN                 ",
    "DevEventAvailable                ",
    "DevEventPlogiFailed              ",
    "DevEventPrliFailed               ",
    "DevEventLoggedOut                ",
    "DevEventAllocDeviceResetSoft     ",
    "DevEventAllocDeviceResetHard     ",
    "DevEventDeviceResetSoft          ",
    "DevEventDeviceResetHard          ",
    "DevEventDeviceResetDone          ",
    "DevEventDeviceResetDoneFail      ",
    "DevEventAL_PA_Self_OK            ",
    "DevEventAL_PA_Self_BAD           ",
    "DevEventAllocAdisc               ",
    "DevEventAdisc                    ",
    "DevEventAdiscDone_OK             ",
    "DevEventAdiscDone_FAIL_No_Device ",
    "DevEventAdiscDone_FAIL_ReLogin   ",
    "DevEventDoTickVerifyALPA         ",
    "DevEventTickGotSFThread          ",
    "DevEventExternalDeviceReset      ",
    "DevEventExternalLogout           ",
    "DevEventSendIO                   ",
    "DevEvent_FC_TAPE_Recovery        ",
    "DevEvent_Device_Gone             ",
    agNULL

};


#endif /* TestDevStateMachine was defined */

#endif /* USESTATEMACROS was defined */

#endif /*  __DevState_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\fcciioct.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Module Name:

   FCCIIoct.c

Abstract:

   FCCI Ioctl Handler

Author:
   PS - Pooni Subranamiyam   HP FCCI
   LP - Leopold Purwadihardja

Revision History:

Environment:

   kernel mode only

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/C/fcciioct.c $

Revision History:

   $Revision: 5 $
   $Date: 11/10/00 5:50p $
   $Modtime:: $

--*/


#include "buildop.h"
#include "osflags.h"
#include "hhba5100.ver"

#ifdef _FCCI_SUPPORT

void
FcciFillDriverInfo(
   PSRB_IO_CONTROL srbIoCtl,
   AFCCI_DRIVER_INFO *FcciDriverInfo,
   UCHAR *status
   )
{

   if  (srbIoCtl->Length < ( sizeof(FCCI_DRIVER_INFO )    + 
                            sizeof(LDRIVER_NAME)         + 
                            sizeof(LDRIVER_DESCRIPTION)  +
                       sizeof(LDRIVER_VERSION_STR)  +
                             sizeof(LVER_COMPANYNAME_STR)))
   
   {
      FcciDriverInfo->out.DriverNameLength = (sizeof(LDRIVER_NAME) / sizeof(WCHAR));
      FcciDriverInfo->out.DriverDescriptionLength = (sizeof(LDRIVER_DESCRIPTION) / sizeof(WCHAR));
      FcciDriverInfo->out.DriverVersionLength = (sizeof(LDRIVER_VERSION_STR) / sizeof(WCHAR));
      FcciDriverInfo->out.DriverVendorLength = (sizeof(LVER_COMPANYNAME_STR) / sizeof(WCHAR));
      srbIoCtl->ReturnCode = FCCI_RESULT_INSUFFICIENT_BUFFER;
   } 
   else 
   {
      FcciDriverInfo->out.DriverNameLength = (sizeof(LDRIVER_NAME) /sizeof(WCHAR));
      memcpy(FcciDriverInfo->out.DriverName, LDRIVER_NAME, sizeof(LDRIVER_NAME));
      FcciDriverInfo->out.DriverDescriptionLength = (sizeof(LDRIVER_DESCRIPTION) / sizeof(WCHAR));
      memcpy(FcciDriverInfo->out.DriverDescription, LDRIVER_DESCRIPTION,
                                     sizeof(LDRIVER_DESCRIPTION));
      FcciDriverInfo->out.DriverVersionLength = (sizeof(LDRIVER_VERSION_STR) / sizeof(WCHAR));
      memcpy(FcciDriverInfo->out.DriverVersion, LDRIVER_VERSION_STR,sizeof(LDRIVER_VERSION_STR));
      FcciDriverInfo->out.DriverVendorLength = (sizeof(LVER_COMPANYNAME_STR) /sizeof(WCHAR));
      memcpy(FcciDriverInfo->out.DriverVendor, LVER_COMPANYNAME_STR,sizeof(LVER_COMPANYNAME_STR));
      srbIoCtl->ReturnCode = FCCI_RESULT_SUCCESS;
   }

}

void
FcciFillAdapterInfo(
   PSRB_IO_CONTROL srbIoCtl,
   AFCCI_ADAPTER_INFO *FcciAdapterInfo,
   PCARD_EXTENSION pCard,
   UCHAR *status
   )
{
    

   if  (srbIoCtl->Length <  (sizeof(FCCI_ADAPTER_INFO)    +
                            sizeof(LVER_COMPANYNAME_STR) + 
                            sizeof(PRODUCT_NAME)         +
                       sizeof(MODEL_NAME)           +
                             sizeof(SERIAL_NUMBER)))
   
   {
      FcciAdapterInfo->out.VendorNameLength =  (sizeof(LVER_COMPANYNAME_STR) / sizeof(WCHAR));
      FcciAdapterInfo->out.ProductNameLength = (sizeof(PRODUCT_NAME) / sizeof(WCHAR));
      FcciAdapterInfo->out.ModelNameLength =   (sizeof(MODEL_NAME) /sizeof(WCHAR));
      FcciAdapterInfo->out.SerialNumberLength = (sizeof(SERIAL_NUMBER) /sizeof(WCHAR));
      srbIoCtl->ReturnCode = FCCI_RESULT_INSUFFICIENT_BUFFER;
   } 
   else 
   {
      FcciAdapterInfo->out.PortCount     = PORT_COUNT; // Number of SCSI target ports
      FcciAdapterInfo->out.BusCount      = FCCI_MAX_BUS;
      FcciAdapterInfo->out.TargetsPerBus = FCCI_MAX_TGT;
      FcciAdapterInfo->out.LunsPerTarget = FCCI_MAX_LUN;
      FcciAdapterInfo->out.VendorNameLength   = (sizeof(LVER_COMPANYNAME_STR) / sizeof(WCHAR));
      FcciAdapterInfo->out.ProductNameLength  = (sizeof(PRODUCT_NAME) / sizeof(WCHAR));
      FcciAdapterInfo->out.ModelNameLength    = (sizeof(MODEL_NAME) / sizeof(WCHAR));
      FcciAdapterInfo->out.SerialNumberLength = (sizeof(SERIAL_NUMBER) / sizeof(WCHAR));
      memcpy(FcciAdapterInfo->out.VendorName, LVER_COMPANYNAME_STR, sizeof(LVER_COMPANYNAME_STR));
      memcpy(FcciAdapterInfo->out.ProductName, PRODUCT_NAME, sizeof(PRODUCT_NAME));
      memcpy(FcciAdapterInfo->out.ModelName,  MODEL_NAME, sizeof(MODEL_NAME));
      memcpy(FcciAdapterInfo->out.SerialNumber,SERIAL_NUMBER, sizeof(SERIAL_NUMBER));
      srbIoCtl->ReturnCode = FCCI_RESULT_SUCCESS;

   }
}

#define ChipIOUp_Frame_Manager_Status_NP    0x20000000

void
FcciFillAdapterPortInfo(
   PSRB_IO_CONTROL srbIoCtl,
   FCCI_ADAPTER_PORT_INFO *FcciAdapterPortInfo,
   PCARD_EXTENSION pCard,
   UCHAR *status
   )
{
   os_bit32 FM_Status;
   agFCChanInfo_t  chanInfo;
   agRoot_t        *hpRoot=&pCard->hpRoot;
   ULONG PortNumber;

   PortNumber = FcciAdapterPortInfo->in.PortNumber;
   /* If more than one miniport object per adapter then we need to do something *
   /* As of now do nothing  */

   fcGetChannelInfo (hpRoot, &chanInfo);

   osCopy(FcciAdapterPortInfo->out.NodeWWN, chanInfo.NodeWWN, 8);
   osDEBUGPRINT((ALWAYS_PRINT,"HPFillAdapterInfo: NodeWWN 0x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                                chanInfo.NodeWWN[0],chanInfo.NodeWWN[1],
                                chanInfo.NodeWWN[2],chanInfo.NodeWWN[3],
                                chanInfo.NodeWWN[4],chanInfo.NodeWWN[5],
                                chanInfo.NodeWWN[6],chanInfo.NodeWWN[7] ));
   FcciAdapterPortInfo->out.Flags |= FCCI_FLAG_NodeWWN_Valid;
   osCopy(FcciAdapterPortInfo->out.PortWWN, chanInfo.PortWWN, 8);
   FcciAdapterPortInfo->out.Flags |= FCCI_FLAG_PortWWN_Valid;
   osDEBUGPRINT((ALWAYS_PRINT,"HPFillAdapterInfo: PortWWN 0x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                                chanInfo.PortWWN[0],chanInfo.PortWWN[1],
                                chanInfo.PortWWN[2],chanInfo.PortWWN[3],
                                chanInfo.PortWWN[4],chanInfo.PortWWN[5],
                                chanInfo.PortWWN[6],chanInfo.PortWWN[7] ));
   FcciAdapterPortInfo->out.NportId = chanInfo.CurrentAddress.AL_PA;
   FcciAdapterPortInfo->out.Flags |= FCCI_FLAG_NportID_Valid;
   osDEBUGPRINT((ALWAYS_PRINT,"HPFillAdapterInfo: Alpa = 0x%02x\n",chanInfo.CurrentAddress.AL_PA));
   FcciAdapterPortInfo->out.PortTopology  = FCCI_PORT_TOPO_PTOP_FABRIC; // Current Topology

   FM_Status = osChipIOUpReadBit32(pCard->hpRoot, 0xC8);
   
   if( FM_Status & ChipIOUp_Frame_Manager_Status_NP )
      FcciAdapterPortInfo->out.PortState = FCCI_PORT_STATE_NON_PARTICIPATING;
   
   switch (pCard->State) 
   {
      case CS_DRIVER_ENTRY         :
      case CS_DURING_DRV_ENTRY     :
      case CS_DURING_FINDADAPTER   :
      case CS_DURING_DRV_INIT      :
      case CS_DURING_RESET_ADAPTER :
         FcciAdapterPortInfo->out.PortState = FCCI_PORT_STATE_INITIALIZING;
         break;
         
      case CS_FCLAYER_LOST_IO   :
      case CS_DURING_STARTIO    :         
      case CS_DURING_ISR        :        
      case CS_DURING_OSCOMPLETE :       
      case CS_HANDLES_GOOD      :        
      case CS_DURING_ANY        :     
      case CS_DUR_ANY_ALL       :      
      case CS_DUR_ANY_MOD       :      
      case CS_DUR_ANY_LOW       : 
         if (pCard->LinkState == LS_LINK_UP)
            FcciAdapterPortInfo->out.PortState = FCCI_PORT_STATE_NORMAL; // Current Adapter State
         break;
      default              :
         FcciAdapterPortInfo->out.PortState = 0;
   }
   srbIoCtl->ReturnCode = FCCI_RESULT_SUCCESS;

}

void
FcciFillLogUnitInfo(
   PSRB_IO_CONTROL srbIoCtl,
   FCCI_LOGUNIT_INFO *FcciLogUnitInfo,
   PCARD_EXTENSION pCard,
   UCHAR *status
   )
{
   agFCDev_t hpFcDev;
   agFCDevInfo_t hpFcDevInfo;
   UCHAR PathId, TargetId, Lun;
   agRoot_t * hpRoot=&pCard->hpRoot;
   PLU_EXTENSION pLunExt = NULL;     /* added for YAM21 support */
   LUN tempLun;                        /* added for FCP Lun data */
   PLUN ptempLun = &tempLun;
      
   PathId   = (UCHAR) FcciLogUnitInfo->in.TargetAddress.PathId;
   TargetId = (UCHAR)FcciLogUnitInfo->in.TargetAddress.TargetId;
   Lun      = (UCHAR)FcciLogUnitInfo->in.TargetAddress.Lun;
    
   /* Grab the Lun Extension, to be used in MapToHandle */
   pLunExt = ScsiPortGetLogicalUnit(pCard,
                                     PathId,
                                     TargetId,
                                     Lun );
   if (pLunExt != NULL) 
   {
      hpFcDev = MapToHandle(pCard, PathId, TargetId, Lun, pLunExt);
      if (hpFcDev != NULL) 
      {
         fcGetDeviceInfo(hpRoot, hpFcDev, &hpFcDevInfo);
         osCopy(FcciLogUnitInfo->out.NodeWWN, hpFcDevInfo.NodeWWN, 8);
         FcciLogUnitInfo->out.Flags |= FCCI_FLAG_NodeWWN_Valid;
         osCopy(FcciLogUnitInfo->out.PortWWN, hpFcDevInfo.PortWWN, 8);
         FcciLogUnitInfo->out.Flags |= FCCI_FLAG_PortWWN_Valid;
         FcciLogUnitInfo->out.NportId = hpFcDevInfo.CurrentAddress.AL_PA;
         FcciLogUnitInfo->out.Flags |= FCCI_FLAG_NportID_Valid;
         if (hpFcDevInfo.Present)
            FcciLogUnitInfo->out.Flags |= FCCI_FLAG_Exists;
         if (hpFcDevInfo.LoggedIn)
            FcciLogUnitInfo->out.Flags |= FCCI_FLAG_Logged_In;
   
   
         /* Get the FCP lun data */
         
         memset(ptempLun, 0, sizeof(LUN));
         if(pLunExt)
         {
            FcciLogUnitInfo->out.Flags |= FCCI_FLAG_LogicalUnit_Valid;
            switch(pLunExt->Mode)
            {
               case PA_DEVICE_TRY_MODE_VS:
                  SET_VS_LUN(ptempLun, PathId, TargetId, Lun)
                  memcpy(&(FcciLogUnitInfo->out.LogicalUnitNumber), ptempLun, sizeof(LUN)); 
                  break;
         
               case PA_DEVICE_TRY_MODE_LU:
                  SET_LU_LUN(ptempLun, PathId, TargetId, Lun)
                  memcpy(&(FcciLogUnitInfo->out.LogicalUnitNumber), ptempLun, sizeof(LUN)); 
                  break;
         
               case PA_DEVICE_TRY_MODE_PA:
                  SET_PA_LUN(ptempLun, PathId, TargetId, Lun)
                  memcpy(&(FcciLogUnitInfo->out.LogicalUnitNumber), ptempLun, sizeof(LUN)); 
                  break;
               
               default:
                  FcciLogUnitInfo->out.Flags &= ~FCCI_FLAG_LogicalUnit_Valid;

            } // end switch
         
         } // end if ( pLunExt )
      
      }
      else 
      {
         srbIoCtl->ReturnCode = FCCI_RESULT_INVALID_TARGET;
      }
   }
   else 
   {
      srbIoCtl->ReturnCode = FCCI_RESULT_INVALID_TARGET;
   }
   srbIoCtl->ReturnCode = FCCI_RESULT_SUCCESS;
}

void
FcciFillDeviceInfo(
   PSRB_IO_CONTROL srbIoCtl,
   AFCCI_DEVICE_INFO *FcciGetDeviceInfo,
   PCARD_EXTENSION pCard,
   UCHAR *status
   )
{
   agFCDev_t       hpFcDev;
   agFCDevInfo_t   hpFcDevInfo;
   UCHAR PathId, TargetId, Lun;
   agRoot_t        *hpRoot = &pCard->hpRoot;
   PLU_EXTENSION  pLunExt = NULL;
   int gNumberOfDevices = 0;
   int Count = 0;

   for (PathId = 0; PathId < NUMBER_OF_BUSES; PathId++) 
   {
      for (TargetId = 0; TargetId < MAXIMUM_TID; TargetId++) 
      {
         pLunExt = NULL;
         Lun = 0;
         pLunExt = ScsiPortGetLogicalUnit(pCard,
                                             PathId,
                                             TargetId,
                                             Lun );
                                   
         hpFcDev = MapToHandle(pCard, PathId, TargetId, Lun, pLunExt);
         if (hpFcDev != NULL) gNumberOfDevices++;
      }
   }

   Count = 0;
   if  (srbIoCtl->Length < ((gNumberOfDevices * sizeof(FCCI_DEVICE_INFO_ENTRY)) + sizeof(FCCI_DEVICE_INFO_OUT))) 
   {
      FcciGetDeviceInfo->out.TotalDevices = gNumberOfDevices;
      FcciGetDeviceInfo->out.OutListEntryCount = 0;
      srbIoCtl->ReturnCode = FCCI_RESULT_INSUFFICIENT_BUFFER;
   } 
   else 
   {
      srbIoCtl->ReturnCode = FCCI_RESULT_SUCCESS;
      FcciGetDeviceInfo->out.TotalDevices = gNumberOfDevices;
      FcciGetDeviceInfo->out.OutListEntryCount = gNumberOfDevices;
      for (PathId = 0; PathId < FCCI_MAX_BUS; PathId++) 
      {
         for (TargetId = 0; TargetId < FCCI_MAX_TGT; TargetId++) 
         {
            pLunExt = NULL;
            Lun = 0;
            pLunExt = ScsiPortGetLogicalUnit(pCard,
                                             PathId,
                                             TargetId,
                                             Lun );
            hpFcDev = MapToHandle(pCard, PathId, TargetId, Lun, pLunExt);
            if (hpFcDev != NULL) 
            {
               memset(&hpFcDevInfo, 0, sizeof( agFCDevInfo_t));
               fcGetDeviceInfo(hpRoot, hpFcDev, &hpFcDevInfo);
               osCopy(FcciGetDeviceInfo->out.entryList[Count].NodeWWN,hpFcDevInfo.NodeWWN,8);
               FcciGetDeviceInfo->out.entryList[Count].Flags |= FCCI_FLAG_NodeWWN_Valid;
               osCopy(FcciGetDeviceInfo->out.entryList[Count].PortWWN,hpFcDevInfo.PortWWN,8);
               FcciGetDeviceInfo->out.entryList[Count].Flags |= FCCI_FLAG_PortWWN_Valid;
               FcciGetDeviceInfo->out.entryList[Count].NportId = hpFcDevInfo.CurrentAddress.AL_PA;
               FcciGetDeviceInfo->out.entryList[Count].Flags |= FCCI_FLAG_NportID_Valid;
               if (hpFcDevInfo.Present)
                  FcciGetDeviceInfo->out.entryList[Count].Flags |= FCCI_FLAG_Exists;
               if (hpFcDevInfo.LoggedIn)
                  FcciGetDeviceInfo->out.entryList[Count].Flags |= FCCI_FLAG_Logged_In;
               FcciGetDeviceInfo->out.entryList[Count].TargetAddress.PathId = PathId;
               FcciGetDeviceInfo->out.entryList[Count].TargetAddress.TargetId = TargetId;
               FcciGetDeviceInfo->out.entryList[Count].TargetAddress.Lun = Lun;
               FcciGetDeviceInfo->out.entryList[Count].Flags |= FCCI_FLAG_TargetAddress_Valid;
               Count++;
            }
         }
      }
   }

}

void
FcciDoDeviceReset(
   PSRB_IO_CONTROL srbIoCtl,
   FCCI_RESET_TARGET *FcciResetTarget,
   PCARD_EXTENSION pCard,
   UCHAR *PathId,
   UCHAR *TargetId,
   UCHAR *status
   )
{
   agRoot_t * hpRoot=&pCard->hpRoot;
   agFCDev_t hpFcDev;
   ULONG ResetStatus;
   UCHAR Lun;

   *PathId   = (UCHAR)FcciResetTarget->in.PathId;
   *TargetId = (UCHAR)FcciResetTarget->in.TargetId;
   Lun       = (UCHAR)FcciResetTarget->in.Lun;
   hpFcDev = MapToHandle(pCard, *PathId, *TargetId, Lun, NULL);
   if (hpFcDev == NULL ||
        (ResetStatus = fcResetDevice(hpRoot, hpFcDev, fcHardReset)) != fcResetSuccess) 
   {
      srbIoCtl->ReturnCode = FCCI_RESULT_HARD_ERROR;
   }
}

ULONG FCCIIoctl(
   IN PCARD_EXTENSION pCard,
   IN PSCSI_REQUEST_BLOCK Srb,
   BOOLEAN    *LinkResetPerformed,
   BOOLEAN    *DeviceResetPerformed,
   UCHAR       *srb_status,
   UCHAR       *PathId, 
   UCHAR       *TargetId
   )
{
   agRoot_t * phpRoot      =   &pCard->hpRoot;
   PSRB_EXTENSION pSrbExt  =   Srb->SrbExtension;
   PSRB_IO_CONTROL srbIoCtl;
   UCHAR status;
// PSRB_IO_CONTROL srbIoCtl;
// ULONG    done = FALSE;
//   UCHAR    srbPathId = Srb->PathId;
//   UCHAR    srbTargetId = Srb->TargetId;
//   UCHAR    srbLun = Srb->Lun;

   status = *srb_status;
   
   srbIoCtl = ((PSRB_IO_CONTROL)(Srb->DataBuffer));

   switch (srbIoCtl->ControlCode) 
   {
      case FCCI_SRBCTL_GET_DRIVER_INFO : 
      {
         AFCCI_DRIVER_INFO *AFcciDriverInfo;

         if (FCCI_BufferLengthIsValid((PUCHAR)Srb->DataBuffer, 
                                                    Srb->DataTransferLength)) 
         {
            AFcciDriverInfo = (AFCCI_DRIVER_INFO *)FCCI_GetCommandBuffer(Srb->DataBuffer); 
            FcciFillDriverInfo(srbIoCtl, AFcciDriverInfo, &status);
         }
         else 
         {
            srbIoCtl->ReturnCode = FCCI_RESULT_INSUFFICIENT_BUFFER;
         }
         break;
      }

      case FCCI_SRBCTL_GET_ADAPTER_INFO : 
      {
         AFCCI_ADAPTER_INFO *AFcciAdapterInfo;
         
         if (FCCI_BufferLengthIsValid((PUCHAR)Srb->DataBuffer, 
                                                    Srb->DataTransferLength)) 
         {
            AFcciAdapterInfo = (AFCCI_ADAPTER_INFO *)FCCI_GetCommandBuffer(Srb->DataBuffer); 
            FcciFillAdapterInfo(srbIoCtl, AFcciAdapterInfo, pCard, &status);
         }
         else 
         {
            srbIoCtl->ReturnCode = FCCI_RESULT_INSUFFICIENT_BUFFER;
         }
         break;
      }

      case FCCI_SRBCTL_GET_ADAPTER_PORT_INFO : 
      {
         FCCI_ADAPTER_PORT_INFO *FcciAdapterPortInfo;
         
         if (FCCI_BufferLengthIsValid((PUCHAR)Srb->DataBuffer, 
                                                    Srb->DataTransferLength)) 
         {
            FcciAdapterPortInfo = (FCCI_ADAPTER_PORT_INFO *)FCCI_GetCommandBuffer(Srb->DataBuffer); 
            FcciFillAdapterPortInfo(srbIoCtl, FcciAdapterPortInfo, pCard,  &status);
         }
         else 
         {
            srbIoCtl->ReturnCode = FCCI_RESULT_INSUFFICIENT_BUFFER;
         }
         break;
      }

      case FCCI_SRBCTL_GET_LOGUNIT_INFO : 
      {
         FCCI_LOGUNIT_INFO *FcciLogUnitInfo;
         
         if (FCCI_BufferLengthIsValid((PUCHAR)Srb->DataBuffer, Srb->DataTransferLength)) 
         {
            FcciLogUnitInfo = (FCCI_LOGUNIT_INFO *)FCCI_GetCommandBuffer(Srb->DataBuffer); 
            FcciFillLogUnitInfo(srbIoCtl, FcciLogUnitInfo, pCard, &status);
         }
         else 
         {
            srbIoCtl->ReturnCode = FCCI_RESULT_INSUFFICIENT_BUFFER;
         }
         break;
      }

      case FCCI_SRBCTL_GET_DEVICE_INFO : 
      {
         AFCCI_DEVICE_INFO *AFcciDeviceInfo;
         BOOLEAN BufferLengthValid;
         
         if (FCCI_BufferLengthIsValid((PUCHAR)Srb->DataBuffer, Srb->DataTransferLength)) 
         {
            AFcciDeviceInfo = (AFCCI_DEVICE_INFO *)FCCI_GetCommandBuffer(Srb->DataBuffer); 
            FcciFillDeviceInfo(srbIoCtl, AFcciDeviceInfo, pCard, &status);
         }
         else 
         {
            srbIoCtl->ReturnCode = FCCI_RESULT_INSUFFICIENT_BUFFER;
         }
         break;
      }
        
      case FCCI_SRBCTL_RESET_TARGET : 
      {
         FCCI_RESET_TARGET *FcciResetTarget;
         if (FCCI_BufferLengthIsValid((PUCHAR)Srb->DataBuffer, Srb->DataTransferLength)) 
         {
            FcciResetTarget = (FCCI_RESET_TARGET *)FCCI_GetCommandBuffer(Srb->DataBuffer); 
            FcciDoDeviceReset(srbIoCtl, FcciResetTarget,pCard,PathId,TargetId,&status);
         }
         else 
         {
            srbIoCtl->ReturnCode = FCCI_RESULT_INSUFFICIENT_BUFFER;
         }
         break;
      }
               
      default :
         osDEBUGPRINT((ALWAYS_PRINT,"HPFibreStartIo: MiniportIOCtl not supported\n"));
         srbIoCtl->ReturnCode = HP_FC_RTN_BAD_CTL_CODE;

   } // end IOCTL switch
   
   *srb_status = status;
   return 0;

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\fcapi.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/FcApi.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 7/20/00 2:33p   $ (Last Modified)

Purpose:

  This is the TachyonXL-specific FC Layer API Include File.

--*/

#ifndef __TachyonXL_FcApi_H__

#define __TachyonXL_FcApi_H__

/*
 * Define each FC Layer function overridden
 */

#endif  /* ~__TachyonXL_FcApi_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\dvrentry.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Module Name:

    DvrEntry.c

Abstract:

    This is the miniport driver entry point for the Agilent
    PCI to Fibre Channel Host Bus Adapter (HBA).

Authors:

    MB - Michael Bessire
    DL - Dennis Lindfors FC Layer support
    IW - Ie Wei Njoo
    LP - Leopold Purwadihardja
    KR - Kanna Rajagopal

Environment:

    kernel mode only

Version Control Information:

    $Archive: /Drivers/Win2000/Trunk/OSLayer/C/DVRENTRY.C $

Revision History:

    $Revision: 4 $
    $Date: 10/23/00 5:40p $
    $Modtime:: 10/19/00 5:00p          $

Notes:

--*/


#include "buildop.h"
#include "osflags.h"

#if DBG
#include "ntdebug.h"
//  EXTERNAL_DEBUG_LEVEL is defined in ntdebug.h so this file does not change
extern ULONG Global_Print_Level =  EXTERNAL_DEBUG_LEVEL;
extern ULONG hpFcConsoleLevel;
// extern ULONG  HPDebugFlag =  EXTERNAL_HP_DEBUG_LEVEL;
#endif //  DBG

#if defined(HP_PCI_HOT_PLUG)
   #include "HotPlug4.h"    // NT 4.0 PCI Hot-Plug header file
#endif

#ifdef _DEBUG_EVENTLOG_
#include "eventlog.h"
PVOID    gDriverObject;
void RegisterUnload(void *dev);
#endif

#ifdef __REGISTERFORSHUTDOWN__
ULONG    gRegisterForShutdown = 0;
#endif


#ifdef   _ENABLE_LARGELUN_
ULONG    gMaximumLuns = MAXIMUM_LUN;
ULONG    gEnableLargeLun= 0;
#endif

#ifdef YAM2_1
#include "hhba5100.ver"
#endif

ULONG gDebugPerr = 0;
ULONG gEnablePseudoDevice = 0;
ULONG gMaximumTransferLength=0; 
ULONG gCrashDumping=FALSE;
ULONG gIrqlLevel = 0;

// os adjust parameter cache
OS_ADJUST_PARAM_CACHE hpOsAdjustParamCache;

/* Global Flag to indicate no. of ticks
 * before returning selection time out
 */
ULONG gGlobalIOTimeout = 10;

/*++

Routine Description:

    Installable driver initialization entry point for system.

Arguments:

    Driver Object - pointer ScsiPortxxx routines use to call DriverEntry
    Argument2     - pointer ScsiPortxxx routines use to call DriverEntry

Return Value:

    Status from ScsiPortInitialize()

--*/

ULONG
DriverEntry (
    IN PVOID DriverObject,
    IN PVOID Argument2
    )
{
    ULONG return_value;
   
    DebugPrint((0,"\nIN Agilent DriverEntry %lx %lx PRINT %08x  @ %x\n",DriverObject,Argument2, Global_Print_Level,osTimeStamp(0) ));

    osDEBUGPRINT((ALWAYS_PRINT,"\nIN Agilent DriverEntry %lx %lx  @ %x &Global_Print_Level %lx &hpFcConsoleLevel %lx\n",
        DriverObject,
        Argument2, 
        osTimeStamp(0),
        &Global_Print_Level,
        &hpFcConsoleLevel));

    #ifdef _DEBUG_EVENTLOG_
    gDriverObject = DriverObject;
    InitializeEventLog( DriverObject);
    #endif

    #ifdef _DEBUG_READ_REGISTRY_
    ReadGlobalRegistry(DriverObject);
    #endif
   
    // Initialize drivers and Fc layer
    return_value= HPFibreEntry(DriverObject, Argument2);

    #ifdef _DEBUG_EVENTLOG_
    if (return_value == 0)
    {
        #ifdef HP_NT50    
        RegisterUnload(DriverObject);
        #endif
        LogDriverStarted( DriverObject );
    }
    //
    // Initialize the event log.
    //
    // LogEvent(0, 0,HPFC_MSG_DYNAMIC_STRING, LOG_LEVEL_DEBUG, NULL, 0, NULL);
    // LogEvent(0, 0,HPFC_MSG_DYNAMIC_STRING, LOG_LEVEL_DEBUG, NULL, 0, "Testing Yahoo Yahee ...");
    // LogEvent(0, 0,HPFC_MSG_DYNAMIC_STRING, LOG_LEVEL_DEBUG, NULL, 0, "Next test %d %x %s ...", 2000, 2000, "two thou");

    #endif
   
    osDEBUGPRINT((ALWAYS_PRINT,"OUT Agilent DriverEntry %x\n",return_value));
    return (return_value);

} // end DriverEntry()


/*++

Routine Description:

    This routine is called from DriverEntry if this driver is installable
    or directly from the system if the driver is built into the kernel.
    It calls the OS dependent driver ScsiPortInitialize routine which
    controls the initialization.

Arguments:

    Driver Object - pointer ScsiPortxxx routines use to call DriverEntry
    Argument2     - pointer ScsiPortxxx routines use to call DriverEntry

Return Value:

    Status from ScsiPortInitialize()

--*/
ULONG
HPFibreEntry(
    IN PVOID DriverObject,
    IN PVOID Argument2
    )
{
    HW_INITIALIZATION_DATA hwInitializationData;
    ULONG i;
    // ULONG adapterCount = 0;
    ULONG return_value;
    ULONG cachedMemoryNeeded,Mem_needed;
    ULONG cachedMemoryAlign;
    ULONG dmaMemoryNeeded;
    ULONG dmaMemoryPhyAlign;
    ULONG nvMemoryNeeded;
    ULONG usecsPerTick;
    ULONG dmaMemoryPtrAlign;

    #if defined(HP_PCI_HOT_PLUG)
   // The HotPlugContext is used to pass info between actual HBAs 
   // with Hot Plug Psuedo device.
    HOT_PLUG_CONTEXT  HotPlugContext;      
    ULONG return_value2;
    #endif

    // vendor and device identification
    // ??? should get this from FCLayer
    UCHAR vendorId[4] = {'1', '0', '3', 'C'};
    UCHAR deviceId[4] = {'1', '0', '2', '\0'};

    osDEBUGPRINT((ALWAYS_PRINT,"HPFibreEntry In\n"));

    #if defined(HP_PCI_HOT_PLUG)            //-----------------BEGIN
    // The array in HotPlugcontext is used to contain pointers to device 
    // extensions and a count of the number of HBAs found. The count will 
    // be held in element zero of the array.
    HotPlugContext.extensions[0] = 0;
    #endif                              //----------------------------END

    // zero out structure.
    for (i=0; i<sizeof(HW_INITIALIZATION_DATA); i++) 
    {
        ((PUCHAR)&hwInitializationData)[i] = 0;
    }

    // set size of hwInitializationData.
    hwInitializationData.HwInitializationDataSize =
                                               sizeof(HW_INITIALIZATION_DATA);

    // set entry points.
    hwInitializationData.HwInitialize   =(PHW_INITIALIZE)HPFibreInitialize;
    hwInitializationData.HwFindAdapter  =(PHW_FIND_ADAPTER)HPFibreFindAdapter;
    hwInitializationData.HwStartIo      =(PHW_STARTIO)HPFibreStartIo;
    hwInitializationData.HwInterrupt    =(PHW_INTERRUPT)HPFibreInterrupt;
    hwInitializationData.HwResetBus     =(PHW_RESET_BUS)HPFibreResetBus;

    #if defined(HP_NT50)                //++++++++++++++++++++++++++++BEGIN
    hwInitializationData.HwAdapterControl = (PHW_ADAPTER_CONTROL)HPAdapterControl;
    #endif                              //++++++++++++++++++++++++++++END

    // indicate the number of access ranges that will be used.
    // (ie. reserved, IOBASEL, IOBASEU, Memory, RAMBASE, etc)
    //      1         2        3        4       5

    osDEBUGPRINT((DENT,"IN Num Config Ranges %lx\n",hwInitializationData.NumberOfAccessRanges));
    hwInitializationData.NumberOfAccessRanges = NUMBER_ACCESS_RANGES;

    // indicate the bus type.
    hwInitializationData.AdapterInterfaceType = PCIBus;

    // indicate no buffer mapping but will need physical addresses.
    hwInitializationData.NeedPhysicalAddresses = TRUE;

    // indicate other supported features
    hwInitializationData.AutoRequestSense     = TRUE;

    #ifdef MULTIPLE_IOS_PER_DEVICE          //--------------------------BEGIN
    hwInitializationData.MultipleRequestPerLu = TRUE;
    hwInitializationData.TaggedQueuing        = TRUE;
    #else // NOT MULTIPLE_IOS_PER_DEVICE    //--------------------------ELSE
    hwInitializationData.MultipleRequestPerLu = FALSE;
    hwInitializationData.TaggedQueuing        = FALSE;
    #endif //  MULTIPLE_IOS_PER_DEVICE      //--------------------------END

    // set up HBA identification information. This will be used by the
    // Scsiport driver to call the HwFindAdapter routine for each
    // associated device found.
    hwInitializationData.VendorId       = vendorId;
    hwInitializationData.VendorIdLength = 4;
    hwInitializationData.DeviceId       = deviceId;
    hwInitializationData.DeviceIdLength = 3;

    osZero (&hpOsAdjustParamCache, sizeof(hpOsAdjustParamCache));
    hpOsAdjustParamCache.safeToAccessRegistry = TRUE;

    osDEBUGPRINT((DENT,"Call fcInitializeDriver\n"));
    
    #ifdef OLD_CODE                         
    return_value = fcInitializeDriver (NULL,
                                       &cachedMemoryNeeded,
                                       &cachedMemoryAlign,
                                       &dmaMemoryNeeded,
                                       &dmaMemoryPtrAlign,
                                       &dmaMemoryPhyAlign,
                                       &nvMemoryNeeded,
                                       &usecsPerTick);

    if (return_value)
    {
        osDEBUGPRINT((ALWAYS_PRINT,"Call fcInitializeDriver failed error=%x\n", return_value));
        #ifdef _DEBUG_EVENTLOG_
        LogEvent(NULL, 
                  NULL,
                  HPFC_MSG_INITIALIZEDRIVERFAILED,
                  NULL, 
                  0, 
                  "%xx", return_value);
        #endif
      
        return (return_value);
    }  

    // IWN, IA-64 need 8 byte aligned
    cachedMemoryAlign = 8;
    #endif
    
    
    cachedMemoryAlign = 0;
    cachedMemoryNeeded = 0;

    hpOsAdjustParamCache.safeToAccessRegistry = FALSE;

    // specify size of extensions.
    // Per card  memory ==>> pCard
    #ifndef YAM2_1                                  
    Mem_needed = sizeof(CARD_EXTENSION) +
                 cachedMemoryNeeded +
                 cachedMemoryAlign;
    #else
    gDeviceExtensionSize = OSDATA_SIZE + 
                  cachedMemoryNeeded +
                  cachedMemoryAlign;
      
    Mem_needed =   gDeviceExtensionSize;

    osDEBUGPRINT((ALWAYS_PRINT,"HPFibreEntry: gDeviceExtensionSize is %x\n",gDeviceExtensionSize));
    osDEBUGPRINT((ALWAYS_PRINT,"HPFibreEntry: OSDATA_SIZE is %x \n",OSDATA_SIZE ));
    //osDEBUGPRINT((ALWAYS_PRINT,"cachedMemoryNeeded is %x\n",cachedMemoryNeeded));
    //osDEBUGPRINT((ALWAYS_PRINT,"cachedMemoryAlign is %x\n",cachedMemoryAlign));
    #endif

    hwInitializationData.DeviceExtensionSize     = Mem_needed;
    osDEBUGPRINT((DENT,"DeviceExtensionSize is %x\n",hwInitializationData.DeviceExtensionSize));
    #ifndef YAM2_1
    osDEBUGPRINT((DENT,"OS DeviceExtensionSize is %x\n", sizeof(CARD_EXTENSION)));
    #else
    osDEBUGPRINT((DENT,"OS DeviceExtensionSize is %x\n", gDeviceExtensionSize));
    #endif
    osDEBUGPRINT((DENT,"FC Layer DeviceExtensionSize is %x\n",cachedMemoryNeeded + cachedMemoryAlign));


    // Per logical unit memory ==>> lunExtension
    hwInitializationData.SpecificLuExtensionSize = sizeof(LU_EXTENSION);
    osDEBUGPRINT((DENT,"SpecificLuExtensionSize is %x\n",hwInitializationData.SpecificLuExtensionSize ));
    
    // Per request memory ==>> pSrbExt
    hwInitializationData.SrbExtensionSize        = sizeof(SRB_EXTENSION);
    osDEBUGPRINT((DENT,"SrbExtensionSize  is %x\n",hwInitializationData.SrbExtensionSize ));

    // Initialize calls findadap then adapinit during boot

    osDEBUGPRINT((DENT,"ScsiPortInitialize DriverObject %lx Argument2 %lx\n",
                                            DriverObject,Argument2 ));
    #if defined(HP_PCI_HOT_PLUG)
    // The HotPlugContext is used to pass info between actual HBAs 
    // with Hot Plug Psuedo device.
    return_value = ScsiPortInitialize(DriverObject,
                              Argument2,
                              &hwInitializationData,
                              &HotPlugContext);
    #else
    return_value = ScsiPortInitialize(DriverObject,
                              Argument2,
                              &hwInitializationData,
                              NULL);
    #endif
    osDEBUGPRINT((ALWAYS_PRINT,"HPFibreEntry: ScsiPortInitialize return_value %x\n", return_value));

    #if defined(HP_PCI_HOT_PLUG)

    if (!return_value) 
    {
        //
        // Added to provide use of pseudo controller for PCI Hot Plug IOCTL
        // handling.
        //

        for (i = 0; i < sizeof(HW_INITIALIZATION_DATA); i++) 
        {
            ((PUCHAR) &hwInitializationData)[i] = 0;
        }

        //
        // Fill in the hardware initialization data structure.
        //

        hwInitializationData.HwInitializationDataSize = sizeof(HW_INITIALIZATION_DATA);

        //
        // Set driver entry points.
        //

        hwInitializationData.HwInitialize = (PHW_INITIALIZE)PsuedoInit;
        hwInitializationData.HwStartIo = (PHW_STARTIO)PsuedoStartIo;
        hwInitializationData.HwInterrupt = NULL;
        hwInitializationData.HwResetBus = (PHW_RESET_BUS)PsuedoResetBus;
        hwInitializationData.HwDmaStarted = NULL;
        hwInitializationData.HwAdapterState = NULL;

        //
        // Specify size of extensions.
        //
        hwInitializationData.DeviceExtensionSize = sizeof(PSUEDO_DEVICE_EXTENSION); 
        hwInitializationData.SpecificLuExtensionSize = sizeof(LU_EXTENSION);
        hwInitializationData.SrbExtensionSize = sizeof(SRB_EXTENSION);

        //
        // Initialize other data.
        //
        hwInitializationData.MapBuffers = FALSE;
        hwInitializationData.NeedPhysicalAddresses = TRUE;
        hwInitializationData.TaggedQueuing = FALSE;
        hwInitializationData.AutoRequestSense = FALSE;
        hwInitializationData.ReceiveEvent = FALSE;
        hwInitializationData.MultipleRequestPerLu = TRUE;

        //
        // We are positioning the pseudo device as a PCI based controller,
        // since hot-plug will be supported only in PCI based systems.
        // This pseudo controller will not require any reserved resources.
        // 
        hwInitializationData.AdapterInterfaceType = PCIBus;
        hwInitializationData.NumberOfAccessRanges = 0;
        hwInitializationData.HwFindAdapter = (PHW_FIND_ADAPTER)PsuedoFind;

        HotPlugContext.psuedoDone = FALSE;

        return_value2 = ScsiPortInitialize(DriverObject, Argument2, &hwInitializationData, &HotPlugContext);

        osDEBUGPRINT((ALWAYS_PRINT, "\tPsuedo controller ScsiPortInitialize\t= %0#10x\n", return_value2));
    }

    #endif

    osDEBUGPRINT((ALWAYS_PRINT,"HPFibreEntry Out\n"));

    return (return_value);

} // end HPFibreEntry()


/*++

Routine Description:

    Searches the registry's DriverParameters string for a parameter.  
    String search is case-sensitive.

Arguments:

    Parameter     - NULL-terminated driver parameter string to look for.
    Default       - Default value of driver Parameter
    Min           - Lower legal limit of driver Parameter
    Max            - Upper legal limit of driver Parameter
    ArgumentString   - pointer of string to parse.
    
Return Value:

    Default        - Default return value if ArgumentString's Min, Max value is invalid
    Min         - Lower legal limit of Parameter value
    Max              - Upper legal limit of Parameter value 

--*/
ULONG
GetDriverParameter(
    IN PCHAR Parameter,
    IN ULONG Default,
    IN ULONG Min,
    IN ULONG Max,
    IN PCHAR ArgumentString
    )
{

    USHORT  ParameterValue=0;
    BOOLEAN Done=FALSE;

    UCHAR *RegStr = ArgumentString;
    UCHAR *DrvStr;
   

    if (ArgumentString == NULL)
        return Default;

    while (*RegStr != (UCHAR) NULL) 
    {
        //
        // skip character sets that are meaningless to us
        //
        while (C_isspace(*RegStr))  
        {
            RegStr++;
        }

        if (*RegStr == (UCHAR) NULL) 
        {
            return Default;
        }
        //
        // Start of a non-space character
        //
        DrvStr   =  Parameter;

        while (!(*RegStr == (UCHAR) NULL || *DrvStr == (UCHAR) NULL || C_isspace(*RegStr))) 
        {
            if (*DrvStr != *RegStr) 
            {
                RegStr++;
                break;
            }
            DrvStr++;
            RegStr++;
          
        } //End while (!(*RegStr == (UCHAR) NULL || *DrvStr == (UCHAR) NULL || C_isspace(*RegStr)))

        if (*DrvStr == (UCHAR) NULL) break;

    }//End   while (*RegStr != (UCHAR) NULL)


    //
    // Increment string pointer by one to skip "=" character
    //
    RegStr++;
   
    //
    // Since string compare was successful, we must now check the validity of ArgumentString
    //
    while ( !(*RegStr == (UCHAR) NULL || C_isspace(*RegStr) || !(C_isdigit(*RegStr))  )) 
    {
        if ( ( *RegStr>='0') && (*RegStr <='9') ) 
        {
            ParameterValue = ParameterValue*10 + (*RegStr - '0');
            Done = TRUE;
            RegStr++;
        }
    } //End while (!(*RegStr == (UCHAR) NULL || C_isspace(*RegStr)))

    //
    // if done bit is set, therefore ParameterValue is useable
    //
    if (Done  &&  ((ParameterValue >= Min) && (ParameterValue <= Max)) ) 
    {
        return (ParameterValue);
    } 
    else 
        if (Done  &&  (ParameterValue >= Max)) 
        {
            return (Max);
        } 
        else 
        {
            return (Default); //if no value found, return the Default value.
        }

} //End GetDriverParameter

/*++

Routine Description:

    OS Adjust Parameters:

    If the parameter name is found in the os adjust parameter cache then the
    parameter value of the parameter name is read from the os adjust
    parameter cache.

  
    Parameter value read, is returned if the parameter value is between
    "paramMin" and "paramMax" otherwise "paramDefault" is returned.
  

Arguments:

    pCard - HBA miniport driver's data adapter storage

Return Value:

    TRUE  - if initialization successful.
    FALSE - if initialization unsuccessful.

--*/
os_bit32
osAdjustParameterBit32 (
    agRoot_t *hpRoot,
    char     *paramName,
    os_bit32     paramDefault,
    os_bit32     paramMin,
    os_bit32     paramMax)
{
    os_bit32  x;
    int    found = FALSE;
    PCARD_EXTENSION pCard;
    char * pchar;
    ULONG   numIOs = 4;

    if (gCrashDumping)
    {
        gMaxPaDevices = 16;

        if (osStringCompare(paramName, "NumIOs") == TRUE)
        {
            x = numIOs;
            found = TRUE;
        }
        else if (osStringCompare(paramName, "NumCommandQ") == TRUE)
        {
            x = numIOs;
            found = TRUE;
        }
        else if (osStringCompare(paramName, "NumCompletionQ") == TRUE)
        {
            x = numIOs;
            found = TRUE;
        }
        else if (osStringCompare(paramName, "SizeSGLs") == TRUE)
        {
            x = paramMin;
            found = TRUE;
        }
        else if (osStringCompare(paramName, "NumSGLs") == TRUE)
        {
            x = 4;
            found = TRUE;
        }
        else if (osStringCompare(paramName, "NumTgtCmnds") == TRUE)
        {
            x = 4;
            found = TRUE;
        }
        else if (osStringCompare(paramName, "SF_CMND_Reserve") == TRUE)
        {
            x = 4;
            found = TRUE;
        }
        else if (osStringCompare(paramName, "NumInboundBufferQ") == TRUE)
        {
            x = 32;
            found = TRUE;
        }
        else if (osStringCompare(paramName, "NumDevices") == TRUE)
        {
            x = gMaxPaDevices;
            found = TRUE;
        }

        if (found == TRUE) 
        {
            if (x < paramMin)
                return paramMin;
            else 
                if (x > paramMax)
                    return paramMax;
                else
                    return x;
        } 
        else
            return paramDefault;    
    }

    //
    //  If we can read DriverParameters, we will retrieve the parameters from the Registry instead of the 
    //  "cached" parameters read during DriverEntry
    //
    if (hpRoot) 
    {
        pCard   = (PCARD_EXTENSION)hpRoot->osData;
        if (pCard) 
        {
            pchar = pCard->ArgumentString;    
        
            if (pchar) 
            {
            x = GetDriverParameter(   paramName, paramDefault, paramMin, paramMax, pchar) ;
            osDEBUGPRINT((ALWAYS_PRINT, "\tDriverParameter:%s\tDefault:%x, Min:%x, Max:%x, Return:%x\n", 
                    paramName,
                    paramDefault,
                    paramMin,
                    paramMax,
                    x));
            return x;    
            
        }
        //
        //  When we are at this level in the code, we could not read DriverParameters, i.e we cannot retrieve 
        //  per-host-adapter level parameters from the "cache" (We are already at FindAdapter at this stage)
        //
        else 
            if (RetrieveOsAdjustBit32Entry (paramName, &x)) 
            {
                found = TRUE;
            }
        } // if (pCard) 
    }

    #ifdef _DEBUG_READ_FROM_REGISTRY //+++ DEBUG purpose
    
    else 
        if (  hpOsAdjustParamCache.safeToAccessRegistry &&
            hpOsAdjustParamCache.numBit32Elements < MAX_OS_ADJUST_BIT32_PARAMS) 
        {
            if (ReadFromRegistry (paramName, 0, &x, sizeof (ULONG))) 
            {
                osStringCopy (hpOsAdjustParamCache.bit32Element [
                    hpOsAdjustParamCache.numBit32Elements].paramName,
                    paramName,
                    MAX_OS_ADJUST_PARAM_NAME_LEN - 1);

                hpOsAdjustParamCache.bit32Element [
                    hpOsAdjustParamCache.numBit32Elements].value = x;

                hpOsAdjustParamCache.numBit32Elements++;
                found = TRUE;
            }
        }
    #endif

    if (found == TRUE) 
    {
        if (x < paramMin)
            return paramMin;
        else 
            if (x > paramMax)
                return paramMax;
            else
                return x;
    } 
    else
        return paramDefault;
}

/*++

Routine Description:

    FCLayer Support routine

    If the parameter name is found in the os adjust parameter cache then the
    parameter value of the parameter name is read from the os adjust
    parameter cache.


    Parameter value read, is copied to paramBuffer.

Arguments:
    hpRoot            - card common data
    paramName         - name
    paramBuffer       - buffer
    paramBufLen       - length
   

Return Value:

    none
--*/

void
osAdjustParameterBuffer (
    agRoot_t *hpRoot,
    char     *paramName,
    void     *paramBuffer,
    os_bit32 paramBufLen)
{
    if (RetrieveOsAdjustBufferEntry (paramName, paramBuffer, paramBufLen))
        return;

#ifdef _DEBUG_READ_FROM_REGISTRY //+++ DEBUG purpose
    if (  hpOsAdjustParamCache.safeToAccessRegistry &&
           hpOsAdjustParamCache.numBufferElements < MAX_OS_ADJUST_BUFFER_PARAMS) 
    {
        if (ReadFromRegistry (paramName, 1,
                hpOsAdjustParamCache.bufferElement [hpOsAdjustParamCache.numBufferElements].value,
                (MAX_OS_ADJUST_PARAM_BUFFER_VALUE_LEN - 1))) 
        {
            osStringCopy (hpOsAdjustParamCache.bufferElement [
                    hpOsAdjustParamCache.numBufferElements].paramName,
                    paramName,
                    MAX_OS_ADJUST_PARAM_NAME_LEN - 1);

            osStringCopy (paramBuffer,
                    hpOsAdjustParamCache.bufferElement [
                      hpOsAdjustParamCache.numBufferElements].value,
                    paramBufLen);

            hpOsAdjustParamCache.numBufferElements++;
        }
    }
#endif    
}

/*++

Routine Description:
   This function is used for os adjust parameters of type os_bit32.

   If the parameter name is present in the os adjust parameter cache
   then the parameter value is copied to the address pointed to by the "value"
   parameter and TRUE is returned.

   If the parameter name is not present in the os adjust parameter cache
   then FALSE is returned.


Arguments:
   paramName         - name
   paramBuffer       - buffer
   

Return Value:

   none
--*/
BOOLEAN
RetrieveOsAdjustBit32Entry (
    char  *paramName,
    os_bit32 *value)
{
    int i;

    for (i = 0; i < hpOsAdjustParamCache.numBit32Elements; i++) 
    {
        if (osStringCompare (paramName,
                hpOsAdjustParamCache.bit32Element[i].paramName))
        {
            *value = hpOsAdjustParamCache.bit32Element[i].value;
            return TRUE;
        }
    }

    return FALSE;
}

/*++

Routine Description:
    RetrieveOsAdjustBufferEntry ()

    This function is used for os adjust parameters of type string.

    If the parameter name is present in the os adjust parameter cache
    then the parameter value is copied to the address pointed to by the "value"
    parameter and TRUE is returned.

    If the parameter name is not present in the os adjust parameter cache
    then FALSE is returned.



Arguments:
    paramName         - name
    paramBuffer       - buffer
    paramBufLen       - length
   

Return Value:

    none
--*/
BOOLEAN
RetrieveOsAdjustBufferEntry (
    char  *paramName,
    char  *value,
    int   len)
{
    int i;

    for (i = 0; i < hpOsAdjustParamCache.numBufferElements; i++) 
    {
        if (osStringCompare (paramName,
                hpOsAdjustParamCache.bufferElement[i].paramName))
        {
            osStringCopy (value,hpOsAdjustParamCache.bufferElement[i].value, len);
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\fccint.h ===
/*++

Copyright (c) 2000 Agilent Technologies

Module Name:

   fccint.c

Abstract:

Authors:

Environment:

   kernel mode only

Notes:

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/H/fccint.h $


Revision History:

   $Revision: 3 $
   $Date: 9/07/00 11:57a $
   $Modtime:: 9/07/00 11:57a           $

Notes:


--*/

//fccint.h
/*-------------- Fibre Channel Port Common Interface Definitions -------------*/

#ifndef _FCCI_NT_H //{
#define _FCCI_NT_H

#ifndef _NTDDSCSIH_
   #error You must include ntddscsi.h prior to this header.
#endif

/* FOR REFERENCE - from NTDDSCSI.h

typedef struct _SRB_IO_CONTROL 
{
        ULONG HeaderLength;
        UCHAR Signature[8];
        ULONG Timeout;
        ULONG ControlCode;
        ULONG ReturnCode;
        ULONG Length;
} SRB_IO_CONTROL, *PSRB_IO_CONTROL;

*/

/* 
pSRB->DataBuffer points to a buffer with the following layout and
length of pSRB->DataTransferLength.

  pSRB->DataBuffer
  { 
   SRB_IO_CONTROL Header Structure
   { 
        ULONG HeaderLength;
        UCHAR Signature[8];
        ULONG Timeout;
        ULONG ControlCode;
        ULONG ReturnCode;
        ULONG Length;
   } 

   CommandBuffer (variable in length*, can be of zero length)
   { 
        ....
   } 
  }
  
   * The length of the command buffer is SRB_IO_CONTROL.Length
*/

/*----- SRBCTL Signature -----------------------------------------------------*/
#define FCCI_SIGNATURE_VERSION_01               "FC_CI_01"

#define FCCI_SIGNATURE                          FCCI_SIGNATURE_VERSION_01

/*----- List of Control Codes ------------------------------------------------*/
#define FCCI_SRBCTL_GET_DRIVER_INFO             1
#define FCCI_SRBCTL_GET_ADAPTER_INFO       2
#define FCCI_SRBCTL_GET_ADAPTER_PORT_INFO  3
#define FCCI_SRBCTL_GET_LOGUNIT_INFO       4
#define FCCI_SRBCTL_GET_DEVICE_INFO             5
#define FCCI_SRBCTL_RESET_TARGET           6
#define FCCI_SRBCTL_INIT_EVENT_QUEUE       7
#define FCCI_SRBCTL_TERM_EVENT_QUEUE       8
#define FCCI_SRBCTL_QUEUE_EVENT                 9

/*----- Return Codes ---------------------------------------------------------*/
#define FCCI_RESULT_SUCCESS                     0
#define FCCI_RESULT_HARD_ERROR                  1
#define FCCI_RESULT_TEMP_ERROR                  2
#define FCCI_RESULT_UNKOWN_CTL_CODE             3
#define FCCI_RESULT_INSUFFICIENT_BUFFER         4
#define FCCI_RESULT_INVALID_TARGET              5

/*----- Flags ----------------------------------------------------------------*/
#define FCCI_FLAG_NodeWWN_Valid                 0x00000001
#define FCCI_FLAG_PortWWN_Valid                 0x00000002
#define FCCI_FLAG_NportID_Valid                 0x00000004
#define FCCI_FLAG_LogicalUnit_Valid             0x00000008
#define FCCI_FLAG_TargetAddress_Valid      0x00000010

#define FCCI_FLAG_Logged_In                     0x00000100
#define FCCI_FLAG_Exists                        0x00000200

/*----- Global & Shared data structures and defines --------------------------*/

typedef struct _FCCI_TARGET_ADDRESS 
{
   ULONG     PathId;                  // ULONG to be forward compatible
   ULONG     TargetId;           // ULONG to be forward compatible
   ULONG     Lun;                // ULONG to be forward compatible
} FCCI_TARGET_ADDRESS, *PFCCI_TARGET_ADDRESS;

// FCCI_BufferLengthIsValid
// pDataBuffer: Pointer to data buffer pointer to by the SRB DataBuffer field
//  nDataTransferLength: Length of data buffer from SRB DataTransferLength field
//
// returns:
//      TRUE if buffer length is valid
//      FALSE if buffer length is not valid
__inline 
BOOLEAN 
FCCI_BufferLengthIsValid( PVOID pDataBuffer, ULONG nDataTransferLength )
{
   PSRB_IO_CONTROL pHeader = (PSRB_IO_CONTROL) pDataBuffer;
   
   if ( nDataTransferLength < sizeof(SRB_IO_CONTROL) )
        return FALSE;

   if ( pHeader->HeaderLength < sizeof(SRB_IO_CONTROL) )
        return FALSE;

   if ( pHeader->Length + pHeader->HeaderLength > nDataTransferLength )
        return FALSE;

   return TRUE;
}

// FCCI_GetIOControlHeader
// pDataBuffer: Pointer to data buffer pointer to by the SRB DataBuffer field
//
// returns:
//      A pointer to the SRB_IO_CONTROL structure contained in SRB DataBuffer.
__inline 
PSRB_IO_CONTROL
FCCI_GetIOControlHeader( PVOID pDataBuffer )
{
   return (PSRB_IO_CONTROL) pDataBuffer;
}

// FCCI_GetCommandBuffer
// pDataBuffer: Pointer to data buffer pointer to by the SRB DataBuffer field
//
// returns:
//      A pointer to the command buffer contained in SRB DataBuffer
//      or it can return NULL if not command buffer exists.
__inline 
PVOID 
FCCI_GetCommandBuffer( PVOID pDataBuffer )
{
   PSRB_IO_CONTROL pHeader = (PSRB_IO_CONTROL) pDataBuffer;
   PUCHAR pBuffer = (PUCHAR) pDataBuffer;
   
   if ( pHeader->HeaderLength == 0 )
        return NULL;

   return (PVOID) ( pBuffer + pHeader->HeaderLength );
}

// FCCI_SetSignature
// pHeader:  Pointer to a SRB_IO_CONTROL structure
// pSig:          Pointer to the signature char buffer
__inline 
void 
FCCI_SetSignature( PSRB_IO_CONTROL pHeader, PUCHAR pSig )
{
   *((ULONGLONG*)&pHeader->Signature) = *((ULONGLONG*)&pSig);
}

// FCCI_IsSignature
// pHeader:  Pointer to a SRB_IO_CONTROL structure
// pSig:          Pointer to the signature char buffer
//
// returns:
//      TRUE if signatures match
//      FALSE if they don't
__inline 
BOOLEAN 
FCCI_IsSignature( PSRB_IO_CONTROL pHeader, PUCHAR pSig )
{
   ULONGLONG nSigA, nSigB;

   nSigA = *((ULONGLONG*)&pHeader->Signature);
   nSigB = *((ULONGLONG*)&pSig);

   return (nSigA == nSigB) ? TRUE : FALSE;
}

/*----- FCCI_SRBCTL_GET_DRIVER_INFO - data structures and defines ------------*/
typedef struct _FCCI_DRIVER_INFO_OUT 
{
   // lengths of each character field (number of WCHARs)
   USHORT    DriverNameLength;
   USHORT    DriverDescriptionLength;
   USHORT    DriverVersionLength;
   USHORT    DriverVendorLength;

   // character fields (lengths just previous) follow in this order
   //   WCHAR          DriverName[DriverNameLength];
   //   WCHAR          DriverDescription[DriverDescriptionLength];
   //   WCHAR          DriverVersion[DriverVersionLength];
   //   WCHAR          DriverVendor[DriverVendorLength];
} FCCI_DRIVER_INFO_OUT, *PFCCI_DRIVER_INFO_OUT;

// Used by consumers
#define FCCI_DRIVER_INFO_DEFAULT_SIZE (sizeof(FCCI_DRIVER_INFO) + (sizeof(WCHAR) * 32) * 4)

// !!! IMPORTANT !!!
// If the supplied buffer is not large enough to hold the variable length data
// fill in the non variable length fields and return the request
// with a ResultCode of FCCI_RESULT_INSUFFICIENT_BUFFER.

typedef union _FCCI_DRIVER_INFO 
{       
   // no inbound data
   FCCI_DRIVER_INFO_OUT     out;
} FCCI_DRIVER_INFO, *PFCCI_DRIVER_INFO;

/*----- FCCI_SRBCTL_GET_ADAPTER_INFO - data structures and defines -----------*/
typedef struct _FCCI_ADAPTER_INFO_OUT 
{
   ULONG     PortCount;               // How many ports on adapter?
                                      // The number should reflect the number of
                                      // ports this "miniport" device object controls
                                      // not necessarily the true number of
                                      // of ports on the adapter.

   ULONG     BusCount;           // How many virtual buses on adapter?
   ULONG     TargetsPerBus;      // How many targets supported per bus?
   ULONG     LunsPerTarget;      // How many LUNs supported per target?

   // lengths of each character field (number of WCHARs)
   USHORT    VendorNameLength;
   USHORT    ProductNameLength;
   USHORT    ModelNameLength;
   USHORT    SerialNumberLength;

   // character fields (lengths just previous) follow in this order
   //   WCHAR          VendorName[VendorNameLength];
   //   WCHAR          ProductName[ProductNameLength];
   //   WCHAR          ModelName[ModelNameLength];
   //   WCHAR          SerialNumber[SerialNumberLength];
} FCCI_ADAPTER_INFO_OUT, *PFCCI_ADAPTER_INFO_OUT;

// Used by consumers
#define FCCI_ADAPTER_INFO_DEFAULT_SIZE (sizeof(FCCI_ADAPTER_INFO) + (sizeof(WCHAR) * 32) * 4)

// !!! IMPORTANT !!!
// If the supplied buffer is not large enough to hold the variable length data
// fill in the non variable length fields and return the request
// with a ResultCode of FCCI_RESULT_INSUFFICIENT_BUFFER.

typedef union _FCCI_ADAPTER_INFO 
{       
   // no inbound data
   FCCI_ADAPTER_INFO_OUT    out;
} FCCI_ADAPTER_INFO, *PFCCI_ADAPTER_INFO;

/*----- FCCI_SRBCTL_GET_ADAPTER_PORT_INFO - data structures and defines ------*/
typedef struct _FCCI_ADAPTER_PORT_INFO_IN
{
   ULONG     PortNumber;              // Number of adapter port we want data for
                                      // The index is zero based.
} FCCI_ADAPTER_PORT_INFO_IN, *PFCCI_ADAPTER_PORT_INFO_IN; 

typedef struct _FCCI_ADAPTER_PORT_INFO_OUT
{
   UCHAR     NodeWWN[8];              // Node World Wide Name for adapter port
   UCHAR     PortWWN[8];              // Port World Wide Name for adapter port
   ULONG     NportId;            // Current NportId for adapter port
   ULONG     PortState;               // Current port state
   ULONG     PortTopology;       // Current port topology
   ULONG     Flags;
} FCCI_ADAPTER_PORT_INFO_OUT, *PFCCI_ADAPTER_PORT_INFO_OUT;

// States

// for those that do not support state information
#define FCCI_PORT_STATE_NOT_SUPPORTED      0
// adapter-driver is initializing or resetting  
#define FCCI_PORT_STATE_INITIALIZING       1
// online, connected, and running     
#define FCCI_PORT_STATE_NORMAL                  2
// not connected to anything ("no light", no GBIC, etc.)  
#define FCCI_PORT_STATE_NO_CABLE           3
// connected but in non-participating mode 
#define FCCI_PORT_STATE_NON_PARTICIPATING  4
// adapter has failed (not recoverable)    
#define FCCI_PORT_STATE_HARDWARE_ERROR          5
// adapter firmware or driver has failed (not recoverable)     
#define FCCI_PORT_STATE_SOFTWARE_ERROR          6    

// Topologies

// for those that do not support topology information
#define FCCI_PORT_TOPO_NOT_SUPPORTED  0
// topology is unkown
#define FCCI_PORT_TOPO_UNKOWN              1
// FCAL without switch (NLPort - NLPort - ...)  
#define FCCI_PORT_TOPO_LOOP                2
// FCAL attached to switch (NLPort - FLPort - ...)   
#define FCCI_PORT_TOPO_LOOP_FABRIC         3
// Point-to-Point without switch (NPort - NPort)     
#define FCCI_PORT_TOPO_PTOP                4
// Point-to-Point with switch (NPort - FPort)
#define FCCI_PORT_TOPO_PTOP_FABRIC         5    

typedef union _FCCI_ADAPTER_PORT_INFO 
{       
   FCCI_ADAPTER_PORT_INFO_IN     in;
   FCCI_ADAPTER_PORT_INFO_OUT    out;
} FCCI_ADAPTER_PORT_INFO, *PFCCI_ADAPTER_PORT_INFO;

/*----- FCCI_SRBCTL_GET_LOGUNIT_INFO - data structures and defines -----------*/
typedef struct _FCCI_LOGUNIT_INFO_IN
{
   FCCI_TARGET_ADDRESS TargetAddress; // scsi address to return info about
} FCCI_LOGUNIT_INFO_IN, *PFCCI_LOGUNIT_INFO_IN;

typedef struct _FCCI_LOGUNIT_INFO_OUT
{
   UCHAR     NodeWWN[8];                   // Node World Wide Name for device
   UCHAR     PortWWN[8];                   // Port World Wide Name for device
   ULONG     NportId;                 // Current NportId for device
   USHORT    LogicalUnitNumber[4];    // 8 byte LUN used in FC frame
   ULONG     Flags;
} FCCI_LOGUNIT_INFO_OUT, *PFCCI_LOGUNIT_INFO_OUT;

typedef union _FCCI_LOGUNIT_INFO 
{       
   FCCI_LOGUNIT_INFO_IN     in;
   FCCI_LOGUNIT_INFO_OUT    out;
} FCCI_LOGUNIT_INFO, *PFCCI_LOGUNIT_INFO;

/*----- FCCI_SRBCTL_GET_DEVICE_INFO - data structures and defines ------------*/

typedef struct _FCCI_DEVICE_INFO_ENTRY
{
   UCHAR                    NodeWWN[8];         // Node World Wide Name for device
   UCHAR                    PortWWN[8];         // Port World Wide Name for device
   ULONG                    NportId;       // Current NportId for device
   FCCI_TARGET_ADDRESS TargetAddress; // scsi address
   ULONG                    Flags;
} FCCI_DEVICE_INFO_ENTRY, *PFCCI_DEVICE_INFO_ENTRY;

typedef struct _FCCI_DEVICE_INFO_OUT
{
   ULONG     TotalDevices;       // set to total number of device the adapter
                                      // knows of.

   ULONG     OutListEntryCount;  // set to number of device entries being 
                                      // returned in list (see comment below).

   //FCCI_DEVICE_INFO_ENTRY  entryList[OutListEntryCount];
} FCCI_DEVICE_INFO_OUT, *PFCCI_DEVICE_INFO_OUT;

// !!! IMPORTANT !!!
// If the number of known devices is greater than the list size
// set OutListEntryCount to zero, don't fill in any list entries
// and set TotalDevices to the number of known devices.
// Then complete the FCCI_IOCTL_GET_DEVICE_INFO with a ResultCode
// of FCCI_RESULT_INSUFFICIENT_BUFFER.
// The higher level driver can then allocate a larger buffer and attempt the
// call again (if it wants to).

typedef union _FCCI_DEVICE_INFO
{       
   // no inbound data
   FCCI_DEVICE_INFO_OUT     out;
} FCCI_DEVICE_INFO, *PFCCI_DEVICE_INFO;

/*----- FCCI_SRBCTL_RESET_TARGET - data structures and defines ---------------*/

// inbound buffer will contain a FCCI_TARGET_ADDRESS 
// of the device to reset.

typedef union _FCCI_RESET_TARGET 
{       
   FCCI_TARGET_ADDRESS      in;
   // no outbound data
} FCCI_RESET_TARGET, *PFCCI_RESET_TARGET;


// The following is not yet supported or required...

   /*----- Events - data structures and defines ---------------------------------*/

   typedef struct _FCCI_EVENT_QUEUE_HEAD
   {
        struct  _FCCI_EVENT_QUEUE_HEAD*    NextQueueHead; // link to next queue
        struct  _FCCI_EVENT*               TopEvent; // simple LIFO list (aka Stack)

        ULONG     Extra;    // providers can use how ever they want
   } FCCI_EVENT_QUEUE_HEAD, *PFCCI_EVENT_QUEUE_HEAD;

   /*----- FCCI_SRBCTL_INIT_EVENT_QUEUE - data structures and defines -----------*/

   typedef struct _FCCI_INIT_EVENT_QUEUE_IN
   {
        PFCCI_EVENT_QUEUE_HEAD   QueueHead;     // pointer to queue head to be added
   } FCCI_INIT_EVENT_QUEUE_IN, *PFCCI_INIT_EVENT_QUEUE_IN;

   typedef union _FCCI_INIT_EVENT_QUEUE 
   {         
        FCCI_INIT_EVENT_QUEUE_IN in;
        // no outbound data
   } FCCI_INIT_EVENT_QUEUE, *PFCCI_INIT_EVENT_QUEUE;

   /*----- FCCI_SRBCTL_TERM_EVENT_QUEUE - data structures and defines -----------*/

   // on term complete any queued events with FCCI_EVENT_NO_EVENT

   typedef struct _FCCI_TERM_EVENT_QUEUE_IN
   {
        PFCCI_EVENT_QUEUE_HEAD   QueueHead;     // pointer to queue head to be removed
   } FCCI_TERM_EVENT_QUEUE_IN, *PFCCI_TERM_EVENT_QUEUE_IN;

   typedef union _FCCI_TERM_EVENT_QUEUE 
   {         
        FCCI_TERM_EVENT_QUEUE_IN in;
        // no outbound data
   } FCCI_TERM_EVENT_QUEUE, *PFCCI_TERM_EVENT_QUEUE;

   /*----- FCCI_SRBCTL_QUEUE_EVENT - data structures and defines ----------------*/

   // Events

   // null event (use to clear event queue)
   #define FCCI_EVENT_NO_EVENT                       0
   // new device, device info change, LIP, RSCN, etc.
   #define FCCI_EVENT_DEVICE_INFO_CHANGE        1
   // adapter NportID chagned, etc.
   #define FCCI_EVENT_ADAPTER_INFO_CHANGE       2
   // driver name, version, etc.
   #define FCCI_EVENT_DRIVER_INFO_CHANGE        3

   // No return data payloads have been defined at this time. So set
   // OutDataLength to zero.

   typedef struct _FCCI_EVENT
   {
        PFCCI_EVENT_QUEUE_HEAD   QueueHead;     // pointer to queue head
                                                     // this field is filled in by consumer
                                                     // and must NOT be change by providers
        
        struct  _FCCI_EVENT*     NextEvent;     // used by providers
        PSCSI_REQUEST_BLOCK      RelatedSRB;    // used by providers
        ULONG                         Extra;         // providers can use how ever they want

        ULONG     Event;                        // event type (see list above)
        ULONG     OutDataLength;           // set to size of data returned (if any)

        //UCHAR   data[OutDataLength];     // varible length data follows 
   } FCCI_EVENT, *PFCCI_EVENT;

   typedef union _FCCI_QUEUE_EVENT 
   {         
        FCCI_EVENT     in;
        FCCI_EVENT     out;
   } FCCI_QUEUE_EVENT, *PFCCI_QUEUE_EVENT;

   /*----------------------------------------------------------------------------*/

#endif //ndef'd _FCCI_NT_H //}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\fcmain.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/FCMain.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 10/30/00 6:39p  $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures used by ../C/FCMain.C

--*/

#ifndef __FCMain_H__
#define __FCMain_H__
#define NPORT_STUFF
#define NAME_SERVICES

/* #define USE_XL_Delay_Register */

/* #define  _BYPASSLOOPMAP */


/* #define BROCADE_BUG */
/* #define ONLY_UNTIL_DEVTHREADS_INITIALIZE */
/*+
FC Layer Main Logging Levels
-*/
#define FCMainLogErrorLevel                  0x00000002
#define CFuncLogConsoleERROR                 0x00000004

#ifdef _DvrArch_1_30_
#define IPStateLogErrorLevel                 0x00000005
#define PktStateLogErrorLevel                0x00000005
#endif /* _DvrArch_1_30_ was defined */

#define SFStateLogErrorLevel                 0x00000005
#define TgtStateLogErrorLevel                0x00000005
#define CStateLogConsoleERROR                0x00000005
#define TimerServiceLogErrorLevel            0x00000005
#define QueueLogConsoleERRORLevel            0x00000006
#define CDBStateLogErrorLevel                0x00000007
#define DevStateLogErrorLevel                0x00000007
#define LinkSvcLog_ERROR_Level               0x00000009

#define SF_FCP_LogConsoleLevel               0x00000009

#define CStateLogConsoleShowSEST             0x00000019

#define CStateLogConsoleHideInboundErrors    0x00000009
#define CStateLogConsoleLevelLip             0x00000009

#define LinkSvcLogConsoleLevel               0x00000009

#define LinkSvcLogTraceLevel                 0x00000009

#define CTLogConsoleLevelInfo                0x00000009
#define CTLogConsoleLevel                    0x00000009
#define CTLogTraceLevel                      0x00000009

#define SFStateLogConsoleLevelOne            0x0000000C

#define CStateLogConsoleErrorOverRun         0x0000000C
#define CStateLogConsoleLevelHi              0x0000000C
#define CStateLogConsoleLevelLo              0x0000000E
#define CStateLogConsoleLevel                0x0000000F
#define FCMainLogConsoleLevel                0x00000010
#define FCMainLogConsoleCardSupported        0x00000005
#define CFuncCheckCstateErrorLevel           0x0000000A
#define FlashSvcLogConsoleLevel              0x00000007
#define FlashSvcLogTraceLevel                0x00000007
#define CFuncLogConsolePLOGIPAYLOAD          0x00000017

#define CDBStateAbortPathLevel               0x00000017
#define CDBStateCCC_IOPathLevel              0x00000007

#define MemMapDumpCalculationLogConsoleLevel 0x0000001B
#define TimerServiceLogInfoLevel             0x00000014
#define CDBStateLogOtherErrorLevel           0x00000017

#define SFStateLogConsoleLevel               0x0000001E
#ifdef _DvrArch_1_30_
#define IPStateLogConsoleLevel               0x00000009
#define PktStateLogConsoleLevel              0x00000009
#endif /* _DvrArch_1_30_ was defined */

#define TgtStateLogConsoleLevel              0x00000009

#define DevStateLogConsoleLevel              0x00000020
#define CDBStateLogConsoleLevel              0x00000025
#define QueueLogConsoleLevel                 0x00000026
#define TimerServiceLogConsoleLevel          0x00000190
#define CFuncLogConsoleDefaultLevel          0x00000190

#define QueueLogTraceLevel                   0x00000100

#define StateLogTraceLevel                   0x00000101
#define SF_FCP_LogTraceLevel                 0x00000100
#define LinkSvcLogTraceHideLevel             0x00000109


#define FCMainLogTraceLevel                  0x00000115
#define MemMapDumpCalculationLogTraceLevel   0x00000100

/*+
Useful macros
-*/

#define NEXT_INDEX(index, end)    ((index+1) & (end-1))

#define ERQ_FULL(prodIndex, conIndex, ERQ_LEN) \
                (NEXT_INDEX(prodIndex, ERQ_LEN) == conIndex) ? agTRUE : agFALSE

#define ONE_SECOND (200 * 1000 ) /* During a one microsecond  loop  one second takes 200,000 iterations */

#define Init_FM_Delay_Count (ONE_SECOND * 2)
#define Init_FM_NPORT_Delay_Count (ONE_SECOND * 10)

#define MAX_NO_PROGRESS_DETECTS                 5

#define MAX_PLOGI_TIMEOUTS                      10
#define MAX_FLOGI_TIMEOUTS                      2
#define MAX_FLOGI_RETRYS                        3
#define MAX_fcInitializeChannel_RETRYS          30

#define FC_MAX_RESET_RETRYS                     1
#define FC_MAX_PRLI_REJECT_RETRY                5

#define FC_MAX_ELASTIC_STORE_ERRORS_ALLOWED     90
#define FC_MAX_LIP_F7_ALLOWED                   80
#define FC_MAX_LOST_SIGNALS_ALLOWED             20
#define FC_MAX_LINK_FAILURES_ALLOWED            20
#define FC_MAX_NODE_BY_PASSED_ALLOWED           20
#define FC_MAX_LOSE_OF_SYNC_ALLOWED             20

#define FC_MAX_TRANSMIT_PE_ALLOWED             20
#define FC_MAX_LINK_FAULTS_ALLOWED             20
#define FC_MAX_LST_ALLOWED                     0
#define FRAMEMGR_LINK_DOWN  ( ChipIOUp_Frame_Manager_Status_OS | ChipIOUp_Frame_Manager_Status_LS )
 
#define FRAMEMGR_NPORT_OK ( ChipIOUp_Frame_Manager_Status_LSM_Old_Port | ChipIOUp_Frame_Manager_Status_PSM_ACTIVE )
#define FRAMEMGR_NPORT_LINK_FAIL ( ChipIOUp_Frame_Manager_Status_LSM_Old_Port | ChipIOUp_Frame_Manager_Status_PSM_LF2 | ChipIOUp_Frame_Manager_Status_OS )

#define FRAMEMGR_NPORT_NO_CABLE ( ChipIOUp_Frame_Manager_Status_LSM_Old_Port | ChipIOUp_Frame_Manager_Status_PSM_Offline )

#define BB_CREDIT_SHIFTED( BB_CREDIT) (BB_CREDIT <<  ChipIOUp_Frame_Manager_Configuration_BB_Credit_SHIFT)

/*+
Forward Typedef's
-*/

typedef struct SFThread_s
               SFThread_t;

typedef struct CDBThread_s
               CDBThread_t;

typedef struct DevThread_s
               DevThread_t;

typedef struct TgtThread_s
               TgtThread_t;

#ifdef _DvrArch_1_30_

typedef struct IPThread_s
               IPThread_t;

typedef struct PktThread_s
               PktThread_t;

#endif /* _DvrArch_1_30_ was defined */

typedef struct CThread_s
               CThread_t;

/*+
Linked List Structure Declaration
-*/

typedef struct fiList_s
               fiList_t;

struct fiList_s {
                  fiList_t *flink;
                  fiList_t *blink;
                };
/*+
agTimeOutValue_t Type Declaration
-*/

typedef struct agTimeOutValue_s
               agTimeOutValue_t;

struct agTimeOutValue_s {
                            os_bit32 RT_Tov;
                            os_bit32 ED_Tov;
                            os_bit32 LP_Tov;
                            os_bit32 AL_Time;
                        };


/*+
SFThread Request Type Declaration
-*/

enum SFThread_Request_State_e
     {
       SFThread_Request_InActive,
       SFThread_Request_Pending,
       SFThread_Request_Granted
     };

typedef enum SFThread_Request_State_e
             SFThread_Request_State_t;

typedef struct SFThread_Request_s
               SFThread_Request_t;

struct SFThread_Request_s {
                            fiList_t                  SFThread_Wait_Link;
                            eventRecord_t             eventRecord_to_send;
                            SFThread_t               *SFThread;
                            SFThread_Request_State_t  State;
                          };

/*+
ESGL Request Type Declaration
-*/

enum ESGL_State_e
     {
       ESGL_Request_InActive,
       ESGL_Request_Pending,
       ESGL_Request_Granted
     };

typedef enum ESGL_State_e
             ESGL_State_t;

typedef struct ESGL_Request_s
               ESGL_Request_t;

struct ESGL_Request_s {
                        fiList_t      ESGL_Wait_Link;
                        eventRecord_t eventRecord_to_send;
                        os_bit32      num_ESGL;
                        os_bit32      offsetToFirst;
                        ESGL_State_t  State;
                      };

/*+
Timer Request Type Declaration
-*/

typedef struct fiTime_s
               fiTime_t;

struct fiTime_s {
                  os_bit32 Lo;
                  os_bit32 Hi;
                };

typedef struct fiTimer_Request_s
               fiTimer_Request_t;

struct fiTimer_Request_s {
                           fiList_t      TimerQ_Link;
                           eventRecord_t eventRecord_to_send;
                           fiTime_t      Deadline;
                           agBOOLEAN       Active;
                         };

/*-
Device Slot (Position in Device Handle Array) Type Declaration
-*/

typedef os_bit32 DevSlot_t;

#define DevSlot_Invalid 0xFFFFFFFF

/*-
Device Slot to WWN Mapping Type Declaration
-*/

typedef struct SlotWWN_s
               SlotWWN_t;

struct SlotWWN_s {
                   os_bit8        Slot_Status;
                   os_bit8        Slot_Domain_Address;
                   os_bit8        Slot_Area_Address;
                   os_bit8        Slot_Loop_Address;
                   FC_Port_Name_t Slot_PortWWN;
                 };

#define SlotWWN_Slot_Status_Empty 0
#define SlotWWN_Slot_Status_InUse 1
#define SlotWWN_Slot_Status_Stale 2

/*+
Thread Type Declaration
-*/

#define threadType_SFThread  1
#define threadType_CDBThread 2
#define threadType_DevThread 3
#define threadType_TgtThread 4
#define threadType_CThread   5
#ifdef _DvrArch_1_30_
#define threadType_IPThread  6
#define threadType_PktThread 7
#endif /* _DvrArch_1_30_ was defined */



/*+
SF Thread Structure Declaration
-*/


#define SFThread_SF_CMND_Class_NULL             0x00
#define SFThread_SF_CMND_Class_LinkSvc          0x01
#define SFThread_SF_CMND_Class_SF_FCP           0x02
#define SFThread_SF_CMND_Class_CDB_FCP          0x03
#define SFThread_SF_CMND_Class_CT               0x04
#define SFThread_SF_CMND_Class_FC_Tape          0x05

/* SF ELS types are 0x01 to 0x11 */
#define SFThread_SF_CMND_Type_NULL              0x00
#define SFThread_SF_CMND_Type_CDB               0x81
#define SFThread_SF_CMND_Type_CDB_FC_Tape       0x82

#define SFThread_SF_CMND_State_NULL                     0x00
#define SFThread_SF_CMND_State_CDB_FC_Tape_AllocREC     0x05
#define SFThread_SF_CMND_State_CDB_FC_Tape_REC          0x06
#define SFThread_SF_CMND_State_CDB_FC_Tape_REC2         0x07
#define SFThread_SF_CMND_State_CDB_FC_Tape_SRR          0x08
#define SFThread_SF_CMND_State_CDB_FC_Tape_SRR2         0x09
#define SFThread_SF_CMND_State_CDB_FC_Tape_ReSend       0x0a
#define SFThread_SF_CMND_State_CDB_FC_Tape_GotXRDY      0x0b

#define SFThread_SF_CMND_Status_NULL                        0x00
#define SFThread_SF_CMND_Status_CDB_FC_TapeTargetReSendData 0x11
#define SFThread_SF_CMND_Status_CDB_FC_TapeSRR_Success      0x12
#define SFThread_SF_CMND_Status_CDB_FC_TapeGet_Data         0x13
#define SFThread_SF_CMND_Status_CDB_FC_TapeGet_RSP          0x14
#define SFThread_SF_CMND_Status_CDB_FC_TapeInitiatorReSend_Data        0x15

struct SFThread_s {
                    fi_thread__t                     thread_hdr;
                    fiList_t                         SFLink;
                    union    {
                               fi_thread__t    *unknown;
#ifdef _DvrArch_1_30_
                               PktThread_t *IPPkt;
#endif /* _DvrArch_1_30_ was defined */
                               CDBThread_t *CDB;
                               DevThread_t *Device;
                               TgtThread_t *Target;
                               CThread_t   *Channel;
                             }                       parent;
                    X_ID_t                           X_ID;
                    FCHS_t                          *SF_CMND_Ptr;
                    os_bit32                            SF_CMND_Offset;
                    os_bit32                            SF_CMND_Lower32;
                    os_bit8                             SF_CMND_Class;
                    os_bit8                             SF_CMND_Type;
                    os_bit8                             SF_CMND_State;
                    os_bit8                             SF_CMND_Status;
                    fiTimer_Request_t                Timer_Request;
                    event_t                          QueuedEvent;
                    os_bit8                             SF_REJ_RETRY_COUNT;
                    os_bit8                             RejectReasonCode;
                    os_bit8                             RejectExplanation;

                  };

/*+
CDB Thread Structure Declaration
-*/

#define CDBThread_Read  0
#define CDBThread_Write 1

struct CDBThread_s {
                    fi_thread__t         thread_hdr;
                    fiList_t             CDBLink;
                    DevThread_t        * Device;
                    X_ID_t               X_ID;
                    FCHS_t             * FCP_CMND_Ptr;
                    os_bit32             FCP_CMND_Offset;
                    os_bit32             FCP_CMND_Lower32;
                    os_bit8              CDB_CMND_Class;
                    os_bit8              CDB_CMND_Type;
                    os_bit8              CDB_CMND_State;
                    os_bit8              CDB_CMND_Status;
                    agBOOLEAN            Active; /* Maintain Alignment of structure above these fields with SFThread */
                    agBOOLEAN            ExchActive;
                    agIORequest_t      * hpIORequest;
                    agCDBRequest_t     * CDBRequest;
                    os_bit32             ReadWrite;
                    os_bit32             DataLength;
                    os_bit32             TimeStamp;

                    agBOOLEAN            ReSentIO;
                    agBOOLEAN            ActiveDuringLinkEvent;
                    os_bit32             SentERQ;
                    agBOOLEAN            FC_Tape_Active;
                    os_bit32             FC_Tape_RXID;
                    os_bit32             FC_Tape_HBA_Has_SequenceInitiative;
                    os_bit32             FC_Tape_Last_Count;
                    os_bit32             FC_Tape_REC_Reject_Count;
                    os_bit32             FC_Tape_ExchangeStatusBlock;
                    os_bit32             FC_Tape_CompletionStatus;

                    fiTime_t             CDBStartTimeBase;
                    os_bit32             Lun;
                    os_bit32             CCC_pollingCount;
                    os_bit32             CompletionStatus;
                    SEST_t             * SEST_Ptr;
                    os_bit32             SEST_Offset;
                    FCHS_t             * FCP_RESP_Ptr;
                    os_bit32             FCP_RESP_Offset;
                    os_bit32             FCP_RESP_Lower32;
                    ESGL_Request_t       ESGL_Request;
                    fiList_t             ESGL_Wait_Link;
                    fiTimer_Request_t    Timer_Request;
                    SFThread_Request_t   SFThread_Request;
                    os_bit32             SG_Cache_Offset;
                    os_bit32             SG_Cache_Used;
                    SG_Element_t         SG_Cache[MemMap_SizeCachedSGLs_MIN];
                   };

#define CDBThread_ptr(hpIORequest) ((CDBThread_t *)((hpIORequest)->fcData))

/*+
Device Thread Structure Declaration
-*/

#ifdef Device_IO_Throttle

#define Device_IO_Throttle_Increment pDevThread->DevActive_pollingCount++;
#define Device_IO_Throttle_Initialize pDevThread->DevActive_pollingCount=0;
#define Device_IO_Throttle_Decrement pDevThread->DevActive_pollingCount--;
#define Device_IO_Throttle_Declareation  os_bit32 DevActive_pollingCount;
#define Device_IO_Throttle_MAX_Outstanding_IO       1

#else /* Device_IO_Throttle Not defined */

#define Device_IO_Throttle_Increment
#define Device_IO_Throttle_Initialize
#define Device_IO_Throttle_Decrement
#define Device_IO_Throttle_Declareation

#endif /* Device_IO_Throttle */

struct DevThread_s {
                     fi_thread__t        thread_hdr;
                     fiList_t            DevLink;
                     CThread_t          *Channel;
                     fiList_t            Awaiting_Login_CDBLink;
                     fiList_t            Send_IO_CDBLink;
                     fiList_t            Active_CDBLink_0;
                     fiList_t            Active_CDBLink_1;
                     fiList_t            Active_CDBLink_2;
                     fiList_t            Active_CDBLink_3;
                     fiList_t            TimedOut_CDBLink;
                     DevSlot_t           DevSlot;
                     agFCDevInfo_t       DevInfo;
                     os_bit32            pollingCount;
                     Device_IO_Throttle_Declareation
                     os_bit32            Plogi_Reason_Code;
                     agBOOLEAN           FC_TapeDevice;
                     agBOOLEAN           PRLI_rejected;
                     fiTimer_Request_t   Timer_Request;
                     SFThread_Request_t  SFThread_Request;
                     os_bit32            Failed_Reset_Count;
                     os_bit32            Prev_Active_Device_FLAG;
                     os_bit32            In_Verify_ALPA_FLAG;
                     os_bit32            Lun_Active_Bitmask;
                     FCHS_t              Template_FCHS;
                     IRE_t               Template_SEST_IRE;
                     IWE_t               Template_SEST_IWE;
                     agBOOLEAN           OtherAgilentHBA;
#ifdef __TACHYON_XL_CLASS2
                     agBOOLEAN             GoingClass2;
#endif
#ifdef _DvrArch_1_30_
                     X_ID_t              IP_X_ID;
                     BOOLEAN             NewIPExchange;
#endif /* _DvrArch_1_30_ was defined */
                   };

#define DevThread_ptr(hpFCDev) ((DevThread_t *)(hpFCDev))

#define fiComputeDevThread_D_ID(DevThread)                \
    (  (DevThread->DevInfo.CurrentAddress.Domain << 16)   \
     | (DevThread->DevInfo.CurrentAddress.Area   <<  8)   \
     |  DevThread->DevInfo.CurrentAddress.AL_PA         )

/*+
Target Thread Structure Declaration
-*/

struct TgtThread_s {
                     fi_thread__t            thread_hdr;
                     fiList_t            TgtLink;
                     CThread_t          *Channel;
                     fiTimer_Request_t   Timer_Request;
                     SFThread_Request_t  SFThread_Request;
                     os_bit32               TgtCmnd_Length;
                     FCHS_t              TgtCmnd_FCHS;
                   };

#ifdef _DvrArch_1_30_
/*+
IP Thread Structure Declaration
-*/

struct IPThread_s {
                    fi_thread__t  thread_hdr;
                    DevThread_t  *BroadcastDevice;
                    fiList_t      OutgoingLink;
                    fiList_t      IncomingBufferLink;
		    PktThread_t  *CompletedPkt;
		    void         *osData;
		    struct {
		        os_bit32     LastReported;
		        os_bit32     MostRecent;
		        void         *osData;
		    } LinkStatus;
                  };

/*+
Packet Thread Structure Declaration
-*/

struct PktThread_s {
                     fi_thread__t                     thread_hdr;
                     fiList_t                         PktLink;
                     DevThread_t                     *Device;
                     FCHS_t                          *Pkt_CMND_Ptr;
                     os_bit32                         Pkt_CMND_Offset;
                     os_bit32                         Pkt_CMND_Lower32;
		     os_bit32                         status;
		     void                            *osData;
		     os_bit32                         DataLength;
                     fiTimer_Request_t                Timer_Request;
                     SFThread_Request_t               SFThread_Request;
                   };

#endif /* _DvrArch_1_30_ was defined */

/*+
Declaration of Function Pointers used by Channel Thread Structure
-*/

typedef ERQConsIndex_t (*GetERQConsIndex_t)(
                                             agRoot_t *hpRoot
                                           );

typedef IMQProdIndex_t (*GetIMQProdIndex_t)(
                                             agRoot_t *hpRoot
                                           );

typedef void (*fiFillInFCP_CMND_t)(
                                    CDBThread_t *CDBThread
                                  );

typedef void (*fiFillInFCP_RESP_t)(
                                    CDBThread_t *CDBThread
                                  );

typedef void (*fiFillInFCP_SEST_t)(
                                    CDBThread_t *CDBThread
                                  );

typedef void (*ESGLAlloc_t)(
                             agRoot_t       *hpRoot,
                             ESGL_Request_t *ESGL_Request
                           );

typedef void (*ESGLAllocCancel_t)(
                                   agRoot_t       *hpRoot,
                                   ESGL_Request_t *ESGL_Request
                                 );

typedef void (*ESGLFree_t)(
                            agRoot_t       *hpRoot,
                            ESGL_Request_t *ESGL_Request
                          );

typedef void (*WaitForERQ_t)(
                              agRoot_t *hpRoot
                            );

typedef void (*WaitForERQEmpty_t)(
                                   agRoot_t *hpRoot
                                 );

typedef os_bit32 (*fiFillInPLOGI_t)(
                                  SFThread_t *SFThread
                                );

typedef os_bit32 (*fiFillInFLOGI_t)(
                                  SFThread_t *SFThread
                                );

typedef os_bit32 (*fiFillInLOGO_t)(
                                 SFThread_t *SFThread
                               );

typedef os_bit32 (*fiFillInPRLI_t)(
                                 SFThread_t *SFThread
                               );

typedef os_bit32 (*fiFillInPRLO_t)(
                                 SFThread_t *SFThread
                               );

typedef os_bit32 (*fiFillInADISC_t)(
                                  SFThread_t *SFThread
                                );

typedef os_bit32 (*fiFillInSCR_t)(
                                  SFThread_t *SFThread
                                );

typedef os_bit32 (*fiFillInSRR_t)(
                                  SFThread_t *SFThread,
                                  os_bit32     OXID,
                                  os_bit32     RXID,
                                  os_bit32     Relative_Offset,
                                  os_bit32     R_CTL
                                );
typedef os_bit32 (*fiFillInREC_t)(
                                  SFThread_t *SFThread,
                                  os_bit32       OXID,
                                  os_bit32       RXID
                                );

typedef os_bit32 (*fiLinkSvcProcessSFQ_t)(
                                        agRoot_t        *hpRoot,
                                        SFQConsIndex_t   SFQConsIndex,
                                        os_bit32            Frame_Length,
                                        fi_thread__t       **Thread_to_return
                                      );

typedef os_bit32 (*fiSF_FCP_ProcessSFQ_t)(
                                        agRoot_t        *hpRoot,
                                        SFQConsIndex_t   SFQConsIndex,
                                        os_bit32            Frame_Length,
                                        fi_thread__t       **Thread_to_return
                                      );

typedef os_bit32 (*fiCTProcessSFQ_t)(
                                        agRoot_t        *hpRoot,
                                        SFQConsIndex_t   SFQConsIndex,
                                        os_bit32            Frame_Length,
                                        fi_thread__t       **Thread_to_return
                                      );

typedef void (*updateSESTwithESGLptr_t)(
                                  CDBThread_t *CDBFThread
                                );

typedef void (*fillESGL_t)(
                                  CDBThread_t *CDBFThread
                                );
typedef void (*fillLocalSGL_t)(
                                  CDBThread_t *CDBFThread
                                );

typedef void (*CDBFuncIRB_Init_t)(
                                  CDBThread_t *CDBFThread
                                );


typedef agBOOLEAN (*ProccessIMQ_t)(
                              agRoot_t *hpRoot
                            );

typedef void (*FCPCompletion_t)(

                              agRoot_t *hpRoot,
                              os_bit32 status
                            );

typedef void (*SF_IRB_fill_t)(
                             SFThread_t  * SFThread,
                             os_bit32         SFS_Len,
                             os_bit32         D_ID,
                             os_bit32         DCM_Bit
                            );

#ifdef _DvrArch_1_30_
typedef void (*Pkt_IRB_fill_t)(
                             PktThread_t  * PktThread,
                             os_bit32         PktS_Len,
                             os_bit32         D_ID,
                             os_bit32         DCM_Bit
                            );
#endif /* _DvrArch_1_30_ was defined */

typedef struct CThreadFuncPtrs_s
               CThreadFuncPtrs_t;


struct CThreadFuncPtrs_s {
                           GetERQConsIndex_t       GetERQConsIndex;
                           GetIMQProdIndex_t       GetIMQProdIndex;
                           fiFillInFCP_CMND_t      fiFillInFCP_CMND;
                           fiFillInFCP_RESP_t      fiFillInFCP_RESP;
                           fiFillInFCP_SEST_t      fiFillInFCP_SEST;
                           ESGLAlloc_t             ESGLAlloc;
                           ESGLAllocCancel_t       ESGLAllocCancel;
                           ESGLFree_t              ESGLFree;
                           WaitForERQ_t            WaitForERQ;
                           WaitForERQEmpty_t       WaitForERQEmpty;
                           fiFillInPLOGI_t         fiFillInPLOGI;
                           fiFillInFLOGI_t         fiFillInFLOGI;
                           fiFillInLOGO_t          fiFillInLOGO;
                           fiFillInPRLI_t          fiFillInPRLI;
                           fiFillInPRLO_t          fiFillInPRLO;
                           fiFillInADISC_t         fiFillInADISC;
                           fiFillInSCR_t           fiFillInSCR;                           
                           fiFillInSRR_t           fiFillInSRR;
                           fiFillInREC_t           fiFillInREC;
                           fiLinkSvcProcessSFQ_t   fiLinkSvcProcessSFQ;
                           fiSF_FCP_ProcessSFQ_t   fiSF_FCP_ProcessSFQ;
                           fiCTProcessSFQ_t        fiCTProcessSFQ;
                           updateSESTwithESGLptr_t upSEST;
                           fillESGL_t              fillESGL;
                           fillLocalSGL_t          fillLocalSGL;
                           CDBFuncIRB_Init_t       CDBFuncIRB_Init;
                           ProccessIMQ_t           Proccess_IMQ;
                           FCPCompletion_t         FCP_Completion;
                           SF_IRB_fill_t           SF_IRB_Init;
#ifdef _DvrArch_1_30_
                           Pkt_IRB_fill_t          Pkt_IRB_Init;
#endif /* _DvrArch_1_30_ was defined */
                         };

/* DeviceDiscoveryMethod */
#define DDiscoveryScanAllALPAs            0x00000000
#define DDiscoveryLoopMapReceived         0x00000010
#define DDiscoveryQueriedNameService      0x00000100
#define DDiscoveryPtToPtConnection        0x00001000
#define DDiscoveryMethodInvalid           0xFFFF

/*+
Channel Thread Structure Declaration
-*/

struct CThread_s {
                   fi_thread__t             thread_hdr;
                   DevThread_t             *DeviceSelf;
#ifdef _DvrArch_1_30_
                   IPThread_t              *IP;
#endif /* _DvrArch_1_30_ was defined */
                   fiList_t                 Active_DevLink;
                   fiList_t                 Unknown_Slot_DevLink;
                   fiList_t                 AWaiting_Login_DevLink;
                   fiList_t                 AWaiting_ADISC_DevLink;
                   fiList_t                 Slot_Searching_DevLink;
                   fiList_t                 Prev_Active_DevLink;
                   fiList_t                 Prev_Unknown_Slot_DevLink;
                   fiList_t                 DevSelf_NameServer_DevLink;
                   fiList_t                 RSCN_Recieved_NameServer_DevLink;

                   fiList_t                 QueueFrozenWaitingSFLink;
#ifdef _DvrArch_1_30_
                   fiList_t                 Free_PktLink;
#endif /* _DvrArch_1_30_ was defined */
                   fiList_t                 Free_TgtLink;
                   fiList_t                 Free_DevLink;
                   fiList_t                 Free_CDBLink;
                   fiList_t                 SFThread_Wait_Link;
                   fiList_t                 Free_SFLink;
                   fiList_t                 ESGL_Wait_Link;
                   os_bit32                 Free_ESGL_count;
                   os_bit32                 offsetToFirstFree_ESGL;
                   ERQProdIndex_t           HostCopy_ERQProdIndex;
                   IMQConsIndex_t           HostCopy_IMQConsIndex;
                   agBOOLEAN                sysIntsActive;
                   agBOOLEAN                sysIntsActive_before_fcLeavingOS_call;

                   agBOOLEAN                LaserEnable;
                   agTimeOutValue_t         TimeOutValues;
                   os_bit32                 sysIntsLogicallyEnabled;

                   os_bit32                 From_IMQ_Frame_Manager_Status;
                   os_bit32                 Last_IMQ_Frame_Manager_Status_Message;
                   os_bit32                 CDBpollingCount; /* Removable */
                   os_bit32                 SFpollingCount;
                   os_bit32                 FM_pollingCount; /* Removable */
                   os_bit32                 FindDEV_pollingCount;
                   os_bit32                 NumberOfPlogiTimeouts;
                   os_bit32                 NumberOfFLOGITimeouts;
                   os_bit32                 DEVReset_pollingCount;
                   os_bit32                 ADISC_pollingCount;
                   os_bit32                 FLOGI_pollingCount;
                   os_bit32                 Fabric_pollingCount;
                   agBOOLEAN                Flogi_AllocDone;
                   agBOOLEAN                FlogiTimedOut;

                   agBOOLEAN                PreviouslyAquiredALPA;
                   agBOOLEAN                ALPA_Changed_OnLinkEvent;

                   agBOOLEAN                ProcessingIMQ;
                   agBOOLEAN                LoopPreviousSuccess;
                   agBOOLEAN                Green_LED_State;
                   agBOOLEAN                Yellow_LED_State;
                   agBOOLEAN                flashPresent;

                   agBOOLEAN                JANUS; /* Janus Board type */

                   fiTime_t                 TimeBase;
                   fiTime_t                 LinkDownTime;
                   fiList_t                 TimerQ;
                   fiTimer_Request_t        Timer_Request;

                   agBOOLEAN                InterruptsDelayed;
                   agBOOLEAN                InterruptDelaySuspended;
                   agBOOLEAN                NoStallTimerTickActive;
                   agBOOLEAN                TimerTickActive;
                   os_bit32                 IOsStartedThisTimerTick;
                   os_bit32                 IOsCompletedThisTimerTick;
                   os_bit32                 IOsIntCompletedThisTimerTick;
                   os_bit32                 IOsActive;
                   os_bit32                 IOsActive_LastTick;
                   os_bit32                 IOsActive_No_ProgressCount;
                   os_bit32                 IOsStartedSinceISR;
                   agBOOLEAN                DelayedInterruptActive;

#ifdef __FC_Layer_Loose_IOs
                   os_bit32                 IOsTotalCompleted;
                   os_bit32                 IOsFailedCompeted;
#endif /*  __FC_Layer_Loose_IOs  */

#ifdef _SANMARK_LIP_BACKOFF
                   os_bit32                 TicksTillLIP_Count;
#endif /* _SANMARK_LIP_BACKOFF */ 


#ifdef _Enforce_MaxCommittedMemory_
                   os_bit32                 CommittedMemory;
#endif /* _Enforce_MaxCommittedMemory_ was defined */
                   /* Loopmap derived information */
                   agBOOLEAN                LoopMapFabricFound;
                   agBOOLEAN                LoopMapErrataFound;

                   agBOOLEAN                LoopMapNPortPossible;
                   agBOOLEAN                LoopMapLIRP_Received;

                   agBOOLEAN                XL2DelayActive;

                   os_bit8                  Elastic_Store_ERROR_Count;
                   os_bit8                  Lip_F7_In_tick;
                   os_bit8                  Link_Failures_In_tick;
                   os_bit8                  Lost_Signal_In_tick;

                   os_bit8                  Node_By_Passed_In_tick;
                   os_bit8                  Lost_sync_In_tick;
                   os_bit8                  Transmit_PE_In_tick;
                   os_bit8                  Link_Fault_In_tick;
                   os_bit32                 Loop_State_TimeOut_In_tick;
                   os_bit32                 DeviceDiscoveryMethod;

                   agBOOLEAN                PrimitiveReceived;
                   agBOOLEAN                FoundActiveDevicesBefore;

                   os_bit32                 Loop_Reset_Event_to_Send;
                   os_bit32                 AquiredCredit_Shifted;

                   agBOOLEAN                DirectoryServicesStarted;
                   agBOOLEAN                DirectoryServicesFailed;
                   agBOOLEAN                ReScanForDevices;

                   agBOOLEAN                LOOP_DOWN;
                   agBOOLEAN                IDLE_RECEIVED;
                   agBOOLEAN                OUTBOUND_RECEIVED;
                   agBOOLEAN                ERQ_FROZEN;
                   agBOOLEAN                FCP_FROZEN;
                   agBOOLEAN                FabricLoginRequired;
                   agBOOLEAN                FlogiSucceeded;
                   agBOOLEAN                InitAsNport;
/*
                   agBOOLEAN                RelyOnLossSyncStatus;
*/
                   agBOOLEAN                ConnectedToNportOrFPort;
                   agBOOLEAN                ExpectMoreNSFrames;
                   agBOOLEAN                NS_CurrentBit32Index;
                   agBOOLEAN                RSCNProcessingPending;
                   agBOOLEAN                RSCNreceived;
                   agBOOLEAN                FlogiRcvdFromTarget;
                   agBOOLEAN                TwoGigSuccessfull;
                   os_bit32                 NumberTwoGigFailures;

                   SFThread_Request_t       SFThread_Request;
                   DevThread_t              DirDevThread;
                   os_bit32                 NOS_DetectedInIMQ;

                   os_bit32                 NumberOutstandingFindDevice;
                   os_bit32                 LastSingleThreadedEnterCaller;
                   os_bit32                 LastSingleThreadedLeaveCaller;
                   os_bit32                 LastAsyncSingleThreadedEnterCaller;

                   os_bit32                 VENDID;
                   os_bit32                 DEVID;
                   os_bit32                 REVID;
                   os_bit32                 SVID;

                   FC_F_Port_Name_t         F_Port_Name;
                   FC_Fabric_Name_t         Fabric_Name;
                   FC_F_Port_Common_Parms_t F_Port_Common_Parms;
                   FC_F_Port_Class_Parms_t  F_Port_Class_1_Parms;
                   FC_F_Port_Class_Parms_t  F_Port_Class_2_Parms;
                   FC_F_Port_Class_Parms_t  F_Port_Class_3_Parms;

                   agFCChanInfo_t           ChanInfo;

                   CThreadFuncPtrs_t        FuncPtrs;

                   fiMemMapCalculation_t    Calculation;
                 };

#define CThread_ptr(hpRoot) ((CThread_t *)((hpRoot)->fcData))

#define fiComputeCThread_S_ID(CThread)                   \
    (  (CThread->ChanInfo.CurrentAddress.Domain << 16)   \
     | (CThread->ChanInfo.CurrentAddress.Area   <<  8)   \
     |  CThread->ChanInfo.CurrentAddress.AL_PA         )

/*+
Thread Union Declaration
-*/

typedef union AllThreads_u
              AllThreads_t;

union AllThreads_u {
                     SFThread_t  SFThread;
                     CDBThread_t CDBThread;
                     DevThread_t DevThread;
                     TgtThread_t TgtThread;
#ifdef _DvrArch_1_30_
                     IPThread_t  IPThread;
                     PktThread_t PktThread;
#endif /* _DvrArch_1_30_ was defined */
                     CThread_t   CThread;
                   };


#ifndef _Partial_Log_Debug_String_

#define fiLogDebugString(agRoot,detailLevel,formatString,firstString,secondString,firstPtr,secondPtr,\
                firstBit32,secondBit32,thirdBit32,fourthBit32,                      \
                fifthBit32,sixthBit32,seventhBit32, eighthBit32)                    \
                                                                                    \
    osLogDebugString( agRoot,detailLevel,formatString,firstString,secondString,firstPtr,secondPtr,   \
                firstBit32,secondBit32,thirdBit32,fourthBit32,                      \
                fifthBit32,sixthBit32,seventhBit32, eighthBit32)                    \

#define fiLogString(agRoot,formatString,firstString,secondString,firstPtr,secondPtr,\
                firstBit32,secondBit32,thirdBit32,fourthBit32,                      \
                fifthBit32,sixthBit32,seventhBit32, eighthBit32)                    \
                                                                                    \
    osLogString( agRoot,formatString,firstString,secondString,firstPtr,secondPtr,   \
                firstBit32,secondBit32,thirdBit32,fourthBit32,                      \
                fifthBit32,sixthBit32,seventhBit32, eighthBit32)                    \

#else /* Not _Full_Log_Debug_String_ */

#define fiLogDebugString(agRoot,detailLevel,formatString,firstString,secondString,firstPtr,secondPtr,\
                firstBit32,secondBit32,thirdBit32,fourthBit32,                      \
                fifthBit32,sixthBit32,seventhBit32, eighthBit32)                    \
                                                                                    \

/*                                                                                    \
    osLogDebugString( agRoot,detailLevel,formatString,firstString,secondString,firstPtr,secondPtr,   \
                firstBit32,secondBit32,thirdBit32,fourthBit32,                      \
                fifthBit32,sixthBit32,seventhBit32, eighthBit32)                    \

*/

#define fiLogString(agRoot,formatString,firstString,secondString,firstPtr,secondPtr,\
                firstBit32,secondBit32,thirdBit32,fourthBit32,                      \
                fifthBit32,sixthBit32,seventhBit32, eighthBit32)                    \
                                                                                    \
    osLogString( agRoot,formatString,firstString,secondString,firstPtr,secondPtr,   \
                firstBit32,secondBit32,thirdBit32,fourthBit32,                      \
                fifthBit32,sixthBit32,seventhBit32, eighthBit32)                    \

/*  
    osLogDebugString( agRoot,FCMainLogErrorLevel,formatString,firstString,secondString,firstPtr,secondPtr,   \
                firstBit32,secondBit32,thirdBit32,fourthBit32,                      \
                fifthBit32,sixthBit32,seventhBit32, eighthBit32)                    \
              
*/                                                                                   \

#endif /* End Not _Full_Log_Debug_String_ */

#define fdAbortIO                   1001
#define fdDelayedInterruptHandler   1002
#define fdEnteringOS                1003
#define fdGetChannelInfo            1004
#define fdGetDeviceHandles          1005
#define fdGetDeviceInfo             1006
#define fdInitializeChannel         1007
#define fdLeavingOS                 1008
#define fdResetChannel              1009
#define fdResetDevice               1010
#define fdShutdownChannel           1011
#define fdStartIO                   1012
#define fdSystemInterruptsActive    1013
#define fdTimerTick                 1014
/*
 
#define
*/
#ifndef SingleThreadedDebug
#define fiSingleThreadedEnter(hproot, Caller ) osSingleThreadedEnter( hproot )
#define fiSingleThreadedLeave(hpRoot, Caller ) osSingleThreadedLeave( hpRoot )
#define faSingleThreadedEnter(hproot, Caller ) osSingleThreadedEnter( hproot )
#define faSingleThreadedLeave(hpRoot, Caller ) osSingleThreadedLeave( hpRoot )

#else /* SingleThreadedDebug */

#define fiSingleThreadedEnter(hproot, Caller ) internSingleThreadedEnter( hproot, Caller )
#define fiSingleThreadedLeave(hpRoot, Caller ) internSingleThreadedLeave( hpRoot, Caller )

#define faSingleThreadedEnter(hproot, Caller ) internAsyncSingleThreadedEnter( hproot, Caller )
#define faSingleThreadedLeave(hpRoot, Caller ) internAsyncSingleThreadedLeave( hpRoot, Caller )

#endif /* SingleThreadedDebug */


#endif /* __FCMain_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\fcstruct.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/FCStruct.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 10/03/00 1:55p  $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures generic to Fibre Channel

Reference Documents:

  Fibre Channel       - Physical And Signaling Interface (FC-PH)         - Rev      4.3 - June 1, 1994
  Fibre Channel       - Physical And Signaling Interface - 2 (FC-PH-2)   - Rev      7.4 - September 10, 1996
  Fibre Channel       - Generic Services - 2 (FC-GS-2)                   - dpANS X3.288-199x
  Fibre Channel       - Arbitrated Loop (FC-AL)                          - Rev      4.5
  Fibre Channel       - Arbitrated Loop (FC-AL-2)                        - Rev      5.4
  Information Technology - FibreChannel Protocol for SCSI                - Rev 2 (FCP-2) March 30, 1999
  Information Systems - dpANS Fibre Channel Protocol for SCSI (FCP-SCSI) - Revision 012 - May 30, 1995

--*/

#ifndef __FCStruct_H__
#define __FCStruct_H__

/*+
Frame Format (Section 17, FC-PH)
-*/

#define FC_Frame_Data_Size_Max 2112

/*+
Port ID (Section 18.3, FC-PH
   and Section 18.3, FC-PH-2)
-*/

typedef os_bit32 FC_Port_ID_Bit32_Form_t;

#define FC_Port_ID_Bit32_Form_t_SIZE                                      0x00000004

typedef struct FC_Port_ID_Struct_Form_s
               FC_Port_ID_Struct_Form_t;

#define FC_Port_ID_Struct_Form_t_SIZE                                     0x00000004

struct FC_Port_ID_Struct_Form_s {
                                  os_bit8 reserved;
                                  os_bit8 Domain;
                                  os_bit8 Area;
                                  os_bit8 AL_PA;
                                };

typedef union FC_Port_ID_u
              FC_Port_ID_t;

#define FC_Port_ID_t_SIZE                                                 0x00000004

union FC_Port_ID_u {
                     FC_Port_ID_Bit32_Form_t  Bit32_Form;
                     FC_Port_ID_Struct_Form_t Struct_Form;
                   };

#define FC_Well_Known_Port_ID_Alias_Server                                0x00FFFFF8
#define FC_Well_Known_Port_ID_Quality_of_Service_Facilitator_Class_4      0x00FFFFF9
#define FC_Well_Known_Port_ID_Management_Server                           0x00FFFFFA
#define FC_Well_Known_Port_ID_Time_Server                                 0x00FFFFFB
#define FC_Well_Known_Port_ID_Directory_Server                            0x00FFFFFC
#define FC_Well_Known_Port_ID_Fabric_Controller                           0x00FFFFFD
#define FC_Well_Known_Port_ID_Fabric_F_Port                               0x00FFFFFE
#define FC_Well_Known_Port_ID_Broadcast_Alias_ID                          0x00FFFFFF
#ifdef _DvrArch_1_30_
#define FC_Broadcast_Replicate_AL_PA                                      0x000000FF
#endif /* _DvrArch_1_30_ was defined */

/*+
Frame Header (Section 18, FC-PH
        and Section 18, FC-PH-2)
-*/

typedef struct FC_Frame_Header_s
               FC_Frame_Header_t;

#define FC_Frame_Header_t_SIZE                                            0x00000018

struct FC_Frame_Header_s
       {
         os_bit32 R_CTL__D_ID;
         os_bit32 CS_CTL__S_ID;
         os_bit32 TYPE__F_CTL;
         os_bit32 SEQ_ID__DF_CTL__SEQ_CNT;
         os_bit32 OX_ID__RX_ID;
         os_bit32 Parameter;
       };

#define FC_Frame_Header_R_CTL_Hi_MASK                                     0xF0000000
#define FC_Frame_Header_R_CTL_Lo_MASK                                     0x0F000000
#define FC_Frame_Header_R_CTL_MASK                                        (FC_R_CTL_Hi_MASK | FC_R_CTL_Lo_MASK)

#define FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame                   0x00000000
#define FC_Frame_Header_R_CTL_Hi_Extended_Link_Data_Frame                 0x20000000
#define FC_Frame_Header_R_CTL_Hi_FC_4_Link_Data_Frame                     0x30000000
#define FC_Frame_Header_R_CTL_Hi_Video_Data_Frame                         0x40000000
#define FC_Frame_Header_R_CTL_Hi_Basic_Link_Data_Frame                    0x80000000
#define FC_Frame_Header_R_CTL_Hi_Link_Control_Frame                       0xC0000000

#define FC_Frame_Header_R_CTL_Lo_Uncategorized_Information                0x00000000
#define FC_Frame_Header_R_CTL_Lo_Solicited_Data                           0x01000000
#define FC_Frame_Header_R_CTL_Lo_Unsolicited_Control                      0x02000000
#define FC_Frame_Header_R_CTL_Lo_Solicited_Control                        0x03000000
#define FC_Frame_Header_R_CTL_Lo_Unsolicited_Data                         0x04000000
#define FC_Frame_Header_R_CTL_Lo_Data_Descriptor                          0x05000000
#define FC_Frame_Header_R_CTL_Lo_Unsolicited_Command                      0x06000000
#define FC_Frame_Header_R_CTL_Lo_Command_Status                           0x07000000

#define FC_Frame_Header_R_CTL_Lo_BLS_NOP                                  0x00000000
#define FC_Frame_Header_R_CTL_Lo_BLS_ABTS                                 0x01000000
#define FC_Frame_Header_R_CTL_Lo_BLS_RMC                                  0x02000000
#define FC_Frame_Header_R_CTL_Lo_BLS_BA_ACC                               0x04000000
#define FC_Frame_Header_R_CTL_Lo_BLS_BA_RJT                               0x05000000

#define FC_Frame_Header_R_CTL_Lo_LC_ACK_1                                 0x00000000
#define FC_Frame_Header_R_CTL_Lo_LC_ACK_N                                 0x01000000
#define FC_Frame_Header_R_CTL_Lo_LC_ACK_0                                 0x01000000
#define FC_Frame_Header_R_CTL_Lo_LC_P_RJT                                 0x02000000
#define FC_Frame_Header_R_CTL_Lo_LC_F_RJT                                 0x03000000
#define FC_Frame_Header_R_CTL_Lo_LC_P_BSY                                 0x04000000
#define FC_Frame_Header_R_CTL_Lo_LC_F_BSY_to_Data_Frame                   0x05000000
#define FC_Frame_Header_R_CTL_Lo_LC_F_BSY_to_Link_Control_Frame           0x06000000
#define FC_Frame_Header_R_CTL_Lo_LC_LCR                                   0x07000000

#define FC_Frame_Header_CS_CTL_MASK                                       0xFF000000

#define FC_Frame_Header_CS_CTL_Class_1_Simplex                            0x80000000
#define FC_Frame_Header_CS_CTL_Class_1_SCR                                0x40000000
#define FC_Frame_Header_CS_CTL_Class_1_COR                                0x20000000
#define FC_Frame_Header_CS_CTL_Class_1_BCR                                0x10000000

#define FC_Frame_Header_S_ID_MASK                                         0x00FFFFFF

#define FC_Frame_Header_D_ID_MASK                                         0x00FFFFFF

#define FC_Frame_Header_TYPE_MASK                                         0xFF000000

#define FC_Frame_Header_TYPE_BLS                                          0x00000000 /* FC_R_CTL_Hi_Basic_Link_Data_Frame or */
#define FC_Frame_Header_TYPE_ELS                                          0x01000000 /* FC_R_CTL_Hi_Extended_Link_Data_Frame */

#define FC_Frame_Header_TYPE_8802_2_LLC_In_Order                          0x04000000 /* FC_R_CTL_Hi_FC_4_Link_Data_Frame  or */
#define FC_Frame_Header_TYPE_8802_2_LLC_SNAP                              0x05000000 /* FC_R_CTL_Hi_FC_4_Device_Data_Frame   */
#define FC_Frame_Header_TYPE_SCSI_FCP                                     0x08000000 /*            "            "            */
#define FC_Frame_Header_TYPE_SCSI_GPP                                     0x09000000 /*            "            "            */
#define FC_Frame_Header_TYPE_IPI_3_Master                                 0x11000000 /*            "            "            */
#define FC_Frame_Header_TYPE_IPI_3_Slave                                  0x12000000 /*            "            "            */
#define FC_Frame_Header_TYPE_IPI_3_Peer                                   0x13000000 /*            "            "            */
#define FC_Frame_Header_TYPE_CP_IPI_3_Master                              0x15000000 /*            "            "            */
#define FC_Frame_Header_TYPE_CP_IPI_3_Slave                               0x16000000 /*            "            "            */
#define FC_Frame_Header_TYPE_CP_IPI_3_Peer                                0x17000000 /*            "            "            */
#define FC_Frame_Header_TYPE_SBCCS_Channel                                0x19000000 /*            "            "            */
#define FC_Frame_Header_TYPE_SBCCS_Control_Unit                           0x1A000000 /*            "            "            */
#define FC_Frame_Header_TYPE_Fibre_Channel_Services                       0x20000000 /*            "            "            */
#define FC_Frame_Header_TYPE_FC_FG                                        0x21000000 /*            "            "            */
#define FC_Frame_Header_TYPE_FC_XS                                        0x22000000 /*            "            "            */
#define FC_Frame_Header_TYPE_FC_AL                                        0x23000000 /*            "            "            */
#define FC_Frame_Header_TYPE_SNMP                                         0x24000000 /*            "            "            */
#define FC_Frame_Header_TYPE_HIPPI_FP                                     0x40000000 /*            "            "            */
#define FC_Frame_Header_TYPE_Fabric_Controller                            0x5D000000 /*            "            "            */

#define FC_Frame_Header_F_CTL_MASK                                        0x00FFFFFF

#define FC_Frame_Header_F_CTL_Exchange_Context_Originator                 0x00000000
#define FC_Frame_Header_F_CTL_Exchange_Context_Responder                  0x00800000
#define FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK  (FC_Frame_Header_F_CTL_Exchange_Context_Originator | FC_Frame_Header_F_CTL_Exchange_Context_Responder)

#define FC_Frame_Header_F_CTL_Sequence_Context_Initiator                  0x00000000
#define FC_Frame_Header_F_CTL_Sequence_Context_Recipient                  0x00400000
#define FC_Frame_Header_F_CTL_Sequence_Context_Initiator_Recipient_MASK   (FC_Frame_Header_F_CTL_Sequence_Context_Initiator | FC_Frame_Header_F_CTL_Sequence_Context_Recipient)

#define FC_Frame_Header_F_CTL_First_Sequence                              0x00200000

#define FC_Frame_Header_F_CTL_Last_Sequence                               0x00100000

#define FC_Frame_Header_F_CTL_End_Sequence                                0x00080000

#define FC_Frame_Header_F_CTL_End_Connection                              0x00040000
#define FC_Frame_Header_F_CTL_Deactivate_Class_4_Circuit                  0x00040000

#define FC_Frame_Header_F_CTL_Sequence_Initiative_Hold                    0x00000000
#define FC_Frame_Header_F_CTL_Sequence_Initiative_Transfer                0x00010000

#define FC_Frame_Header_F_CTL_X_ID_Reassigned                             0x00008000

#define FC_Frame_Header_F_CTL_Invalidate_X_ID                             0x00004000

#define FC_Frame_Header_F_CTL_ACK_Form_MASK                               0x00003000
#define FC_Frame_Header_F_CTL_ACK_Form_No_Assistance_Provided             0x00000000
#define FC_Frame_Header_F_CTL_ACK_Form_ACK_1_Required                     0x00001000
#define FC_Frame_Header_F_CTL_ACK_Form_ACK_N_Required                     0x00002000
#define FC_Frame_Header_F_CTL_ACK_Form_ACK_0_Required                     0x00003000

#define FC_Frame_Header_F_CTL_Compressed_Payload                          0x00000800

#define FC_Frame_Header_F_CTL_Retransmitted_Sequence                      0x00000200

#define FC_Frame_Header_F_CTL_Unidirectional_Transmit                     0x00000100
#define FC_Frame_Header_F_CTL_Remove_Class_4_Circuit                      0x00000100

#define FC_Frame_Header_F_CTL_Continue_Sequence_Condition_MASK            0x000000C0
#define FC_Frame_Header_F_CTL_No_Information                              0x00000000
#define FC_Frame_Header_F_CTL_Sequence_to_follow_immediately              0x00000040
#define FC_Frame_Header_F_CTL_Sequence_to_follow_soon                     0x00000080
#define FC_Frame_Header_F_CTL_Sequence_to_follow_delayed                  0x000000C0

#define FC_Frame_Header_F_CTL_Abort_Sequence_Condition_MASK               0x00000030
#define FC_Frame_Header_F_CTL_Continue_Sequence                           0x00000000 /* ACK Frame - Sequence Recipient  */
#define FC_Frame_Header_F_CTL_Abort_Sequence_Perform_ABTS                 0x00000010 /*     "          "         "      */
#define FC_Frame_Header_F_CTL_Stop_Sequence                               0x00000020 /*     "          "         "      */
#define FC_Frame_Header_F_CTL_Immediate_Sequence_Retransmission_Requested 0x00000030 /*     "          "         "      */
#define FC_Frame_Header_F_CTL_Abort_Discard_Multiple_Sequences            0x00000000 /* Data Frame - Sequence Initiator */
#define FC_Frame_Header_F_CTL_Abort_Discard_Single_Sequence               0x00000010 /*     "          "         "      */
#define FC_Frame_Header_F_CTL_Process_Policy_with_Infinite_Buffers        0x00000020 /*     "          "         "      */
#define FC_Frame_Header_F_CTL_Discard_Multiple_Sequences                  0x00000030 /*     "          "         "      */

#define FC_Frame_Header_F_CTL_Relative_Offset_Present                     0x00000008

#define FC_Frame_Header_F_CTL_Fill_Data_Bytes_MASK                        0x00000003
#define FC_Frame_Header_F_CTL_0_Fill_Bytes                                0x00000000
#define FC_Frame_Header_F_CTL_1_Fill_Byte                                 0x00000001
#define FC_Frame_Header_F_CTL_2_Fill_Bytes                                0x00000002
#define FC_Frame_Header_F_CTL_3_Fill_Bytes                                0x00000003

#define FC_Frame_Header_SEQ_ID_MASK                                       0xFF000000

#define FC_Frame_Header_DF_CTL_MASK                                       0x00FF0000

#define FC_Frame_Header_DF_CTL_Expiration_Security_Header                 0x00400000
#define FC_Frame_Header_DF_CTL_Network_Header                             0x00200000
#define FC_Frame_Header_DF_CTL_Association_Header                         0x00100000

#define FC_Frame_Header_DF_CTL_Device_Header_MASK                         0x00030000
#define FC_Frame_Header_DF_CTL_No_Device_Header                           0x00000000
#define FC_Frame_Header_DF_CTL_16_Byte_Device_Header                      0x00010000
#define FC_Frame_Header_DF_CTL_32_Byte_Device_Header                      0x00020000
#define FC_Frame_Header_DF_CTL_64_Byte_Device_Header                      0x00030000

#define FC_Frame_Header_SEQ_CNT_MASK                                      0x0000FFFF

#define FC_Frame_Header_OX_ID_MASK                                        0xFFFF0000
#define FC_Frame_Header_OX_ID_SHIFT                                             0x10

#define FC_Frame_Header_RX_ID_MASK                                        0x0000FFFF
#define FC_Frame_Header_RX_ID_SHIFT                                             0x00

/*+
Basic Link Services (Section 21.2, FC-PH)
-*/

typedef struct FC_BA_ACC_Payload_s
               FC_BA_ACC_Payload_t;

#define FC_BA_ACC_Payload_t_SIZE                                          0x0000000C

struct FC_BA_ACC_Payload_s
       {
         os_bit32 SEQ_ID_Validity__SEQ_ID__Reserved;
         os_bit32 OX_ID__RX_ID;
         os_bit32 Low_SEQ_CNT__High_SEQ_CNT;
       };

#define FC_BA_ACC_Payload_SEQ_ID_Validity_MASK                            0xFF000000
#define FC_BA_ACC_Payload_SEQ_ID_Invalid                                  0x00000000
#define FC_BA_ACC_Payload_SEQ_ID_Valid                                    0x80000000

#define FC_BA_ACC_Payload_SEQ_ID_MASK                                     0x00FF0000

#define FC_BA_ACC_Payload_OX_ID_MASK                                      0xFFFF0000
#define FC_BA_ACC_Payload_OX_ID_SHIFT                                           0x10

#define FC_BA_ACC_Payload_RX_ID_MASK                                      0x0000FFFF
#define FC_BA_ACC_Payload_RX_ID_SHIFT                                           0x00

#define FC_BA_ACC_Payload_Low_SEQ_CNT_MASK                                0xFFFF0000
#define FC_BA_ACC_Payload_Low_SEQ_CNT_SHIFT                                     0x10

#define FC_BA_ACC_Payload_High_SEQ_CNT_MASK                               0x0000FFFF
#define FC_BA_ACC_Payload_High_SEQ_CNT_SHIFT                                    0x00

typedef struct FC_BA_RJT_Payload_s
               FC_BA_RJT_Payload_t;

#define FC_BA_RJT_Payload_t_SIZE                                          0x00000004

struct FC_BA_RJT_Payload_s
       {
         os_bit32 Reserved__Reason_Code__Reason_Explanation__Vendor_Unique;
       };

#define FC_BA_RJT_Payload_Reason_Code_MASK                                0x00FF0000
#define FC_BA_RJT_Payload_Reason_Code_Invalid_Command_Code                0x00010000
#define FC_BA_RJT_Payload_Reason_Code_Logical_Error                       0x00030000
#define FC_BA_RJT_Payload_Reason_Code_Logical_Busy                        0x00050000
#define FC_BA_RJT_Payload_Reason_Code_Protocol_Error                      0x00070000
#define FC_BA_RJT_Payload_Reason_Code_Unable_To_Perform                   0x00090000
#define FC_BA_RJT_Payload_Reason_Code_Vendor_Unique_Error                 0x00FF0000

#define FC_BA_RJT_Payload_Reason_Explanation_MASK                         0x0000FF00
#define FC_BA_RJT_Payload_Reason_Explanation_No_Additional_Explanation    0x00000000
#define FC_BA_RJT_Payload_Reason_Explanation_Invalid_OX_ID_RX_ID_Combo    0x00000300
#define FC_BA_RJT_Payload_Reason_Explanation_Sequence_Aborted__No_Info    0x00000500

/*+
Login and Service Parameters (Section 23, FC-PH
                        and Section 23, FC-PH-2)
-*/

typedef struct FC_N_Port_Common_Parms_s
               FC_N_Port_Common_Parms_t;

#define FC_N_Port_Common_Parms_t_SIZE                                     0x00000010

struct FC_N_Port_Common_Parms_s
       {
         os_bit32 FC_PH_Version__BB_Credit;
         os_bit32 Common_Features__BB_Recv_Data_Field_Size;
         os_bit32 N_Port_Total_Concurrent_Sequences__RO_by_Info_Category;
         os_bit32 E_D_TOV;
       };

#define FC_N_Port_Common_Parms_Highest_Version_MASK                       0xFF000000
#define FC_N_Port_Common_Parms_Highest_Version_SHIFT                            0x18

#define FC_N_Port_Common_Parms_Lowest_Version_MASK                        0x00FF0000
#define FC_N_Port_Common_Parms_Lowest_Version_SHIFT                             0x10

#define FC_N_Port_Common_Parms_Version_4_0                                      0x06
#define FC_N_Port_Common_Parms_Version_4_1                                      0x07
#define FC_N_Port_Common_Parms_Version_4_2                                      0x08
#define FC_N_Port_Common_Parms_Version_4_3                                      0x09
/*
was  #define FC_N_Port_Common_Parms_Version_FC_PH_2                             0x10
*/
#define FC_N_Port_Common_Parms_Version_FC_PH_2                                  0x20

#define FC_N_Port_Common_Parms_BB_Credit_MASK                             0x0000FFFF
#define FC_N_Port_Common_Parms_BB_Credit_SHIFT                                  0x00

#define FC_N_Port_Common_Parms_Continuously_Increasing_Supported          0x80000000
#define FC_N_Port_Common_Parms_Random_Relative_Offset_Supported           0x40000000
#define FC_N_Port_Common_Parms_Valid_Vendor_Version_Level                 0x20000000

#define FC_N_Port_Common_Parms_N_Port_F_Port_MASK                         0x10000000
#define FC_N_Port_Common_Parms_N_Port                                     0x00000000
#define FC_N_Port_Common_Parms_F_Port                                     0x10000000

#define FC_N_Port_Common_Parms_Alternate_BB_Credit_Management             0x08000000
#define FC_N_Port_Common_Parms_Multicast_Supported                        0x02000000
#define FC_N_Port_Common_Parms_Broadcast_Supported                        0x01000000
#define FC_N_Port_Common_Parms_Dedicated_Simplex_Supported                0x00400000

#define FC_N_Port_Common_Parms_BB_Recv_Data_Field_Size_MASK               0x00000FFF
#define FC_N_Port_Common_Parms_BB_Recv_Data_Field_Size_SHIFT                    0x00

#define FC_N_Port_Common_Parms_Total_Concurrent_Sequences_MASK            0x00FF0000
#define FC_N_Port_Common_Parms_Total_Concurrent_Sequences_SHIFT                 0x10

#define FC_N_Port_Common_Parms_RO_by_Info_Category_MASK                   0x0000FFFF
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_1111                 0x00008000
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_1110                 0x00004000
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_1101                 0x00002000
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_1100                 0x00001000
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_1011                 0x00000800
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_1010                 0x00000400
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_1001                 0x00000200
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_1000                 0x00000100
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_0111                 0x00000080
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_0110                 0x00000040
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_0101                 0x00000020
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_0100                 0x00000010
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_0011                 0x00000008
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_0010                 0x00000004
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_0001                 0x00000002
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_0000                 0x00000001

typedef struct FC_N_Port_Class_Parms_s
               FC_N_Port_Class_Parms_t;

#define FC_N_Port_Class_Parms_t_SIZE                                      0x00000010

struct FC_N_Port_Class_Parms_s
       {
         os_bit32 Class_Validity__Service_Options__Initiator_Control_Flags;
         os_bit32 Recipient_Control_Flags__Receive_Data_Size;
         os_bit32 Concurrent_Sequences__EE_Credit;
         os_bit32 Open_Sequences_per_Exchange;
       };

#define FC_N_Port_Class_Parms_Class_Validity                              0x80000000

#define FC_N_Port_Class_Parms_Service_Options_MASK                        0x7FFF0000
#define FC_N_Port_Class_Parms_Intermix_Requested_or_Functional            0x40000000
#define FC_N_Port_Class_Parms_Stacked_Connect_Requests_Transparent_Mode   0x20000000
#define FC_N_Port_Class_Parms_Stacked_Connect_Requests_Lock_Down_Mode     0x10000000

#define FC_F_Port_Class_Parms_SCR_Support_MASK                            0x30000000
#define FC_F_Port_Class_Parms_SCR_Not_Supported                           0x00000000
#define FC_F_Port_Class_Parms_SCR_Lock_Down_Mode                          0x10000000
#define FC_F_Port_Class_Parms_SCR_Transparent_Mode                        0x20000000
#define FC_F_Port_Class_Parms_SCR_Invalid                                 0x30000000

#define FC_N_Port_Class_Parms_Sequential_Delivery_Requested               0x08000000
#define FC_N_Port_Class_Parms_Dedicated_Simplex_Supported                 0x04000000
#define FC_N_Port_Class_Parms_Dedicated_Camp_On_Supported                 0x02000000
#define FC_N_Port_Class_Parms_Buffered_Class_1_Requested_or_Supported     0x01000000

#define FC_N_Port_Class_Parms_Initiator_Control_MASK                      0x0000FFFF

#define FC_N_Port_Class_Parms_X_ID_Reassignment_MASK                      0x0000C000
#define FC_N_Port_Class_Parms_X_ID_Reassignment_Not_Supported             0x00000000
#define FC_N_Port_Class_Parms_X_ID_Reassignment_Supported                 0x00004000
#define FC_N_Port_Class_Parms_X_ID_Reassignment_Required                  0x0000C000

#define FC_N_Port_Class_Parms_Initial_Process_Associator_MASK             0x00003000
#define FC_N_Port_Class_Parms_Initial_Process_Associator_Not_Supported    0x00000000
#define FC_N_Port_Class_Parms_Initial_Process_Associator_Supported        0x00001000
#define FC_N_Port_Class_Parms_Initial_Process_Associator_Required         0x00003000

#define FC_N_Port_Class_Parms_Initiator_ACK_0_Capable                     0x00000800

#define FC_N_Port_Class_Parms_Initiator_ACK_N_Capable                     0x00000400

#define FC_N_Port_Class_Parms_Recipient_Control_MASK                      0xFFFF0000

#define FC_N_Port_Class_Parms_Recipient_ACK_0_Capable                     0x80000000

#define FC_N_Port_Class_Parms_Recipient_ACK_N_Capable                     0x40000000

#define FC_N_Port_Class_Parms_X_ID_Interlock_Required                     0x20000000

#define FC_N_Port_Class_Parms_Error_Policy_Supported_MASK                 0x18000000
#define FC_N_Port_Class_Parms_Only_Discard_Supported                      0x00000000
#define FC_N_Port_Class_Parms_Both_Discard_and_Process_Supported          0x18000000

#define FC_N_Port_Class_Parms_Categories_per_Sequence_MASK                0x03000000
#define FC_N_Port_Class_Parms_1_Category_per_Sequence                     0x00000000
#define FC_N_Port_Class_Parms_2 Categories_per_Sequence                   0x01000000
#define FC_N_Port_Class_Parms_More_than_2_Categories_per_Sequence         0x03000000

#define FC_N_Port_Class_Parms_Receive_Data_Size_MASK                      0x0000FFFF
#define FC_N_Port_Class_Parms_Receive_Data_Size_SHIFT                           0x00

#define FC_N_Port_Class_Parms_Concurrent_Sequences_MASK                   0xFFFF0000
#define FC_N_Port_Class_Parms_Concurrent_Sequences_SHIFT                        0x10

#define FC_N_Port_Class_Parms_EE_Credit_MASK                              0x00007FFF
#define FC_N_Port_Class_Parms_EE_Credit_SHIFT                                   0x00

#define FC_N_Port_Class_Parms_Open_Sequences_per_Exchange_MASK            0x00FF0000
#define FC_N_Port_Class_Parms_Open_Sequences_per_Exchange_SHIFT                 0x10

typedef struct FC_F_Port_Common_Parms_s
               FC_F_Port_Common_Parms_t;

#define FC_F_Port_Common_Parms_t_SIZE                                     0x00000010

struct FC_F_Port_Common_Parms_s
       {
         os_bit32 FC_PH_Version__BB_Credit;
         os_bit32 Common_Features__BB_Recv_Data_Field_Size;
         os_bit32 R_A_TOV;
         os_bit32 E_D_TOV;
       };

#define FC_F_Port_Common_Parms_Highest_Version_MASK                       0xFF000000
#define FC_F_Port_Common_Parms_Highest_Version_SHIFT                            0x18

#define FC_F_Port_Common_Parms_Lowest_Version_MASK                        0x00FF0000
#define FC_F_Port_Common_Parms_Lowest_Version_SHIFT                             0x10

#define FC_F_Port_Common_Parms_Version_4_0                                      0x06
#define FC_F_Port_Common_Parms_Version_4_1                                      0x07
#define FC_F_Port_Common_Parms_Version_4_2                                      0x08
#define FC_F_Port_Common_Parms_Version_4_3                                      0x09
#define FC_F_Port_Common_Parms_Version_FC_PH_2                                  0x10

#define FC_F_Port_Common_Parms_BB_Credit_MASK                             0x0000FFFF
#define FC_F_Port_Common_Parms_BB_Credit_SHIFT                                  0x00

#define FC_F_Port_Common_Parms_Continuously_Increasing_Supported          0x80000000
#define FC_F_Port_Common_Parms_Random_Relative_Offset_Supported           0x40000000
#define FC_F_Port_Common_Parms_Valid_Vendor_Version_Level                 0x20000000

#define FC_F_Port_Common_Parms_N_Port_F_Port_MASK                         0x10000000
#define FC_F_Port_Common_Parms_N_Port                                     0x00000000
#define FC_F_Port_Common_Parms_F_Port                                     0x10000000

#define FC_F_Port_Common_Parms_Alternate_BB_Credit_Management             0x08000000
#define FC_F_Port_Common_Parms_Multicast_Supported                        0x02000000
#define FC_F_Port_Common_Parms_Broadcast_Supported                        0x01000000
#define FC_F_Port_Common_Parms_Dedicated_Simplex_Supported                0x00400000

#define FC_F_Port_Common_Parms_BB_Recv_Data_Field_Size_MASK               0x00000FFF
#define FC_F_Port_Common_Parms_BB_Recv_Data_Field_Size_SHIFT                    0x00

typedef struct FC_F_Port_Class_Parms_s
               FC_F_Port_Class_Parms_t;

#define FC_F_Port_Class_Parms_t_SIZE                                      0x00000010

struct FC_F_Port_Class_Parms_s
       {
         os_bit32 Class_Validity__Service_Options;
         os_bit32 Reserved_1;
         os_bit32 Reserved_2;
         os_bit32 CR_TOV;
       };

#define FC_F_Port_Class_Parms_Class_Validity                              0x80000000

#define FC_F_Port_Class_Parms_Service_Options_MASK                        0x7FFF0000
#define FC_F_Port_Class_Parms_Intermix_Requested_or_Functional            0x40000000
#define FC_F_Port_Class_Parms_Stacked_Connect_Requests_Transparent_Mode   0x20000000
#define FC_F_Port_Class_Parms_Stacked_Connect_Requests_Lock_Down_Mode     0x10000000

#define FC_F_Port_Class_Parms_SCR_Support_MASK                            0x30000000
#define FC_F_Port_Class_Parms_SCR_Not_Supported                           0x00000000
#define FC_F_Port_Class_Parms_SCR_Lock_Down_Mode                          0x10000000
#define FC_F_Port_Class_Parms_SCR_Transparent_Mode                        0x20000000
#define FC_F_Port_Class_Parms_SCR_Invalid                                 0x30000000

#define FC_F_Port_Class_Parms_Sequential_Delivery_Requested               0x08000000
#define FC_F_Port_Class_Parms_Dedicated_Simplex_Supported                 0x04000000
#define FC_F_Port_Class_Parms_Dedicated_Camp_On_Supported                 0x02000000
#define FC_F_Port_Class_Parms_Buffered_Class_1_Requested_or_Supported     0x01000000

typedef os_bit8 FC_Port_Name_t            [ 8];
typedef os_bit8 FC_N_Port_Name_t          [ 8];
typedef os_bit8 FC_F_Port_Name_t          [ 8];

typedef os_bit8 FC_Node_or_Fabric_Name_t  [ 8];
typedef os_bit8 FC_Node_Name_t            [ 8];
typedef os_bit8 FC_Fabric_Name_t          [ 8];

typedef os_bit8 FC_Vendor_Version_Level_t [16];

#define FC_Port_Name_t_SIZE                                               0x00000008
#define FC_N_Port_Name_t_SIZE                                             0x00000008
#define FC_F_Port_Name_t_SIZE                                             0x00000008

#define FC_Node_or_Fabric_Name_t_SIZE                                     0x00000008
#define FC_Node_Name_t_SIZE                                               0x00000008
#define FC_Fabric_Name_t_SIZE                                             0x00000008

#define FC_Vendor_Version_Level_t_SIZE                                    0x00000010

/*+
Association Header (Section 19.4, FC-PH)
-*/

typedef struct FC_Association_Header_s
               FC_Association_Header_t;

#define FC_Association_Header_t_SIZE                                      0x00000020

struct FC_Association_Header_s
       {
         os_bit32 Validity_Bits;
         os_bit32 Originator_Process_Associator;
         os_bit32 Reserved;
         os_bit32 Responder_Process_Associator;
         os_bit32 Originator_Operation_Associator_Hi;
         os_bit32 Originator_Operation_Associator_Lo;
         os_bit32 Responder_Operation_Associator_Hi;
         os_bit32 Responder_Operation_Associator_Lo;
       };

#define FC_Association_Header_Originator_Process_Associator_Meaningful    0x80000000
#define FC_Association_Header_Responder_Process_Associator_Meaningful     0x40000000
#define FC_Association_Header_Originator_Operation_Associator_Meaningful  0x20000000
#define FC_Association_Header_Responder_Operation_Associator_Meaningful   0x10000000

/*+
Extended Link Services (Sections 21.3-21.5, FC-PH
                 and Sections 21.3-21.19, FC-PH-2
                          and Section 6, FCP-SCSI
                            and Annex A, FCP-SCSI)
-*/

#define FC_ELS_Type_MASK                                                  0xFF000000
#define FC_ELS_Type_LS_RJT                                                0x01000000
#define FC_ELS_Type_ACC                                                   0x02000000
#define FC_ELS_Type_PLOGI                                                 0x03000000
#define FC_ELS_Type_FLOGI                                                 0x04000000
#define FC_ELS_Type_LOGO                                                  0x05000000
#define FC_ELS_Type_ABTX                                                  0x06000000
#define FC_ELS_Type_RCS                                                   0x07000000
#define FC_ELS_Type_RES                                                   0x08000000
#define FC_ELS_Type_RSS                                                   0x09000000
#define FC_ELS_Type_RSI                                                   0x0A000000
#define FC_ELS_Type_ESTS                                                  0x0B000000
#define FC_ELS_Type_ESTC                                                  0x0C000000
#define FC_ELS_Type_ADVC                                                  0x0D000000
#define FC_ELS_Type_RTV                                                   0x0E000000
#define FC_ELS_Type_RLS                                                   0x0F000000
#define FC_ELS_Type_ECHO                                                  0x10000000
#define FC_ELS_Type_TEST                                                  0x11000000
#define FC_ELS_Type_RRQ                                                   0x12000000
#define FC_ELS_Type_REC                                                   0x13000000
#define FC_ELS_Type_SRR                                                   0x14000000
#define FC_ELS_Type_PRLI                                                  0x20000000
#define FC_ELS_Type_PRLO                                                  0x21000000
#define FC_ELS_Type_SCN                                                   0x22000000
#define FC_ELS_Type_TPLS                                                  0x23000000
#define FC_ELS_Type_TPRLO                                                 0x24000000
#define FC_ELS_Type_GAID                                                  0x30000000
#define FC_ELS_Type_FACT                                                  0x31000000
#define FC_ELS_Type_FDACT                                                 0x32000000
#define FC_ELS_Type_NACT                                                  0x33000000
#define FC_ELS_Type_NDACT                                                 0x34000000
#define FC_ELS_Type_QoSR                                                  0x40000000
#define FC_ELS_Type_RVCS                                                  0x41000000
#define FC_ELS_Type_PDISC                                                 0x50000000
#define FC_ELS_Type_FDISC                                                 0x51000000
#define FC_ELS_Type_ADISC                                                 0x52000000
#ifdef _DvrArch_1_30_
#define FC_ELS_Type_FARP_REQ                                              0x54000000
#define FC_ELS_Type_FARP_REPLY                                            0x55000000
#endif /* _DvrArch_1_30_ was defined */

#define FC_ELS_Type_FAN                                                   0x60000000

#define FC_ELS_Type_RSCN                                                  0x61000000
#define FC_ELS_Type_SCR                                                   0x62000000


typedef struct FC_ELS_Unknown_Payload_s
               FC_ELS_Unknown_Payload_t;

#define FC_ELS_Unknown_Payload_t_SIZE                                     0x00000004

struct FC_ELS_Unknown_Payload_s
       {
         os_bit32 ELS_Type; /* & FC_ELS_Type_MASK == FC_ELS_Type_XXX */
       };

typedef struct FC_ELS_LS_RJT_Payload_s
               FC_ELS_LS_RJT_Payload_t;

#define FC_ELS_LS_RJT_Payload_t_SIZE                                      0x00000008

struct FC_ELS_LS_RJT_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_LS_RJT */
         os_bit32 Reason_Code__Reason_Explanation__Vendor_Unique;
       };

#define FC_ELS_LS_RJT_Reason_Code_MASK                                    0x00FF0000
#define FC_ELS_LS_RJT_Reason_Code_Shift                                   16
#define FC_ELS_LS_RJT_Invalid_LS_Command_Code                             0x00010000
#define FC_ELS_LS_RJT_Logical_Error                                       0x00030000
#define FC_ELS_LS_RJT_Logical_Busy                                        0x00050000
#define FC_ELS_LS_RJT_Protocol_Error                                      0x00070000
#define FC_ELS_LS_RJT_Unable_to_perform_command_request                   0x00090000
#define FC_ELS_LS_RJT_Command_Not_Supported                               0x000B0000
#define FC_ELS_LS_RJT_Vendor_Unique_Error                                 0x00FF0000

#define FC_ELS_LS_RJT_Shifted_Invalid_LS_Command_Code              (FC_ELS_LS_RJT_Invalid_LS_Command_Code               >> FC_ELS_LS_RJT_Reason_Code_Shift )
#define FC_ELS_LS_RJT_Shifted_Logical_Error                        (FC_ELS_LS_RJT_Logical_Error                         >> FC_ELS_LS_RJT_Reason_Code_Shift )
#define FC_ELS_LS_RJT_Shifted_Logical_Busy                         (FC_ELS_LS_RJT_Logical_Busy                          >> FC_ELS_LS_RJT_Reason_Code_Shift )
#define FC_ELS_LS_RJT_Shifted_Protocol_Error                       (FC_ELS_LS_RJT_Protocol_Error                        >> FC_ELS_LS_RJT_Reason_Code_Shift )
#define FC_ELS_LS_RJT_Shifted_Unable_to_perform_command_request    (FC_ELS_LS_RJT_Unable_to_perform_command_request     >> FC_ELS_LS_RJT_Reason_Code_Shift )
#define FC_ELS_LS_RJT_Shifted_Command_Not_Supported                (FC_ELS_LS_RJT_Command_Not_Supported                 >> FC_ELS_LS_RJT_Reason_Code_Shift )
#define FC_ELS_LS_RJT_Shifted_Vendor_Unique_Error                  (FC_ELS_LS_RJT_Vendor_Unique_Error                   >> FC_ELS_LS_RJT_Reason_Code_Shift )

#define FC_ELS_LS_RJT_Reason_Explanation_Shift                            8
#define FC_ELS_LS_RJT_Reason_Explanation_MASK                             0x0000FF00
#define FC_ELS_LS_RJT_No_Additional_Explanation                           0x00000000
#define FC_ELS_LS_RJT_Service_Parm_Error_Options                          0x00000100
#define FC_ELS_LS_RJT_Service_Parm_Error_Initiator_Ctl                    0x00000300
#define FC_ELS_LS_RJT_Service_Parm_Error_Recipient_Ctl                    0x00000500
#define FC_ELS_LS_RJT_Service_Parm_Error_Rec_Data_Field_Size              0x00000700
#define FC_ELS_LS_RJT_Service_Parm_Error_Concurrent_Seq                   0x00000900
#define FC_ELS_LS_RJT_Service_Parm_Error_Credit                           0x00000B00
#define FC_ELS_LS_RJT_Invalid_N_Port_F_Port_Name                          0x00000D00
#define FC_ELS_LS_RJT_Invalid_Node_Fabric_Name                            0x00000E00
#define FC_ELS_LS_RJT_Invalid_Common_Service_Parameters                   0x00000F00
#define FC_ELS_LS_RJT_Invalid_Association_Header                          0x00001100
#define FC_ELS_LS_RJT_Association_Header_Required                         0x00001300
#define FC_ELS_LS_RJT_Invalid_Originator_S_ID                             0x00001500
#define FC_ELS_LS_RJT_Invalid_OX_ID_RX_ID_Combination                     0x00001700
#define FC_ELS_LS_RJT_Command_Request_Already_In_Progress                 0x00001900
#define FC_ELS_LS_RJT_Invalid_N_Port_Identifier                           0x00001F00
#define FC_ELS_LS_RJT_Invalid_SEQ_ID                                      0x00002100
#define FC_ELS_LS_RJT_Attempt_to_Abort_Invalid_Exchange                   0x00002300
#define FC_ELS_LS_RJT_Attempt_to_Abort_Inactive_Exchange                  0x00002500
#define FC_ELS_LS_RJT_Recovery_Qualifier_Required                         0x00002700
#define FC_ELS_LS_RJT_Insufficient_Resources_to_Support_Login             0x00002900
#define FC_ELS_LS_RJT_Unable_to_Supply_Requested_Data                     0x00002A00
#define FC_ELS_LS_RJT_Request_Not_Supported                               0x00002C00
#define FC_ELS_LS_RJT_No_Alias_IDs_Available_for_this_Alias_Type          0x00003000
#define FC_ELS_LS_RJT_Alias_ID_Cannot_Be_Activated__No_Resources          0x00003100
#define FC_ELS_LS_RJT_Alias_ID_Cannot_Be_Activated__Invalid_Alias_ID      0x00003200
#define FC_ELS_LS_RJT_Alias_ID_Cannot_Be_Activated__Does_Not_Exist        0x00003300
#define FC_ELS_LS_RJT_Alias_ID_Cannot_Be_Activated__Resource_Problem      0x00003400
#define FC_ELS_LS_RJT_Service_Parameter_Conflict                          0x00003500
#define FC_ELS_LS_RJT_Invalid_Alias_Token                                 0x00003600
#define FC_ELS_LS_RJT_Unsupported_Alias_Token                             0x00003700
#define FC_ELS_LS_RJT_Alias_Group_Can_Not_Be_Formed                       0x00003800
#define FC_ELS_LS_RJT_QoS_Parm_Error                                      0x00004000
#define FC_ELS_LS_RJT_VC_ID_Not_Found                                     0x00004100
#define FC_ELS_LS_RJT_Insufficient_Resources_For_Class_4_Connection       0x00004200

#define FC_ELS_LS_RJT_Shifted_No_Additional_Explanation                           (FC_ELS_LS_RJT_No_Additional_Explanation >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Service_Parm_Error_Options                          (FC_ELS_LS_RJT_Service_Parm_Error_Options>> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Service_Parm_Error_Initiator_Ctl                    (FC_ELS_LS_RJT_Service_Parm_Error_Initiator_Ctl>> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Service_Parm_Error_Recipient_Ctl                    (FC_ELS_LS_RJT_Service_Parm_Error_Recipient_Ctl >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Service_Parm_Error_Rec_Data_Field_Size              (FC_ELS_LS_RJT_Service_Parm_Error_Rec_Data_Field_Size>> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Service_Parm_Error_Concurrent_Seq                   (FC_ELS_LS_RJT_Service_Parm_Error_Concurrent_Seq >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Service_Parm_Error_Credit                           (FC_ELS_LS_RJT_Service_Parm_Error_Credit >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Invalid_N_Port_F_Port_Name                          (FC_ELS_LS_RJT_Invalid_N_Port_F_Port_Name >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Invalid_Node_Fabric_Name                            (FC_ELS_LS_RJT_Invalid_Node_Fabric_Name >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Invalid_Common_Service_Parameters                   (FC_ELS_LS_RJT_Invalid_Common_Service_Parameters >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Invalid_Association_Header                          (FC_ELS_LS_RJT_Invalid_Association_Header >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Association_Header_Required                         (FC_ELS_LS_RJT_Association_Header_Required >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Invalid_Originator_S_ID                             (FC_ELS_LS_RJT_Invalid_Originator_S_ID >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Invalid_OX_ID_RX_ID_Combination                     (FC_ELS_LS_RJT_Invalid_OX_ID_RX_ID_Combination >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Command_Request_Already_In_Progress                 (FC_ELS_LS_RJT_Command_Request_Already_In_Progress >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Invalid_N_Port_Identifier                           (FC_ELS_LS_RJT_Invalid_N_Port_Identifier >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Invalid_SEQ_ID                                      (FC_ELS_LS_RJT_Invalid_SEQ_ID >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Attempt_to_Abort_Invalid_Exchange                   (FC_ELS_LS_RJT_Attempt_to_Abort_Invalid_Exchange >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Attempt_to_Abort_Inactive_Exchange                  (FC_ELS_LS_RJT_Attempt_to_Abort_Inactive_Exchange >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Recovery_Qualifier_Required                         (FC_ELS_LS_RJT_Recovery_Qualifier_Required >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Insufficient_Resources_to_Support_Login             (FC_ELS_LS_RJT_Insufficient_Resources_to_Support_Login >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Unable_to_Supply_Requested_Data                     (FC_ELS_LS_RJT_Unable_to_Supply_Requested_Data >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Request_Not_Supported                               (FC_ELS_LS_RJT_Request_Not_Supported >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_No_Alias_IDs_Available_for_this_Alias_Type          (FC_ELS_LS_RJT_No_Alias_IDs_Available_for_this_Alias_Type >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Alias_ID_Cannot_Be_Activated__No_Resources          (FC_ELS_LS_RJT_Alias_ID_Cannot_Be_Activated__No_Resources >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Alias_ID_Cannot_Be_Activated__Invalid_Alias_ID      (FC_ELS_LS_RJT_Alias_ID_Cannot_Be_Activated__Invalid_Alias_ID >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Alias_ID_Cannot_Be_Activated__Does_Not_Exist        (FC_ELS_LS_RJT_Alias_ID_Cannot_Be_Activated__Does_Not_Exist >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Alias_ID_Cannot_Be_Activated__Resource_Problem      (FC_ELS_LS_RJT_Alias_ID_Cannot_Be_Activated__Resource_Problem >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Service_Parameter_Conflict                          (FC_ELS_LS_RJT_Service_Parameter_Conflict >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Invalid_Alias_Token                                 (FC_ELS_LS_RJT_Invalid_Alias_Token >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Unsupported_Alias_Token                             (FC_ELS_LS_RJT_Unsupported_Alias_Token >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Alias_Group_Can_Not_Be_Formed                       (FC_ELS_LS_RJT_Alias_Group_Can_Not_Be_Formed >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_QoS_Parm_Error                                      (FC_ELS_LS_RJT_QoS_Parm_Error >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_VC_ID_Not_Found                                     (FC_ELS_LS_RJT_VC_ID_Not_Found >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Insufficient_Resources_For_Class_4_Connection       (FC_ELS_LS_RJT_Insufficient_Resources_For_Class_4_Connection >> FC_ELS_LS_RJT_Reason_Explanation_Shift)

#define FC_ELS_LS_RJT_Vendor_Unique_MASK                                  0x000000FF

typedef struct FC_ELS_ACC_Unknown_Payload_s
               FC_ELS_ACC_Unknown_Payload_t;

#define FC_ELS_ACC_Unknown_Payload_t_SIZE                                 0x00000004

struct FC_ELS_ACC_Unknown_Payload_s
       {
         os_bit32 ELS_Type; /* & FC_ELS_Type_MASK == FC_ELS_Type_ACC */
       };

typedef struct FC_ELS_PLOGI_Payload_s
               FC_ELS_PLOGI_Payload_t;

#define FC_ELS_PLOGI_Payload_t_SIZE                                       0x00000074

struct FC_ELS_PLOGI_Payload_s
       {
         os_bit32                     ELS_Type; /* == FC_ELS_Type_PLOGI */
         FC_N_Port_Common_Parms_t  Common_Service_Parameters;
         FC_N_Port_Name_t          N_Port_Name;
         FC_Node_Name_t            Node_Name;
         FC_N_Port_Class_Parms_t   Class_1_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_2_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_3_Service_Parameters;
         os_bit8                      Reserved[16];
         FC_Vendor_Version_Level_t Vendor_Version_Level;
       };

typedef struct FC_ELS_ACC_PLOGI_Payload_s
               FC_ELS_ACC_PLOGI_Payload_t;

#define FC_ELS_ACC_PLOGI_Payload_t_SIZE                                   0x00000074

struct FC_ELS_ACC_PLOGI_Payload_s
       {
         os_bit32                     ELS_Type; /* == FC_ELS_Type_ACC */
         FC_N_Port_Common_Parms_t  Common_Service_Parameters;
         FC_N_Port_Name_t          N_Port_Name;
         FC_Node_Name_t            Node_Name;
         FC_N_Port_Class_Parms_t   Class_1_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_2_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_3_Service_Parameters;
         os_bit8                      Reserved[16];
         FC_Vendor_Version_Level_t Vendor_Version_Level;
       };

typedef struct FC_ELS_FLOGI_Payload_s
               FC_ELS_FLOGI_Payload_t;

#define FC_ELS_FLOGI_Payload_t_SIZE                                       0x00000074

struct FC_ELS_FLOGI_Payload_s
       {
         os_bit32                     ELS_Type; /* == FC_ELS_Type_FLOGI */
         FC_N_Port_Common_Parms_t  Common_Service_Parameters;
         FC_N_Port_Name_t          N_Port_Name;
         FC_Node_Name_t            Node_Name;
         FC_N_Port_Class_Parms_t   Class_1_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_2_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_3_Service_Parameters;
         os_bit8                      Reserved[16];
         FC_Vendor_Version_Level_t Vendor_Version_Level;
       };

typedef struct FC_ELS_ACC_FLOGI_Payload_s
               FC_ELS_ACC_FLOGI_Payload_t;

#define FC_ELS_ACC_FLOGI_Payload_t_SIZE                                   0x00000074

struct FC_ELS_ACC_FLOGI_Payload_s
       {
         os_bit32                     ELS_Type; /* == FC_ELS_Type_ACC */
         FC_F_Port_Common_Parms_t  Common_Service_Parameters;
         FC_F_Port_Name_t          F_Port_Name;
         FC_Fabric_Name_t          Fabric_Name;
         FC_F_Port_Class_Parms_t   Class_1_Service_Parameters;
         FC_F_Port_Class_Parms_t   Class_2_Service_Parameters;
         FC_F_Port_Class_Parms_t   Class_3_Service_Parameters;
         os_bit8                      Reserved[16];
         FC_Vendor_Version_Level_t Vendor_Version_Level;
       };

typedef struct FC_ELS_LOGO_Payload_s
               FC_ELS_LOGO_Payload_t;

#define FC_ELS_LOGO_Payload_t_SIZE                                        0x00000010

struct FC_ELS_LOGO_Payload_s
       {
         os_bit32          ELS_Type; /* == FC_ELS_Type_LOGO */
         os_bit32          N_Port_Identifier;
         FC_Port_Name_t Port_Name;
       };

#define FC_ELS_LOGO_N_Port_Identifier_MASK                                0x00FFFFFF

typedef struct FC_ELS_ACC_LOGO_Payload_s
               FC_ELS_ACC_LOGO_Payload_t;

#define FC_ELS_ACC_LOGO_Payload_t_SIZE                                    0x00000004

struct FC_ELS_ACC_LOGO_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ACC */
       };
typedef struct FC_ELS_GENERIC_ACC_Payload_s
               FC_ELS_GENERIC_ACC_Payload_t;

#define FC_ELS_GENERIC_ACC_Payload_t_SIZE                                    0x00000004

struct FC_ELS_GENERIC_ACC_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ACC */
       };
typedef struct FC_ELS_ABTX_Payload_s
               FC_ELS_ABTX_Payload_t;

#define FC_ELS_ABTX_Payload_t_SIZE                                        0x0000002C

struct FC_ELS_ABTX_Payload_s
       {
         os_bit32                   ELS_Type; /* == FC_ELS_Type_ABTX */
         os_bit32                   Recovery_Qualifier__Originator_S_ID;
         os_bit32                   OX_ID__RX_ID;
         FC_Association_Header_t Association_Header;
       };

#define FC_ELS_ABTX_Recovery_Qualifier_MASK                               0xFF000000
#define FC_ELS_ABTX_No_Recovery_Qualifier                                 0x00000000
#define FC_ELS_ABTX_Recovery_Qualifier_Required                           0x80000000

#define FC_ELS_ABTX_Originator_S_ID_MASK                                  0x00FFFFFF
#define FC_ELS_ABTX_Originator_S_ID_SHIFT                                       0x00

#define FC_ELS_ABTX_OX_ID_MASK                                            0xFFFF0000
#define FC_ELS_ABTX_OX_ID_SHIFT                                                 0x10

#define FC_ELS_ABTX_RX_ID_MASK                                            0x0000FFFF
#define FC_ELS_ABTX_RX_ID_SHIFT                                                 0x00

typedef struct FC_ELS_ACC_ABTX_Payload_s
               FC_ELS_ACC_ABTX_Payload_t;

#define FC_ELS_ACC_ABTX_Payload_t_SIZE                                    0x00000004

struct FC_ELS_ACC_ABTX_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ACC */
       };

typedef struct FC_ELS_RCS_Payload_s
               FC_ELS_RCS_Payload_t;

#define FC_ELS_RCS_Payload_t_SIZE                                         0x00000008

struct FC_ELS_RCS_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_RCS */
         os_bit32 N_Port_Identifier;
       };

#define FC_ELS_RCS_N_Port_Identifier_MASK                                 0x00FFFFFF

typedef struct FC_ELS_ACC_RCS_Payload_s
               FC_ELS_ACC_RCS_Payload_t;

#define FC_ELS_ACC_RCS_Payload_t_SIZE                                     0x00000008

struct FC_ELS_ACC_RCS_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ACC */
         os_bit32 Completion_Status__N_Port_Identifier;
       };

#define FC_ELS_ACC_RCS_Completion_Status_MASK                             0xFF000000
#define FC_ELS_ACC_RCS_Connect_Request_Delivered                          0x80000000
#define FC_ELS_ACC_RCS_Connect_Request_Stacked                            0x40000000
#define FC_ELS_ACC_RCS_Connection_Established                             0x20000000
#define FC_ELS_ACC_RCS_Intermix_Mode                                      0x10000000

#define FC_ELS_ACC_RCS_N_Port_Identifier_MASK                             0x00FFFFFF

typedef struct FC_ELS_RES_Payload_s
               FC_ELS_RES_Payload_t;

#define FC_ELS_RES_Payload_t_SIZE                                         0x0000002C

struct FC_ELS_RES_Payload_s
       {
         os_bit32                   ELS_Type; /* == FC_ELS_Type_RES */
         os_bit32                   Originator_S_ID;
         os_bit32                   OX_ID__RX_ID;
         FC_Association_Header_t Association_Header;
       };

#define FC_ELS_RES_Originator_S_ID_MASK                                   0x00FFFFFF
#define FC_ELS_RES_Originator_S_ID_SHIFT                                        0x00

#define FC_ELS_RES_OX_ID_MASK                                             0xFFFF0000
#define FC_ELS_RES_OX_ID_SHIFT                                                  0x10

#define FC_ELS_RES_RX_ID_MASK                                             0x0000FFFF
#define FC_ELS_RES_RX_ID_SHIFT                                                  0x00

typedef struct FC_ELS_ACC_RES_Payload_s
               FC_ELS_ACC_RES_Payload_t;

#define FC_ELS_ACC_RES_Payload_t_SIZE                                     0x00000024

struct FC_ELS_ACC_RES_Payload_s
       {
         os_bit32                   ELS_Type; /* == FC_ELS_Type_ACC */
                                 /* Dynamically-sized Exchange Status Block goes here */
         FC_Association_Header_t Association_Header;
       };

typedef struct FC_ELS_RSS_Payload_s
               FC_ELS_RSS_Payload_t;

#define FC_ELS_RSS_Payload_t_SIZE                                         0x0000000C

struct FC_ELS_RSS_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_RSS */
         os_bit32 SEQ_ID__Originator_S_ID;
         os_bit32 OX_ID__RX_ID;
       };

#define FC_ELS_RSS_SEQ_ID_MASK                                            0xFF000000
#define FC_ELS_RSS_SEQ_ID_SHIFT                                                 0x18

#define FC_ELS_RSS_Originator_S_ID_MASK                                   0x00FFFFFF
#define FC_ELS_RSS_Originator_S_ID_SHIFT                                        0x00

#define FC_ELS_RSS_OX_ID_MASK                                             0xFFFF0000
#define FC_ELS_RSS_OX_ID_SHIFT                                                  0x10

#define FC_ELS_RSS_RX_ID_MASK                                             0x0000FFFF
#define FC_ELS_RSS_RX_ID_SHIFT                                                  0x00

typedef struct FC_ELS_ACC_RSS_Payload_s
               FC_ELS_ACC_RSS_Payload_t;

#define FC_ELS_ACC_RSS_Payload_t_SIZE                                     0x00000004

struct FC_ELS_ACC_RSS_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ACC */
               /* Dynamically-sized Sequence Status Block goes here */
       };

typedef struct FC_ELS_RSI_Payload_s
               FC_ELS_RSI_Payload_t;

#define FC_ELS_RSI_Payload_t_SIZE                                         0x0000002C

struct FC_ELS_RSI_Payload_s
       {
         os_bit32                   ELS_Type; /* == FC_ELS_Type_RSI */
         os_bit32                   Originator_S_ID;
         os_bit32                   OX_ID__RX_ID;
         FC_Association_Header_t Association_Header;
       };

#define FC_ELS_RSI_Originator_S_ID_MASK                                   0x00FFFFFF
#define FC_ELS_RSI_Originator_S_ID_SHIFT                                        0x00

#define FC_ELS_RSI_OX_ID_MASK                                             0xFFFF0000
#define FC_ELS_RSI_OX_ID_SHIFT                                                  0x10

#define FC_ELS_RSI_RX_ID_MASK                                             0x0000FFFF
#define FC_ELS_RSI_RX_ID_SHIFT                                                  0x00

typedef struct FC_ELS_ACC_RSI_Payload_s
               FC_ELS_ACC_RSI_Payload_t;

#define FC_ELS_ACC_RSI_Payload_t_SIZE                                     0x00000004

struct FC_ELS_ACC_RSI_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ACC */
       };

typedef struct FC_ELS_ESTS_Payload_s
               FC_ELS_ESTS_Payload_t;

#define FC_ELS_ESTS_Payload_t_SIZE                                        0x00000004

struct FC_ELS_ESTS_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ESTS */
       };

typedef struct FC_ELS_ACC_ESTS_Payload_s
               FC_ELS_ACC_ESTS_Payload_t;

#define FC_ELS_ACC_ESTS_Payload_t_SIZE                                    0x00000074

struct FC_ELS_ACC_ESTS_Payload_s
       {
         os_bit32                     ELS_Type; /* == FC_ELS_Type_ACC */
         FC_N_Port_Common_Parms_t  Common_Service_Parameters;
         FC_N_Port_Name_t          N_Port_Name;
         FC_Node_Name_t            Node_Name;
         FC_N_Port_Class_Parms_t   Class_1_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_2_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_3_Service_Parameters;
         os_bit8                      Reserved[16];
         FC_Vendor_Version_Level_t Vendor_Version_Level;
       };

typedef struct FC_ELS_ESTC_Payload_s
               FC_ELS_ESTC_Payload_t;

#define FC_ELS_ESTC_Payload_t_SIZE                                        FC_Frame_Data_Size_Max

struct FC_ELS_ESTC_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ESTC */
         os_bit8  Any_Data[FC_Frame_Data_Size_Max - sizeof(os_bit32)];
       };

typedef struct FC_ELS_ADVC_Payload_s
               FC_ELS_ADVC_Payload_t;

#define FC_ELS_ADVC_Payload_t_SIZE                                        0x00000074

struct FC_ELS_ADVC_Payload_s
       {
         os_bit32                     ELS_Type; /* == FC_ELS_Type_ADVC */
         FC_N_Port_Common_Parms_t  Common_Service_Parameters;
         FC_N_Port_Name_t          N_Port_Name;
         FC_Node_Name_t            Node_Name;
         FC_N_Port_Class_Parms_t   Class_1_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_2_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_3_Service_Parameters;
         os_bit8                      Reserved[16];
         FC_Vendor_Version_Level_t Vendor_Version_Level;
       };

typedef struct FC_ELS_ACC_ADVC_Payload_s
               FC_ELS_ACC_ADVC_Payload_t;

#define FC_ELS_ACC_ADVC_Payload_t_SIZE                                    0x00000074

struct FC_ELS_ACC_ADVC_Payload_s
       {
         os_bit32                     ELS_Type; /* == FC_ELS_Type_ACC */
         FC_N_Port_Common_Parms_t  Common_Service_Parameters;
         FC_N_Port_Name_t          N_Port_Name;
         FC_Node_Name_t            Node_Name;
         FC_N_Port_Class_Parms_t   Class_1_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_2_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_3_Service_Parameters;
         os_bit8                      Reserved[16];
         FC_Vendor_Version_Level_t Vendor_Version_Level;
       };

typedef struct FC_ELS_RTV_Payload_s
               FC_ELS_RTV_Payload_t;

#define FC_ELS_RTV_Payload_t_SIZE                                         0x00000004

struct FC_ELS_RTV_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_RTV */
       };

typedef struct FC_ELS_ACC_RTV_Payload_s
               FC_ELS_ACC_RTV_Payload_t;

#define FC_ELS_ACC_RTV_Payload_t_SIZE                                     0x0000000C

struct FC_ELS_ACC_RTV_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ACC */
         os_bit32 R_A_TOV;
         os_bit32 E_D_TOV;
       };

typedef struct FC_ELS_RLS_Payload_s
               FC_ELS_RLS_Payload_t;

#define FC_ELS_RLS_Payload_t_SIZE                                         0x00000008

struct FC_ELS_RLS_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_RLS */
         os_bit32 Port_Identifier;
       };

#define FC_ELS_RLS_Port_Identifier_MASK                                   0x00FFFFFF

typedef struct FC_ELS_ACC_RLS_Payload_s
               FC_ELS_ACC_RLS_Payload_t;

#define FC_ELS_ACC_RLS_Payload_t_SIZE                                     0x00000004

struct FC_ELS_ACC_RLS_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ACC */
               /* Link Error Status Block goes here */
       };

typedef struct FC_ELS_ECHO_Payload_s
               FC_ELS_ECHO_Payload_t;

#define FC_ELS_ECHO_Payload_t_SIZE                                        FC_Frame_Data_Size_Max

struct FC_ELS_ECHO_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ECHO */
         os_bit8  Echo_Data[FC_Frame_Data_Size_Max - sizeof(os_bit32)];
       };

typedef struct FC_ELS_ACC_ECHO_Payload_s
               FC_ELS_ACC_ECHO_Payload_t;

#define FC_ELS_ACC_ECHO_Payload_t_SIZE                                    FC_Frame_Data_Size_Max

struct FC_ELS_ACC_ECHO_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ACC */
         os_bit8  Echo_Data[FC_Frame_Data_Size_Max - sizeof(os_bit32)];
       };

typedef struct FC_ELS_TEST_Payload_s
               FC_ELS_TEST_Payload_t;

#define FC_ELS_TEST_Payload_t_SIZE                                        FC_Frame_Data_Size_Max

struct FC_ELS_TEST_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_TEST */
         os_bit8  Test_Data[FC_Frame_Data_Size_Max - sizeof(os_bit32)];
       };

typedef struct FC_ELS_RRQ_Payload_s
               FC_ELS_RRQ_Payload_t;

#define FC_ELS_RRQ_Payload_t_SIZE                                         0x0000002C

struct FC_ELS_RRQ_Payload_s
       {
         os_bit32                   ELS_Type; /* == FC_ELS_Type_RRQ */
         os_bit32                   Originator_S_ID;
         os_bit32                   OX_ID__RX_ID;
         FC_Association_Header_t Association_Header;
       };

#define FC_ELS_RRQ_Originator_S_ID_MASK                                   0x00FFFFFF
#define FC_ELS_RRQ_Originator_S_ID_SHIFT                                        0x00

#define FC_ELS_RRQ_OX_ID_MASK                                             0xFFFF0000
#define FC_ELS_RRQ_OX_ID_SHIFT                                                  0x10

#define FC_ELS_RRQ_RX_ID_MASK                                             0x0000FFFF
#define FC_ELS_RRQ_RX_ID_SHIFT                                                  0x00

typedef struct FC_ELS_ACC_RRQ_Payload_s
               FC_ELS_ACC_RRQ_Payload_t;

#define FC_ELS_ACC_RRQ_Payload_t_SIZE                                     0x00000004

struct FC_ELS_ACC_RRQ_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ACC */
       };

typedef struct FC_ELS_PRLI_Parm_Page_s
               FC_ELS_PRLI_Parm_Page_t;

#define FC_ELS_PRLI_Parm_Page_t_SIZE                                      0x00000010

struct FC_ELS_PRLI_Parm_Page_s
       {
         os_bit32 Type__Type_Extension__Flags;
         os_bit32 Originator_Process_Associator;
         os_bit32 Responder_Process_Associator;
         os_bit32 Service_Parameters;
       };

#define FC_ELS_PRLI_Parm_Type_MASK                                        0xFF000000
#define FC_ELS_PRLI_Parm_Type_SCSI_FCP                                    0x08000000

#define FC_ELS_PRLI_Parm_Type_Extension_MASK                              0x00FF0000

#define FC_ELS_PRLI_Parm_Flags_MASK                                       0x0000FFFF
#define FC_ELS_PRLI_Parm_Originator_Process_Associator_Valid              0x00008000
#define FC_ELS_PRLI_Parm_Responder_Process_Associator_Valid               0x00004000
#define FC_ELS_PRLI_Parm_Establish_Image_Pair                             0x00002000

#define FC_ELS_PRLI_Parm_Confirmed_Completion_Allowed                     0x00000080
#define FC_ELS_PRLI_Parm_Data_Overlay_Allowed                             0x00000040
#define FC_ELS_PRLI_Parm_Initiator_Function                               0x00000020
#define FC_ELS_PRLI_Parm_Target_Function                                  0x00000010
#define FC_ELS_PRLI_Parm_Command_Data_Mixed_Allowed                       0x00000008
#define FC_ELS_PRLI_Parm_Data_Response_Mixed_Allowed                      0x00000004
#define FC_ELS_PRLI_Parm_Read_XFER_RDY_Disabled                           0x00000002
#define FC_ELS_PRLI_Parm_Write_XFER_RDY_Disabled                          0x00000001

#define FC_PRLI_Parm_Pages_MAX ((FC_Frame_Data_Size_Max - sizeof(os_bit32))/sizeof(FC_ELS_PRLI_Parm_Page_t))

typedef struct FC_ELS_PRLI_Payload_s
               FC_ELS_PRLI_Payload_t;

#define FC_ELS_PRLI_Payload_t_SIZE                                        (FC_Frame_Data_Size_Max - FC_ELS_PRLI_Parm_Page_t_SIZE + 4)

struct FC_ELS_PRLI_Payload_s
       {
         os_bit32                   ELS_Type__Page_Length__Payload_Length; /* & FC_ELS_Type_MASK == FC_ELS_Type_PRLI */
         FC_ELS_PRLI_Parm_Page_t Parm_Page[FC_PRLI_Parm_Pages_MAX];
       };

#define FC_ELS_PRLI_Page_Length_MASK                                      0x00FF0000
#define FC_ELS_PRLI_Page_Length_SHIFT                                           0x10

#define FC_ELS_PRLI_Payload_Length_MASK                                   0x0000FFFF
#define FC_ELS_PRLI_Payload_Length_SHIFT                                        0x00

typedef struct FC_ELS_ACC_PRLI_Parm_Page_s
               FC_ELS_ACC_PRLI_Parm_Page_t;

#define FC_ELS_ACC_PRLI_Parm_Page_t_SIZE                                  0x00000010

struct FC_ELS_ACC_PRLI_Parm_Page_s
       {
         os_bit32 Type__Type_Extension__Flags;
         os_bit32 Originator_Process_Associator;
         os_bit32 Responder_Process_Associator;
         os_bit32 Service_Parameters;
       };

#define FC_ELS_ACC_PRLI_Parm_Type_MASK                                    0xFF000000
#define FC_ELS_ACC_PRLI_Parm_Type_SCSI_FCP                                0x08000000

#define FC_ELS_ACC_PRLI_Parm_Type_Extension_MASK                          0x00FF0000

#define FC_ELS_ACC_PRLI_Parm_Flags_MASK                                   0x0000FFFF
#define FC_ELS_ACC_PRLI_Parm_Originator_Process_Associator_Valid          0x00008000
#define FC_ELS_ACC_PRLI_Parm_Responder_Process_Associator_Valid           0x00004000
#define FC_ELS_ACC_PRLI_Parm_Image_Pair_Established                       0x00002000

#define FC_ELS_ACC_PRLI_Parm_Flags_Response_Code_MASK                     0x00000F00
#define FC_ELS_ACC_PRLI_Parm_Flags_Response_Request_Executed              0x00000100
#define FC_ELS_ACC_PRLI_Parm_Flags_Response_No_Resources_Available        0x00000200
#define FC_ELS_ACC_PRLI_Parm_Flags_Response_Initialization_Not_Completed  0x00000300
#define FC_ELS_ACC_PRLI_Parm_Flags_Response_Target_Image_Does_Not_Exist   0x00000400
#define FC_ELS_ACC_PRLI_Parm_Flags_Response_Target_Image_Precluded        0x00000500
#define FC_ELS_ACC_PRLI_Parm_Flags_Response_Executed_Conditionally        0x00000600
#define FC_ELS_ACC_PRLI_Parm_Flags_Response_Multiple_Not_Supported        0x00000700

#define FC_ELS_ACC_PRLI_Parm_Initiator_Function                           0x00000020
#define FC_ELS_ACC_PRLI_Parm_Target_Function                              0x00000010
#define FC_ELS_ACC_PRLI_Parm_Command_Data_Mixed_Allowed                   0x00000008
#define FC_ELS_ACC_PRLI_Parm_Data_Response_Mixed_Allowed                  0x00000004
#define FC_ELS_ACC_PRLI_Parm_Read_XFER_RDY_Disabled                       0x00000002
#define FC_ELS_ACC_PRLI_Parm_Write_XFER_RDY_Disabled                      0x00000001

#define FC_ACC_PRLI_Parm_Pages_MAX ((FC_Frame_Data_Size_Max - sizeof(os_bit32))/sizeof(FC_ELS_ACC_PRLI_Parm_Page_t))

typedef struct FC_ELS_ACC_PRLI_Payload_s
               FC_ELS_ACC_PRLI_Payload_t;

#define FC_ELS_ACC_PRLI_Payload_t_SIZE                                    (FC_Frame_Data_Size_Max - FC_ELS_ACC_PRLI_Parm_Page_t_SIZE + 4)

struct FC_ELS_ACC_PRLI_Payload_s
       {
         os_bit32                       ELS_Type__Page_Length__Payload_Length; /* & FC_ELS_Type_MASK == FC_ELS_Type_ACC */
         FC_ELS_ACC_PRLI_Parm_Page_t Parm_Page[FC_ACC_PRLI_Parm_Pages_MAX];
       };

#define FC_ELS_ACC_PRLI_Page_Length_MASK                                  0x00FF0000
#define FC_ELS_ACC_PRLI_Page_Length_SHIFT                                       0x10

#define FC_ELS_ACC_PRLI_Payload_Length_MASK                               0x0000FFFF
#define FC_ELS_ACC_PRLI_Payload_Length_SHIFT                                    0x00

typedef struct FC_ELS_PRLO_Parm_Page_s
               FC_ELS_PRLO_Parm_Page_t;

#define FC_ELS_PRLO_Parm_Page_t_SIZE                                      0x00000010

struct FC_ELS_PRLO_Parm_Page_s
       {
         os_bit32 Type__Type_Extension__Flags;
         os_bit32 Originator_Process_Associator;
         os_bit32 Responder_Process_Associator;
         os_bit32 Reserved;
       };

#define FC_ELS_PRLO_Parm_Type_MASK                                        0xFF000000
#define FC_ELS_PRLO_Parm_Type_SCSI_FCP                                    0x08000000

#define FC_ELS_PRLO_Parm_Type_Extension_MASK                              0x00FF0000

#define FC_ELS_PRLO_Parm_Flags_MASK                                       0x0000FFFF
#define FC_ELS_PRLO_Parm_Originator_Process_Associator_Valid              0x00008000
#define FC_ELS_PRLO_Parm_Responder_Process_Associator_Valid               0x00004000

#define FC_PRLO_Parm_Pages_MAX ((FC_Frame_Data_Size_Max - sizeof(os_bit32))/sizeof(FC_ELS_PRLO_Parm_Page_t))

typedef struct FC_ELS_PRLO_Payload_s
               FC_ELS_PRLO_Payload_t;

#define FC_ELS_PRLO_Payload_t_SIZE                                        (FC_Frame_Data_Size_Max - FC_ELS_PRLO_Parm_Page_t_SIZE + 4)

struct FC_ELS_PRLO_Payload_s
       {
         os_bit32                   ELS_Type__Page_Length__Payload_Length; /* & FC_ELS_Type_MASK == FC_ELS_Type_PRLO */
         FC_ELS_PRLO_Parm_Page_t Parm_Page[FC_PRLO_Parm_Pages_MAX];
       };

#define FC_ELS_PRLO_Page_Length_MASK                                      0x00FF0000
#define FC_ELS_PRLO_Page_Length_SHIFT                                           0x10

#define FC_ELS_PRLO_Payload_Length_MASK                                   0x0000FFFF
#define FC_ELS_PRLO_Payload_Length_SHIFT                                        0x00

typedef struct FC_ELS_ACC_PRLO_Parm_Page_s
               FC_ELS_ACC_PRLO_Parm_Page_t;

#define FC_ELS_ACC_PRLO_Parm_Page_t_SIZE                                  0x00000010

struct FC_ELS_ACC_PRLO_Parm_Page_s
       {
         os_bit32 Type__Type_Extension__Flags;
         os_bit32 Originator_Process_Associator;
         os_bit32 Responder_Process_Associator;
         os_bit32 Reserved;
       };

#define FC_ELS_ACC_PRLO_Parm_Type_MASK                                    0xFF000000
#define FC_ELS_ACC_PRLO_Parm_Type_SCSI_FCP                                0x08000000

#define FC_ELS_ACC_PRLO_Parm_Type_Extension_MASK                          0x00FF0000

#define FC_ELS_ACC_PRLO_Parm_Flags_MASK                                   0x0000FFFF
#define FC_ELS_ACC_PRLO_Parm_Originator_Process_Associator_Valid          0x00008000
#define FC_ELS_ACC_PRLO_Parm_Responder_Process_Associator_Valid           0x00004000

#define FC_ELS_ACC_PRLO_Parm_Flags_Response_Code_MASK                     0x00000F00
#define FC_ELS_ACC_PRLO_Parm_Flags_Response_Request_Executed              0x00000100
#define FC_ELS_ACC_PRLO_Parm_Flags_Response_Target_Image_Does_Not_Exist   0x00000400
#define FC_ELS_ACC_PRLO_Parm_Flags_Response_Multiple_Not_Supported        0x00000700

#define FC_ACC_PRLO_Parm_Pages_MAX ((FC_Frame_Data_Size_Max - sizeof(os_bit32))/sizeof(FC_ELS_ACC_PRLO_Parm_Page_t))

typedef struct FC_ELS_ACC_PRLO_Payload_s
               FC_ELS_ACC_PRLO_Payload_t;

#define FC_ELS_ACC_PRLO_Payload_t_SIZE                                    (FC_Frame_Data_Size_Max - FC_ELS_ACC_PRLO_Parm_Page_t_SIZE + 4)

struct FC_ELS_ACC_PRLO_Payload_s
       {
         os_bit32                       ELS_Type__Page_Length__Payload_Length; /* & FC_ELS_Type_MASK == FC_ELS_Type_ACC */
         FC_ELS_ACC_PRLO_Parm_Page_t Parm_Page[FC_ACC_PRLO_Parm_Pages_MAX];
       };

#define FC_ELS_ACC_PRLO_Page_Length_MASK                                  0x00FF0000
#define FC_ELS_ACC_PRLO_Page_Length_SHIFT                                       0x10

#define FC_ELS_ACC_PRLO_Payload_Length_MASK                               0x0000FFFF
#define FC_ELS_ACC_PRLO_Payload_Length_SHIFT                                    0x00

typedef os_bit32 FC_ELS_SCN_Affected_N_Port_ID_t;

#define FC_ELS_SCN_Affected_N_Port_ID_t_SIZE                              0x00000004

#define FC_ELS_SCN_Affected_N_Port_IDs_MAX ((FC_Frame_Data_Size_Max - sizeof(os_bit32))/sizeof(FC_ELS_SCN_Affected_N_Port_ID_t))

typedef struct FC_ELS_SCN_Payload_s
               FC_ELS_SCN_Payload_t;

#define FC_ELS_SCN_Payload_t_SIZE                                         FC_Frame_Data_Size_Max

struct FC_ELS_SCN_Payload_s
       {
         os_bit32                           ELS_Type__Page_Length__Payload_Length; /* & FC_ELS_Type_MASK == FC_ELS_Type_SCN */
         FC_ELS_SCN_Affected_N_Port_ID_t Affected_N_Port_ID[FC_ELS_SCN_Affected_N_Port_IDs_MAX];
       };

#define FC_ELS_SCN_Page_Length_MASK                                       0x00FF0000
#define FC_ELS_SCN_Page_Length_SHIFT                                            0x10

#define FC_ELS_SCN_Payload_Length_MASK                                    0x0000FFFF
#define FC_ELS_SCN_Payload_Length_SHIFT                                         0x00


typedef os_bit32 FC_ELS_RSCN_Affected_N_Port_ID_t;

#define FC_ELS_RSCN_Affected_N_Port_ID_t_SIZE                              0x00000004

#define FC_ELS_RSCN_Affected_N_Port_IDs_MAX ((FC_Frame_Data_Size_Max - sizeof(os_bit32))/sizeof(FC_ELS_RSCN_Affected_N_Port_ID_t))

typedef struct FC_ELS_RSCN_Payload_s
               FC_ELS_RSCN_Payload_t;

#define FC_ELS_RSCN_Payload_t_SIZE                                         FC_Frame_Data_Size_Max

struct FC_ELS_RSCN_Payload_s
       {
         os_bit32                           ELS_Type__Page_Length__Payload_Length; /* & FC_ELS_Type_MASK == FC_ELS_Type_RSCN */
         FC_ELS_RSCN_Affected_N_Port_ID_t Affected_N_Port_ID[FC_ELS_RSCN_Affected_N_Port_IDs_MAX];
       };

#define FC_ELS_RSCN_Page_Length_MASK                                       0x00FF0000
#define FC_ELS_RSCN_Page_Length_SHIFT                                            0x10

#define FC_ELS_RSCN_Payload_Length_MASK                                    0x0000FFFF
#define FC_ELS_RSCN_Payload_Length_SHIFT                                         0x00


typedef os_bit32  FC_ELS_SCR_Registration_Function_t;

typedef struct FC_ELS_SCR_Payload_s
               FC_ELS_SCR_Payload_t;

#define FC_ELS_SCR_Payload_t_SIZE                                          0x00000008

struct FC_ELS_SCR_Payload_s
    {
        os_bit32                               ELS_Type_Command;
        FC_ELS_SCR_Registration_Function_t  Reserved_Registration_Function;
    };
 
#define FC_ELS_SCR_Registration_Function_MASK                                 0x0000000F
#define FC_ELS_SCR_Fabric_Detected_Registration                               0x00000001
#define FC_ELS_SCR_N_Port_Detected_Registration                               0x00000002
#define FC_ELS_SCR_Full_Registration                                          0x00000003


typedef struct FC_ELS_ACC_SCR_Payload_s
               FC_ELS_ACC_SCR_Payload_t;

#define FC_ELS_ACC_SCR_Payload_t_SIZE                                   0x0000004

struct FC_ELS_ACC_SCR_Payload_s
       {
         os_bit32            ELS_Type; /* == FC_ELS_Type_ACC */
       };

typedef struct FC_ELS_SRR_Payload_s
               FC_ELS_SRR_Payload_t;

#define FC_ELS_ACC_SRR_Payload_t_SIZE                                   0x0000004
#define FC_ELS_SRR_OXID_MASK            0xFFFF0000
#define FC_ELS_SRR_OXID_SHIFT           0x10

#define FC_ELS_SRR_RXID_MASK            0x0000FFFF
#define FC_ELS_SRR_RXID_SHIFT           0x0

/* The RCTL that goes here is as described in FC-PH
   for FCP_XFER_RDY, it is 05, FCP_RSP 07 and FCP_DATA
   01 */
#define FC_ELS_SRR_Payload_t_SIZE                                   0x0000010
#define FC_ELS_R_CTL_MASK                       0xFF000000
#define FC_ELS_R_CTL_FOR_IU_SHIFT               0x18

           
struct FC_ELS_SRR_Payload_s
    {
        os_bit32                           ELS_Type;
        os_bit32                           OXID_RXID;
        os_bit32                           Relative_Offset;
        os_bit32                           R_CTL_For_IU_Reserved;
    }; 

#define FC_ELS_ACC_SRR_RJT_CODE         0x00052A00


/* Read Exchange Context REC - Requests an NPort to return exchange information
   for the RX_ID or OX_ID originated by the S)ID specified in the payload of the request
   sequence */

#define FC_ELS_REC_Payload_t_SIZE                                   0x00000C
typedef struct FC_ELS_REC_Payload_s
                FC_ELS_REC_Payload_t;

#define FC_ELS_REC_ExChOriginatorSid_MASK          0x00FFFFFF
#define FC_ELS_REC_ExChOriginatorSid_SHIFT         0x0
#define FC_ELS_REC_OXID_MASK                       0xFFFF0000
#define FC_ELS_REC_OXID_SHIFT                      0x10
#define FC_ELS_REC_RXID_MASK                       0x0000FFFF
#define FC_ELS_REC_RXID_SHIFT                      0x0

struct FC_ELS_REC_Payload_s
    {
        os_bit32                           ELS_Type;
        os_bit32                           Reserved_ExChOriginatorSid;
        os_bit32                           OXID_RXID;
    };

typedef struct FC_ELS_REC_ACC_Payload_s
               FC_ELS_REC_ACC_Payload_t;

#define FC_ELS_REC_ACC_OXID_MASK                            0xFFFF0000
#define FC_ELS_REC_ACC_OXID_SHIFT                           0x10
#define FC_ELS_REC_ACC_RXID_MASK                            0x0000FFFF
#define FC_ELS_REC_ACC_RXID_SHIFT                           0x0

#define FC_REC_ESTAT_VALID_VALUE_MASK                       0x06000000
#define FC_REC_ESTAT_VALID_VALUE_SHIFT                      0x20
#define FC_REC_ESTAT_VALID_VALUE                            0x00000003

#define FC_REC_ESTAT_Mask                                   0x003FFFFF
#define FC_REC_ESTAT_ESB_OWNER_Responder                    0x80000000
#define FC_REC_ESTAT_SequenceInitiativeThisPort             0x40000000
#define FC_REC_ESTAT_ExchangeCompletion                     0x20000000
#define FC_REC_ESTAT_EndingConditionAbnormal                0x10000000
#define FC_REC_ESTAT_ErrorTypeAbnormal                      0x08000000
#define FC_REC_ESTAT_RecoveryQualiferActive                 0x04000000
#define FC_REC_ESTAT_ExchangePolicy_AbortDiscardMultiple    0x00000000
#define FC_REC_ESTAT_ExchangePolicy_AbortDiscardSingle      0x01000000
#define FC_REC_ESTAT_ExchangePolicy_Processinfinite         0x02000000
#define FC_REC_ESTAT_ExchangePolicy_DiscardMultipleRetry    0x03000000
#define FC_REC_ESTAT_ExchangePolicy_MASK                    0x03000000

#define FC_REC_ESTAT_Originator_X_ID_invalid                0x00800000
#define FC_REC_ESTAT_Responder_X_ID_invalid                 0x00400000



#define FC_ELS_REC_ACC_Payload_t_SIZE                                   0x000018
struct FC_ELS_REC_ACC_Payload_s
    {
        os_bit32       ELS_Type_Command;
        os_bit32       OXID_RXID;
        os_bit32       OriginatorAddressIdentifier;
        os_bit32       ResponderAddressIdentifier;
        os_bit32       DataTransferCount;
        os_bit32       ESTAT;
    };

typedef struct FC_ELS_TPLS_Image_Pair_s
               FC_ELS_TPLS_Image_Pair_t;

#define FC_ELS_TPLS_Image_Pair_t_SIZE                                     0x00000010

struct FC_ELS_TPLS_Image_Pair_s
       {
         os_bit32 Flags;
         os_bit32 Originator_Process_Associator;
         os_bit32 Responder_Process_Associator;
         os_bit32 Reserved;
       };

#define FC_ELS_TPLS_Image_Pair_Flags_MASK                                 0x0000FFFF

#define FC_ELS_TPLS_Image_Pair_Originator_Process_Associator_Valid        0x00008000
#define FC_ELS_TPLS_Image_Pair_Responder_Process_Associator_Valid         0x00004000

#define FC_ELS_TPLS_Image_Pairs_MAX ((FC_Frame_Data_Size_Max - sizeof(os_bit32))/sizeof(FC_ELS_TPLS_Image_Pair_t))

typedef struct FC_ELS_TPLS_Payload_s
               FC_ELS_TPLS_Payload_t;

#define FC_ELS_TPLS_Payload_t_SIZE                                        (FC_Frame_Data_Size_Max - FC_ELS_TPLS_Image_Pair_t_SIZE + 4)

struct FC_ELS_TPLS_Payload_s
       {
         os_bit32                    ELS_Type__Page_Length__Payload_Length; /* & FC_ELS_Type_MASK == FC_ELS_Type_TPLS */
         FC_ELS_TPLS_Image_Pair_t Image_Pair[FC_ELS_TPLS_Image_Pairs_MAX];
       };

#define FC_ELS_TPLS_Page_Length_MASK                                      0x00FF0000
#define FC_ELS_TPLS_Page_Length_SHIFT                                           0x10

#define FC_ELS_TPLS_Payload_Length_MASK                                   0x0000FFFF
#define FC_ELS_TPLS_Payload_Length_SHIFT                                        0x00

typedef struct FC_ELS_ACC_TPLS_Image_Pair_s
               FC_ELS_ACC_TPLS_Image_Pair_t;

#define FC_ELS_ACC_TPLS_Image_Pair_t_SIZE                                 0x00000010

struct FC_ELS_ACC_TPLS_Image_Pair_s
       {
         os_bit32 Flags;
         os_bit32 Originator_Process_Associator;
         os_bit32 Responder_Process_Associator;
         os_bit32 Reserved;
       };

#define FC_ELS_TPLS_Image_Pair_Flags_MASK                                 0x0000FFFF

#define FC_ELS_ACC_TPLS_Image_Pair_Originator_Process_Associator_Valid    0x00008000
#define FC_ELS_ACC_TPLS_Image_Pair_Responder_Process_Associator_Valid     0x00004000

#define FC_ELS_ACC_TPLS_Pair_Flags_Response_Code_MASK                     0x00000F00
#define FC_ELS_ACC_TPLS_Pair_Flags_Response_Request_Executed              0x00000100
#define FC_ELS_ACC_TPLS_Pair_Flags_Response_Multiple_Not_Supported        0x00000700

#define FC_ELS_ACC_TPLS_Image_Pairs_MAX ((FC_Frame_Data_Size_Max - sizeof(os_bit32))/sizeof(FC_ELS_ACC_TPLS_Image_Pair_t))

typedef struct FC_ELS_ACC_TPLS_Payload_s
               FC_ELS_ACC_TPLS_Payload_t;

#define FC_ELS_ACC_TPLS_Payload_t_SIZE                                    (FC_Frame_Data_Size_Max - FC_ELS_ACC_TPLS_Image_Pair_t_SIZE + 4)

struct FC_ELS_ACC_TPLS_Payload_s
       {
         os_bit32                        ELS_Type__Page_Length__Payload_Length; /* & FC_ELS_Type_MASK == FC_ELS_Type_ACC */
         FC_ELS_ACC_TPLS_Image_Pair_t Image_Pair[FC_ELS_ACC_TPLS_Image_Pairs_MAX];
       };

#define FC_ELS_ACC_TPLS_Page_Length_MASK                                  0x00FF0000
#define FC_ELS_ACC_TPLS_Page_Length_SHIFT                                       0x10

#define FC_ELS_ACC_TPLS_Payload_Length_MASK                               0x0000FFFF
#define FC_ELS_ACC_TPLS_Payload_Length_SHIFT                                    0x00

typedef struct FC_ELS_TPRLO_Parm_Page_s
               FC_ELS_TPRLO_Parm_Page_t;

#define FC_ELS_TPRLO_Parm_Page_t_SIZE                                     0x00000010

struct FC_ELS_TPRLO_Parm_Page_s
       {
         os_bit32 Flags;
         os_bit32 Originator_Process_Associator;
         os_bit32 Responder_Process_Associator;
         os_bit32 Third_Party_N_Port_ID;
       };

#define FC_ELS_TPRLO_Parm_Page_Flags_MASK                                 0x0000FFFF

#define FC_ELS_TPRLO_Parm_Page_Originator_Process_Associator_Valid        0x00008000
#define FC_ELS_TPRLO_Parm_Page_Responder_Process_Associator_Valid         0x00004000
#define FC_ELS_TPRLO_Parm_Page_Third_Party_N_Port_Valid                   0x00002000
#define FC_ELS_TPRLO_Parm_Page_Global_Process_Logout                      0x00001000

#define FC_ELS_TPRLO_Parm_Page_Third_Party_N_Port_ID_MASK                 0x00FFFFFF

#define FC_ELS_TPRLO_Parm_Pages_MAX ((FC_Frame_Data_Size_Max - sizeof(os_bit32))/sizeof(FC_ELS_TPRLO_Parm_Page_t))

typedef struct FC_ELS_TPRLO_Payload_s
               FC_ELS_TPRLO_Payload_t;

#define FC_ELS_TPRLO_Payload_t_SIZE                                       (FC_Frame_Data_Size_Max - FC_ELS_TPRLO_Parm_Page_t_SIZE + 4)

struct FC_ELS_TPRLO_Payload_s
       {
         os_bit32                    ELS_Type__Page_Length__Payload_Length; /* & FC_ELS_Type_MASK == FC_ELS_Type_TPRLO */
         FC_ELS_TPRLO_Parm_Page_t Parm_Page[FC_ELS_TPRLO_Parm_Pages_MAX];
       };

#define FC_ELS_TPRLO_Page_Length_MASK                                     0x00FF0000
#define FC_ELS_TPRLO_Page_Length_SHIFT                                          0x10

#define FC_ELS_TPRLO_Payload_Length_MASK                                  0x0000FFFF
#define FC_ELS_TPRLO_Payload_Length_SHIFT                                       0x00

typedef struct FC_ELS_ACC_TPRLO_Payload_s
               FC_ELS_ACC_TPRLO_Payload_t;

#define FC_ELS_ACC_TPRLO_Payload_t_SIZE                                   (FC_Frame_Data_Size_Max - FC_ELS_TPRLO_Parm_Page_t_SIZE + 4)

struct FC_ELS_ACC_TPRLO_Payload_s
       {
         os_bit32                    ELS_Type__Page_Length__Payload_Length; /* & FC_ELS_Type_MASK == FC_ELS_Type_ACC */
         FC_ELS_TPRLO_Parm_Page_t Parm_Page[FC_ELS_TPRLO_Parm_Pages_MAX];
       };

#define FC_ELS_ACC_TPRLO_Page_Length_MASK                                 0x00FF0000
#define FC_ELS_ACC_TPRLO_Page_Length_SHIFT                                      0x10

#define FC_ELS_ACC_TPRLO_Payload_Length_MASK                              0x0000FFFF
#define FC_ELS_ACC_TPRLO_Payload_Length_SHIFT                                   0x00

typedef os_bit8 FC_ELS_Alias_Token_t [12];
typedef os_bit8 FC_ELS_Alias_SP_t    [80];

#define FC_ELS_Alias_Token_t_SIZE                                         0x0000000C
#define FC_ELS_Alias_SP_t_SIZE                                            0x00000050

typedef os_bit32 FC_ELS_NP_List_Element_t;

#define FC_ELS_NP_List_Element_t_SIZE                                     0x00000004

typedef os_bit32 FC_ELS_Alias_ID_t;

#define FC_ELS_Alias_ID_t_SIZE                                            0x00000004

#define FC_ELS_GAID_Payload_NP_List_Size_MAX ((FC_Frame_Data_Size_Max - sizeof(os_bit32) - sizeof(FC_ELS_Alias_Token_t) - sizeof(FC_ELS_Alias_SP_t) - sizeof(os_bit32))/sizeof(FC_ELS_NP_List_Element_t))

typedef struct FC_ELS_GAID_Payload_s
               FC_ELS_GAID_Payload_t;

#define FC_ELS_GAID_Payload_t_SIZE                                        FC_Frame_Data_Size_Max

struct FC_ELS_GAID_Payload_s
       {
         os_bit32                    ELS_Type; /* == FC_ELS_Type_GAID */
         FC_ELS_Alias_Token_t     Alias_Token;
         FC_ELS_Alias_SP_t        Alias_SP;
         os_bit32                    NP_List_Length;
         FC_ELS_NP_List_Element_t NP_List[FC_ELS_GAID_Payload_NP_List_Size_MAX];
       };

typedef struct FC_ELS_ACC_GAID_Payload_s
               FC_ELS_ACC_GAID_Payload_t;

#define FC_ELS_ACC_GAID_Payload_t_SIZE                                    (FC_ELS_Alias_ID_t_SIZE + 4)

struct FC_ELS_ACC_GAID_Payload_s
       {
         os_bit32             ELS_Type; /* == FC_ELS_Type_ACC */
         FC_ELS_Alias_ID_t Alias_ID;
       };

#define FC_ELS_FACT_Payload_NP_List_Size_MAX ((FC_Frame_Data_Size_Max - sizeof(os_bit32) - sizeof(FC_ELS_Alias_ID_t) - sizeof(os_bit32))/sizeof(FC_ELS_NP_List_Element_t))

typedef struct FC_ELS_FACT_Payload_s
               FC_ELS_FACT_Payload_t;

#define FC_ELS_FACT_Payload_t_SIZE                                        FC_Frame_Data_Size_Max

struct FC_ELS_FACT_Payload_s
       {
         os_bit32                    ELS_Type; /* == FC_ELS_Type_FACT */
         FC_ELS_Alias_ID_t        Alias_ID;
         os_bit32                    NP_List_Length;
         FC_ELS_NP_List_Element_t NP_List[FC_ELS_FACT_Payload_NP_List_Size_MAX];
       };

typedef struct FC_ELS_ACC_FACT_Payload_s
               FC_ELS_ACC_FACT_Payload_t;

#define FC_ELS_ACC_FACT_Payload_t_SIZE                                    0x00000004

struct FC_ELS_ACC_FACT_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ACC */
       };

#define FC_ELS_FDACT_Payload_NP_List_Size_MAX ((FC_Frame_Data_Size_Max - sizeof(os_bit32) - sizeof(FC_ELS_Alias_ID_t) - sizeof(os_bit32))/sizeof(FC_ELS_NP_List_Element_t))

typedef struct FC_ELS_FDACT_Payload_s
               FC_ELS_FDACT_Payload_t;

#define FC_ELS_FDACT_Payload_t_SIZE                                       FC_Frame_Data_Size_Max

struct FC_ELS_FDACT_Payload_s
       {
         os_bit32                    ELS_Type; /* == FC_ELS_Type_FDACT */
         FC_ELS_Alias_ID_t        Alias_ID;
         os_bit32                    NP_List_Length;
         FC_ELS_NP_List_Element_t NP_List[FC_ELS_FDACT_Payload_NP_List_Size_MAX];
       };

typedef struct FC_ELS_ACC_FDACT_Payload_s
               FC_ELS_ACC_FDACT_Payload_t;

#define FC_ELS_ACC_FDACT_Payload_t_SIZE                                   0x00000004

struct FC_ELS_ACC_FDACT_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ACC */
       };

typedef struct FC_ELS_NACT_Payload_s
               FC_ELS_NACT_Payload_t;

#define FC_ELS_NACT_Payload_t_SIZE                                        (FC_ELS_Alias_Token_t_SIZE + FC_ELS_Alias_ID_t_SIZE + FC_ELS_Alias_SP_t_SIZE + 4)

struct FC_ELS_NACT_Payload_s
       {
         os_bit32                ELS_Type; /* == FC_ELS_Type_NACT */
         FC_ELS_Alias_Token_t Alias_Token;
         FC_ELS_Alias_ID_t    Alias_ID;
         FC_ELS_Alias_SP_t    Alias_SP;
       };

typedef struct FC_ELS_ACC_NACT_Payload_s
               FC_ELS_ACC_NACT_Payload_t;

#define FC_ELS_ACC_NACT_Payload_t_SIZE                                    0x00000004

struct FC_ELS_ACC_NACT_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ACC */
       };

typedef struct FC_ELS_NDACT_Payload_s
               FC_ELS_NDACT_Payload_t;

#define FC_ELS_NDACT_Payload_t_SIZE                                       (FC_ELS_Alias_ID_t_SIZE + 4)

struct FC_ELS_NDACT_Payload_s
       {
         os_bit32             ELS_Type; /* == FC_ELS_Type_NDACT */
         FC_ELS_Alias_ID_t Alias_ID;
       };

typedef struct FC_ELS_ACC_NDACT_Payload_s
               FC_ELS_ACC_NDACT_Payload_t;

#define FC_ELS_ACC_NDACT_Payload_t_SIZE                                   0x00000004

struct FC_ELS_ACC_NDACT_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ACC */
       };

typedef struct FC_ELS_QoSR_Payload_s
               FC_ELS_QoSR_Payload_t;

#define FC_ELS_QoSR_Payload_t_SIZE                                        0x0000004C

struct FC_ELS_QoSR_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_QoSR */
         os_bit32 Reserved_1;
         os_bit32 CTI_VC_ID__CTI_Address_Identifier;
         os_bit32 CTI_Maximum_Bandwidth;
         os_bit32 CTI_Minimum_Bandwidth;
         os_bit32 CTI_Maximum_Delay;
         os_bit32 CTI_VC_Data_Field_Size;
         os_bit32 Reserved_2;
         os_bit32 Reserved_3;
         os_bit32 Reserved_4;
         os_bit32 CTR_VC_ID__CTR_Address_Identifier;
         os_bit32 CTR_Maximum_Bandwidth;
         os_bit32 CTR_Minimum_Bandwidth;
         os_bit32 CTR_Maximum_Delay;
         os_bit32 CTR_VC_Data_Field_Size;
         os_bit32 Reserved_5;
         os_bit32 Reserved_6;
         os_bit32 Reserved_7;
         os_bit32 Live_VC_Credit_Limit__Class_4_End_to_End_Credit;
       };

#define FC_ELS_QoSR_CTI_VC_ID_MASK                                        0xFF000000
#define FC_ELS_QoSR_CTI_VC_ID_SHIFT                                             0x18

#define FC_ELS_QoSR_CTI_Address_Identifier_MASK                           0x00FFFFFF
#define FC_ELS_QoSR_CTI_Address_Identifier_SHIFT                                0x00

#define FC_ELS_QoSR_CTR_VC_ID_MASK                                        0xFF000000
#define FC_ELS_QoSR_CTR_VC_ID_SHIFT                                             0x18

#define FC_ELS_QoSR_CTR_Address_Identifier_MASK                           0x00FFFFFF
#define FC_ELS_QoSR_CTR_Address_Identifier_SHIFT                                0x00

#define FC_ELS_QoSR_Live_VC_Credit_Limit_MASK                             0x00FF0000
#define FC_ELS_QoSR_Live_VC_Credit_Limit_SHIFT                                  0x10

#define FC_ELS_QoSR_Live_Class_4_End_to_End_Credit_MASK                   0x0000FFFF
#define FC_ELS_QoSR_Live_Class_4_End_to_End_Credit_SHIFT                        0x00

typedef struct FC_ELS_ACC_QoSR_Payload_s
               FC_ELS_ACC_QoSR_Payload_t;

#define FC_ELS_ACC_QoSR_Payload_t_SIZE                                    0x0000004C

struct FC_ELS_ACC_QoSR_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ACC */
         os_bit32 Reserved_1;
         os_bit32 CTI_VC_ID__CTI_Address_Identifier;
         os_bit32 CTI_Maximum_Bandwidth;
         os_bit32 CTI_Minimum_Bandwidth;
         os_bit32 CTI_Maximum_Delay;
         os_bit32 CTI_VC_Data_Field_Size;
         os_bit32 Reserved_2;
         os_bit32 Reserved_3;
         os_bit32 Reserved_4;
         os_bit32 CTR_VC_ID__CTR_Address_Identifier;
         os_bit32 CTR_Maximum_Bandwidth;
         os_bit32 CTR_Minimum_Bandwidth;
         os_bit32 CTR_Maximum_Delay;
         os_bit32 CTR_VC_Data_Field_Size;
         os_bit32 Reserved_5;
         os_bit32 Reserved_6;
         os_bit32 Reserved_7;
         os_bit32 Live_VC_Credit_Limit__Class_4_End_to_End_Credit;
       };

#define FC_ELS_ACC_QoSR_CTI_VC_ID_MASK                                    0xFF000000
#define FC_ELS_ACC_QoSR_CTI_VC_ID_SHIFT                                         0x18

#define FC_ELS_ACC_QoSR_CTI_Address_Identifier_MASK                       0x00FFFFFF
#define FC_ELS_ACC_QoSR_CTI_Address_Identifier_SHIFT                            0x00

#define FC_ELS_ACC_QoSR_CTR_VC_ID_MASK                                    0xFF000000
#define FC_ELS_ACC_QoSR_CTR_VC_ID_SHIFT                                         0x18

#define FC_ELS_ACC_QoSR_CTR_Address_Identifier_MASK                       0x00FFFFFF
#define FC_ELS_ACC_QoSR_CTR_Address_Identifier_SHIFT                            0x00

#define FC_ELS_ACC_QoSR_Live_VC_Credit_Limit_MASK                         0x00FF0000
#define FC_ELS_ACC_QoSR_Live_VC_Credit_Limit_SHIFT                              0x10

#define FC_ELS_ACC_QoSR_Live_Class_4_End_to_End_Credit_MASK               0x0000FFFF
#define FC_ELS_ACC_QoSR_Live_Class_4_End_to_End_Credit_SHIFT                    0x00

typedef struct FC_ELS_RVCS_Payload_s
               FC_ELS_RVCS_Payload_t;

#define FC_ELS_RVCS_Payload_t_SIZE                                        0x00000008

struct FC_ELS_RVCS_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_RVCS */
         os_bit32 N_Port_Identifier;
       };

#define FC_ELS_RVCS_N_Port_Identifier_MASK                                0x00FFFFFF
#define FC_ELS_RVCS_N_Port_Identifier_SHIFT                                     0x00

typedef struct FC_ELS_ACC_RVCS_Class_4_Status_Block_s
               FC_ELS_ACC_RVCS_Class_4_Status_Block_t;

#define FC_ELS_ACC_RVCS_Class_4_Status_Block_t_SIZE                       0x00000008

struct FC_ELS_ACC_RVCS_Class_4_Status_Block_s
       {
         os_bit32 CTI_VC_ID__CTI_Address_Identifier;
         os_bit32 CTR_VC_ID__CTR_Address_Identifier;
       };

#define FC_ELS_ACC_RVCS_Class_4_Status_Block_CTI_VC_ID_MASK               0xFF000000
#define FC_ELS_ACC_RVCS_Class_4_Status_Block_CTI_VC_ID_SHIFT                    0x18

#define FC_ELS_ACC_RVCS_Class_4_Status_Block_CTI_Address_Identifier_MASK  0x00FFFFFF
#define FC_ELS_ACC_RVCS_Class_4_Status_Block_CTI_Address_Identifier_SHIFT       0x00

#define FC_ELS_ACC_RVCS_Class_4_Status_Block_CTR_VC_ID_MASK               0xFF000000
#define FC_ELS_ACC_RVCS_Class_4_Status_Block_CTR_VC_ID_SHIFT                    0x18

#define FC_ELS_ACC_RVCS_Class_4_Status_Block_CTR_Address_Identifier_MASK  0x00FFFFFF
#define FC_ELS_ACC_RVCS_Class_4_Status_Block_CTR_Address_Identifier_SHIFT       0x00

#define FC_ELS_ACC_RVCS_Class_4_Status_Blocks_MAX ((FC_Frame_Data_Size_Max - sizeof(os_bit32))/sizeof(FC_ELS_ACC_RVCS_Class_4_Status_Block_t))

typedef struct FC_ELS_ACC_RVCS_Payload_s
               FC_ELS_ACC_RVCS_Payload_t;

#define FC_ELS_ACC_RVCS_Payload_t_SIZE                                    FC_Frame_Data_Size_Max

struct FC_ELS_ACC_RVCS_Payload_s
       {
         os_bit32                                  ELS_Type; /* == FC_ELS_Type_ACC */
         os_bit32                                  Reserved;
         FC_ELS_ACC_RVCS_Class_4_Status_Block_t Status_Block[FC_ELS_ACC_RVCS_Class_4_Status_Blocks_MAX];
       };

typedef struct FC_ELS_PDISC_Payload_s
               FC_ELS_PDISC_Payload_t;

#define FC_ELS_PDISC_Payload_t_SIZE                                       0x00000074

struct FC_ELS_PDISC_Payload_s
       {
         os_bit32                     ELS_Type; /* == FC_ELS_Type_PDISC */
         FC_N_Port_Common_Parms_t  Common_Service_Parameters;
         FC_N_Port_Name_t          N_Port_Name;
         FC_Node_Name_t            Node_Name;
         FC_N_Port_Class_Parms_t   Class_1_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_2_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_3_Service_Parameters;
         os_bit8                      Reserved[16];
         FC_Vendor_Version_Level_t Vendor_Version_Level;
       };

typedef struct FC_ELS_ACC_PDISC_Payload_s
               FC_ELS_ACC_PDISC_Payload_t;

#define FC_ELS_ACC_PDISC_Payload_t_SIZE                                   0x00000074

struct FC_ELS_ACC_PDISC_Payload_s
       {
         os_bit32                     ELS_Type; /* == FC_ELS_Type_ACC */
         FC_N_Port_Common_Parms_t  Common_Service_Parameters;
         FC_N_Port_Name_t          N_Port_Name;
         FC_Node_Name_t            Node_Name;
         FC_N_Port_Class_Parms_t   Class_1_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_2_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_3_Service_Parameters;
         os_bit8                      Reserved[16];
         FC_Vendor_Version_Level_t Vendor_Version_Level;
       };

typedef struct FC_ELS_FDISC_Payload_s
               FC_ELS_FDISC_Payload_t;

#define FC_ELS_FDISC_Payload_t_SIZE                                       0x00000074

struct FC_ELS_FDISC_Payload_s
       {
         os_bit32                     ELS_Type; /* == FC_ELS_Type_FDISC */
         FC_N_Port_Common_Parms_t  Common_Service_Parameters;
         FC_N_Port_Name_t          N_Port_Name;
         FC_Node_Name_t            Node_Name;
         FC_N_Port_Class_Parms_t   Class_1_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_2_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_3_Service_Parameters;
         os_bit8                      Reserved[16];
         FC_Vendor_Version_Level_t Vendor_Version_Level;
       };

typedef struct FC_ELS_ACC_FDISC_Payload_s
               FC_ELS_ACC_FDISC_Payload_t;

#define FC_ELS_ACC_FDISC_Payload_t_SIZE                                   0x00000074

struct FC_ELS_ACC_FDISC_Payload_s
       {
         os_bit32                     ELS_Type; /* == FC_ELS_Type_ACC */
         FC_F_Port_Common_Parms_t  Common_Service_Parameters;
         FC_F_Port_Name_t          F_Port_Name;
         FC_Fabric_Name_t          Fabric_Name;
         FC_F_Port_Class_Parms_t   Class_1_Service_Parameters;
         FC_F_Port_Class_Parms_t   Class_2_Service_Parameters;
         FC_F_Port_Class_Parms_t   Class_3_Service_Parameters;
         os_bit8                      Reserved[16];
         FC_Vendor_Version_Level_t Vendor_Version_Level;
       };

typedef struct FC_ELS_FAN_Payload_s
               FC_ELS_FAN_Payload_t;

#define FC_ELS_FAN_Payload_t_SIZE                                         0x00000006

struct FC_ELS_FAN_Payload_s
       {
         os_bit32            ELS_Type; /* == FC_ELS_Type_FAN */
         os_bit32            FabricLoopAddress;
         FC_Node_Name_t   Fabric_Port_Name;
         FC_Node_Name_t   Fabric_Name;
       };

typedef struct FC_ELS_ADISC_Payload_s
               FC_ELS_ADISC_Payload_t;

#define FC_ELS_ADISC_Payload_t_SIZE                                       0x0000001C

struct FC_ELS_ADISC_Payload_s
       {
         os_bit32            ELS_Type; /* == FC_ELS_Type_ADISC */
         os_bit32            Hard_Address_of_Originator;
         FC_N_Port_Name_t Port_Name_of_Originator;
         FC_Node_Name_t   Node_Name_of_Originator;
         os_bit32            N_Port_ID_of_Originator;
       };

#define FC_ELS_ADISC_Hard_Address_of_Originator_MASK                      0x00FFFFFF
#define FC_ELS_ADISC_Hard_Address_of_Originator_SHIFT                           0x00

#define FC_ELS_ADISC_N_Port_ID_of_Originator_MASK                         0x00FFFFFF
#define FC_ELS_ADISC_N_Port_ID_of_Originator_SHIFT                              0x00

typedef struct FC_ELS_ACC_ADISC_Payload_s
               FC_ELS_ACC_ADISC_Payload_t;

#define FC_ELS_ACC_ADISC_Payload_t_SIZE                                   0x0000001C

struct FC_ELS_ACC_ADISC_Payload_s
       {
         os_bit32            ELS_Type; /* == FC_ELS_Type_ACC */
         os_bit32            Hard_Address_of_Responder;
         FC_N_Port_Name_t Port_Name_of_Responder;
         FC_Node_Name_t   Node_Name_of_Responder;
         os_bit32            N_Port_ID_of_Responder;
       };

#define FC_ELS_ACC_ADISC_Hard_Address_of_Responder_MASK                   0x00FFFFFF
#define FC_ELS_ACC_ADISC_Hard_Address_of_Responder_SHIFT                        0x00

#define FC_ELS_ACC_ADISC_N_Port_ID_of_Responder_MASK                      0x00FFFFFF
#define FC_ELS_ACC_ADISC_N_Port_ID_of_Responder_SHIFT                           0x00
#ifdef _DvrArch_1_30_
typedef struct FC_ELS_FARP_REQ_Payload_s
               FC_ELS_FARP_REQ_Payload_t;

#define FC_ELS_FARP_Payload_t_SIZE                                       0x0000004C

struct FC_ELS_FARP_REQ_Payload_s
       {
         os_bit32            ELS_Type; /* == FC_ELS_Type_FARP_REQ */
         os_bit32            Match_Code_Requester_Port_ID;
         os_bit32            Flags_Responder_Port_ID;
         FC_N_Port_Name_t    Port_Name_of_Requester;
         FC_Node_Name_t      Node_Name_of_Requester;
         FC_N_Port_Name_t    Port_Name_of_Responder;
         FC_Node_Name_t      Node_Name_of_Responder;
         os_bit8             IP_Address_of_Requester[16];
         os_bit8             IP_Address_of_Responder[16];
       };

#define FC_ELS_FARP_REQ_Match_Code_Points_MASK                            0xFF000000
#define FC_ELS_FARP_REQ_Match_Code_Points_SHIFT                                 0x18

#define FC_ELS_FARP_REQ_Match_Code_Points_Match_WW_PN                           0x01
#define FC_ELS_FARP_REQ_Match_Code_Points_Match_WW_NN                           0x02
#define FC_ELS_FARP_REQ_Match_Code_Points_Match_IPv4                            0x04

#define FC_ELS_FARP_REQ_Port_ID_of_Requester_MASK                         0x00FFFFFF
#define FC_ELS_FARP_REQ_Port_ID_of_Requester_SHIFT                              0x00

#define FC_ELS_FARP_REQ_Responder_Flags_MASK                              0xFF000000
#define FC_ELS_FARP_REQ_Responder_Flags_SHIFT                                   0x18

#define FC_ELS_FARP_REQ_Responder_Flags_Init_Plogi                              0x01
#define FC_ELS_FARP_REQ_Responder_Flags_Init_Reply                              0x02

#define FC_ELS_FARP_REQ_Port_ID_of_Responder_MASK                         0x00FFFFFF
#define FC_ELS_FARP_REQ_Port_ID_of_Responder_SHIFT                              0x00

typedef struct FC_ELS_FARP_REPLY_Payload_s
               FC_ELS_FARP_REPLY_Payload_t;

#define FC_ELS_ACC_FARP_Payload_t_SIZE                                   0x0000004C

struct FC_ELS_FARP_REPLY_Payload_s
       {
         os_bit32            ELS_Type; /* == FC_ELS_Type_FARP_REPLY */
         os_bit32            Match_Code_Requester_Port_ID;
         os_bit32            Flags_Responder_Port_ID;
         FC_N_Port_Name_t    Port_Name_of_Requester;
         FC_Node_Name_t      Node_Name_of_Requester;
         FC_N_Port_Name_t    Port_Name_of_Responder;
         FC_Node_Name_t      Node_Name_of_Responder;
         os_bit8             IP_Address_of_Requester[16];
         os_bit8             IP_Address_of_Responder[16];
       };
#endif /* _DvrArch_1_30_ was defined */

typedef union FC_ELS_ACC_Payload_u
              FC_ELS_ACC_Payload_t;

#define FC_ELS_ACC_Payload_t_SIZE                                         FC_Frame_Data_Size_Max

union FC_ELS_ACC_Payload_u
      {
        FC_ELS_ACC_Unknown_Payload_t Unknown;
        FC_ELS_ACC_PLOGI_Payload_t   PLOGI;
        FC_ELS_ACC_FLOGI_Payload_t   FLOGI;
        FC_ELS_ACC_LOGO_Payload_t    LOGO;
        FC_ELS_GENERIC_ACC_Payload_t ACC;
        FC_ELS_ACC_ABTX_Payload_t    ABTX;
        FC_ELS_ACC_RCS_Payload_t     RCS;
        FC_ELS_ACC_RES_Payload_t     RES;
        FC_ELS_ACC_RSS_Payload_t     RSS;
        FC_ELS_ACC_RSI_Payload_t     RSI;
        FC_ELS_ACC_ESTS_Payload_t    ESTS;
        FC_ELS_ACC_ADVC_Payload_t    ADVC;
        FC_ELS_ACC_RTV_Payload_t     RTV;
        FC_ELS_ACC_RLS_Payload_t     RLS;
        FC_ELS_ACC_ECHO_Payload_t    FC_ECHO;
        FC_ELS_ACC_RRQ_Payload_t     RRQ;
        FC_ELS_ACC_PRLI_Payload_t    PRLI;
        FC_ELS_ACC_PRLO_Payload_t    PRLO;
        FC_ELS_ACC_TPLS_Payload_t    TPLS;
        FC_ELS_ACC_GAID_Payload_t    GAID;
        FC_ELS_ACC_FACT_Payload_t    FACT;
        FC_ELS_ACC_FDACT_Payload_t   FDACT;
        FC_ELS_ACC_NACT_Payload_t    NACT;
        FC_ELS_ACC_NDACT_Payload_t   NDACT;
        FC_ELS_ACC_QoSR_Payload_t    QoSR;
        FC_ELS_ACC_RVCS_Payload_t    RVCS;
        FC_ELS_ACC_PDISC_Payload_t   PDISC;
        FC_ELS_ACC_FDISC_Payload_t   FDISC;
        FC_ELS_ACC_ADISC_Payload_t   ADISC;
        FC_ELS_ACC_TPRLO_Payload_t   TPRLO;
#ifdef _DvrArch_1_30_
        FC_ELS_FARP_REPLY_Payload_t  FARP;
#endif /* _DvrArch_1_30_ was defined */
      };

typedef union FC_ELS_Payload_u
              FC_ELS_Payload_t;

#define FC_ELS_Payload_t_SIZE                                             FC_Frame_Data_Size_Max

union FC_ELS_Payload_u
      {
        FC_ELS_Unknown_Payload_t            Unknown;
        FC_ELS_LS_RJT_Payload_t             LS_RJT;
        FC_ELS_GENERIC_ACC_Payload_t        ACC;
        FC_ELS_PLOGI_Payload_t              PLOGI;
        FC_ELS_FLOGI_Payload_t              FLOGI;
        FC_ELS_LOGO_Payload_t               LOGO;
        FC_ELS_ABTX_Payload_t               ABTX;
        FC_ELS_RCS_Payload_t                RCS;
        FC_ELS_RES_Payload_t                RES;
        FC_ELS_RSS_Payload_t                RSS;
        FC_ELS_RSI_Payload_t                RSI;
        FC_ELS_ESTS_Payload_t               ESTS;
        FC_ELS_ESTC_Payload_t               ESTC;
        FC_ELS_ADVC_Payload_t               ADVC;
        FC_ELS_RTV_Payload_t                RTV;
        FC_ELS_RLS_Payload_t                RLS;
        FC_ELS_ECHO_Payload_t               FC_ECHO;
        FC_ELS_TEST_Payload_t               TEST;
        FC_ELS_RRQ_Payload_t                RRQ;
        FC_ELS_PRLI_Payload_t               PRLI;
        FC_ELS_PRLO_Payload_t               PRLO;
        FC_ELS_SCN_Payload_t                SCN;
        FC_ELS_TPLS_Payload_t               TPLS;
        FC_ELS_GAID_Payload_t               GAID;
        FC_ELS_FACT_Payload_t               FACT;
        FC_ELS_FDACT_Payload_t              FDACT;
        FC_ELS_NACT_Payload_t               NACT;
        FC_ELS_NDACT_Payload_t              NDACT;
        FC_ELS_QoSR_Payload_t               QoSR;
        FC_ELS_RVCS_Payload_t               RVCS;
        FC_ELS_PDISC_Payload_t              PDISC;
        FC_ELS_FDISC_Payload_t              FDISC;
        FC_ELS_ADISC_Payload_t              ADISC;
        FC_ELS_TPRLO_Payload_t              TPRLO;
        FC_ELS_RSCN_Payload_t               RSCN;
        FC_ELS_SCR_Payload_t                SCR; 
        FC_ELS_SRR_Payload_t                SRR;
        FC_ELS_FAN_Payload_t                FAN;
#ifdef _DvrArch_1_30_
        FC_ELS_FARP_REQ_Payload_t           FARP;
#endif /* _DvrArch_1_30_ was defined */
      };

/*+
Loop Initialization (Section 10.4, FC-AL
                 and Section 10.4, FC-AL-2)
-*/

/*
 * Note: LoopInit ELS overloads TEST ELS
 *
 *       Check FC_ELS_TEST_Payload_t.ELS_Type os_bit32 for exact
 *       equality to FC_ELS_Type_TEST to detect a LoopInit ELS
 *
 *       In other words, while ELS_Type & FC_ELS_Type_MASK
 *       may be equal to FC_ELS_Type_TEST, ELS_Type may not be
 *       which would indicate this is some sort of LoopInit ELS
 */

#define FC_ELS_Type_LoopInit_Code_MASK                                    0xFFFF0000
#define FC_ELS_Type_LoopInit_Flags_MASK                                   0x0000FFFF

#define FC_ELS_Type_LoopInit_Code_LISM                                    0x11010000
#define FC_ELS_Type_LoopInit_Code_LIFA                                    0x11020000
#define FC_ELS_Type_LoopInit_Code_LIPA                                    0x11030000
#define FC_ELS_Type_LoopInit_Code_LIHA                                    0x11040000
#define FC_ELS_Type_LoopInit_Code_LISA                                    0x11050000
#define FC_ELS_Type_LoopInit_Code_LIRP                                    0x11060000
#define FC_ELS_Type_LoopInit_Code_LILP                                    0x11070000

#define FC_ELS_Type_LoopInit_LISA_Flag_LIRP_And_LILP_Supported            0x00000100

typedef struct FC_ELS_LoopInit_Unknown_Payload_s
               FC_ELS_LoopInit_Unknown_Payload_t;

#define FC_ELS_LoopInit_Unknown_Payload_t_SIZE                            0x00000004

struct FC_ELS_LoopInit_Unknown_Payload_s
       {
         os_bit32 Code_Flags; /* & FC_ELS_Type_MASK == FC_ELS_Type_TEST */
       };

typedef struct FC_ELS_LoopInit_Port_Name_Payload_s
               FC_ELS_LoopInit_Port_Name_Payload_t;

#define FC_ELS_LoopInit_Port_Name_Payload_t_SIZE                          0x0000000C

struct FC_ELS_LoopInit_Port_Name_Payload_s
       {
         os_bit32            Code_Flags; /* & FC_ELS_Type_LoopInit_Code_MASK == FC_ELS_Type_LoopInit_Code_LISM */
         FC_N_Port_Name_t Port_Name;
       };

#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_L_Bit                        0x80000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x00                         0x40000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x01                         0x20000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x02                         0x10000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x04                         0x08000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x08                         0x04000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x0F                         0x02000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x10                         0x01000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x17                         0x00800000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x18                         0x00400000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x1B                         0x00200000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x1D                         0x00100000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x1E                         0x00080000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x1F                         0x00040000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x23                         0x00020000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x25                         0x00010000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x26                         0x00008000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x27                         0x00004000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x29                         0x00002000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x2A                         0x00001000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x2B                         0x00000800
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x2C                         0x00000400
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x2D                         0x00000200
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x2E                         0x00000100
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x31                         0x00000080
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x32                         0x00000040
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x33                         0x00000020
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x34                         0x00000010
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x35                         0x00000008
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x36                         0x00000004
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x39                         0x00000002
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x3A                         0x00000001

#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x3C                         0x80000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x43                         0x40000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x45                         0x20000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x46                         0x10000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x47                         0x08000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x49                         0x04000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x4A                         0x02000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x4B                         0x01000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x4C                         0x00800000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x4D                         0x00400000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x4E                         0x00200000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x51                         0x00100000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x52                         0x00080000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x53                         0x00040000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x54                         0x00020000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x55                         0x00010000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x56                         0x00008000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x59                         0x00004000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x5A                         0x00002000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x5C                         0x00001000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x63                         0x00000800
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x65                         0x00000400
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x66                         0x00000200
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x67                         0x00000100
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x69                         0x00000080
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x6A                         0x00000040
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x6B                         0x00000020
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x6C                         0x00000010
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x6D                         0x00000008
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x6E                         0x00000004
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x71                         0x00000002
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x72                         0x00000001

#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x73                         0x80000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x74                         0x40000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x75                         0x20000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x76                         0x10000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x79                         0x08000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x7A                         0x04000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x7C                         0x02000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x80                         0x01000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x81                         0x00800000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x82                         0x00400000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x84                         0x00200000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x88                         0x00100000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x8F                         0x00080000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x90                         0x00040000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x97                         0x00020000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x98                         0x00010000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x9B                         0x00008000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x9D                         0x00004000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x9E                         0x00002000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x9F                         0x00001000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0xA3                         0x00000800
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0xA5                         0x00000400
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0xA6                         0x00000200
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0xA7                         0x00000100
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0xA9                         0x00000080
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0xAA                         0x00000040
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0xAB                         0x00000020
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0xAC                         0x00000010
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0xAD                         0x00000008
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0xAE                         0x00000004
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0xB1                         0x00000002
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0xB2                         0x00000001

#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xB3                         0x80000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xB4                         0x40000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xB5                         0x20000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xB6                         0x10000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xB9                         0x08000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xBA                         0x04000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xBC                         0x02000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xC3                         0x01000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xC5                         0x00800000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xC6                         0x00400000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xC7                         0x00200000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xC9                         0x00100000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xCA                         0x00080000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xCB                         0x00040000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xCC                         0x00020000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xCD                         0x00010000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xCE                         0x00008000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xD1                         0x00004000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xD2                         0x00002000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xD3                         0x00001000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xD4                         0x00000800
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xD5                         0x00000400
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xD6                         0x00000200
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xD9                         0x00000100
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xDA                         0x00000080
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xDC                         0x00000040
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xE0                         0x00000020
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xE1                         0x00000010
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xE2                         0x00000008
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xE4                         0x00000004
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xE8                         0x00000002
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xEF                         0x00000001

typedef struct FC_ELS_LoopInit_AL_PA_Bit_Map_Payload_s
               FC_ELS_LoopInit_AL_PA_Bit_Map_Payload_t;

#define FC_ELS_LoopInit_AL_PA_Bit_Map_Payload_t_SIZE                      0x00000014

struct FC_ELS_LoopInit_AL_PA_Bit_Map_Payload_s
       {
         os_bit32 Code_Flags; /* & FC_ELS_Type_LoopInit_Code_MASK == FC_ELS_Type_LoopInit_Code_LIFA
                                                               or FC_ELS_Type_LoopInit_Code_LIPA
                                                               or FC_ELS_Type_LoopInit_Code_LIHA
                                                               or FC_ELS_Type_LoopInit_Code_LISA */
         os_bit32 AL_PA_Bit_Map_Word_0;
         os_bit32 AL_PA_Bit_Map_Word_1;
         os_bit32 AL_PA_Bit_Map_Word_2;
         os_bit32 AL_PA_Bit_Map_Word_3;
       };

#define FC_ELS_LoopInit_AP_PA_Position_Map_Slots                                0x7F

typedef struct FC_ELS_LoopInit_AL_PA_Position_Map_Payload_s
               FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t;

#define FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t_SIZE                 0x00000084

struct FC_ELS_LoopInit_AL_PA_Position_Map_Payload_s
       {
         os_bit32 Code_Flags; /* & FC_ELS_Type_LoopInit_Code_MASK == FC_ELS_Type_LoopInit_Code_LIRP
                                                               or FC_ELS_Type_LoopInit_Code_LILP */
         os_bit8  AL_PA_Index;
         os_bit8  AL_PA_Slot[FC_ELS_LoopInit_AP_PA_Position_Map_Slots];
       };

typedef union FC_ELS_LoopInit_Payload_u
              FC_ELS_LoopInit_Payload_t;

union FC_ELS_LoopInit_Payload_u
      {
        FC_ELS_LoopInit_Unknown_Payload_t            Unknown;
        FC_ELS_LoopInit_Port_Name_Payload_t          Port_Name;
        FC_ELS_LoopInit_AL_PA_Bit_Map_Payload_t      AL_PA_Bit_Map;
        FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t AL_PA_Position_Map;
      };

/*+
Name Server (FC-GS-2)
-*/

typedef struct FC_CT_IU_HDR_s
               FC_CT_IU_HDR_t;

#define FC_CT_IU_HDR_t_SIZE                                               0x00000010

struct FC_CT_IU_HDR_s
       {
         os_bit32 Revision__IN_ID;
         os_bit32 FS_Type__FS_Subtype__Options;
         os_bit32 CommandResponse_Code__MaximumResidual_Size;
         os_bit32 Reason_Code__Reason_Code_Explanation__Vendor_Unique;
       };

#define FC_CT_IU_HDR_Revision_MASK                                        0xFF000000

#define FC_CT_IU_HDR_Revision_First_Revision                              0x01000000


#define FC_CT_IU_HDR_IN_ID_MASK                                           0x00FFFFFF

#define FC_CT_IU_HDR_FS_Type_MASK                                         0xFF000000
#define FC_CT_IU_HDR_FS_Type_Alias_Server_Application                     0xF8000000
#define FC_CT_IU_HDR_FS_Type_Management_Service_Application               0xFA000000
#define FC_CT_IU_HDR_FS_Type_Time_Service_Application                     0xFB000000
#define FC_CT_IU_HDR_FS_Type_Directory_Service_Application                0xFC000000
#define FC_CT_IU_HDR_FS_Type_Reserved_Fabric_Controller_Service           0xFD000000

#define FC_CT_IU_HDR_FS_Subtype_MASK                                      0x00FF0000
#define FC_CT_IU_HDR_FS_Subtype_Directory_Name_Service                    0x00020000

#define FC_CT_IU_HDR_Options_MASK                                         0x0000FF00
#define FC_CT_IU_HDR_Options_X_Bit_MASK                                   0x00008000
#define FC_CT_IU_HDR_Options_X_Bit_Single_Exchange                        0x00000000
#define FC_CT_IU_HDR_Options_X_Bit_Multiple_Exchanges                     0x00008000

#define FC_CT_IU_HDR_CommandResponse_Code_MASK                            0xFFFF0000
#define FC_CT_IU_HDR_CommandResponse_Code_Non_FS_IU                       0x00000000
#define FC_CT_IU_HDR_CommandResponse_Code_FS_REQ_IU_First                 0x00010000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GA_NXT                   0x01000000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GPN_ID                   0x01120000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GNN_ID                   0x01130000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GCS_ID                   0x01140000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GFT_ID                   0x01170000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GSPN_ID                  0x01180000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GPT_ID                   0x011A0000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GIPP_ID                  0x011B0000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GID_PN                   0x01210000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GIPP_PN                  0x012B0000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GID_NN                   0x01310000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GIP_NN                   0x01350000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GIPA_NN                  0x01360000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GSNN_NN                  0x01390000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GNN_IP                   0x01530000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GIPA_IP                  0x01560000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GID_FT                   0x01710000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GID_PT                   0x01A10000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GID_IPP                  0x01B10000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GPN_IPP                  0x01B20000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_RPN_ID                   0x02120000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_RNN_ID                   0x02130000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_RCS_ID                   0x02140000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_RFT_ID                   0x02170000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_RSPN_ID                  0x02180000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_RPT_ID                   0x021A0000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_RIPP_ID                  0x021B0000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_RIP_NN                   0x02350000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_RIPA_NN                  0x02360000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_RSNN_NN                  0x02390000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_DA_ID                    0x03000000
#define FC_CT_IU_HDR_CommandResponse_Code_FS_REQ_IU_Last                  0x7FFF0000
#define FC_CT_IU_HDR_CommandResponse_Code_FS_RJT_IU                       0x80010000
#define FC_CT_IU_HDR_CommandResponse_Code_FS_ACC_IU                       0x80020000

#define FC_CT_IU_HDR_MaximumResidual_Size_MASK                            0x0000FFFF
#define FC_CT_IU_HDR_MaximumResidual_Size_FS_REQ_No_Maximum               0x00000000
#define FC_CT_IU_HDR_MaximumResidual_Size_FS_REQ_Reserved                 0x0000FFFF
#define FC_CT_IU_HDR_MaximumResidual_Size_FS_ACC_All_Info_Returned        0x00000000
#define FC_CT_IU_HDR_MaximumResidual_Size_FS_ACC_More_Than_65534          0x0000FFFF

#define FC_CT_IU_HDR_Reason_Code_MASK                                     0x00FF0000
#define FC_CT_IU_HDR_Reason_Code_Unused                                   0x00000000
#define FC_CT_IU_HDR_Reason_Code_Invalid_Command_Code                     0x00010000
#define FC_CT_IU_HDR_Reason_Code_Invalid_Version_Level                    0x00020000
#define FC_CT_IU_HDR_Reason_Code_Logical_Error                            0x00030000
#define FC_CT_IU_HDR_Reason_Code_Invalid_IU_Size                          0x00040000
#define FC_CT_IU_HDR_Reason_Code_Logical_Busy                             0x00050000
#define FC_CT_IU_HDR_Reason_Code_Protocol_Error                           0x00070000
#define FC_CT_IU_HDR_Reason_Code_Unable_To_Perform_Command_Request        0x00090000
#define FC_CT_IU_HDR_Reason_Code_Command_Not_Supported                    0x000B0000
#define FC_CT_IU_HDR_Reason_Code_Vendor_Unique_Error                      0x00FF0000

#define FC_CT_IU_HDR_Reason_Code_Explanation_MASK                         0x0000FF00
#define FC_CT_IU_HDR_Reason_Code_Explanation_Unused                       0x00000000
#define FC_CT_IU_HDR_Reason_Code_Explanation_NS_RJC_No_Additional         0x00000000
#define FC_CT_IU_HDR_Reason_Code_Explanation_NS_RJC_PortID_Not_Reg        0x00000100
#define FC_CT_IU_HDR_Reason_Code_Explanation_NS_RJC_PortName_Not_Reg      0x00000200
#define FC_CT_IU_HDR_Reason_Code_Explanation_NS_RJC_NodeName_Not_Reg      0x00000300
#define FC_CT_IU_HDR_Reason_Code_Explanation_NS_RJC_Class_Not_Reg         0x00000400
#define FC_CT_IU_HDR_Reason_Code_Explanation_NS_RJC_Node_IP_Not_Reg       0x00000500
#define FC_CT_IU_HDR_Reason_Code_Explanation_NS_RJC_IPA_Not_Reg           0x00000600
#define FC_CT_IU_HDR_Reason_Code_Explanation_NS_RJC_FC_4_TYPEs_Not_Reg    0x00000700
#define FC_CT_IU_HDR_Reason_Code_Explanation_NS_RJC_Sym_PortName_Not_Reg  0x00000800
#define FC_CT_IU_HDR_Reason_Code_Explanation_NS_RJC_Sym_NodeName_Not_Reg  0x00000900
#define FC_CT_IU_HDR_Reason_Code_Explanation_NS_RJC_Port_Type_Not_Reg     0x00000A00
#define FC_CT_IU_HDR_Reason_Code_Explanation_NS_RJC_Port_IP_Not_Reg       0x00000B00
#define FC_CT_IU_HDR_Reason_Code_Explanation_NS_RJC_Access_Denied         0x00001000
#define FC_CT_IU_HDR_Reason_Code_Explanation_NS_RJC_Unacceptable_PortID   0x00001100
#define FC_CT_IU_HDR_Reason_Code_Explanation_NS_RJC_Database_Empty        0x00001200

#define FC_CT_IU_HDR_Vendor_Unique_MASK                                   0x000000FF
#define FC_CT_IU_HDR_Vendor_Unique_Unused                                 0x00000000

typedef os_bit8 FC_NS_Port_Type_t;

#define FC_NS_Port_Type_t_SIZE                                            0x00000001

#define FC_NS_Port_Type_Unidentified                                            0x00
#define FC_NS_Port_Type_N_Port                                                  0x01
#define FC_NS_Port_Type_NL_Port                                                 0x02
#define FC_NS_Port_Type_FNL_Port                                                0x03
#define FC_NS_Port_Type_Nx_Port                                                 0x7F
#define FC_NS_Port_Type_F_Port                                                  0x81
#define FC_NS_Port_Type_FL_Port                                                 0x82
#define FC_NS_Port_Type_E_Port                                                  0x84

typedef os_bit8 FC_NS_Port_ID_t            [3];

#define FC_NS_Port_ID_t_SIZE                                              0x00000003

typedef struct FC_NS_Control_Port_ID_s
               FC_NS_Control_Port_ID_t;

#define FC_NS_Control_Port_ID_t_SIZE                                      0x00000004

struct FC_NS_Control_Port_ID_s
       {
         os_bit8            Control;
         FC_NS_Port_ID_t Port_ID;
       };

#define FC_NS_Control_Port_ID_Control_MASK                                      0x80
#define FC_NS_Control_Port_ID_Control_Not_Last_Port_ID                          0x00
#define FC_NS_Control_Port_ID_Control_Last_Port_ID                              0x80

#define FC_NS_Control_Port_ID_MAX                                               0x80

typedef os_bit8 FC_NS_Port_Name_t          [8];

#define FC_NS_Port_Name_t_SIZE                                            0x00000008

typedef os_bit8 FC_NS_Node_Name_t          [8];

#define FC_NS_Node_Name_t_SIZE                                            0x00000008

#define FC_NS_Symbolic_Port_Name_Len_MAX                                        0xFF

typedef os_bit8 FC_NS_Symbolic_Port_Name_t [FC_NS_Symbolic_Port_Name_Len_MAX];

#define FC_NS_Symbolic_Port_Name_t_SIZE                                   FC_NS_Symbolic_Port_Name_Len_MAX

#define FC_NS_Symbolic_Node_Name_Len_MAX                                        0xFF

typedef os_bit8 FC_NS_Symbolic_Node_Name_t [FC_NS_Symbolic_Node_Name_Len_MAX];

#define FC_NS_Symbolic_Node_Name_t_SIZE                                   FC_NS_Symbolic_Node_Name_Len_MAX

typedef os_bit8 FC_NS_IPA_t                [8];

#define FC_NS_IPA_t_SIZE                                                  0x00000008

typedef os_bit8 FC_NS_IP_Address_t         [16];

#define FC_NS_IP_Address_t_SIZE                                           0x00000010

typedef os_bit8 FC_NS_Class_of_Service_t   [4];

#define FC_NS_Class_of_Service_t_SIZE                                     0x00000004

typedef os_bit32 FC_NS_FC_4_Type_Code_t;

#define FC_NS_FC_4_Type_Code_t_SIZE                                       0x00000004

typedef os_bit8 FC_NS_FC_4_Types_t         [32];

#define FC_NS_FC_4_Types_t_SIZE                                           0x00000020

typedef struct FC_NS_DU_GA_NXT_Request_Payload_s
               FC_NS_DU_GA_NXT_Request_Payload_t;

#define FC_NS_DU_GA_NXT_Request_Payload_t_SIZE                            0x00000004

struct FC_NS_DU_GA_NXT_Request_Payload_s
       {
            FC_Port_ID_Struct_Form_t Port_ID;
       };

typedef struct FC_NS_DU_GA_NXT_FS_ACC_Payload_s
               FC_NS_DU_GA_NXT_FS_ACC_Payload_t;

#define FC_NS_DU_GA_NXT_FS_ACC_Payload_t_SIZE                             0x00000260

struct FC_NS_DU_GA_NXT_FS_ACC_Payload_s
       {
         FC_NS_Port_Type_t          Port_Type;
         FC_NS_Port_ID_t            Port_ID;
         FC_NS_Port_Name_t          Port_Name;
         os_bit8                       Symbolic_Port_Name_LEN;
         FC_NS_Symbolic_Port_Name_t Symbolic_Port_Name;
         FC_NS_Node_Name_t          Node_Name;
         os_bit8                       Symbolic_Node_Name_LEN;
         FC_NS_Symbolic_Node_Name_t Symbolic_Node_Name;
         FC_NS_IPA_t                IPA;
         FC_NS_IP_Address_t         Node_IP_Address;
         FC_NS_Class_of_Service_t   Class_of_Service;
         FC_NS_FC_4_Types_t         FC_4_Types;
         FC_NS_IP_Address_t         Port_IP_Address;
       };

typedef struct FC_NS_DU_GPN_ID_Request_Payload_s
               FC_NS_DU_GPN_ID_Request_Payload_t;

#define FC_NS_DU_GPN_ID_Request_Payload_t_SIZE                            0x00000004

struct FC_NS_DU_GPN_ID_Request_Payload_s
       {
            FC_Port_ID_Struct_Form_t Port_ID;
       };

typedef struct FC_NS_DU_GPN_ID_FS_ACC_Payload_s
               FC_NS_DU_GPN_ID_FS_ACC_Payload_t;

#define FC_NS_DU_GPN_ID_FS_ACC_Payload_t_SIZE                             0x00000008

struct FC_NS_DU_GPN_ID_FS_ACC_Payload_s
       {
         FC_NS_Port_Name_t Port_Name;
       };

typedef struct FC_NS_DU_GNN_ID_Request_Payload_s
               FC_NS_DU_GNN_ID_Request_Payload_t;

#define FC_NS_DU_GNN_ID_Request_Payload_t_SIZE                            0x00000004

struct FC_NS_DU_GNN_ID_Request_Payload_s
       {
            FC_Port_ID_Struct_Form_t Port_ID;
       };

typedef struct FC_NS_DU_GNN_ID_FS_ACC_Payload_s
               FC_NS_DU_GNN_ID_FS_ACC_Payload_t;

#define FC_NS_DU_GNN_ID_FS_ACC_Payload_t_SIZE                             0x00000008

struct FC_NS_DU_GNN_ID_FS_ACC_Payload_s
       {
         FC_NS_Node_Name_t Node_Name;
       };

typedef struct FC_NS_DU_GCS_ID_Request_Payload_s
               FC_NS_DU_GCS_ID_Request_Payload_t;

#define FC_NS_DU_GCS_ID_Request_Payload_t_SIZE                            0x00000004

struct FC_NS_DU_GCS_ID_Request_Payload_s
       {
            FC_Port_ID_Struct_Form_t Port_ID;
       };

typedef struct FC_NS_DU_GCS_ID_FS_ACC_Payload_s
               FC_NS_DU_GCS_ID_FS_ACC_Payload_t;

#define FC_NS_DU_GCS_ID_FS_ACC_Payload_t_SIZE                             0x00000004

struct FC_NS_DU_GCS_ID_FS_ACC_Payload_s
       {
         FC_NS_Class_of_Service_t Class_of_Service;
       };

typedef struct FC_NS_DU_GFT_ID_Request_Payload_s
               FC_NS_DU_GFT_ID_Request_Payload_t;

#define FC_NS_DU_GFT_ID_Request_Payload_t_SIZE                            0x00000004

struct FC_NS_DU_GFT_ID_Request_Payload_s
       {
            FC_Port_ID_Struct_Form_t Port_ID;
       };

typedef struct FC_NS_DU_GFT_ID_FS_ACC_Payload_s
               FC_NS_DU_GFT_ID_FS_ACC_Payload_t;

#define FC_NS_DU_GFT_ID_FS_ACC_Payload_t_SIZE                             0x00000020

struct FC_NS_DU_GFT_ID_FS_ACC_Payload_s
       {
         FC_NS_FC_4_Types_t FC_4_Types;
       };

typedef struct FC_NS_DU_GSPN_ID_Request_Payload_s
               FC_NS_DU_GSPN_ID_Request_Payload_t;

#define FC_NS_DU_GSPN_ID_Request_Payload_t_SIZE                           0x00000004

struct FC_NS_DU_GSPN_ID_Request_Payload_s
       {
            FC_Port_ID_Struct_Form_t Port_ID;
       };

typedef struct FC_NS_DU_GSPN_ID_FS_ACC_Payload_s
               FC_NS_DU_GSPN_ID_FS_ACC_Payload_t;

#define FC_NS_DU_GSPN_ID_FS_ACC_Payload_t_SIZE                            0x00000100

struct FC_NS_DU_GSPN_ID_FS_ACC_Payload_s
       {
         os_bit8                    Symbolic_Port_Name_LEN;
         FC_NS_Symbolic_Port_Name_t Symbolic_Port_Name;
       };

typedef struct FC_NS_DU_GPT_ID_Request_Payload_s
               FC_NS_DU_GPT_ID_Request_Payload_t;

#define FC_NS_DU_GPT_ID_Request_Payload_t_SIZE                            0x00000004

struct FC_NS_DU_GPT_ID_Request_Payload_s
       {
            FC_Port_ID_Struct_Form_t Port_ID;
       };

typedef struct FC_NS_DU_GPT_ID_FS_ACC_Payload_s
               FC_NS_DU_GPT_ID_FS_ACC_Payload_t;

#define FC_NS_DU_GPT_ID_FS_ACC_Payload_t_SIZE                             0x00000004

struct FC_NS_DU_GPT_ID_FS_ACC_Payload_s
       {
         FC_NS_Port_Type_t Port_Type;
         os_bit8              Reserved[3];
       };

typedef struct FC_NS_DU_GIPP_ID_Request_Payload_s
               FC_NS_DU_GIPP_ID_Request_Payload_t;

#define FC_NS_DU_GIPP_ID_Request_Payload_t_SIZE                           0x00000004

struct FC_NS_DU_GIPP_ID_Request_Payload_s
       {
            FC_Port_ID_Struct_Form_t Port_ID;
       };

typedef struct FC_NS_DU_GIPP_ID_FS_ACC_Payload_s
               FC_NS_DU_GIPP_ID_FS_ACC_Payload_t;

#define FC_NS_DU_GIPP_ID_FS_ACC_Payload_t_SIZE                            0x00000010

struct FC_NS_DU_GIPP_ID_FS_ACC_Payload_s
       {
         FC_NS_IP_Address_t Port_IP_Address;
       };

typedef struct FC_NS_DU_GID_PN_Request_Payload_s
               FC_NS_DU_GID_PN_Request_Payload_t;

#define FC_NS_DU_GID_PN_Request_Payload_t_SIZE                            0x00000008

struct FC_NS_DU_GID_PN_Request_Payload_s
       {
         FC_NS_Port_Name_t Port_Name;
       };

typedef struct FC_NS_DU_GID_PN_FS_ACC_Payload_s
               FC_NS_DU_GID_PN_FS_ACC_Payload_t;

#define FC_NS_DU_GID_PN_FS_ACC_Payload_t_SIZE                             0x00000004

struct FC_NS_DU_GID_PN_FS_ACC_Payload_s
       {
            FC_Port_ID_Struct_Form_t Port_ID;
       };

typedef struct FC_NS_DU_GIPP_PN_Request_Payload_s
               FC_NS_DU_GIPP_PN_Request_Payload_t;

#define FC_NS_DU_GIPP_PN_Request_Payload_t_SIZE                           0x00000008

struct FC_NS_DU_GIPP_PN_Request_Payload_s
       {
         FC_NS_Port_Name_t Port_Name;
       };

typedef struct FC_NS_DU_GIPP_PN_FS_ACC_Payload_s
               FC_NS_DU_GIPP_PN_FS_ACC_Payload_t;

#define FC_NS_DU_GIPP_PN_FS_ACC_Payload_t_SIZE                            0x00000010

struct FC_NS_DU_GIPP_PN_FS_ACC_Payload_s
       {
         FC_NS_IP_Address_t Port_IP_Address;
       };

typedef struct FC_NS_DU_GID_NN_Request_Payload_s
               FC_NS_DU_GID_NN_Request_Payload_t;

#define FC_NS_DU_GID_NN_Request_Payload_t_SIZE                            0x00000008

struct FC_NS_DU_GID_NN_Request_Payload_s
       {
         FC_NS_Node_Name_t Node_Name;
       };

typedef struct FC_NS_DU_GID_NN_FS_ACC_Payload_s
               FC_NS_DU_GID_NN_FS_ACC_Payload_t;

#define FC_NS_DU_GID_NN_FS_ACC_Payload_t_SIZE                             0x00000200

struct FC_NS_DU_GID_NN_FS_ACC_Payload_s
       {
         FC_NS_Control_Port_ID_t Control_Port_ID[FC_NS_Control_Port_ID_MAX];
       };

typedef struct FC_NS_DU_GIP_NN_Request_Payload_s
               FC_NS_DU_GIP_NN_Request_Payload_t;

#define FC_NS_DU_GIP_NN_Request_Payload_t_SIZE                            0x00000008

struct FC_NS_DU_GIP_NN_Request_Payload_s
       {
         FC_NS_Node_Name_t Node_Name;
       };

typedef struct FC_NS_DU_GIP_NN_FS_ACC_Payload_s
               FC_NS_DU_GIP_NN_FS_ACC_Payload_t;

#define FC_NS_DU_GIP_NN_FS_ACC_Payload_t_SIZE                             0x00000010

struct FC_NS_DU_GIP_NN_FS_ACC_Payload_s
       {
         FC_NS_IP_Address_t Node_IP_Address;
       };

typedef struct FC_NS_DU_GIPA_NN_Request_Payload_s
               FC_NS_DU_GIPA_NN_Request_Payload_t;

#define FC_NS_DU_GIPA_NN_Request_Payload_t_SIZE                           0x00000008

struct FC_NS_DU_GIPA_NN_Request_Payload_s
       {
         FC_NS_Node_Name_t Node_Name;
       };

typedef struct FC_NS_DU_GIPA_NN_FS_ACC_Payload_s
               FC_NS_DU_GIPA_NN_FS_ACC_Payload_t;

#define FC_NS_DU_GIPA_NN_FS_ACC_Payload_t_SIZE                            0x00000008

struct FC_NS_DU_GIPA_NN_FS_ACC_Payload_s
       {
         FC_NS_IPA_t IPA;
       };

typedef struct FC_NS_DU_GSNN_NN_Request_Payload_s
               FC_NS_DU_GSNN_NN_Request_Payload_t;

#define FC_NS_DU_GSNN_NN_Request_Payload_t_SIZE                           0x00000008

struct FC_NS_DU_GSNN_NN_Request_Payload_s
       {
         FC_NS_Node_Name_t Node_Name;
       };

typedef struct FC_NS_DU_GSNN_NN_FS_ACC_Payload_s
               FC_NS_DU_GSNN_NN_FS_ACC_Payload_t;

#define FC_NS_DU_GSNN_NN_FS_ACC_Payload_t_SIZE                            0x00000100

struct FC_NS_DU_GSNN_NN_FS_ACC_Payload_s
       {
         os_bit8                       Symbolic_Node_Name_LEN;
         FC_NS_Symbolic_Node_Name_t Symbolic_Node_Name;
       };

typedef struct FC_NS_DU_GNN_IP_Request_Payload_s
               FC_NS_DU_GNN_IP_Request_Payload_t;

#define FC_NS_DU_GNN_IP_Request_Payload_t_SIZE                            0x00000010

struct FC_NS_DU_GNN_IP_Request_Payload_s
       {
         FC_NS_IP_Address_t Node_IP_Address;
       };

typedef struct FC_NS_DU_GNN_IP_FS_ACC_Payload_s
               FC_NS_DU_GNN_IP_FS_ACC_Payload_t;

#define FC_NS_DU_GNN_IP_FS_ACC_Payload_t_SIZE                             0x00000008

struct FC_NS_DU_GNN_IP_FS_ACC_Payload_s
       {
         FC_NS_Node_Name_t Node_Name;
       };

typedef struct FC_NS_DU_GIPA_IP_Request_Payload_s
               FC_NS_DU_GIPA_IP_Request_Payload_t;

#define FC_NS_DU_GIPA_IP_Request_Payload_t_SIZE                           0x00000010

struct FC_NS_DU_GIPA_IP_Request_Payload_s
       {
         FC_NS_IP_Address_t Node_IP_Address;
       };

typedef struct FC_NS_DU_GIPA_IP_FS_ACC_Payload_s
               FC_NS_DU_GIPA_IP_FS_ACC_Payload_t;

#define FC_NS_DU_GIPA_IP_FS_ACC_Payload_t_SIZE                            0x00000008

struct FC_NS_DU_GIPA_IP_FS_ACC_Payload_s
       {
         FC_NS_IPA_t IPA;
       };

typedef struct FC_NS_DU_GID_FT_Request_Payload_s
               FC_NS_DU_GID_FT_Request_Payload_t;

#define FC_NS_DU_GID_FT_Request_Payload_t_SIZE                            0x00000004

struct FC_NS_DU_GID_FT_Request_Payload_s
       {
         FC_NS_FC_4_Type_Code_t FC_4_Type_Code;
       };

#define FC_NS_DU_GID_FT_FC_Frame_Header_TYPE_SCSI_FCP_Shift               0x18

typedef struct FC_NS_DU_GID_FT_FS_ACC_Payload_s
               FC_NS_DU_GID_FT_FS_ACC_Payload_t;

#define FC_NS_DU_GID_FT_FS_ACC_Payload_t_SIZE                             0x00000200

struct FC_NS_DU_GID_FT_FS_ACC_Payload_s
       {
         FC_NS_Control_Port_ID_t Control_Port_ID[FC_NS_Control_Port_ID_MAX];
       };

typedef struct FC_NS_DU_GID_PT_Request_Payload_s
               FC_NS_DU_GID_PT_Request_Payload_t;

#define FC_NS_DU_GID_PT_Request_Payload_t_SIZE                            0x00000004

struct FC_NS_DU_GID_PT_Request_Payload_s
       {
         FC_NS_Port_Type_t Port_Type;
         os_bit8              Reserved[3];
       };

typedef struct FC_NS_DU_GID_PT_FS_ACC_Payload_s
               FC_NS_DU_GID_PT_FS_ACC_Payload_t;

#define FC_NS_DU_GID_PT_FS_ACC_Payload_t_SIZE                             0x00000200

struct FC_NS_DU_GID_PT_FS_ACC_Payload_s
       {
         FC_NS_Control_Port_ID_t Control_Port_ID[FC_NS_Control_Port_ID_MAX];
       };

typedef struct FC_NS_DU_GID_IPP_Request_Payload_s
               FC_NS_DU_GID_IPP_Request_Payload_t;

#define FC_NS_DU_GID_IPP_Request_Payload_t_SIZE                           0x00000010

struct FC_NS_DU_GID_IPP_Request_Payload_s
       {
         FC_NS_IP_Address_t Port_IP_Address;
       };

typedef struct FC_NS_DU_GID_IPP_FS_ACC_Payload_s
               FC_NS_DU_GID_IPP_FS_ACC_Payload_t;

#define FC_NS_DU_GID_IPP_FS_ACC_Payload_t_SIZE                            0x00000004

struct FC_NS_DU_GID_IPP_FS_ACC_Payload_s
       {
            FC_Port_ID_Struct_Form_t Port_ID;
       };

typedef struct FC_NS_DU_GPN_IPP_Request_Payload_s
               FC_NS_DU_GPN_IPP_Request_Payload_t;

#define FC_NS_DU_GPN_IPP_Request_Payload_t_SIZE                           0x00000010

struct FC_NS_DU_GPN_IPP_Request_Payload_s
       {
         FC_NS_IP_Address_t Port_IP_Address;
       };

typedef struct FC_NS_DU_GPN_IPP_FS_ACC_Payload_s
               FC_NS_DU_GPN_IPP_FS_ACC_Payload_t;

#define FC_NS_DU_GPN_IPP_FS_ACC_Payload_t_SIZE                            0x00000008

struct FC_NS_DU_GPN_IPP_FS_ACC_Payload_s
       {
         FC_NS_Port_Name_t Port_Name;
       };

typedef struct FC_NS_DU_RPN_ID_Payload_s
               FC_NS_DU_RPN_ID_Payload_t;

#define FC_NS_DU_RPN_ID_Payload_t_SIZE                                    0x0000000C

struct FC_NS_DU_RPN_ID_Payload_s
       {
         FC_Port_ID_Struct_Form_t   Port_ID;
         FC_NS_Port_Name_t          Port_Name;
       };

typedef struct FC_NS_DU_RNN_ID_Payload_s
               FC_NS_DU_RNN_ID_Payload_t;

#define FC_NS_DU_RNN_ID_Payload_t_SIZE                                    0x0000000C

struct FC_NS_DU_RNN_ID_Payload_s
       {
            FC_Port_ID_Struct_Form_t Port_ID;
            FC_NS_Node_Name_t        Node_Name;
       };

typedef struct FC_NS_DU_RCS_ID_Payload_s
               FC_NS_DU_RCS_ID_Payload_t;

#define FC_NS_DU_RCS_ID_Payload_t_SIZE                                    0x00000008

struct FC_NS_DU_RCS_ID_Payload_s
       {
         FC_Port_ID_Struct_Form_t Port_ID;
         FC_NS_Class_of_Service_t Class_of_Service;
       };

typedef struct FC_NS_DU_RFT_ID_Payload_s
               FC_NS_DU_RFT_ID_Payload_t;

#define FC_NS_DU_RFT_ID_Payload_t_SIZE                                    0x00000024

struct FC_NS_DU_RFT_ID_Payload_s
       {
         FC_Port_ID_Struct_Form_t Port_ID;
         FC_NS_FC_4_Types_t FC_4_Types;
       };

typedef struct FC_NS_DU_RSPN_ID_Payload_s
               FC_NS_DU_RSPN_ID_Payload_t;

#define FC_NS_DU_RSPN_ID_Payload_t_SIZE                                   0x00000104

struct FC_NS_DU_RSPN_ID_Payload_s
       {
         FC_Port_ID_Struct_Form_t Port_ID;
         os_bit8                   Symbolic_Port_Name_LEN;
         FC_NS_Symbolic_Port_Name_t Symbolic_Port_Name;
       };

typedef struct FC_NS_DU_RPT_ID_Payload_s
               FC_NS_DU_RPT_ID_Payload_t;

#define FC_NS_DU_RPT_ID_Payload_t_SIZE                                    0x00000008

struct FC_NS_DU_RPT_ID_Payload_s
       {
         FC_Port_ID_Struct_Form_t Port_ID;
         FC_NS_Port_Type_t Port_Type;
         os_bit8              Reserved_2[3];
       };

typedef struct FC_NS_DU_RIPP_ID_Payload_s
               FC_NS_DU_RIPP_ID_Payload_t;

#define FC_NS_DU_RIPP_ID_Payload_t_SIZE                                   0x00000014

struct FC_NS_DU_RIPP_ID_Payload_s
       {
         FC_Port_ID_Struct_Form_t Port_ID;
         FC_NS_IP_Address_t Port_IP_Address;
       };

typedef struct FC_NS_DU_RIP_NN_Payload_s
               FC_NS_DU_RIP_NN_Payload_t;

#define FC_NS_DU_RIP_NN_Payload_t_SIZE                                    0x00000018

struct FC_NS_DU_RIP_NN_Payload_s
       {
         FC_NS_Node_Name_t  Node_Name;
         FC_NS_IP_Address_t Node_IP_Address;
       };

typedef struct FC_NS_DU_RIPA_NN_Payload_s
               FC_NS_DU_RIPA_NN_Payload_t;

#define FC_NS_DU_RIPA_NN_Payload_t_SIZE                                   0x00000010

struct FC_NS_DU_RIPA_NN_Payload_s
       {
         FC_NS_Node_Name_t Node_Name;
         FC_NS_IPA_t       IPA;
       };

typedef struct FC_NS_DU_RSNN_NN_Payload_s
               FC_NS_DU_RSNN_NN_Payload_t;

#define FC_NS_DU_RSNN_NN_Payload_t_SIZE                                   0x00000108

struct FC_NS_DU_RSNN_NN_Payload_s
       {
         FC_NS_Node_Name_t          Node_Name;
         os_bit8                       Symbolic_Node_Name_LEN;
         FC_NS_Symbolic_Node_Name_t Symbolic_Node_Name;
       };

typedef struct FC_NS_DU_DA_ID_Payload_s
               FC_NS_DU_DA_ID_Payload_t;

#define FC_NS_DU_DA_ID_Payload_t_SIZE                                     0x00000004

struct FC_NS_DU_DA_ID_Payload_s
       {
         FC_Port_ID_Struct_Form_t Port_ID;
       };

/*+
FCP Services (Section 7, FCP-SCSI
            and Annex C, FCP-SCSI)
-*/

#define FC_FCP_CMND_FcpLun_LEVELS                                                  4

#define FC_FCP_CMND_FCP_LUN_0                                                      0
#define FC_FCP_CMND_FCP_LUN_1                                                      1
#define FC_FCP_CMND_FCP_LUN_2                                                      2
#define FC_FCP_CMND_FCP_LUN_3                                                      3

#define FC_FCP_CMND_FcpLun_LEVEL_1                                        FC_FCP_CMND_FCP_LUN_0
#define FC_FCP_CMND_FcpLun_LEVEL_2                                        FC_FCP_CMND_FCP_LUN_1
#define FC_FCP_CMND_FcpLun_LEVEL_3                                        FC_FCP_CMND_FCP_LUN_2
#define FC_FCP_CMND_FcpLun_LEVEL_4                                        FC_FCP_CMND_FCP_LUN_3

typedef struct FC_FCP_CMND_FcpLun_LEVEL_s
               FC_FCP_CMND_FcpLun_LEVEL_t;

#define FC_FCP_CMND_FcpLun_LEVEL_t_SIZE                                   0x00000002

struct FC_FCP_CMND_FcpLun_LEVEL_s
       {
         os_bit8 Byte_0;
         os_bit8 Byte_1;
       };

#define FC_FCP_CMND_FcpLun_LEVEL_Byte_0_AddessMethod_MASK                       0xC0
#define FC_FCP_CMND_FcpLun_LEVEL_Byte_0_AddessMethod_Peripheral                 0x00
#define FC_FCP_CMND_FcpLun_LEVEL_Byte_0_AddessMethod_VolumeSet                  0x40
#define FC_FCP_CMND_FcpLun_LEVEL_Byte_0_AddessMethod_LUN                        0x80
#define FC_FCP_CMND_FcpLun_LEVEL_Byte_0_AddessMethod_Reserved                   0xC0

/*
   Peripheral AddressMethod

                    bit number
              7  6  5  4  3  2  1  0
            +-=--=--=--=--=--=--=--=
          0 | 0  0  ----------Bus---   If Bus == 0, Byte 1 contains LUN
     byte   |
          1 | ---------Target/LUN---   If Bus != 0, Byte 1 contains Target
*/

#define FC_FCP_CMND_FcpLun_LEVEL_Peripheral_AM_Byte_0_Bus_MASK                  0x3F
#define FC_FCP_CMND_FcpLun_LEVEL_Peripheral_AM_Byte_0_Bus_SHIFT                 0x00

#define FC_FCP_CMND_FcpLun_LEVEL_Peripheral_AM_Byte_1_Target_MASK               0xFF
#define FC_FCP_CMND_FcpLun_LEVEL_Peripheral_AM_Byte_1_Target_SHIFT              0x00

#define FC_FCP_CMND_FcpLun_LEVEL_Peripheral_AM_Byte_1_LUN_MASK                  0xFF
#define FC_FCP_CMND_FcpLun_LEVEL_Peripheral_AM_Byte_1_LUN_SHIFT                 0x00

/*
   VolumeSet AddressMethod

                    bit number
              7  6  5  4  3  2  1  0
            +-=--=--=--=--=--=--=--=
          0 | 0  1  ----LUN[13:8]---
     byte   |
          1 | -----------LUN[7:0]---
*/

#define FC_FCP_CMND_FcpLun_LEVEL_VolumeSet_AM_LUN_Hi_Part_MASK                0x3F00
#define FC_FCP_CMND_FcpLun_LEVEL_VolumeSet_AM_LUN_Hi_Part_SHIFT                 0x08

#define FC_FCP_CMND_FcpLun_LEVEL_VolumeSet_AM_LUN_Lo_Part_MASK                0x00FF
#define FC_FCP_CMND_FcpLun_LEVEL_VolumeSet_AM_LUN_Lo_Part_SHIFT                 0x00

#define FC_FCP_CMND_FcpLun_LEVEL_VolumeSet_AM_Byte_0_LUN_Hi_MASK                0x3F
#define FC_FCP_CMND_FcpLun_LEVEL_VolumeSet_AM_Byte_0_LUN_Hi_SHIFT               0x00

#define FC_FCP_CMND_FcpLun_LEVEL_VolumeSet_AM_Byte_1_LUN_Lo_MASK                0xFF
#define FC_FCP_CMND_FcpLun_LEVEL_VolumeSet_AM_Byte_1_LUN_Lo_SHIFT               0x00

/*
   LUN AddressMethod

                    bit number
              7  6  5  4  3  2  1  0
            +-=--=--=--=--=--=--=--=
          0 | 1  0  -------Target---
     byte   |
          1 | --Bus--  -------LUN---
*/

#define FC_FCP_CMND_FcpLun_LEVEL_LUN_AM_Byte_0_Target_MASK                      0x3F
#define FC_FCP_CMND_FcpLun_LEVEL_LUN_AM_Byte_0_Target_SHIFT                     0x00

#define FC_FCP_CMND_FcpLun_LEVEL_LUN_AM_Byte_1_Bus_MASK                         0xE0
#define FC_FCP_CMND_FcpLun_LEVEL_LUN_AM_Byte_1_Bus_SHIFT                        0x05

#define FC_FCP_CMND_FcpLun_LEVEL_LUN_AM_Byte_1_LUN_MASK                         0x1F
#define FC_FCP_CMND_FcpLun_LEVEL_LUN_AM_Byte_1_LUN_SHIFT                        0x00

typedef struct FC_FCP_CMND_FcpCntl_s
               FC_FCP_CMND_FcpCntl_t;

#define FC_FCP_CMND_FcpCntl_t_SIZE                                        0x00000004

struct FC_FCP_CMND_FcpCntl_s
       {
         os_bit8 Reserved_Bit8;
         os_bit8 TaskCodes;
         os_bit8 TaskManagementFlags;
         os_bit8 ExecutionManagementCodes;
       };

#define FC_FCP_CMND_FcpCntl_TaskCodes_TaskAttribute_MASK                        0x07
#define FC_FCP_CMND_FcpCntl_TaskCodes_TaskAttribute_SIMPLE_Q                    0x00
#define FC_FCP_CMND_FcpCntl_TaskCodes_TaskAttribute_HEAD_OF_Q                   0x01
#define FC_FCP_CMND_FcpCntl_TaskCodes_TaskAttribute_ORDERED_Q                   0x02
#define FC_FCP_CMND_FcpCntl_TaskCodes_TaskAttribute_ACA_Q                       0x04
#define FC_FCP_CMND_FcpCntl_TaskCodes_TaskAttribute_UNTAGGED                    0x05

#define FC_FCP_CMND_FcpCntl_TaskManagementFlags_TERMINATE_TASK                  0x80
#define FC_FCP_CMND_FcpCntl_TaskManagementFlags_CLEAR_ACA                       0x40
#define FC_FCP_CMND_FcpCntl_TaskManagementFlags_TARGET_RESET                    0x20
#define FC_FCP_CMND_FcpCntl_TaskManagementFlags_CLEAR_TASK_SET                  0x04
#define FC_FCP_CMND_FcpCntl_TaskManagementFlags_ABORT_TASK_SET                  0x02

#define FC_FCP_CMND_FcpCntl_ExecutionManagementCodes_READ_DATA                  0x02
#define FC_FCP_CMND_FcpCntl_ExecutionManagementCodes_WRITE_DATA                 0x01

typedef struct FC_FCP_CMND_Payload_s
               FC_FCP_CMND_Payload_t;

#define FC_FCP_CMND_Payload_t_SIZE                                        0x00000020

struct FC_FCP_CMND_Payload_s
       {
         FC_FCP_CMND_FcpLun_LEVEL_t FcpLun[FC_FCP_CMND_FcpLun_LEVELS];
         FC_FCP_CMND_FcpCntl_t      FcpCntl;
         os_bit8                       FcpCdb[16];
         os_bit32                      FcpDL;
       };

typedef struct FC_FCP_RSP_FCP_STATUS_s
               FC_FCP_RSP_FCP_STATUS_t;

#define FC_FCP_RSP_FCP_STATUS_t_SIZE                                      0x00000004

struct FC_FCP_RSP_FCP_STATUS_s
       {
         os_bit8 Reserved_Bit8_0;
         os_bit8 Reserved_Bit8_1;
         os_bit8 ValidityStatusIndicators;
         os_bit8 SCSI_status_byte;
       };

#define FC_FCP_RSP_FCP_STATUS_ValidityStatusIndicators_FCP_RESID_UNDER          0x08
#define FC_FCP_RSP_FCP_STATUS_ValidityStatusIndicators_FCP_RESID_OVER           0x04
#define FC_FCP_RSP_FCP_STATUS_ValidityStatusIndicators_FCP_SNS_LEN_VALID        0x02
#define FC_FCP_RSP_FCP_STATUS_ValidityStatusIndicators_FCP_RSP_LEN_VALID        0x01

typedef struct FC_FCP_RSP_Payload_s
               FC_FCP_RSP_Payload_t;

#define FC_FCP_RSP_Payload_t_SIZE                                         0x00000018

struct FC_FCP_RSP_Payload_s
       {
         os_bit32                   Reserved_Bit32_0;
         os_bit32                   Reserved_Bit32_1;
         FC_FCP_RSP_FCP_STATUS_t FCP_STATUS;
         os_bit32                   FCP_RESID;
         os_bit32                   FCP_SNS_LEN;
         os_bit32                   FCP_RSP_LEN;
       };

/*+
Function:  FCStructASSERTs()

Purpose:   Returns the number of FCStruct.H typedefs which are not the correct size.

Algorithm: Each typedef in FCStruct.H is checked for having the correct size.  While
           this property doesn't guarantee correct packing of the fields within, it
           is a pretty good indicator that the typedef has the intended layout.

           The total number of typedefs which are not of correct size is returned from
           this function.  Hence, if the return value is non-zero, the declarations
           can not be trusted to match the various Fibre Channel specifications.
-*/

osGLOBAL os_bit32 FCStructASSERTs(
                              void
                            );

#endif /* __FCStruct_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\flashsvc.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/FlashSvc.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 10/24/00 6:54p  $ (Last Modified)

Purpose:

  This file implements Flash Services for the FC Layer.

--*/

#ifndef _New_Header_file_Layout_

#include "../h/globals.h"
#include "../h/state.h"
#include "../h/tlstruct.h"
#include "../h/memmap.h"
#include "../h/fcmain.h"
#include "../h/flashsvc.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"
#include "tlstruct.h"
#include "memmap.h"
#include "fcmain.h"
#include "flashsvc.h"
#endif  /* _New_Header_file_Layout_ */

os_bit32 fiFlashSvcASSERTs(
                         void
                       )
{
    os_bit32 to_return = 0;

    if ( sizeof(fiFlashBit16ToBit8s_t)          !=                       sizeof(os_bit16) ) to_return++;
    if ( sizeof(fiFlashBit32ToBit8s_t)          !=                       sizeof(os_bit32) ) to_return++;

    if ( sizeof(fiFlashSector_Bit8_Form_t)      !=                Am29F010_Sector_SIZE ) to_return++;
    if ( sizeof(fiFlashSector_Bit16_Form_t)     !=                Am29F010_Sector_SIZE ) to_return++;
    if ( sizeof(fiFlashSector_Bit32_Form_t)     !=                Am29F010_Sector_SIZE ) to_return++;
    if ( sizeof(fiFlashSector_Last_Form_t)      !=                Am29F010_Sector_SIZE ) to_return++;

#ifndef __FlashSvc_H__64KB_Struct_Size_Limited__
    if ( sizeof(fiFlashStructure_t)             !=                       Am29F010_SIZE ) to_return++;
#endif /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */

    return to_return;
}

agBOOLEAN fiFlashSvcInitialize(
                           agRoot_t  *hpRoot
                         )
{
    CThread_t          *CThread  = CThread_ptr(hpRoot);
    os_bit8             Sentinel;
    fiFlash_Card_WWN_t  WWN;

    /* Dump fiFlashStructure.Sector[fiFlashSector_Last] whether Present or Absent */

    if(    CThread->Calculation.Input.cardRomUpper32  == 0 &&
         ( CThread->Calculation.Input.cardRomLower32  == 0     ||
           CThread->Calculation.Input.cardRomLen      == 0        ))
    {
        CThread->flashPresent = agFALSE;
        fiFlashGet_Card_WWN( hpRoot, &WWN );

    }
    else
    {
        fiFlashDumpLastSector(
                               hpRoot
                             );

        /* Establish whether Flash is Present or Absent */

#ifdef __FlashSvc_H__64KB_Struct_Size_Limited__
        Sentinel = fiFlashReadBit8(
                                    hpRoot,
                                    hpFieldOffset(
                                                   fiFlashSector_Last_Form_t,
                                                   Sentinel
                                                 ) + (fiFlashSector_Last * sizeof(fiFlashSector_t))
                                  );
#else /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */
        Sentinel = fiFlashReadBit8(
                                    hpRoot,
                                    hpFieldOffset(
                                                   fiFlashStructure_t,
                                                   Sector[fiFlashSector_Last].Last_Form.Sentinel
                                                 )
                                  );
#endif /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */

        if (Sentinel == fiFlash_Sector_Sentinel_Byte)
        {
            /* Read Card's WWN from Flash */

#ifdef __FlashSvc_H__64KB_Struct_Size_Limited__
            fiFlashReadBlock(
                              hpRoot,
                              hpFieldOffset(
                                             fiFlashSector_Last_Form_t,
                                             Card_WWN
                                           ) + (fiFlashSector_Last * sizeof(fiFlashSector_t)),
                              WWN,
                              sizeof(fiFlash_Card_WWN_t)
                            );
#else /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */
            fiFlashReadBlock(
                              hpRoot,
                              hpFieldOffset(
                                             fiFlashStructure_t,
                                             Sector[fiFlashSector_Last].Last_Form.Card_WWN
                                           ),
                              WWN,
                              sizeof(fiFlash_Card_WWN_t)
                            );
#endif /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */

            /* Validate acceptable WWN found in Flash */

            if (   (WWN[0] != fiFlash_Card_WWN_0)
                || (WWN[1] != fiFlash_Card_WWN_1)
                || (WWN[2] != fiFlash_Card_WWN_2))
                {
                    fiLogDebugString(
                                      hpRoot,
                                      FlashSvcLogConsoleLevel,
                                      "fiFlashSvcInitialize(): Found invalid WWN in Flash!",
                                     (char *)agNULL,(char *)agNULL,
                                     (void *)agNULL,(void *)agNULL,
                                      0,0,0,0,0,0,0,0);

                    fiLogDebugString(
                                      hpRoot,
                                      FlashSvcLogConsoleLevel,
                                      "    WWN expected = %02X%02X%02X%s %s",
                                      "VV",
                                      "WWXXYYZZ",
                                      (void *)agNULL,(void *)agNULL,
                                      fiFlash_Card_WWN_0,
                                      fiFlash_Card_WWN_1,
                                      fiFlash_Card_WWN_2,
                                      0,0,0,0,0);

                    fiLogDebugString(
                                      hpRoot,
                                      FlashSvcLogConsoleLevel,
                                      "    WWN in Flash = %02X%02X%02X%02X %02X%02X%02X%02X",
                                     (char *)agNULL,(char *)agNULL,
                                     (void *)agNULL,(void *)agNULL,
                                      WWN[0],
                                      WWN[1],
                                      WWN[2],
                                      WWN[3],
                                      WWN[4],
                                      WWN[5],
                                      WWN[6],
                                      WWN[7]
                                    );
                }

            /* Indicate Flash is Present */

            CThread->flashPresent = agTRUE;
        }
        else /* Sentinel != fiFlash_Sector_Sentinel_Byte  (1st test) */
        {
            /* Return true to fail this card following code will write flash rom ! */
            return(agTRUE);

            fiFlashInitializeChip(
                                   hpRoot
                                 );

            /* Check to make sure initialization succeeded */

#ifdef __FlashSvc_H__64KB_Struct_Size_Limited__
            Sentinel = fiFlashReadBit8(
                                        hpRoot,
                                        hpFieldOffset(
                                                       fiFlashSector_Last_Form_t,
                                                       Sentinel
                                                     ) + (fiFlashSector_Last * sizeof(fiFlashSector_t))
                                      );
#else /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */
            Sentinel = fiFlashReadBit8(
                                        hpRoot,
                                        hpFieldOffset(
                                                       fiFlashStructure_t,
                                                       Sector[fiFlashSector_Last].Last_Form.Sentinel
                                                     )
                                      );
#endif /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */

            if (Sentinel == fiFlash_Sector_Sentinel_Byte)
            {
                /* Indicate Flash is Present */

                CThread->flashPresent = agTRUE;
            }
            else /* Sentinel != fiFlash_Sector_Sentinel_Byte (2nd test) */
            {
                /* Indicate Flash is Absent */

                CThread->flashPresent = agFALSE;
            }
        }

    }
    fiLogDebugString(
                      hpRoot,
                      FlashSvcLogConsoleLevel,
                      "fiFlashSvcInitialize(): CThread->flashPresent set to %1x",
                     (char *)agNULL,(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                      (os_bit32)CThread->flashPresent,
                     0,0,0,0,0,0,0);

    /* Fill in NodeWWN and PortWWN in ChanInfo */

    CThread->ChanInfo.NodeWWN[0]= WWN[0];
    CThread->ChanInfo.NodeWWN[1]= WWN[1];
    CThread->ChanInfo.NodeWWN[2]= WWN[2];
    CThread->ChanInfo.NodeWWN[3]= WWN[3];
    CThread->ChanInfo.NodeWWN[4]= WWN[4];
    CThread->ChanInfo.NodeWWN[5]= WWN[5];
    CThread->ChanInfo.NodeWWN[6]= WWN[6];
    CThread->ChanInfo.NodeWWN[7]= (os_bit8)(WWN[7] ^ 0x01); /* Flip low bit to construct NodeWWN from PortWWN */

    CThread->ChanInfo.PortWWN[0]= WWN[0];
    CThread->ChanInfo.PortWWN[1]= WWN[1];
    CThread->ChanInfo.PortWWN[2]= WWN[2];
    CThread->ChanInfo.PortWWN[3]= WWN[3];
    CThread->ChanInfo.PortWWN[4]= WWN[4];
    CThread->ChanInfo.PortWWN[5]= WWN[5];
    CThread->ChanInfo.PortWWN[6]= WWN[6];
    CThread->ChanInfo.PortWWN[7]= WWN[7];
    return(agFALSE);

}

void fiFlashDumpLastSector(
                            agRoot_t *hpRoot
                          )
{
    CThread_t                 *CThread               = CThread_ptr(hpRoot);
    agBOOLEAN                    flashPresent_at_entry = CThread->flashPresent;
    fiFlashSector_Last_Form_t *Last_Sector           = CThread->Calculation.MemoryLayout.FlashSector.addr.CachedMemory.cachedMemoryPtr;

    /* Make sure FLASH appears to be present upon entry */

    CThread->flashPresent = agTRUE;

    /* Fetch Last_Sector from FLASH */

    fiFlashGet_Last_Sector(
                            hpRoot,
                            Last_Sector
                          );

    /* Now return entry value of CThread->flashPresent */

    CThread->flashPresent = flashPresent_at_entry;

    /* Finally, dump "interesting" contents of Last_Sector */

    fiLogDebugString(
                      hpRoot,
                      FlashSvcLogConsoleLevel,
                      "fiFlashDumpLastSector(): Assembly_Info = %02X %02X %02X %02X %02X %02X %02X %02X",
                     (char *)agNULL,(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                      Last_Sector->Assembly_Info[ 0],
                      Last_Sector->Assembly_Info[ 1],
                      Last_Sector->Assembly_Info[ 2],
                      Last_Sector->Assembly_Info[ 3],
                      Last_Sector->Assembly_Info[ 4],
                      Last_Sector->Assembly_Info[ 5],
                      Last_Sector->Assembly_Info[ 6],
                      Last_Sector->Assembly_Info[ 7]
                    );

    fiLogDebugString(
                      hpRoot,
                      FlashSvcLogConsoleLevel,
                      "fiFlashDumpLastSector():                 %02X %02X %02X %02X %02X %02X %02X %02X",
                     (char *)agNULL,(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                      Last_Sector->Assembly_Info[ 8],
                      Last_Sector->Assembly_Info[ 9],
                      Last_Sector->Assembly_Info[10],
                      Last_Sector->Assembly_Info[11],
                      Last_Sector->Assembly_Info[12],
                      Last_Sector->Assembly_Info[13],
                      Last_Sector->Assembly_Info[14],
                      Last_Sector->Assembly_Info[15]
                    );

    fiLogDebugString(
                      hpRoot,
                      FlashSvcLogConsoleLevel,
                      "fiFlashDumpLastSector():                 %02X %02X %02X %02X %02X %02X %02X %02X",
                     (char *)agNULL,(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                      Last_Sector->Assembly_Info[16],
                      Last_Sector->Assembly_Info[17],
                      Last_Sector->Assembly_Info[18],
                      Last_Sector->Assembly_Info[19],
                      Last_Sector->Assembly_Info[20],
                      Last_Sector->Assembly_Info[21],
                      Last_Sector->Assembly_Info[22],
                      Last_Sector->Assembly_Info[23]
                    );

    fiLogDebugString(
                      hpRoot,
                      FlashSvcLogConsoleLevel,
                      "fiFlashDumpLastSector():                 %02X %02X %02X %02X %02X %02X %02X %02X",
                     (char *)agNULL,(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                      Last_Sector->Assembly_Info[24],
                      Last_Sector->Assembly_Info[25],
                      Last_Sector->Assembly_Info[26],
                      Last_Sector->Assembly_Info[27],
                      Last_Sector->Assembly_Info[28],
                      Last_Sector->Assembly_Info[29],
                      Last_Sector->Assembly_Info[30],
                      Last_Sector->Assembly_Info[31]
                    );

    fiLogDebugString(
                      hpRoot,
                      FlashSvcLogConsoleLevel,
                      "fiFlashDumpLastSector(): Hard_Address  = %02X %02X %02X",
                     (char *)agNULL,(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                      Last_Sector->Hard_Domain_Address,
                      Last_Sector->Hard_Area_Address,
                      Last_Sector->Hard_Loop_Address,
                      0,0,0,0,0
                    );

    fiLogDebugString(
                      hpRoot,
                      FlashSvcLogConsoleLevel,
                      "fiFlashDumpLastSector(): Sentinel      = %02X",
                     (char *)agNULL,(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                      Last_Sector->Sentinel,
                      0,0,0,0,0,0,0
                    );

    fiLogDebugString(
                      hpRoot,
                      FlashSvcLogConsoleLevel,
                      "fiFlashDumpLastSector(): Card_WWN      = %02X %02X %02X %02X %02X %02X %02X %02X",
                     (char *)agNULL,(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                      Last_Sector->Card_WWN[0],
                      Last_Sector->Card_WWN[1],
                      Last_Sector->Card_WWN[2],
                      Last_Sector->Card_WWN[3],
                      Last_Sector->Card_WWN[4],
                      Last_Sector->Card_WWN[5],
                      Last_Sector->Card_WWN[6],
                      Last_Sector->Card_WWN[7]
                    );

    fiLogDebugString(
                      hpRoot,
                      FlashSvcLogConsoleLevel,
                      "fiFlashDumpLastSector(): Card_SVID     = %08X",
                     (char *)agNULL,(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                      Last_Sector->Card_SVID,
                      0,0,0,0,0,0,0
                    );
}

void fiFlashInitializeChip(
                            agRoot_t *hpRoot
                          )
{
    CThread_t                 *CThread     = CThread_ptr(hpRoot);
    fiFlashSector_Last_Form_t *Last_Sector = CThread->Calculation.MemoryLayout.FlashSector.addr.CachedMemory.cachedMemoryPtr;

    /* Make sure FLASH appears to NOT be present upon entry */

    CThread->flashPresent = agFALSE;

    /* Fetch Last_Sector Template w/ Defaults filled in */

    fiFlashGet_Last_Sector(
                            hpRoot,
                            Last_Sector
                          );

    /* Now indicate that FLASH is present so that fiFlashUpdate_Last_Sector() will function */

    CThread->flashPresent = agTRUE;

    /* Update Last_Sector (w/out setting Sentinel byte) */

    fiFlashUpdate_Last_Sector(
                               hpRoot,
                               Last_Sector
                             );

    /* Finally, now that Last_Sector is successfully written, set the Sentinel byte */

#ifdef __FlashSvc_H__64KB_Struct_Size_Limited__
    fiFlashWriteBit8(
                      hpRoot,
                      hpFieldOffset(
                                     fiFlashSector_Last_Form_t,
                                     Sentinel
                                   ) + (fiFlashSector_Last * sizeof(fiFlashSector_t)),
                      fiFlash_Sector_Sentinel_Byte
                    );
#else /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */
    fiFlashWriteBit8(
                      hpRoot,
                      hpFieldOffset(
                                     fiFlashStructure_t,
                                     Sector[fiFlashSector_Last].Last_Form.Sentinel
                                   ),
                      fiFlash_Sector_Sentinel_Byte
                    );
#endif /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */
}

void fiFlashFill_Assembly_Info( fiFlashSector_Last_Form_t    *Last_Sector,
                                fiFlash_Card_Assembly_Info_t *Assembly_Info
                              )
{
    os_bit32 i;

    for (i = 0;
         i < sizeof(fiFlash_Card_Assembly_Info_t);
         i++)
    {
        Last_Sector->Assembly_Info[i] = (*Assembly_Info)[i];
    }
}

void fiFlashFill_Hard_Address( fiFlashSector_Last_Form_t *Last_Sector,
                               os_bit8                       Hard_Domain_Address,
                               os_bit8                       Hard_Area_Address,
                               os_bit8                       Hard_Loop_Address
                             )
{
    Last_Sector->Hard_Domain_Address = Hard_Domain_Address;
    Last_Sector->Hard_Area_Address   = Hard_Area_Address;
    Last_Sector->Hard_Loop_Address   = Hard_Loop_Address;
}

void fiFlashFill_Card_WWN( fiFlashSector_Last_Form_t *Last_Sector,
                           fiFlash_Card_WWN_t        *Card_WWN
                         )
{
    os_bit32 i;

    for (i = 0;
         i < sizeof(fiFlash_Card_WWN_t);
         i++)
    {
        Last_Sector->Card_WWN[i] = (*Card_WWN)[i];
    }
}

void fiFlashFill_Card_SVID( fiFlashSector_Last_Form_t *Last_Sector,
                            fiFlash_Card_SVID_t        Card_SVID
                          )
{
    Last_Sector->Card_SVID = Card_SVID;
}

void fiFlashGet_Last_Sector(
                             agRoot_t                  *hpRoot,
                             fiFlashSector_Last_Form_t *Last_Sector
                           )
{
    CThread_t                 *CThread               = CThread_ptr(hpRoot);
#ifdef __FlashSvc_H__64KB_Struct_Size_Limited__
    os_bit32                      Last_Sector_Offset    = fiFlashSector_Last * sizeof(fiFlashSector_t);
#else /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */
    os_bit32                      Last_Sector_Offset    = hpFieldOffset(fiFlashStructure_t,Sector[fiFlashSector_Last]);
#endif /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */
    fiFlashSector_Bit8_Form_t *Last_Sector_Bit8_Form;
    os_bit32      i;

    if (CThread->flashPresent == agTRUE)
    {
        fiFlashReadBlock(
                          hpRoot,
                          Last_Sector_Offset,
                          (void *)Last_Sector,
                          sizeof(fiFlashSector_Last_Form_t)
                        );
    }
    else /* CThread->flashPresent == agFALSE */
    {
        /* Initialize Last_Sector Template */

        Last_Sector_Bit8_Form = (fiFlashSector_Bit8_Form_t *)Last_Sector;

        for (i = 0;
             i < sizeof(fiFlashSector_Bit8_Form_t);
             i++)
        {
            Last_Sector_Bit8_Form->Bit8[i] = Am29F010_Erased_Bit8;
        }

        /* Fill in Last_Sector default/initial values (that can be computed) */

        fiFlashGet_Assembly_Info(
                                  hpRoot,
                                  &(Last_Sector->Assembly_Info)
                                );

        fiFlashGet_Hard_Address(
                                 hpRoot,
                                 &(Last_Sector->Hard_Domain_Address),
                                 &(Last_Sector->Hard_Area_Address),
                                 &(Last_Sector->Hard_Loop_Address)
                               );

        fiFlashGet_Card_WWN(
                             hpRoot,
                             &(Last_Sector->Card_WWN)
                           );

        fiFlashGet_Card_SVID(
                              hpRoot,
                              &(Last_Sector->Card_SVID)
                            );
    }
}

void fiFlashGet_Assembly_Info(
                               agRoot_t                     *hpRoot,
                               fiFlash_Card_Assembly_Info_t *Assembly_Info
                             )
{
    CThread_t *CThread              = CThread_ptr(hpRoot);
#ifdef __FlashSvc_H__64KB_Struct_Size_Limited__
    os_bit32      Assembly_Info_Offset = hpFieldOffset(fiFlashSector_Last_Form_t,Assembly_Info) + (fiFlashSector_Last * sizeof(fiFlashSector_t));
#else /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */
    os_bit32      Assembly_Info_Offset = hpFieldOffset(fiFlashStructure_t,Sector[fiFlashSector_Last].Last_Form.Assembly_Info);
#endif /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */
    os_bit32      i;

    if (CThread->flashPresent == agTRUE)
    {
        fiFlashReadBlock(
                          hpRoot,
                          Assembly_Info_Offset,
                          (void *)Assembly_Info,
                          sizeof(fiFlash_Card_Assembly_Info_t)
                        );
    }
    else /* CThread->flashPresent == agFALSE */
    {
        /* Initialize Last_Sector Template */

        for (i = 0;
             i < sizeof(fiFlash_Card_Assembly_Info_t);
             i++)
        {
            (*Assembly_Info)[i] = Am29F010_Erased_Bit8;
        }
    }
}

void fiFlashGet_Hard_Address(
                              agRoot_t *hpRoot,
                              os_bit8     *Hard_Domain_Address,
                              os_bit8     *Hard_Area_Address,
                              os_bit8     *Hard_Loop_Address
                            )
{
    CThread_t *CThread                    = CThread_ptr(hpRoot);
#ifdef __FlashSvc_H__64KB_Struct_Size_Limited__
    os_bit32      Hard_Domain_Address_Offset = hpFieldOffset(fiFlashSector_Last_Form_t,Hard_Domain_Address) + (fiFlashSector_Last * sizeof(fiFlashSector_t));
    os_bit32      Hard_Area_Address_Offset   = hpFieldOffset(fiFlashSector_Last_Form_t,Hard_Area_Address) + (fiFlashSector_Last * sizeof(fiFlashSector_t));
    os_bit32      Hard_Loop_Address_Offset   = hpFieldOffset(fiFlashSector_Last_Form_t,Hard_Loop_Address) + (fiFlashSector_Last * sizeof(fiFlashSector_t));
#else /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */
    os_bit32      Hard_Domain_Address_Offset = hpFieldOffset(fiFlashStructure_t,Sector[fiFlashSector_Last].Last_Form.Hard_Domain_Address);
    os_bit32      Hard_Area_Address_Offset   = hpFieldOffset(fiFlashStructure_t,Sector[fiFlashSector_Last].Last_Form.Hard_Area_Address);
    os_bit32      Hard_Loop_Address_Offset   = hpFieldOffset(fiFlashStructure_t,Sector[fiFlashSector_Last].Last_Form.Hard_Loop_Address);
#endif /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */

    if (CThread->flashPresent == agTRUE)
    {
        *Hard_Domain_Address = fiFlashReadBit8(
                                                hpRoot,
                                                Hard_Domain_Address_Offset
                                              );

        *Hard_Area_Address   = fiFlashReadBit8(
                                                hpRoot,
                                                Hard_Area_Address_Offset
                                              );

        *Hard_Loop_Address   = fiFlashReadBit8(
                                                hpRoot,
                                                Hard_Loop_Address_Offset
                                              );
    }
    else /* CThread->flashPresent == agFALSE */
    {
        /* Indicate no Hard Domain/Area/Loop Address */

        *Hard_Domain_Address = fiFlash_Card_Unassigned_Domain_Address;
        *Hard_Area_Address   = fiFlash_Card_Unassigned_Area_Address;
        *Hard_Loop_Address   = fiFlash_Card_Unassigned_Loop_Address;
    }
}

void fiFlashGet_Card_WWN(
                          agRoot_t           *hpRoot,
                          fiFlash_Card_WWN_t *Card_WWN
                        )
{
    CThread_t *CThread         = CThread_ptr(hpRoot);
#ifdef __FlashSvc_H__64KB_Struct_Size_Limited__
    os_bit32      Card_WWN_Offset = hpFieldOffset(fiFlashSector_Last_Form_t,Card_WWN) + (fiFlashSector_Last * sizeof(fiFlashSector_t));
#else /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */
    os_bit32      Card_WWN_Offset = hpFieldOffset(fiFlashStructure_t,Sector[fiFlashSector_Last].Last_Form.Card_WWN);
#endif /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */

    if (CThread->flashPresent == agTRUE)
    {
        fiFlashReadBlock(
                          hpRoot,
                          Card_WWN_Offset,
                          (void *)Card_WWN,
                          sizeof(fiFlash_Card_WWN_t)
                        );
    }
    else /* CThread->flashPresent == agFALSE */
    {
        /* Manufacture reasonable WWN */

        (*Card_WWN)[0] = fiFlash_Card_WWN_0_DEFAULT(hpRoot);
        (*Card_WWN)[1] = fiFlash_Card_WWN_1_DEFAULT(hpRoot);
        (*Card_WWN)[2] = fiFlash_Card_WWN_2_DEFAULT(hpRoot);
        (*Card_WWN)[3] = fiFlash_Card_WWN_3_DEFAULT(hpRoot);
        (*Card_WWN)[4] = fiFlash_Card_WWN_4_DEFAULT(hpRoot);
        (*Card_WWN)[5] = fiFlash_Card_WWN_5_DEFAULT(hpRoot);
        (*Card_WWN)[6] = fiFlash_Card_WWN_6_DEFAULT(hpRoot);
        (*Card_WWN)[7] = fiFlash_Card_WWN_7_DEFAULT(hpRoot);
    }
}

void fiFlashGet_Card_SVID(
                           agRoot_t            *hpRoot,
                           fiFlash_Card_SVID_t *Card_SVID
                         )
{
    CThread_t *CThread          = CThread_ptr(hpRoot);
    os_bit32      Chip_DEVID       = CThread->DEVID;
#ifdef __FlashSvc_H__64KB_Struct_Size_Limited__
    os_bit32      Card_SVID_Offset = hpFieldOffset(fiFlashSector_Last_Form_t,Card_SVID) + (fiFlashSector_Last * sizeof(fiFlashSector_t));
#else /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */
    os_bit32      Card_SVID_Offset = hpFieldOffset(fiFlashStructure_t,Sector[fiFlashSector_Last].Last_Form.Card_SVID);
#endif /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */

    if (CThread->flashPresent == agTRUE)
    {
        *Card_SVID = fiFlashReadBit32(
                                       hpRoot,
                                       Card_SVID_Offset
                                     );
    }
    else /* CThread->flashPresent == agFALSE */
    {
        /* Determine appropriate SVID */

        if (Chip_DEVID == ChipConfig_DEVID_TachyonTL)
        {
            /* Card contains TachyonTL - assume it is an HHBA-5100A or an HHBA-5101A */

            *Card_SVID = ChipConfig_SubsystemID_HHBA5100A_or_HHBA5101A | ChipConfig_SubsystemVendorID_Hewlett_Packard;
        }
        else if (Chip_DEVID == ChipConfig_DEVID_TachyonTS)
        {
            /* Card contains TachyonTS - assume it is an HHBA-5121A */

            *Card_SVID = ChipConfig_SubsystemID_HHBA5121A | ChipConfig_SubsystemVendorID_Hewlett_Packard;
        }
        else /* Unknown CThread->DEVID */
        {
            *Card_SVID = 0;

            fiLogDebugString(
                              hpRoot,
                              FlashSvcLogConsoleLevel,
                              "fiFlashGet_Card_SVID(): Unknown DEVID (0x%04X) - no known HBA SVID applies !!!",
                             (char *)agNULL,(char *)agNULL,
                             (void *)agNULL,(void *)agNULL,
                              (Chip_DEVID >> 16),
                              0,0,0,0,0,0,0
                            );
        }
    }
}

void fiFlashSet_Assembly_Info(
                               agRoot_t                     *hpRoot,
                               fiFlash_Card_Assembly_Info_t *Assembly_Info
                             )
{
    CThread_t                 *CThread     = CThread_ptr(hpRoot);
    fiFlashSector_Last_Form_t *Last_Sector = CThread->Calculation.MemoryLayout.FlashSector.addr.CachedMemory.cachedMemoryPtr;

    fiFlashGet_Last_Sector(
                            hpRoot,
                            Last_Sector
                          );

    fiFlashFill_Assembly_Info( Last_Sector,
                               Assembly_Info
                             );

    fiFlashUpdate_Last_Sector(
                               hpRoot,
                               Last_Sector
                             );
}

void fiFlashSet_Hard_Address(
                              agRoot_t *hpRoot,
                              os_bit8      Hard_Domain_Address,
                              os_bit8      Hard_Area_Address,
                              os_bit8      Hard_Loop_Address
                            )
{
    CThread_t                 *CThread     = CThread_ptr(hpRoot);
    fiFlashSector_Last_Form_t *Last_Sector = CThread->Calculation.MemoryLayout.FlashSector.addr.CachedMemory.cachedMemoryPtr;

    fiFlashGet_Last_Sector(
                            hpRoot,
                            Last_Sector
                          );

    fiFlashFill_Hard_Address( Last_Sector,
                              Hard_Domain_Address,
                              Hard_Area_Address,
                              Hard_Loop_Address
                            );

    fiFlashUpdate_Last_Sector(
                               hpRoot,
                               Last_Sector
                             );
}

void fiFlashSet_Card_WWN(
                          agRoot_t           *hpRoot,
                          fiFlash_Card_WWN_t *Card_WWN
                        )
{
    CThread_t                 *CThread     = CThread_ptr(hpRoot);
    fiFlashSector_Last_Form_t *Last_Sector = CThread->Calculation.MemoryLayout.FlashSector.addr.CachedMemory.cachedMemoryPtr;

    fiFlashGet_Last_Sector(
                            hpRoot,
                            Last_Sector
                          );

    fiFlashFill_Card_WWN( Last_Sector,
                          Card_WWN
                        );

    fiFlashUpdate_Last_Sector(
                               hpRoot,
                               Last_Sector
                             );
}

void fiFlashSet_Card_SVID(
                           agRoot_t            *hpRoot,
                           fiFlash_Card_SVID_t  Card_SVID
                         )
{
    CThread_t                 *CThread     = CThread_ptr(hpRoot);
    fiFlashSector_Last_Form_t *Last_Sector = CThread->Calculation.MemoryLayout.FlashSector.addr.CachedMemory.cachedMemoryPtr;

    fiFlashGet_Last_Sector(
                            hpRoot,
                            Last_Sector
                          );

    fiFlashFill_Card_SVID( Last_Sector,
                           Card_SVID
                         );

    fiFlashUpdate_Last_Sector(
                               hpRoot,
                               Last_Sector
                             );
}

void fiFlashUpdate_Last_Sector(
                                agRoot_t                  *hpRoot,
                                fiFlashSector_Last_Form_t *Last_Sector
                              )
{
#ifdef __FlashSvc_H__64KB_Struct_Size_Limited__
    os_bit32 Last_Sector_Offset = fiFlashSector_Last * sizeof(fiFlashSector_t);
#else /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */
    os_bit32 Last_Sector_Offset = hpFieldOffset(fiFlashStructure_t,Sector[fiFlashSector_Last]);
#endif /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */

    fiFlashEraseSector(
                        hpRoot,
                        fiFlashSector_Last
                      );

    fiFlashWriteBlock(
                       hpRoot,
                       Last_Sector_Offset,
                       (void *)Last_Sector,
                       sizeof(fiFlashSector_Last_Form_t)
                     );
}

void fiFlashEraseChip(
                       agRoot_t *hpRoot
                     )
{
#ifdef OSLayer_Stub
    os_bit32 flashOffset  = 0;
    os_bit32 flashChipLen = Am29F010_Num_Sectors * Am29F010_Sector_SIZE;

    while (flashChipLen > 0)
    {
        fiFlashWriteBit8(
                          hpRoot,
                          flashOffset,
                          0xFF
                        );

        flashOffset  += sizeof(os_bit8);
        flashChipLen -= sizeof(os_bit8);
    }
#else /* OSLayer_Stub was not defined */
    os_bit8  Toggle_1;
    os_bit8  Toggle_2;

    /* Kick-off Embedded Program Sector Erase */

    osCardRomWriteBit8(
                        hpRoot,
                        Am29F010_Chip_Erase_Cmd1_OFFSET,
                        Am29F010_Chip_Erase_Cmd1_DATA
                      );
    osCardRomWriteBit8(
                        hpRoot,
                        Am29F010_Chip_Erase_Cmd2_OFFSET,
                        Am29F010_Chip_Erase_Cmd2_DATA
                      );
    osCardRomWriteBit8(
                        hpRoot,
                        Am29F010_Chip_Erase_Cmd3_OFFSET,
                        Am29F010_Chip_Erase_Cmd3_DATA
                      );
    osCardRomWriteBit8(
                        hpRoot,
                        Am29F010_Chip_Erase_Cmd4_OFFSET,
                        Am29F010_Chip_Erase_Cmd4_DATA
                      );
    osCardRomWriteBit8(
                        hpRoot,
                        Am29F010_Chip_Erase_Cmd5_OFFSET,
                        Am29F010_Chip_Erase_Cmd5_DATA
                      );
    osCardRomWriteBit8(
                        hpRoot,
                        Am29F010_Chip_Erase_Cmd6_OFFSET,
                        Am29F010_Chip_Erase_Cmd6_DATA
                      );

    /* Use Toggle Bit Algorithm to know when Chip Erase is done */

    Toggle_1 = osCardRomReadBit8(
                                  hpRoot,
                                  Am29F010_Chip_Erase_Cmd6_OFFSET
                                );

    while(1)
    {
        Toggle_2 = osCardRomReadBit8(
                                      hpRoot,
                                      Am29F010_Chip_Erase_Cmd6_OFFSET
                                    );

        if ((Toggle_1 & Am29F010_Toggle_Bit_MASK) == (Toggle_2 & Am29F010_Toggle_Bit_MASK))
        {
            /* Successfully Programmed */

            return;
        }

        if ((Toggle_2 & Am29F010_Exceeded_Timing_Limits_MASK) == Am29F010_Exceeded_Timing_Limits_MASK)
        {
            Toggle_1 = osCardRomReadBit8(
                                          hpRoot,
                                          Am29F010_Chip_Erase_Cmd6_OFFSET
                                        );
            Toggle_2 = osCardRomReadBit8(
                                          hpRoot,
                                          Am29F010_Chip_Erase_Cmd6_OFFSET
                                        );

            if ((Toggle_1 & Am29F010_Toggle_Bit_MASK) == (Toggle_2 & Am29F010_Toggle_Bit_MASK))
            {
                /* Successfully Programmed */

                return;
            }

            /* Programming Failed - Reset Chip */

            osCardRomWriteBit8(
                                hpRoot,
                                Am29F010_Reset_Cmd1_OFFSET,
                                Am29F010_Reset_Cmd1_DATA
                              );

            return;
        }

        Toggle_1 = Toggle_2;
    }
#endif /* OSLayer_Stub was not defined */
}

void fiFlashEraseSector(
                         agRoot_t *hpRoot,
                         os_bit32     EraseSector
                       )
{
#ifdef OSLayer_Stub
    os_bit32 flashOffset    = Am29F010_Sector_Erase_Cmd6_OFFSET_by_Sector_Number(EraseSector);
    os_bit32 flashSectorLen = Am29F010_Sector_SIZE;

    while (flashSectorLen > 0)
    {
        fiFlashWriteBit8(
                          hpRoot,
                          flashOffset,
                          0xFF
                        );

        flashOffset    += sizeof(os_bit8);
        flashSectorLen -= sizeof(os_bit8);
    }
#else /* OSLayer_Stub was not defined */
    os_bit32 flashOffset = Am29F010_Sector_Erase_Cmd6_OFFSET_by_Sector_Number(EraseSector);
    os_bit8  Toggle_1;
    os_bit8  Toggle_2;

    /* Kick-off Embedded Program Sector Erase */

    osCardRomWriteBit8(
                        hpRoot,
                        Am29F010_Sector_Erase_Cmd1_OFFSET,
                        Am29F010_Sector_Erase_Cmd1_DATA
                      );
    osCardRomWriteBit8(
                        hpRoot,
                        Am29F010_Sector_Erase_Cmd2_OFFSET,
                        Am29F010_Sector_Erase_Cmd2_DATA
                      );
    osCardRomWriteBit8(
                        hpRoot,
                        Am29F010_Sector_Erase_Cmd3_OFFSET,
                        Am29F010_Sector_Erase_Cmd3_DATA
                      );
    osCardRomWriteBit8(
                        hpRoot,
                        Am29F010_Sector_Erase_Cmd4_OFFSET,
                        Am29F010_Sector_Erase_Cmd4_DATA
                      );
    osCardRomWriteBit8(
                        hpRoot,
                        Am29F010_Sector_Erase_Cmd5_OFFSET,
                        Am29F010_Sector_Erase_Cmd5_DATA
                      );
    osCardRomWriteBit8(
                        hpRoot,
                        flashOffset,
                        Am29F010_Sector_Erase_Cmd6_DATA
                      );

    /* Use Toggle Bit Algorithm to know when Sector Erase is done */

    Toggle_1 = osCardRomReadBit8(
                                  hpRoot,
                                  flashOffset
                                );

    while(1)
    {
        Toggle_2 = osCardRomReadBit8(
                                      hpRoot,
                                      flashOffset
                                    );

        if ((Toggle_1 & Am29F010_Toggle_Bit_MASK) == (Toggle_2 & Am29F010_Toggle_Bit_MASK))
        {
            /* Successfully Programmed */

            return;
        }

        if ((Toggle_2 & Am29F010_Exceeded_Timing_Limits_MASK) == Am29F010_Exceeded_Timing_Limits_MASK)
        {
            Toggle_1 = osCardRomReadBit8(
                                          hpRoot,
                                          flashOffset
                                        );
            Toggle_2 = osCardRomReadBit8(
                                          hpRoot,
                                          flashOffset
                                        );

            if ((Toggle_1 & Am29F010_Toggle_Bit_MASK) == (Toggle_2 & Am29F010_Toggle_Bit_MASK))
            {
                /* Successfully Programmed */

                return;
            }

            /* Programming Failed - Reset Chip */

            osCardRomWriteBit8(
                                hpRoot,
                                Am29F010_Reset_Cmd1_OFFSET,
                                Am29F010_Reset_Cmd1_DATA
                              );

            return;
        }

        Toggle_1 = Toggle_2;
    }
#endif /* OSLayer_Stub was not defined */
}

os_bit8 fiFlashReadBit8(
                      agRoot_t *hpRoot,
                      os_bit32     flashOffset
                    )
{
    return osCardRomReadBit8(
                              hpRoot,
                              flashOffset
                            );
}

os_bit16 fiFlashReadBit16(
                        agRoot_t *hpRoot,
                        os_bit32     flashOffset
                      )
{
    fiFlashBit16ToBit8s_t fiFlashBit16ToBit8s;

    fiFlashBit16ToBit8s.bit_8s_form[0] = fiFlashReadBit8(
                                                         hpRoot,
                                                         flashOffset
                                                       );
    fiFlashBit16ToBit8s.bit_8s_form[1] = fiFlashReadBit8(
                                                         hpRoot,
                                                         flashOffset + 1
                                                       );

    return fiFlashBit16ToBit8s.bit_16_form;
}

os_bit32 fiFlashReadBit32(
                        agRoot_t *hpRoot,
                        os_bit32     flashOffset
                      )
{
    fiFlashBit32ToBit8s_t fiFlashBit32ToBit8s;

    fiFlashBit32ToBit8s.bit_8s_form[0] = fiFlashReadBit8(
                                                         hpRoot,
                                                         flashOffset
                                                       );
    fiFlashBit32ToBit8s.bit_8s_form[1] = fiFlashReadBit8(
                                                         hpRoot,
                                                         flashOffset + 1
                                                       );
    fiFlashBit32ToBit8s.bit_8s_form[2] = fiFlashReadBit8(
                                                         hpRoot,
                                                         flashOffset + 2
                                                       );
    fiFlashBit32ToBit8s.bit_8s_form[3] = fiFlashReadBit8(
                                                         hpRoot,
                                                         flashOffset + 3
                                                       );

    return fiFlashBit32ToBit8s.bit_32_form;
}

void fiFlashReadBlock(
                       agRoot_t *hpRoot,
                       os_bit32     flashOffset,
                       void     *flashBuffer,
                       os_bit32     flashBufLen
                     )
{
    while (flashBufLen > 0)
    {
        *((os_bit8 *)flashBuffer) = fiFlashReadBit8(
                                                  hpRoot,
                                                  flashOffset
                                                );

        flashOffset += sizeof(os_bit8);
        flashBuffer  = (void *)((os_bit8 *)flashBuffer + 1);
        flashBufLen -= sizeof(os_bit8);
    }
}

void fiFlashWriteBit8(
                       agRoot_t *hpRoot,
                       os_bit32     flashOffset,
                       os_bit8      flashValue
                     )
{
#ifdef OSLayer_Stub
    osCardRomWriteBit8(
                        hpRoot,
                        flashOffset,
                        flashValue
                      );
#else /* OSLayer_Stub was not defined */
    os_bit8 Toggle_1;
    os_bit8 Toggle_2;

    /* Kick-off Embedded Program Write */

    osCardRomWriteBit8(
                        hpRoot,
                        Am29F010_Program_Cmd1_OFFSET,
                        Am29F010_Program_Cmd1_DATA
                      );
    osCardRomWriteBit8(
                        hpRoot,
                        Am29F010_Program_Cmd2_OFFSET,
                        Am29F010_Program_Cmd2_DATA
                      );
    osCardRomWriteBit8(
                        hpRoot,
                        Am29F010_Program_Cmd3_OFFSET,
                        Am29F010_Program_Cmd3_DATA
                      );
    osCardRomWriteBit8(
                        hpRoot,
                        flashOffset,
                        flashValue
                      );

    /* Use Toggle Bit Algorithm to know when Write is done */

    Toggle_1 = osCardRomReadBit8(
                                  hpRoot,
                                  flashOffset
                                );

    while(1)
    {
        Toggle_2 = osCardRomReadBit8(
                                      hpRoot,
                                      flashOffset
                                    );

        if ((Toggle_1 & Am29F010_Toggle_Bit_MASK) == (Toggle_2 & Am29F010_Toggle_Bit_MASK))
        {
            /* Successfully Programmed */

            return;
        }

        if ((Toggle_2 & Am29F010_Exceeded_Timing_Limits_MASK) == Am29F010_Exceeded_Timing_Limits_MASK)
        {
            Toggle_1 = osCardRomReadBit8(
                                          hpRoot,
                                          flashOffset
                                        );
            Toggle_2 = osCardRomReadBit8(
                                          hpRoot,
                                          flashOffset
                                        );

            if ((Toggle_1 & Am29F010_Toggle_Bit_MASK) == (Toggle_2 & Am29F010_Toggle_Bit_MASK))
            {
                /* Successfully Programmed */

                return;
            }

            /* Programming Failed - Reset Chip */

            osCardRomWriteBit8(
                                hpRoot,
                                Am29F010_Reset_Cmd1_OFFSET,
                                Am29F010_Reset_Cmd1_DATA
                              );

            return;
        }

        Toggle_1 = Toggle_2;
    }
#endif /* OSLayer_Stub was not defined */
}

void fiFlashWriteBit16(
                        agRoot_t *hpRoot,
                        os_bit32     flashOffset,
                        os_bit16     flashValue
                      )
{
    fiFlashBit16ToBit8s_t fiFlashBit16ToBit8s;

    fiFlashBit16ToBit8s.bit_16_form = flashValue;

    fiFlashWriteBit8(
                      hpRoot,
                      flashOffset,
                      fiFlashBit16ToBit8s.bit_8s_form[0]
                    );
    fiFlashWriteBit8(
                      hpRoot,
                      flashOffset + 1,
                      fiFlashBit16ToBit8s.bit_8s_form[1]
                    );
}

void fiFlashWriteBit32(
                        agRoot_t *hpRoot,
                        os_bit32     flashOffset,
                        os_bit32     flashValue
                      )
{
    fiFlashBit32ToBit8s_t fiFlashBit32ToBit8s;

    fiFlashBit32ToBit8s.bit_32_form = flashValue;

    fiFlashWriteBit8(
                      hpRoot,
                      flashOffset,
                      fiFlashBit32ToBit8s.bit_8s_form[0]
                    );
    fiFlashWriteBit8(
                      hpRoot,
                      flashOffset + 1,
                      fiFlashBit32ToBit8s.bit_8s_form[1]
                    );
    fiFlashWriteBit8(
                      hpRoot,
                      flashOffset + 2,
                      fiFlashBit32ToBit8s.bit_8s_form[2]
                    );
    fiFlashWriteBit8(
                      hpRoot,
                      flashOffset + 3,
                      fiFlashBit32ToBit8s.bit_8s_form[3]
                    );
}

void fiFlashWriteBlock(
                        agRoot_t *hpRoot,
                        os_bit32     flashOffset,
                        void     *flashBuffer,
                        os_bit32     flashBufLen
                      )
{
    while (flashBufLen > 0)
    {
        fiFlashWriteBit8(
                          hpRoot,
                          flashOffset,
                          *((os_bit8 *)flashBuffer)
                        );

        flashOffset += sizeof(os_bit8);
        flashBuffer  = (void *)((os_bit8 *)flashBuffer + 1);
        flashBufLen -= sizeof(os_bit8);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\flashsvc.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/FlashSvc.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 10/24/00 6:54p  $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures used by ../C/FlashSvc.C

--*/

#ifndef __FlashSvc_H__
#define __FlashSvc_H__

#define FlashChip Am29F010

/* Sector Layout */

#define Am29F010_Num_Sectors                                              8

#define Am29F010_Sector_MASK                                     0x0001C000
#define Am29F010_Sector_SHIFT                                          0x0E
#define Am29F010_Sector_SIZE                                     0x00004000
#define Am29F010_Sector_Offset_MASK                              0x00003FFF

#define Am29F010_SIZE                                            (Am29F010_Num_Sectors * Am29F010_Sector_SIZE)

/* Reset */

#define Am29F010_Reset_Cmd1_OFFSET                               0x00000000
#define Am29F010_Reset_Cmd1_DATA                                       0xF0

/* Autoselect */

#define Am29F010_Autoselect_Cmd1_OFFSET                          0x00005555
#define Am29F010_Autoselect_Cmd1_DATA                                  0xAA

#define Am29F010_Autoselect_Cmd2_OFFSET                          0x00002AAA
#define Am29F010_Autoselect_Cmd2_DATA                                  0x55

#define Am29F010_Autoselect_Cmd3_OFFSET                          0x00005555
#define Am29F010_Autoselect_Cmd3_DATA                                  0x90

#define Am29F010_Autoselect_ManufacturerID_OFFSET                0x00000000
#define Am29F010_Autoselect_ManafacturerID_DATA                        0x01

#define Am29F010_Autoselect_DeviceID_OFFSET                      0x00000001
#define Am29F010_Autoselect_DeviceID_DATA                              0x20

#define Am29F010_Autoselect_SectorProtectVerify_OFFSET_by_Sector_Number(SectorNumber) \
            (((SectorNumber) << Am29F010_Sector_SHIFT) | 0x00000002)

#define Am29F010_Autoselect_SectorProtectVerify_OFFSET_by_Sector_Base(SectorBase) \
            (((SectorBase) & Am29F010_Sector_MASK) | 0x00000002)

#define Am29F010_Autoselect_SectorProtectVerify_DATA_Unprotected       0x00
#define Am29F010_Autoselect_SectorProtectVerify_DATA_Protected         0x01

/* Program */

#define Am29F010_Program_Cmd1_OFFSET                             0x00005555
#define Am29F010_Program_Cmd1_DATA                                     0xAA

#define Am29F010_Program_Cmd2_OFFSET                             0x00002AAA
#define Am29F010_Program_Cmd2_DATA                                     0x55

#define Am29F010_Program_Cmd3_OFFSET                             0x00005555
#define Am29F010_Program_Cmd3_DATA                                     0xA0

/* Erased-to Value */

#define Am29F010_Erased_Bit8                                           0xFF
#define Am29F010_Erased_Bit16                                        0xFFFF
#define Am29F010_Erased_Bit32                                    0xFFFFFFFF

/* Chip Erase */

#define Am29F010_Chip_Erase_Cmd1_OFFSET                          0x00005555
#define Am29F010_Chip_Erase_Cmd1_DATA                                  0xAA

#define Am29F010_Chip_Erase_Cmd2_OFFSET                          0x00002AAA
#define Am29F010_Chip_Erase_Cmd2_DATA                                  0x55

#define Am29F010_Chip_Erase_Cmd3_OFFSET                          0x00005555
#define Am29F010_Chip_Erase_Cmd3_DATA                                  0x80

#define Am29F010_Chip_Erase_Cmd4_OFFSET                          0x00005555
#define Am29F010_Chip_Erase_Cmd4_DATA                                  0xAA

#define Am29F010_Chip_Erase_Cmd5_OFFSET                          0x00002AAA
#define Am29F010_Chip_Erase_Cmd5_DATA                                  0x55

#define Am29F010_Chip_Erase_Cmd6_OFFSET                          0x00005555
#define Am29F010_Chip_Erase_Cmd6_DATA                                  0x10

/* Sector Erase */

#define Am29F010_Sector_Erase_Cmd1_OFFSET                        0x00005555
#define Am29F010_Sector_Erase_Cmd1_DATA                                0xAA

#define Am29F010_Sector_Erase_Cmd2_OFFSET                        0x00002AAA
#define Am29F010_Sector_Erase_Cmd2_DATA                                0x55

#define Am29F010_Sector_Erase_Cmd3_OFFSET                        0x00005555
#define Am29F010_Sector_Erase_Cmd3_DATA                                0x80

#define Am29F010_Sector_Erase_Cmd4_OFFSET                        0x00005555
#define Am29F010_Sector_Erase_Cmd4_DATA                                0xAA

#define Am29F010_Sector_Erase_Cmd5_OFFSET                        0x00002AAA
#define Am29F010_Sector_Erase_Cmd5_DATA                                0x55

#define Am29F010_Sector_Erase_Cmd6_OFFSET_by_Sector_Number(SectorNumber) \
            ((SectorNumber) << Am29F010_Sector_SHIFT)

#define Am29F010_Sector_Erase_Cmd6_OFFSET_by_Sector_Base(SectorBase) \
            ((SectorBase) & Am29F010_Sector_MASK)

#define Am29F010_Sector_Erase_Cmd6_DATA                                0x30

/* Write Operation Status */

#define Am29F010_Polling_Bit_MASK                                      0x80
#define Am29F010_Toggle_Bit_MASK                                       0x40
#define Am29F010_Exceeded_Timing_Limits_MASK                           0x20
#define Am29F010_Sector_Erase_Timer_MASK                               0x08

/* Byte Order Preservation Typedefs */

typedef union fiFlashBit16ToBit8s_u
              fiFlashBit16ToBit8s_t;

union fiFlashBit16ToBit8s_u {
                              os_bit16 bit_16_form;
                              os_bit8  bit_8s_form[sizeof(os_bit16)];
                            };

typedef union fiFlashBit32ToBit8s_u
              fiFlashBit32ToBit8s_t;

union fiFlashBit32ToBit8s_u {
                              os_bit32 bit_32_form;
                              os_bit8  bit_8s_form[sizeof(os_bit32)];
                            };

/* Flash Image Layout */

typedef struct fiFlashSector_Bit8_Form_s
               fiFlashSector_Bit8_Form_t;

struct fiFlashSector_Bit8_Form_s {
                                   os_bit8 Bit8[Am29F010_Sector_SIZE/sizeof(os_bit8)];
                                 };

typedef struct fiFlashSector_Bit16_Form_s
               fiFlashSector_Bit16_Form_t;

struct fiFlashSector_Bit16_Form_s {
                                    os_bit16 Bit16[Am29F010_Sector_SIZE/sizeof(os_bit16)];
                                  };

typedef struct fiFlashSector_Bit32_Form_s
               fiFlashSector_Bit32_Form_t;

struct fiFlashSector_Bit32_Form_s {
                                    os_bit32 Bit32[Am29F010_Sector_SIZE/sizeof(os_bit32)];
                                  };

/* fiFlash_Card_Assembly_Info_t is simply a buffer reserved to
     hold manufacturing info                                   */

typedef os_bit8 fiFlash_Card_Assembly_Info_t [32];

/* fiFlash_Card_Domain/Area/Loop_Address are each one byte fields
     used to specify a Hard Address (or, rather, a Default Address) */

#define fiFlash_Card_Unassigned_Domain_Address 0xFF
#define fiFlash_Card_Unassigned_Area_Address   0xFF
#define fiFlash_Card_Unassigned_Loop_Address   0xFF

/* fiFlash_Sector_Sentinel_Byte is just a single byte used to know that
     the Flash has been programmed.  Eventually, this should be replaced
     or augmented by a checksum (using the 3 neighboring filler bytes).  */

#define fiFlash_Sector_Sentinel_Byte 0xED

/* fiFlash_Card_WWN_t is of the form: 0x50 0x06 0x0B 0xQR 0xST 0xUV 0xWX 0xYZ
     where Q,R,S,T,U,V,W,X,Y, & Z are hex digits (0-F)                        */

typedef os_bit8 fiFlash_Card_WWN_t [8];


#define fiFlash_Card_WWN_0_HP              0x50
#define fiFlash_Card_WWN_1_HP              0x06
#define fiFlash_Card_WWN_2_HP              0x0B
#define fiFlash_Card_WWN_3_HP              0x0

#define fiFlash_Card_WWN_0_Agilent         0x50
#define fiFlash_Card_WWN_1_Agilent         0x03
#define fiFlash_Card_WWN_2_Agilent         0x0D
#define fiFlash_Card_WWN_3_Agilent         0x30

#define fiFlash_Card_WWN_0_Adaptec         0x50
#define fiFlash_Card_WWN_1_Adaptec         0x03
#define fiFlash_Card_WWN_2_Adaptec         0x0D
#define fiFlash_Card_WWN_3_Adaptec         0x30

#ifdef _ADAPTEC_HBA
#define fiFlash_Card_WWN_0 fiFlash_Card_WWN_0_Adaptec
#define fiFlash_Card_WWN_1 fiFlash_Card_WWN_1_Adaptec
#define fiFlash_Card_WWN_2 fiFlash_Card_WWN_2_Adaptec
#define fiFlash_Card_WWN_3 fiFlash_Card_WWN_3_Adaptec
#endif /* _ADAPTEC_HBA */

#ifdef _AGILENT_HBA
#define fiFlash_Card_WWN_0 fiFlash_Card_WWN_0_Agilent
#define fiFlash_Card_WWN_1 fiFlash_Card_WWN_1_Agilent
#define fiFlash_Card_WWN_2 fiFlash_Card_WWN_2_Agilent
#define fiFlash_Card_WWN_3 fiFlash_Card_WWN_3_Agilent
#endif /* _AGILENT_HBA */

#ifdef _GENERIC_HBA
#define fiFlash_Card_WWN_0 fiFlash_Card_WWN_0_HP
#define fiFlash_Card_WWN_1 fiFlash_Card_WWN_1_HP
#define fiFlash_Card_WWN_2 fiFlash_Card_WWN_2_HP
#define fiFlash_Card_WWN_3 fiFlash_Card_WWN_3_HP

#endif /* _GENERIC_HBA */


#define fiFlash_Card_WWN_0_DEFAULT(agRoot) fiFlash_Card_WWN_0
#define fiFlash_Card_WWN_1_DEFAULT(agRoot) fiFlash_Card_WWN_1
#define fiFlash_Card_WWN_2_DEFAULT(agRoot) fiFlash_Card_WWN_2
#define fiFlash_Card_WWN_3_DEFAULT(agRoot) fiFlash_Card_WWN_3

#define fiFlash_Card_WWN_4_DEFAULT(agRoot) ((os_bit8)((((os_bitptr)(agRoot)) & 0xFF000000) >> 0x18))
#define fiFlash_Card_WWN_5_DEFAULT(agRoot) ((os_bit8)((((os_bitptr)(agRoot)) & 0x00FF0000) >> 0x10))
#define fiFlash_Card_WWN_6_DEFAULT(agRoot) ((os_bit8)((((os_bitptr)(agRoot)) & 0x0000FF00) >> 0x08))
#define fiFlash_Card_WWN_7_DEFAULT(agRoot) ((os_bit8)((((os_bitptr)(agRoot)) & 0x000000FF) >> 0x00))

/* fiFlash_Card_SVID_t is of the form: 0xGHIJ103C (LittleEndian)
     where I,J,G, & H are hex digits (0-F) and make up the SubSystemID
     whereas the 0x103C serves as the SubsystemVendorID                */

typedef os_bit32 fiFlash_Card_SVID_t;

#define fiFlashSector_Last_Form_Fill_Bytes (   Am29F010_Sector_SIZE                 \
                                             - sizeof(fiFlash_Card_Assembly_Info_t) \
                                             - sizeof(os_bit8)                         \
                                             - sizeof(os_bit8)                         \
                                             - sizeof(os_bit8)                         \
                                             - sizeof(os_bit8)                         \
                                             - sizeof(fiFlash_Card_WWN_t)           \
                                             - sizeof(fiFlash_Card_SVID_t)          )

typedef struct fiFlashSector_Last_Form_s
               fiFlashSector_Last_Form_t;

struct fiFlashSector_Last_Form_s {
                                   os_bit8                      Bit8[fiFlashSector_Last_Form_Fill_Bytes];
                                   fiFlash_Card_Assembly_Info_t Assembly_Info;
                                   os_bit8                      Hard_Domain_Address;
                                   os_bit8                      Hard_Area_Address;
                                   os_bit8                      Hard_Loop_Address;
                                   os_bit8                      Sentinel;
                                   fiFlash_Card_WWN_t           Card_WWN;
                                   fiFlash_Card_SVID_t          Card_SVID;
                                 };

#define fiFlashSector_Last (Am29F010_Num_Sectors - 1)

typedef union fiFlashSector_u
              fiFlashSector_t;

union fiFlashSector_u {
                        fiFlashSector_Bit8_Form_t  Bit8_Form;
                        fiFlashSector_Bit16_Form_t Bit16_Form;
                        fiFlashSector_Bit32_Form_t Bit32_Form;
                        fiFlashSector_Last_Form_t  Last_Form;
                      };

#ifndef __FlashSvc_H__64KB_Struct_Size_Limited__
#ifdef OSLayer_BIOS
#define __FlashSvc_H__64KB_Struct_Size_Limited__
#endif /* OSLayer_BIOS was defined */
#ifdef OSLayer_I2O
#define __FlashSvc_H__64KB_Struct_Size_Limited__
#endif /* OSLayer_I2O was defined */
#endif /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */

#ifndef __FlashSvc_H__64KB_Struct_Size_Limited__
typedef struct fiFlashStructure_s
               fiFlashStructure_t;

struct fiFlashStructure_s {
                            fiFlashSector_t Sector[Am29F010_Num_Sectors];
                          };
#endif /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */

/* Function Prototypes */

osGLOBAL os_bit32 fiFlashSvcASSERTs(
                                     void
                                   );

osGLOBAL agBOOLEAN fiFlashSvcInitialize(
                                    agRoot_t *agRoot
                                  );

osGLOBAL void fiFlashDumpLastSector(
                                     agRoot_t *agRoot
                                   );

osGLOBAL void fiFlashInitializeChip(
                                     agRoot_t *agRoot
                                   );

osGLOBAL void fiFlashFill_Assembly_Info( fiFlashSector_Last_Form_t    *Last_Sector,
                                         fiFlash_Card_Assembly_Info_t *Assembly_Info
                                       );

osGLOBAL void fiFlashFill_Hard_Address( fiFlashSector_Last_Form_t *Last_Sector,
                                        os_bit8                    Hard_Domain_Address,
                                        os_bit8                    Hard_Area_Address,
                                        os_bit8                    Hard_Loop_Address
                                      );

osGLOBAL void fiFlashFill_Card_WWN( fiFlashSector_Last_Form_t *Last_Sector,
                                    fiFlash_Card_WWN_t        *Card_WWN
                                  );

osGLOBAL void fiFlashFill_Card_SVID( fiFlashSector_Last_Form_t *Last_Sector,
                                     fiFlash_Card_SVID_t        Card_SVID
                                   );

osGLOBAL void fiFlashGet_Last_Sector(
                                      agRoot_t                  *agRoot,
                                      fiFlashSector_Last_Form_t *Last_Sector
                                    );

osGLOBAL void fiFlashGet_Assembly_Info(
                                        agRoot_t                     *agRoot,
                                        fiFlash_Card_Assembly_Info_t *Assembly_Info
                                      );

osGLOBAL void fiFlashGet_Hard_Address(
                                       agRoot_t *agRoot,
                                       os_bit8  *Hard_Domain_Address,
                                       os_bit8  *Hard_Area_Address,
                                       os_bit8  *Hard_Loop_Address
                                     );

osGLOBAL void fiFlashGet_Card_WWN(
                                   agRoot_t           *agRoot,
                                   fiFlash_Card_WWN_t *Card_WWN
                                 );

osGLOBAL void fiFlashGet_Card_SVID(
                                    agRoot_t            *agRoot,
                                    fiFlash_Card_SVID_t *Card_SVID
                                  );

osGLOBAL void fiFlashSet_Assembly_Info(
                                        agRoot_t                     *agRoot,
                                        fiFlash_Card_Assembly_Info_t *Assembly_Info
                                      );

osGLOBAL void fiFlashSet_Hard_Address(
                                       agRoot_t *agRoot,
                                       os_bit8   Hard_Domain_Address,
                                       os_bit8   Hard_Area_Address,
                                       os_bit8   Hard_Loop_Address
                                     );

osGLOBAL void fiFlashSet_Card_WWN(
                                   agRoot_t           *agRoot,
                                   fiFlash_Card_WWN_t *Card_WWN
                                 );

osGLOBAL void fiFlashSet_Card_SVID(
                                    agRoot_t            *agRoot,
                                    fiFlash_Card_SVID_t  Card_SVID
                                  );

osGLOBAL void fiFlashUpdate_Last_Sector(
                                         agRoot_t                  *agRoot,
                                         fiFlashSector_Last_Form_t *Last_Sector
                                       );

osGLOBAL void fiFlashEraseChip(
                                agRoot_t *agRoot
                              );

osGLOBAL void fiFlashEraseSector(
                                  agRoot_t *agRoot,
                                  os_bit32  EraseSector
                                );

osGLOBAL os_bit8 fiFlashReadBit8(
                                  agRoot_t *agRoot,
                                  os_bit32  flashOffset
                                );

osGLOBAL os_bit16 fiFlashReadBit16(
                                    agRoot_t *agRoot,
                                    os_bit32  flashOffset
                                  );

osGLOBAL os_bit32 fiFlashReadBit32(
                                    agRoot_t *agRoot,
                                    os_bit32  flashOffset
                                  );

osGLOBAL void fiFlashReadBlock(
                                agRoot_t *agRoot,
                                os_bit32  flashOffset,
                                void     *flashBuffer,
                                os_bit32  flashBufLen
                              );

osGLOBAL void fiFlashWriteBit8(
                                agRoot_t *agRoot,
                                os_bit32  flashOffset,
                                os_bit8   flashValue
                              );

osGLOBAL void fiFlashWriteBit16(
                                 agRoot_t *agRoot,
                                 os_bit32  flashOffset,
                                 os_bit16  flashValue
                               );

osGLOBAL void fiFlashWriteBit32(
                                 agRoot_t *agRoot,
                                 os_bit32  flashOffset,
                                 os_bit32  flashValue
                               );

osGLOBAL void fiFlashWriteBlock(
                                 agRoot_t *agRoot,
                                 os_bit32  flashOffset,
                                 void     *flashBuffer,
                                 os_bit32  flashBufLen
                               );

#endif /* __FlashSvc_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\fcmain.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/FCMain.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 10/30/00 6:39p  $ (Last Modified)

Purpose:

  This file implements the main entry points for the FC Layer.

--*/
#ifndef _New_Header_file_Layout_
#include "../h/globals.h"
#include "../h/state.h"
#include "../h/memmap.h"
#include "../h/tlstruct.h"
#include "../h/fcmain.h"
#include "../h/queue.h"
#include "../h/timersvc.h"
#include "../h/flashsvc.h"
#ifdef _DvrArch_1_30_
#include "../h/ipstate.h"
#include "../h/pktstate.h"
#endif /* _DvrArch_1_30_ was defined */
#include "../h/devstate.h"
#include "../h/cdbstate.h"
#include "../h/sfstate.h"
#include "../h/cstate.h"
#include "../h/cfunc.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"
#include "memmap.h"
#include "tlstruct.h"
#include "fcmain.h"
#include "queue.h"
#include "timersvc.h"
#include "flashsvc.h"
#ifdef _DvrArch_1_30_
#include "ipstate.h"
#include "pktstate.h"
#endif /* _DvrArch_1_30_ was defined */
#include "devstate.h"
#include "cdbstate.h"
#include "sfstate.h"
#include "cstate.h"
#include "cfunc.h"
#endif  /* _New_Header_file_Layout_ */

#ifndef __State_Force_Static_State_Tables__
actionUpdate_t noActionUpdate = { 0,0,agNULL,agNULL };
#endif /* __State_Force_Static_State_Tables__ was not defined */

os_bit8 Alpa_Index[256] =
    {
       0x00, 0x01, 0x02, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, /* ALPA 00 01 02 04       */
       0x04, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x05, /* ALPA 08 0F             */

       0x06, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, /* ALPA 10 17             */
       0x08, 0xFF, 0xFF, 0x09, 0xFF, 0x0A, 0x0B, 0x0C, /* ALPA 18 1B 1D 1E 1F    */

       0xFF, 0xFF, 0xFF, 0x0D, 0xFF, 0x0E, 0x0F, 0x10, /* ALPA 23 25 26 27       */
       0xFF, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0xFF, /* ALPA 29 2A 2B 2C 2D 2E */

       0xFF, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0xFF, /* ALPA 31 32 33 34 35 36 */
       0xFF, 0x1D, 0x1E, 0xFF, 0x1F, 0xFF, 0xFF, 0xFF, /* ALPA 39 3A 3C          */

       0xFF, 0xFF, 0xFF, 0x20, 0xFF, 0x21, 0x22, 0x23, /* ALPA 43 45 46 47       */
       0xFF, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0xFF, /* ALPA 49 4A 4B 4C 4D 4E */

       0xFF, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0xFF, /* ALPA 51 52 53 54 55 56 */
       0xFF, 0x30, 0x31, 0xFF, 0x32, 0xFF, 0xFF, 0xFF, /* ALPA 59 5A 5C          */

       0xFF, 0xFF, 0xFF, 0x33, 0xFF, 0x34, 0x35, 0x36, /* ALPA 63 65 66 67       */
       0xFF, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0xFF, /* ALPA 69 6A 6B 6C 6D 6E */

       0xFF, 0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x42, 0xFF, /* ALPA 71 72 73 74 75 76 */
       0xFF, 0x43, 0x44, 0xFF, 0x45, 0xFF, 0xFF, 0xFF, /* ALPA 79 7A 7C          */

       0x46, 0x47, 0x48, 0xFF, 0x49, 0xFF, 0xFF, 0xFF, /* ALPA 80 81 82 84       */
       0x4A, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x4B, /* ALPA 88 8F             */

       0x4C, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x4D, /* ALPA 90 97             */
       0x4E, 0xFF, 0xFF, 0x4F, 0xFF, 0x50, 0x51, 0x52, /* ALPA 98 9B 9D 9E 9F    */

       0xFF, 0xFF, 0xFF, 0x53, 0xFF, 0x54, 0x55, 0x56, /* ALPA A3 A5 A6 A7       */
       0xFF, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0xFF, /* ALPA A9 AA AB AC AD AE */

       0xFF, 0x5D, 0x5E, 0x5F, 0x60, 0x61, 0x62, 0xFF, /* ALPA B1 B2 B3 B4 B5 B6 */
       0xFF, 0x63, 0x64, 0xFF, 0x65, 0xFF, 0xFF, 0xFF, /* ALPA B9 BA BC          */

       0xFF, 0xFF, 0xFF, 0x66, 0xFF, 0x67, 0x68, 0x69, /* ALPA C3 C5 C6 C7       */
       0xFF, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0xFF, /* ALPA C9 CA CB CC CD CE */

       0xFF, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0xFF, /* ALPA D1 D2 D3 D4 D5 D6 */
       0xFF, 0x76, 0x77, 0xFF, 0x78, 0xFF, 0xFF, 0xFF, /* ALPA D9 DA DC          */

       0x79, 0x7A, 0x7B, 0xFF, 0x7C, 0xFF, 0xFF, 0xFF, /* ALPA E0 E1 E2 E4       */
       0x7D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7E, /* ALPA E8 EF             */

       0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
       0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF  
    };

/*+
   Function: fcAbortIO 

    Purpose: Abort given request
  Called By: OSLayer
      Calls: CDBEvent_PrepareforAbort
             CDBEventAlloc_Abort
             osIOCompleted
-*/
void fcAbortIO(
                agRoot_t      *hpRoot,
                agIORequest_t *hpIORequest
              )
{
    CThread_t   * pCThread   = CThread_ptr(hpRoot);
    CDBThread_t * pCDBThread = (CDBThread_t * )(hpIORequest->fcData);

    fiSingleThreadedEnter( hpRoot, fdAbortIO );

    if(pCDBThread != agNULL)
    {
        pCDBThread->CompletionStatus =  osIOAborted;

		/*  hpRoot was removed from this message. IWN */
         fiLogDebugString(hpRoot,
                     FCMainLogConsoleLevel,
                        "fcAbortIO hpIORequest %p CDBThread %p State %d",
                        (char *)agNULL,(char *)agNULL,
                        hpIORequest,pCDBThread,
                        pCDBThread->thread_hdr.currentState,
                        0,0,0,0,0,0,0);


        if( pCDBThread->thread_hdr.currentState != CDBStateThreadFree &&
            pCDBThread->thread_hdr.currentState != CDBStateConfused      )
        {
            fiSendEvent(&(pCDBThread->thread_hdr),CDBEvent_PrepareforAbort);
            if(! fiListElementOnList(  &(pCDBThread->CDBLink), &(pCThread->Free_CDBLink)))
            {
                fiSendEvent(&(pCDBThread->thread_hdr),CDBEventAlloc_Abort);
            }
        }
        else
        {
            if( pCDBThread->thread_hdr.currentState == CDBStateConfused )
            {
                pCDBThread->CompletionStatus =  osIOAbortFailed;
				/*  hpRoot was removed from this message. IWN */
                fiLogDebugString(hpRoot,
                        FCMainLogConsoleLevel,
                        "fcAbortIO hpIORequest %p CDBThread %p State %d Request CDBStateConfused !",
                        (char *)agNULL,(char *)agNULL,
                        hpIORequest,pCDBThread,
                        pCDBThread->thread_hdr.currentState,
                        0,0,0,0,0,0,0);
                osIOCompleted( hpRoot,
                               pCDBThread->hpIORequest,
                               pCDBThread->CompletionStatus,
                               0);


            }
        }

    }
    else
    {
		/*  hpRoot was removed from this message. IWN */
        fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "fcAbortIO hpIORequest %p CDBThread %p Request BAD !",
                        (char *)agNULL,(char *)agNULL,
                        hpIORequest,pCDBThread,
                        0,0,0,0,0,0,0,0);
    }
    fiSingleThreadedLeave( hpRoot , fdAbortIO );
    return;
}


#ifdef _DvrArch_1_30_

/*+
   Function: fcBindToWorkQs
    Purpose: IP Currently does nothing
  Called By: OSLayer
      Calls: 
-*/
os_bit32 fcBindToWorkQs(
                         agRoot_t  *agRoot,
                         os_bit32   agQPairID,
                         void     **agInboundQBase,
                         os_bit32   agInboundQEntries,
                         os_bit32  *agInboundQProdIndex,
                         os_bit32  *agInboundQConsIndex,
                         void     **agOutboundQBase,
                         os_bit32   agOutboundQEntries,
                         os_bit32  *agOutboundQProdIndex,
                         os_bit32  *agOutboundQConsIndex
                       )
{
    fiLogDebugString( agRoot,
                      FCMainLogConsoleLevel,
                      "fcBindToWorkQs():               agRoot==0x%8P            agQPairID==0x%1X",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agRoot,(void *)agNULL,
                      agQPairID,
                      0,0,0,0,0,0,0);

    fiLogDebugString( agRoot,
                      FCMainLogConsoleLevel,
                      "                        agInboundQBase==0x%8P    agInboundQEntries==0x%8X",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agInboundQBase,(void *)agNULL,
                      agInboundQEntries,
                      0,0,0,0,0,0,0);

    fiLogDebugString(agRoot,
                      FCMainLogConsoleLevel,
                      "                   agInboundQProdIndex==0x%8P  agInboundQConsIndex==0x%8P",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agInboundQProdIndex,
                      (void *)agInboundQConsIndex,
                      0,0,0,0,0,0,0,0 );

    fiLogDebugString( agRoot,
                      FCMainLogConsoleLevel,
                      "                       agOutboundQBase==0x%8P   agOutboundQEntries==0x%8X",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agOutboundQBase,(void *)agNULL,
                      agOutboundQEntries,
                      0,0,0,0,0,0,0 );

    fiLogDebugString( agRoot,
                      FCMainLogConsoleLevel,
                      "                  agOutboundQProdIndex==0x%8P agOutboundQConsIndex==0x%8P",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agOutboundQProdIndex,
                      (void *)agOutboundQConsIndex,
                      0,0,0,0,0,0,0,0 );

    return fcBindQInvalidID;
}
#endif /* _DvrArch_1_30_ was defined */

/*+
   Function: fcCardSupported
    Purpose: Returns True if card is supported by fclayer
  Called By: OSLayer fcInitializeChannel
      Calls: osChipConfigReadBit32
-*/
agBOOLEAN fcCardSupported(
                           agRoot_t *hpRoot
                         )
{
    os_bit32 DEVID_VENDID;
    os_bit32 VENDID;
    os_bit32 DEVID;
    os_bit32 REVID;
    os_bit32 SVID;
    os_bit32 MAJOR_REVID;
    os_bit32 MINOR_REVID;

    os_bit32 SUB_VENDID;
    os_bit32 SUB_DEVID;

    DEVID_VENDID = osChipConfigReadBit32(
                                          hpRoot,
                                          ChipConfig_DEVID_VENDID
                                        );

    VENDID       = DEVID_VENDID & ChipConfig_VENDID_MASK;

    DEVID        = DEVID_VENDID & ChipConfig_DEVID_MASK;

    REVID        = osChipConfigReadBit32(
                                          hpRoot,
                                          ChipConfig_CLSCODE_REVID
                                        )                          & ChipConfig_REVID_Major_Minor_MASK;

    MAJOR_REVID  = (REVID & ChipConfig_REVID_Major_MASK) >> ChipConfig_REVID_Major_MASK_Shift;
    MINOR_REVID  =  REVID & ChipConfig_REVID_Minor_MASK;

    SVID         = osChipConfigReadBit32(
                                          hpRoot,
                                          ChipConfig_SVID
                                        );
    SUB_VENDID       = SVID & ChipConfig_SubsystemVendorID_MASK;

    SUB_DEVID        = SVID & ChipConfig_SubsystemID_MASK;


    fiLogDebugString(
                      hpRoot,
                      FCMainLogConsoleCardSupported,
                      "fcCardSupported(): VENDID==0x%04X DEVID==0x%04X REVID==0x%02X (%x.%x) SVID==0x%08X",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      VENDID,
                      (DEVID >> 16),
                      REVID,
                      MAJOR_REVID,
                      MINOR_REVID,
                      SVID,
                      0,0
                    );


    fiLogString(hpRoot,
                      "%s VENDID==0x%04X DEVID==0x%04X",
                      "fcCardSupported",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      VENDID,
                      (DEVID >> 16),
                      0,0,0,0,0,0);
    fiLogString(hpRoot,
                      "%s REVID==0x%02X (%x.%x) SVID==0x%08X",
                      "fcCardSupported",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      REVID,
                      MAJOR_REVID,
                      MINOR_REVID,
                      SVID,
                      0,0,0,0);

/*
    fiLogDebugString(
                      hpRoot,
                      FCMainLogConsoleCardSupported,
                      "Testing agfmtfill %s %s %p %p",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      0,0,0,0,0,0,0,0
                    );
*/    
#ifndef _ADAPTEC_HBA
#ifndef _AGILENT_HBA
#ifndef _GENERIC_HBA
#error Need  _AGILENT_HBA or _ADAPTEC_HBA defined !
#endif
#endif
#endif

#ifdef _ADAPTEC_HBA

	/* To differentiate Adaptec card's we need to check the Sub system vendor
	 * and sub device ids.
	 */

if (    ((VENDID == ChipConfig_VENDID_Agilent_Technologies) ||
        (VENDID == ChipConfig_VENDID_Hewlett_Packard))  )
    {
        switch (SUB_VENDID)
        {
        case ChipConfig_SubsystemVendorID_Adaptec:
            break;
        case ChipConfig_SubsystemVendorID_Agilent_Technologies:
        case ChipConfig_SubsystemVendorID_Hewlett_Packard:
        default:
            fiLogString( hpRoot,
                          "FAILED fcCardSupported():NOT  ChipConfig_SubsystemVendorID_Adaptec %X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          SUB_VENDID,0,0,0,0,0,0,0 );

            return agFALSE;

        }
    }

#endif /* _ADAPTEC_HBA */ 

#ifdef _AGILENT_HBA
    
if (    ((VENDID == ChipConfig_VENDID_Agilent_Technologies) ||
        (VENDID == ChipConfig_VENDID_Hewlett_Packard))  )
    {
    switch (SUB_VENDID)
        {
        case ChipConfig_SubsystemVendorID_Adaptec:
            fiLogString( hpRoot,
                          "FAILED fcCardSupported(): ChipConfig_SubsystemVendorID_Adaptec %X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0 );

            return agFALSE;
        case ChipConfig_SubsystemVendorID_Agilent_Technologies:
        case ChipConfig_SubsystemVendorID_Hewlett_Packard:
                break;
        default:
            fiLogString( hpRoot,
                          "FAILED fcCardSupported(): ChipConfig_SubsystemVendorID_UNKNOWN %X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          SUB_VENDID,0,0,0,0,0,0,0 );
            return agFALSE;

        }
    
    }
#endif /* _AGILENT_HBA */ 
    

    if (    (DEVID != ChipConfig_DEVID_TachyonTL)
         && (DEVID != ChipConfig_DEVID_TachyonTS)
         && (DEVID != ChipConfig_DEVID_TachyonXL2) )
    {
        fiLogDebugString( hpRoot,
                          FCMainLogErrorLevel,
                          "fcCardSupported():    DEVID != ChipConfig_DEVID_TachyonTL (0x%04X)",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          (ChipConfig_DEVID_TachyonTL >> 16),
                          0,0,0,0,0,0,0 );

        fiLogDebugString( hpRoot,
                          FCMainLogErrorLevel,
                          "                   && DEVID != ChipConfig_DEVID_TachyonTS (0x%04X)",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          (ChipConfig_DEVID_TachyonTS >> 16),
                          0,0,0,0,0,0,0 );

        fiLogDebugString( hpRoot,
                          FCMainLogErrorLevel,
                          "                   && DEVID != ChipConfig_DEVID_TachyonXL2 (0x%04X)",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          (ChipConfig_DEVID_TachyonXL2 >> 16),
                          0,0,0,0,0,0,0 );

        return agFALSE;
    }


    if (    (DEVID == ChipConfig_DEVID_TachyonTL)
         && (REVID <  ChipConfig_REVID_2_2) )
    {
        fiLogDebugString(
                          hpRoot,
                          FCMainLogConsoleCardSupported,
                          "fcCardSupported():    DEVID == ChipConfig_DEVID_TachyonTL (0x%04X)",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                          (ChipConfig_DEVID_TachyonTL >> 16),
                          0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          FCMainLogConsoleCardSupported,
                          "                   && REVID <  ChipConfig_REVID_2_2 (0x%02X)",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                          ChipConfig_REVID_2_2,
                          0,0,0,0,0,0,0
                        );
    }


    return agTRUE;
}


/*+
   Function: fcDelayedInterruptHandler
    Purpose: Process interrupts after interrupts have been masked off by fcInterruptHandler
             Evalulates current status on interrupt delay mechanism
             Re enables interrupts on exit
  Called By: OSLayer 
      Calls: CFuncRead_Interrupts
             on or off card version of Proccess_IMQ
-*/
void fcDelayedInterruptHandler(
                                agRoot_t *hpRoot
                              )
{
    CThread_t *pCThread         = CThread_ptr(hpRoot);
    os_bit32      intStatus;
    os_bit32      IOsActiveAtEntry;

    if(pCThread->DelayedInterruptActive)
    {
        fiLogString(hpRoot,
                          "%s Active twice !",
                          "fcDelayedInterruptHandler",(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0);
    }
    else
    {
        pCThread->DelayedInterruptActive = agTRUE;
    }
    
    fiSingleThreadedEnter( hpRoot , fdDelayedInterruptHandler );

    /*
    ** read interrupt register
    */

    intStatus = CFuncRead_Interrupts(hpRoot);

    if (intStatus & ChipIOUp_INTSTAT_INT)
    {
        IOsActiveAtEntry = pCThread->IOsActive;

        pCThread->IOsStartedSinceISR = 0;

        if (pCThread->InterruptDelaySuspended == agTRUE)
        {
            /* Indicate Interrupt Delay Suspension is over since ISR was called */

            pCThread->InterruptDelaySuspended = agFALSE;

            if (pCThread->InterruptsDelayed == agTRUE)
            {
                /* Restart delaying interrupts (if they should now be delayed) */

                CFuncInteruptDelay(hpRoot, agTRUE);
            }
        }

        pCThread->FuncPtrs.Proccess_IMQ( hpRoot );

        if(pCThread->RSCNreceived )
        {
            if( pCThread->thread_hdr.currentState == CStateRSCNErrorBackIOs  )
            {
                pCThread->RSCNreceived = agFALSE;
                CFuncDoADISC( hpRoot);
                fiSendEvent(&(pCThread->thread_hdr),CEventDeviceListEmpty);
                fiLogString(hpRoot,
                                "%s CState %d",
                                "fcDelayed",(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                pCThread->thread_hdr.currentState,
                                0,0,0,0,0,0,0);

            }
        }

        pCThread->IOsIntCompletedThisTimerTick += (IOsActiveAtEntry - pCThread->IOsActive);
    }
#ifdef ENABLE_INTERRUPTS_IN_IMQ
    else
    {
        CFuncEnable_Interrupts(hpRoot,ChipIOUp_INTEN_INT);
    }
#endif /* ENABLE_INTERRUPTS_IN_IMQ */

    if( ! pCThread->ProcessingIMQ )
    {
        if( pCThread->thread_hdr.currentState != CStateNormal  )
        {
            if( pCThread->thread_hdr.currentState == CStateResetNeeded  )
            {
                fiSendEvent(&(pCThread->thread_hdr),(event_t) pCThread->Loop_Reset_Event_to_Send);
            }
        }
    }

#ifndef ENABLE_INTERRUPTS_IN_IMQ
    /*Always enable interupts */
    CFuncEnable_Interrupts(hpRoot,ChipIOUp_INTEN_INT);
#endif /* ENABLE_INTERRUPTS_IN_IMQ */

    if(! (osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST ) & ChipIOUp_INTEN_INT ))
    {
        if( pCThread->thread_hdr.currentState == CStateLIPEventStorm         ||
            pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm   )
        {
        /* Ok to have ints disabled for these states */
        }
        else
        {

            fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "Leave %s (%p) IMQ Int disabled ! * ! Cstate %d",
                            "fcDelayedInterruptHandler",(char *)agNULL,
                            hpRoot,(void *)agNULL,
                            pCThread->thread_hdr.currentState,
                            0,0,0,0,0,0,0);

            fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "Interrupts %08X sysInts - Active %08X LogicallyEnabled %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST ),
                            CThread_ptr(hpRoot)->sysIntsActive,
                            CThread_ptr(hpRoot)->sysIntsLogicallyEnabled,
                            0,0,0,0,0);
        }

    }

    pCThread->DelayedInterruptActive = agFALSE;

    fiSingleThreadedLeave( hpRoot, fdDelayedInterruptHandler  );

    return;
}


/*+

  Function: fcEnteringOS
   Purpose: This function is called to indicate to the FC Layer that it is 
            being called after the OS has switched back (presumably between NetWare 
            and BIOS) from the "other OS".  The prior switch out of "this OS" was 
            preceded by a call to fcLeavingOS() 
  Called By: <unknown OS Layer functions>
      Calls: CFuncEnable_Interrupts

-*/
void fcEnteringOS(
                   agRoot_t *hpRoot
                 )
{
    CThread_t *CThread = CThread_ptr(hpRoot);

    fiSingleThreadedEnter( hpRoot , fdEnteringOS );


    CThread->sysIntsActive = CThread->sysIntsActive_before_fcLeavingOS_call;

    CFuncEnable_Interrupts(
                            hpRoot,
                            0
                          );

    fiSingleThreadedLeave( hpRoot , fdEnteringOS );


    return;
}

/*+
  Function: fcGetChannelInfo
   Purpose: This function is called to copy agFCChanInfo_t for the agRoot_t HBA channel.
            Oslayer must provide buffer large enough to hold agFCChanInfo_t.
  Called By: <unknown OS Layer functions>
      Calls: None
-*/
os_bit32 fcGetChannelInfo(
                        agRoot_t       *hpRoot,
                        agFCChanInfo_t *hpFCChanInfo
                      )
{
    CThread_t *CThread = CThread_ptr(hpRoot);

    fiSingleThreadedEnter( hpRoot , fdGetChannelInfo );

    fiLogDebugString(hpRoot,
                    FCMainLogConsoleLevel,
                    "fcGetChannelInfo()",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    if (  CThread->thread_hdr.currentState == CStateNormal )
    {
        CThread->ChanInfo.LinkUp = agTRUE;
    }
    else
    {
        CThread->ChanInfo.LinkUp = agFALSE;
    }

    /*Update Chaninfo for SNIA IOCTLS */
    CThread->ChanInfo.PortSupportedSpeed =  (CThread->DEVID == ChipConfig_DEVID_TachyonXL2) ? HBA_PORTSPEED_2GBIT : HBA_PORTSPEED_1GBIT;
    CThread->ChanInfo.PortSpeed = CThread->TwoGigSuccessfull ? HBA_PORTSPEED_2GBIT : HBA_PORTSPEED_1GBIT;
    CThread->ChanInfo.PortState = (  CThread->thread_hdr.currentState == CStateNormal ) ? HBA_PORTSTATE_ONLINE : HBA_PORTSTATE_LINKDOWN;

    if(CThread->InitAsNport)
    {
        CThread->ChanInfo.PortType = HBA_PORTTYPE_NPORT;
    }
    else
    {
        CThread->ChanInfo.PortType = CThread->FlogiSucceeded ?  HBA_PORTTYPE_FLPORT : HBA_PORTTYPE_NLPORT;
    }

    CThread->ChanInfo.PortSupportedClassofService = 0x8;

    /*Not available til phase 2
    CThread->ChanInfo.FabricName;
    CThread->ChanInfo.PortSupportedFc4Types ;
    CThread->ChanInfo.PortActiveFc4Types;
    Not available til phase 2 */

    *hpFCChanInfo = CThread_ptr(hpRoot)->ChanInfo;

    fiSingleThreadedLeave(hpRoot , fdGetChannelInfo );

    return fcChanInfoReturned;
}


/*+
  Function: fcGetDeviceHandles
   Purpose: This function is called to copy maxFCDevs of handle information for the agRoot_t HBA channel.
            Oslayer must provide buffer large enough to hold maxFCDevs of handles.
            Returns zero if no devices found or if FCLayer does not have a valid list of devices.
            Only time possible to get non zero is after Link_up event notification with devices attached.
  Called By: <unknown OS Layer functions>
      Calls: Access's data structures only.
-*/
os_bit32 fcGetDeviceHandles(
                          agRoot_t  *hpRoot,
                          agFCDev_t  hpFCDev[],
                          os_bit32   maxFCDevs
                        )
{
    os_bit32     DevsFound       = 0;
    DevSlot_t    Highest_DevSlot = 0;
    fiList_t    *Active_DevLink;
    fiList_t    *Next_DevLink;
    CThread_t   *CThread         = CThread_ptr(hpRoot);
    DevThread_t *DevThread;
    os_bit32        slot;

    fiSingleThreadedEnter(hpRoot , fdGetDeviceHandles);

    fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "In %s EL %d",
                    "fcGetDeviceHandles",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiNumElementsOnList(&CThread->Active_DevLink),
                    0,0,0,0,0,0,0);

    if (  CThread->thread_hdr.currentState != CStateNormal )
    {
        fiSingleThreadedLeave(hpRoot , fdGetDeviceHandles);

        return 0;
    }

    Active_DevLink = &(CThread->Active_DevLink);
    Next_DevLink   = Active_DevLink;

    while ((Next_DevLink = Next_DevLink->flink) != Active_DevLink)
    {
        DevsFound += 1;

        DevThread = hpObjectBase(DevThread_t,DevLink,Next_DevLink);

        if (DevThread->DevSlot > Highest_DevSlot)
        {
            Highest_DevSlot = DevThread->DevSlot;
        }
    }

    for (slot = 0;
         slot < maxFCDevs;
         slot++)
    {
        hpFCDev[slot] = (agFCDev_t *)agNULL;
    }

    while ((Next_DevLink = Next_DevLink->flink) != Active_DevLink)
    {
        DevThread = hpObjectBase(DevThread_t,DevLink,Next_DevLink);

        slot      = DevThread->DevSlot;

        if (slot < maxFCDevs)
        {
            hpFCDev[slot] = (agFCDev_t *)DevThread;
        }
    }

    fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "Out %s EL %d",
                    "fcGetDeviceHandles",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiNumElementsOnList(&CThread->Active_DevLink),
                    0,0,0,0,0,0,0);

    fiSingleThreadedLeave(hpRoot , fdGetDeviceHandles);

    if (DevsFound > 0)
    {
        return (Highest_DevSlot + 1);
    }
    else /* DevsFound == 0 */
    {
        return 0;
    }
}


/*+
  Function: fcGetDeviceInfo
   Purpose: This function is called to copy hpFCDevInfo of device information for the agFCDev_t on agRoot_t HBA channel.
            Oslayer must provide buffer large enough to hold agFCDevInfo_t of handle.
  Called By: <unknown OS Layer functions>
      Calls: Access's data structures only
-*/
os_bit32 fcGetDeviceInfo(
                       agRoot_t      *hpRoot,
                       agFCDev_t      hpFCDev,
                       agFCDevInfo_t *hpFCDevInfo
                     )
{

    DevThread_t  * DevThread = (DevThread_t  *)hpFCDev;
    CThread_t    * CThread   = CThread_ptr(hpRoot);
    if(DevThread == agNULL)
    {
    return fcGetDevInfoFailed;
    }
/*
    fiLogString(hpRoot,
                    "Enter %s Enter %d Leave %d",
                    "fcGetDeviceInfo",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(hpRoot)->LastSingleThreadedEnterCaller,
                    CThread_ptr(hpRoot)->LastSingleThreadedLeaveCaller,
                    0,0,0,0,0,0);
*/
    fiSingleThreadedEnter(hpRoot , fdGetDeviceInfo);

    fiLogDebugString(hpRoot,
                    FCMainLogConsoleLevel,
                    "fcGetDeviceInfo(%p)",
                    (char *)agNULL,(char *)agNULL,
                    hpFCDev,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
    /*Update Devinfo for SNIA IOCTLS */
    DevThread->DevInfo.PortSupportedSpeed =  (CThread->DEVID == ChipConfig_DEVID_TachyonXL2) ? HBA_PORTSPEED_2GBIT : HBA_PORTSPEED_1GBIT;
    DevThread->DevInfo.PortSpeed = CThread->TwoGigSuccessfull ? HBA_PORTSPEED_2GBIT : HBA_PORTSPEED_1GBIT;
    DevThread->DevInfo.PortState = (  CThread->thread_hdr.currentState == CStateNormal ) ? HBA_PORTSTATE_ONLINE : HBA_PORTSTATE_LINKDOWN;

    if(CThread->InitAsNport)
    {
        DevThread->DevInfo.PortType = HBA_PORTTYPE_NPORT;
    }
    else
    {
        DevThread->DevInfo.PortType = CThread->FlogiSucceeded ?  HBA_PORTTYPE_FLPORT : HBA_PORTTYPE_NLPORT;
    }

    DevThread->DevInfo.PortSupportedClassofService = 0x8;


    /*Not available til phase 2
    DevThread->DevInfo.PortSupportedFc4Types ;
    DevThread->DevInfo.FabricName;
    DevThread->DevInfo.PortActiveFc4Types;
    Not available til phase 2 */

    *hpFCDevInfo = DevThread->DevInfo;
    fiSingleThreadedLeave(hpRoot , fdGetDeviceInfo);
    return fcGetDevInfoReturned;
}

/* extern os_bit32 hpFcConsoleLevel; */
/*+
  Function: fcInitializeChannel
   Purpose: This function is called initialize the agRoot_t for the channel. All memory 
            has to be allocated prior to calls of this function. If memory layout verifaction
            fails this function fails. Adapter specfic code exists. Various fclayer flags are 
            initialized. A number of attempts are made to exit this routine with the link in the UP
            state.
 Called By: <unknown OS Layer functions>
     Calls: fcCardSupported
            fiMemMapCalculate
            fiFlashSvcInitialize
            fiInstallStateMachine
            fiInitializeThread
            SFThreadInitializeRequest
            fiTimerInitializeRequest
            DevThreadInitializeSlots
            CFuncEnable_Interrupts
            CEventDoInitalize
            CFuncInit_FunctionPointers
            CFuncInteruptDelay
            Proccess_IMQ
            CFuncInterruptPoll

-*/
os_bit32 fcInitializeChannel(
                           agRoot_t *hpRoot,
                           os_bit32    initType,
                           agBOOLEAN   sysIntsActive,
                           void       *cachedMemoryPtr,
                           os_bit32    cachedMemoryLen,
                           os_bit32    dmaMemoryUpper32,
                           os_bit32    dmaMemoryLower32,
                           void       *dmaMemoryPtr,
                           os_bit32    dmaMemoryLen,
                           os_bit32    nvMemoryLen,
                           os_bit32    cardRamUpper32,
                           os_bit32    cardRamLower32,
                           os_bit32    cardRamLen,
                           os_bit32    cardRomUpper32,
                           os_bit32    cardRomLower32,
                           os_bit32    cardRomLen,
                           os_bit32    usecsPerTick
                         )
{
    agBOOLEAN               fiMemMapCalculate_rtn;
    fiMemMapCalculation_t   fiMemMapCalculation;
    CThread_t             * pCThread;
    os_bit32                DEVID_VENDID;
    os_bit32                retry_count = 0;

#ifdef OSLayer_NT

	os_bit32				   tmp;
#endif /* OSLayer_NT */

#ifdef Force_sysIntsActive
    sysIntsActive = Force_sysIntsActive;
#endif /* Force_sysIntsActive */

    if (fcCardSupported(
                         hpRoot
                       )        != agTRUE)
    {
        fiLogDebugString(
                          hpRoot,
                          FCMainLogErrorLevel,
                          "fcInitializeChannel(): fcCardSupported() Sanity Check returned agFALSE !!!",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogString(hpRoot,
                        "%s failed %s failed",
                        "fcInitializeChannel","fcCardSupported",
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);

        return fcInitializeFailure;
    }

    fiSingleThreadedEnter(hpRoot , fdInitializeChannel);

    fiMemMapCalculation.Input.initType         = initType;
    fiMemMapCalculation.Input.sysIntsActive    = sysIntsActive;
    fiMemMapCalculation.Input.cachedMemoryPtr  = cachedMemoryPtr;
    fiMemMapCalculation.Input.cachedMemoryLen  = cachedMemoryLen;
    fiMemMapCalculation.Input.dmaMemoryUpper32 = dmaMemoryUpper32;
    fiMemMapCalculation.Input.dmaMemoryLower32 = dmaMemoryLower32;
    fiMemMapCalculation.Input.dmaMemoryPtr     = dmaMemoryPtr;
    fiMemMapCalculation.Input.dmaMemoryLen     = dmaMemoryLen;
    fiMemMapCalculation.Input.nvMemoryLen      = nvMemoryLen;
    fiMemMapCalculation.Input.cardRamUpper32   = cardRamUpper32;
    fiMemMapCalculation.Input.cardRamLower32   = cardRamLower32;
    fiMemMapCalculation.Input.cardRamLen       = cardRamLen;
    fiMemMapCalculation.Input.cardRomUpper32   = cardRomUpper32;
    fiMemMapCalculation.Input.cardRomLower32   = cardRomLower32;
    fiMemMapCalculation.Input.cardRomLen       = cardRomLen;
    fiMemMapCalculation.Input.usecsPerTick     = usecsPerTick;


    fiLogDebugString(
                    hpRoot,
                    FCMainLogErrorLevel,
                    "fcInitializeChannel vdma %p pdma %08X",
                    (char *)agNULL,(char *)agNULL,
                    dmaMemoryPtr,(void *)agNULL,
                    (os_bit32)dmaMemoryLower32,
                    0,0,0,0,0,0,0
                    );



    fiMemMapCalculate_rtn = fiMemMapCalculate(
                                               hpRoot,
                                               &fiMemMapCalculation,
                                               agFALSE
                                              );

    if (fiMemMapCalculate_rtn == agFALSE)
    {
        fiLogDebugString(
                        hpRoot,
                        FCMainLogConsoleLevel,
                        "fcInitializeChannel\fiMemMapCalculate(EnforceDefaults==agFALSE) returned agFALSE !!!",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,&fiMemMapCalculation,
                        0,0,0,0,0,0,0,0
                        );

        fiMemMapCalculate_rtn = fiMemMapCalculate(
                                                   hpRoot,
                                                   &fiMemMapCalculation,
                                                   agTRUE
                                                  );
    }

    if (fiMemMapCalculate_rtn == agFALSE)
    {
        fiLogDebugString(
                          hpRoot,
                          FCMainLogConsoleLevel,
                          "fcInitializeChannel\fiMemMapCalculate(EnforceDefaults==agTRUE) returned agFALSE as well!!!",
                          (char *)agNULL,(char *)agNULL,
                          hpRoot,&fiMemMapCalculation,
                          0,0,0,0,0,0,0,0
                        );

        fiLogString(hpRoot,
                        "%s failed %s failed %x",
                        "fcInitializeChannel","fiMemMapCalculate",
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);

        fiSingleThreadedLeave(hpRoot , fdInitializeChannel);

        return fcInitializeFailure;
    }

    hpRoot->fcData = (void *)(fiMemMapCalculation.MemoryLayout.CThread.addr.CachedMemory.cachedMemoryPtr);

    ((CThread_t *)(hpRoot->fcData))->Calculation = fiMemMapCalculation;

    pCThread = CThread_ptr(hpRoot)->Calculation.MemoryLayout.CThread.addr.CachedMemory.cachedMemoryPtr;

    /* Read in important PCI Config Registers */

    DEVID_VENDID     = osChipConfigReadBit32(
                                              hpRoot,
                                              ChipConfig_DEVID_VENDID
                                            );

    pCThread->VENDID = DEVID_VENDID & ChipConfig_VENDID_MASK;

    pCThread->DEVID  = DEVID_VENDID & ChipConfig_DEVID_MASK;

    pCThread->REVID  = osChipConfigReadBit32(
                                              hpRoot,
                                              ChipConfig_CLSCODE_REVID
                                            )                          & ChipConfig_REVID_Major_Minor_MASK;

    pCThread->SVID   = osChipConfigReadBit32(
                                              hpRoot,
                                              ChipConfig_SVID
                                            );

    if(pCThread->SVID == 0x1101103C )
    {

        fiLogString(hpRoot,
                        "(%p) %s  SVID (%08X) JANUS Board Yuk !!!",
                        "fcInitializeChannel",(char *)agNULL,
                        hpRoot,(void *)agNULL,
                        pCThread->SVID,0,0,0,0,0,0,0);

        pCThread->JANUS = agTRUE;
    }
    else
    {
        fiLogDebugString(hpRoot,
                        CFuncLogConsoleERROR,
                        "(%p) %s  SVID (%08X) Single Channel Board",
                        "fcInitializeChannel",(char *)agNULL,
                        hpRoot,(void *)agNULL,
                        pCThread->SVID,0,0,0,0,0,0,0);
        pCThread->JANUS = agFALSE;
    }

    CFuncReadBiosParms(hpRoot);
    pCThread->NumberTwoGigFailures=0;
    /* Initialize Interrupt Delay Mechanism to be disabled */

    pCThread->RSCNreceived            = agFALSE;

    pCThread->InterruptsDelayed       = agFALSE;
    pCThread->InterruptDelaySuspended = agFALSE;
    pCThread->NoStallTimerTickActive  = agFALSE;
    pCThread->TimerTickActive         = agFALSE;

#ifdef __FC_Layer_Loose_IOs
    pCThread->IOsTotalCompleted = 0;
    pCThread->IOsFailedCompeted = 0;
#endif /*  __FC_Layer_Loose_IOs  */

    pCThread->thread_hdr.subState     = CSubStateInitialized;

    if( fiFlashSvcInitialize(hpRoot))
    {
        fiLogString(hpRoot,
                        "%s failed %s failed %x",
                        "fcInitializeChannel","fiFlashSvcInitialize",
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);

        fiSingleThreadedLeave(hpRoot , fdInitializeChannel);

        return fcInitializeFailure;
    }

    /* Setup Channel Thread */

#ifndef __State_Force_Static_State_Tables__
    fiInstallStateMachine(
        &CStateTransitionMatrix,
        &CStateActionScalar,
        pCThread->Calculation.MemoryLayout.CTransitions.addr.CachedMemory.cachedMemoryPtr,
        pCThread->Calculation.MemoryLayout.CActions.addr.CachedMemory.cachedMemoryPtr,
        pCThread->Calculation.MemoryLayout.On_Card_MASK,
        &noActionUpdate
        );
#endif /* __State_Force_Static_State_Tables__ was not defined */

    fiInitializeThread(&pCThread->thread_hdr,
        hpRoot,
        threadType_CThread,
        CStateShutdown,
#ifdef __State_Force_Static_State_Tables__
        &CStateTransitionMatrix,
        &CStateActionScalar
#else /* __State_Force_Static_State_Tables__ was not defined */
        pCThread->Calculation.MemoryLayout.CTransitions.addr.CachedMemory.cachedMemoryPtr,
        pCThread->Calculation.MemoryLayout.CActions.addr.CachedMemory.cachedMemoryPtr
#endif /* __State_Force_Static_State_Tables__ was not defined */
        );

    pCThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;

    SFThreadInitializeRequest(
                               &(pCThread->SFThread_Request)
                             );

    fiTimerInitializeRequest(
                               &(pCThread->Timer_Request)
                            );

    DevThreadInitializeSlots(
                               hpRoot
                            );

    /* Kick-off CThread to continue initialization */

#ifdef TEST_OSLayer_Stub
/*
    testCthread( hpRoot );
    testSFthread( hpRoot );
    testDevthread( hpRoot );
    testCDBthread( hpRoot );
    return fcInitializeSuccess;
*/
#endif  /* TEST_OSLayer_Stub */
    pCThread->AquiredCredit_Shifted = BB_CREDIT_SHIFTED( 1 ); /* Start out with one credit */

    pCThread->DelayedInterruptActive = agFALSE;

    pCThread->DeviceSelf = (DevThread_t *)agNULL;
    pCThread->NOS_DetectedInIMQ = 0;
    pCThread->LaserEnable = agFALSE;

    pCThread->ProcessingIMQ = agFALSE;
    pCThread->IDLE_RECEIVED = agFALSE;
    pCThread->LOOP_DOWN = agTRUE;
    pCThread->ChanInfo.LinkUp = agFALSE;

    pCThread->Elastic_Store_ERROR_Count     = 0;
    pCThread->Lip_F7_In_tick                = 0;
    pCThread->Link_Failures_In_tick         = 0;
    pCThread->Lost_Signal_In_tick           = 0;

    pCThread->Node_By_Passed_In_tick        = 0;
    pCThread->Lost_sync_In_tick             = 0;
    pCThread->Transmit_PE_In_tick           = 0;
    pCThread->Link_Fault_In_tick            = 0;

    pCThread->TimerTickActive               = agFALSE;

    pCThread->TimeOutValues.RT_Tov = pCThread->Calculation.Parameters.RT_TOV;
    pCThread->TimeOutValues.ED_Tov = pCThread->Calculation.Parameters.ED_TOV;
    pCThread->TimeOutValues.LP_Tov = pCThread->Calculation.Parameters.LP_TOV;
    pCThread->TimeOutValues.AL_Time= pCThread->Calculation.Parameters.AL_Time;

    pCThread->Loop_State_TimeOut_In_tick    = 0;
    /* SNIA Link statistics                                 ChipLinkStatus registers    */

    pCThread->ChanInfo.LIPCountUpper= 0;
    pCThread->ChanInfo.LIPCountLower= 0;

    pCThread->ChanInfo.NOSCountUpper= 0;
    pCThread->ChanInfo.NOSCountLower= 0;

    pCThread->ChanInfo.ErrorFramesUpper= 0;
    pCThread->ChanInfo.ErrorFramesLower= 0;                 /* Link_Status_3_Exp_Frm and Link_Status_2_Rx_EOFa */

    pCThread->ChanInfo.DumpedFramesUpper= 0;
    pCThread->ChanInfo.DumpedFramesLower= 0;                /* Link_Status_2_Dis_Frm */

    pCThread->ChanInfo.LinkFailureCountUpper = 0;
    pCThread->ChanInfo.LinkFailureCountLower = 0;           /* Link_Status_1_Link_Fail */

    pCThread->ChanInfo.LossOfSyncCountLower  = 0;
    pCThread->ChanInfo.LossOfSyncCountUpper  = 0;           /* Link_Status_1_Loss_of_Sync */

    pCThread->ChanInfo.LossOfSignalCountLower = 0;
    pCThread->ChanInfo.LossOfSignalCountUpper = 0;          /* Link_Status_1_Loss_of_Signal */

    pCThread->ChanInfo.PrimitiveSeqProtocolErrCountUpper= 0;
    pCThread->ChanInfo.PrimitiveSeqProtocolErrCountLower= 0;/* Link_Status_2_Proto_Err */

    pCThread->ChanInfo.InvalidRxWordCountUpper= 0;
    pCThread->ChanInfo.InvalidRxWordCountLower= 0;          /* Link_Status_1_Bad_RX_Char */

    pCThread->ChanInfo.InvalidCRCCountUpper= 0;
    pCThread->ChanInfo.InvalidCRCCountLower= 0;             /* Link_Status_2_Bad_CRC */

#ifdef _SANMARK_LIP_BACKOFF
    pCThread->TicksTillLIP_Count           = 0;
#endif /* _SANMARK_LIP_BACKOFF */ 

    pCThread->sysIntsActive           = sysIntsActive;
    pCThread->sysIntsLogicallyEnabled = 0;
 
    pCThread->PreviouslyAquiredALPA = agFALSE;
    pCThread->ExpectMoreNSFrames    = agTRUE;
    pCThread->NS_CurrentBit32Index  = 0;

    pCThread->CDBpollingCount        = 0;
    pCThread->SFpollingCount         = 0;
    pCThread->Fabric_pollingCount    = 0;

    /* set NumberOutstandingFindDevice to the a max of 32 or less */
    pCThread->NumberOutstandingFindDevice = pCThread->Calculation.Parameters.SF_CMND_Reserve > 32 ? 32 : pCThread->Calculation.Parameters.SF_CMND_Reserve   ;

    fiLogDebugString(hpRoot,
            FCMainLogErrorLevel,
            "NumberOutstandingFindDevice %d NumDevices %d SF_CMND_Reserve %d",
            (char *)agNULL,(char *)agNULL,
            (void *)agNULL,(void *)agNULL,
            pCThread->NumberOutstandingFindDevice,
            pCThread->Calculation.Parameters.NumDevices,
            pCThread->Calculation.Parameters.SF_CMND_Reserve ,
            0,0,0,0,0);

    CFuncEnable_Interrupts(
                            hpRoot,
                            (  ChipIOUp_INTEN_MPE
                             | ChipIOUp_INTEN_CRS
                             | ChipIOUp_INTEN_INT
                             | ChipIOUp_INTEN_DER
                             | ChipIOUp_INTEN_PER)
                          );

    CFuncInit_FunctionPointers(hpRoot );

    CFuncInteruptDelay(hpRoot, agFALSE);

    fiSendEvent(&(pCThread->thread_hdr),CEventDoInitalize);

    if (pCThread->FlogiRcvdFromTarget)
    {
        /* We are in a situation where we recvd our own FLOGI. Our 
           controller gets into this mode when we switch from
           loop to point to point and the system does not do a 
           PCI reset on a softboot. We have to give up on point to point
           and go loop. */

        pCThread->Calculation.Parameters.InitAsNport = 0;

        fiLogDebugString(hpRoot,
                FCMainLogErrorLevel,
                "Going to Loop mode due to initialize nport failure .... CState %d",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                pCThread->thread_hdr.currentState,
                0,0,0,0,0,0,0);

        fiSendEvent(&(pCThread->thread_hdr),CEventDoInitalize);
    }

#ifdef OSLayer_NT

    if(pCThread->Calculation.Parameters.WolfPack)
    {
	    /*Guru: Stall for 10 seconds for Wolfpack */
        for (tmp = 0; tmp < 10000; tmp++)
        {
            osStallThread(hpRoot, 300 );
            if( pCThread->thread_hdr.currentState == CStateNormal  )
            {
                pCThread->FuncPtrs.Proccess_IMQ(hpRoot);
            }
            osStallThread(hpRoot, 600 );
            if( pCThread->thread_hdr.currentState == CStateNormal  )
            {
                pCThread->FuncPtrs.Proccess_IMQ(hpRoot);
            }
            osStallThread(hpRoot, 100 );
            if( pCThread->thread_hdr.currentState == CStateNormal  )
            {
                pCThread->FuncPtrs.Proccess_IMQ(hpRoot);
            }

        }
    }
#endif  /* OSLayer_NT */

    pCThread->FuncPtrs.Proccess_IMQ(hpRoot);

    if( pCThread->thread_hdr.currentState != CStateNormal  )
    {
        fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "After CEventDoInitalize Failed CState %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);
        if (pCThread->InitAsNport)
        {
            fiSendEvent(&(pCThread->thread_hdr),CEventDoInitalize);
        }

        
        if( pCThread->thread_hdr.currentState == CStateResetNeeded  )
        {
            while ( pCThread->thread_hdr.currentState == CStateResetNeeded  )
            {
                if( pCThread->Loop_Reset_Event_to_Send == CEventDoInitalize)
                {
                    pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
                }
                if( retry_count > MAX_fcInitializeChannel_RETRYS)
                {
                   break;
                }
                fiLogString(hpRoot,
                            "After CEventDoInitalize Failed retry_count %d",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            retry_count,
                            0,0,0,0,0,0,0);

                retry_count ++;

                fiSendEvent(&(pCThread->thread_hdr),(event_t) pCThread->Loop_Reset_Event_to_Send);
            }
        }
        else
        {
            if( pCThread->thread_hdr.currentState == CStateRSCNErrorBackIOs)
            {
                if(fiListElementOnList( (fiList_t *)(&(pCThread->Timer_Request)),
                                               &(pCThread->TimerQ)))
                {
                    fiTimerStop(&pCThread->Timer_Request);
                }

                fiSendEvent(&(pCThread->thread_hdr),CEventAllocDiPlogiThread);
            }
            else
            {
                if( pCThread->thread_hdr.currentState != CStateInitializeFailed)
                {
                    fiLogString(hpRoot,
                                    "%s Success %s %d %x CEventShutdown",
                                    "fcInitializeChannel","Cstate",
                                    (void *)agNULL,(void *)agNULL,
                                    (os_bit32)pCThread->thread_hdr.currentState,
                                    0,0,0,0,0,0,0);

                    fiSendEvent(&(pCThread->thread_hdr),CEventShutdown);
                    fiSendEvent(&(pCThread->thread_hdr),CEventDoInitalize);
                }
            }

            if( pCThread->thread_hdr.currentState != CStateNormal)
            {

                fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "After CEventDoInitalize Failed CState %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);
                fiSingleThreadedLeave(hpRoot , fdInitializeChannel);

                fiLogString(hpRoot,
                                "%s Success %s %d %x",
                                "fcInitializeChannel","Cstate",
                                (void *)agNULL,(void *)agNULL,
                                (os_bit32)pCThread->thread_hdr.currentState,
                                0,0,0,0,0,0,0);

                return fcInitializeSuccess;
            }
        }
    }


    if( CFuncIMQ_Interrupt_Pending( hpRoot))
    {   /* Some OSLayers Enable interupts before getting a vector*/
        /* Try to clear interrupt before returning  */
        fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "CFuncIMQ_Interrupt_Pending FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                0,0,0,0);
         pCThread->FuncPtrs.Proccess_IMQ(hpRoot);
    }

    fiLogDebugString(hpRoot,
                FCMainLogConsoleLevel,
                "After CEventDoInitalize CCnt %x",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                pCThread->CDBpollingCount,
                0,0,0,0,0,0,0);

    fiLogDebugString(hpRoot,
                FCMainLogConsoleLevel,
                "CFuncEnable_Interrupts CCnt %x",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                pCThread->CDBpollingCount,
                0,0,0,0,0,0,0);

    if(CFuncInterruptPoll( hpRoot,&pCThread->CDBpollingCount ))
    {
        fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "fcinit Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                0,0,0,0);
    }

    fiSingleThreadedLeave(hpRoot , fdInitializeChannel);

    CFuncEnable_Interrupts(hpRoot,ChipIOUp_INTEN_INT);

    fiLogString(hpRoot,
                    "E %s Success %s %d",
                    "fcInitializeChannel","Cstate",
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)pCThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);


    return fcInitializeSuccess;
}

/*+
  Function: fcInitializeDriver
   Purpose: This function is called to calculate memory needed for the channel.
            The addresses of the passed pointers are updated after calculations are complete.
 Called By: <unknown OS Layer functions>
     Calls: FCStructASSERTs
            TLStructASSERTs
            fiFlashSvcASSERTs
            fiMemMapCalculate
-*/
os_bit32 fcInitializeDriver(
                          agRoot_t *hpRoot,
                          os_bit32    *cachedMemoryNeeded,
                          os_bit32    *cachedMemoryPtrAlign,
                          os_bit32    *dmaMemoryNeeded,
                          os_bit32    *dmaMemoryPtrAlign,
                          os_bit32    *dmaMemoryPhyAlign,
                          os_bit32    *nvMemoryNeeded,
                          os_bit32    *usecsPerTick
                        )
{
    agBOOLEAN               fiMemMapCalculate_rtn;
    fiMemMapCalculation_t fiMemMapCalculation;

    if (FCStructASSERTs()   > 0)
    {
        fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "%s FAILED !!!!!",
                "FCStructASSERTs",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                0,0,0,0,0,0,0,0);
 
        return fcInitializeFailure;
    }

    if (TLStructASSERTs()   > 0)
    {
        fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "%s FAILED !!!!!",
                "TLStructASSERTs",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                0,0,0,0,0,0,0,0);
 
        return fcInitializeFailure;
    }

    if (fiFlashSvcASSERTs() > 0)
    {
        fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "%s FAILED !!!!!",
                "fiFlashSvcASSERTs",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                0,0,0,0,0,0,0,0);
 
        return fcInitializeFailure;
    }


    fiMemMapCalculation.Input.initType         = 0;
    fiMemMapCalculation.Input.sysIntsActive    = agFALSE;
    fiMemMapCalculation.Input.cachedMemoryPtr  = agNULL;
    fiMemMapCalculation.Input.cachedMemoryLen  = 0xFFFFFFFF;
    fiMemMapCalculation.Input.dmaMemoryUpper32 = 0;
    fiMemMapCalculation.Input.dmaMemoryLower32 = 0;
    fiMemMapCalculation.Input.dmaMemoryPtr     = agNULL;
    fiMemMapCalculation.Input.dmaMemoryLen     = 0xFFFFFFFF;
    fiMemMapCalculation.Input.nvMemoryLen      = 0xFFFFFFFF;
    fiMemMapCalculation.Input.cardRamUpper32   = 0;
    fiMemMapCalculation.Input.cardRamLower32   = 0;
    fiMemMapCalculation.Input.cardRamLen       = 0x00040000;
    fiMemMapCalculation.Input.cardRomUpper32   = 0;
    fiMemMapCalculation.Input.cardRomLower32   = 0;
    fiMemMapCalculation.Input.cardRomLen       = 0x00020000;
    fiMemMapCalculation.Input.usecsPerTick     = 0;

    fiMemMapCalculate_rtn = fiMemMapCalculate(
                                               hpRoot,
                                               &fiMemMapCalculation,
                                               agFALSE
                                              );

    if (fiMemMapCalculate_rtn == agFALSE)
    {
        fiLogDebugString(
                          hpRoot,
                          FCMainLogConsoleLevel,
                          "fcInitializeDriver\fiMemMapCalculate(EnforceDefaults==agFALSE) returned agFALSE !!!",
                          (char *)agNULL,(char *)agNULL,
                          hpRoot,&fiMemMapCalculation,
                          0,0,0,0,0,0,0,0
                        );

        fiMemMapCalculate_rtn = fiMemMapCalculate(
                                                   hpRoot,
                                                   &fiMemMapCalculation,
                                                   agTRUE
                                                  );
    }

    if (fiMemMapCalculate_rtn == agFALSE)
    {
        fiLogDebugString(
                          hpRoot,
                          FCMainLogConsoleLevel,
                          "fcInitializeDriver\fiMemMapCalculate(EnforceDefaults==agTRUE) returned agFALSE as well!!!",
                          (char *)agNULL,(char *)agNULL,
                          hpRoot,&fiMemMapCalculation,
                          0,0,0,0,0,0,0,0
                        );

        *cachedMemoryNeeded   = 0;
        *cachedMemoryPtrAlign = 0;
        *dmaMemoryNeeded      = 0;
        *dmaMemoryPtrAlign    = 0;
        *dmaMemoryPhyAlign    = 0;
        *nvMemoryNeeded       = 0;
        *usecsPerTick         = 0;

        return fcInitializeFailure;
    }

    *cachedMemoryNeeded   = fiMemMapCalculation.ToRequest.cachedMemoryNeeded;
    *cachedMemoryPtrAlign = fiMemMapCalculation.ToRequest.cachedMemoryPtrAlignAssumed;
    *dmaMemoryNeeded      = fiMemMapCalculation.ToRequest.dmaMemoryNeeded;
    *dmaMemoryPtrAlign    = fiMemMapCalculation.ToRequest.dmaMemoryPtrAlignAssumed;
    *dmaMemoryPhyAlign    = fiMemMapCalculation.ToRequest.dmaMemoryPhyAlignAssumed;
    *nvMemoryNeeded       = fiMemMapCalculation.ToRequest.nvMemoryNeeded;
    *usecsPerTick         = fiMemMapCalculation.ToRequest.usecsPerTick;

    return fcInitializeSuccess;
}

/*+
  Function: fcInterruptHandler
   Purpose: This function is called to disable interrupts for the channel.
            returns agTRUE if interrupt if active on this channel.
            Returns agFALSE if interrupt is cleared when checked.
            Special case. Some systems do not PCI reset the chip on reboot. 
            This could cause interrupts to be asserted before fclayer is setup(agNULL agRoot_t).
            Some OS's route interrupts to interrupt handler as soon as channel is identified.
            If called with agNULL agRoot_t reset chip.
 Called By: <unknown OS Layer functions>
     Calls: osChipIOUpWriteBit32
            CFuncSoftResetAdapter
            CFuncRead_Interrupts
            CFuncDisable_Interrupts
            osFCLayerAsyncError
            osDebugBreakpoint
-*/
agBOOLEAN fcInterruptHandler(
                            agRoot_t *hpRoot
                          )
{
    CThread_t *pCThread  = CThread_ptr(hpRoot);
    os_bit32      intStatus;

    if ( pCThread == agNULL)
    {
        /*
        ** Disable the interrupt.
        */

        osChipIOUpWriteBit32( hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST, 0 );

        /* If No Cthread this blue screens.....
             CFuncDisable_Interrupts(
                                     hpRoot,
                                     (  ChipIOUp_INTEN_MPE
                                      | ChipIOUp_INTEN_CRS
                                      | ChipIOUp_INTEN_INT
                                      | ChipIOUp_INTEN_DER
                                      | ChipIOUp_INTEN_PER)
                                   );
        */

        /*
        ** execute a hard reset on the HBA.
        */

        CFuncSoftResetAdapter(hpRoot);/*fcInterrupt*/

        return agFALSE;
    }

    intStatus = (  CFuncRead_Interrupts(
                                         hpRoot
                                       )
                 & ChipIOUp_INTPEND_MASK       );

    if (intStatus == ChipIOUp_INTPEND_INT)
    {
        /* Typically, we will find that TachyonTL generated the INT (a.k.a. "TachLite Interrupt") */

        CFuncDisable_Interrupts(
                                 hpRoot,
                                 ChipIOUp_INTEN_INT
                               );

        return agTRUE;
    }

	/*+
	 * If power is already removed from the PCI slot, return agFALSE as this is
	 * a spurious / invalid interrupt.
	-*/

    if (intStatus & ChipIOUp_INTPEND_Reserved )
    {   /* These bits should always be zero if set no power to chip these are set ! */
        return agFALSE;
    }
    if (!intStatus)
    {
        /* Alternatively, we will find that TachyonTL didn't generate any interrupt at all
           (i.e. some other PCI device is sharing TachyonTL's PCI Interrupt Line)          */

        return agFALSE;
    }

    /* If we get here, some non-INT interrupt has been raised (potentially INT as well) */

    if (intStatus & ChipIOUp_INTPEND_MPE)
    {
        /* MPE Interrupt raised - mask it and call osFCLayerAsyncError() */

        CFuncDisable_Interrupts(
                                 hpRoot,
                                 ChipIOUp_INTEN_MPE
                               );

        fiLogDebugString(
                          hpRoot,
                          FCMainLogErrorLevel,
                          "TachyonTL generated %s Interrupt (%s)",
                          "External Memory Parity Error",
                          "MPE",
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        osFCLayerAsyncError(
                             hpRoot,
                             osFCConfusedMPE
                           );
    }

    if (intStatus & ChipIOUp_INTPEND_CRS)
    {
        /* CRS Interrupt raised - mask it and call osFCLayerAsyncError() */

        CFuncDisable_Interrupts(
                                 hpRoot,
                                 ChipIOUp_INTEN_CRS
                               );

        fiLogDebugString(
                          hpRoot,
                          FCMainLogErrorLevel,
                          "TachyonTL generated %s Interrupt (%s)",
                          "PCI Master Address Crossed 45-Bit Boundary",
                          "CRS",
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        osFCLayerAsyncError(
                             hpRoot,
                             osFCConfusedCRS
                           );
    }

    if (intStatus & ChipIOUp_INTPEND_DER)
    {
        /* DER Interrupt raised - mask it and call osFCLayerAsyncError() */

        CFuncDisable_Interrupts(
                                 hpRoot,
                                 ChipIOUp_INTEN_DER
                               );

        fiLogDebugString(
                          hpRoot,
                          FCMainLogErrorLevel,
                          "TachyonTL generated %s Interrupt (%s)",
                          "DMA Error Detected",
                          "DER",
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        osFCLayerAsyncError(
                             hpRoot,
                             osFCConfusedDER
                           );
    }

    if (intStatus & ChipIOUp_INTPEND_PER)
    {
        /* PER Interrupt raised - mask it and call osFCLayerAsyncError() */

        CFuncDisable_Interrupts(
                                 hpRoot,
                                 ChipIOUp_INTEN_PER
                               );
/*
        fiLogDebugString(
                          hpRoot,
                          FCMainLogErrorLevel,
                          "TachyonTL generated %s Interrupt (%s)",
                          "PCI Error Detected",
                          "PER",
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

*/
       fiLogString(hpRoot,
                          "TachyonTL generated %s Interrupt (%s)",
                          "PCI Error Detected",
                          "PER",
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        CFuncYellowLed(hpRoot, agTRUE );
        osDebugBreakpoint (hpRoot, agTRUE, "PER");
        osFCLayerAsyncError(
                             hpRoot,
                             osFCConfusedPER
                           );
    }

    /* In case we are still alive, handle case where INT is also raised */

    if (intStatus & ChipIOUp_INTPEND_INT)
    {
        /* TachyonTL also generated the INT (a.k.a. "TachLite Interrupt") */

        CFuncDisable_Interrupts(
                                 hpRoot,
                                 ChipIOUp_INTEN_INT
                               );
    }

    return agTRUE;
} /* end fcInterruptHandler() */

/*+
  Function: fcIOInfoReadBit8
   Purpose: This function is called to read 8 bits of the response buffer information for agIORequest_t
            at offset fcIOInfoOffset.
            Only valid during osIOCompleted
 Called By: osIOCompleted
     Calls: Access's data structures only
-*/
os_bit8 fcIOInfoReadBit8(
                       agRoot_t      *hpRoot,
                       agIORequest_t *hpIORequest,
                       os_bit32          fcIOInfoOffset
                     )
{
    os_bit8                   to_return;
    os_bit32                  FCP_RESP_Offset;
    fiMemMapCalculation_t *Calculation;

    fiLogDebugString(hpRoot,
                    FCMainLogConsoleLevel,
                    "fcIOInfoReadBit8",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    Calculation = &(CThread_ptr(hpRoot)->Calculation);

    if (Calculation->MemoryLayout.FCP_RESP.memLoc == inCardRam)
    {
        FCP_RESP_Offset = CDBThread_ptr(hpIORequest)->FCP_RESP_Offset + fcIOInfoOffset;

        to_return = osCardRamReadBit8(
                                       hpRoot,
                                       FCP_RESP_Offset
                                     );
    }
    else /* Calculation->MemoryLayout.FCP_RESP.memLoc ==inDmaMemory */
    {
        to_return = *((os_bit8 *)(CDBThread_ptr(hpIORequest)->FCP_RESP_Ptr) + fcIOInfoOffset);
    }

    return to_return;
}

/*+
  Function: fcIOInfoReadBit16
   Purpose: This function is called to read 16 bits of the response buffer information for agIORequest_t
            at offset fcIOInfoOffset.
            Only valid during osIOCompleted
 Called By: osIOCompleted
     Calls: Access's data structures only
-*/
os_bit16 fcIOInfoReadBit16(
                         agRoot_t      *hpRoot,
                         agIORequest_t *hpIORequest,
                         os_bit32       fcIOInfoOffset
                       )
{
    os_bit16               to_return;
    os_bit32               FCP_RESP_Offset;
    fiMemMapCalculation_t *Calculation;

    fiLogDebugString(hpRoot,
                    FCMainLogConsoleLevel,
                    "fcIOInfoReadBit16",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    Calculation = &(CThread_ptr(hpRoot)->Calculation);

    if (Calculation->MemoryLayout.FCP_RESP.memLoc == inCardRam)
    {
        FCP_RESP_Offset = CDBThread_ptr(hpIORequest)->FCP_RESP_Offset + fcIOInfoOffset;

        to_return = osCardRamReadBit16(
                                        hpRoot,
                                        FCP_RESP_Offset
                                      );
    }
    else /* Calculation->MemoryLayout.FCP_RESP.memLoc ==inDmaMemory */
    {
        to_return = *(os_bit16 *)(((os_bit8 *)(CDBThread_ptr(hpIORequest)->FCP_RESP_Ptr) + fcIOInfoOffset));
    }

    return to_return;
}

/*+
  Function: fcIOInfoReadBit32
   Purpose: This function is called to read 32 bits of the response buffer information for agIORequest_t
            at offset fcIOInfoOffset.
            Only valid during osIOCompleted
 Called By: osIOCompleted
     Calls: Access's data structures only
-*/
os_bit32 fcIOInfoReadBit32(
                         agRoot_t      *hpRoot,
                         agIORequest_t *hpIORequest,
                         os_bit32          fcIOInfoOffset
                       )
{
    os_bit32                  to_return;
    os_bit32                  FCP_RESP_Offset;
    fiMemMapCalculation_t *Calculation;

    fiLogDebugString(hpRoot,
                    FCMainLogConsoleLevel,
                    "fcIOInfoReadBit32",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    Calculation = &(CThread_ptr(hpRoot)->Calculation);

    if (Calculation->MemoryLayout.FCP_RESP.memLoc == inCardRam)
    {
        FCP_RESP_Offset = CDBThread_ptr(hpIORequest)->FCP_RESP_Offset + fcIOInfoOffset;

        to_return = osCardRamReadBit32(
                                        hpRoot,
                                        FCP_RESP_Offset
                                      );
    }
    else /* Calculation->MemoryLayout.FCP_RESP.memLoc ==inDmaMemory */
    {
        to_return = *(os_bit32 *)(((os_bit8 *)(CDBThread_ptr(hpIORequest)->FCP_RESP_Ptr) + fcIOInfoOffset));
    }

    return to_return;
}

/*+
  Function: fcIOInfoReadBlock
   Purpose: This function is called to copy fcIOInfoBufLen bytes of the response buffer information
            for agIORequest_t at offset fcIOInfoOffset.
            Only valid during osIOCompleted
 Called By: osIOCompleted
     Calls: Access's data structures only
-*/
void fcIOInfoReadBlock(
                        agRoot_t      *hpRoot,
                        agIORequest_t *hpIORequest,
                        os_bit32       fcIOInfoOffset,
                        void          *fcIOInfoBuffer,
                        os_bit32       fcIOInfoBufLen
                      )
{
    os_bit32                  FCP_RESP_Offset;
    fiMemMapCalculation_t *Calculation;
    os_bit32                  cnt;
    os_bit8                  *src;
    os_bit8                  *dst = (void *)fcIOInfoBuffer;

#ifndef Performance_Debug
    fiLogDebugString(hpRoot,
                    FCMainLogConsoleLevel,
                    "fcIOInfoReadBlock",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
#endif /* Performance_Debug */

    Calculation = &(CThread_ptr(hpRoot)->Calculation);

    if (Calculation->MemoryLayout.FCP_RESP.memLoc == inCardRam)
    {
        FCP_RESP_Offset = CDBThread_ptr(hpIORequest)->FCP_RESP_Offset + fcIOInfoOffset;

        osCardRamReadBlock(
                            hpRoot,
                            FCP_RESP_Offset,
                            fcIOInfoBuffer,
                            fcIOInfoBufLen
                          );
    }
    else /* Calculation->MemoryLayout.FCP_RESP.memLoc ==inDmaMemory */
    {
        src = (os_bit8 *)(CDBThread_ptr(hpIORequest)->FCP_RESP_Ptr) + fcIOInfoOffset;

        for (cnt = 0;
             cnt < fcIOInfoBufLen;
             cnt++
            )
        {
            *dst++ = *src++;
        }
    }

}


/*+

  Function: fcLeavingOS
   Purpose: This function is called to indicate to the FC Layer that it should prepare for the 
            OS to switch (presumably between NetWare and BIOS). Upon return from the "other OS", a 
            corresponding call to fcEnteringOS() will be made .  It is assumed by the OS Layer 
            that calling this function causes the FC Layer to stop participation on the Fibre 
            Channel until fcEnteringOS() is called.  Further, no interrupts or other PCI bus 
            accesses will be required by the card during this time.

  Called By: <unknown OS Layer functions>
      Calls: CFuncDisable_Interrupts

-*/
void fcLeavingOS(
                  agRoot_t *hpRoot
                )
{
    CThread_t *CThread;

    fiSingleThreadedEnter(hpRoot , fdLeavingOS);

    CThread = CThread_ptr(hpRoot);

    CThread->sysIntsActive_before_fcLeavingOS_call = CThread->sysIntsActive;

    CThread->sysIntsActive                         = agFALSE;

    CFuncDisable_Interrupts(
                             hpRoot,
                             0
                           );

    fiSingleThreadedLeave(hpRoot , fdLeavingOS);

    return;
}

#ifdef _DvrArch_1_30_

/*+
   Function: fcIPCancel
    Purpose: IP Cancels CancelItem
  Called By: OSLayer
      Calls: 
-*/
os_bit32 fcIPCancel(
                     agRoot_t          *hpRoot,
                     void              *osData,
		             void              *CancelItem
                   )
{
    CThread_t       *pCThread    = CThread_ptr(hpRoot);
    IPThread_t      *pIPThread   = pCThread->IP;
    void            *item        = CancelItem;

    if (item != agNULL)
    {
        if( fiListElementOnList( (fiList_t *) item, &pIPThread->IncomingBufferLink ) )
        {
            fiListDequeueThis( item );

            osFcNetIoctlCompleted( hpRoot, item, FC_CMND_STATUS_CANCELED );
        }
    }
    else do 
    {
        fiListDequeueFromHead( &item, &pIPThread->IncomingBufferLink );

        osFcNetIoctlCompleted( hpRoot, item, FC_CMND_STATUS_CANCELED );

    } while ( item != (void *) agNULL );

    osFcNetIoctlCompleted( hpRoot, osData, FC_CMND_STATUS_SUCCESS );

    return 0;
}

/*+
   Function: fcIPReceive
    Purpose: IP Initiates status report
  Called By: OSLayer
      Calls: 
-*/
os_bit32 fcIPReceive(
                      agRoot_t          *hpRoot,
                      void              *osData
                    )
{
    CThread_t       *pCThread    = CThread_ptr(hpRoot);
    IPThread_t      *pIPThread   = pCThread->IP;

    fiListEnqueueListAtTail( &pIPThread->IncomingBufferLink, osData );

    return 0;
}

/*+
   Function: fcIPSend
    Purpose: IP Initiates IPSend
  Called By: OSLayer
      Calls: PktEventDoIPData
-*/
os_bit32 fcIPSend(
                   agRoot_t          *hpRoot,
                   os_bit8           *DestAddress,
                   void              *osData,
		           os_bit32           PacketLength
                 )
{
    CThread_t       *pCThread    = CThread_ptr(hpRoot);
    PktThread_t     *pPktThread;
    os_bit32         i;

    DevThread_t     *pDevThread;
    os_bit8          PortWWN[8];

    fiLogDebugString(hpRoot,
                    IPStateLogConsoleLevel,
                    "In %s - State = %d",
                    "fcIPSend",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    PortWWN[0] = 0;
    PortWWN[1] = 0;
    for (i = 0; i < 6; i++)
        PortWWN[i+2] = DestAddress[i];

    pDevThread = CFuncMatchPortWWNtoThread( hpRoot, PortWWN );

    pPktThread = PktThreadAlloc( hpRoot, pDevThread );	

    pPktThread->osData = osData;
    pPktThread->DataLength = PacketLength;

    fiListEnqueueListAtTail( &pCThread->IP->OutgoingLink, pPktThread );

    fiSendEvent( &pPktThread->thread_hdr, PktEventDoIPData );

    return 0;
}

/*+
   Function: fcIPStatus
    Purpose: IP Initiates status report
  Called By: OSLayer
      Calls: IPEventReportLinkStatus
-*/
os_bit32 fcIPStatus(
                     agRoot_t          *hpRoot,
                     void              *osData
                   )
{
    CThread_t       *pCThread    = CThread_ptr(hpRoot);
    IPThread_t      *pIPThread   = pCThread->IP;

    pIPThread->LinkStatus.osData = osData;

    fiSendEvent( &pIPThread->thread_hdr, IPEventReportLinkStatus );

    return 0;
}

/*+
   Function: fcProcessInboundQ
    Purpose: IP Currently does nothing
  Called By: OSLayer
      Calls: 
-*/
void fcProcessInboundQ(
                        agRoot_t  *agRoot,
                        os_bit32   agQPairID
                      )
{
    fiLogDebugString( agRoot,
                      FCMainLogConsoleLevel,
                      "fcProcessInboundQ(): agRoot==0x%8P agQPairID==0x%1X",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agRoot,(void *)agNULL,
                      agQPairID,
                      0,0,0,0,0,0,0 );
}
#endif /* _DvrArch_1_30_ was defined */

/*+
  Function: fcResetChannel
   Purpose: Completes all outstanding IO's. Initiates rescan of channel if channel is OK.
            Takes appropriate action if channel is not OK.
 Called By: OSLayer
     Calls: CFuncCompleteAllActiveCDBThreads
            CFuncCheckCstate
            CEventAsyncLoopEventDetected
            CFuncShowActiveCDBThreads
-*/
os_bit32 fcResetChannel(
                      agRoot_t *hpRoot,
                      os_bit32  hpResetType
                    )
{
    event_t      Event_to_Send = 0;
    CThread_t   *pCThread;
    os_bit32     Num_ActiveCDBSonEntry = 0;

    pCThread = CThread_ptr(hpRoot)->Calculation.MemoryLayout.CThread.addr.CachedMemory.cachedMemoryPtr;

    fiLogString(hpRoot,
                "In %s CState %d Active IO %x",
                "fcResetChannel",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)pCThread->thread_hdr.currentState,
				CFuncShowActiveCDBThreads( hpRoot, ShowActive),
                0,0,0,0,0,0);

    fiSingleThreadedEnter(hpRoot , fdResetChannel);

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "fcResetChannel Ccnt %x CState %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->CDBpollingCount,
                    (os_bit32)pCThread->thread_hdr.currentState,
                    0,0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "FM Status %08X TL Status %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    0,0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(hpRoot)->LOOP_DOWN,
                    CThread_ptr(hpRoot)->IDLE_RECEIVED,
                    CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                    CThread_ptr(hpRoot)->ERQ_FROZEN,
                    CThread_ptr(hpRoot)->FCP_FROZEN,
                    CThread_ptr(hpRoot)->ProcessingIMQ,
                    0,0);

    Num_ActiveCDBSonEntry = CFuncShowActiveCDBThreads( hpRoot, ShowActive);

    CFuncCompleteAllActiveCDBThreads( hpRoot,osIOFailed,CDBEventIODeviceReset );

    if( pCThread->thread_hdr.currentState != CStateNormal )
    {
        if( (Event_to_Send = CFuncCheckCstate(hpRoot)) != 0)
        {
            fiSendEvent(&(pCThread->thread_hdr),Event_to_Send);
        }
        else
        {
            fiSendEvent(&(pCThread->thread_hdr),CEventDoInitalize);
        }
    }
    else
    {
        fiSendEvent(&(pCThread->thread_hdr),CEventAsyncLoopEventDetected);
    }

    if ((hpResetType & fcSyncAsyncResetMask) == fcAsyncReset)
    {
        osResetChannelCallback(
                                hpRoot,
                                fcResetSuccess
                              );
    }


    Num_ActiveCDBSonEntry = CFuncShowActiveCDBThreads( hpRoot, ShowActive);

    fiLogString(hpRoot,
                "Out %s CState %d Active %d",
                "fcResetChannel",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)pCThread->thread_hdr.currentState,
				Num_ActiveCDBSonEntry,
                0,0,0,0,0,0);

    fiSingleThreadedLeave(hpRoot , fdResetChannel);


    return(fcResetSuccess);
}


/*+
  Function: fcResetDevice
   Purpose: Completes all outstanding IO's on hpFCDev. If hpResetType is hard reset
            send task managment function Target Reset to hpFCDev. (This will break a 
            reserve on a disk drive ) Soft reset will do PLOGI and PRLI.
            If hpFCDevhpFCDev is  fcResetAllDevs all devices are sent the reset type.
        
 Called By: OSLayer
     Calls: Proccess_IMQ
            fiResetAllDevices
            fiResetDevice
            CFuncCheckCstate
            CFuncShowActiveCDBThreads
-*/
os_bit32 fcResetDevice(
                     agRoot_t  *hpRoot,
                     agFCDev_t  hpFCDev,
                     os_bit32   hpResetType
                   )
{
    CThread_t  *CThread                 = CThread_ptr(hpRoot);
    event_t     Event_to_Send           = 0;
    os_bit32    Num_ActiveCDBSonEntry   = 0;

    os_bit32 status = fcResetSuccess;

    fiSingleThreadedEnter(hpRoot, fdResetDevice );

    if(CThread->DEVReset_pollingCount)
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Entry Non zero DEVReset_pollingCount %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread->DEVReset_pollingCount,
                    0,0,0,0,0,0,0);

        CThread->DEVReset_pollingCount = 0;
    }

    fiLogString(hpRoot,
                    "IN fcResetDevice %p Ldt %X CS %d AC %x",
                    (char *)agNULL,(char *)agNULL,
                    hpFCDev,(void *)agNULL,
                    CThread->LinkDownTime.Lo,
                    CThread->thread_hdr.currentState,
                    CFuncAll_clear( hpRoot ),
                    0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "IN fcResetDevice %p Ccnt %x",
                    (char *)agNULL,(char *)agNULL,
                    hpFCDev,(void *)agNULL,
                    CThread->CDBpollingCount,
                    0,0,0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "FM Status %08X TL Status %08X FMcfg %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32( hpRoot,ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(hpRoot)->LOOP_DOWN,
                    CThread_ptr(hpRoot)->IDLE_RECEIVED,
                    CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                    CThread_ptr(hpRoot)->ERQ_FROZEN,
                    CThread_ptr(hpRoot)->FCP_FROZEN,
                    CThread_ptr(hpRoot)->ProcessingIMQ,
                    0,0);

    fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "Interrupt %08X (%08X) TLStatus %08X pending  %x !",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CFuncRead_Interrupts(hpRoot),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    CFuncIMQ_Interrupt_Pending( hpRoot),
                    0,0,0,0);

    if(  CFuncIMQ_Interrupt_Pending( hpRoot))
    {
        CThread->FuncPtrs.Proccess_IMQ(hpRoot);
    }

    if ( hpFCDev == agNULL )
    {
        fiSingleThreadedLeave(hpRoot, fdResetDevice );

        return fcResetFailure;
    }


    Num_ActiveCDBSonEntry = CFuncShowActiveCDBThreads( hpRoot, ShowActive);

	if(! CFuncFreezeQueuesPoll(hpRoot) )
    {
		CFuncReInitializeSEST(hpRoot);
		osChipIOUpWriteBit32(hpRoot, ChipIOUp_SEST_Linked_List_Head_Tail, 0xffffffff);
	}
    else
    {
        fiLogString(hpRoot,
                "%s %s failed !",
                "fcResetDevice","CFuncFreezeQueuesPoll",
                (void *)agNULL,(void *)agNULL,
                0,0,0,0,0,0,0,0);

	}

	if (CFunc_Always_Enable_Queues(hpRoot))
    {
        fiLogString(hpRoot,
                "%s %s failed !",
                "fcResetDevice","CFunc_Always_Enable_Queues",
                (void *)agNULL,(void *)agNULL,
                0,0,0,0,0,0,0,0);
	}


    CThread->thread_hdr.subState = CSubStateResettingDevices;

    if ( hpFCDev == fcResetAllDevs )
    {
        status = fiResetAllDevices( hpRoot, hpResetType );

    }
    else
    {
        status = fiResetDevice( hpRoot, hpFCDev, hpResetType, agTRUE, agTRUE);
    }

    if(CThread->DEVReset_pollingCount)
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Exit Non zero DEVReset_pollingCount %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread->DEVReset_pollingCount,
                    0,0,0,0,0,0,0);

        CThread->DEVReset_pollingCount = 0;
    }

    CThread->thread_hdr.subState = CSubStateInitialized;

    if( (Event_to_Send = CFuncCheckCstate(hpRoot)) != 0)
    {
        fiSendEvent(&(CThread->thread_hdr),Event_to_Send);
    }

    if ((hpResetType & fcSyncAsyncResetMask) == fcAsyncReset)
    {
        osResetDeviceCallback(
                                hpRoot,hpFCDev,
                                fcResetSuccess
                              );
    }


    fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "OUT fcResetDevice %p Ccnt %x",
                    (char *)agNULL,(char *)agNULL,
                    hpFCDev,(void *)agNULL,
                    CThread->CDBpollingCount,
                    0,0,0,0,0,0,0);

    fiLogString(hpRoot,
                "%s %p CState %d Aoe %x Now %x",
                "fcResetDevice",(char *)agNULL,
                 hpFCDev,(void *)agNULL,
                (os_bit32)CThread->thread_hdr.currentState,
				Num_ActiveCDBSonEntry,
				CFuncShowActiveCDBThreads( hpRoot, ShowActive),
                0,0,0,0,0);

    fiSingleThreadedLeave(hpRoot, fdResetDevice );

    return status;
}


/*+
  Function: fcShutdownChannel
   Purpose: Takes channel to shutdown state.        
 Called By: OSLayer
     Calls: CEventShutdown
-*/
void fcShutdownChannel(
                        agRoot_t  *hpRoot
                      )
{
    CThread_t *CThread = CThread_ptr(hpRoot);


    fiSingleThreadedEnter(hpRoot, fdShutdownChannel );

    fiSendEvent( &CThread->thread_hdr, CEventShutdown );

    fiSingleThreadedLeave(hpRoot, fdShutdownChannel );

    fiLogDebugString(hpRoot,
                    FCMainLogConsoleLevel,
                    "Out fcShutdownChannel",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);


    return;
}

/*+
  Function: fcStartIO
   Purpose: Executes SCSI IO to given hpFCDev.
            if defined _Sanity_Check_hpIORequest_ verifies that no IO's are owed by fclayer with the current 
            agIORequest_t. If Calculation.Parameters.IO_Mode is polling do not return until request completes.
            If CThread->IOsStartedSinceISR < CThread->Calculation.Parameters.IOsBetweenISRs disable 
            CFuncInteruptDelay.
   Returns: fcIOBusy if FCLayer cannot execute request if in a improper state or lack of recources.
            fcIONoDevice if device handle bad.
            fcIOStarted if IO accepted - fclayer now "owns" request.
 Called By: OSLayer
     Calls: CDBThreadAlloc
            DevEventSendIO
            CFuncInterruptPoll
            CThread->Loop_Reset_Event_to_Send
            CFuncInteruptDelay
            Proccess_IMQ
-*/
os_bit32 fcStartIO(
                 agRoot_t          *hpRoot,
                 agIORequest_t     *hpIORequest,
                 agFCDev_t          hpFCDev,
                 os_bit32           hpRequestType,
                 agIORequestBody_t *hpRequestBody
               )
{
    CThread_t   *CThread   = CThread_ptr(hpRoot);
    CDBThread_t *CDBThread;
    DevThread_t *DevThread = (DevThread_t *)hpFCDev;

#ifdef _Sanity_Check_hpIORequest_
    fiList_t    *Sanity_DevLink;
    fiList_t    *Sanity_DevLink_Start;
    DevThread_t *Sanity_DevThread;
    fiList_t    *Sanity_CDBLink;
    fiList_t    *Sanity_CDBLink_Start;
    CDBThread_t *Sanity_CDBThread;
#endif /* _Sanity_Check_hpIORequest_ was defined */

    fiSingleThreadedEnter(hpRoot, fdStartIO );

    if ( hpFCDev == agNULL )
    {
        fiSingleThreadedLeave(hpRoot, fdStartIO );

        return fcIONoDevice;
    }

    if( CThread->thread_hdr.currentState != CStateNormal )
    {
        fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "fcStartIO Busy - CThread not in CStateNormal State %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread->thread_hdr.currentState,
                    hpRequestType,0,0,0,0,0,0);

        fiSingleThreadedLeave(hpRoot, fdStartIO );

        if( CThread->thread_hdr.currentState == CStateInitializeFailed )
        {
        }
        return fcIOBusy;
    }

#ifdef _Sanity_Check_hpIORequest_
    Sanity_DevLink_Start = &(CThread->Active_DevLink);
    Sanity_DevLink       = Sanity_DevLink_Start;
    while ((Sanity_DevLink = Sanity_DevLink->flink) != Sanity_DevLink_Start)
    {
        Sanity_DevThread     = hpObjectBase(DevThread_t,DevLink,Sanity_DevLink);
        Sanity_CDBLink_Start = &(Sanity_DevThread->Active_CDBLink);
        Sanity_CDBLink       = Sanity_CDBLink_Start;
        while ((Sanity_CDBLink = Sanity_CDBLink->flink) != Sanity_CDBLink_Start)
        {
            Sanity_CDBThread = hpObjectBase(CDBThread_t,CDBLink,Sanity_CDBLink);
            if (hpIORequest == Sanity_CDBThread->hpIORequest)
            {
                fiLogDebugString(
                                  hpRoot,
                                  FCMainLogErrorLevel,
                                  "fcStartIO() called w/ already active hpIORequest (0x%08X) thread (0x%08X)",
                                  (char *)agNULL,(char *)agNULL,
                                  (void *)agNULL,(void *)agNULL,
                                  (os_bit32)hpIORequest,
                                  (os_bit32)Sanity_CDBThread,
                                  0,0,0,0,0,0
                                );
            }
        }
    }
#endif /* _Sanity_Check_hpIORequest_ was defined */

#ifdef Device_IO_Throttle
    if( DevThread->DevActive_pollingCount > (Device_IO_Throttle_MAX_Outstanding_IO - 1)  )
    {
        fiSingleThreadedLeave(hpRoot,fdStartIO );
        fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "fcStartIO Busy - DevActive_pollingCount %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    DevThread->DevActive_pollingCount,
                    0,0,0,0,0,0,0);
        return fcIOBusy;
    }
#endif /* Device_IO_Throttle */

    if ((CDBThread = CDBThreadAlloc(
                                     hpRoot,
                                     hpIORequest,
                                     hpFCDev,
                                     hpRequestBody
                                   )) == (CDBThread_t *)agNULL)
    {
        fiSingleThreadedLeave(hpRoot,fdStartIO );

        fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "fcStartIO Busy - CDBThreadAlloc Failed",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

        return fcIOBusy;
    }

#ifndef Performance_Debug
    fiLogDebugString(hpRoot,
                    FCMainLogConsoleLevel,
                    "Lun %08X %08X Control %08X CDB %08X %08X %08X %08X DL %08X ",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    *(os_bit32 *)&hpRequestBody->CDBRequest.FcpCmnd.FcpLun[0],
                    *(os_bit32 *)&hpRequestBody->CDBRequest.FcpCmnd.FcpLun[4],
                    *(os_bit32 *)&hpRequestBody->CDBRequest.FcpCmnd.FcpCntl[0],
                    *(os_bit32 *)&hpRequestBody->CDBRequest.FcpCmnd.FcpCdb[0],
                    *(os_bit32 *)&hpRequestBody->CDBRequest.FcpCmnd.FcpCdb[4],
                    *(os_bit32 *)&hpRequestBody->CDBRequest.FcpCmnd.FcpCdb[8],
                    *(os_bit32 *)&hpRequestBody->CDBRequest.FcpCmnd.FcpCdb[12],
                    *(os_bit32 *)&hpRequestBody->CDBRequest.FcpCmnd.FcpDL[0]);

#endif /* Performance_Debug */

    /*
    fiSendEvent( &(CDBThread->thread_hdr), CDBEventInitialize );
    */
    fiSendEvent( &(DevThread->thread_hdr), DevEventSendIO );

    if( CThread->thread_hdr.currentState == CStateResetNeeded )
    {
        fiSendEvent(&(CThread->thread_hdr),(event_t)CThread->Loop_Reset_Event_to_Send);
    }

    if ((CThread->sysIntsActive == agFALSE) || (CThread->Calculation.Parameters.IO_Mode == MemMap_Polling_IO_Mode))
    {
        if(CFuncInterruptPoll( hpRoot,&CThread->CDBpollingCount ))
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Sio Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0);
        }
    }
    else /* (CThread->sysIntsActive == agTRUE) && (CThread->Calculation.Parameters.IO_Mode == MemMap_Interrupt_IO_Mode) */
    {
        if (++CThread->IOsStartedSinceISR < CThread->Calculation.Parameters.IOsBetweenISRs)
        {
            CThread->FuncPtrs.Proccess_IMQ(hpRoot);/* IO Path */
            if(CThread->RSCNreceived )
            {
                if( CThread->thread_hdr.currentState == CStateRSCNErrorBackIOs  )
                {
                    CThread->RSCNreceived = agFALSE;
                    CFuncDoADISC( hpRoot);
                    fiSendEvent(&(CThread->thread_hdr),CEventDeviceListEmpty);
                    fiLogString(hpRoot,
                                    "%s CState %d",
                                    "fcStartIO",(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    CThread->thread_hdr.currentState,
                                    0,0,0,0,0,0,0);

                }
            }

        }
        else /* ++CThread->IOsStartedSinceISR >= CThread->Calculation.Parameters.IOsBetweenISRs */
        {
            if (    (CThread->InterruptsDelayed       == agTRUE)
                 && (CThread->InterruptDelaySuspended == agFALSE) )
            {
                /* Temporarily stop delaying interrupts */

                CThread->InterruptDelaySuspended = agTRUE;

                CFuncInteruptDelay(hpRoot, agFALSE);
#ifdef USE_XL_Delay_Register
                /* If XL DelayTimer */
                CThread->FuncPtrs.Proccess_IMQ(hpRoot); /* IO Path */
#endif /* USE_XL_Delay_Register */

            }
        }
    }

    fiSingleThreadedLeave(hpRoot, fdStartIO );

    return fcIOStarted;
}

/*+
  Function: fcSystemInterruptsActive
   Purpose: Allows OSLayer to control channel interrupt activity - global enable / disable.
 Called By: OSLayer
     Calls: CFuncEnable_Interrupts
-*/
void fcSystemInterruptsActive(
                               agRoot_t *hpRoot,
                               agBOOLEAN   sysIntsActive
                             )
{
    fiSingleThreadedEnter(hpRoot, fdSystemInterruptsActive );

    CThread_ptr(hpRoot)->sysIntsActive = sysIntsActive;

    CFuncEnable_Interrupts(
                            hpRoot,
                            0
                          );

    fiSingleThreadedLeave(hpRoot, fdSystemInterruptsActive );

    return;
}

/*
#define SkipHeartBeat
*/

/*+
  Function: fcTimerTick
   Purpose: Periodic opportuinity for fclayer housekeeping. Generally set to one second intervals. 
            Blinks the LED. Reset counters, poll link statictics, enable / disable interrupt delay. 
            Sends recovery events.
 Called By: OSLayer
     Calls: fiTimerTick
            Proccess_IMQ
            CFuncInteruptDelay
            CFuncCheckCstate
            CFuncCheckForTimeouts
-*/
void fcTimerTick(
                  agRoot_t *hpRoot
                )
{
    CThread_t * CThread                       = CThread_ptr(hpRoot);
    os_bit32    IntDelayRateMethod            = CThread->Calculation.Parameters.IntDelayRateMethod;
    os_bit32    IntDelayOnIORate              = CThread->Calculation.Parameters.IntDelayOnIORate;
    os_bit32    IntDelayOffIORate             = CThread->Calculation.Parameters.IntDelayOffIORate;
    os_bit32    IOsStartedThisTimerTick;
    os_bit32    IOsCompletedThisTimerTick;
    os_bit32    IOsIntCompletedThisTimerTick;
    os_bit32    IOsPollCompletedThisTimerTick;
    os_bit32    IOsActive;

    agBOOLEAN  Link_Status_counts_Change = agFALSE;

    event_t     event_to_send;
    os_bit32    Link_Status_Counts = 0;

    fiSingleThreadedEnter(hpRoot, fdTimerTick );
    if (! CThread->InitAsNport)
    {
        CThread->NoStallTimerTickActive = agTRUE;
    }
    CThread->TimerTickActive = agTRUE;
    /* Fetch running counters */

    IOsStartedThisTimerTick       = CThread->IOsStartedThisTimerTick;
    IOsCompletedThisTimerTick     = CThread->IOsCompletedThisTimerTick;
    IOsIntCompletedThisTimerTick  = CThread->IOsIntCompletedThisTimerTick;
    IOsPollCompletedThisTimerTick = IOsCompletedThisTimerTick - IOsIntCompletedThisTimerTick;
    IOsActive                     = CThread->IOsActive;

    if( CThread->IOsActive_LastTick )
    {
        if( CThread->IOsActive_LastTick == CThread->IOsActive)
        {
            if( IOsStartedThisTimerTick == 0 )
            {
                if( IOsIntCompletedThisTimerTick == 0 )
                {
                    if( IOsPollCompletedThisTimerTick == 0  &&  CThread->thread_hdr.currentState == CStateNormal )
                    {
                        CThread->IOsActive_No_ProgressCount++;

                        fiLogString(hpRoot,
                                        "%s No Progress Act %d Pend %d Cs %d Cnt %d",
                                        "fcTimerTick",(char *)agNULL,
                                        (void *)agNULL,(void *)agNULL,
                                        CThread->IOsActive,
                                        (CThread->FuncPtrs.GetIMQProdIndex(hpRoot) - CThread->HostCopy_IMQConsIndex),
                                        CThread->thread_hdr.currentState,
                                        CThread->IOsActive_No_ProgressCount,
                                        0,0,0,0);

                        if( CThread->IOsActive_No_ProgressCount > MAX_NO_PROGRESS_DETECTS )
                        {
                            CFuncShowActiveCDBThreads( hpRoot,ShowERQ);
                            CThread->LinkDownTime = CThread->TimeBase;
                        }
                    }
                }
            }
        }
        else
        {
            CThread->IOsActive_No_ProgressCount = 0;
        }
    }

    /* Invoke normal TimerTick processing to increment time base and deliver expired timer events */

    fiTimerTick(
                 hpRoot,
                 CThread->Calculation.Input.usecsPerTick
               );

    /* Check to see if Interrupt Delay mechanism needs adjustment */

    if((CThread->FuncPtrs.GetIMQProdIndex(hpRoot) - CThread->HostCopy_IMQConsIndex) > 2)
    {
/*
        fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "CThread->HostCopy_IMQConsIndex %03X != %03X %X Ints %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        CThread->HostCopy_IMQConsIndex,
                        CThread->FuncPtrs.GetIMQProdIndex(hpRoot),
                        (CThread->FuncPtrs.GetIMQProdIndex(hpRoot) - CThread->HostCopy_IMQConsIndex),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST ),
                        0,0,0,0);
*/
#ifdef USE_XL_Delay_Register
                /* If XL DelayTimer */
/*              This chnage masks the interrupt delay problem !
                CThread->FuncPtrs.Proccess_IMQ(hpRoot); 

*/
#endif /* USE_XL_Delay_Register */
#ifndef Performance_Debug
#endif /* Performance_Debug */

    }

    if (CThread->InterruptsDelayed == agFALSE)
    {
        /* Interrupts are currently not delayed - do they need to be? */

        if (    (    ( IntDelayRateMethod == MemMap_RateMethod_IOsStarted       )
                  && ( IntDelayOnIORate   <= IOsStartedThisTimerTick            ) )
             || (    ( IntDelayRateMethod == MemMap_RateMethod_IOsCompleted     )
                  && ( IntDelayOnIORate   <= IOsCompletedThisTimerTick          ) )
             || (    ( IntDelayRateMethod == MemMap_RateMethod_IOsIntCompleted  )
                  && ( IntDelayOnIORate   >= IOsIntCompletedThisTimerTick       ) )
             || (    ( IntDelayRateMethod == MemMap_RateMethod_IOsPollCompleted )
                  && ( IntDelayOnIORate   <= IOsPollCompletedThisTimerTick      ) )
             || (    ( IntDelayRateMethod == MemMap_RateMethod_IOsActive        )
                  && ( IntDelayOnIORate   <= IOsActive                          ) ) )
        {
            /* Start delaying interrupts */

            CThread->InterruptsDelayed = agTRUE;
            CFuncInteruptDelay(hpRoot, agTRUE);
        }
    }
    else /* CThread->InterruptsDelayed == agTRUE */
    {
        /* Interrupts are currently delayed - do they still need to be? */

        if (    (    ( IntDelayRateMethod == MemMap_RateMethod_IOsStarted       )
                  && ( IntDelayOffIORate  >= IOsStartedThisTimerTick            ) )
             || (    ( IntDelayRateMethod == MemMap_RateMethod_IOsCompleted     )
                  && ( IntDelayOffIORate  >= IOsCompletedThisTimerTick          ) )
             || (    ( IntDelayRateMethod == MemMap_RateMethod_IOsIntCompleted  )
                  && ( IntDelayOffIORate  <= IOsIntCompletedThisTimerTick       ) )
             || (    ( IntDelayRateMethod == MemMap_RateMethod_IOsPollCompleted )
                  && ( IntDelayOffIORate  >= IOsPollCompletedThisTimerTick      ) )
             || (    ( IntDelayRateMethod == MemMap_RateMethod_IOsActive        )
                  && ( IntDelayOffIORate  >= IOsActive                          ) ) )
        {
            /* Stop delaying interrupts */

            CThread->InterruptsDelayed = agFALSE;

            /* If XL DelayTimer CThread->FuncPtrs.Proccess_IMQ(hpRoot);*/

           CFuncInteruptDelay(hpRoot, agFALSE);
#ifdef USE_XL_Delay_Register
            /* If XL DelayTimer */
            CThread->FuncPtrs.Proccess_IMQ(hpRoot); /* IO Path */
#endif /* USE_XL_Delay_Register */

        }
    }

    CThread->Elastic_Store_ERROR_Count     = 0;
    CThread->Lip_F7_In_tick                = 0;
    CThread->Link_Failures_In_tick         = 0;
    CThread->Lost_Signal_In_tick           = 0;

    CThread->Node_By_Passed_In_tick        = 0;
    CThread->Lost_sync_In_tick             = 0;
    CThread->Transmit_PE_In_tick           = 0;
    CThread->Link_Fault_In_tick            = 0;

    CThread->Loop_State_TimeOut_In_tick    = 0;
    
    Link_Status_Counts =  osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Link_Status_1 );
    if(Link_Status_Counts )
    {
        Link_Status_counts_Change = agTRUE;
        fiLogDebugString(hpRoot,
                        FCMainLogConsoleLevel,
                        "%s %08x FMStatus %08x",
                        "Link_Status_1",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        Link_Status_Counts,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        0,0,0,0,0,0);

        if(CThread->ChanInfo.LossOfSignalCountLower    \
            + ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Signal_AdjustToChar(Link_Status_Counts) \
            < CThread->ChanInfo.LossOfSignalCountLower )
        {
            CThread->ChanInfo.LossOfSignalCountUpper ++;
        }
        CThread->ChanInfo.LossOfSignalCountLower += ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Signal_AdjustToChar(Link_Status_Counts);

        if(CThread->ChanInfo.InvalidRxWordCountUpper    \
            + ChipIOUp_Frame_Manager_Link_Status_1_Bad_RX_Char_AdjustToChar(Link_Status_Counts) \
            < CThread->ChanInfo.InvalidRxWordCountUpper )
        {
            CThread->ChanInfo.InvalidRxWordCountUpper ++;
        }
        CThread->ChanInfo.InvalidRxWordCountLower += ChipIOUp_Frame_Manager_Link_Status_1_Bad_RX_Char_AdjustToChar(Link_Status_Counts);

        if(CThread->ChanInfo.LossOfSyncCountLower    \
            + ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Sync_AdjustToChar(Link_Status_Counts) \
            < CThread->ChanInfo.LossOfSyncCountLower )
        {
            CThread->ChanInfo.LossOfSyncCountUpper ++;
        }
        CThread->ChanInfo.LossOfSyncCountLower += ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Sync_AdjustToChar(Link_Status_Counts);


        if(CThread->ChanInfo.LinkFailureCountLower    \
            + ChipIOUp_Frame_Manager_Link_Status_1_Link_Fail_AdjustToChar(Link_Status_Counts) \
            < CThread->ChanInfo.LinkFailureCountLower )
        {
            CThread->ChanInfo.LinkFailureCountUpper ++;
        }
        CThread->ChanInfo.LinkFailureCountLower += ChipIOUp_Frame_Manager_Link_Status_1_Link_Fail_AdjustToChar(Link_Status_Counts);
    }

    Link_Status_Counts =  osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Link_Status_2 );

    if(Link_Status_Counts )
    {
        Link_Status_counts_Change = agTRUE;
        fiLogDebugString(hpRoot,
                        FCMainLogConsoleLevel,
                        "%%s %08x FMStatus %08x",
                        "Link_Status_2",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        Link_Status_Counts,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        0,0,0,0,0,0);
        if(CThread->ChanInfo.ErrorFramesLower    \
            + ChipIOUp_Frame_Manager_Link_Status_2_Rx_EOFa_AdjustToChar(Link_Status_Counts) \
            < CThread->ChanInfo.ErrorFramesLower )
        {
            CThread->ChanInfo.ErrorFramesUpper ++;
        }
        CThread->ChanInfo.ErrorFramesLower += ChipIOUp_Frame_Manager_Link_Status_2_Rx_EOFa_AdjustToChar(Link_Status_Counts);

        if(CThread->ChanInfo.DumpedFramesLower    \
            + ChipIOUp_Frame_Manager_Link_Status_2_Dis_Frm_AdjustToChar(Link_Status_Counts) \
            < CThread->ChanInfo.DumpedFramesLower )
        {
            CThread->ChanInfo.DumpedFramesUpper ++;
        }
        CThread->ChanInfo.DumpedFramesLower += ChipIOUp_Frame_Manager_Link_Status_2_Dis_Frm_AdjustToChar(Link_Status_Counts);

        if(CThread->ChanInfo.InvalidCRCCountLower    \
            + ChipIOUp_Frame_Manager_Link_Status_2_Bad_CRC_AdjustToChar(Link_Status_Counts) \
            < CThread->ChanInfo.InvalidCRCCountLower )
        {
            CThread->ChanInfo.InvalidCRCCountUpper ++;
        }
        CThread->ChanInfo.InvalidCRCCountLower += ChipIOUp_Frame_Manager_Link_Status_2_Bad_CRC_AdjustToChar(Link_Status_Counts);

        if(CThread->ChanInfo.PrimitiveSeqProtocolErrCountLower    \
            + ChipIOUp_Frame_Manager_Link_Status_2_Proto_Err_AdjustToChar(Link_Status_Counts) \
            < CThread->ChanInfo.PrimitiveSeqProtocolErrCountLower )
        {
            CThread->ChanInfo.PrimitiveSeqProtocolErrCountUpper ++;
        }
        CThread->ChanInfo.PrimitiveSeqProtocolErrCountLower += ChipIOUp_Frame_Manager_Link_Status_2_Proto_Err_AdjustToChar(Link_Status_Counts);
    }


#ifdef __TACHYON_XL2
    Link_Status_Counts =  osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Link_Status_3 );

    if(Link_Status_Counts )
    {
        Link_Status_counts_Change = agTRUE;
        fiLogDebugString(hpRoot,
                        FCMainLogConsoleLevel,
                        "%s %08x FMStatus %08x",
                        "Link_Status_3",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        Link_Status_Counts,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        0,0,0,0,0,0);
        if(CThread->ChanInfo.ErrorFramesLower    \
            + ChipIOUp_Frame_Manager_Link_Status_3_Exp_Frm_AdjustToChar(Link_Status_Counts) \
            < CThread->ChanInfo.ErrorFramesLower )
        {
            CThread->ChanInfo.ErrorFramesUpper ++;
        }
        CThread->ChanInfo.ErrorFramesLower += ChipIOUp_Frame_Manager_Link_Status_3_Exp_Frm_AdjustToChar(Link_Status_Counts);
    }

#endif	/* __TACHYON_XL2 */																	

    if( Link_Status_counts_Change &&  CThread->thread_hdr.currentState == CStateNormal )
    {
        fiLogDebugString(hpRoot,
                        FCMainLogConsoleLevel,
                        "%p %s FMStatus %08x",
                        "Link_Detect",(char *)agNULL,
                        hpRoot,(void *)agNULL,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        0,0,0,0,0,0,0);

        CFuncShowActiveCDBThreads( hpRoot,ShowERQ);
        CThread->LinkDownTime = CThread->TimeBase;
    }

    /* If nothing is going on, send watchdog frame to ourselves */

    if (CThread->IOsStartedThisTimerTick == 0 )
    {

        if( CThread->thread_hdr.currentState == CStateNormal )
        {

            if( CThread->DeviceSelf->In_Verify_ALPA_FLAG == agFALSE)
            {

                if ( CThread->DeviceDiscoveryMethod != DDiscoveryQueriedNameService)
                {

                    if ( ! CThread->InitAsNport)
                    {

#ifndef SkipHeartBeat
                        if(CThread->Calculation.Parameters.HeartBeat)
                        {
                            fiSendEvent(&CThread->DeviceSelf->thread_hdr,DevEventDoTickVerifyALPA);
                        }
#endif  /* SkipHeartBeat */
                    }
                }
            }
        }
        else
        {
            fiLogDebugString(hpRoot,
                            FCMainLogConsoleLevel,
                            "FcTimerTick  Not CStateNormal %d FM Status %08X TL Status %08X ",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            CThread->thread_hdr.currentState,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                            0,0,0,0,0);

        }
    }
    else
    {
#ifndef Performance_Debug
        fiLogDebugString(hpRoot,
                            FCMainLogConsoleLevel,
                            "%d Start %d Complete %d Int Complete %d Polled %d Active %d",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            CThread->InterruptsDelayed,
                            CThread->IOsStartedThisTimerTick,
                            CThread->IOsCompletedThisTimerTick,
                            CThread->IOsIntCompletedThisTimerTick,
                            CThread->IOsCompletedThisTimerTick - CThread->IOsIntCompletedThisTimerTick,
                            CThread->IOsActive,
                            0,0);
#endif /* Performance_Debug */

    }

    /* Reset IO/Tick Counters */

    CThread->IOsStartedThisTimerTick      = 0;
    CThread->IOsCompletedThisTimerTick    = 0;
    CThread->IOsIntCompletedThisTimerTick = 0;
    CThread->IOsActive_LastTick           = CThread->IOsActive;

    /* Just in case, Reset Channel if previously postponed
       (this should no longer be needed here but it can't hurt) */

    if( (event_to_send = CFuncCheckCstate(hpRoot)) != 0)
    {
        fiSendEvent(&(CThread->thread_hdr),event_to_send);
    }

    if( CThread->thread_hdr.currentState == CStateNormal || (CThread->thread_hdr.currentState == CStateRSCNErrorBackIOs ))
    {
        /* If XL DelayTimer CThread->FuncPtrs.Proccess_IMQ(hpRoot);*/ /* IO Path */

        if( CThread->thread_hdr.currentState == CStateNormal )
        {
            if(CFuncCheckForTimeouts(hpRoot, &CThread->Active_DevLink))
            {
                CFuncShowNonEmptyLists(hpRoot, &CThread->Active_DevLink);
#ifdef USE_XL_Delay_Register
                /* If XL DelayTimer */
                CThread->FuncPtrs.Proccess_IMQ(hpRoot); 
#endif /* USE_XL_Delay_Register */

                fiLogDebugString(hpRoot,
                                FCMainLogErrorLevel,
                                "%s %s IMQ %X %X Ints %08X Active %d",
                                "CFCFT","CAN",
                                (void *)agNULL,(void *)agNULL,
                                CThread->FuncPtrs.GetIMQProdIndex(hpRoot),
                                CThread->HostCopy_IMQConsIndex,
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST ),
                                CThread->IOsActive,0,0,0,0);
            }
            
        }

        if( CThread->thread_hdr.currentState == CStateRSCNErrorBackIOs )
        {

            if(CFuncCheckForTimeouts(hpRoot, &CThread->Active_DevLink))
            {
                CFuncShowNonEmptyLists(hpRoot, &CThread->Active_DevLink);
                fiLogDebugString(hpRoot,
                                FCMainLogErrorLevel,
                                "%s %s IMQ %X %X Ints %08X",
                                "CFuncCheckForTimeouts","CStateRSCNErrorBackIOs",
                                (void *)agNULL,(void *)agNULL,
                                CThread->FuncPtrs.GetIMQProdIndex(hpRoot),
                                CThread->HostCopy_IMQConsIndex,
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST ),
                                0,0,0,0,0);
            }
            if(CFuncCheckForTimeouts(hpRoot, &CThread->Prev_Active_DevLink))
            {
                fiLogDebugString(hpRoot,
                                FCMainLogErrorLevel,
                                "%s %s IMQ %X %X Ints %08X",
                                "CFuncCheckForTimeouts","CStateRSCNErrorBackIOs",
                                (void *)agNULL,(void *)agNULL,
                                CThread->FuncPtrs.GetIMQProdIndex(hpRoot),
                                CThread->HostCopy_IMQConsIndex,
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST ),
                                0,0,0,0,0);
            }
            
        }

       /* fiLogString(hpRoot,
                    "%s %s %d",
                    "fcTimerTick","CFuncCheckForTimeouts",
                    (void *)agNULL,(void *)agNULL,
                    CThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);
       */

    }
    else
    {
#ifdef _SANMARK_LIP_BACKOFF
        if( !fiListElementOnList( (fiList_t *)(&(CThread->Timer_Request)), &(CThread->TimerQ)))
            {
                switch(CThread->TicksTillLIP_Count)
                {

                    case 0:
                        CThread->TicksTillLIP_Count++;
                        break;
                    case 1:
                        CThread->TicksTillLIP_Count++;
                        fiTimerSetDeadlineFromNow(hpRoot, &CThread->Timer_Request, 2000000);

                        CThread->Timer_Request.eventRecord_to_send.thread= &CThread->thread_hdr;

                        CThread->Timer_Request.eventRecord_to_send.event = CEventDoInitalize;

                        fiTimerStart(hpRoot,&CThread->Timer_Request);
                        break;
                    case 2:
                        CThread->TicksTillLIP_Count++;
                        fiTimerSetDeadlineFromNow(hpRoot, &CThread->Timer_Request, 2000000 * 6);

                        CThread->Timer_Request.eventRecord_to_send.thread= &CThread->thread_hdr;

                        CThread->Timer_Request.eventRecord_to_send.event = CEventDoInitalize;

                        fiTimerStart(hpRoot,&CThread->Timer_Request);
                        break;
                    case 3:
                        CThread->TicksTillLIP_Count++;
                        fiTimerSetDeadlineFromNow(hpRoot, &CThread->Timer_Request, 2000000 * 12);

                        CThread->Timer_Request.eventRecord_to_send.thread= &CThread->thread_hdr;

                        CThread->Timer_Request.eventRecord_to_send.event = CEventDoInitalize;

                        fiTimerStart(hpRoot,&CThread->Timer_Request);
                        break;

                    default:
                        CThread->TicksTillLIP_Count = 0;

            }

        }

#endif /* _SANMARK_LIP_BACKOFF */ 

        fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "Exit %s %X %08X CState %d",
                        "fcTimerTick",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        CThread->TimeBase.Hi,
                        CThread->TimeBase.Lo,
                        CThread->thread_hdr.currentState,
                        0,0,0,0,0);
    }

    fiSingleThreadedLeave(hpRoot, fdTimerTick );

    return;
}


/*+
  Function: fcmain_c
   Purpose: When compiled updates browser info file for VC 5.0 / 6.0
   Returns: none
 Called By: none
     Calls: none
-*/
/* void fcmain_c(void){}  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\fcstruct.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/FCStruct.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 8/29/00 11:27a  $ (Last Modified)

Purpose:

  This file validates the typedef declarations in ../H/FCStruct.H

--*/
#ifndef _New_Header_file_Layout_
#include "../h/globals.h"
#include "../h/fcstruct.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "fcstruct.h"
#endif  /* _New_Header_file_Layout_ */


/*+
Function:  FCStructASSERTs()

Purpose:   Returns the number of FCStruct.H typedefs which are not the correct size.

Algorithm: Each typedef in FCStruct.H is checked for having the correct size.  While
           this property doesn't guarantee correct packing of the fields within, it
           is a pretty good indicator that the typedef has the intended layout.

           The total number of typedefs which are not of correct size is returned from
           this function.  Hence, if the return value is non-zero, the declarations
           can not be trusted to match the various Fibre Channel specifications.
-*/

os_bit32 FCStructASSERTs(
                       void
                     )
{
    os_bit32 to_return = 0;

    if ( sizeof(FC_Port_ID_Bit32_Form_t)                      !=                      FC_Port_ID_Bit32_Form_t_SIZE ) to_return++;
    if ( sizeof(FC_Port_ID_Struct_Form_t)                     !=                     FC_Port_ID_Struct_Form_t_SIZE ) to_return++;
    if ( sizeof(FC_Port_ID_t)                                 !=                                 FC_Port_ID_t_SIZE ) to_return++;
    if ( sizeof(FC_Frame_Header_t)                            !=                            FC_Frame_Header_t_SIZE ) to_return++;
    if ( sizeof(FC_BA_ACC_Payload_t)                          !=                          FC_BA_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_BA_RJT_Payload_t)                          !=                          FC_BA_RJT_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_N_Port_Common_Parms_t)                     !=                     FC_N_Port_Common_Parms_t_SIZE ) to_return++;
    if ( sizeof(FC_N_Port_Class_Parms_t)                      !=                      FC_N_Port_Class_Parms_t_SIZE ) to_return++;
    if ( sizeof(FC_F_Port_Common_Parms_t)                     !=                     FC_F_Port_Common_Parms_t_SIZE ) to_return++;
    if ( sizeof(FC_F_Port_Class_Parms_t)                      !=                      FC_F_Port_Class_Parms_t_SIZE ) to_return++;
    if ( sizeof(FC_Port_Name_t)                               !=                               FC_Port_Name_t_SIZE ) to_return++;
    if ( sizeof(FC_N_Port_Name_t)                             !=                             FC_N_Port_Name_t_SIZE ) to_return++;
    if ( sizeof(FC_F_Port_Name_t)                             !=                             FC_F_Port_Name_t_SIZE ) to_return++;
    if ( sizeof(FC_Node_or_Fabric_Name_t)                     !=                     FC_Node_or_Fabric_Name_t_SIZE ) to_return++;
    if ( sizeof(FC_Node_Name_t)                               !=                               FC_Node_Name_t_SIZE ) to_return++;
    if ( sizeof(FC_Fabric_Name_t)                             !=                             FC_Fabric_Name_t_SIZE ) to_return++;
    if ( sizeof(FC_Vendor_Version_Level_t)                    !=                    FC_Vendor_Version_Level_t_SIZE ) to_return++;
    if ( sizeof(FC_Association_Header_t)                      !=                      FC_Association_Header_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_Unknown_Payload_t)                     !=                     FC_ELS_Unknown_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_LS_RJT_Payload_t)                      !=                      FC_ELS_LS_RJT_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_Unknown_Payload_t)                 !=                 FC_ELS_ACC_Unknown_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_PLOGI_Payload_t)                       !=                       FC_ELS_PLOGI_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_PLOGI_Payload_t)                   !=                   FC_ELS_ACC_PLOGI_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_FLOGI_Payload_t)                       !=                       FC_ELS_FLOGI_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_FLOGI_Payload_t)                   !=                   FC_ELS_ACC_FLOGI_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_LOGO_Payload_t)                        !=                        FC_ELS_LOGO_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_LOGO_Payload_t)                    !=                    FC_ELS_ACC_LOGO_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_SRR_Payload_t)                         !=                        FC_ELS_SRR_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_REC_Payload_t)                         !=                        FC_ELS_REC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_REC_ACC_Payload_t)                     !=                    FC_ELS_REC_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ABTX_Payload_t)                        !=                        FC_ELS_ABTX_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_ABTX_Payload_t)                    !=                    FC_ELS_ACC_ABTX_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_RCS_Payload_t)                         !=                         FC_ELS_RCS_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_RCS_Payload_t)                     !=                     FC_ELS_ACC_RCS_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_RES_Payload_t)                         !=                         FC_ELS_RES_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_RES_Payload_t)                     !=                     FC_ELS_ACC_RES_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_RSS_Payload_t)                         !=                         FC_ELS_RSS_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_RSS_Payload_t)                     !=                     FC_ELS_ACC_RSS_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_RSI_Payload_t)                         !=                         FC_ELS_RSI_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_RSI_Payload_t)                     !=                     FC_ELS_ACC_RSI_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ESTS_Payload_t)                        !=                        FC_ELS_ESTS_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_ESTS_Payload_t)                    !=                    FC_ELS_ACC_ESTS_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ESTC_Payload_t)                        !=                        FC_ELS_ESTC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ADVC_Payload_t)                        !=                        FC_ELS_ADVC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_ADVC_Payload_t)                    !=                    FC_ELS_ACC_ADVC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_RTV_Payload_t)                         !=                         FC_ELS_RTV_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_RTV_Payload_t)                     !=                     FC_ELS_ACC_RTV_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_RLS_Payload_t)                         !=                         FC_ELS_RLS_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_RLS_Payload_t)                     !=                     FC_ELS_ACC_RLS_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ECHO_Payload_t)                        !=                        FC_ELS_ECHO_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_ECHO_Payload_t)                    !=                    FC_ELS_ACC_ECHO_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_TEST_Payload_t)                        !=                        FC_ELS_TEST_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_RRQ_Payload_t)                         !=                         FC_ELS_RRQ_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_RRQ_Payload_t)                     !=                     FC_ELS_ACC_RRQ_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_PRLI_Parm_Page_t)                      !=                      FC_ELS_PRLI_Parm_Page_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_PRLI_Payload_t)                        !=                        FC_ELS_PRLI_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_PRLI_Parm_Page_t)                  !=                  FC_ELS_ACC_PRLI_Parm_Page_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_PRLI_Payload_t)                    !=                    FC_ELS_ACC_PRLI_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_PRLO_Parm_Page_t)                      !=                      FC_ELS_PRLO_Parm_Page_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_PRLO_Payload_t)                        !=                        FC_ELS_PRLO_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_PRLO_Parm_Page_t)                  !=                  FC_ELS_ACC_PRLO_Parm_Page_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_PRLO_Payload_t)                    !=                    FC_ELS_ACC_PRLO_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_SCN_Affected_N_Port_ID_t)              !=              FC_ELS_SCN_Affected_N_Port_ID_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_SCN_Payload_t)                         !=                         FC_ELS_SCN_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_TPLS_Image_Pair_t)                     !=                     FC_ELS_TPLS_Image_Pair_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_TPLS_Payload_t)                        !=                        FC_ELS_TPLS_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_TPLS_Image_Pair_t)                 !=                 FC_ELS_ACC_TPLS_Image_Pair_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_TPLS_Payload_t)                    !=                    FC_ELS_ACC_TPLS_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_TPRLO_Parm_Page_t)                     !=                     FC_ELS_TPRLO_Parm_Page_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_TPRLO_Payload_t)                       !=                       FC_ELS_TPRLO_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_TPRLO_Payload_t)                   !=                   FC_ELS_ACC_TPRLO_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_Alias_Token_t)                         !=                         FC_ELS_Alias_Token_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_Alias_SP_t)                            !=                            FC_ELS_Alias_SP_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_NP_List_Element_t)                     !=                     FC_ELS_NP_List_Element_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_Alias_ID_t)                            !=                            FC_ELS_Alias_ID_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_GAID_Payload_t)                        !=                        FC_ELS_GAID_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_GAID_Payload_t)                    !=                    FC_ELS_ACC_GAID_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_FACT_Payload_t)                        !=                        FC_ELS_FACT_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_FACT_Payload_t)                    !=                    FC_ELS_ACC_FACT_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_FDACT_Payload_t)                       !=                       FC_ELS_FDACT_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_FDACT_Payload_t)                   !=                   FC_ELS_ACC_FDACT_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_NACT_Payload_t)                        !=                        FC_ELS_NACT_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_NACT_Payload_t)                    !=                    FC_ELS_ACC_NACT_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_NDACT_Payload_t)                       !=                       FC_ELS_NDACT_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_NDACT_Payload_t)                   !=                   FC_ELS_ACC_NDACT_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_QoSR_Payload_t)                        !=                        FC_ELS_QoSR_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_QoSR_Payload_t)                    !=                    FC_ELS_ACC_QoSR_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_RVCS_Payload_t)                        !=                        FC_ELS_RVCS_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_RVCS_Class_4_Status_Block_t)       !=       FC_ELS_ACC_RVCS_Class_4_Status_Block_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_RVCS_Payload_t)                    !=                    FC_ELS_ACC_RVCS_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_PDISC_Payload_t)                       !=                       FC_ELS_PDISC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_PDISC_Payload_t)                   !=                   FC_ELS_ACC_PDISC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_FDISC_Payload_t)                       !=                       FC_ELS_FDISC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_FDISC_Payload_t)                   !=                   FC_ELS_ACC_FDISC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ADISC_Payload_t)                       !=                       FC_ELS_ADISC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_ADISC_Payload_t)                   !=                   FC_ELS_ACC_ADISC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_Payload_t)                         !=                         FC_ELS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_Payload_t)                             !=                             FC_ELS_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_LoopInit_Unknown_Payload_t)            !=            FC_ELS_LoopInit_Unknown_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_LoopInit_Port_Name_Payload_t)          !=          FC_ELS_LoopInit_Port_Name_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_SRR_Payload_t)                         !=          FC_ELS_SRR_Payload_t_SIZE )                to_return++;
    if ( sizeof(FC_ELS_RSS_Payload_t)                         !=          FC_ELS_RSS_Payload_t_SIZE )                to_return++;
    if ( sizeof(FC_ELS_LoopInit_AL_PA_Bit_Map_Payload_t)      !=      FC_ELS_LoopInit_AL_PA_Bit_Map_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t) != FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_CT_IU_HDR_t)                               !=                               FC_CT_IU_HDR_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_Port_Type_t)                            !=                            FC_NS_Port_Type_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_Port_ID_t)                              !=                              FC_NS_Port_ID_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_Control_Port_ID_t)                      !=                      FC_NS_Control_Port_ID_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_Port_Name_t)                            !=                            FC_NS_Port_Name_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_Node_Name_t)                            !=                            FC_NS_Node_Name_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_Symbolic_Port_Name_t)                   !=                   FC_NS_Symbolic_Port_Name_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_Symbolic_Node_Name_t)                   !=                   FC_NS_Symbolic_Node_Name_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_IPA_t)                                  !=                                  FC_NS_IPA_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_IP_Address_t)                           !=                           FC_NS_IP_Address_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_Class_of_Service_t)                     !=                     FC_NS_Class_of_Service_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_FC_4_Type_Code_t)                       !=                       FC_NS_FC_4_Type_Code_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_FC_4_Types_t)                           !=                           FC_NS_FC_4_Types_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GA_NXT_Request_Payload_t)            !=            FC_NS_DU_GA_NXT_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GA_NXT_FS_ACC_Payload_t)             !=             FC_NS_DU_GA_NXT_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GPN_ID_Request_Payload_t)            !=            FC_NS_DU_GPN_ID_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GPN_ID_FS_ACC_Payload_t)             !=             FC_NS_DU_GPN_ID_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GNN_ID_Request_Payload_t)            !=            FC_NS_DU_GNN_ID_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GNN_ID_FS_ACC_Payload_t)             !=             FC_NS_DU_GNN_ID_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GCS_ID_Request_Payload_t)            !=            FC_NS_DU_GCS_ID_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GCS_ID_FS_ACC_Payload_t)             !=             FC_NS_DU_GCS_ID_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GFT_ID_Request_Payload_t)            !=            FC_NS_DU_GFT_ID_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GFT_ID_FS_ACC_Payload_t)             !=             FC_NS_DU_GFT_ID_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GSPN_ID_Request_Payload_t)           !=           FC_NS_DU_GSPN_ID_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GSPN_ID_FS_ACC_Payload_t)            !=            FC_NS_DU_GSPN_ID_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GPT_ID_Request_Payload_t)            !=            FC_NS_DU_GPT_ID_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GPT_ID_FS_ACC_Payload_t)             !=             FC_NS_DU_GPT_ID_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GIPP_ID_Request_Payload_t)           !=           FC_NS_DU_GIPP_ID_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GIPP_ID_FS_ACC_Payload_t)            !=            FC_NS_DU_GIPP_ID_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GID_PN_Request_Payload_t)            !=            FC_NS_DU_GID_PN_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GID_PN_FS_ACC_Payload_t)             !=             FC_NS_DU_GID_PN_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GIPP_PN_Request_Payload_t)           !=           FC_NS_DU_GIPP_PN_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GIPP_PN_FS_ACC_Payload_t)            !=            FC_NS_DU_GIPP_PN_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GID_NN_Request_Payload_t)            !=            FC_NS_DU_GID_NN_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GID_NN_FS_ACC_Payload_t)             !=             FC_NS_DU_GID_NN_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GIP_NN_Request_Payload_t)            !=            FC_NS_DU_GIP_NN_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GIP_NN_FS_ACC_Payload_t)             !=             FC_NS_DU_GIP_NN_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GIPA_NN_Request_Payload_t)           !=           FC_NS_DU_GIPA_NN_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GIPA_NN_FS_ACC_Payload_t)            !=            FC_NS_DU_GIPA_NN_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GSNN_NN_Request_Payload_t)           !=           FC_NS_DU_GSNN_NN_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GSNN_NN_FS_ACC_Payload_t)            !=            FC_NS_DU_GSNN_NN_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GNN_IP_Request_Payload_t)            !=            FC_NS_DU_GNN_IP_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GNN_IP_FS_ACC_Payload_t)             !=             FC_NS_DU_GNN_IP_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GIPA_IP_Request_Payload_t)           !=           FC_NS_DU_GIPA_IP_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GIPA_IP_FS_ACC_Payload_t)            !=            FC_NS_DU_GIPA_IP_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GID_FT_Request_Payload_t)            !=            FC_NS_DU_GID_FT_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GID_FT_FS_ACC_Payload_t)             !=             FC_NS_DU_GID_FT_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GID_PT_Request_Payload_t)            !=            FC_NS_DU_GID_PT_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GID_PT_FS_ACC_Payload_t)             !=             FC_NS_DU_GID_PT_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GID_IPP_Request_Payload_t)           !=           FC_NS_DU_GID_IPP_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GID_IPP_FS_ACC_Payload_t)            !=            FC_NS_DU_GID_IPP_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GPN_IPP_Request_Payload_t)           !=           FC_NS_DU_GPN_IPP_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GPN_IPP_FS_ACC_Payload_t)            !=            FC_NS_DU_GPN_IPP_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_RPN_ID_Payload_t)                    !=                    FC_NS_DU_RPN_ID_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_RNN_ID_Payload_t)                    !=                    FC_NS_DU_RNN_ID_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_RCS_ID_Payload_t)                    !=                    FC_NS_DU_RCS_ID_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_RFT_ID_Payload_t)                    !=                    FC_NS_DU_RFT_ID_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_RSPN_ID_Payload_t)                   !=                   FC_NS_DU_RSPN_ID_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_RPT_ID_Payload_t)                    !=                    FC_NS_DU_RPT_ID_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_RIPP_ID_Payload_t)                   !=                   FC_NS_DU_RIPP_ID_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_RIP_NN_Payload_t)                    !=                    FC_NS_DU_RIP_NN_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_RIPA_NN_Payload_t)                   !=                   FC_NS_DU_RIPA_NN_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_RSNN_NN_Payload_t)                   !=                   FC_NS_DU_RSNN_NN_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_DA_ID_Payload_t)                     !=                     FC_NS_DU_DA_ID_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_FCP_CMND_FcpLun_LEVEL_t)                   !=                   FC_FCP_CMND_FcpLun_LEVEL_t_SIZE ) to_return++;
    if ( sizeof(FC_FCP_CMND_FcpCntl_t)                        !=                        FC_FCP_CMND_FcpCntl_t_SIZE ) to_return++;
    if ( sizeof(FC_FCP_CMND_Payload_t)                        !=                        FC_FCP_CMND_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_FCP_RSP_FCP_STATUS_t)                      !=                      FC_FCP_RSP_FCP_STATUS_t_SIZE ) to_return++;
    if ( sizeof(FC_FCP_RSP_Payload_t)                         !=                         FC_FCP_RSP_Payload_t_SIZE ) to_return++;

    return to_return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\findadap.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Module Name:

    FindAdap.c

Abstract:

    This is the miniport driver for the Agilent
    PCI to Fibre Channel Host Bus Adapter (HBA).

Authors:

    MB - Michael Bessire
    DL - Dennis Lindfors FC Layer support
    IW - Ie Wei Njoo
    LP - Leopold Purwadihardja
    KR - Kanna Rajagopal

Environment:

    kernel mode only

Version Control Information:

    $Archive: /Drivers/Win2000/MSE/OSLayer/C/FINDADAP.C $

Revision History:
    $Revision: 11 $
    $Date: 3/30/01 11:54a $
    $Modtime:: 3/30/01 11:52a          $

Notes:

--*/


#include "buildop.h"
#include "osflags.h"
#include "err_code.h"
#if defined(HP_PCI_HOT_PLUG)
   #include "HotPlug4.h"      // NT 4.0 PCI Hot-Plug header file
#endif


//
// Remove the use of static global, NT50 PnP support.
//

/*
PCARD_EXTENSION hpTLCards [MAX_ADAPTERS];
int hpTLNumCards = 0;   
*/

#ifdef _DEBUG_EVENTLOG_
extern PVOID gDriverObject;
#endif

extern ULONG gMultiMode;
extern ULONG gMaximumTransferLength; 
extern ULONG gGlobalIOTimeout;
extern ULONG gCrashDumping;
extern ULONG hpFcConsoleLevel;

void ScanRegistry(IN PCARD_EXTENSION pCard,PUCHAR param);

/*++

Routine Description:

    This function is called by the OS-specific port driver after
    the necessary storage has been allocated, to gather information
    about the HBA's configuration.

Arguments:

    pCard - HBA miniport driver's adapter data storage
    Context         - address of HwContext value pass in the
                     ScsiPortInitialize routine
    BusInformation  - address of bus-type-specific info that the port driver
                     has gathered
    ArgumentString  - address of a zero-terminated ASCII string
    ConfigInfo      - Configuration information structure describing HBA
    Again           - set to TRUE if the driver can support more than one HBA
                     and we want the ScsiPortxxx driver to call again with a
                     new pCard.

Return Value:

    SP_RETURN_FOUND if HBA present in system
    SP_RETURN_ERROR on error

--*/
ULONG
HPFibreFindAdapter(
    IN PCARD_EXTENSION pCard,
    IN PVOID Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    )
{
    ULONG range;
    ULONG rangeNT;
    PVOID ranges[NUMBER_ACCESS_RANGES];
    ULONG Lengths[NUMBER_ACCESS_RANGES];
    UCHAR IOorMEM[NUMBER_ACCESS_RANGES];
    ULONG cachedMemoryNeeded;
    ULONG cachedMemoryAlign;
    ULONG dmaMemoryNeeded;
    ULONG dmaMemoryPhyAlign;
    ULONG nvMemoryNeeded;
    ULONG usecsPerTick=0;
    ULONG error=FALSE;
    ULONG x;
    ULONG num_access_range =  NUMBER_ACCESS_RANGES;
    ULONG Mem_needed;
    SCSI_PHYSICAL_ADDRESS phys_addr;
    ULONG length;
    agRoot_t *phpRoot;
    ULONG return_value;
    agBOOLEAN cardSupported;
    ULONG dmaMemoryPtrAlign;
    int i;

    //
    //  KC: Cacheline Update
    //
    ULONG SSvID;
    ULONG RetrnWal;
    ULONG pciCfgData[NUM_PCI_CONFIG_DATA_ELEMENTS];
    ULONG bus, device, function;
    PCI_SLOT_NUMBER slotnum;
    ULONG BusStuff;
    ULONG CLine;
    ULONG SecondaryBus;
    ULONG offset;
    USHORT ConfigReg16;
    UCHAR  ConfigReg8;
    ULONG  ConfigReg32;

    #if defined(HP_PCI_HOT_PLUG)
    PHOT_PLUG_CONTEXT pHotPlugContext = (PHOT_PLUG_CONTEXT) Context;
    #endif


    // the following is the AccessRanges[] representation of the PCI
    // configuration registers filled in by the scsiport driver.
    //      0x10: Reserved
    //      0x14: IOBASEL  - AccessRanges[0].RangeStart
    //      0x18: IOBASEU  - AccessRanges[1].RangeStart
    //      0x1C: MEMBASE  - AccessRanges[2].RangeStart
    //
    // Reserved register 0x10 ignored by scsiport driver.
    #ifndef YAM2_1
    osZero (pCard, sizeof(CARD_EXTENSION));
    #else
    osZero (pCard, OSDATA_SIZE);
    #endif

    pCard->signature = 0xfcfc5100;

    *Again = TRUE;
   
    //
    // KC: Cacheline Update
    //
    slotnum.u.AsULONG = 0;

    //
    // Remove the use of static global, NT50 PnP support
    //

    /****
    * For debugging purpose....
    *
    hpTLCards [hpTLNumCards] = pCard;
    hpTLNumCards++; 

    if (hpTLNumCards >= MAX_ADAPTERS)
        *Again = FALSE;
    else
        *Again = TRUE;
        
    osDEBUGPRINT((ALWAYS_PRINT, "&hpTLCards = %x hpTLNumCards = %d pCard = %x\n", 
                        &hpTLCards, hpTLNumCards, pCard));
    */

    osDEBUGPRINT((ALWAYS_PRINT, "HPFibreFindAdapter: IN\n"));

    phpRoot = &pCard->hpRoot;

    pCard->State |= CS_DURING_FINDADAPTER;

    // Initialize osdata
    phpRoot->osData = pCard;
    pCard->AdapterQ.Head = NULL;
    pCard->AdapterQ.Tail = NULL;
    //--LP101000   pCard->TimedOutIO=0;
    pCard->RootSrbExt = NULL;
    pCard->inDriver = FALSE;
    pCard->inTimer = FALSE;
    pCard->ForceTag = TRUE;


    ScsiPortGetBusData(pCard,
                        PCIConfiguration,
                        ConfigInfo->SystemIoBusNumber,
                        ConfigInfo->SlotNumber,
                        &pCard->pciConfigData,
                        PCI_CONFIG_DATA_SIZE);

    //
    // Get the parameter entry "DriverParameters"
    //
    if (ArgumentString) 
    {
        osDEBUGPRINT(( ALWAYS_PRINT,"HPFibreFindAdapter: FindAdapter ArgumentString = (%s)\n", ArgumentString));

        pCard->ArgumentString = ArgumentString;
        
        // Scan and set OSLayer changeble parameter
        ScanRegistry(pCard, ArgumentString);

        #ifdef DBG
        if (gCrashDumping)
        {   
            #ifdef _DEBUG_EVENTLOG_
            gEventLogCount = 0;
            LogLevel = 0;
            #endif

            osDEBUGPRINT(( ALWAYS_PRINT,"FindAdapter: !!!!!!! CRASH DUMP MODE !!!!!!!!!!\n"));        
            gDbgPrintIo = DBGPRINT_HPFibreStartIo|DBGPRINT_START|DBGPRINT_DONE|DBGPRINT_SCSIPORT_RequestComplete|DBGPRINT_SCSIPORT_ScsiportCompleteRequest;
//          hpFcConsoleLevel=0xf;
        }
        #endif
    } // if (ArgumentString) 
    else
        osDEBUGPRINT(( ALWAYS_PRINT,"HPFibreFindAdapter: No Argument String.\n"));

    #if DBG_TRACE
    pCard->traceBufferLen = HP_FC_TRACE_BUFFER_LEN;
    pCard->curTraceBufferPtr = &pCard->traceBuffer[0];
    // Note that traceBuffer was already zeroed in call to zeroing CARD_EXTENSION above.
    #endif

    cardSupported = fcCardSupported (phpRoot);
    if (cardSupported == agFALSE) 
    {
        pCard->State &= ~CS_DURING_FINDADAPTER;
        osDEBUGPRINT((ALWAYS_PRINT, "HPFibreFindAdapter: returning SP_RETURN_NOT_FOUND\n"));
        return SP_RETURN_NOT_FOUND;
    }

    #if DBG > 2
    dump_pCard( pCard);
    #endif

    osDEBUGPRINT(( DMOD,"Num Config Ranges %lx @ %x\n",ConfigInfo->NumberOfAccessRanges, osTimeStamp(0) ));

    pCard->SystemIoBusNumber = ConfigInfo->SystemIoBusNumber;
    pCard->SlotNumber        = ConfigInfo->SlotNumber;

    // Initialize Memory or IO port switch
    IOorMEM[0] = TRUE;
    IOorMEM[1] = TRUE;

    for( range=2; range < NUMBER_ACCESS_RANGES; range++)
    {
        IOorMEM[range] = FALSE;
    }

    for( range=0; range < NUMBER_ACCESS_RANGES; range++)
    {
        ranges[range] = NULL;
        Lengths[range] = 0;
        osDEBUGPRINT(( DMOD,"ranges[%x] = %lx IOorMEM[%x] %x\n",
                    range, ranges[range],range,IOorMEM[range] ));
    }

    for( range=0,rangeNT=0; range < num_access_range; range++,rangeNT++)
    {
        if ((range==3)&&(!osChipConfigReadBit32(phpRoot,0x20)))
        {
            rangeNT -= 1;
            continue;
        }
        if ((range==4)&&(!osChipConfigReadBit32(phpRoot,0x24)))
        {
            rangeNT -= 1;
            continue;
        }
        osDEBUGPRINT(( DMOD,"Before ScsiPortGetDeviceBase %x\n",(*ConfigInfo->AccessRanges)[range].RangeStart));

        // Check if we could safely access the range
        if(ScsiPortValidateRange(pCard,
                        ConfigInfo->AdapterInterfaceType,
                        ConfigInfo->SystemIoBusNumber,
                        (*ConfigInfo->AccessRanges)[rangeNT].RangeStart,
                        (*ConfigInfo->AccessRanges)[rangeNT].RangeLength,
                        IOorMEM[range])) 
        {
            // It is safe to access the range        
            if((ranges[range] = ScsiPortGetDeviceBase(pCard,
                     ConfigInfo->AdapterInterfaceType,
                     ConfigInfo->SystemIoBusNumber,
                     (*ConfigInfo->AccessRanges)[rangeNT].RangeStart,
                     (*ConfigInfo->AccessRanges)[rangeNT].RangeLength,
                     IOorMEM[range])) == pNULL) 
            {
                osDEBUGPRINT(( DMOD,"Get Device Failed ranges[%x] = %lx IOorMEM[%x] %x\n", range, ranges[range],range,IOorMEM[range] ));
                if(range <= 2 ) 
                {
                    error = TRUE;
                    osDEBUGPRINT((ALWAYS_PRINT,"ERROR mapping base address.\n"));
                    // Log error.
                    #ifdef TAKEN_OUT_012100             
                    #ifdef _DvrArch_1_20_
                    osLogString(phpRoot,
                     "%X",               // FS
                     "ERR_MAP_IOLBASE",  // S1
                     0,                  // S2
                     agNULL,agNULL,
                     0,                  // 1
                     0,                  // 2
                     0,                  // 3
                     0,                  // 4
                     SP_INTERNAL_ADAPTER_ERROR, // 5
                     ERR_MAP_IOLBASE,    // 6
                     0,                  // 7
                     0 );                // 8

                    #else /* _DvrArch_1_20_ was not defined */

                    osLogString(phpRoot,
                     "%X",               // FS
                     "ERR_MAP_IOLBASE",  // S1
                     0,                  // S2
                     0,                  // 1
                     0,                  // 2
                     0,                  // 3
                     0,                  // 4
                     SP_INTERNAL_ADAPTER_ERROR, // 5
                     ERR_MAP_IOLBASE,    // 6
                     0,                  // 7
                     0 );                // 8


                    #endif   /* _DvrArch_1_20_ was not defined */
                    #endif
                }
                break;
            }
        }

        // Not safe to access the range
        else
        {
            error = TRUE;
            osDEBUGPRINT((ALWAYS_PRINT,"ScsiPortValidateRange FAILED.\n"));
            // Log error.
            #ifdef TAKEN_OUT_012100             
            #ifdef _DvrArch_1_20_
            osLogString(phpRoot,
                  "%X",             // FS
                  "ERR_VALIDATE_IOLBASE", // S1
                  0,                // S2
                  agNULL,agNULL,
                  0,                // 1
                  0,                // 2
                  0,                // 3
                  0,                // 4
                  SP_INTERNAL_ADAPTER_ERROR, // 5
                  ERR_VALIDATE_IOLBASE,   // 6
                  0,                // 7
                  0 );              // 8
            #else /* _DvrArch_1_20_ was not defined */
            osLogString(phpRoot,
                  "%X",             // FS
                  "ERR_VALIDATE_IOLBASE", // S1
                  0,                // S2
                  0,                // 1
                  0,                // 2
                  0,                // 3
                  0,                // 4
                  SP_INTERNAL_ADAPTER_ERROR, // 5
                  ERR_VALIDATE_IOLBASE,   // 6
                  0,                // 7
                  0 );              // 8
            #endif   /* _DvrArch_1_20_ was not defined */
            #endif
            break;
        }

        osDEBUGPRINT(( DMOD,"ranges[%x] = %lx\n", range, ranges[range]  ));
        Lengths[range] = (*ConfigInfo->AccessRanges)[rangeNT].RangeLength;
    } // for loop

    if (error == TRUE)
        goto error;

    pCard->IoLBase      = ranges[0];
    pCard->IoUpBase     = ranges[1];
    pCard->MemIoBase    = ranges[2];
    pCard->RamBase      = ranges[3];
    pCard->RomBase      = ranges[4];
    pCard->RamLength    = Lengths[3];
    pCard->RomLength    = Lengths[4];

    pCard->AltRomBase = NULL; // this should be filled by reading config space
    pCard->AltRomLength = 0;  // this should be obtained from config space info

    osDEBUGPRINT(( DMOD,"HPFibreFindAdapter: IoLAddrBase   address is %x\n",pCard->IoLBase   ));
    osDEBUGPRINT(( DMOD,"HPFibreFindAdapter: IoUpAddrBase  address is %x\n",pCard->IoUpBase  ));
    osDEBUGPRINT(( DMOD,"HPFibreFindAdapter: MemIoAddrBase address is %x\n",pCard->MemIoBase ));
    osDEBUGPRINT(( DMOD,"HPFibreFindAdapter: RamAddrBase   address is %x\n",pCard->RamBase   ));
    osDEBUGPRINT(( DMOD,"HPFibreFindAdapter: RomAddrBase   address is %x\n",pCard->RomBase   ));

    pCard->cardRomUpper = 0;
    pCard->cardRamUpper = 0;

    pCard->cardRamLower = osChipConfigReadBit32( phpRoot,0x20 );
    pCard->cardRomLower = osChipConfigReadBit32( phpRoot,0x24 );

    // 
    // When on-card-RAM is not present, current TL boards indicate
    // that on-card-RAM is present in the PCI config space.
    // So here test the on-card-RAM.
    //
    if (TestOnCardRam (phpRoot) == FALSE)
        pCard->RamLength = 0;

    pCard->cardRamLower &= 0xFFFFFFF0;
    pCard->cardRomLower &= 0xFFFFFFF0;


    #ifdef __REGISTERFORSHUTDOWN__
    if (gRegisterForShutdown)
    {
        ConfigInfo->CachesData = TRUE;
    }
    #endif


    // FC Layer does not have any alignment restriction.
    ConfigInfo->AlignmentMask = 0x0;

    // indicate bus master support
    ConfigInfo->Master = TRUE;

    // Want to snoop at the buffer
    ConfigInfo->MapBuffers = TRUE;

    // maximum number of Target ID's supported.
    #ifndef YAM2_1
    ConfigInfo->MaximumNumberOfTargets = MAXIMUM_TID;
    #else
    ConfigInfo->MaximumNumberOfTargets = (UCHAR)gMaximumTargetIDs;
    #endif

    // number of FC busses the HBA supports
    // For NT4.0 we will claim we support more than 1 bus to get the scsiport
    // driver to support 4*MAXIMUM_TID=128 target id's. Then map to the
    // appropriate alpa based on the bus, tid and lun requested.

    ConfigInfo->NumberOfBuses = NUMBER_OF_BUSES;

    #if defined(HP_NT50)
    // whisler requires that this param is set to a number, else SP will scan only 9 luns
    ConfigInfo->MaximumNumberOfLogicalUnits = 255;
    if (gCrashDumping)
        ConfigInfo->MaximumNumberOfLogicalUnits = 1;
    #endif

    if (gMaximumTransferLength)
        ConfigInfo->MaximumTransferLength = gMaximumTransferLength;
    //else use the default value that SP set (4GB)
   
    if (gCrashDumping)
    {
        ConfigInfo->MaximumTransferLength = 512;
        ConfigInfo->ScatterGather = FALSE;
        ConfigInfo->NumberOfPhysicalBreaks =0;
    }
    else
    {
    // Indicate maximum number of physical segments.
    // If the port driver sets a value for this member, the miniport driver can 
    // adjust the value to lower but no higher.

    if (    ConfigInfo->NumberOfPhysicalBreaks == SP_UNINITIALIZED_VALUE || 
            ConfigInfo->NumberOfPhysicalBreaks > (osSGL_NUM_ENTRYS - 1))
        ConfigInfo->NumberOfPhysicalBreaks =  osSGL_NUM_ENTRYS - 1;
    ConfigInfo->ScatterGather = TRUE;
    }

    osDEBUGPRINT(( ALWAYS_PRINT,"HPFibreFindAdapter: MaxXLen=%x SGSup=%x PhyBreaks=%x\n",
       ConfigInfo->MaximumTransferLength,
       ConfigInfo->ScatterGather,
       ConfigInfo->NumberOfPhysicalBreaks));

    #if defined(HP_NT50)
    //
    // Check if System supports 64bit DMA  
    //
    if (ConfigInfo->Dma64BitAddresses & SCSI_DMA64_SYSTEM_SUPPORTED ) 
    {
        ConfigInfo->Dma64BitAddresses |= SCSI_DMA64_MINIPORT_SUPPORTED;
    }
    #endif


    for (i = 0; i < NUMBER_OF_BUSES; i++)
        ConfigInfo->InitiatorBusId[i] = (UCHAR) INITIATOR_BUS_ID;

    return_value = fcInitializeDriver (phpRoot,
                                        &cachedMemoryNeeded,
                                        &cachedMemoryAlign,
                                        &dmaMemoryNeeded,
                                        &dmaMemoryPtrAlign,
                                        &dmaMemoryPhyAlign,
                                        &nvMemoryNeeded,
                                        &usecsPerTick);
    if (dmaMemoryPhyAlign < dmaMemoryPtrAlign)
        dmaMemoryPhyAlign = dmaMemoryPtrAlign;

    // IWN, IA-64 need 8 byte aligned
    cachedMemoryAlign = 8;

    pCard->cachedMemoryNeeded =   cachedMemoryNeeded;
    pCard->cachedMemoryAlign  =   cachedMemoryAlign;
    pCard->dmaMemoryNeeded    =   dmaMemoryNeeded;
    pCard->usecsPerTick   =       usecsPerTick;

    osDEBUGPRINT(( ALWAYS_PRINT,"HPFibreFindAdapter: cachedMemoryNeeded %lx Align %lx\n",cachedMemoryNeeded, cachedMemoryAlign));
    osDEBUGPRINT(( ALWAYS_PRINT,"HPFibreFindAdapter: dmaMemoryNeeded    %lx Align %lx\n",dmaMemoryNeeded, dmaMemoryPhyAlign));


    // allocate uncached memory for DMA/shared memory purposes. Only
    // one call to ScsiPortGetUncachedExtension is allowed within the
    // HwFindAdapter routine for each HBA supported and it must occur
    // after the ConfigInfo buffer has been filled out. The
    // ScsiPortGetUncachedExtension returns a virtual address to the
    // uncached extension.

    Mem_needed = OSDATA_UNCACHED_SIZE + cachedMemoryNeeded + cachedMemoryAlign;
    if (pCard->dmaMemoryNeeded) 
    {
        Mem_needed += pCard->dmaMemoryNeeded + dmaMemoryPhyAlign;
    }

    if(gCrashDumping)
    {
        // add space for the local DMA buffer also,
        // for use in startio
        Mem_needed += (8 * 1024) + 0x512; // lets just make it 512 byte aligned.. 
    }

    //if ((pCard->dmaMemoryPtr = ScsiPortGetUncachedExtension(pCard,
    if ((pCard->UncachedMemoryPtr = ScsiPortGetUncachedExtension(pCard,
                                       ConfigInfo,
                                       Mem_needed
                                       )) == NULL) 
    {
         osDEBUGPRINT((ALWAYS_PRINT,"HPFibreFindAdapter: ScsiPortGetUncachedExtension FAILED.\n"));
         // Log error.
        #ifdef TAKEN_OUT_012100             
        #ifdef _DvrArch_1_20_
        osLogString(phpRoot,
                  "%X",                // FS
                  "ERR_UNCACHED_EXTENSION",  // S1
                  0,                   // S2
                  agNULL,agNULL,
                  0,                   // 1
                  0,                   // 2
                  0,                   // 3
                  0,                   // 4
                  SP_INTERNAL_ADAPTER_ERROR, // 5
                  ERR_UNCACHED_EXTENSION,    // 6
                  0,                   // 7
                  0 );                 // 8
        #else /* _DvrArch_1_20_ was not defined */
        osLogString(phpRoot,
                  "%X",                // FS
                  "ERR_UNCACHED_EXTENSION",  // S1
                  0,                   // S2
                  0,                   // 1
                  0,                   // 2
                  0,                   // 3
                  0,                   // 4
                  SP_INTERNAL_ADAPTER_ERROR, // 5
                  ERR_UNCACHED_EXTENSION,    // 6
                  0,                   // 7
                  0 );                 // 8
        #endif   /* _DvrArch_1_20_ was not defined */
        #endif
        goto error;
      
    }

    osDEBUGPRINT(( ALWAYS_PRINT,"HPFibreFindAdapter: pCard->dmaMemoryPtr is %x needed = %x\n",pCard->dmaMemoryPtr,Mem_needed));

    //  Moved all 
    pCard->Dev = (DEVICE_ARRAY *)( ((char *)pCard->UncachedMemoryPtr) + PADEV_OFFSET);
    pCard->hpFCDev = (agFCDev_t*) ( ((char *)pCard->UncachedMemoryPtr) + FCDEV_OFFSET );
    pCard->nodeInfo = (NODE_INFO*) ( ((char *)pCard->UncachedMemoryPtr) + FCNODE_INFO_OFFSET);
    #ifdef _DEBUG_EVENTLOG_
    pCard->Events = (EVENTLOG_BUFFER*)( ((char*)pCard->UncachedMemoryPtr)+ EVENTLOG_OFFSET);
    #endif
    pCard->cachedMemoryPtr = (PULONG) ((PUCHAR)pCard->UncachedMemoryPtr+CACHE_OFFSET);
   
    #if defined(HP_NT50)
    //WIN64 compliant
    pCard->cachedMemoryPtr = 
        (PULONG) ( ((UINT_PTR)pCard->cachedMemoryPtr + (UINT_PTR)cachedMemoryAlign - 1) & 
                (~((UINT_PTR)cachedMemoryAlign - 1)));
    #else
    pCard->cachedMemoryPtr =  
        (PULONG) (((ULONG)pCard->cachedMemoryPtr +cachedMemoryAlign - 1) & (~(cachedMemoryAlign - 1)));
    #endif

    if (pCard->dmaMemoryNeeded) 
    {
        pCard->dmaMemoryPtr = (PULONG) (((char *)pCard->cachedMemoryPtr) + cachedMemoryNeeded + cachedMemoryAlign);

    
        phys_addr = ScsiPortGetPhysicalAddress(pCard,
                                         NULL, // only for uncached extension
                                         pCard->dmaMemoryPtr,
                                         &length);

        pCard->dmaMemoryUpper32 = phys_addr.HighPart;
        pCard->dmaMemoryLower32 = phys_addr.LowPart;

        osDEBUGPRINT(( ALWAYS_PRINT,"Before Ptr %lx pCard->dmaMemoryUpper32 is %lx Lower %lx Length %x Needed %x\n",
            pCard->dmaMemoryPtr,
            pCard->dmaMemoryUpper32,
            pCard->dmaMemoryLower32,
            length,
            pCard->dmaMemoryNeeded+dmaMemoryPhyAlign));

        Mem_needed = pCard->dmaMemoryLower32 & (dmaMemoryPhyAlign -1) ;
        Mem_needed = dmaMemoryPhyAlign - Mem_needed;
        pCard->dmaMemoryLower32 += Mem_needed;
        pCard->dmaMemoryPtr = (ULONG *)((UCHAR *)pCard->dmaMemoryPtr+Mem_needed);

        osDEBUGPRINT(( ALWAYS_PRINT,"New Ptr %lx  pCard->dmaMemoryUpper32 is %lx Lower %lx Length %x Needed %x\n",
            pCard->dmaMemoryPtr,
            pCard->dmaMemoryUpper32,
            pCard->dmaMemoryLower32,
            length,
            pCard->dmaMemoryNeeded ));
    }
    
    osDEBUGPRINT((ALWAYS_PRINT,"HPFibreFindAdapter: Dev = %x  hpFCDev = %x  nodeInfo  = %x  dma = %x  cachedMemoryPtr = %lx\n",
                                pCard->Dev,
                                pCard->hpFCDev,
                                pCard->nodeInfo,
                                pCard->dmaMemoryPtr,
                                pCard->cachedMemoryPtr));

    #ifdef DBG
    {
        ULONG       xx;
        PA_DEVICE   *dbgPaDev;
        char        *dbgTemp;
        agFCDev_t   *dbgFcDev;
        NODE_INFO   *dbgNodeInfo;

        osDEBUGPRINT((ALWAYS_PRINT,"HPFibreFindAdapter: DEV_ARRAY_SIZE=%x  PADEV_SIZE=%x  FCDEV_SIZE=%x  FCNODE_INFO_SIZE=%x  EVENTLOG_SIZE=%x  OSDATA_SIZE=%x  OSDATA_UNCACHED_SIZE=%x\n",
            DEV_ARRAY_SIZE,
            PADEV_SIZE,
            FCDEV_SIZE,
            FCNODE_INFO_SIZE, 
            EVENTLOG_SIZE,
            OSDATA_SIZE,
            OSDATA_UNCACHED_SIZE));


        osDEBUGPRINT((ALWAYS_PRINT,"HPFibreFindAdapter: PADEV_OFFSET=%x  FCDEV_OFFSET=%x  FCNODE_INFO_OFFSET=%x  EVENTLOG_OFFSET=%x  CACHE_OFFSET=%x\n",
            PADEV_OFFSET,
            FCDEV_OFFSET,
            FCNODE_INFO_OFFSET,
            EVENTLOG_OFFSET, 
            CACHE_OFFSET));

        /* Count the Devices */
        dbgPaDev = pCard->Dev->PaDevice; 
        dbgTemp = (char*)dbgPaDev;
        for (xx=0;xx < gMaxPaDevices;xx++)
            dbgPaDev++;
        
        osDEBUGPRINT((ALWAYS_PRINT,"HPFibreFindAdapter: Dev=%x  Dev->PaDev[0]=%x  Dev->PaDev[%d]=%x\n",
                                pCard->Dev,
                                dbgTemp,
                                gMaxPaDevices,
                                dbgPaDev));
        
        dbgFcDev = pCard->hpFCDev;
        for (xx=0;xx < gMaxPaDevices;xx++)
            dbgFcDev++;

        osDEBUGPRINT((ALWAYS_PRINT,"HPFibreFindAdapter: hpFCDev[0]=%x  hpFCDev[%d]=%x\n",
                                pCard->hpFCDev,
                                gMaxPaDevices,
                                dbgFcDev));

        dbgNodeInfo = pCard->nodeInfo;
        for (xx=0;xx < gMaxPaDevices;xx++)
            dbgNodeInfo++;
        
        osDEBUGPRINT((ALWAYS_PRINT,"HPFibreFindAdapter: nodeInfo[0]=%x  nodeInfo[%d]=%x  cachedMemoryPtr=%x\n",
                                pCard->nodeInfo,
                                gMaxPaDevices,
                                dbgNodeInfo,
                                pCard->cachedMemoryPtr));
    }
    #endif

    if (gCrashDumping)
    {
        // grab the local DMA buffer and align it..
        pCard->localDataBuffer = (PULONG)((PUCHAR)pCard->dmaMemoryPtr + pCard->dmaMemoryNeeded + dmaMemoryPhyAlign);
        phys_addr = ScsiPortGetPhysicalAddress(pCard,
                                         NULL, // only for uncached extension
                                         pCard->localDataBuffer,
                                         &length);
        Mem_needed = phys_addr.LowPart & (0x512 - 1) ;
        Mem_needed = (0x512 - 1) - Mem_needed;
        pCard->localDataBuffer = (PULONG)((PUCHAR)pCard->localDataBuffer + Mem_needed);
        osDEBUGPRINT((ALWAYS_PRINT,"HPFibreFindAdapter: localDataBuffer = %x\n", pCard->localDataBuffer));
    }

    // fill in queue ptrs that are aligned on the size of queue
    // within the buffers.

    // initialize the PCI registers (ie. bus master,parity error response, etc)
    // NT enables the PCI configuration command register to 0x0117.
    // InitPCIRegisters(pCard, ConfigInfo);

    // set this to true for each HBA installed.
    pCard->IsFirstTime = TRUE;

    // for the first time through indicate reset type required. It appears
    // a hard reset is required if the NT system is rebooted without a reset
    // or power cycle for initialization to properly occur.
    pCard->ResetType = HARD_RESET;

    // set pointer to ConfigInfo. Used to call InitPCIRegisters().
    // pCard->pConfigInfo = ConfigInfo;

    // set status to not logged in
    // InitLunExtensions(pCard);

    #if DBG > 2
    dump_pCard( pCard);
    #endif

    osDEBUGPRINT(( DLOW,"HPFibreFindAdapter: SP_RETURN_FOUND\n"));

    pCard->State &= ~CS_DURING_FINDADAPTER;

    //----------------------------------------------------------------------------
    #if defined(HP_PCI_HOT_PLUG)
    //
    // Load pointer to pCard in PSUEDO table for PCI Hot Plug option.
    //
    pHotPlugContext->extensions[0] += 1;      // Number of HBAs.
    pHotPlugContext->extensions[pHotPlugContext->extensions[0]] = (ULONG) pCard;
    //
    // Set the required fields for the PCI Hot Plug support.
    //
    pCard->rcmcData.numAccessRanges = (UCHAR)rangeNT;     // Save # of PCI access ranges used
    pCard->rcmcData.accessRangeLength[0]= 0x100; // I/O base address lo
    pCard->rcmcData.accessRangeLength[1]= 0x100; // I/O base address upper
    pCard->rcmcData.accessRangeLength[2]= 0x200; // Mem base address
    if (pCard->RamLength != 0 )
    {
        pCard->rcmcData.accessRangeLength[3] = pCard->RamLength;
        if (pCard->RomLength !=0 )
            pCard->rcmcData.accessRangeLength[4] = pCard->RomLength;
    }
    else 
        if (pCard->RomLength !=0 )
            pCard->rcmcData.accessRangeLength[3]= pCard->RomLength;

    #endif
    //----------------------------------------------------------------------------

    #ifdef YAM2_1
    InitializeDeviceTable(pCard);
    #endif
   
    #ifdef _DEBUG_EVENTLOG_
    {
        ULONG    ix;

        pCard->EventLogBufferIndex = MAX_CARDS_SUPPORTED;        /* initialize it */
   
        ix = AllocEventLogBuffer(gDriverObject, (PVOID) pCard);
        if (ix < MAX_CARDS_SUPPORTED)
        {
            pCard->EventLogBufferIndex = ix;                      /* store it */
            StartEventLogTimer(gDriverObject,pCard);
        }
    }
    #endif
    return SP_RETURN_FOUND;


error:
    for (range=0; range <  num_access_range; range++) 
    {
        if (ranges[range])
            ScsiPortFreeDeviceBase(pCard, ranges[range]);
    }

    *Again = FALSE;
    pCard->State &= ~CS_DURING_FINDADAPTER;
    osDEBUGPRINT((ALWAYS_PRINT, "HPFibreFindAdapter: returning SP_RETURN_ERROR\n"));
    return SP_RETURN_ERROR;

} // end HPFibreFindAdapter()

/*++

Routine Description:

    Tests on-card-RAM.

Arguments:

    hpRoot - HBA miniport driver's data adapter storage

Return Value:

    TRUE:  If the on-card-RAM test is successful
    FALSE: If the on-card-RAM test fails

--*/

int
TestOnCardRam (agRoot_t *hpRoot)
{
    PCARD_EXTENSION pCard = (PCARD_EXTENSION)hpRoot->osData;
    ULONG           x;

    for (x = 0; x < pCard->RamLength; x = x + 4) 
    {
        osCardRamWriteBit32 (hpRoot, x, 0x55aa55aa);
        if (osCardRamReadBit32 (hpRoot, x) != 0x55aa55aa) 
        {
            osDEBUGPRINT((ALWAYS_PRINT, "TestOnCardRam: ON-CARD-RAM test failed\n"));
            return FALSE;
        }

        osCardRamWriteBit32 (hpRoot, x, 0xaa55aa55);
        if (osCardRamReadBit32 (hpRoot, x) != 0xaa55aa55) 
        {
            osDEBUGPRINT((ALWAYS_PRINT, "TestOnCardRam: ON-CARD-RAM test failed\n"));
            return FALSE;
        }
    }

    return TRUE;
}


void ScanRegistry(IN PCARD_EXTENSION pCard, PUCHAR param)
{
    gRegisterForShutdown =      GetDriverParameter(  "RegisterForShutdown", gRegisterForShutdown, 0, 2, param) ;
    osDEBUGPRINT((ALWAYS_PRINT, "ScanRegistry: RegisterForShutdown=%x\n",gRegisterForShutdown));

    gRegSetting.PaPathIdWidth = GetDriverParameter(  "PaPathIdWidth", DEFAULT_PaPathIdWidth,0,8,param);
    osDEBUGPRINT((ALWAYS_PRINT, "ScanRegistry: gRegSetting.PaPathIdWidth=%x\n",gRegSetting.PaPathIdWidth));

    gRegSetting.VoPathIdWidth = GetDriverParameter(  "VoPathIdWidth",DEFAULT_VoPathIdWidth,0,8,param);
    osDEBUGPRINT((ALWAYS_PRINT, "ScanRegistry: gRegSetting.VoPathIdWidth=%x\n",gRegSetting.VoPathIdWidth));
    
    gRegSetting.LuPathIdWidth = GetDriverParameter(  "LuPathIdWidth",DEFAULT_LuPathIdWidth,0,8,param);
    osDEBUGPRINT((ALWAYS_PRINT, "ScanRegistry: gRegSetting.LuPathIdWidth=%x\n",gRegSetting.LuPathIdWidth));
    
    gRegSetting.MaximumTids =   GetDriverParameter(  "MaximumTids",gRegSetting.MaximumTids,8,gMaximumTargetIDs,param);
    osDEBUGPRINT((ALWAYS_PRINT, "ScanRegistry: gRegSetting.MaximumTids=%x\n",gRegSetting.MaximumTids));
    
    gRegSetting.LuTargetWidth = GetDriverParameter(  "LuTargetWidth",DEFAULT_LuTargetWidth,8,32,param);
    osDEBUGPRINT((ALWAYS_PRINT, "ScanRegistry: gRegSetting.LuTargetWidth=%x\n",gRegSetting.LuTargetWidth));
    
    gGlobalIOTimeout =          GetDriverParameter(  "GlobalIOTimeout",gGlobalIOTimeout,0,20, param);
    osDEBUGPRINT((ALWAYS_PRINT, "ScanRegistry: gGlobalIOTimeout=%x\n",gGlobalIOTimeout));
    
    gEnablePseudoDevice =       GetDriverParameter(  "EnablePseudoDevice",gEnablePseudoDevice,0,1,param);
    osDEBUGPRINT((ALWAYS_PRINT, "ScanRegistry: gEnablePseudoDevice=%x\n",gEnablePseudoDevice));
    
    gMaximumTransferLength =    GetDriverParameter(  "MaximumTransferLength",gMaximumTransferLength,0,-1,param);
    osDEBUGPRINT((ALWAYS_PRINT, "ScanRegistry: gMaximumTransferLength=%x\n",gMaximumTransferLength));
    
    gCrashDumping = ( GetDriverParameter("dump", 0, 0, 1, param) || 
                        GetDriverParameter("ntldr", 0, 0, 1, param) );  
    
    pCard->ForceTag = GetDriverParameter("ForceTag",pCard->ForceTag,0,1, param);
    osDEBUGPRINT((ALWAYS_PRINT, "ScanRegistry: pCard->ForceTag=%x\n",pCard->ForceTag));

    #ifdef DBGPRINT_IO
    gDbgPrintIo =    GetDriverParameter(  "DbgPrintIo",gDbgPrintIo,0,-1,param);
    osDEBUGPRINT((ALWAYS_PRINT, "ScanRegistry: gDbgPrintIo=%x\n",gDbgPrintIo));
    #endif

	gMultiMode = GetDriverParameter("MultiMode", gMultiMode, 0,1, param);
    osDEBUGPRINT((ALWAYS_PRINT, "ScanRegistry: gMultiMode=%x\n",gMultiMode));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\fmtfill.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/FmtFill.H $

  $Revision: 2 $
      $Date: 3/20/01 3:36p $ (Last Check-In)
   $Modtime:: 8/14/00 6:45p   $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures used by ../C/FmtFill.C

--*/

#ifndef __FmtFill_H__

#define __FmtFill_H__

#ifdef _DvrArch_1_20_
/*+

  agFmtBitXXMaxWidth defines the maximum width supported for each numeric
  format specifier (i.e. 'b', 'o', 'd', 'x', 'X').  For the extreme case
  where the format specifier is 'b' (binary), there are no more than 32
  digits in the binary representation of a os_bit32.  Hence, it is recommended
  that agFmtBitXXMaxWidth be set to 32 - certainly no less than 32.

  The pointer format specifiers ('p' and 'P') are assumed to require no more
  digits than any of the numeric format specifiers mentioned above.  Given
  that pointer formatting is only supported with hex digits, using a value
  of 32 for agFmtBitXXMaxWidth will support 128-bit pointers - certainly beyond
  the needs of any implementation today and in the forseeable future.
  
  Note that string format specifiers ('s') are not limited in width other than
  by the overall length of the target/output string.

-*/

#define agFmtBitXXMaxWidth 32
#else  /* _DvrArch_1_20_ was not defined */
#define hpFmtBitXXMaxWidth 32
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 agFmtFill(
                             char     *targetString,
                             os_bit32  targetLen,
                             char     *formatString,
                             char     *firstString,
                             char     *secondString,
                             void     *firstPtr,
                             void     *secondPtr,
                             os_bit32  firstBit32,
                             os_bit32  secondBit32,
                             os_bit32  thirdBit32,
                             os_bit32  fourthBit32,
                             os_bit32  fifthBit32,
                             os_bit32  sixthBit32,
                             os_bit32  seventhBit32,
                             os_bit32  eighthBit32
                           );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 hpFmtFill(
                        char  *targetString,
                        bit32  targetLen,
                        char  *formatString,
                        char  *firstString,
                        char  *secondString,
                        bit32  firstBit32,
                        bit32  secondBit32,
                        bit32  thirdBit32,
                        bit32  fourthBit32,
                        bit32  fifthBit32,
                        bit32  sixthBit32,
                        bit32  seventhBit32,
                        bit32  eighthBit32
                      );
#endif /* _DvrArch_1_20_ was not defined */

#endif  /* __FmtFill_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\fmtfill.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/FmtFill.C $

  $Revision: 2 $
      $Date: 3/20/01 3:36p $ (Last Check-In)
   $Modtime:: 9/18/00 1:04p   $ (Last Modified)

Purpose:

  This file implements functions to fill in a
  buffer based on ANSI-style format specifiers.

--*/
#ifndef _New_Header_file_Layout_
#include "../h/globals.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#endif  /* _New_Header_file_Layout_ */

/*+

   Function: agFmtFill_Single()

    Purpose: Implements the logic to substitute one String, Pointer, or Bit32
             for a format specifier.  At entry, the percent-sign ('%') which
             begins a format specifier has already been "consumed".  The
             remainder of the format specifier needs to be parsed and the
             appropriate value substituted into targetString.

  Called By: agFmtFill_From_Arrays()

      Calls: <none>

-*/

#ifdef _DvrArch_1_20_
osLOCAL void agFmtFill_Single(
                               char      *targetString,
                               os_bit32   targetLen,
                               char      *formatString,
                               char      *stringToFormat,
                               os_bitptr  bitptrToFormat,
                               os_bit32   bit32ToFormat,
                               os_bit32  *targetStringProduced,
                               os_bit32  *formatStringConsumed,
                               os_bit32  *stringsConsumed,
                               os_bit32  *bitptrsConsumed,
                               os_bit32  *bit32sConsumed
                           )
#else  /* _DvrArch_1_20_ was not defined */
LOCAL void hpFmtFill_Single(
                             char  *targetString,
                             bit32  targetLen,
                             char  *formatString,
                             char  *stringToFormat,
                             bit32  bit32ToFormat,
                             bit32 *targetStringProduced,
                             bit32 *formatStringConsumed,
                             bit32 *stringsConsumed,
                             bit32 *bit32sConsumed
                           )
#endif /* _DvrArch_1_20_ was not defined */
{
#ifdef _DvrArch_1_20_
    char     c;
    os_bit32 fmtWidth                        = 0;
    os_bit32 fmtBase;
    os_bit32 formatPos                       = 0;
    char     fillChar                        = ' ';
    os_bit32 charIncBelow10                  = '0';
    os_bit32 charIncAbove9                   = 0;
    os_bit32 digit;
    os_bit32 digits                          = 0;
    char     digitStore[agFmtBitXXMaxWidth];
    os_bit32 chars                           = 0;
#else  /* _DvrArch_1_20_ was not defined */
    char  c;
    bit32 fmtWidth                        = 0;
    bit32 fmtBase;
    bit32 formatPos                       = 0;
    char  fillChar                        = ' ';
    bit32 charIncBelow10                  = '0';
    bit32 charIncAbove9                   = 0;  
    bit32 digit;
    bit32 digits                          = 0;
    char  digitStore[hpFmtBitXXMaxWidth];
    bit32 chars                           = 0;
#endif /* _DvrArch_1_20_ was not defined */

    /* The five return-values initialized below will indicate to the caller how */
    /*   many "units" of each type were consumed or produced during this call.  */
    /* TargetString characters are produced - as many as are needed to format   */
    /*   the String, Pointer, or Bit32 (not to exceed the format specifier's    */
    /*   requested width nor the capacity of TargetString.                      */
    /* FormatString characters are consumed - only up to the last character of  */
    /*   the current format specifier.                                          */
    /* Exactly one String, Pointer, or Bit32 will be consumed.                  */

    *targetStringProduced = 0;
    *formatStringConsumed = 0;
    *stringsConsumed      = 0;
#ifdef _DvrArch_1_20_
    *bitptrsConsumed      = 0;
#endif /* _DvrArch_1_20_ was defined */
    *bit32sConsumed       = 0;

    /* Note that this function assumes the leading '%' has already been eaten */

    if ((c = formatString[0]) == '0')
    {
        /* Zero-fill numerics (on the left) of format specifier begins '%0' */

        fillChar = '0';
        formatPos++;
    }

    /* Fetch format specifier's requested width */

    while (((c = formatString[formatPos++]) >= '0') &&
           (c <= '9'))
    {
        fmtWidth = (fmtWidth * 10) + (c - '0');
    }

    /* While statement above existed once it read "past" fmtWidth   */
    /*   Hence, c contains the Data Type to insert in TargetString. */

    switch (c)
    {
    case '%':
        /* If we get here, the format specifier is for a percent-sign ('%')      */
        /*   (i.e. Caller simply wants a percent-sign inserted in TargetString). */

        if (fillChar == '0')
        {
            /* Zero-filled percent-signs are not allowed */

            return;
        }

        if (fmtWidth != 0)
        {
            /* Field Width for percent-signs are not allowed */

            return;
        }

        if (1 > targetLen)
        {
            /* If we get here, there wasn't enough room in targetString */

            return;
        }

        *targetString = '%';       /* Place percent-sign ('%') in TargetString */

        *targetStringProduced = 1; /* Only produced a single character         */
        *formatStringConsumed = 1; /* Only consumed the (second) percent-sign  */

        return;
    case 's':
        /* If we get here, the format specifier is for a String */

        if (fillChar == '0')
        {
            /* Zero-filled strings are not allowed */

            return;
        }

        /* Copy String to TargetString - not to exceed fmtWidth or targetLen */

        while ((c = *stringToFormat++) != '\0')
        {
            *targetString++ = c;
            chars++;

            if ((chars == fmtWidth) ||
                (chars == targetLen))
            {
                break;
            }
        }

        /* Pad TargetString with fillChar (spaces) if           */
        /*   fmtWidth was specified and not yet fully consumed. */

        while ((chars < fmtWidth) &&
               (chars < targetLen))
        {
            *targetString++ = fillChar;
            chars++;
        }

        *targetStringProduced = chars;     /* Indicate how many chars were inserted in TargetString       */
        *formatStringConsumed = formatPos; /* formatPos indicates how many chars were in format specifier */

        *stringsConsumed      = 1;         /* String format specifier consumes exactly one String         */

        return;
#ifdef _DvrArch_1_20_
    case 'p':
    case 'P':
        /* If we get here, the format specifier is for a Pointer */

        fmtBase = 16;

        if (c == 'p')
        {
            charIncAbove9 = 'a' - 10;
        }
        else /* c == 'P' */
        {
            charIncAbove9 = 'A' - 10;
        }

        if (fmtWidth > agFmtBitXXMaxWidth)
        {
            /* If we get here, the format specifier was malformed */

            return;
        }

        /* Fill digitStore[] with hex digits computed using modulo arithmetic - low order digit first */

        while (bitptrToFormat != 0)
        {
            digit          = (os_bit32)(bitptrToFormat % fmtBase);
            bitptrToFormat = bitptrToFormat / fmtBase;

            digitStore[digits++] = (digit < 10 ? (char)(digit + charIncBelow10) : (char)(digit + charIncAbove9));

            if (digits > agFmtBitXXMaxWidth)
            {
                /* If we get here, there wasn't enough room in digitStore[] */

#ifdef _DvrArch_1_20_
                /* This should never happen for Bit32's
                   so long as agFmtBitXXMaxWidth >= 32  */
#else  /* _DvrArch_1_20_ was not defined */
                /* This should never happen for Bit32's
                   so long as hpFmtBitXXMaxWidth >= 32  */
#endif /* _DvrArch_1_20_ was not defined */

                return;
            }
        }

        if (digits == 0)
        {
            /* Special case - display 'agNULL' as value of pointer (with a space "fillChar") */

            digitStore[5] = 'a'; /* digitStore is read backwards, so 'agNULL' must be inserted backwards */
            digitStore[4] = 'g';
            digitStore[3] = 'N';
            digitStore[2] = 'U';
            digitStore[1] = 'L';
            digitStore[0] = 'L';

            digits        = 6;

            fillChar      = ' ';
        }

        /* Use fmtWidth if supplied, otherwise use minimum required (i.e. what was used in digitStore[]) */

        fmtWidth = (fmtWidth == 0 ? digits : fmtWidth);

        if (digits > fmtWidth)
        {
            /* If we get here, there wasn't enough room in fmtWidth */

            return;
        }

        if (fmtWidth > targetLen)
        {
            /* If we get here, there wasn't enough room in targetString */

            return;
        }

        for (digit = fmtWidth;
             digit > digits;
             digit--)
        {
            *targetString++ = fillChar;
        }

        while (digit > 0)
        {
            *targetString++ = digitStore[--digit];
        }

        *targetStringProduced = fmtWidth;  /* Indicate how many chars were inserted in TargetString       */
        *formatStringConsumed = formatPos; /* formatPos indicates how many chars were in format specifier */

        *bitptrsConsumed      = 1;         /* Pointer format specifier consumes exactly one Pointer       */

        return;
#endif /* _DvrArch_1_20_ was defined */
    case 'b':
        fmtBase = 2;
        break;
    case 'o':
        fmtBase = 8;
        break;
    case 'd':
        fmtBase = 10;
        break;
    case 'x':
        fmtBase = 16;
        charIncAbove9 = 'a' - 10;
        break;
    case 'X':
        fmtBase = 16;
        charIncAbove9 = 'A' - 10;
        break;
    case '\0':
    default:
        /* If we get here, the format specifier was malformed */

        return;
    }

    /* If we get here, the format specifier is for a Bit32 */

#ifdef _DvrArch_1_20_
    if (fmtWidth > agFmtBitXXMaxWidth)
#else  /* _DvrArch_1_20_ was not defined */
    if (fmtWidth > hpFmtBitXXMaxWidth)
#endif /* _DvrArch_1_20_ was not defined */
    {
        /* If we get here, the format specifier was malformed */

        return;
    }

    /* Fill digitStore[] with digits in the requested fmtBase     */
    /*   computed using modulo arithmetic - low order digit first */

    while (bit32ToFormat != 0)
    {
        digit         = bit32ToFormat % fmtBase;
        bit32ToFormat = bit32ToFormat / fmtBase;

        digitStore[digits++] = (digit < 10 ? (char)(digit + charIncBelow10) :(char)( digit + charIncAbove9));

#ifdef _DvrArch_1_20_
        if (digits > agFmtBitXXMaxWidth)
#else  /* _DvrArch_1_20_ was not defined */
        if (digits > hpFmtBitXXMaxWidth)
#endif /* _DvrArch_1_20_ was not defined */
        {
            /* If we get here, there wasn't enough room in digitStore[] */

#ifdef _DvrArch_1_20_
            /* This should never happen for Bit32's
               so long as agFmtBitXXMaxWidth >= 32  */
#else  /* _DvrArch_1_20_ was not defined */
            /* This should never happen for Bit32's
               so long as hpFmtBitXXMaxWidth >= 32  */
#endif /* _DvrArch_1_20_ was not defined */

            return;
        }
    }

    if (digits == 0)
    {
        digitStore[0] = '0';
        digits        = 1;
    }

    /* Use fmtWidth if supplied, otherwise use minimum required (i.e. what was used in digitStore[]) */

    fmtWidth = (fmtWidth == 0 ? digits : fmtWidth);

    if (digits > fmtWidth)
    {
        /* If we get here, there wasn't enough room in fmtWidth */

        return;
    }

    if (fmtWidth > targetLen)
    {
        /* If we get here, there wasn't enough room in targetString */

        return;
    }

    for (digit = fmtWidth;
         digit > digits;
         digit--)
    {
        *targetString++ = fillChar;
    }

    while (digit > 0)
    {
        *targetString++ = digitStore[--digit];
    }

    *targetStringProduced = fmtWidth;  /* Indicate how many chars were inserted in TargetString       */
    *formatStringConsumed = formatPos; /* formatPos indicates how many chars were in format specifier */

    *bit32sConsumed       = 1;         /* Bit32 format specifier consumes exactly one Bit32           */

    return;
}

/*+

   Function: agFmtFill_From_Arrays()

    Purpose: To enable looping, agFmtFill() has assembled arrays to hold the
             Strings, Pointers, and Bit32s which were passed in.  This way,
             loop indexes can simply advance as each data type is consumed as
             requested by format specifiers in formatString.

  Called By: agFmtFill()

      Calls: agFmtFill_Single()

-*/

#ifdef _DvrArch_1_20_
osLOCAL os_bit32 agFmtFill_From_Arrays(
                                        char       *targetString,
                                        os_bit32    targetLen,
                                        char       *formatString,
                                        char      **stringArray,
                                        os_bitptr  *bitptrArray,
                                        os_bit32   *bit32Array
                                      )
#else  /* _DvrArch_1_20_ was not defined */
LOCAL bit32 hpFmtFill_From_Arrays(
                                   char   *targetString,
                                   bit32   targetLen,
                                   char   *formatString,
                                   char  **stringArray,
                                   bit32  *bit32Array
                                 )
#endif /* _DvrArch_1_20_ was not defined */
{
#ifdef _DvrArch_1_20_
    os_bit32 bytesCopied = 0;
    os_bit32 targetStringProduced;
    os_bit32 formatStringConsumed;
    os_bit32 stringsConsumed;
    os_bit32 bitptrsConsumed;
    os_bit32 bit32sConsumed;
    char     c;
#else  /* _DvrArch_1_20_ was not defined */
    bit32 bytesCopied = 0;
    bit32 targetStringProduced;
    bit32 formatStringConsumed;
    bit32 stringsConsumed;
    bit32 bit32sConsumed;
    char  c;
#endif /* _DvrArch_1_20_ was not defined */

    /* Scan formatString until formatString exhaused or targetString is full */

    while (((c = *formatString++) != '\0') &&
           (bytesCopied < targetLen) )
    {
        if (c == '%')
        {
        /* Found a format specifier                                                       */

        /* Call agFmtFill_Single() to substitute the desired String, Pointer, or Bit32    */
        /*   for the format specifier.  Note that agFmtFill_Single() will "consume" the   */
        /*   corresponding array element as well as the remainder of the format specifier */
        /*   in the formatString.                                                         */

#ifdef _DvrArch_1_20_
            agFmtFill_Single(
#else  /* _DvrArch_1_20_ was not defined */
            hpFmtFill_Single(
#endif /* _DvrArch_1_20_ was not defined */
                              targetString,
                              (targetLen - bytesCopied),
                              formatString,
                              *stringArray,
#ifdef _DvrArch_1_20_
                              *bitptrArray,
#endif /* _DvrArch_1_20_ was defined */
                              *bit32Array,
                              &targetStringProduced,
                              &formatStringConsumed,
                              &stringsConsumed,
#ifdef _DvrArch_1_20_
                              &bitptrsConsumed,
#endif /* _DvrArch_1_20_ was defined */
                              &bit32sConsumed
                            );

            formatString += formatStringConsumed;
            targetString += targetStringProduced;
            bytesCopied  += targetStringProduced;
            stringArray  += stringsConsumed;
#ifdef _DvrArch_1_20_
            bitptrArray  += bitptrsConsumed,
#endif /* _DvrArch_1_20_ was defined */
            bit32Array   += bit32sConsumed;
        }
        else
        {
            /* Current character does not start a formatSpecifier - simply copy to targetString */

            *targetString++ = c;
            bytesCopied++;
        }
    }

    /* Terminate string with NULL character if their is room */

    if (bytesCopied < targetLen)
    {
        *targetString = '\0';
    }

    return bytesCopied;
}

#ifdef _DvrArch_1_20_
osLOCAL char      *agFmtFill_NULL_formatString = "agFmtFill(): formatString was NULL";
osLOCAL char      *agFmtFill_NULL_firstString  = "NULL 1st String";
osLOCAL char      *agFmtFill_NULL_secondString = "NULL 2nd String";
#endif /* _DvrArch_1_20_ was defined */

/*+

   Function: agFmtFill()

    Purpose: This function is called to format a string containing up to two
             character strings, two void pointers, and eight Bit32s in the
             manner of the LibC function sprintf().  The first two arguments
             describe the buffer to receive the formatted string.  The formatString
             is the required format string.  Subsequent arguments are required and
             must be either character string pointers, void pointers, or 32-bit
             entities.  Note that the strings are inserted as requested by "%s"
             format specifiers, the pointers are inserted as requested by "%p"
             and "%P" format specifiers, and the Bit32s are inserted as requested
             by numeric format specifiers.  String format specifiers are satisfied
             by the subsequent string arguments.  Pointer format specifiers are
             satisfied by the subsequent pointer arguments.  Numeric specifiers
             are satisfied by the subsequent Bit32 arguments.  A special "%%"
             format specifier will insert the "%" character.  Note that this is
             different from the sprintf() function in standard C libraries which
             consume arguments left to right regardless of format specifier type.

  Called By: osLogString()
             osLogDebugString()

      Calls: agFmtFill_From_Arrays()

-*/

#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 agFmtFill(
                             char     *targetString,
                             os_bit32  targetLen,
                             char     *formatString,
                             char     *firstString,
                             char     *secondString,
                             void     *firstPtr,
                             void     *secondPtr,
                             os_bit32  firstBit32,
                             os_bit32  secondBit32,
                             os_bit32  thirdBit32,
                             os_bit32  fourthBit32,
                             os_bit32  fifthBit32,
                             os_bit32  sixthBit32,
                             os_bit32  seventhBit32,
                             os_bit32  eighthBit32
                           )
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 hpFmtFill(
                        char  *targetString,
                        bit32  targetLen,
                        char  *formatString,
                        char  *firstString,
                        char  *secondString,
                        bit32  firstBit32,
                        bit32  secondBit32,
                        bit32  thirdBit32,
                        bit32  fourthBit32,
                        bit32  fifthBit32,
                        bit32  sixthBit32,
                        bit32  seventhBit32,
                        bit32  eighthBit32
                      )
#endif /* _DvrArch_1_20_ was not defined */
{
    char      *stringArray[2];
#ifdef _DvrArch_1_20_
    os_bitptr  bitptrArray[2];
    os_bit32   bit32Array[8];
#else  /* _DvrArch_1_20_ was not defined */
    bit32      bit32Array[8];
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
    if (    (targetString == (char *)agNULL)
         || (targetLen    == 0)              )
    {
        return (os_bit32)0;
    }

    if (formatString == (char *)agNULL)
    {
        formatString = agFmtFill_NULL_formatString;
    }

    if (firstString  == (char *)agNULL)
    {
        firstString  = agFmtFill_NULL_firstString;
    }

    if (secondString == (char *)agNULL)
    {
        secondString = agFmtFill_NULL_secondString;
    }
#endif /* _DvrArch_1_20_ was defined */

/* Convert to array-form of agFmtFill() to ease implementation */

    stringArray[0] = firstString;
    stringArray[1] = secondString;

#ifdef _DvrArch_1_20_
    if (firstPtr == (void *)agNULL)
    {
        bitptrArray[0] = (os_bitptr)0; /* Make sure agNULL os_bitptr can be detected */
    }
    else
    {
        bitptrArray[0] = (os_bitptr)(firstPtr);
    }

    if (secondPtr == (void *)agNULL)
    {
        bitptrArray[1] = (os_bitptr)0; /* Make sure agNULL os_bitptr can be detected */
    }
    else
    {
        bitptrArray[1] = (os_bitptr)(secondPtr);
    }
#endif /* _DvrArch_1_20_ was defined */

    bit32Array[0]  = firstBit32;
    bit32Array[1]  = secondBit32;
    bit32Array[2]  = thirdBit32;
    bit32Array[3]  = fourthBit32;
    bit32Array[4]  = fifthBit32;
    bit32Array[5]  = sixthBit32;
    bit32Array[6]  = seventhBit32;
    bit32Array[7]  = eighthBit32;

#ifdef _DvrArch_1_20_
    return agFmtFill_From_Arrays(
#else  /* _DvrArch_1_20_ was not defined */
    return hpFmtFill_From_Arrays(
#endif /* _DvrArch_1_20_ was not defined */
                                  targetString,
                                  targetLen,
                                  formatString,
                                  stringArray,
#ifdef _DvrArch_1_20_
                                  bitptrArray,
#endif /* _DvrArch_1_20_ was defined */
                                  bit32Array
                                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\fwspec.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/FWSpec.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 8/14/00 6:46p   $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures
  used to communicate via the Embedded Firmware API

--*/

#ifndef __FWSpec_H__

#define __FWSpec_H__

#ifdef _DvrArch_1_20_
typedef struct agRpcInbound_s
               agRpcInbound_t;

struct agRpcInbound_s
       {
         os_bit32 ReqControl;
         os_bit32 ReqAddrLo;
         os_bit32 ReqAddrHi;
       };

#define agRpcInbound_ReqControl_ReqID_MASK       (os_bit32)0xFFFF0000
#define agRpcInbound_ReqControl_ReqID_SHIFT      (os_bit32)0x10

#define agRpcInbound_ReqControl_ReqAddr64        (os_bit32)0x00008000

#define agRpcInbound_ReqControl_ReqLocal         (os_bit32)0x00004000

#define agRpcInbound_ReqControl_ReqSGL           (os_bit32)0x00002000

#define agRpcInbound_ReqControl_ReqLen_MASK      (os_bit32)0x00000FFF
#define agRpcInbound_ReqControl_ReqLen_SHIFT     (os_bit32)0x00
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpRpcInbound_s
               hpRpcInbound_t;

struct hpRpcInbound_s
       {
         bit32 ReqControl;
         bit32 ReqAddrLo;
         bit32 ReqAddrHi;
       };

#define hpRpcInbound_ReqControl_ReqID_MASK       (bit32)0xFFFF0000
#define hpRpcInbound_ReqControl_ReqID_SHIFT      (bit32)0x10

#define hpRpcInbound_ReqControl_ReqAddr64        (bit32)0x00008000

#define hpRpcInbound_ReqControl_ReqLocal         (bit32)0x00004000

#define hpRpcInbound_ReqControl_ReqSGL           (bit32)0x00002000

#define hpRpcInbound_ReqControl_ReqLen_MASK      (bit32)0x00000FFF
#define hpRpcInbound_ReqControl_ReqLen_SHIFT     (bit32)0x00
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef os_bit32 agRpcInboundFast_t;

#define agRpcInboundFast_ReqID_MASK              (os_bit32)0xFFFF0000
#define agRpcInboundFast_ReqID_SHIFT             (os_bit32)0x10

#define agRpcInboundFast_ReqLen_MASK             (os_bit32)0x0000FFFF
#define agRpcInboundFast_ReqLen_SHIFT            (os_bit32)0x00
#else  /* _DvrArch_1_20_ was not defined */
typedef bit32 hpRpcInboundFast_t;

#define hpRpcInboundFast_ReqID_MASK              (bit32)0xFFFF0000
#define hpRpcInboundFast_ReqID_SHIFT             (bit32)0x10

#define hpRpcInboundFast_ReqLen_MASK             (bit32)0x0000FFFF
#define hpRpcInboundFast_ReqLen_SHIFT            (bit32)0x00
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef os_bit32 agRpcOutbound_t;

#define agRpcOutbound_ReqID_MASK                 (os_bit32)0xFFFF0000
#define agRpcOutbound_ReqID_SHIFT                (os_bit32)0x10

#define agRpcOutbound_ReqType_MASK               (os_bit32)0x0000FF00
#define agRpcOutbound_ReqType_SHIFT              (os_bit32)0x08

#define agRpcOutbound_ReqStatus_MASK             (os_bit32)0x000000FF
#define agRpcOutbound_ReqStatus_SHIFT            (os_bit32)0x00
#else  /* _DvrArch_1_20_ was not defined */
typedef bit32 hpRpcOutbound_t;

#define hpRpcOutbound_ReqID_MASK                 (bit32)0xFFFF0000
#define hpRpcOutbound_ReqID_SHIFT                (bit32)0x10

#define hpRpcOutbound_ReqType_MASK               (bit32)0x0000FF00
#define hpRpcOutbound_ReqType_SHIFT              (bit32)0x08

#define hpRpcOutbound_ReqStatus_MASK             (bit32)0x000000FF
#define hpRpcOutbound_ReqStatus_SHIFT            (bit32)0x00
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
#define agRpcPortIDStickyOff                     (os_bit32)0x0

typedef os_bit32 agRpcPortID_t;

#define agRpcPortID_StickyID_MASK                (os_bit32)0xF0000000
#define agRpcPortID_StickyID_SHIFT               (os_bit32)0x1C

#define agRpcPortID_ChannelID_MASK               (os_bit32)0x0F000000
#define agRpcPortID_ChannelID_SHIFT              (os_bit32)0x18

#define agRpcPortID_PortID_MASK                  (os_bit32)0x00FFFFFF
#define agRpcPortID_PortID_SHIFT                 (os_bit32)0x00
#else  /* _DvrArch_1_20_ was not defined */
typedef bit32 hpRpcPortID_t;

#define hpRpcPortID_StickyID_MASK                (bit32)0xF0000000
#define hpRpcPortID_StickyID_SHIFT               (bit32)0x1C
#define hpRpcPortIDStickyOff                     0x0

#define hpRpcPortID_ChannelID_MASK               (bit32)0x0F000000
#define hpRpcPortID_ChannelID_SHIFT              (bit32)0x18

#define hpRpcPortID_PortID_MASK                  (bit32)0x00FFFFFF
#define hpRpcPortID_PortID_SHIFT                 (bit32)0x00
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef os_bit16 agRpcReqID_t;

#define agRpcReqIDNone                           (agRpcReqID_t)0x0000
#define agRpcReqIDFast                           (agRpcReqID_t)0x8000
#else  /* _DvrArch_1_20_ was not defined */
typedef bit16 hpRpcReqID_t;

#define hpRpcReqIDNone                           (hpRpcReqID_t)0x0000
#define hpRpcReqIDFast                           (hpRpcReqID_t)0x8000
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
#define agRpcReqStatusOK                         (agRpcReqStatus_t)0x00
#define agRpcReqStatusBadInbound                 (agRpcReqStatus_t)0x01
#define agRpcReqStatusBadRequest                 (agRpcReqStatus_t)0x02
#define agRpcReqStatusLinkEvent                  (agRpcReqStatus_t)0x03
#define agRpcReqStatusBadReqID                   (agRpcReqStatus_t)0x04
#define agRpcReqStatusOK_Info                    (agRpcReqStatus_t)0x05
#define agRpcReqStatusPortStale                  (agRpcReqStatus_t)0x06
#define agRpcReqStatusIOAborted                  (agRpcReqStatus_t)0x07
#define agRpcReqStatusIOPortGone                 (agRpcReqStatus_t)0x08
#define agRpcReqStatusIOPortReset                (agRpcReqStatus_t)0x09
#define agRpcReqStatusIOInfoBad                  (agRpcReqStatus_t)0x0A
#define agRpcReqStatusIOOverUnder                (agRpcReqStatus_t)0x0B
#define agRpcReqStatusIOFailed                   (agRpcReqStatus_t)0x0C
#define agRpcReqStatusBadChannelID               (agRpcReqStatus_t)0x0D
#define agRpcReqStatusBadPortID                  (agRpcReqStatus_t)0x0E
#define agRpcReqStatusGetPortsNeedRoom           (agRpcReqStatus_t)0x0F
#define agRpcReqStatusBusy                       (agRpcReqStatus_t)0x10

typedef os_bit8 agRpcReqStatus_t;
#else  /* _DvrArch_1_20_ was not defined */
typedef bit8 hpRpcReqStatus_t;

#define hpRpcReqStatusOK                         (hpRpcReqStatus_t)0x00
#define hpRpcReqStatusBadInbound                 (hpRpcReqStatus_t)0x01
#define hpRpcReqStatusBadRequest                 (hpRpcReqStatus_t)0x02
#define hpRpcReqStatusLinkEvent                  (hpRpcReqStatus_t)0x03
#define hpRpcReqStatusBadReqID                   (hpRpcReqStatus_t)0x04
#define hpRpcReqStatusOK_Info                    (hpRpcReqStatus_t)0x05
#define hpRpcReqStatusPortStale                  (hpRpcReqStatus_t)0x06
#define hpRpcReqStatusIOAborted                  (hpRpcReqStatus_t)0x07
#define hpRpcReqStatusIOPortGone                 (hpRpcReqStatus_t)0x08
#define hpRpcReqStatusIOPortReset                (hpRpcReqStatus_t)0x09
#define hpRpcReqStatusIOInfoBad                  (hpRpcReqStatus_t)0x0A
#define hpRpcReqStatusIOOverUnder                (hpRpcReqStatus_t)0x0B
#define hpRpcReqStatusIOFailed                   (hpRpcReqStatus_t)0x0C
#define hpRpcReqStatusBadChannelID               (hpRpcReqStatus_t)0x0D
#define hpRpcReqStatusBadPortID                  (hpRpcReqStatus_t)0x0E
#define hpRpcReqStatusGetPortsNeedRoom           (hpRpcReqStatus_t)0x0F
#define hpRpcReqStatusBusy                       (hpRpcReqStatus_t)0x10
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef os_bit8 agRpcReqType_t;

#define agRpcReqTypeNone                         (agRpcReqType_t)0x00
#define agRpcReqTypeAbort                        (agRpcReqType_t)0x01
#define agRpcReqTypeDoSCSI                       (agRpcReqType_t)0x02
#define agRpcReqTypeGetChannelInfo               (agRpcReqType_t)0x03
#define agRpcReqTypeGetPortInfo                  (agRpcReqType_t)0x04
#define agRpcReqTypeGetPorts                     (agRpcReqType_t)0x05
#define agRpcReqTypeResetChannel                 (agRpcReqType_t)0x06
#define agRpcReqTypeResetPort                    (agRpcReqType_t)0x07
#define agRpcReqTypeSetupFastPath                (agRpcReqType_t)0x08
#else  /* _DvrArch_1_20_ was not defined */
typedef bit8 hpRpcReqType_t;

#define hpRpcReqTypeNone                         (hpRpcReqType_t)0x00
#define hpRpcReqTypeAbort                        (hpRpcReqType_t)0x01
#define hpRpcReqTypeDoSCSI                       (hpRpcReqType_t)0x02
#define hpRpcReqTypeGetChannelInfo               (hpRpcReqType_t)0x03
#define hpRpcReqTypeGetPortInfo                  (hpRpcReqType_t)0x04
#define hpRpcReqTypeGetPorts                     (hpRpcReqType_t)0x05
#define hpRpcReqTypeResetChannel                 (hpRpcReqType_t)0x06
#define hpRpcReqTypeResetPort                    (hpRpcReqType_t)0x07
#define hpRpcReqTypeSetupFastPath                (hpRpcReqType_t)0x08
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef struct agRpcSGL_s
               agRpcSGL_t;

struct agRpcSGL_s
       {
         os_bit32 Control;
         os_bit32 AddrLo;
         os_bit32 AddrHi;
       };

#define agRpcSGL_Control_Addr64                  (os_bit32)0x80000000

#define agRpcSGL_Control_Local                   (os_bit32)0x40000000

#define agRpcSGL_Control_Len_MASK                (os_bit32)0x0FFFFFFF
#define agRpcSGL_Control_Len_SHIFT               (os_bit32)0x00
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpRpcSGL_s
               hpRpcSGL_t;

struct hpRpcSGL_s
       {
         bit32 Control;
         bit32 AddrLo;
         bit32 AddrHi;
       };

#define hpRpcSGL_Control_Addr64                  (bit32)0x80000000

#define hpRpcSGL_Control_Local                   (bit32)0x40000000

#define hpRpcSGL_Control_Len_MASK                (bit32)0x0FFFFFFF
#define hpRpcSGL_Control_Len_SHIFT               (bit32)0x00
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef struct agRpcReqAbort_s
               agRpcReqAbort_t;

struct agRpcReqAbort_s
       {
         agRpcReqType_t ReqType;
         os_bit8        reserved;
         agRpcReqID_t   ReqID_to_Abort;
       };
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpRpcReqAbort_s
               hpRpcReqAbort_t;

struct hpRpcReqAbort_s
       {
         hpRpcReqType_t ReqType;
         bit8           reserved;
         hpRpcReqID_t   ReqID_to_Abort;
       };
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef struct agRpcReqDoSCSI_s
               agRpcReqDoSCSI_t;

struct agRpcReqDoSCSI_s
       {
         agRpcReqType_t        ReqType;
         os_bit8               reserved_1[3];
         agRpcPortID_t         PortID;
         os_bit16              reserved_2;
         os_bit16              RespControl;
         os_bit32              RespAddrLo;
         os_bit32              RespAddrHi;
         FC_FCP_CMND_Payload_t FCP_CMND;
         agRpcSGL_t            SGL[1];
       };

#define agRpcReqDoSCSI_RespControl_RespAddr64    (os_bit16)0x8000

#define agRpcReqDoSCSI_RespControl_RespLocal     (os_bit16)0x4000

#define agRpcReqDoSCSI_RespControl_RespSGL       (os_bit16)0x2000

#define agRpcReqDoSCSI_RespControl_RespLen_MASK  (os_bit16)0x0FFF
#define agRpcReqDoSCSI_RespControl_RespLen_SHIFT (os_bit16)0x00
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpRpcReqDoSCSI_s
               hpRpcReqDoSCSI_t;

struct hpRpcReqDoSCSI_s
       {
         hpRpcReqType_t        ReqType;
         bit8                  reserved_1[3];
         hpRpcPortID_t         PortID;
         bit16                 reserved_2;
         bit16                 RespControl;
         bit32                 RespAddrLo;
         bit32                 RespAddrHi;
         FC_FCP_CMND_Payload_t FCP_CMND;
         hpRpcSGL_t            SGL[1];
       };

#define hpRpcReqDoSCSI_RespControl_RespAddr64    (bit16)0x8000

#define hpRpcReqDoSCSI_RespControl_RespLocal     (bit16)0x4000

#define hpRpcReqDoSCSI_RespControl_RespSGL       (bit16)0x2000

#define hpRpcReqDoSCSI_RespControl_RespLen_MASK  (bit16)0x0FFF
#define hpRpcReqDoSCSI_RespControl_RespLen_SHIFT (bit16)0x00
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef struct agRpcReqGetChannelInfo_s
               agRpcReqGetChannelInfo_t;

struct agRpcReqGetChannelInfo_s
       {
         agRpcReqType_t ReqType;
         os_bit8        ChannelID;
         os_bit8        reserved[2];
         agRpcSGL_t     SGL[1];
       };
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpRpcReqGetChannelInfo_s
               hpRpcReqGetChannelInfo_t;

struct hpRpcReqGetChannelInfo_s
       {
         hpRpcReqType_t ReqType;
         bit8           ChannelID;
         bit8           reserved[2];
         hpRpcSGL_t     SGL[1];
       };
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef struct agRpcReqGetPortInfo_s
               agRpcReqGetPortInfo_t;

struct agRpcReqGetPortInfo_s
       {
         agRpcReqType_t ReqType;
         os_bit8        reserved[3];
         agRpcPortID_t  PortID;
         agRpcSGL_t     SGL[1];
       };
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpRpcReqGetPortInfo_s
               hpRpcReqGetPortInfo_t;

struct hpRpcReqGetPortInfo_s
       {
         hpRpcReqType_t ReqType;
         bit8           reserved[3];
         hpRpcPortID_t  PortID;
         hpRpcSGL_t     SGL[1];
       };
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef struct agRpcReqGetPorts_s
               agRpcReqGetPorts_t;

struct agRpcReqGetPorts_s
       {
         agRpcReqType_t ReqType;
         os_bit8        reserved[3];
         agRpcSGL_t     SGL[1];
       };
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpRpcReqGetPorts_s
               hpRpcReqGetPorts_t;

struct hpRpcReqGetPorts_s
       {
         hpRpcReqType_t ReqType;
         bit8           reserved[3];
         hpRpcSGL_t     SGL[1];
       };
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef struct agRpcReqResetChannel_s
               agRpcReqResetChannel_t;

struct agRpcReqResetChannel_s
       {
         agRpcReqType_t ReqType;
         os_bit8        ChannelID;
       };
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpRpcReqResetChannel_s
               hpRpcReqResetChannel_t;

struct hpRpcReqResetChannel_s
       {
         hpRpcReqType_t ReqType;
         bit8           ChannelID;
       };
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef struct agRpcReqResetPort_s
               agRpcReqResetPort_t;

struct agRpcReqResetPort_s
       {
         agRpcReqType_t ReqType;
         os_bit8        reserved[3];
         agRpcPortID_t  PortID;
       };
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpRpcReqResetPort_s
               hpRpcReqResetPort_t;

struct hpRpcReqResetPort_s
       {
         hpRpcReqType_t ReqType;
         bit8           reserved[3];
         hpRpcPortID_t  PortID;
       };
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef struct agRpcReqSetupFastPath_s
               agRpcReqSetupFastPath_t;

struct agRpcReqSetupFastPath_s
       {
         agRpcReqType_t ReqType;
         os_bit8        reserved[3];
         os_bit32       PoolEntriesSupplied;
         os_bit32       PoolEntriesUtilized;
         os_bit32       PoolEntrySize;
         os_bit32       PoolEntryOffset;
         agRpcSGL_t     SGL[1];
       };
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpRpcReqSetupFastPath_s
               hpRpcReqSetupFastPath_t;

struct hpRpcReqSetupFastPath_s
       {
         hpRpcReqType_t ReqType;
         bit8           reserved[3];
         bit32          PoolEntriesSupplied;
         bit32          PoolEntriesUtilized;
         bit32          PoolEntrySize;
         bit32          PoolEntryOffset;
         hpRpcSGL_t     SGL[1];
       };
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef struct agRpcReqUnknown_s
               agRpcReqUnknown_t;

struct agRpcReqUnknown_s
       {
         agRpcReqType_t ReqType;
       };
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpRpcReqUnknown_s
               hpRpcReqUnknown_t;

struct hpRpcReqUnknown_s
       {
         hpRpcReqType_t ReqType;
       };
#endif /* _DvrArch_1_20_ was not defined */

#endif  /* __FWSpec_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\fwstub.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/FWStub.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 8/07/00 6:01p   $ (Last Modified)

Purpose:

  This file implements the main entry points and support functions for the
  Stub FC Layer which implements the FirmWare Specification (FWSpec.DOC).

--*/

#include "../h/globals.h"
#include "../h/fwstub.h"

/*
 * Implement each FC Layer Function
 */

/*+

   Function: fcAbortIO()

    Purpose: This function is called to abort an I/O Request previously initiated by a call
             to fcStartIO().  The OS Layer should not assume that the I/O Request has been
             aborted until a call has been made to osIOCompleted() (presumably with the
             osIOAborted status).  Note that if osIOCompleted() hasn't yet been called for
             an I/O aborted via fcAbortIO(), the FC Layer must ensure that when osIOCompleted()
             is ultimately called that the I/O is marked as having been aborted even if the
             I/O actually had completed successfully.

             For the FWStub FC Layer, the synchronous behavior of the Abort Request must be
             preserved.  Thus, the Abort Request is transmitted to the Embedded Firmware
             and FWStub polls for for completion.

  Called By: <unknown OS Layer functions>

      Calls: osSingleThreadedEnter()
             osSingleThreadedLeave()
             FWStub_Send_Request()
             FWStub_Poll_Response()

-*/

osGLOBAL void fcAbortIO(
                         agRoot_t      *agRoot,
                         agIORequest_t *agIORequest
                       )
{
    FWStub_IO_NonDMA_t     *IO_NonDMA;
    FWStub_IO_DMA_t        *IO_DMA;
    FWStub_Global_NonDMA_t *Global_NonDMA;
    FWStub_Global_DMA_t    *Global_DMA;
    os_bit32                Global_DMA_Lower32;
    agRpcReqAbort_t        *ReqAbort_DMA;
    os_bit32                ReqAbort_DMA_Lower32;
    agBOOLEAN               FWStub_Send_Request_RETURN;
    agRpcOutbound_t         RpcOutbound;

    osSingleThreadedEnter(
                           agRoot
                         );

    IO_NonDMA = FWStub_IO_NonDMA_from_agIORequest(
                                                   agIORequest
                                                 );

    if (    (IO_NonDMA->Active == agFALSE)
         || (IO_NonDMA->Aborted == agTRUE) )
    {
        osSingleThreadedLeave(
                               agRoot
                             );

        return;
    }

    IO_DMA = IO_NonDMA->DMA;

    IO_NonDMA->Aborted = agTRUE;

    Global_NonDMA = FWStub_Global_NonDMA(
                                          agRoot
                                        );

    Global_DMA         = Global_NonDMA->DMA;
    Global_DMA_Lower32 = Global_NonDMA->DMA_Lower32;

    ReqAbort_DMA         = &(Global_DMA->Request.ReqAbort);
    ReqAbort_DMA_Lower32 = Global_DMA_Lower32 + agFieldOffset(
                                                               FWStub_Global_DMA_t,
                                                               Request.ReqAbort
                                                             );

    ReqAbort_DMA->ReqType        = agRpcReqTypeAbort;
    ReqAbort_DMA->ReqID_to_Abort = IO_DMA->ReqDoSCSI.PortID;

    FWStub_Send_Request_RETURN = FWStub_Send_Request(
                                                      agRoot,
                                                      FWStub_Global_ReqID,
                                                      sizeof(agRpcReqAbort_t),
                                                      ReqAbort_DMA_Lower32,
                                                      FWStub_Send_Request_Retries_DEFAULT,
                                                      FWStub_Send_Request_RetryStall_DEFAULT
                                                    );

    if (FWStub_Send_Request_RETURN == agFALSE)
    {
        osSingleThreadedLeave(
                               agRoot
                             );

        return;
    }

    RpcOutbound = FWStub_Poll_Response(
                                        agRoot,
                                        FWStub_Global_ReqID,
                                        agFALSE,
                                        FWStub_Poll_Response_RetryStall_DEFAULT
                                      );

    osSingleThreadedLeave(
                           agRoot
                         );
}

/*+

   Function: fcBindToWorkQs()

    Purpose: This function is used to attach the FC Layer to a pair of Work Queues presumably
             shared with another driver.  Two Work Queues make up an interface between the FC
             Layer and its peer.  Each Work Queue is described by a base address, number of
             entries, and the addresses of producer and consumer indexes.  Any number of Work
             Queue pairs could be supported, but each will have a defined purpose.  Initially,
             only a Work Queue pair for IP is supported.

             For the FWStub FC Layer, this function is not implemented.

  Called By: <unknown OS Layer functions>

      Calls: <none>

-*/

#ifdef _DvrArch_1_30_
osGLOBAL os_bit32 fcBindToWorkQs(
                                  agRoot_t  *agRoot,
                                  os_bit32   agQPairID,
                                  void     **agInboundQBase,
                                  os_bit32   agInboundQEntries,
                                  os_bit32  *agInboundQProdIndex,
                                  os_bit32  *agInboundQConsIndex,
                                  void     **agOutboundQBase,
                                  os_bit32   agOutboundQEntries,
                                  os_bit32  *agOutboundQProdIndex,
                                  os_bit32  *agOutboundQConsIndex
                                )
{
    return (os_bit32)0;
}
#endif /* _DvrArch_1_30_ was defined */

/*+

   Function: fcCardSupported()

    Purpose: This function is called to check to see if the FC Layer supports this card
             corresponding to the value of agRoot passed.  Presumably, the PCI Configuration
             Registers VendorID (bytes 0x00-0x01), DeviceID (bytes 0x02-0x03), RevisionID
             (byte 0x08), ClassCode (bytes 0x09-0x0B), SubsystemVendorID (bytes 0x2C-0x2D),
             and SubsystemID (bytes 0x2E-0x2F) are used in this determination.  Perhaps, the
             WorldWideName (WWN) is used as well.  The function returns agTRUE if the FC
             Layer supports this card and agFALSE if it does not.

             For the FWStub FC Layer, only the DeviceID and VendorID of the Intel 21554
             Bridge Chip on the SA-IOP is verified.

  Called By: <unknown OS Layer functions>

      Calls: osChipConfigReadBit32()

-*/

osGLOBAL agBOOLEAN fcCardSupported(
                                    agRoot_t *agRoot
                                  )
{
    if (osChipConfigReadBit32(
                               agRoot,
                               agFieldOffset(
                                              I21554_Primary_Interface_Config_t,
                                              DeviceID_VendorID
                                            )
                             ) == (I21554_Config_DeviceID_21554 | I21554_Config_VendorID_Intel))
    {
        return agTRUE;
    }
    else
    {
        return agFALSE;
    }
}

/*+

   Function: fcDelayedInterruptHandler()

    Purpose: This function is called following a prior call to fcInterruptHandler() which
             returned agTRUE.  At that time, the Fibre Channel protocol chip (TachyonTL,
             in this case) had raised an interrupt which fcInterruptHandler() masked.  The
             role of fcDelayedInterruptHandler() is to handle the original interrupt (e.g.
             process the I/O completion message in the IMQ), unmask the interrupt and return.
             Now that calls to osSingleThreadedEnter() are allowed (calling osSingleThreadedEnter()
             from fcInterruptHandler() was not allowed), the FC Layer can control access to data
             structures and the chip as needed.

             For the FWStub FC Layer, messages arriving on the Outbound FIFO of the Intel 21554
             Bridge are processed.  Note that only messages using the "Normal Path" are acknowledged.
             In either case, all messages currently in the Outbound FIFO are processed prior to return.

  Called By: <unknown OS Layer functions>

      Calls: osSingleThreadedEnter()
             FWStub_Process_Response()
             osChipMemWriteBit32()
             osSingleThreadedLeave()

-*/

osGLOBAL void fcDelayedInterruptHandler(
                                         agRoot_t *agRoot
                                       )
{
    FWStub_Global_NonDMA_t *Global_NonDMA;
    agRpcOutbound_t         RpcOutbound;

    osSingleThreadedEnter(
                           agRoot
                         );

    Global_NonDMA = FWStub_Global_NonDMA(
                                          agRoot
                                        );

#ifdef FWStub_Tune_for_One_INT_per_IO
    RpcOutbound = Global_NonDMA->agRpcOutbound;

    if (!(RpcOutbound & (agRpcReqIDFast << agRpcOutbound_ReqID_SHIFT)))
    {
        /* ReqIDs with the agRpcReqIDFast bit set need not be ACK'd */

        FWStub_AckOutbound(
                            agRoot
                          );
    }

    FWStub_Process_Response(
                             agRoot,
                             RpcOutbound
                           );
#else  /* FWStub_Tune_for_One_INT_per_IO was not defined */
    while ( (RpcOutbound = FWStub_FetchOutbound(
                                                 agRoot
                                               )       ) != 0xFFFFFFFF )
    {
        if (!(RpcOutbound & (agRpcReqIDFast << agRpcOutbound_ReqID_SHIFT)))
        {
            /* ReqIDs with the agRpcReqIDFast bit set need not be ACK'd */

            FWStub_AckOutbound(
                                agRoot
                              );
        }

        FWStub_Process_Response(
                                 agRoot,
                                 RpcOutbound
                               );
    }
#endif /* FWStub_Tune_for_One_INT_per_IO was not defined */

    if (Global_NonDMA->sysIntsActive != agFALSE)
    {
        osChipMemWriteBit32(
                             agRoot,
                             agFieldOffset(
                                            I21554_CSR_t,
                                            I2O_Outbound_Post_List_Interrupt_Mask
                                          ),
                             0
                           );
    }

    osSingleThreadedLeave(
                           agRoot
                         );
}

/*+

   Function: fcEnteringOS()

    Purpose: This function is called to indicate to the FC Layer that it is being called after
             the OS has switched back (presumably between NetWare and BIOS) from the "other OS".
             The prior switch out of "this OS" was preceded by a call to fcLeavingOS().

             For the FWStub FC Layer, Interrupt Handling is re-enabled if active prior to the
             corresponding call to fcLeavingOS().

  Called By: <unknown OS Layer functions>

      Calls: osSingleThreadedEnter()
             osChipMemWriteBit32()
             osSingleThreadedLeave()

-*/

osGLOBAL void fcEnteringOS(
                            agRoot_t *agRoot
                          )
{
    osSingleThreadedEnter(
                           agRoot
                         );

    if (FWStub_Global_NonDMA(agRoot)->sysIntsActive == agFALSE)
    {
        osChipMemWriteBit32(
                             agRoot,
                             agFieldOffset(
                                            I21554_CSR_t,
                                            I2O_Outbound_Post_List_Interrupt_Mask
                                          ),
                             I21554_CSR_I2O_Outbound_Post_List_Interrupt_Mask
                           );
    }
    else /* FWStub_Global_NonDMA(agRoot)->sysIntsActive == agTRUE */
    {
        osChipMemWriteBit32(
                             agRoot,
                             agFieldOffset(
                                            I21554_CSR_t,
                                            I2O_Outbound_Post_List_Interrupt_Mask
                                          ),
                             0
                           );
    }

    osSingleThreadedLeave(
                           agRoot
                         );
}

/*+

   Function: fcGetChannelInfo()

    Purpose: This function is called to return information about the channel.  The information
             returned is described in the agFCChanInfo_t structure.

             For the FWStub FC Layer, the synchronous behavior of the GetChannelInfo Request must
             be preserved.  Thus, the GetChannelInfo Request is transmitted to the Embedded Firmware
             and FWStub polls for for completion.

  Called By: <unknown OS Layer functions>

      Calls: osSingleThreadedEnter()
             FWStub_Send_Request()
             osSingleThreadedLeave()
             FWStub_Poll_Response()

-*/

osGLOBAL os_bit32 fcGetChannelInfo(
                                    agRoot_t       *agRoot,
                                    agFCChanInfo_t *agFCChanInfo
                                  )
{
    FWStub_Global_NonDMA_t   *Global_NonDMA;
    FWStub_Global_DMA_t      *Global_DMA;
    os_bit32                  Global_DMA_Lower32;
    agRpcReqGetChannelInfo_t *ReqGetChannelInfo_DMA;
    os_bit32                  ReqGetChannelInfo_DMA_Lower32;
    agFCChanInfo_t           *ChanInfo_DMA;
    os_bit32                  ChanInfo_DMA_Lower32;
    agBOOLEAN                 FWStub_Send_Request_RETURN;
    agRpcOutbound_t           RpcOutbound;
    os_bit32                  To_Return;

    osSingleThreadedEnter(
                           agRoot
                         );

    Global_NonDMA = FWStub_Global_NonDMA(
                                          agRoot
                                        );

    Global_DMA         = Global_NonDMA->DMA;
    Global_DMA_Lower32 = Global_NonDMA->DMA_Lower32;

    ReqGetChannelInfo_DMA         = &(Global_DMA->Request.ReqGetChannelInfo);
    ReqGetChannelInfo_DMA_Lower32 = Global_DMA_Lower32 + agFieldOffset(
                                                                        FWStub_Global_DMA_t,
                                                                        Request.ReqGetChannelInfo
                                                                      );

    ChanInfo_DMA         = &(Global_DMA->RequestInfo.ChanInfo);
    ChanInfo_DMA_Lower32 = Global_DMA_Lower32 + agFieldOffset(
                                                               FWStub_Global_DMA_t,
                                                               RequestInfo.ChanInfo
                                                             );

    ReqGetChannelInfo_DMA->ReqType        = agRpcReqTypeGetChannelInfo;
    ReqGetChannelInfo_DMA->ChannelID      = 0;
    ReqGetChannelInfo_DMA->SGL[0].Control = (sizeof(agFCChanInfo_t) << agRpcSGL_Control_Len_SHIFT);
    ReqGetChannelInfo_DMA->SGL[0].AddrLo  = ChanInfo_DMA_Lower32;

    FWStub_Send_Request_RETURN = FWStub_Send_Request(
                                                      agRoot,
                                                      FWStub_Global_ReqID,
                                                      sizeof(agRpcReqGetChannelInfo_t),
                                                      ReqGetChannelInfo_DMA_Lower32,
                                                      FWStub_Send_Request_Retries_DEFAULT,
                                                      FWStub_Send_Request_RetryStall_DEFAULT
                                                    );

    if (FWStub_Send_Request_RETURN == agFALSE)
    {
        osSingleThreadedLeave(
                               agRoot
                             );

        return ~fcChanInfoReturned;
    }

    RpcOutbound = FWStub_Poll_Response(
                                        agRoot,
                                        FWStub_Global_ReqID,
                                        agFALSE,
                                        FWStub_Poll_Response_RetryStall_DEFAULT
                                      );

    if (    ( (RpcOutbound & agRpcOutbound_ReqStatus_MASK) >> agRpcOutbound_ReqStatus_SHIFT )
         == agRpcReqStatusOK)
    {
        *agFCChanInfo = *ChanInfo_DMA;

        To_Return = fcChanInfoReturned;
    }
    else /* RpcOutbound[ReqStatus] != agRpcReqStatusOK */
    {
        To_Return = ~fcChanInfoReturned;
    }

    osSingleThreadedLeave(
                           agRoot
                         );

    return To_Return;
}

/*+

   Function: fcGetDeviceHandles()

    Purpose: This function is called to return the device handles for each device currently
             available.  Note that the function returns the number of device slots available
             but will only copy the handles which will fit into the supplied buffer.  Further,
             there are potentially holes in the list where devices once existed but are not
             presently addressable.  Hence, the number of handles actually present in the
             returned list must be determined by the OS Layer.  As the FC Layer is responsible
             for ensuring the persistence of addressing to each device, a particular slot in
             the returned array will always refer to the same device (though the value contained
             in that slot may differ from time to time).

             For the FWStub FC Layer, the synchronous behavior of the GetDeviceHandles Request must
             be preserved.  Thus, the GetDeviceHandles Request is transmitted to the Embedded Firmware
             and FWStub polls for for completion.

  Called By: <unknown OS Layer functions>

      Calls: osSingleThreadedEnter()
             FWStub_Send_Request()
             osSingleThreadedLeave()
             FWStub_Poll_Response()

-*/

osGLOBAL os_bit32 fcGetDeviceHandles(
                                      agRoot_t  *agRoot,
                                      agFCDev_t  agFCDev[],
                                      os_bit32   maxFCDevs
                                    )
{
    FWStub_Global_NonDMA_t *Global_NonDMA;
    FWStub_Global_DMA_t    *Global_DMA;
    os_bit32                Global_DMA_Lower32;
    agRpcReqGetPorts_t     *ReqGetPorts_DMA;
    os_bit32                ReqGetPorts_DMA_Lower32;
    agFCDev_t              *Devices_DMA;
    os_bit32                Devices_DMA_Lower32;
    agBOOLEAN               FWStub_Send_Request_RETURN;
    agRpcOutbound_t         RpcOutbound;
    os_bit32                Device_Index;
    os_bit32                To_Return;

    osSingleThreadedEnter(
                           agRoot
                         );

    Global_NonDMA = FWStub_Global_NonDMA(
                                          agRoot
                                        );

    Global_DMA         = Global_NonDMA->DMA;
    Global_DMA_Lower32 = Global_NonDMA->DMA_Lower32;

    ReqGetPorts_DMA         = &(Global_DMA->Request.ReqGetPorts);
    ReqGetPorts_DMA_Lower32 = Global_DMA_Lower32 + agFieldOffset(
                                                                  FWStub_Global_DMA_t,
                                                                  Request.ReqGetPorts
                                                                );

    Devices_DMA         = &(Global_DMA->RequestInfo.Devices[0]);
    Devices_DMA_Lower32 = Global_DMA_Lower32 + agFieldOffset(
                                                              FWStub_Global_DMA_t,
                                                              RequestInfo.Devices[0]
                                                            );

    ReqGetPorts_DMA->ReqType        = agRpcReqTypeGetPorts;
    ReqGetPorts_DMA->SGL[0].Control = ((FWStub_NumDevices * sizeof(agFCDev_t)) << agRpcSGL_Control_Len_SHIFT);
    ReqGetPorts_DMA->SGL[0].AddrLo  = Devices_DMA_Lower32;

    for(
         Device_Index = 0;
         Device_Index < FWStub_NumDevices;
         Device_Index++
       )
    {
        Devices_DMA[Device_Index] = (agFCDev_t)0x00000000;
    }

    FWStub_Send_Request_RETURN = FWStub_Send_Request(
                                                      agRoot,
                                                      FWStub_Global_ReqID,
                                                      sizeof(agRpcReqGetPorts_t),
                                                      ReqGetPorts_DMA_Lower32,
                                                      FWStub_Send_Request_Retries_DEFAULT,
                                                      FWStub_Send_Request_RetryStall_DEFAULT
                                                    );

    if (FWStub_Send_Request_RETURN == agFALSE)
    {
        osSingleThreadedLeave(
                               agRoot
                             );

        return 0;
    }

    RpcOutbound = FWStub_Poll_Response(
                                        agRoot,
                                        FWStub_Global_ReqID,
                                        agFALSE,
                                        FWStub_Poll_Response_RetryStall_DEFAULT
                                      );

    To_Return = 0;

    if (    ( (RpcOutbound & agRpcOutbound_ReqStatus_MASK) >> agRpcOutbound_ReqStatus_SHIFT )
         == agRpcReqStatusOK)
    {
        for(
             Device_Index = 0;
             (Device_Index < FWStub_NumDevices);
             Device_Index++
           )
        {
            if (Device_Index < maxFCDevs)
            {
                agFCDev[Device_Index] = Devices_DMA[Device_Index];
            }

            if (Devices_DMA[Device_Index] != (agFCDev_t)0x00000000)
            {
                To_Return = Device_Index + 1;
            }
        }
    }

    osSingleThreadedLeave(
                           agRoot
                         );

    return To_Return;
}

/*+

   Function: fcGetDeviceInfo()

    Purpose: This function is called to return information about the specified device handle.
             The information returned is described in the agFCDevInfo_t structure.

             For the FWStub FC Layer, the synchronous behavior of the GetDeviceInfo Request must
             be preserved.  Thus, the GetDeviceInfo Request is transmitted to the Embedded Firmware
             and FWStub polls for for completion.

  Called By: <unknown OS Layer functions>

      Calls: osSingleThreadedEnter()
             FWStub_Send_Request()
             osSingleThreadedLeave()
             FWStub_Poll_Response()

-*/

osGLOBAL os_bit32 fcGetDeviceInfo(
                                   agRoot_t      *agRoot,
                                   agFCDev_t      agFCDev,
                                   agFCDevInfo_t *agFCDevInfo
                                 )
{
    FWStub_Global_NonDMA_t *Global_NonDMA;
    FWStub_Global_DMA_t    *Global_DMA;
    os_bit32                Global_DMA_Lower32;
    agRpcReqGetPortInfo_t  *ReqGetPortInfo_DMA;
    os_bit32                ReqGetPortInfo_DMA_Lower32;
    agFCDevInfo_t          *DevInfo_DMA;
    os_bit32                DevInfo_DMA_Lower32;
    agBOOLEAN               FWStub_Send_Request_RETURN;
    agRpcOutbound_t         RpcOutbound;
    os_bit32                To_Return;

    osSingleThreadedEnter(
                           agRoot
                         );

    Global_NonDMA = FWStub_Global_NonDMA(
                                          agRoot
                                        );

    Global_DMA         = Global_NonDMA->DMA;
    Global_DMA_Lower32 = Global_NonDMA->DMA_Lower32;

    ReqGetPortInfo_DMA         = &(Global_DMA->Request.ReqGetPortInfo);
    ReqGetPortInfo_DMA_Lower32 = Global_DMA_Lower32 + agFieldOffset(
                                                                     FWStub_Global_DMA_t,
                                                                     Request.ReqGetPortInfo
                                                                   );

    DevInfo_DMA         = &(Global_DMA->RequestInfo.DevInfo);
    DevInfo_DMA_Lower32 = Global_DMA_Lower32 + agFieldOffset(
                                                              FWStub_Global_DMA_t,
                                                              RequestInfo.DevInfo
                                                            );

    ReqGetPortInfo_DMA->ReqType        = agRpcReqTypeGetPortInfo;
    ReqGetPortInfo_DMA->PortID         = (agRpcPortID_t)agFCDev;
    ReqGetPortInfo_DMA->SGL[0].Control = (sizeof(agFCDevInfo_t) << agRpcSGL_Control_Len_SHIFT);
    ReqGetPortInfo_DMA->SGL[0].AddrLo  = DevInfo_DMA_Lower32;

    FWStub_Send_Request_RETURN = FWStub_Send_Request(
                                                      agRoot,
                                                      FWStub_Global_ReqID,
                                                      sizeof(agRpcReqGetPortInfo_t),
                                                      ReqGetPortInfo_DMA_Lower32,
                                                      FWStub_Send_Request_Retries_DEFAULT,
                                                      FWStub_Send_Request_RetryStall_DEFAULT
                                                    );

    if (FWStub_Send_Request_RETURN == agFALSE)
    {
        osSingleThreadedLeave(
                               agRoot
                             );

        return ~fcGetDevInfoReturned;
    }

    RpcOutbound = FWStub_Poll_Response(
                                        agRoot,
                                        FWStub_Global_ReqID,
                                        agFALSE,
                                        FWStub_Poll_Response_RetryStall_DEFAULT
                                      );

    if (    ( (RpcOutbound & agRpcOutbound_ReqStatus_MASK) >> agRpcOutbound_ReqStatus_SHIFT )
         == agRpcReqStatusOK)
    {
        *agFCDevInfo = *DevInfo_DMA;

        To_Return = fcGetDevInfoReturned;
    }
    else /* RpcOutbound[ReqStatus] != agRpcReqStatusOK */
    {
        To_Return = ~fcGetDevInfoReturned;
    }

    osSingleThreadedLeave(
                           agRoot
                         );

    return To_Return;
}

/*+

   Function: fcInitializeChannel()

    Purpose: This function is called to initialize a particular channel.  Note that channel
             initialization must be preceded by a call to fcInitializeDriver().  In addition
             to indicating memory allocated, the OS Layer specifies the number of microseconds
             between timer ticks (indicated in calls to fcTimerTick()).  If the value of
             usecsPerTick returned is zero, no calls to fcTimerTick() will be made.  Note also
             that this interval may be different from that requested in the return from
             fcInitializeDriver().  Finally, it is possible to request that the initialization
             be completed before returning (fcSyncInit) or asynchronously (fcAsyncInit) followed
             by a callback to osInitializeChannelCallback().  In the asynchronous case, a return
             (from this function) of fcInitializeSuccess simply means that initialization of the
             channel has begun and that the final status (the value osInitializeChannelCallback()
             ultimately returns) should be tested for success.  Should the return (from this
             function) be fcInitializeFailure and fcAsyncInit was specified, no callback to
             osInitializeChannelCallback() will be made.  During initialization, it is often the
             case that interrupts are not yet available.  A parameter, sysIntsActive, indicates
             whether or not interrupts are available.  A subsequent call to fcSystemInterruptsActive()
             will indicate when interrupts become available should they not be at this time.

             For the FWStub FC Layer, the InitializeChannel function simply means that data structures
             internal to FWStub must be initialized.  The Embedded Firmware has already initialized the
             actual FibreChannel Port(s).  In addition, the "Fast Path" for optimized I/O commands is
             set up via a synchronous request (i.e. fcInitializeChannel() polls for completion).
             Finally, the Outbound FIFO is emptied so that subsequent execution will proceed from a
             clean starting point.

  Called By: <unknown OS Layer functions>

      Calls: osSingleThreadedEnter()
             osChipMemWriteBit32()
             FWStub_Send_Request()
             osInitializeChannelCallback()
             osSingleThreadedLeave()
             FWStub_Poll_Response()

-*/

osGLOBAL os_bit32 fcInitializeChannel(
                                       agRoot_t  *agRoot,
                                       os_bit32   initType,
                                       agBOOLEAN  sysIntsActive,
                                       void      *cachedMemoryPtr,
                                       os_bit32   cachedMemoryLen,
                                       os_bit32   dmaMemoryUpper32,
                                       os_bit32   dmaMemoryLower32,
                                       void      *dmaMemoryPtr,
                                       os_bit32   dmaMemoryLen,
                                       os_bit32   nvMemoryLen,
                                       os_bit32   cardRamUpper32,
                                       os_bit32   cardRamLower32,
                                       os_bit32   cardRamLen,
                                       os_bit32   cardRomUpper32,
                                       os_bit32   cardRomLower32,
                                       os_bit32   cardRomLen,
                                       os_bit32   usecsPerTick
                                     )
{
    FWStub_Global_NonDMA_t  *Global_NonDMA;
    FWStub_Global_DMA_t     *Global_DMA;
    os_bit32                 Global_DMA_Lower32;
    agRpcReqSetupFastPath_t *ReqSetupFastPath_DMA;
    os_bit32                 ReqSetupFastPath_DMA_Lower32;
    agBOOLEAN                FWStub_Send_Request_RETURN;
    agRpcOutbound_t          RpcOutbound;
    FWStub_IO_NonDMA_t      *IO_NonDMA;
    FWStub_IO_DMA_t         *IO_DMA;
    os_bit32                 IO_DMA_Lower32;
    agRpcReqID_t             ReqID;

    osSingleThreadedEnter(
                           agRoot
                         );

    Global_NonDMA      = (FWStub_Global_NonDMA_t *)cachedMemoryPtr;
    Global_DMA         = (FWStub_Global_DMA_t *)dmaMemoryPtr;
    Global_DMA_Lower32 = dmaMemoryLower32;

    Global_NonDMA->DMA           = Global_DMA;
    Global_NonDMA->DMA_Lower32   = Global_DMA_Lower32;

    if (sysIntsActive == agFALSE)
    {
        Global_NonDMA->sysIntsActive = agFALSE;

        osChipMemWriteBit32(
                             agRoot,
                             agFieldOffset(
                                            I21554_CSR_t,
                                            I2O_Outbound_Post_List_Interrupt_Mask
                                          ),
                             I21554_CSR_I2O_Outbound_Post_List_Interrupt_Mask
                           );
    }
    else /* sysIntsActive == agTRUE */
    {
        Global_NonDMA->sysIntsActive = agTRUE;

        osChipMemWriteBit32(
                             agRoot,
                             agFieldOffset(
                                            I21554_CSR_t,
                                            I2O_Outbound_Post_List_Interrupt_Mask
                                          ),
                             0
                           );
    }

#ifdef FWStub_Use_Fast_Path
    /* Setup Fast Path for DoSCSI Request IDs */

    ReqSetupFastPath_DMA         = &(Global_DMA->Request.ReqSetupFastPath);
    ReqSetupFastPath_DMA_Lower32 = Global_DMA_Lower32 + agFieldOffset(
                                                                       FWStub_Global_DMA_t,
                                                                       Request.ReqSetupFastPath
                                                                     );

    ReqSetupFastPath_DMA->ReqType             = agRpcReqTypeSetupFastPath;

    ReqSetupFastPath_DMA->PoolEntriesSupplied = FWStub_NumIOs;
    ReqSetupFastPath_DMA->PoolEntriesUtilized = 0;
    ReqSetupFastPath_DMA->PoolEntrySize       = sizeof(FWStub_IO_DMA_t);
    ReqSetupFastPath_DMA->PoolEntryOffset     = (os_bit32)0;

    ReqSetupFastPath_DMA->SGL[0].Control      = (    (FWStub_NumIOs * sizeof(FWStub_IO_DMA_t))
                                                  << agRpcSGL_Control_Len_SHIFT                );
    ReqSetupFastPath_DMA->SGL[0].AddrLo       = Global_DMA_Lower32 + agFieldOffset(
                                                                                    FWStub_Global_DMA_t,
                                                                                    IOs
                                                                                  );
    ReqSetupFastPath_DMA->SGL[0].AddrHi       = (os_bit32)0;

    FWStub_Send_Request_RETURN = FWStub_Send_Request(
                                                      agRoot,
                                                      FWStub_Global_ReqID,
                                                      sizeof(agRpcReqSetupFastPath_t),
                                                      ReqSetupFastPath_DMA_Lower32,
                                                      FWStub_Send_Request_Retries_DEFAULT,
                                                      FWStub_Send_Request_RetryStall_DEFAULT
                                                    );

    if (FWStub_Send_Request_RETURN == agFALSE)
    {
        if ( (initType & fcSyncAsyncInitMask) == fcAsyncInit )
        {
            osInitializeChannelCallback(
                                         agRoot,
                                         fcInitializeFailure
                                       );
        }

        osSingleThreadedLeave(
                               agRoot
                             );

        return fcInitializeFailure;
    }

    RpcOutbound = FWStub_Poll_Response(
                                        agRoot,
                                        FWStub_Global_ReqID,
                                        agTRUE,
                                        FWStub_Poll_Response_RetryStall_DEFAULT
                                      );

    if (    ( (RpcOutbound & agRpcOutbound_ReqStatus_MASK) >> agRpcOutbound_ReqStatus_SHIFT )
         != agRpcReqStatusOK)
    {
        if ( (initType & fcSyncAsyncInitMask) == fcAsyncInit )
        {
            osInitializeChannelCallback(
                                         agRoot,
                                         fcInitializeFailure
                                       );
        }

        osSingleThreadedLeave(
                               agRoot
                             );

        return fcInitializeFailure;
    }

    /* Queue onto DoSCSI Request Free List Fast Path Request IDs to Utilize */
#else /* FWStub_Use_Fast_Path was not defined */
    /* Queue onto DoSCSI Request Free List Normal Path Request IDs to Utilize */
#endif /* FWStub_Use_Fast_Path was not defined */

    for(
         ReqID = 1;
#ifdef FWStub_Use_Fast_Path
         ReqID <= Global_DMA->Request.ReqSetupFastPath.PoolEntriesUtilized;
#else /* FWStub_Use_Fast_Path was not defined */
         ReqID <  FWStub_Global_ReqID;
#endif /* FWStub_Use_Fast_Path was not defined */
         ReqID++
       )
    {
        IO_NonDMA      = FWStub_IO_NonDMA(Global_NonDMA,ReqID);
        IO_DMA         = FWStub_IO_DMA(Global_DMA,ReqID);
        IO_DMA_Lower32 = FWStub_IO_DMA_Lower32(Global_DMA_Lower32,ReqID);

        if (ReqID == 1)
        {
            IO_NonDMA->Next = (FWStub_IO_NonDMA_t *)agNULL;
        }
        else
        {
            IO_NonDMA->Next = Global_NonDMA->First_IO;
        }

        Global_NonDMA->First_IO = IO_NonDMA;

        IO_NonDMA->DMA         = IO_DMA;
        IO_NonDMA->DMA_Lower32 = IO_DMA_Lower32;
#ifdef FWStub_Use_Fast_Path
        IO_NonDMA->ReqID       = ReqID | agRpcReqIDFast;
#else /* FWStub_Use_Fast_Path was not defined */
        IO_NonDMA->ReqID       = ReqID;
#endif /* FWStub_Use_Fast_Path was not defined */
        IO_NonDMA->agIORequest = (agIORequest_t *)agNULL;
        IO_NonDMA->Active      = agFALSE;
        IO_NonDMA->Aborted     = agFALSE;
        IO_NonDMA->FCP_CMND    = FWStub_IO_DMA_FCP_CMND(IO_DMA);
        IO_NonDMA->SGL         = FWStub_IO_DMA_SGL(IO_DMA);
        IO_NonDMA->Info        = FWStub_IO_DMA_Info(IO_DMA);

        IO_DMA->ReqDoSCSI.ReqType     = agRpcReqTypeDoSCSI;
        IO_DMA->ReqDoSCSI.RespControl = (FWStub_MaxInfo << agRpcReqDoSCSI_RespControl_RespLen_SHIFT);
        IO_DMA->ReqDoSCSI.RespAddrLo  = FWStub_IO_DMA_Info_Lower32(IO_DMA_Lower32);
    }

    agRoot->fcData = (void *)Global_NonDMA;

    /* Empty extraneous Outbound FIFO data */

    while ( (RpcOutbound = FWStub_FetchOutbound(
                                                 agRoot
                                               )       ) != 0xFFFFFFFF )
    {
        if (!(RpcOutbound & (agRpcReqIDFast << agRpcOutbound_ReqID_SHIFT)))
        {
            /* ReqIDs with the agRpcReqIDFast bit set need not be ACK'd */

            FWStub_AckOutbound(
                                agRoot
                              );
        }
    }

    if ( (initType & fcSyncAsyncInitMask) == fcAsyncInit )
    {
        osInitializeChannelCallback(
                                     agRoot,
                                     fcInitializeSuccess
                                   );
    }

    osSingleThreadedLeave(
                           agRoot
                         );

    return fcInitializeSuccess;
}

/*+

   Function: fcInitializeDriver()

    Purpose: This function is called to initialize the FC Layer's portion of the driver.  While
             the agRoot structure is passed as an argument, it is only useful as a handle to pass
             back to the OS Layer (presumably in calls to osAdjustParameterXXX() in determining
             how much memory is needed by each instance of the driver) as no non-stack memory is
             available to preserve the contents of agRoot.  The amount and alignment of memory
             needed by each instance of the driver (i.e. for each channel) is returned by
             fcInitializeDriver() in the reference arguments provided.  The three types of memory
             requested are cached, non-cached (a.k.a. dma), and non-volatile.  Note that the
             non-cached memory (a.k.a. "dma memory") is constrained to be physically contiguous
             memory.  In addition to memory needs, the FC Layer specifies the number of microseconds
             between timer ticks (indicated in calls to fcTimerTick()).  If the value of usecsPerTick
             returned is zero, no calls to fcTimerTick() will be made.

             For the FWStub FC Layer, all data structures are hard-specified in ..\H\FWStub.H
             rather than computed using calls to osAdjustParameterBit32().

  Called By: <unknown OS Layer functions>

      Calls: <none>

-*/

osGLOBAL os_bit32 fcInitializeDriver(
                                      agRoot_t *agRoot,
                                      os_bit32 *cachedMemoryNeeded,
                                      os_bit32 *cachedMemoryPtrAlign,
                                      os_bit32 *dmaMemoryNeeded,
                                      os_bit32 *dmaMemoryPtrAlign,
                                      os_bit32 *dmaMemoryPhyAlign,
                                      os_bit32 *nvMemoryNeeded,
                                      os_bit32 *usecsPerTick
                                    )
{
    *cachedMemoryNeeded   = FWStub_cachedMemoryNeeded;
    *cachedMemoryPtrAlign = FWStub_cachedMemoryPtrAlign;
    *dmaMemoryNeeded      = FWStub_dmaMemoryNeeded;
    *dmaMemoryPtrAlign    = FWStub_dmaMemoryPtrAlign;
    *dmaMemoryPhyAlign    = FWStub_dmaMemoryPhyAlign;
    *nvMemoryNeeded       = FWStub_nvMemoryNeeded;
    *usecsPerTick         = FWStub_usecsPerTick;

    return fcInitializeSuccess;
}

/*+

   Function: fcInterruptHandler()

    Purpose: This function is called from the OS Layer's Interrupt Service Routine in response to
             some PCI device raising an interrupt.  The presumption by the FC Layer is that it is
             possible some thread is currently executing this instance of the driver.  Therefore,
             fcInterruptHandler() must be very cautious in accessing any data structure.  It is
             invalid to call osSingleThreadedEnter() (see Section 8.63 below) from this function.
             Any logic which must be executed requiring single threaded access must be deferred
             until the OS Layer can support a call to osSingleThreadedEnter().  A corresponding
             function, fcDelayedInterruptHandler(), is provided for this case.  If
             fcInterruptHandler() determines that it's chip (TachyonTL, in this case) is raising
             the interrupt, it should mask off the interrupt and return agTRUE.  If the Fibre Channel
             chip is not the source of the interrupt, no further action is required and agFALSE is
             returned.  Note that fcDelayedInterruptHandler() will only be called if agTRUE is returned.

             It is possible for a card to generate interrupts prior to the driver being initialized.
             Should these interrupts get routed to the OS Layer prior to fcInitializeChannel() being
             called, the OS Layer will provide an agRoot with a agNULL fcData field.  In this special
             case, the FC Layer should simply mask the interrupt from the card (using
             osChipConfigRead/WriteBitXXX() function calls) and return agFALSE (indicating that
             fcDelayedInterruptHandler() need not be called at this time to service the extraneous
             interrupt).

             For the FWStub FC Layer, the Outbound FIFO is read or the corresponding Interrupt Bit
             in the Intel 21554 Bridge is checked for message arrival.

  Called By: <unknown OS Layer functions>

      Calls: osChipMemReadBit32()
             osChipMemWriteBit32()

-*/

osGLOBAL agBOOLEAN fcInterruptHandler(
                                       agRoot_t *agRoot
                                     )
{
#ifdef FWStub_Tune_for_One_INT_per_IO
    if ( (FWStub_Global_NonDMA(agRoot)->agRpcOutbound = FWStub_FetchOutbound(
                                                                              agRoot
                                                                            )       ) != 0xFFFFFFFF )
#else  /* FWStub_Tune_for_One_INT_per_IO was not defined */
    if (osChipMemReadBit32(
                            agRoot,
                            agFieldOffset(
                                           I21554_CSR_t,
                                           I2O_Outbound_Post_List_Status
                                         )
                          ) & I21554_CSR_I2O_Outbound_Post_List_Status_Not_Empty)
#endif /* FWStub_Tune_for_One_INT_per_IO was not defined */
    {
        osChipMemWriteBit32(
                             agRoot,
                             agFieldOffset(
                                            I21554_CSR_t,
                                            I2O_Outbound_Post_List_Interrupt_Mask
                                          ),
                             I21554_CSR_I2O_Outbound_Post_List_Interrupt_Mask
                           );

        return agTRUE;
    }
    else
    {
        return agFALSE;
    }
}

/*+

   Function: fcIOInfoReadBit8()

    Purpose: This function is called to read an 8-bit value from the I/O Info referred to by an
             agIORequest_t.  The OS Layer should call this function only within osIOCompleted().
             The caller need not know where the I/O Info resides (e.g. whether it is in host memory
             or in on-card RAM) nor whether it is in consecutive memory or not (e.g. when part of
             the I/O Info wraps around to the beginning of the Single Frame Queue for TachyonXL2).

             For the FWStub FC Layer, the Response Frame is located and the requested 8-bit value
             extracted and returned.

  Called By: <unknown OS Layer functions>

      Calls: <none>

-*/

osGLOBAL os_bit8 fcIOInfoReadBit8(
                                   agRoot_t      *agRoot,
                                   agIORequest_t *agIORequest,
                                   os_bit32       fcIOInfoOffset
                                 )
{
    FWStub_IO_NonDMA_t *IO_NonDMA;
    os_bit8            *IOInfo_DMA;

    IO_NonDMA = FWStub_IO_NonDMA_from_agIORequest(
                                                   agIORequest
                                                 );

    IOInfo_DMA = &(IO_NonDMA->DMA->Info[fcIOInfoOffset]);

    return *IOInfo_DMA;
}

/*+

   Function: fcIOInfoReadBit16()

    Purpose: This function is called to read a 16-bit value from the I/O Info referred to by an
             agIORequest_t. The OS Layer should call this function only within osIOCompleted().
             The caller need not know where the I/O Info resides (e.g. whether it is in host memory
             or in on-card RAM) nor whether it is in consecutive memory or not (e.g. when part of
             the I/O Info wraps around to the beginning of the Single Frame Queue for TachyonXL2).
             Finally, it is assumed that the 2-byte value is read from a 2-byte aligned offset using
             a 2-byte access.

             For the FWStub FC Layer, the Response Frame is located and the requested 16-bit value
             extracted and returned.

  Called By: <unknown OS Layer functions>

      Calls: <none>

-*/

osGLOBAL os_bit16 fcIOInfoReadBit16(
                                     agRoot_t      *agRoot,
                                     agIORequest_t *agIORequest,
                                     os_bit32       fcIOInfoOffset
                                   )
{
    FWStub_IO_NonDMA_t *IO_NonDMA;
    os_bit16           *IOInfo_DMA;

    IO_NonDMA = FWStub_IO_NonDMA_from_agIORequest(
                                                   agIORequest
                                                 );

    IOInfo_DMA = (os_bit16 *)(&(IO_NonDMA->DMA->Info[fcIOInfoOffset]));

    return *IOInfo_DMA;
}

/*+

   Function: fcIOInfoReadBit32()

    Purpose: This function is called to read a 32-bit value from the I/O Info referred to by an
             agIORequest_t. The OS Layer should call this function only within osIOCompleted().
             The caller need not know where the I/O Info resides (e.g. whether it is in host
             memory or in on-card RAM) nor whether it is in consecutive memory or not (e.g. when
             part of the I/O Info wraps around to the beginning of the Single Frame Queue for
             TachyonXL2).  Finally, it is assumed that the 4-byte value is read from a 4-byte
             aligned offset using a 4-byte access.

             For the FWStub FC Layer, the Response Frame is located and the requested 32-bit value
             extracted and returned.

  Called By: <unknown OS Layer functions>

      Calls: <none>

-*/

osGLOBAL os_bit32 fcIOInfoReadBit32(
                                     agRoot_t      *agRoot,
                                     agIORequest_t *agIORequest,
                                     os_bit32       fcIOInfoOffset
                                   )
{
    FWStub_IO_NonDMA_t *IO_NonDMA;
    os_bit32           *IOInfo_DMA;

    IO_NonDMA = FWStub_IO_NonDMA_from_agIORequest(
                                                   agIORequest
                                                 );

    IOInfo_DMA = (os_bit32 *)(&(IO_NonDMA->DMA->Info[fcIOInfoOffset]));

    return *IOInfo_DMA;
}

/*+

   Function: fcIOInfoReadBlock()

    Purpose: This function is called to read a block of data from the I/O Info referred to by an
             agIORequest_t. The OS Layer should call this function only within osIOCompleted().
             The caller need not know where the I/O Info resides (e.g. whether it is in host memory
             or in on-card RAM) nor whether it is in consecutive memory or not (e.g. when part of
             the I/O Info wraps around to the beginning of the Single Frame Queue for TachyonXL2).

             For the FWStub FC Layer, the Response Frame is located and the requested block is copied
             into the specified buffer.

  Called By: <unknown OS Layer functions>

      Calls: <none>

-*/

osGLOBAL void fcIOInfoReadBlock(
                                 agRoot_t      *agRoot,
                                 agIORequest_t *agIORequest,
                                 os_bit32       fcIOInfoOffset,
                                 void          *fcIOInfoBuffer,
                                 os_bit32       fcIOInfoBufLen
                               )
{
    FWStub_IO_NonDMA_t *IO_NonDMA;
    os_bit8            *IOInfo_DMA;
    os_bit8            *IOInfo_DMA_Destination = (os_bit8 *)fcIOInfoBuffer;

    IO_NonDMA = FWStub_IO_NonDMA_from_agIORequest(
                                                   agIORequest
                                                 );

    IOInfo_DMA = &(IO_NonDMA->DMA->Info[fcIOInfoOffset]);

    while (fcIOInfoBufLen-- > 0)
    {
        *IOInfo_DMA_Destination++ = *IOInfo_DMA++;
    }

    return;
}

/*+

   Function: fcLeavingOS()

    Purpose: This function is called to indicate to the FC Layer that it should prepare for the OS
             to switch (presumably between NetWare and BIOS).  Upon return from the "other OS", a
             corresponding call to fcEnteringOS() will be made.  It is assumed by the OS Layer that
             calling this function causes the FC Layer to stop participation on the Fibre Channel
             until fcEnteringOS() is called.  Further, no interrupts or other PCI bus accesses will
             be required by the card during this time.

             For the FWStub FC Layer, Interrupts are masked (regardless of whether they were
             currently enabled or not).

  Called By: <unknown OS Layer functions>

      Calls: osSingleThreadedEnter()
             osChipMemWriteBit32()
             osSingleThreadedLeave()

-*/

osGLOBAL void fcLeavingOS(
                           agRoot_t *agRoot
                         )
{
    osSingleThreadedEnter(
                           agRoot
                         );

    osChipMemWriteBit32(
                         agRoot,
                         agFieldOffset(
                                        I21554_CSR_t,
                                        I2O_Outbound_Post_List_Interrupt_Mask
                                      ),
                         I21554_CSR_I2O_Outbound_Post_List_Interrupt_Mask
                       );

    osSingleThreadedLeave(
                           agRoot
                         );
}

/*+

   Function: fcProcessInboundQ()

    Purpose: This function is called to instruct the FC Layer to process new elements added to the
             specified Work Queue pair's Inbound Queue.

             For the FWStub FC Layer, this function is not implemented.

  Called By: <unknown OS Layer functions>

      Calls: <none>

-*/

#ifdef _DvrArch_1_30_
osGLOBAL void fcProcessInboundQ(
                                 agRoot_t *agRoot,
                                 os_bit32  agQPairID
                               )
{
}
#endif /* _DvrArch_1_30_ was defined */

/*+

   Function: fcResetChannel()

    Purpose: This function is called to reset the Fibre Channel protocol chip and the channel
             (FC-AL Loop, in this case).  All outstanding I/Os pending on this channel will be
             completed with a status of osIODevReset passed to osIOCompleted().  It is possible
             to request that the reset be completed before returning (fcSyncReset) or
             asynchronously (fcAsyncReset) followed by a callback to osResetChannelCallback().
             In this case, a return (from this function) of fcResetSuccess simply means that a
             reset of the channel has begun and that the final status (the value
             osResetChannelCallback() ultimately returns) should be tested for success.  If this
             function returns fcResetFailure and fcAsyncReset was specified, no call to
             osResetChannelCallback() will be made.

             For the FWStub FC Layer, the synchronous behavior of the ResetChannel Request must
             be preserved.  Thus, the ResetChannel Request is transmitted to the Embedded Firmware
             and FWStub polls for for completion.

  Called By: <unknown OS Layer functions>

      Calls: osSingleThreadedEnter()
             FWStub_Send_Request()
             FWStub_Poll_Response()
             osResetChannelCallback()
             osSingleThreadedLeave()

-*/

osGLOBAL os_bit32 fcResetChannel(
                                  agRoot_t *agRoot,
                                  os_bit32  agResetType
                                )
{
    FWStub_Global_NonDMA_t *Global_NonDMA;
    FWStub_Global_DMA_t    *Global_DMA;
    os_bit32                Global_DMA_Lower32;
    agRpcReqResetChannel_t *ReqResetChannel_DMA;
    os_bit32                ReqResetChannel_DMA_Lower32;
    agBOOLEAN               FWStub_Send_Request_RETURN;
    agRpcOutbound_t         RpcOutbound;
    os_bit32                To_Return;

    osSingleThreadedEnter(
                           agRoot
                         );

    Global_NonDMA = FWStub_Global_NonDMA(
                                          agRoot
                                        );

    Global_DMA         = Global_NonDMA->DMA;
    Global_DMA_Lower32 = Global_NonDMA->DMA_Lower32;

    ReqResetChannel_DMA         = &(Global_DMA->Request.ReqResetChannel);
    ReqResetChannel_DMA_Lower32 = Global_DMA_Lower32 + agFieldOffset(
                                                                      FWStub_Global_DMA_t,
                                                                      Request.ReqResetChannel
                                                                    );

    ReqResetChannel_DMA->ReqType   = agRpcReqTypeResetChannel;
    ReqResetChannel_DMA->ChannelID = 0;

    FWStub_Send_Request_RETURN = FWStub_Send_Request(
                                                      agRoot,
                                                      FWStub_Global_ReqID,
                                                      sizeof(agRpcReqResetChannel_t),
                                                      ReqResetChannel_DMA_Lower32,
                                                      FWStub_Send_Request_Retries_DEFAULT,
                                                      FWStub_Send_Request_RetryStall_DEFAULT
                                                    );

    if (FWStub_Send_Request_RETURN == agFALSE)
    {
        To_Return = fcResetFailure;
    }
    else /* FWStub_Send_Request_RETURN == agTRUE */
    {
        RpcOutbound = FWStub_Poll_Response(
                                            agRoot,
                                            FWStub_Global_ReqID,
                                            agFALSE,
                                            FWStub_Poll_Response_RetryStall_DEFAULT
                                          );

        if (    ( (RpcOutbound & agRpcOutbound_ReqStatus_MASK) >> agRpcOutbound_ReqStatus_SHIFT )
             == agRpcReqStatusOK)
        {
            To_Return = fcResetSuccess;
        }
        else /* RpcOutbound[ReqStatus] != agRpcReqStatusOK */
        {
            To_Return = fcResetFailure;
        }
    }

    if ( (agResetType & fcSyncAsyncResetMask) == fcAsyncReset )
    {
        osResetChannelCallback(
                                agRoot,
                                To_Return
                              );
    }

    osSingleThreadedLeave(
                           agRoot
                         );

    return To_Return;
}

/*+

   Function: fcResetDevice()

    Purpose: This function is called to perform a device reset.  All outstanding I/Os pending on
             this device will be completed with a status of osIODevReset passed to osIOCompleted().
             An option allows performing either a Soft Reset (fcSoftReset) or a Hard Reset
             (fcHardReset) of the device.  Also, it is possible to request that the reset be
             completed before returning (fcSyncReset) or asynchronously (fcAsyncReset) followed by
             a callback to osResetDeviceCallback().  In this case, a return (from this function)
             of fcResetSuccess simply means that a reset of the channel has begun and that the
             final status (the value osResetDeviceCallback() ultimately returns) should be tested
             for success.  If this function returns fcResetFailure and fcAsyncReset was specified,
             no call to osResetDeviceCallback() will be made.  Finally, it is possible to request
             that a reset be performed on every known device.  In this case, the status returned
             will indicate success only when all resets succeeded individually.

             For the FWStub FC Layer, the synchronous behavior of the ResetDevice Request must
             be preserved.  Thus, the ResetDevice Request is transmitted to the Embedded Firmware
             and FWStub polls for for completion.

  Called By: <unknown OS Layer functions>

      Calls: osSingleThreadedEnter()
             FWStub_Send_Request()
             FWStub_Poll_Response()
             osResetDeviceCallback()
             osSingleThreadedLeave()

-*/

osGLOBAL os_bit32 fcResetDevice(
                                 agRoot_t  *agRoot,
                                 agFCDev_t  agFCDev,
                                 os_bit32   agResetType
                               )
{
    FWStub_Global_NonDMA_t *Global_NonDMA;
    FWStub_Global_DMA_t    *Global_DMA;
    os_bit32                Global_DMA_Lower32;
    agRpcReqResetPort_t    *ReqResetPort_DMA;
    os_bit32                ReqResetPort_DMA_Lower32;
    agBOOLEAN               FWStub_Send_Request_RETURN;
    agRpcOutbound_t         RpcOutbound;
    os_bit32                To_Return;

    osSingleThreadedEnter(
                           agRoot
                         );

    Global_NonDMA = FWStub_Global_NonDMA(
                                          agRoot
                                        );

    Global_DMA         = Global_NonDMA->DMA;
    Global_DMA_Lower32 = Global_NonDMA->DMA_Lower32;

    ReqResetPort_DMA         = &(Global_DMA->Request.ReqResetPort);
    ReqResetPort_DMA_Lower32 = Global_DMA_Lower32 + agFieldOffset(
                                                                   FWStub_Global_DMA_t,
                                                                   Request.ReqResetPort
                                                                 );

    ReqResetPort_DMA->ReqType = agRpcReqTypeResetPort;
    ReqResetPort_DMA->PortID  = (agRpcPortID_t)agFCDev;

    FWStub_Send_Request_RETURN = FWStub_Send_Request(
                                                      agRoot,
                                                      FWStub_Global_ReqID,
                                                      sizeof(agRpcReqResetPort_t),
                                                      ReqResetPort_DMA_Lower32,
                                                      FWStub_Send_Request_Retries_DEFAULT,
                                                      FWStub_Send_Request_RetryStall_DEFAULT
                                                    );

    if (FWStub_Send_Request_RETURN == agFALSE)
    {
        To_Return = fcResetFailure;
    }
    else /* FWStub_Send_Request_RETURN == agTRUE */
    {
        RpcOutbound = FWStub_Poll_Response(
                                            agRoot,
                                            FWStub_Global_ReqID,
                                            agFALSE,
                                            FWStub_Poll_Response_RetryStall_DEFAULT
                                          );

        if (    ( (RpcOutbound & agRpcOutbound_ReqStatus_MASK) >> agRpcOutbound_ReqStatus_SHIFT )
             == agRpcReqStatusOK)
        {
            To_Return = fcResetSuccess;
        }
        else /* RpcOutbound[ReqStatus] != agRpcReqStatusOK */
        {
            To_Return = fcResetFailure;
        }
    }

    if ( (agResetType & fcSyncAsyncResetMask) == fcAsyncReset )
    {
        osResetDeviceCallback(
                               agRoot,
                               agFCDev,
                               To_Return
                             );
    }

    osSingleThreadedLeave(
                           agRoot
                         );

    return To_Return;
}

/*+

   Function: fcShutdownChannel()

    Purpose: This function is called to discontinue use of a particular channel.  Upon return, the
             card should not generate any interrupts or any other PCI accesses.  In addition, all
             host resources (i.e. both cached and non-cached memory) are no longer owned by the
             FC Layer.  Upon return, the state of the FC Layer (for this particular channel) is
             identical to the state just prior to the call to fcInitializeChannel().

             For the FWStub FC Layer, Interrupts are masked (regardless of whether they were
             currently enabled or not).

  Called By: <unknown OS Layer functions>

      Calls: osSingleThreadedEnter()
             osChipMemWriteBit32()
             osSingleThreadedLeave()

-*/

osGLOBAL void fcShutdownChannel(
                                 agRoot_t *agRoot
                               )
{
    osSingleThreadedEnter(
                           agRoot
                         );

    osChipMemWriteBit32(
                         agRoot,
                         agFieldOffset(
                                        I21554_CSR_t,
                                        I2O_Outbound_Post_List_Interrupt_Mask
                                      ),
                         I21554_CSR_I2O_Outbound_Post_List_Interrupt_Mask
                       );

    agRoot->fcData = (void *)agNULL;

    osSingleThreadedLeave(
                           agRoot
                         );
}

/*+

   Function: fcStartIO()

    Purpose: This function is called to initiate an I/O Request.  If there are sufficient resources
             to launch the request (assuming it is executable), fcIOStarted will be returned and the
             I/O will be initiated on the Fibre Channel.  If resources are not available, fcIOBusy
             will be returned and the OS Layer should try again later (perhaps when a prior I/O still
             outstanding completes freeing up resources).  Currently, only a CDB (SCSI-3) request is
             defined by passing the agCDBRequest_t variant of an agIORequestBody_t.

             For the FWStub FC Layer, the CDB Request is bundled up into a single message and sent
             to the Embedded Firmware via the Inbound FIFO of the Intel 21554 Bridge.  In Interrupts
             are currently disabled, fcStartIO() will poll for completion.  In either case, any
             messages which have arrived in the Outbound FIFO are processed immediately to avoid
             unnecessary calls to fcInterruptHandler()/fcDelayedInterruptHandler().

  Called By: <unknown OS Layer functions>

      Calls: osSingleThreadedEnter()
             osSingleThreadedLeave()
             osGetSGLChunk()
             FWStub_Send_Request()
             FWStub_Poll_Response()
             FWStub_Process_Response()

-*/

osGLOBAL os_bit32 fcStartIO(
                             agRoot_t          *agRoot,
                             agIORequest_t     *agIORequest,
                             agFCDev_t          agFCDev,
                             os_bit32           agRequestType,
                             agIORequestBody_t *agRequestBody
                           )
{
    FWStub_Global_NonDMA_t *Global_NonDMA;
    FWStub_IO_NonDMA_t     *IO_NonDMA;
    FWStub_IO_DMA_t        *IO_DMA;
    os_bit32                FCP_DL;
    os_bit32                FCP_RO                     = 0;
    os_bit32                SGL_Count                  = 0;
    agRpcSGL_t             *SGL_Slot;
    os_bit32                agChunkUpper32;
    os_bit32                agChunkLen;
    os_bit32                ReqLen;
#ifdef FWStub_Use_Fast_Path
#else /* FWStub_Use_Fast_Path was not defined */
    agBOOLEAN               FWStub_Send_Request_RETURN;
#endif /* FWStub_Use_Fast_Path was not defined */
    agRpcOutbound_t         RpcOutbound;

    osSingleThreadedEnter(
                           agRoot
                         );

    Global_NonDMA = FWStub_Global_NonDMA(agRoot);

    if ( (IO_NonDMA = Global_NonDMA->First_IO) == (FWStub_IO_NonDMA_t *)agNULL )
    {
        osSingleThreadedLeave(
                               agRoot
                             );

        return fcIOBusy;
    }

    Global_NonDMA->First_IO = IO_NonDMA->Next;

    IO_DMA = IO_NonDMA->DMA;

    IO_DMA->ReqDoSCSI.PortID   = (agRpcPortID_t)agFCDev;
    IO_DMA->ReqDoSCSI.FCP_CMND = *((FC_FCP_CMND_Payload_t *)(&(agRequestBody->CDBRequest.FcpCmnd)));

    FCP_DL =   (agRequestBody->CDBRequest.FcpCmnd.FcpDL[0] << 24)
             + (agRequestBody->CDBRequest.FcpCmnd.FcpDL[1] << 16)
             + (agRequestBody->CDBRequest.FcpCmnd.FcpDL[2] <<  8)
             + (agRequestBody->CDBRequest.FcpCmnd.FcpDL[3] <<  0);

    SGL_Slot = IO_NonDMA->SGL;

    while (    (FCP_RO    < FCP_DL)
            && (SGL_Count < FWStub_MaxSGL)
            && (osGetSGLChunk(
                               agRoot,
                               agIORequest,
                               FCP_RO,
                               &agChunkUpper32,
                               &(SGL_Slot->AddrLo),
                               &agChunkLen
                             ) == osSGLSuccess) )
    {
        SGL_Slot->Control = agChunkLen << agRpcSGL_Control_Len_SHIFT;

        FCP_RO    += agChunkLen;
        SGL_Count += 1;
        SGL_Slot  += 1;
    }

    if (FCP_RO != FCP_DL)
    {
        IO_NonDMA->Next         = Global_NonDMA->First_IO;
        Global_NonDMA->First_IO = IO_NonDMA;

        osSingleThreadedLeave(
                               agRoot
                             );

        return fcIONoSupport;
    }

    IO_NonDMA->agIORequest = agIORequest;
    IO_NonDMA->Active      = agTRUE;

    agIORequest->fcData = (void *)IO_NonDMA;

    ReqLen =   sizeof(agRpcReqDoSCSI_t)
             - sizeof(agRpcSGL_t)
             + (   SGL_Count
                 * sizeof(agRpcSGL_t) );

#ifdef FWStub_Use_Fast_Path
    FWStub_PostInbound(
                        agRoot,
                        (   (IO_NonDMA->ReqID << agRpcInboundFast_ReqID_SHIFT)
                          | (ReqLen           << agRpcInboundFast_ReqLen_SHIFT) )
                      );
#else /* FWStub_Use_Fast_Path was not defined */
    FWStub_Send_Request_RETURN = FWStub_Send_Request(
                                                      agRoot,
                                                      IO_NonDMA->ReqID,
                                                      ReqLen,
                                                      IO_NonDMA->DMA_Lower32,
                                                      FWStub_Send_Request_Retries_DEFAULT,
                                                      FWStub_Send_Request_RetryStall_DEFAULT
                                                    );

    if (FWStub_Send_Request_RETURN == agFALSE)
    {
        IO_NonDMA->agIORequest = (agIORequest_t *)agNULL;
        IO_NonDMA->Active      = agFALSE;

        agIORequest->fcData = (void *)agNULL;

        IO_NonDMA->Next         = Global_NonDMA->First_IO;
        Global_NonDMA->First_IO = IO_NonDMA;

        osSingleThreadedLeave(
                               agRoot
                             );

        return fcIOBusy;
    }
#endif /* FWStub_Use_Fast_Path was not defined */

    if (Global_NonDMA->sysIntsActive == agFALSE)
    {
        RpcOutbound = FWStub_Poll_Response(
                                            agRoot,
                                            IO_NonDMA->ReqID,
                                            agFALSE,
                                            FWStub_Poll_Response_RetryStall_DEFAULT
                                          );

        FWStub_Process_Response(
                                 agRoot,
                                 RpcOutbound
                               );
    }
#ifndef FWStub_Tune_for_One_INT_per_IO
    else /* Global_NonDMA->sysIntsActive == agTRUE */
    {
        while ( (RpcOutbound = FWStub_FetchOutbound(
                                                     agRoot
                                                   )       ) != 0xFFFFFFFF )
        {
            if (!(RpcOutbound & (agRpcReqIDFast << agRpcOutbound_ReqID_SHIFT)))
            {
                /* ReqIDs with the agRpcReqIDFast bit set need not be ACK'd */

                FWStub_AckOutbound(
                                    agRoot
                                  );
            }

            FWStub_Process_Response(
                                     agRoot,
                                     RpcOutbound
                                   );
        }
    }
#endif /* FWStub_Tune_for_One_INT_per_IO was not defined */

    osSingleThreadedLeave(
                           agRoot
                         );

    return fcIOStarted;
}

/*+

   Function: fcSystemInterruptsActive()

    Purpose: This function is called to indicate to the FC Layer whether interrupts are available
             or not.  The parameter sysIntsActive indicates whether or not interrupts are available
             at this time.  Similarly, sysIntsActive, as passed to fcInitializeChannel(), specified
             if interrupts were available during channel initialization.  It is often the case that
             interrupts are not yet available during initialization.  In that case, sysIntsActive
             should be agFALSE in the call to fcInitializeChannel().  Initialization would then
             proceed using polling techniques as opposed to waiting for interrupts.  Later, when
             interrupts can be supported, fcSystemInterruptsActive() would be called with sysIntsActive
             set to agTRUE.
    
             For the FWStub FC Layer, the Interrupt corresponding to the Outbound FIFO of the Intel
             21554 Bridge is enabled or disabled based on the value of sysIntsActive argument.
    
  Called By: <unknown OS Layer function>

      Calls: osSingleThreadedEnter()
             osChipMemWriteBit32()
             osSingleThreadedLeave()

-*/

osGLOBAL void fcSystemInterruptsActive(
                                        agRoot_t  *agRoot,
                                        agBOOLEAN  sysIntsActive
                                      )
{
    FWStub_Global_NonDMA_t *Global_NonDMA;

    osSingleThreadedEnter(
                           agRoot
                         );

    Global_NonDMA = FWStub_Global_NonDMA(agRoot);

    if (Global_NonDMA->sysIntsActive != sysIntsActive)
    {
        if (sysIntsActive == agFALSE)
        {
            osChipMemWriteBit32(
                                 agRoot,
                                 agFieldOffset(
                                                I21554_CSR_t,
                                                I2O_Outbound_Post_List_Interrupt_Mask
                                              ),
                                 I21554_CSR_I2O_Outbound_Post_List_Interrupt_Mask
                               );

            Global_NonDMA->sysIntsActive = agFALSE;
        }
        else /* sysIntsActive == agTRUE */
        {
            Global_NonDMA->sysIntsActive = agTRUE;

            osChipMemWriteBit32(
                                 agRoot,
                                 agFieldOffset(
                                                I21554_CSR_t,
                                                I2O_Outbound_Post_List_Interrupt_Mask
                                              ),
                                 0
                               );
        }
    }

    osSingleThreadedLeave(
                           agRoot
                         );
}

/*+

   Function: fcTimerTick()

    Purpose: This function is called periodically based on the number of microseconds ultimately
             specified in the fcInitializeChannel() usecsPerTick argument.  Presumably, this time
             tick is used to implement timed operations within the FC Layer.  Note that this
             function is only called if usecsPerTick was non-zero.  The OS Layer is required to
             call this function at a time when the FC Layer can call any function, particularly
             osSingleThreadedEnter().

             For the FWStub FC Layer, this function is currently not utilized.

  Called By: <unknown OS Layer functions>

      Calls: osSingleThreadedEnter()
             osSingleThreadedLeave()

-*/

osGLOBAL void fcTimerTick(
                           agRoot_t *agRoot
                         )
{
    osSingleThreadedEnter(
                           agRoot
                         );

    osSingleThreadedLeave(
                           agRoot
                         );
}

/*
 * Internal Functions
 */

/*+

   Function: FWStub_Send_Request()

    Purpose: Posts message to Inbound FIFO of Intel 21554 Bridge.

  Called By: fcAbortIO()
             fcGetChannelInfo()
             fcGetDeviceHandles()
             fcGetDeviceInfo()
             fcInitializeChannel()
             fcResetChannel()
             fcResetDevice()
             fcStartIO()

      Calls: osChipMemWriteBit32()
             osStallThread()

-*/

osLOCAL agBOOLEAN FWStub_Send_Request(
                                       agRoot_t     *agRoot,
                                       agRpcReqID_t  ReqID,
                                       os_bit32      ReqLen,
                                       os_bit32      ReqAddr_Lower32,
                                       os_bit32      Retries,
                                       os_bit32      RetryStall
                                     )
{
    os_bit32 Retry;
    os_bit32 RpcInbound_Offset;

    for(
         Retry = 0;
         Retry < Retries;
         Retry++
       )
    {
        if ( (RpcInbound_Offset = FWStub_AllocInbound(
                                                       agRoot
                                                     )       ) != 0xFFFFFFFF )
        {
            osChipMemWriteBit32(
                                 agRoot,
                                 (RpcInbound_Offset + agFieldOffset(
                                                                     agRpcInbound_t,
                                                                     ReqControl
                                                                   )                ),
                                 (   (ReqID  << agRpcInbound_ReqControl_ReqID_SHIFT)
                                   | (ReqLen << agRpcInbound_ReqControl_ReqLen_SHIFT) )
                               );

            osChipMemWriteBit32(
                                 agRoot,
                                 (RpcInbound_Offset + agFieldOffset(
                                                                     agRpcInbound_t,
                                                                     ReqAddrLo
                                                                   )                ),
                                 ReqAddr_Lower32
                               );

            FWStub_PostInbound(
                                agRoot,
                                RpcInbound_Offset
                              );

            return agTRUE;
        }

        osStallThread(
                       agRoot,
                       RetryStall
                     );
    }

    return agFALSE;
}

/*+

   Function: FWStub_Poll_Response()

    Purpose: Polls until the desired ReqID-tagged message arrives in the Outbound FIFO of
             the Intel 21554 Bridge.  Messages which arrive in the meantime (i.e. while
             polling for the desired ReqID) are also processed immediately.

  Called By: fcAbortIO()
             fcGetChannelInfo()
             fcGetDeviceHandles()
             fcGetDeviceInfo()
             fcInitializeChannel()
             fcResetChannel()
             fcResetDevice()
             fcStartIO()

      Calls: FWStub_Process_Response()
             osStallThread()

-*/

osLOCAL agRpcOutbound_t FWStub_Poll_Response(
                                              agRoot_t     *agRoot,
                                              agRpcReqID_t  ReqID,
                                              agBOOLEAN     DisposeOtherReqIDs,
                                              os_bit32      RetryStall
                                            )
{
    agRpcOutbound_t RpcOutbound;

    while(1)
    {
        if ( (RpcOutbound = FWStub_FetchOutbound(
                                                  agRoot
                                                )       ) != 0xFFFFFFFF )
        {
            if (!(RpcOutbound & (agRpcReqIDFast << agRpcOutbound_ReqID_SHIFT)))
            {
                /* ReqIDs with the agRpcReqIDFast bit set need not be ACK'd */

                FWStub_AckOutbound(
                                    agRoot
                                  );
            }

            if (    ( (RpcOutbound & agRpcOutbound_ReqID_MASK) >> agRpcOutbound_ReqID_SHIFT )
                 == ReqID                                                                     )
            {
                return RpcOutbound;
            }
            else /* RpcOutbound[ReqID] != ReqID */
            {
                if (DisposeOtherReqIDs == agFALSE)
                {
                    FWStub_Process_Response(
                                             agRoot,
                                             RpcOutbound
                                           );
                }
            }
        }
        else /* RpcOutbound == 0xFFFFFFFF */
        {
            osStallThread(
                           agRoot,
                           RetryStall
                         );
        }
    }
}

/*+

   Function: FWStub_Process_Response()

    Purpose: Processes a message which has just arrived on the Outbound FIFO of the Intel 21554
             Bridge.  At this time, usually only CDB Completions are actually processed (all others
             having been synchronously processed prior to return from a FWStub_Poll_Response()
             call which polled awaiting a specific ReqID).  Hence, most messages result in a call
             to osIOCompleted().  The lone exception is the LinkUp message which is communicated
             to the OS Layer via a call to osFCLayerAsyncEvent().

  Called By: fcDelayedInterruptHandler()
             fcStartIO()
             FWStub_Poll_Response()

      Calls: osFCLayerAsyncEvent()
             osIOCompleted()

-*/

osLOCAL void FWStub_Process_Response(
                                      agRoot_t        *agRoot,
                                      agRpcOutbound_t  RpcOutbound
                                    )
{
    FWStub_Global_NonDMA_t  *Global_NonDMA;
    FWStub_IO_NonDMA_t      *IO_NonDMA;
    agIORequest_t           *agIORequest;
    agRpcReqStatus_t         IO_Status;
    agFcpRspHdr_t           *IO_Response_Hdr;
    FC_FCP_RSP_FCP_STATUS_t *IO_Response_Status;
    os_bit32                 IO_Info_Len;

    if (    ( (RpcOutbound & agRpcOutbound_ReqStatus_MASK) >> agRpcOutbound_ReqStatus_SHIFT )
         == agRpcReqStatusLinkEvent                                                           )
    {
        osFCLayerAsyncEvent(
                             agRoot,
                             osFCLinkUp
                           );

        return;
    }

    Global_NonDMA = FWStub_Global_NonDMA(agRoot);

    IO_NonDMA = FWStub_IO_NonDMA(
                                  Global_NonDMA,
                                  ( (RpcOutbound & agRpcOutbound_ReqID_MASK) >> agRpcOutbound_ReqID_SHIFT )
                                );

    agIORequest = IO_NonDMA->agIORequest;

    if (IO_NonDMA->Aborted == agFALSE)
    {
        IO_Status = ( (RpcOutbound & agRpcOutbound_ReqStatus_MASK) >> agRpcOutbound_ReqStatus_SHIFT );

        if (IO_Status == agRpcReqStatusOK)
        {
            osIOCompleted(
                           agRoot,
                           agIORequest,
                           osIOSuccess,
                           0
                         );
        }
        else if (IO_Status == agRpcReqStatusOK_Info)
        {
            IO_Response_Hdr = (agFcpRspHdr_t *)(IO_NonDMA->Info);

            IO_Response_Status = (FC_FCP_RSP_FCP_STATUS_t *)(IO_Response_Hdr->FcpStatus);

            IO_Info_Len = sizeof(agFcpRspHdr_t);

            if (IO_Response_Status->ValidityStatusIndicators & FC_FCP_RSP_FCP_STATUS_ValidityStatusIndicators_FCP_SNS_LEN_VALID)
            {
                IO_Info_Len +=   (IO_Response_Hdr->FcpSnsLen[0] << 24)
                               + (IO_Response_Hdr->FcpSnsLen[1] << 16)
                               + (IO_Response_Hdr->FcpSnsLen[2] <<  8)
                               + (IO_Response_Hdr->FcpSnsLen[3] <<  0);
            }

            if (IO_Response_Status->ValidityStatusIndicators & FC_FCP_RSP_FCP_STATUS_ValidityStatusIndicators_FCP_RSP_LEN_VALID)
            {
                IO_Info_Len +=   (IO_Response_Hdr->FcpRspLen[0] << 24)
                               + (IO_Response_Hdr->FcpRspLen[1] << 16)
                               + (IO_Response_Hdr->FcpRspLen[2] <<  8)
                               + (IO_Response_Hdr->FcpRspLen[3] <<  0);
            }

            osIOCompleted(
                           agRoot,
                           agIORequest,
                           osIOSuccess,
                           IO_Info_Len
                         );
        }
        else if (IO_Status == agRpcReqStatusIOPortGone)
        {
            osIOCompleted(
                           agRoot,
                           agIORequest,
                           osIODevGone,
                           0
                         );
        }
        else if (IO_Status == agRpcReqStatusIOPortReset)
        {
            osIOCompleted(
                           agRoot,
                           agIORequest,
                           osIODevReset,
                           0
                         );
        }
        else if (IO_Status == agRpcReqStatusIOInfoBad)
        {
            osIOCompleted(
                           agRoot,
                           agIORequest,
                           osIOInfoBad,
                           0
                         );
        }
        else if (IO_Status == agRpcReqStatusIOOverUnder)
        {
            osIOCompleted(
                           agRoot,
                           agIORequest,
                           osIOOverUnder,
                           0
                         );
        }
        else /* IO_Status == ?? */
        {
            osIOCompleted(
                           agRoot,
                           agIORequest,
                           osIOFailed,
                           0
                         );
        }
    }
    else /* IO_NonDMA->Aborted == agTRUE */
    {
        osIOCompleted(
                       agRoot,
                       agIORequest,
                       osIOAborted,
                       0
                     );

        IO_NonDMA->Aborted = agFALSE;
    }

    IO_NonDMA->agIORequest = (agIORequest_t *)agNULL;
    IO_NonDMA->Active      = agFALSE;

    agIORequest->fcData = (void *)agNULL;

    IO_NonDMA->Next         = Global_NonDMA->First_IO;
    Global_NonDMA->First_IO = IO_NonDMA;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\fwstub.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/FWStub.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 8/07/00 4:57p   $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures used by ../C/FWStub.C

--*/

#ifndef __FWStub_H__

#define __FWStub_H__

#include "I21554.h"

/*+
    Re-order the following #define/#undef pairs for the desired tuning
-*/

#ifdef  FWStub_Use_Fast_Path 
#undef  FWStub_Use_Fast_Path
#endif  /* FWStub_Use_Fast_Path was defined */

#ifndef FWStub_Use_Fast_Path 
#define FWStub_Use_Fast_Path
#endif  /* FWStub_Use_Fast_Path was defined */

#ifndef FWStub_Tune_for_One_INT_per_IO 
#define FWStub_Tune_for_One_INT_per_IO
#endif  /* FWStub_Tune_for_One_INT_per_IO was defined */

#ifdef  FWStub_Tune_for_One_INT_per_IO 
#undef  FWStub_Tune_for_One_INT_per_IO
#endif  /* FWStub_Tune_for_One_INT_per_IO was defined */

/*+
    Define crude size macros (rather than using osAdjustParameterBit32() calls for now)
-*/

#define FWStub_NumDevices 0x80

#define FWStub_NumIOs     0x400

#define FWStub_MaxSGL     0x20

#define FWStub_MaxInfo    (0x20 + 0x100)

/*+
    Define macros used to send & receive messages to/from Embedded CPU
-*/

#define FWStub_AllocInbound(agR) \
            osChipMemReadBit32(agR,agFieldOffset(I21554_CSR_t,I2O_Inbound_Queue))

#define FWStub_PostInbound(agR,Inb) \
            osChipMemWriteBit32(agR,agFieldOffset(I21554_CSR_t,I2O_Inbound_Queue),Inb)

#define FWStub_FetchOutbound(agR) \
            osChipMemReadBit32(agR,agFieldOffset(I21554_CSR_t,I2O_Outbound_Queue))

#define FWStub_AckOutbound(agR) \
            osChipMemWriteBit32(agR,agFieldOffset(I21554_CSR_t,I2O_Outbound_Queue),0)

/*+
    Declare per-IO Data Structures
-*/

typedef struct FWStub_IO_NonDMA_s
               FWStub_IO_NonDMA_t;

typedef struct FWStub_IO_DMA_s
               FWStub_IO_DMA_t;

struct FWStub_IO_NonDMA_s
       {
         FWStub_IO_NonDMA_t    *Next;
         FWStub_IO_DMA_t       *DMA;
         os_bit32               DMA_Lower32;
         agRpcReqID_t           ReqID;
         agIORequest_t         *agIORequest;
         agBOOLEAN              Active;
         agBOOLEAN              Aborted;
         FC_FCP_CMND_Payload_t *FCP_CMND;
         agRpcSGL_t            *SGL;
         os_bit8               *Info;
       };

struct FWStub_IO_DMA_s
       {
         agRpcReqDoSCSI_t ReqDoSCSI;
         agRpcSGL_t       SGL[FWStub_MaxSGL-1];
         os_bit8          Info[FWStub_MaxInfo];
       };

/*+
    Declare Global Data Structures
-*/

typedef struct FWStub_Global_NonDMA_s
               FWStub_Global_NonDMA_t;

typedef struct FWStub_Global_DMA_s
               FWStub_Global_DMA_t;

struct FWStub_Global_NonDMA_s
       {
         FWStub_Global_DMA_t *DMA;
         os_bit32             DMA_Lower32;
         agBOOLEAN            sysIntsActive;
#ifdef FWStub_Tune_for_One_INT_per_IO
         agRpcOutbound_t      agRpcOutbound;
#endif /* FWStub_Tune_for_One_INT_per_IO was defined */
         FWStub_IO_NonDMA_t  *First_IO;
         FWStub_IO_NonDMA_t   IOs[FWStub_NumIOs];
       };

struct FWStub_Global_DMA_s
       {
         union
         {
           agRpcReqAbort_t          ReqAbort;
           agRpcReqGetChannelInfo_t ReqGetChannelInfo;
           agRpcReqGetPortInfo_t    ReqGetPortInfo;
           agRpcReqGetPorts_t       ReqGetPorts;
           agRpcReqResetChannel_t   ReqResetChannel;
           agRpcReqResetPort_t      ReqResetPort;
           agRpcReqSetupFastPath_t  ReqSetupFastPath;
         }                                                      Request;
         union
         {
           agFCDev_t                Devices[FWStub_NumDevices];
           agFCChanInfo_t           ChanInfo;
           agFCDevInfo_t            DevInfo;
         }                                                      RequestInfo;
         FWStub_IO_DMA_t                                        IOs[FWStub_NumIOs];
       };

/*+
    Declare Miscellaneous Macros to walk Data Structures
-*/

#define FWStub_Global_NonDMA(agR) \
            ((FWStub_Global_NonDMA_t *)(((agRoot_t *)agR)->fcData))

#define FWStub_IO_NonDMA_from_agIORequest(agR) \
            ((FWStub_IO_NonDMA_t *)(((agIORequest_t *)agR)->fcData))

#define FWStub_Global_ReqID \
            ((agRpcReqID_t)(FWStub_NumIOs + 1))

#define FWStub_IO_NonDMA(Glob,ReqID) \
            ((FWStub_IO_NonDMA_t *)(&(((FWStub_Global_NonDMA_t *)(Glob))->IOs[(((ReqID) & ~agRpcReqIDFast) - 1)])))

#define FWStub_IO_DMA(Glob,ReqID) \
            ((FWStub_IO_DMA_t *)(&(((FWStub_Global_DMA_t *)(Glob))->IOs[(((ReqID) & ~agRpcReqIDFast) - 1)])))

#define FWStub_IO_DMA_Lower32(Glob,ReqID) \
            (((os_bit32)(Glob)) + agFieldOffset(FWStub_Global_DMA_t,IOs[(((ReqID) & ~agRpcReqIDFast) - 1)]))

#define FWStub_IO_DMA_FCP_CMND(IO) \
            ((FC_FCP_CMND_Payload_t *)(&(((FWStub_IO_DMA_t *)(IO))->ReqDoSCSI.FCP_CMND)))

#define FWStub_IO_DMA_FCP_CMND_Lower32(IO_Lower32) \
            (((os_bit32)(IO_Lower32)) + agFieldOffset(FWStub_IO_DMA_t,ReqDoSCSI.FCP_CMND))

#define FWStub_IO_DMA_SGL(IO) \
            ((agRpcSGL_t *)(&(((FWStub_IO_DMA_t *)(IO))->ReqDoSCSI.SGL[0])))

#define FWStub_IO_DMA_SGL_Lower32(IO_Lower32) \
            (((os_bit32)(IO_Lower32)) + agFieldOffset(FWStub_IO_DMA_t,ReqDoSCSI.SGL[0]))

#define FWStub_IO_DMA_Info(IO) \
            ((os_bit8 *)(&(((FWStub_IO_DMA_t *)(IO))->Info)))

#define FWStub_IO_DMA_Info_Lower32(IO_Lower32) \
            (((os_bit32)(IO_Lower32)) + agFieldOffset(FWStub_IO_DMA_t,Info))

#define FWStub_IO_DMA_SIZE(NumSGL) \
            ((os_bit32)(sizeof(agRpcReqDoSCSI_t) + (((NumSGL) - 1)*sizeof(agRpcSGL_t))))

/*+
    Resultant Macros to return from fcInitializeDriver()
-*/

#define FWStub_cachedMemoryNeeded   (os_bit32)(sizeof(FWStub_Global_NonDMA_t))
#define FWStub_cachedMemoryPtrAlign (os_bit32)1
#define FWStub_dmaMemoryNeeded      (os_bit32)(sizeof(FWStub_Global_DMA_t))
#define FWStub_dmaMemoryPtrAlign    (os_bit32)1
#define FWStub_dmaMemoryPhyAlign    (os_bit32)1
#define FWStub_nvMemoryNeeded       (os_bit32)0
#define FWStub_usecsPerTick         (os_bit32)1000000

/*+
    Internal Function Prototypes
-*/

#define FWStub_Send_Request_Retries_DEFAULT    (os_bit32)10
#define FWStub_Send_Request_RetryStall_DEFAULT (os_bit32)1000

osLOCAL agBOOLEAN FWStub_Send_Request(
                                       agRoot_t     *agRoot,
                                       agRpcReqID_t  ReqID,
                                       os_bit32      ReqLen,
                                       os_bit32      ReqAddr_Lower32,
                                       os_bit32      Retries,
                                       os_bit32      RetryStall
                                     );

#define FWStub_Poll_Response_RetryStall_DEFAULT (os_bit32)1000

osLOCAL agRpcOutbound_t FWStub_Poll_Response(
                                              agRoot_t     *agRoot,
                                              agRpcReqID_t  ReqID,
                                              agBOOLEAN     DisposeOtherReqIDs,
                                              os_bit32      RetryStall
                                            );

osLOCAL void FWStub_Process_Response(
                                      agRoot_t        *agRoot,
                                      agRpcOutbound_t  RpcOutbound
                                    );

#endif /* __FWStub_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\globals.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/Globals.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 3/20/01 3:32p   $ (Last Modified)

Purpose:

  This is the Master Include File for the Fibre Channel HBA Source Code.

  This file should be included by every module to ensure a uniform definition
  of all data types, data structures, and externals.

  This file includes six separate files:

    ..\..\OSLayer\H\OSTypes.H
        - defines basic data types in the OS-specific environment
    FCStruct.H
        - defines Fibre Channel Standards data types
    FmtFill.H
        - defines API of hpFmtFill()
    FcApi.H
        - allows FCLayer-specific overrides to its API
    ..\..\OSLayer\H\OsApi.H
        - allows OSLayer-specific overrides to its API
    FWSpec.H
        - defines API shared with Embedded Firmware implementations

--*/

#ifndef __Globals_H__

#define __Globals_H__

#ifdef _DvrArch_1_20_
/*
 * Include OSLayer-specific data types .H File
 *
 * This file must provide definitions for:
 *
 *    os_bit8   - unsigned 8-bit value
 *    os_bit16  - unsigned 16-bit value
 *    os_bit32  - unsigned 32-bit value
 *    os_bitptr - unsigned value identical in width to a pointer
 *    osGLOBAL  - used to declare a 'C' item external to a module
 *    osLOCAL   - used to declare a 'C' item local to a module
 */
#else  /* _DvrArch_1_20_ was not defined */
/*
 * Include OSLayer-specific data types .H File
 *
 * This file must provide definitions for:
 *
 *    bit8    - unsigned 8-bit value
 *    bit16   - unsigned 16-bit value
 *    bit32   - unsigned 32-bit value
 *    pbit8   - pointer to an unsigned 8-bit value
 *    pbit16  - pointer to an unsigned 16-bit value
 *    pbit32  - pointer to an unsigned 32-bit value
 *    NULL    - used to declare a wildcard pointer which is empty
 *    BOOLEAN - logical value (TRUE or FALSE)
 *    TRUE    - will always satisfy an <if> condition
 *    FALSE   - will never satisfy an <if> condition
 *    GLOBAL  - used to declare a 'C' function external to a module
 *    LOCAL   - used to declare a 'C' function local to a module
 */
#endif /* _DvrArch_1_20_ was not defined */
#ifndef _New_Header_file_Layout_

#include "../../oslayer/h/ostypes.h"
#else /* _New_Header_file_Layout_ */

#include "ostypes.h"
#endif  /* _New_Header_file_Layout_ */

/*
 * Include Fibre Channel Standards .H File
 */

#include "fcstruct.h"

/*
 * Define each Global Data Structure
 */

#ifdef _DvrArch_1_20_
#define agBOOLEAN os_bit32

#define agTRUE    (agBOOLEAN)1
#define agFALSE   (agBOOLEAN)0

#define agNULL    (void *)0
#endif /* _DvrArch_1_20_ was defined */

/* SNIA defines */

#ifndef HBA_API_H

#define HBA_PORTTYPE_UNKNOWN            1 /* Unknown */
#define HBA_PORTTYPE_OTHER              2 /* Other */
#define HBA_PORTTYPE_NOTPRESENT         3 /* Not present */
#define HBA_PORTTYPE_NPORT              5 /* Fabric  */
#define HBA_PORTTYPE_NLPORT             6 /* Public Loop */
#define HBA_PORTTYPE_FLPORT             7
#define HBA_PORTTYPE_FPORT              8 /* Fabric Port */
#define HBA_PORTTYPE_EPORT              9 /* Fabric expansion port */
#define HBA_PORTTYPE_GPORT              10 /* Generic Fabric Port */
#define HBA_PORTTYPE_LPORT              20 /* Private Loop */
#define HBA_PORTTYPE_PTP                21 /* Point to Point */


#define HBA_PORTSTATE_UNKNOWN           1 /* Unknown */
#define HBA_PORTSTATE_ONLINE            2 /* Operational */
#define HBA_PORTSTATE_OFFLINE           3 /* User Offline */
#define HBA_PORTSTATE_BYPASSED          4 /* Bypassed */
#define HBA_PORTSTATE_DIAGNOSTICS       5 /* In diagnostics mode */
#define HBA_PORTSTATE_LINKDOWN          6 /* Link Down */
#define HBA_PORTSTATE_ERROR             7 /* Port Error */
#define HBA_PORTSTATE_LOOPBACK          8 /* Loopback */


#define HBA_PORTSPEED_1GBIT             1 /* 1 GBit/sec */
#define HBA_PORTSPEED_2GBIT             2 /* 2 GBit/sec */
#define HBA_PORTSPEED_10GBIT            4 /* 10 GBit/sec */

#define HBA_EVENT_LIP_OCCURRED          1
#define HBA_EVENT_LINK_UP               2
#define HBA_EVENT_LINK_DOWN             3
#define HBA_EVENT_LIP_RESET_OCCURRED    4
#define HBA_EVENT_RSCN                  5
#define HBA_EVENT_PROPRIETARY           0xFFFF

/* End  SNIA defines */
#endif /* HBA_API_H */


#ifdef _DvrArch_1_20_
typedef struct agFCChanInfo_s
               agFCChanInfo_t;

struct agFCChanInfo_s
        {
            os_bit8                  NodeWWN[8];
            os_bit8                  PortWWN[8];
            struct
            {
                os_bit8 reserved;
                os_bit8 Domain;
                os_bit8 Area;
                os_bit8 AL_PA;
            }                        CurrentAddress;
            struct
            {
                os_bit8 reserved;
                os_bit8 Domain;
                os_bit8 Area;
                os_bit8 AL_PA;
            }                        HardAddress;
            agBOOLEAN                LinkUp;
            os_bit32                 MaxFrameSize;
            os_bit32                 ReadsRequested;
            os_bit32                 ReadsCompleted;
            os_bit32                 ReadFailures;
            os_bit32                 BytesReadUpper32;
            os_bit32                 BytesReadLower32;
            os_bit32                 WritesRequested;
            os_bit32                 WritesCompleted;
            os_bit32                 WriteFailures;
            os_bit32                 BytesWrittenUpper32;
            os_bit32                 BytesWrittenLower32;
            os_bit32                 NonRWRequested;
            os_bit32                 NonRWCompleted;
            os_bit32                 NonRWFailures;
            FC_N_Port_Common_Parms_t N_Port_Common_Parms;
            FC_N_Port_Class_Parms_t  N_Port_Class_1_Parms;
            FC_N_Port_Class_Parms_t  N_Port_Class_2_Parms;
            FC_N_Port_Class_Parms_t  N_Port_Class_3_Parms;

    /* SNIA port attributes */
            os_bit8                 FabricName[8];
            os_bit32                PortType;                       /*PTP, Fabric, etc. */
            os_bit32                PortState;
            os_bit32                PortSupportedClassofService;    /* Class of Service Values - See GS-2 Spec.*/
            os_bit8                 PortSupportedFc4Types[32];      /* 32 bytes of FC-4 per GS-2 */
            os_bit8                 PortActiveFc4Types[32];         /* 32 bytes of FC-4 per GS-2 */
            os_bit32                PortSupportedSpeed;
            os_bit32                PortSpeed;

    /* SNIA port statistics */
            os_bit32                TxFramesUpper;
            os_bit32                TxFramesLower;
            os_bit32                TxWordsUpper;
            os_bit32                TxWordsLower;
            os_bit32                RxFramesUpper;
            os_bit32                RxFramesLower;
            os_bit32                RxWordsUpper;
            os_bit32                RxWordsLower;
            os_bit32                LIPCountUpper;
            os_bit32                LIPCountLower;
            os_bit32                NOSCountUpper;
            os_bit32                NOSCountLower;
            os_bit32                ErrorFramesUpper;
            os_bit32                ErrorFramesLower;                   /* Link_Status_3_Exp_Frm Link_Status_2_Rx_EOFa */
            os_bit32                DumpedFramesUpper;
            os_bit32                DumpedFramesLower;                  /* Link_Status_2_Dis_Frm */
            os_bit32                LinkFailureCountUpper;
            os_bit32                LinkFailureCountLower;              /* Link_Status_1_Link_Fail */
            os_bit32                LossOfSyncCountUpper;
            os_bit32                LossOfSyncCountLower;               /* Link_Status_1_Loss_of_Sync */
            os_bit32                LossOfSignalCountUpper;
            os_bit32                LossOfSignalCountLower;             /* Link_Status_1_Loss_of_Signal */
            os_bit32                PrimitiveSeqProtocolErrCountUpper;
            os_bit32                PrimitiveSeqProtocolErrCountLower;  /* Link_Status_2_Proto_Err */
            os_bit32                InvalidRxWordCountUpper;
            os_bit32                InvalidRxWordCountLower;            /* Link_Status_1_Bad_RX_Char */
            os_bit32                InvalidCRCCountUpper;
            os_bit32                InvalidCRCCountLower;               /* Link_Status_2_Bad_CRC */

       };
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpFCChanInfo_s
               hpFCChanInfo_t;

struct hpFCChanInfo_s {
                        bit8                     NodeWWN[8];
                        bit8                     PortWWN[8];
                        struct {
                                 bit8 reserved;
                                 bit8 Domain;
                                 bit8 Area;
                                 bit8 AL_PA;
                               }                 CurrentAddress;
                        struct {
                                 bit8 reserved;
                                 bit8 Domain;
                                 bit8 Area;
                                 bit8 AL_PA;
                               }                 HardAddress;
                        BOOLEAN                  LinkUp;
                        bit32                    MaxFrameSize;
                        bit32                    ReadsRequested;
                        bit32                    ReadsCompleted;
                        bit32                    ReadFailures;
                        bit32                    BytesReadUpper32;
                        bit32                    BytesReadLower32;
                        bit32                    WritesRequested;
                        bit32                    WritesCompleted;
                        bit32                    WriteFailures;
                        bit32                    BytesWrittenUpper32;
                        bit32                    BytesWrittenLower32;
                        bit32                    NonRWRequested;
                        bit32                    NonRWCompleted;
                        bit32                    NonRWFailures;
                        FC_N_Port_Common_Parms_t N_Port_Common_Parms;
                        FC_N_Port_Class_Parms_t  N_Port_Class_1_Parms;
                        FC_N_Port_Class_Parms_t  N_Port_Class_2_Parms;
                        FC_N_Port_Class_Parms_t  N_Port_Class_3_Parms;
                      };
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef void * agFCDev_t;
#else  /* _DvrArch_1_20_ was not defined */
typedef void * hpFCDev_t;
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
#define agDevUnknown       0x00000000
#define agDevSelf          0x00000001
#define agDevSCSIInitiator 0x00000002
#define agDevSCSITarget    0x00000004

typedef struct agFCDevInfo_s
               agFCDevInfo_t;

struct agFCDevInfo_s
       {
         os_bit8                  NodeWWN[8];
         os_bit8                  PortWWN[8];
         struct
         {
           os_bit8 reserved;
           os_bit8 Domain;
           os_bit8 Area;
           os_bit8 AL_PA;
         }                        CurrentAddress;
         struct
         {
           os_bit8 reserved;
           os_bit8 Domain;
           os_bit8 Area;
           os_bit8 AL_PA;
         }                        HardAddress;
         agBOOLEAN                Present;
         agBOOLEAN                LoggedIn;
         os_bit32                 LoginRetries;
         os_bit32                 ClassOfService;
         os_bit32                 MaxFrameSize;
         os_bit32                 DeviceType;
         os_bit32                 ReadsRequested;
         os_bit32                 ReadsCompleted;
         os_bit32                 ReadFailures;
         os_bit32                 BytesReadUpper32;
         os_bit32                 BytesReadLower32;
         os_bit32                 WritesRequested;
         os_bit32                 WritesCompleted;
         os_bit32                 WriteFailures;
         os_bit32                 BytesWrittenUpper32;
         os_bit32                 BytesWrittenLower32;
         os_bit32                 NonRWRequested;
         os_bit32                 NonRWCompleted;
         os_bit32                 NonRWFailures;
         FC_N_Port_Common_Parms_t N_Port_Common_Parms;
         FC_N_Port_Class_Parms_t  N_Port_Class_1_Parms;
         FC_N_Port_Class_Parms_t  N_Port_Class_2_Parms;
         FC_N_Port_Class_Parms_t  N_Port_Class_3_Parms;
    /* SNIA port attributes */
         os_bit8                 FabricName[8];
         os_bit32                PortType;                       /*PTP, Fabric, etc. */
         os_bit32                PortState;
         os_bit32                PortSupportedClassofService;    /* Class of Service Values - See GS-2 Spec.*/
         os_bit8                 PortSupportedFc4Types[32];      /* 32 bytes of FC-4 per GS-2 */
         os_bit8                 PortActiveFc4Types[32];         /* 32 bytes of FC-4 per GS-2 */
         os_bit32                PortSupportedSpeed;
         os_bit32                PortSpeed;

       };
#else  /* _DvrArch_1_20_ was not defined */
#define hpDevUnknown       0x00000000
#define hpDevSelf          0x00000001
#define hpDevSCSIInitiator 0x00000002
#define hpDevSCSITarget    0x00000004

typedef struct hpFCDevInfo_s
               hpFCDevInfo_t;

struct hpFCDevInfo_s {
                       bit8                     NodeWWN[8];
                       bit8                     PortWWN[8];
                       struct {
                                bit8 reserved;
                                bit8 Domain;
                                bit8 Area;
                                bit8 AL_PA;
                              }                 CurrentAddress;
                       struct {
                                bit8 reserved;
                                bit8 Domain;
                                bit8 Area;
                                bit8 AL_PA;
                              }                 HardAddress;
                       BOOLEAN                  Present;
                       BOOLEAN                  LoggedIn;
                       bit32                    LoginRetries;
                       bit32                    ClassOfService;
                       bit32                    MaxFrameSize;
                       bit32                    DeviceType;
                       bit32                    ReadsRequested;
                       bit32                    ReadsCompleted;
                       bit32                    ReadFailures;
                       bit32                    BytesReadUpper32;
                       bit32                    BytesReadLower32;
                       bit32                    WritesRequested;
                       bit32                    WritesCompleted;
                       bit32                    WriteFailures;
                       bit32                    BytesWrittenUpper32;
                       bit32                    BytesWrittenLower32;
                       bit32                    NonRWRequested;
                       bit32                    NonRWCompleted;
                       bit32                    NonRWFailures;
                       FC_N_Port_Common_Parms_t N_Port_Common_Parms;
                       FC_N_Port_Class_Parms_t  N_Port_Class_1_Parms;
                       FC_N_Port_Class_Parms_t  N_Port_Class_2_Parms;
                       FC_N_Port_Class_Parms_t  N_Port_Class_3_Parms;
                     };
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
#define agFcpCntlReadData  0x02
#define agFcpCntlWriteData 0x01

typedef struct agFcpCmnd_s
               agFcpCmnd_t;

struct agFcpCmnd_s
       {
         os_bit8 FcpLun[8];
         os_bit8 FcpCntl[4];
         os_bit8 FcpCdb[16];
         os_bit8 FcpDL[4];
       };
#else  /* _DvrArch_1_20_ was not defined */

#define hpFcpCntlReadData        0x02
#define hpFcpCntlWriteData       0x01

typedef struct hpFcpCmnd_s
               hpFcpCmnd_t;

struct hpFcpCmnd_s {
                     bit8 FcpLun[8];
                     bit8 FcpCntl[4];
                     bit8 FcpCdb[16];
                     bit8 FcpDL[4];
                   };
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef struct agCDBRequest_s
               agCDBRequest_t;

struct agCDBRequest_s
       {
         agFcpCmnd_t FcpCmnd;
       };
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpCDBRequest_s
               hpCDBRequest_t;

struct hpCDBRequest_s {
                        hpFcpCmnd_t FcpCmnd;
                      };
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef struct agFcpRspHdr_s
               agFcpRspHdr_t;

struct agFcpRspHdr_s
       {
         os_bit32 FrameHeader[8];
         os_bit8  reserved[8];
         os_bit8  FcpStatus[4];
         os_bit8  FcpResId[4];
         os_bit8  FcpSnsLen[4];
         os_bit8  FcpRspLen[4];
       };
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpFcpRspHdr_s
               hpFcpRspHdr_t;

struct hpFcpRspHdr_s {
                       bit32 FrameHeader[8];
                       bit8  reserved[8];
                       bit8  FcpStatus[4];
                       bit8  FcpResId[4];
                       bit8  FcpSnsLen[4];
                       bit8  FcpRspLen[4];
                     };
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef struct agIORequest_s
               agIORequest_t;

struct agIORequest_s
       {
         void *fcData;
         void *osData;
       };
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpIORequest_s
               hpIORequest_t;

struct hpIORequest_s {
                       void *fcData;
                       void *osData;
                     };
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef union agIORequestBody_u
              agIORequestBody_t;

union agIORequestBody_u
      {
        agCDBRequest_t CDBRequest;
      };
#else  /* _DvrArch_1_20_ was not defined */
typedef union hpIORequestBody_u
              hpIORequestBody_t;

union hpIORequestBody_u {
                          hpCDBRequest_t CDBRequest;
                        };
#endif /* _DvrArch_1_20_ was not defined */

#ifdef _DvrArch_1_20_
typedef struct agRoot_s
               agRoot_t;

struct agRoot_s
       {
         void *fcData;
         void *osData;
       };
#else  /* _DvrArch_1_20_ was not defined */
typedef struct hpRoot_s
               hpRoot_t;

struct hpRoot_s {
                  void *fcData;
                  void *osData;
                };
#endif /* _DvrArch_1_20_ was not defined */

/*+
Data Type/Structure Addressing & Bit-Manipulation Macros
-*/

/* Begin: Big_Endian_Code */
#ifndef hpBigEndianCPU   /* hpBigEndianCPU */

#ifdef _DvrArch_1_20_

#define hpSwapBit16(toSwap)                       \
            ( ((((os_bit16)toSwap) & 0x00FF) << 8) | \
              ((((os_bit16)toSwap) & 0xFF00) >> 8) )

#define hpSwapBit32(toSwap)                            \
            ( ((((os_bit32)toSwap) & 0x000000FF) << 24) | \
              ((((os_bit32)toSwap) & 0x0000FF00) <<  8) | \
              ((((os_bit32)toSwap) & 0x00FF0000) >>  8) | \
              ((((os_bit32)toSwap) & 0xFF000000) >> 24) )

#else  /* _DvrArch_1_20_ was not defined */

#define hpSwapBit16(toSwap)                       \
            ( ((((bit16)toSwap) & 0x00FF) << 8) | \
              ((((bit16)toSwap) & 0xFF00) >> 8) )

#define hpSwapBit32(toSwap)                            \
            ( ((((bit32)toSwap) & 0x000000FF) << 24) | \
              ((((bit32)toSwap) & 0x0000FF00) <<  8) | \
              ((((bit32)toSwap) & 0x00FF0000) >>  8) | \
              ((((bit32)toSwap) & 0xFF000000) >> 24) )

#endif /* _DvrArch_1_20_ was not defined */

#else                    /* hpBigEndianCPU */

#define hpSwapBit16(NottoSwap)  NottoSwap
#define hpSwapBit32(NottoSwap)  NottoSwap

#endif                   /* hpBigEndianCPU */
/* End: Big_Endian_Code */

#ifdef _DvrArch_1_20_

#define hpFieldOffset(baseType,fieldName) \
            ((os_bit32)((os_bitptr)(&(((baseType *)0)->fieldName))))

#define hpObjectBase(baseType,fieldName,fieldPtr) \
            ((baseType *)((os_bit8 *)(fieldPtr) - ((os_bitptr)(&(((baseType *)0)->fieldName)))))

#define agFieldOffset(baseType,fieldName) \
            ((os_bit32)((os_bitptr)(&(((baseType *)0)->fieldName))))

#define agObjectBase(baseType,fieldName,fieldPtr) \
            ((baseType *)((os_bit8 *)(fieldPtr) - ((os_bitptr)(&(((baseType *)0)->fieldName)))))

#else  /* _DvrArch_1_20_ was not defined */

#define hpFieldOffset(baseType,fieldName) \
            ((bit32)(&(((baseType *)0)->fieldName)))

#define hpObjectBase(baseType,fieldName,fieldPtr) \
            ((baseType *)((bit8 *)fieldPtr - hpFieldOffset(baseType,fieldName)))

#endif /* _DvrArch_1_20_ was not defined */

/*
 * Include hpFmtFill() API .H File
 */

#include "fmtfill.h"

/*
 * Include FCLayer-specific API .H File
 */

#include "fcapi.h"

/*
 * Define (default) FCLayer API
 */

typedef void * fiFrameHandle_t;

#ifdef _DvrArch_1_20_
typedef void (*fiFrameProcessorFunction_t)(
                                            agRoot_t        *agRoot,
                                            os_bit32         fiD_ID,
                                            os_bit16         fiOX_ID,
                                            fiFrameHandle_t  fiFrame
                                          );
#else  /* _DvrArch_1_20_ was not defined */
typedef void (*fiFrameProcessorFunction_t)(
                                            hpRoot_t        *hpRoot,
                                            bit32            fiD_ID,
                                            bit16            fiOX_ID,
                                            fiFrameHandle_t  fiFrame
                                          );
#endif /* _DvrArch_1_20_ was not defined */

#ifndef fcAbortIO
#ifdef _DvrArch_1_20_
osGLOBAL void fcAbortIO(
                         agRoot_t      *agRoot,
                         agIORequest_t *agIORequest
                       );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void fcAbortIO(
                       hpRoot_t      *hpRoot,
                       hpIORequest_t *hpIORequest
                     );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcAbortIO */

#ifdef _DvrArch_1_30_

#define FC_CMND_STATUS_SUCCESS     0x00
#define FC_CMND_STATUS_TIMEDOUT    0x01
#define FC_CMND_STATUS_CANCELED    0x02

#define fcQPairID_IP     0x00000000

#define fcBindQSuccess   0x00000000
#define fcBindQInvalidID 0x00000001

#if 0
#ifndef fcBindToWorkQs
osGLOBAL os_bit32 fcBindToWorkQs(
                                  agRoot_t  *agRoot,
                                  os_bit32   agQPairID,
                                  void     **agInboundQBase,
                                  os_bit32   agInboundQEntries,
                                  os_bit32  *agInboundQProdIndex,
                                  os_bit32  *agInboundQConsIndex,
                                  void     **agOutboundQBase,
                                  os_bit32   agOutboundQEntries,
                                  os_bit32  *agOutboundQProdIndex,
                                  os_bit32  *agOutboundQConsIndex
                                );

#endif  /* ~fcBindToWorkQs */

#endif /* 0 */

#endif /* _DvrArch_1_30_ was defined */

#ifndef fcCardSupported
#ifdef _DvrArch_1_20_
osGLOBAL agBOOLEAN fcCardSupported(
                                    agRoot_t *agRoot
                                  );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL BOOLEAN fcCardSupported(
                                hpRoot_t *hpRoot
                              );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcCardSupported */

#ifndef fcDelayedInterruptHandler
#ifdef _DvrArch_1_20_
osGLOBAL void fcDelayedInterruptHandler(
                                         agRoot_t *agRoot
                                       );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void fcDelayedInterruptHandler(
                                       hpRoot_t *hpRoot
                                     );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcDelayedInterruptHandler */

#ifndef fcEnteringOS
#ifdef _DvrArch_1_20_
osGLOBAL void fcEnteringOS(
                            agRoot_t *agRoot
                          );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void fcEnteringOS(
                          hpRoot_t *hpRoot
                        );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcEnteringOS */

#define fcChanInfoReturned 0x00000000

#ifndef fcGetChannelInfo
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 fcGetChannelInfo(
                                    agRoot_t       *agRoot,
                                    agFCChanInfo_t *agFCChanInfo
                                  );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 fcGetChannelInfo(
                               hpRoot_t       *hpRoot,
                               hpFCChanInfo_t *hpFCChanInfo
                             );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcGetChannelInfo */

#ifndef fcGetDeviceHandles
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 fcGetDeviceHandles(
                                      agRoot_t  *agRoot,
                                      agFCDev_t  agFCDev[],
                                      os_bit32   maxFCDevs
                                    );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 fcGetDeviceHandles(
                                 hpRoot_t  *hpRoot,
                                 hpFCDev_t  hpFCDev[],
                                 bit32      maxFCDevs
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcGetDeviceHandles */

#define fcGetDevInfoReturned 0x00000000
#define fcGetDevInfoFailed   0x00000001

#ifndef fcGetDeviceInfo
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 fcGetDeviceInfo(
                                   agRoot_t      *agRoot,
                                   agFCDev_t      agFCDev,
                                   agFCDevInfo_t *agFCDevInfo
                                 );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 fcGetDeviceInfo(
                              hpRoot_t      *hpRoot,
                              hpFCDev_t      hpFCDev,
                              hpFCDevInfo_t *hpFCDevInfo
                            );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcGetDeviceInfo */

#define fcSyncInit          0x00000000
#define fcAsyncInit         0x00000001
#define fcSyncAsyncInitMask (fcSyncInit | fcAsyncInit)

#define fcInitializeSuccess 0x00000000
#define fcInitializeFailure 0x00000001

#ifndef fcInializeChannel
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 fcInitializeChannel(
                                       agRoot_t  *agRoot,
                                       os_bit32   initType,
                                       agBOOLEAN  sysIntsActive,
                                       void      *cachedMemoryPtr,
                                       os_bit32   cachedMemoryLen,
                                       os_bit32   dmaMemoryUpper32,
                                       os_bit32   dmaMemoryLower32,
                                       void      *dmaMemoryPtr,
                                       os_bit32   dmaMemoryLen,
                                       os_bit32   nvMemoryLen,
                                       os_bit32   cardRamUpper32,
                                       os_bit32   cardRamLower32,
                                       os_bit32   cardRamLen,
                                       os_bit32   cardRomUpper32,
                                       os_bit32   cardRomLower32,
                                       os_bit32   cardRomLen,
                                       os_bit32   usecsPerTick
                                     );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 fcInitializeChannel(
                                  hpRoot_t *hpRoot,
                                  bit32     initType,
                                  BOOLEAN   sysIntsActive,
                                  void     *cachedMemoryPtr,
                                  bit32     cachedMemoryLen,
                                  bit32     dmaMemoryUpper32,
                                  bit32     dmaMemoryLower32,
                                  void     *dmaMemoryPtr,
                                  bit32     dmaMemoryLen,
                                  bit32     nvMemoryLen,
                                  bit32     cardRamUpper32,
                                  bit32     cardRamLower32,
                                  bit32     cardRamLen,
                                  bit32     cardRomUpper32,
                                  bit32     cardRomLower32,
                                  bit32     cardRomLen,
                                  bit32     usecsPerTick
                                );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcInializeChannel */

#ifndef fcInitializeDriver
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 fcInitializeDriver(
                                      agRoot_t *agRoot,
                                      os_bit32 *cachedMemoryNeeded,
                                      os_bit32 *cachedMemoryPtrAlign,
                                      os_bit32 *dmaMemoryNeeded,
                                      os_bit32 *dmaMemoryPtrAlign,
                                      os_bit32 *dmaMemoryPhyAlign,
                                      os_bit32 *nvMemoryNeeded,
                                      os_bit32 *usecsPerTick
                                    );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 fcInitializeDriver(
                                 hpRoot_t *hpRoot,
                                 bit32    *cachedMemoryNeeded,
                                 bit32    *cachedMemoryPtrAlign,
                                 bit32    *dmaMemoryNeeded,
                                 bit32    *dmaMemoryPtrAlign,
                                 bit32    *dmaMemoryPhyAlign,
                                 bit32    *nvMemoryNeeded,
                                 bit32    *usecsPerTick
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcInitializeDriver */

#ifndef fcInterruptHandler
#ifdef _DvrArch_1_20_
osGLOBAL agBOOLEAN fcInterruptHandler(
                                       agRoot_t *agRoot
                                     );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL BOOLEAN fcInterruptHandler(
                                   hpRoot_t *hpRoot
                                 );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcInterruptHandler */

#ifndef fcIOInfoReadBit8
#ifdef _DvrArch_1_20_
osGLOBAL os_bit8 fcIOInfoReadBit8(
                                   agRoot_t      *agRoot,
                                   agIORequest_t *agIORequest,
                                   os_bit32       fcIOInfoOffset
                                 );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit8 fcIOInfoReadBit8(
                              hpRoot_t      *hpRoot,
                              hpIORequest_t *hpIORequest,
                              bit32          fcIOInfoOffset
                            );
#endif /* _DvrArch_1_20_ was not defined */
#endif /* ~fcIOInfoReadBit8 */

#ifndef fcIOInfoReadBit16
#ifdef _DvrArch_1_20_
osGLOBAL os_bit16 fcIOInfoReadBit16(
                                     agRoot_t      *agRoot,
                                     agIORequest_t *agIORequest,
                                     os_bit32       fcIOInfoOffset
                                   );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit16 fcIOInfoReadBit16(
                                hpRoot_t      *hpRoot,
                                hpIORequest_t *hpIORequest,
                                bit32          fcIOInfoOffset
                              );
#endif /* _DvrArch_1_20_ was not defined */
#endif /* ~fcIOInfoReadBit16 */

#ifndef fcIOInfoReadBit32
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 fcIOInfoReadBit32(
                                     agRoot_t      *agRoot,
                                     agIORequest_t *agIORequest,
                                     os_bit32       fcIOInfoOffset
                                   );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 fcIOInfoReadBit32(
                                hpRoot_t      *hpRoot,
                                hpIORequest_t *hpIORequest,
                                bit32          fcIOInfoOffset
                              );
#endif /* _DvrArch_1_20_ was not defined */
#endif /* ~fcIOInfoReadBit32 */

#ifndef fcIOInfoReadBlock
#ifdef _DvrArch_1_20_
osGLOBAL void fcIOInfoReadBlock(
                                 agRoot_t      *agRoot,
                                 agIORequest_t *agIORequest,
                                 os_bit32       fcIOInfoOffset,
                                 void          *fcIOInfoBuffer,
                                 os_bit32       fcIOInfoBufLen
                               );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void fcIOInfoReadBlock(
                               hpRoot_t      *hpRoot,
                               hpIORequest_t *hpIORequest,
                               bit32          fcIOInfoOffset,
                               void          *fcIOInfoBuffer,
                               bit32          fcIOInfoBufLen
                             );
#endif /* _DvrArch_1_20_ was not defined */
#endif /* ~fcIOInfoReadBlock */

#ifndef fcLeavingOS
#ifdef _DvrArch_1_20_
osGLOBAL void fcLeavingOS(
                           agRoot_t *agRoot
                         );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void fcLeavingOS(
                         hpRoot_t *hpRoot
                       );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcLeavingOS */

#ifdef _DvrArch_1_30_
#ifndef fcProcessInboundQ
osGLOBAL void fcProcessInboundQ(
                                 agRoot_t  *agRoot,
                                 os_bit32   agQPairID
                               );
#endif  /* ~fcProcessInboundQ */
#endif /* _DvrArch_1_30_ was defined */

#define fcSyncReset          0x00000000
#define fcAsyncReset         0x00000001
#define fcSyncAsyncResetMask (fcSyncReset | fcAsyncReset)

#define fcResetSuccess       0x00000000
#define fcResetFailure       0x00000001

#ifndef fcResetChannel
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 fcResetChannel(
                                  agRoot_t *agRoot,
                                  os_bit32  agResetType
                                );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 fcResetChannel(
                             hpRoot_t *hpRoot,
                             bit32     hpResetType
                           );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcResetChannel */




#ifdef _DvrArch_1_20_
#define fcResetAllDevs       (agFCDev_t)(-1)    /* changed to avoid compilation error on IA64 0xFFFFFFFF  */
#else  /* _DvrArch_1_20_ was not defined */
#define fcResetAllDevs       (hpFCDev_t)(-1)    /* changed to avoid compilation error on IA64 0xFFFFFFFF  */
#endif /* _DvrArch_1_20_ was not defined */

#define fcHardReset          0x00000000
#define fcSoftReset          0x00000002
#define fcHardSoftResetMask  (fcHardReset | fcSoftReset)

#ifndef fcResetDevice
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 fcResetDevice(
                                 agRoot_t  *agRoot,
                                 agFCDev_t  agFCDev,
                                 os_bit32   agResetType
                               );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 fcResetDevice(
                            hpRoot_t  *hpRoot,
                            hpFCDev_t  hpFCDev,
                            bit32      hpResetType
                          );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcResetDevice */

#ifndef fcShutdownChannel
#ifdef _DvrArch_1_20_
osGLOBAL void fcShutdownChannel(
                                 agRoot_t *agRoot
                               );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void fcShutdownChannel(
                               hpRoot_t  *hpRoot
                             );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcShutdownChannel */

#define fcIOStarted        0x00000000
#define fcIOBusy           0x00000001
#define fcIOBad            0x00000002
#define fcIONoDevice       0x00000003
#define fcIONoSupport      0x00000004

#define fcCDBRequest       0x00000000

#ifndef fcStartIO
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 fcStartIO(
                             agRoot_t          *agRoot,
                             agIORequest_t     *agIORequest,
                             agFCDev_t          agFCDev,
                             os_bit32           agRequestType,
                             agIORequestBody_t *agRequestBody
                           );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 fcStartIO(
                        hpRoot_t          *hpRoot,
                        hpIORequest_t     *hpIORequest,
                        hpFCDev_t          hpFCDev,
                        bit32              hpRequestType,
                        hpIORequestBody_t *hpRequestBody
                      );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcStartIO */

#ifndef fcSystemInterruptsActive
#ifdef _DvrArch_1_20_
osGLOBAL void fcSystemInterruptsActive(
                                        agRoot_t  *agRoot,
                                        agBOOLEAN  sysIntsActive
                                      );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void fcSystemInterruptsActive(
                                      hpRoot_t *hpRoot,
                                      BOOLEAN   sysIntsActive
                                    );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcSystemInterruptsActive */

#ifndef fcTimerTick
#ifdef _DvrArch_1_20_
osGLOBAL void fcTimerTick(
                           agRoot_t *agRoot
                         );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void fcTimerTick(
                         hpRoot_t *hpRoot
                       );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fcTimerTick */

#define fiAllocOxIDSuccess 0x00000000
#define fiAllocOxIDBusy    0x00000001

#ifndef fiAllocOxID
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 fiAllocOxID(
                               agRoot_t                   *agRoot,
                               os_bit32                    fiD_ID,
                               os_bit16                   *fiOX_ID,
                               fiFrameProcessorFunction_t  fiCallBack
                             );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 fiAllocOxID(
                          hpRoot_t                   *hpRoot,
                          bit32                       fiD_ID,
                          bit16                      *fiOX_ID,
                          fiFrameProcessorFunction_t  fiCallBack
                        );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fiAllocOxID */

#ifndef fiFrameReadBit8
#ifdef _DvrArch_1_20_
osGLOBAL os_bit8 fiFrameReadBit8(
                                  agRoot_t        *agRoot,
                                  fiFrameHandle_t  fiFrame,
                                  os_bit32         fiFrameOffset
                                );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit8 fiFrameReadBit8(
                             hpRoot_t        *hpRoot,
                             fiFrameHandle_t  fiFrame,
                             bit32            fiFrameOffset
                           );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fiFrameReadBit8 */

#ifndef fiFrameReadBit16
#ifdef _DvrArch_1_20_
osGLOBAL os_bit16 fiFrameReadBit16(
                                    agRoot_t        *agRoot,
                                    fiFrameHandle_t  fiFrame,
                                    os_bit32         fiFrameOffset
                                  );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit16 fiFrameReadBit16(
                               hpRoot_t        *hpRoot,
                               fiFrameHandle_t  fiFrame,
                               bit32            fiFrameOffset
                             );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fiFrameReadBit16 */

#ifndef fiFrameReadBit32
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 fiFrameReadBit32(
                                    agRoot_t        *agRoot,
                                    fiFrameHandle_t  fiFrame,
                                    os_bit32         fiFrameOffset
                                  );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 fiFrameReadBit32(
                               hpRoot_t        *hpRoot,
                               fiFrameHandle_t  fiFrame,
                               bit32            fiFrameOffset
                             );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fiFrameReadBit32 */

#ifndef fiFrameReadBlock
#ifdef _DvrArch_1_20_
osGLOBAL void fiFrameReadBlock(
                                agRoot_t        *agRoot,
                                fiFrameHandle_t  fiFrame,
                                os_bit32         fiFrameOffset,
                                void            *fiFrameBuffer,
                                os_bit32         fiFrameBufLen
                              );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void fiFrameReadBlock(
                              hpRoot_t        *hpRoot,
                              fiFrameHandle_t  fiFrame,
                              bit32            fiFrameOffset,
                              void            *fiFrameBuffer,
                              bit32            fiFrameBufLen
                            );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fiFrameReadBlock */

#ifndef fiReturnOxID
#ifdef _DvrArch_1_20_
osGLOBAL void fiReturnOxID(
                            agRoot_t *agRoot,
                            os_bit32  fiD_ID,
                            os_bit16  fiOX_ID
                          );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void fiReturnOxID(
                          hpRoot_t                   *hpRoot,
                          bit32                       fiD_ID,
                          bit16                       fiOX_ID
                        );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fiReturnOxID */

#define fiSendFrameSuccess 0x00000000
#define fiSendFrameBusy    0x00000001

#ifndef fiSendSingleFrame
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 fiSendSingleFrame(
                                     agRoot_t *agRoot,
                                     void     *fiFrame,
                                     os_bit32  fiFrameLen
                                   );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 fiSendSingleFrame(
                                hpRoot_t *hpRoot,
                                void     *fiFrame,
                                bit32     fiFrameLen
                              );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~fiSendSingleFrame */

#ifdef _DvrArch_1_30_

os_bit32 fcIPSend(
                   agRoot_t          *hpRoot,
                   os_bit8           *DestAddress,
                   void              *osData,
           os_bit32           PacketLength
                 );

os_bit32 fcIPReceive(
                      agRoot_t          *hpRoot,
                      void              *osData
                    );

os_bit32 fcIPCancel(
                      agRoot_t          *hpRoot,
                      void              *osData,
              void              *CancelItem
                    );

os_bit32 fcIPStatus(
                      agRoot_t          *hpRoot,
                      void              *osData
                    );

#endif /* _DvrArch_1_30_ was defined */

/*
 * Include OSLayer-specific API .H File
 */
#ifndef _New_Header_file_Layout_
#include "../../oslayer/h/osapi.h"

#else /* _New_Header_file_Layout_ */
#include "osapi.h"

#endif  /* _New_Header_file_Layout_ */


/*
 * Define (default) OSLayer API
 */

#ifndef osAdjustParameterBit32
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 osAdjustParameterBit32(
                                          agRoot_t *agRoot,
                                          char     *paramName,
                                          os_bit32  paramDefault,
                                          os_bit32  paramMin,
                                          os_bit32  paramMax
                                        );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 osAdjustParameterBit32(
                                     hpRoot_t *hpRoot,
                                     char     *paramName,
                                     bit32     paramDefault,
                                     bit32     paramMin,
                                     bit32     paramMax
                                   );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osAdjustParameterBit32 */

#ifndef osAdjustParameterBuffer
#ifdef _DvrArch_1_20_
osGLOBAL void osAdjustParameterBuffer(
                                       agRoot_t *agRoot,
                                       char     *paramName,
                                       void     *paramBuffer,
                                       os_bit32  paramBufLen
                                     );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osAdjustParameterBuffer(
                                     hpRoot_t *hpRoot,
                                     char     *paramName,
                                     void     *paramBuffer,
                                     bit32     paramBufLen
                                   );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osAdjustParameterBuffer */

#ifndef osCardRamReadBit8
#ifdef _DvrArch_1_20_
osGLOBAL os_bit8 osCardRamReadBit8(
                                    agRoot_t *agRoot,
                                    os_bit32  cardRamOffset
                                  );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit8 osCardRamReadBit8(
                               hpRoot_t *hpRoot,
                               bit32     cardRamOffset
                             );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRamReadBit8 */

#ifndef osCardRamReadBit16
#ifdef _DvrArch_1_20_
osGLOBAL os_bit16 osCardRamReadBit16(
                                      agRoot_t *agRoot,
                                      os_bit32  cardRamOffset
                                    );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit16 osCardRamReadBit16(
                                 hpRoot_t *hpRoot,
                                 bit32     cardRamOffset
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRamReadBit16 */

#ifndef osCardRamReadBit32
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 osCardRamReadBit32(
                                      agRoot_t *agRoot,
                                      os_bit32  cardRamOffset
                                    );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 osCardRamReadBit32(
                                 hpRoot_t *hpRoot,
                                 bit32     cardRamOffset
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRamReadBit32 */

#ifndef osCardRamReadBlock
#ifdef _DvrArch_1_20_
osGLOBAL void osCardRamReadBlock(
                                  agRoot_t *agRoot,
                                  os_bit32  cardRamOffset,
                                  void     *cardRamBuffer,
                                  os_bit32  cardRamBufLen
                                );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osCardRamReadBlock(
                                hpRoot_t *hpRoot,
                                bit32     cardRamOffset,
                                void     *cardRamBuffer,
                                bit32     cardRamBufLen
                              );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRamReadBlock */

#ifndef osCardRamWriteBit8
#ifdef _DvrArch_1_20_
osGLOBAL void osCardRamWriteBit8(
                                  agRoot_t *agRoot,
                                  os_bit32  cardRamOffset,
                                  os_bit8   cardRamValue
                                );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osCardRamWriteBit8(
                                hpRoot_t *hpRoot,
                                bit32     cardRamOffset,
                                bit8      cardRamValue
                              );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRamWriteBit8 */

#ifndef osCardRamWriteBit16
#ifdef _DvrArch_1_20_
osGLOBAL void osCardRamWriteBit16(
                                   agRoot_t *agRoot,
                                   os_bit32     cardRamOffset,
                                   os_bit16     cardRamValue
                                 );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osCardRamWriteBit16(
                                 hpRoot_t *hpRoot,
                                 bit32     cardRamOffset,
                                 bit16     cardRamValue
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRamWriteBit16 */

#ifndef osCardRamWriteBit32
#ifdef _DvrArch_1_20_
osGLOBAL void osCardRamWriteBit32(
                                   agRoot_t *agRoot,
                                   os_bit32  cardRamOffset,
                                   os_bit32  cardRamValue
                                 );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osCardRamWriteBit32(
                                 hpRoot_t *hpRoot,
                                 bit32     cardRamOffset,
                                 bit32     cardRamValue
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRamWriteBit32 */

#ifndef osCardRamWriteBlock
#ifdef _DvrArch_1_20_
osGLOBAL void osCardRamWriteBlock(
                                   agRoot_t *agRoot,
                                   os_bit32  cardRamOffset,
                                   void     *cardRamBuffer,
                                   os_bit32  cardRamBufLen
                                 );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osCardRamWriteBlock(
                                 hpRoot_t *hpRoot,
                                 bit32     cardRamOffset,
                                 void     *cardRamBuffer,
                                 bit32     cardRamBufLen
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRamWriteBlock */

#ifndef osCardRomReadBit8
#ifdef _DvrArch_1_20_
osGLOBAL os_bit8 osCardRomReadBit8(
                                    agRoot_t *agRoot,
                                    os_bit32  cardRomOffset
                                  );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit8 osCardRomReadBit8(
                               hpRoot_t *hpRoot,
                               bit32     cardRomOffset
                             );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRomReadBit8 */

#ifndef osCardRomReadBit16
#ifdef _DvrArch_1_20_
osGLOBAL os_bit16 osCardRomReadBit16(
                                      agRoot_t *agRoot,
                                      os_bit32  cardRomOffset
                                    );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit16 osCardRomReadBit16(
                                 hpRoot_t *hpRoot,
                                 bit32     cardRomOffset
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRomReadBit16 */

#ifndef osCardRomReadBit32
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 osCardRomReadBit32(
                                      agRoot_t *agRoot,
                                      os_bit32  cardRomOffset
                                    );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 osCardRomReadBit32(
                                 hpRoot_t *hpRoot,
                                 bit32     cardRomOffset
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRomReadBit32 */

#ifndef osCardRomReadBlock
#ifdef _DvrArch_1_20_
osGLOBAL void osCardRomReadBlock(
                                  agRoot_t *agRoot,
                                  os_bit32  cardRomOffset,
                                  void     *cardRomBuffer,
                                  os_bit32  cardRomBufLen
                                );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osCardRomReadBlock(
                                hpRoot_t *hpRoot,
                                bit32     cardRomOffset,
                                void     *cardRomBuffer,
                                bit32     cardRomBufLen
                              );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRomReadBlock */

#ifndef osCardRomWriteBit8
#ifdef _DvrArch_1_20_
osGLOBAL void osCardRomWriteBit8(
                                  agRoot_t *agRoot,
                                  os_bit32  cardRomOffset,
                                  os_bit8   cardRomValue
                                );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osCardRomWriteBit8(
                                hpRoot_t *hpRoot,
                                bit32     cardRomOffset,
                                bit8      cardRomValue
                              );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRomWriteBit8 */

#ifndef osCardRomWriteBit16
#ifdef _DvrArch_1_20_
osGLOBAL void osCardRomWriteBit16(
                                   agRoot_t *agRoot,
                                   os_bit32  cardRomOffset,
                                   os_bit16  cardRomValue
                                 );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osCardRomWriteBit16(
                                 hpRoot_t *hpRoot,
                                 bit32     cardRomOffset,
                                 bit16     cardRomValue
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRomWriteBit16 */

#ifndef osCardRomWriteBit32
#ifdef _DvrArch_1_20_
osGLOBAL void osCardRomWriteBit32(
                                   agRoot_t *agRoot,
                                   os_bit32  cardRomOffset,
                                   os_bit32  cardRomValue
                                 );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osCardRomWriteBit32(
                                 hpRoot_t *hpRoot,
                                 bit32     cardRomOffset,
                                 bit32     cardRomValue
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRomWriteBit32 */

#ifndef osCardRomWriteBlock
#ifdef _DvrArch_1_20_
osGLOBAL void osCardRomWriteBlock(
                                   agRoot_t *agRoot,
                                   os_bit32  cardRomOffset,
                                   void     *cardRomBuffer,
                                   os_bit32  cardRomBufLen
                                 );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osCardRomWriteBlock(
                                 hpRoot_t *hpRoot,
                                 bit32     cardRomOffset,
                                 void     *cardRomBuffer,
                                 bit32     cardRomBufLen
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osCardRomWriteBlock */

#ifndef osChipConfigReadBit8
#ifdef _DvrArch_1_20_
osGLOBAL os_bit8 osChipConfigReadBit8(
                                       agRoot_t *agRoot,
                                       os_bit32  chipConfigOffset
                                     );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit8 osChipConfigReadBit8(
                                  hpRoot_t *hpRoot,
                                  bit32     chipConfigOffset
                                );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipConfigReadBit8 */

#ifndef osChipConfigReadBit16
#ifdef _DvrArch_1_20_
osGLOBAL os_bit16 osChipConfigReadBit16(
                                         agRoot_t *agRoot,
                                         os_bit32  chipConfigOffset
                                       );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit16 osChipConfigReadBit16(
                                    hpRoot_t *hpRoot,
                                    bit32     chipConfigOffset
                                  );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipConfigReadBit16 */

#ifndef osChipConfigReadBit32
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 osChipConfigReadBit32(
                                         agRoot_t *agRoot,
                                         os_bit32  chipConfigOffset
                                       );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 osChipConfigReadBit32(
                                    hpRoot_t *hpRoot,
                                    bit32     chipConfigOffset
                                  );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipConfigReadBit32 */

#ifndef osChipConfigWriteBit8
#ifdef _DvrArch_1_20_
osGLOBAL void osChipConfigWriteBit8(
                                     agRoot_t *agRoot,
                                     os_bit32  chipConfigOffset,
                                     os_bit8   chipConfigValue
                                   );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osChipConfigWriteBit8(
                                   hpRoot_t *hpRoot,
                                   bit32     chipConfigOffset,
                                   bit8      chipConfigValue
                                 );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipConfigWriteBit8 */

#ifndef osChipConfigWriteBit16
#ifdef _DvrArch_1_20_
osGLOBAL void osChipConfigWriteBit16(
                                      agRoot_t *agRoot,
                                      os_bit32  chipConfigOffset,
                                      os_bit16  chipConfigValue
                                    );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osChipConfigWriteBit16(
                                    hpRoot_t *hpRoot,
                                    bit32     chipConfigOffset,
                                    bit16     chipConfigValue
                                  );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipConfigWriteBit16 */

#ifndef osChipConfigWriteBit32
#ifdef _DvrArch_1_20_
osGLOBAL void osChipConfigWriteBit32(
                                      agRoot_t *agRoot,
                                      os_bit32  chipConfigOffset,
                                      os_bit32  chipConfigValue
                                    );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osChipConfigWriteBit32(
                                    hpRoot_t *hpRoot,
                                    bit32     chipConfigOffset,
                                    bit32     chipConfigValue
                                  );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipConfigWriteBit32 */

#ifndef osChipIOLoReadBit8
#ifdef _DvrArch_1_20_
osGLOBAL os_bit8 osChipIOLoReadBit8(
                                     agRoot_t *agRoot,
                                     os_bit32  chipIOLoOffset
                                   );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit8 osChipIOLoReadBit8(
                                hpRoot_t *hpRoot,
                                bit32     chipIOLoOffset
                              );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipIOLoReadBit8 */

#ifndef osChipIOLoReadBit16
#ifdef _DvrArch_1_20_
osGLOBAL os_bit16 osChipIOLoReadBit16(
                                       agRoot_t *agRoot,
                                       os_bit32  chipIOLoOffset
                                     );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit16 osChipIOLoReadBit16(
                                  hpRoot_t *hpRoot,
                                  bit32     chipIOLoOffset
                                );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipIOLoReadBit16 */

#ifndef osChipIOLoReadBit32
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 osChipIOLoReadBit32(
                                       agRoot_t *agRoot,
                                       os_bit32  chipIOLoOffset
                                     );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 osChipIOLoReadBit32(
                                  hpRoot_t *hpRoot,
                                  bit32     chipIOLoOffset
                                );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipIOLoReadBit32 */

#ifndef osChipIOLoWriteBit8
#ifdef _DvrArch_1_20_
osGLOBAL void osChipIOLoWriteBit8(
                                   agRoot_t *agRoot,
                                   os_bit32  chipIOLoOffset,
                                   os_bit8   chipIOLoValue
                                 );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osChipIOLoWriteBit8(
                                 hpRoot_t *hpRoot,
                                 bit32     chipIOLoOffset,
                                 bit8      chipIOLoValue
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipIOLoWriteBit8 */

#ifndef osChipIOLoWriteBit16
#ifdef _DvrArch_1_20_
osGLOBAL void osChipIOLoWriteBit16(
                                    agRoot_t *agRoot,
                                    os_bit32  chipIOLoOffset,
                                    os_bit16  chipIOLoValue
                                  );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osChipIOLoWriteBit16(
                                  hpRoot_t *hpRoot,
                                  bit32     chipIOLoOffset,
                                  bit16     chipIOLoValue
                                );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipIOLoWriteBit16 */

#ifndef osChipIOLoWriteBit32
#ifdef _DvrArch_1_20_
osGLOBAL void osChipIOLoWriteBit32(
                                    agRoot_t *agRoot,
                                    os_bit32  chipIOLoOffset,
                                    os_bit32  chipIOLoValue
                                  );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osChipIOLoWriteBit32(
                                  hpRoot_t *hpRoot,
                                  bit32     chipIOLoOffset,
                                  bit32     chipIOLoValue
                                );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipIOLoWriteBit32 */

#ifndef osChipIOUpReadBit8
#ifdef _DvrArch_1_20_
osGLOBAL os_bit8 osChipIOUpReadBit8(
                                     agRoot_t *agRoot,
                                     os_bit32  chipIOUpOffset
                                   );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit8 osChipIOUpReadBit8(
                                hpRoot_t *hpRoot,
                                bit32     chipIOUpOffset
                              );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipIOUpReadBit8 */

#ifndef osChipIOUpReadBit16
#ifdef _DvrArch_1_20_
osGLOBAL os_bit16 osChipIOUpReadBit16(
                                    agRoot_t *agRoot,
                                    os_bit32  chipIOUpOffset
                                  );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit16 osChipIOUpReadBit16(
                                  hpRoot_t *hpRoot,
                                  bit32     chipIOUpOffset
                                );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipIOUpReadBit16 */

#ifndef osChipIOUpReadBit32
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 osChipIOUpReadBit32(
                                       agRoot_t *agRoot,
                                       os_bit32  chipIOUpOffset
                                     );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 osChipIOUpReadBit32(
                                  hpRoot_t *hpRoot,
                                  bit32     chipIOUpOffset
                                );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipIOUpReadBit32 */

#ifndef osChipIOUpWriteBit8
#ifdef _DvrArch_1_20_
osGLOBAL void osChipIOUpWriteBit8(
                                   agRoot_t *agRoot,
                                   os_bit32  chipIOUpOffset,
                                   os_bit8   chipIOUpValue
                                 );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osChipIOUpWriteBit8(
                                 hpRoot_t *hpRoot,
                                 bit32     chipIOUpOffset,
                                 bit8      chipIOUpValue
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipIOUpWriteBit8 */

#ifndef osChipIOUpWriteBit16
#ifdef _DvrArch_1_20_
osGLOBAL void osChipIOUpWriteBit16(
                                    agRoot_t *agRoot,
                                    os_bit32  chipIOUpOffset,
                                    os_bit16  chipIOUpValue
                                  );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osChipIOUpWriteBit16(
                                  hpRoot_t *hpRoot,
                                  bit32     chipIOUpOffset,
                                  bit16     chipIOUpValue
                                );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipIOUpWriteBit16 */

#ifndef osChipIOUpWriteBit32
#ifdef _DvrArch_1_20_
osGLOBAL void osChipIOUpWriteBit32(
                                    agRoot_t *agRoot,
                                    os_bit32  chipIOUpOffset,
                                    os_bit32  chipIOUpValue
                                  );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osChipIOUpWriteBit32(
                                  hpRoot_t *hpRoot,
                                  bit32     chipIOUpOffset,
                                  bit32     chipIOUpValue
                                );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipIOUpWriteBit32 */

#ifndef osChipMemReadBit8
#ifdef _DvrArch_1_20_
osGLOBAL os_bit8 osChipMemReadBit8(
                                    agRoot_t *agRoot,
                                    os_bit32  chipMemOffset
                                  );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit8 osChipMemReadBit8(
                               hpRoot_t *hpRoot,
                               bit32     chipMemOffset
                             );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipMemReadBit8 */

#ifndef osChipMemReadBit16
#ifdef _DvrArch_1_20_
osGLOBAL os_bit16 osChipMemReadBit16(
                                      agRoot_t *agRoot,
                                      os_bit32  chipMemOffset
                                    );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit16 osChipMemReadBit16(
                                 hpRoot_t *hpRoot,
                                 bit32     chipMemOffset
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipMemReadBit16 */

#ifndef osChipMemReadBit32
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 osChipMemReadBit32(
                                      agRoot_t *agRoot,
                                      os_bit32  chipMemOffset
                                    );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 osChipMemReadBit32(
                                 hpRoot_t *hpRoot,
                                 bit32     chipMemOffset
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipMemReadBit32 */

#ifndef osChipMemWriteBit8
#ifdef _DvrArch_1_20_
osGLOBAL void osChipMemWriteBit8(
                                  agRoot_t *agRoot,
                                  os_bit32  chipMemOffset,
                                  os_bit8   chipMemValue
                                );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osChipMemWriteBit8(
                                hpRoot_t *hpRoot,
                                bit32     chipMemOffset,
                                bit8      chipMemValue
                              );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipMemWriteBit8 */

#ifndef osChipMemWriteBit16
#ifdef _DvrArch_1_20_
osGLOBAL void osChipMemWriteBit16(
                                   agRoot_t *agRoot,
                                   os_bit32  chipMemOffset,
                                   os_bit16  chipMemValue
                                 );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osChipMemWriteBit16(
                                 hpRoot_t *hpRoot,
                                 bit32     chipMemOffset,
                                 bit16     chipMemValue
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipMemWriteBit16 */

#ifndef osChipMemWriteBit32
#ifdef _DvrArch_1_20_
osGLOBAL void osChipMemWriteBit32(
                                   agRoot_t *agRoot,
                                   os_bit32  chipMemOffset,
                                   os_bit32  chipMemValue
                                 );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osChipMemWriteBit32(
                                 hpRoot_t *hpRoot,
                                 bit32     chipMemOffset,
                                 bit32     chipMemValue
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osChipMemWriteBit32 */

#ifndef osDebugBreakpoint
#ifdef _DvrArch_1_20_
osGLOBAL void osDebugBreakpoint(
                                 agRoot_t  *agRoot,
                                 agBOOLEAN  BreakIfTrue,
                                 char      *DisplayIfTrue
                               );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osDebugBreakpoint(
                               hpRoot_t *hpRoot,
                               BOOLEAN   BreakIfTrue,
                               char     *DisplayIfTrue
                             );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osDebugBreakpoint */

#define osFCConfused    0x00000001
#define osFCConfusedPER 0x00000002
#define osFCConfusedMPE 0x00000003
#define osFCConfusedCRS 0x00000004
#define osFCConfusedDER 0x00000005

#ifndef osFCLayerAsyncError
#ifdef _DvrArch_1_20_
osGLOBAL void osFCLayerAsyncError(
                                   agRoot_t *agRoot,
                                   os_bit32  fcLayerError
                                 );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osFCLayerAsyncError(
                                 hpRoot_t *hpRoot,
                                 bit32     fcLayerError
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osFCLayerAsyncError */

#define osFCLinkUp      0x00000000
#define osFCLinkFalling 0x00000001
#define osFCLinkDown    0x00000002
#define osFCLinkDead    0x00000003
#define osFCLinkRising  0x00000004

#ifndef osFCLayerAsyncEvent
#ifdef _DvrArch_1_20_
osGLOBAL void osFCLayerAsyncEvent(
                                   agRoot_t *agRoot,
                                   os_bit32  fcLayerEvent
                                 );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osFCLayerAsyncEvent(
                                 hpRoot_t *hpRoot,
                                 bit32     fcLayerEvent
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osFCLayerAsyncEvent */

#ifndef osGetDataBufferPtr
#ifdef _DvrArch_1_20_
osGLOBAL void *osGetDataBufferPtr(
                                   agRoot_t      *agRoot,
                                   agIORequest_t *agIORequest
                                 );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void *osGetDataBufferPtr(
                                 hpRoot_t      *hpRoot,
                                 hpIORequest_t *hpIORequest
                               );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osGetDataBufferPtr */

#define osSGLSuccess 0x00000000
#define osSGLInvalid 0x00000001

#ifndef osGetSGLChunk
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 osGetSGLChunk(
                                 agRoot_t      *agRoot,
                                 agIORequest_t *agIORequest,
                                 os_bit32       agChunkOffset,
                                 os_bit32      *agChunkUpper32,
                                 os_bit32      *agChunkLower32,
                                 os_bit32      *agChunkLen
                               );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 osGetSGLChunk(
                            hpRoot_t      *hpRoot,
                            hpIORequest_t *hpIORequest,
                            bit32          hpChunkOffset,
                            bit32         *hpChunkUpper32,
                            bit32         *hpChunkLower32,
                            bit32         *hpChunkLen
                          );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osGetSGLChunk */

#ifndef osInitializeChannelCallback
#ifdef _DvrArch_1_20_
osGLOBAL void osInitializeChannelCallback(
                                           agRoot_t *agRoot,
                                           os_bit32  agInitializeStatus
                                         );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osInitializeChannelCallback(
                                         hpRoot_t *hpRoot,
                                         bit32     hpInitializeStatus
                                       );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osInitializeChannelCallback */

#define osIOSuccess     0x00000000
#define osIOAborted     0x00000001
#define osIOAbortFailed 0x00000002
#define osIODevGone     0x00000003
#define osIODevReset    0x00000004
#define osIOInfoBad     0x00000005
#define osIOOverUnder   0x00000006
#define osIOFailed      0x00000007
#define osIOInvalid     0x000001FF


#ifndef osIOCompleted
#ifdef _DvrArch_1_20_
osGLOBAL void osIOCompleted(
                             agRoot_t      *agRoot,
                             agIORequest_t *agIORequest,
                             os_bit32       agIOStatus,
                             os_bit32       agIOInfoLen
                           );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osIOCompleted(
                           hpRoot_t      *hpRoot,
                           hpIORequest_t *hpIORequest,
                           bit32          hpIOStatus,
                           bit32          hpIOInfoLen
                         );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osIOCompleted */

#ifndef osLogBit32
#ifdef _DvrArch_1_20_
osGLOBAL void osLogBit32(
                          agRoot_t *agRoot,
                          os_bit32  agBit32
                        );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osLogBit32(
                        hpRoot_t *hpRoot,
                        bit32     hpBit32
                      );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osLogBit32 */

#define osLogLevel_Always    0x00000000
#define osLogLevel_Error_MIN 0x00000001
#define osLogLevel_Error_MAX 0x0000000F
#define osLogLevel_Info_MIN  0x00000010
#define osLogLevel_Info_MAX  0xFFFFFFFE
#define osLogLevel_Never     0xFFFFFFFF

#ifndef osLogDebugString
#ifdef _DvrArch_1_20_
osGLOBAL void osLogDebugString(
                                agRoot_t *agRoot,
                                os_bit32  detailLevel,
                                char     *formatString,
                                char     *firstString,
                                char     *secondString,
                                void     *firstPtr,
                                void     *secondPtr,
                                os_bit32  firstBit32,
                                os_bit32  secondBit32,
                                os_bit32  thirdBit32,
                                os_bit32  fourthBit32,
                                os_bit32  fifthBit32,
                                os_bit32  sixthBit32,
                                os_bit32  seventhBit32,
                                os_bit32  eighthBit32
                              );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osLogDebugString(
                              hpRoot_t *hpRoot,
                              bit32     consoleLevel,
                              bit32     traceLevel,
                              char     *formatString,
                              char     *firstString,
                              char     *secondString,
                              bit32     firstBit32,
                              bit32     secondBit32,
                              bit32     thirdBit32,
                              bit32     fourthBit32,
                              bit32     fifthBit32,
                              bit32     sixthBit32,
                              bit32     seventhBit32,
                              bit32     eighthBit32
                            );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osLogDebugString */

#ifndef osLogString
#ifdef _DvrArch_1_20_
osGLOBAL void osLogString(
                           agRoot_t *agRoot,
                           char     *formatString,
                           char     *firstString,
                           char     *secondString,
                           void     *firstPtr,
                           void     *secondPtr,
                           os_bit32  firstBit32,
                           os_bit32  secondBit32,
                           os_bit32  thirdBit32,
                           os_bit32  fourthBit32,
                           os_bit32  fifthBit32,
                           os_bit32  sixthBit32,
                           os_bit32  seventhBit32,
                           os_bit32  eighthBit32
                         );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osLogString(
                         hpRoot_t *hpRoot,
                         char     *formatString,
                         char     *firstString,
                         char     *secondString,
                         bit32     firstBit32,
                         bit32     secondBit32,
                         bit32     thirdBit32,
                         bit32     fourthBit32,
                         bit32     fifthBit32,
                         bit32     sixthBit32,
                         bit32     seventhBit32,
                         bit32     eighthBit32
                       );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osLogString */

#ifndef osNvMemReadBit8
#ifdef _DvrArch_1_20_
osGLOBAL os_bit8 osNvMemReadBit8(
                                  agRoot_t *agRoot,
                                  os_bit32  nvMemOffset
                                );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit8 osNvMemReadBit8(
                             hpRoot_t *hpRoot,
                             bit32     nvMemOffset
                           );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osNvMemReadBit8 */

#ifndef osNvMemReadBit16
#ifdef _DvrArch_1_20_
osGLOBAL os_bit16 osNvMemReadBit16(
                                    agRoot_t *agRoot,
                                    os_bit32  nvMemOffset
                                  );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit16 osNvMemReadBit16(
                               hpRoot_t *hpRoot,
                               bit32     nvMemOffset
                             );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osNvMemReadBit16 */

#ifndef osNvMemReadBit32
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 osNvMemReadBit32(
                                    agRoot_t *agRoot,
                                    os_bit32  nvMemOffset
                                  );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 osNvMemReadBit32(
                               hpRoot_t *hpRoot,
                               bit32     nvMemOffset
                             );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osNvMemReadBit32 */

#ifndef osNvMemReadBlock
#ifdef _DvrArch_1_20_
osGLOBAL void osNvMemReadBlock(
                                agRoot_t *agRoot,
                                os_bit32  nvMemOffset,
                                void     *nvMemBuffer,
                                os_bit32  nvMemBufLen
                              );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osNvMemReadBlock(
                              hpRoot_t *hpRoot,
                              bit32     nvMemOffset,
                              void     *nvMemBuffer,
                              bit32     nvMemBufLen
                            );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osNvMemReadBlock */

#ifndef osNvMemWriteBit8
#ifdef _DvrArch_1_20_
osGLOBAL void osNvMemWriteBit8(
                                agRoot_t *agRoot,
                                os_bit32  nvMemOffset,
                                os_bit8   nvMemValue
                              );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osNvMemWriteBit8(
                              hpRoot_t *hpRoot,
                              bit32     nvMemOffset,
                              bit8      nvMemValue
                            );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osNvMemWriteBit8 */

#ifndef osNvMemWriteBit16
#ifdef _DvrArch_1_20_
osGLOBAL void osNvMemWriteBit16(
                                 agRoot_t *agRoot,
                                 os_bit32  nvMemOffset,
                                 os_bit16  nvMemValue
                               );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osNvMemWriteBit16(
                               hpRoot_t *hpRoot,
                               bit32     nvMemOffset,
                               bit16     nvMemValue
                             );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osNvMemWriteBit16 */

#ifndef osNvMemWriteBit32
#ifdef _DvrArch_1_20_
osGLOBAL void osNvMemWriteBit32(
                                 agRoot_t *agRoot,
                                 os_bit32  nvMemOffset,
                                 os_bit32  nvMemValue
                               );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osNvMemWriteBit32(
                               hpRoot_t *hpRoot,
                               bit32     nvMemOffset,
                               bit32     nvMemValue
                             );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osNvMemWriteBit32 */

#ifndef osNvMemWriteBlock
#ifdef _DvrArch_1_20_
osGLOBAL void osNvMemWriteBlock(
                                 agRoot_t *agRoot,
                                 os_bit32  nvMemOffset,
                                 void     *nvMemBuffer,
                                 os_bit32  nvMemBufLen
                               );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osNvMemWriteBlock(
                               hpRoot_t *hpRoot,
                               bit32     nvMemOffset,
                               void     *nvMemBuffer,
                               bit32     nvMemBufLen
                             );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osNvMemWriteBlock */

#ifndef osResetChannelCallback
#ifdef _DvrArch_1_20_
osGLOBAL void osResetChannelCallback(
                                      agRoot_t *agRoot,
                                      os_bit32  agResetStatus
                                    );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osResetChannelCallback(
                                    hpRoot_t *hpRoot,
                                    bit32     hpResetStatus
                                  );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osResetChannelCallback */

#ifndef osResetDeviceCallback
#ifdef _DvrArch_1_20_
osGLOBAL void osResetDeviceCallback(
                                     agRoot_t  *agRoot,
                                     agFCDev_t  agFCDev,
                                     os_bit32   agResetStatus
                                   );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osResetDeviceCallback(
                                   hpRoot_t  *hpRoot,
                                   hpFCDev_t  hpFCDev,
                                   bit32      hpResetStatus
                                 );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osResetDeviceCallback */

#ifdef _DvrArch_1_30_
#ifndef osSignalOutboundQ
osGLOBAL void osSignalOutboundQ(
                                 agRoot_t  *agRoot,
                                 os_bit32   agQPairID
                               );
#endif  /* ~osSignalOutboundQ */
#endif /* _DvrArch_1_30_ was defined */

#ifndef osSingleThreadedEnter
#ifdef _DvrArch_1_20_
osGLOBAL void osSingleThreadedEnter(
                                     agRoot_t *agRoot
                                   );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osSingleThreadedEnter(
                                   hpRoot_t *hpRoot
                                 );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osSingleThreadedEnter */

#ifndef osSingleThreadedLeave
#ifdef _DvrArch_1_20_
osGLOBAL void osSingleThreadedLeave(
                                     agRoot_t *agRoot
                                   );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osSingleThreadedLeave(
                                   hpRoot_t *hpRoot
                                 );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osSingleThreadedLeave */

#ifndef osStallThread
#ifdef _DvrArch_1_20_
osGLOBAL void osStallThread(
                             agRoot_t *agRoot,
                             os_bit32  microseconds
                           );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osStallThread(
                           hpRoot_t *hpRoot,
                           bit32 microseconds
                         );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osStallThread */

#ifndef osTimeStamp
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 osTimeStamp(
                               agRoot_t *agRoot
                             );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 osTimeStamp(
                          hpRoot_t *hpRoot
                        );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osTimeStamp */

/* Begin: Big_Endian_Code */
#ifndef hpMustSwapDmaMem   /* hpMustSwapDmaMem */

#define osSwapDownwardPayloadToTachLiteEndian(x, y)
#define osSwapDownwardNonPayloadToTachLiteEndian(x, y)
#define osSwapUpwardNonPayloadToSystemEndian(x, y)
#define osSwapUpwardPayloadToFcLinkEndian(x, y)
#define osSwapBit16TachLiteToSystemEndian(x) x
#define osSwapBit32TachLiteToSystemEndian(x) x
#define osSwapBit16ToTachLiteEndian(x) x
#define osSwapBit32ToTachLiteEndian(x) x

#else                      /* hpMustSwapDmaMem */

#ifndef osSwapDownwardPayloadToTachLiteEndian
#ifdef _DvrArch_1_20_
osGLOBAL void osSwapDownwardPayloadToTachLiteEndian(
                                                     void     *Payload,
                                                     os_bit32  Payload_len
                                                   );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osSwapDownwardPayloadToTachLiteEndian(
                                                   void  *Payload,
                                                   bit32  Payload_len
                                                 );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osSwapDownwardPayloadToTachLiteEndian */

#ifndef osSwapUpwardPayloadToFcLinkEndian
#ifdef _DvrArch_1_20_
osGLOBAL void osSwapUpwardPayloadToFcLinkEndian(
                                                 void     *Payload,
                                                 os_bit32  Payload_len
                                               );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osSwapUpwardPayloadToFcLinkEndian(
                                               void  *Payload,
                                               bit32  Payload_len
                                             );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osSwapUpwardPayloadToFcLinkEndian */

#ifndef osSwapDownwardNonPayloadToTachLiteEndian
#ifdef _DvrArch_1_20_
osGLOBAL void osSwapDownwardNonPayloadToTachLiteEndian(
                                                        void     *NonPayload,
                                                        os_bit32  NonPayload_len
                                                      );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osSwapDownwardNonPayloadToTachLiteEndian(
                                                      void  *NonPayload,
                                                      bit32  NonPayload_len
                                                    );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osSwapDownwardNonPayloadToTachLiteEndian */

#ifndef osSwapUpwardNonPayloadToSystemEndian
#ifdef _DvrArch_1_20_
osGLOBAL void osSwapUpwardNonPayloadToSystemEndian(
                                                    void     *NonPayload,
                                                    os_bit32  NonPayload_len
                                                  );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL void osSwapUpwardNonPayloadToSystemEndian(
                                                  void  *NonPayload,
                                                  bit32  NonPayload_len
                                                );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osSwapUpwardNonPayloadToSystemEndian */

#ifndef osSwapBit32TachLiteToSystemEndian
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 osSwapBit32TachLiteToSystemEndian(
                                                     os_bit32 Bit32Value
                                                   );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 osSwapBit32TachLiteToSystemEndian(
                                                bit32 Bit32Value
                                              );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osSwapBit32TachLiteToSystemEndian */

#ifndef osSwapBit16TachLiteToSystemEndian
#ifdef _DvrArch_1_20_
osGLOBAL os_bit16 osSwapBit16TachLiteToSystemEndian(
                                                     os_bit16 Bit32Value
                                                   );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit16 osSwapBit16TachLiteToSystemEndian(
                                                bit16 Bit32Value
                                              );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osSwapBit32TachLiteToSystemEndian */

#ifndef osSwapBit32ToTachLiteEndian
#ifdef _DvrArch_1_20_
osGLOBAL os_bit32 osSwapBit32ToTachLiteEndian(
                                               os_bit32 Bit32Value
                                             );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit32 osSwapBit32ToTachLiteEndian(
                                          bit32 Bit32Value
                                        );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osSwapBit32ToTachLiteEndian */

#ifndef osSwapBit16ToTachLiteEndian
#ifdef _DvrArch_1_20_
osGLOBAL os_bit16 osSwapBit16ToTachLiteEndian(
                                               os_bit16 Bit32Value
                                             );
#else  /* _DvrArch_1_20_ was not defined */
GLOBAL bit16 osSwapBit16ToTachLiteEndian(
                                          bit16 Bit32Value
                                        );
#endif /* _DvrArch_1_20_ was not defined */
#endif  /* ~osSwapBit16ToTachLiteEndian */

#endif                     /* ~hpMustSwapDmaMem */
/* End: Big_Endian_Code */

#ifdef _DvrArch_1_30_
osGLOBAL void osFcNetIoctlCompleted(
                                     agRoot_t *hpRoot,
                     void *osData,
                     os_bit32 status
                   );
#endif /* _DvrArch_1_30_ was defined */

/*
 * Include Embedded Firmware API .H File
 */

#include "fwspec.h"

/*
This is the structure which is at the offset 0x18000 from the base address of the SPI ROM.
*/

typedef struct agBiosConfig_s
               agBiosConfig_t;

#define agBIOS_Config_OffSet                0x18000

struct agBiosConfig_s
{
    os_bit8     Valid;      /*A5-----First byte to validate the structure*/
    os_bit8     Reserved_1;
    os_bit8     Reserved_2;
    os_bit8     Reserved_3;
    os_bit32    Struct_Size;
    os_bit8     agBiosConfig_Version;
    os_bit8     H_Alpa;         /*Hard Alpa     */
    os_bit8     H_Area;         /*Hard Area     */
    os_bit8     H_Domain;       /*Hard Domain   */

    os_bit8     B_Alpa;         /*Boot Alpa     */
    os_bit8     B_Area;         /*Boot Area     */
    os_bit8     B_Domain;       /*Boot Domain   */

    os_bit8     B_WWN[8];       /*Boot WWN       */

    os_bit8     BackwardScan;   /* 1 backward, 0: forward*/
    os_bit8     BiosEnabled;    /* 1 enabled,  0: disabled*/
    os_bit8     MaxDevice;      /* Max No. of device      */
    os_bit8     FLport;         /* 1: FL port, 0: F port  */

    os_bit8     Alpa_WWN;       /* 0:bootID=Alpa, 1:bootID=WWN*/
    os_bit8     ToggleXL2;      /*0 1Gig Mode, 1:2Gig Mode*/
    os_bit8     RevMajor;       /*BIOS_REV*/
    os_bit8     RevMinorL;      /*BIOS_SUB_REV_L*/

    os_bit8     RevMinorH;      /*BIOS_SUB_REV_H*/
    os_bit8     RevType;        /*BIOS_REV_TYPE*/
    os_bit8     Reserved_4;     /**/
    os_bit8     Reserved_5;     /**/
    os_bit8     End_Sig;         /* 55h------Last byte to validate the structure */
};

#define agBIOS_Config_Size                  sizeof(agBiosConfig_s)
#define agBIOS_Config_VALID                 0xA5
#define agBIOS_Config_EndSig                0x55
#define agBIOS_Fport                        0
#define agBIOS_Enabled                      1
#define agBIOS_FLport                       1
#define agBIOS_ToggleXL2_Link_Speed_1_gig   0   /* 1 GBit/sec */
#define agBIOS_ToggleXL2_Link_Speed_2_gig   1   /* 2 GBit/sec */
#define agBIOS_ToggleXL2_Link_Speed_1_RX_2_TX 3
#define agBIOS_ToggleXL2_Link_Speed_2_RX_1_TX 4

#endif  /* __Globals_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\hbaapi.h ===
/**********************************************************************************

   hbaapi.h

   Author:        Benjamin F. Kuo, Troika Networks Inc.
   Description:   Header file for the SNIA HBA API Proposal
   Version:       0.8
   
   Changes:       03/09/2000 Initial Draft
                  05/12/2000 Updated to Version 0.3 of Proposal   
				  06/20/2000 Updated to Version 0.6 of Proposal
				  06/27/2000 Updated to Version 0.7 of Proposal
				  07/17/2000 Updated to Version 0.8 of Proposal
				  07/26/2000 Updated to Version 0.9 of Proposal
				  08/01/2000 Updated to Version 1.0 of Proposal
				  08/19/2000 Updated to Version 1.0A of Proposal
				  09/12/2000 1.0 Final

***********************************************************************************/


#ifdef __cplusplus
extern "C" {
#endif


#ifndef HBA_API_H
#define HBA_API_H

/* Library version string */
#define HBA_LIBVERSION 1

/* DLL imports for WIN32 operation */
#ifdef WIN32
#ifdef HBAAPI_EXPORTS
#define HBA_API __declspec(dllexport)
#else
#define HBA_API __declspec(dllimport)
#endif
#else
#define HBA_API
#endif

/* OS specific definitions */

#ifdef WIN32
typedef unsigned char    HBA_UINT8;	   // Unsigned  8 bits
typedef          char    HBA_INT8;      // Signed    8 bits
typedef unsigned short   HBA_UINT16;	   // Unsigned 16 bits
typedef          short   HBA_INT16;	   // Signed   16 bits
typedef unsigned int     HBA_UINT32;    // Unsigned 32 bits
typedef          int     HBA_INT32;     // Signed   32 bits
typedef void*            HBA_PVOID;     // Pointer  to void
typedef HBA_UINT32   HBA_VOID32;    // Opaque   32 bits


#ifdef _WIN32

typedef 		 _int64		HBA_INT64;
typedef 		 _int64		HBA_UINT64;
#else
typedef struct {
	TN_UINT32	lo_val;
	TN_UINT32	hi_val;
} HBA_INT64;

typedef struct {
	TN_UINT32	lo_val;
	TN_UINT32	hi_val;
} HBA_UINT64;
#endif	/*	#ifdef _WIN32	*/


#else

/* Note this section needs to be cleaned up for various Unix platforms */
typedef unsigned char    HBA_UINT8;	   /* Unsigned  8 bits */
typedef          char    HBA_INT8;      /* Signed    8 bits */
typedef unsigned short   HBA_UINT16;	   /* Unsigned 16 bits */
typedef          short   HBA_INT16;	   /* Signed   16 bits */
typedef unsigned int     HBA_UINT32;    /*Unsigned 32 bits */
typedef          int     HBA_INT32;     /* Signed   32 bits */
typedef void*            HBA_PVOID;     /* Pointer  to void */
typedef HBA_UINT32   HBA_VOID32;    /* Opaque   32 bits */
typedef long long   HBA_INT64;
typedef long long   HBA_UINT64;

#endif  /*  #ifdef WIN32 */


/* 4.2.1	Handle to Device */
typedef HBA_UINT32  HBA_HANDLE;

/* 4.2.2	Status Return Values */
typedef HBA_UINT32 HBA_STATUS;

#define HBA_STATUS_OK        				0
#define HBA_STATUS_ERROR 					1   /* Error */
#define HBA_STATUS_ERROR_NOT_SUPPORTED    	2   /* Function not supported.*/
#define HBA_STATUS_ERROR_INVALID_HANDLE		3   /* invalid handle */
#define HBA_STATUS_ERROR_ARG      	 		4   /* Bad argument */
#define HBA_STATUS_ERROR_ILLEGAL_WWN       	5   /* WWN not recognized */
#define HBA_STATUS_ERROR_ILLEGAL_INDEX		6   /* Index not recognized */
#define HBA_STATUS_ERROR_MORE_DATA			7   /* Larger buffer required */



/* 4.2.3	Port Operational Modes Values */

typedef HBA_UINT32 HBA_PORTTYPE; 		

#define HBA_PORTTYPE_UNKNOWN        	1 /* Unknown */
#define HBA_PORTTYPE_OTHER              2 /* Other */
#define HBA_PORTTYPE_NOTPRESENT         3 /* Not present */
#define HBA_PORTTYPE_NPORT          	5 /* Fabric  */
#define HBA_PORTTYPE_NLPORT 			6 /* Public Loop */
#define HBA_PORTTYPE_FLPORT				7
#define HBA_PORTTYPE_FPORT	           	8 /* Fabric Port */
#define HBA_PORTTYPE_EPORT				9 /* Fabric expansion port */
#define HBA_PORTTYPE_GPORT				10 /* Generic Fabric Port */
#define HBA_PORTTYPE_LPORT          	20 /* Private Loop */
#define HBA_PORTTYPE_PTP  				21 /* Point to Point */


typedef HBA_UINT32 HBA_PORTSTATE; 		
#define HBA_PORTSTATE_UNKNOWN 			1 /* Unknown */
#define HBA_PORTSTATE_ONLINE			2 /* Operational */
#define HBA_PORTSTATE_OFFLINE 			3 /* User Offline */
#define HBA_PORTSTATE_BYPASSED          4 /* Bypassed */
#define HBA_PORTSTATE_DIAGNOSTICS       5 /* In diagnostics mode */
#define HBA_PORTSTATE_LINKDOWN 			6 /* Link Down */
#define HBA_PORTSTATE_ERROR 			7 /* Port Error */
#define HBA_PORTSTATE_LOOPBACK 			8 /* Loopback */


typedef HBA_UINT32 HBA_PORTSPEED;
#define HBA_PORTSPEED_1GBIT				1 /* 1 GBit/sec */
#define HBA_PORTSPEED_2GBIT				2 /* 2 GBit/sec */
#define HBA_PORTSPEED_10GBIT			4 /* 10 GBit/sec */



/* 4.2.4	Class of Service Values - See GS-2 Spec.*/

typedef HBA_UINT32 HBA_COS;


/* 4.2.5	Fc4Types Values */

typedef struct HBA_fc4types {
	HBA_UINT8 bits[32]; /* 32 bytes of FC-4 per GS-2 */
} HBA_FC4TYPES, *PHBA_FC4TYPES;

/* 4.2.6	Basic Types */

typedef struct HBA_wwn {
	HBA_UINT8 wwn[8];
} HBA_WWN, *PHBA_WWN;

typedef struct HBA_ipaddress {
	int	ipversion;		/* see enumerations in RNID */
	union
	{
		unsigned char ipv4address[4];
		unsigned char ipv6address[16];
	} ipaddress;
} HBA_IPADDRESS, *PHBA_IPADDRESS;

/* 4.2.7	Adapter Attributes */
typedef struct hba_AdapterAttributes {
	char 			Manufacturer[64];  		/*Emulex */
	char 			SerialNumber[64];  		/* A12345 */
	char 			Model[256];            	/* QLA2200 */
    char 			ModelDescription[256];  /* Agilent TachLite */
	HBA_WWN 		NodeWWN; 
	char 			NodeSymbolicName[256];	/* From GS-3 */
	char 			HardwareVersion[256];	/* Vendor use */
	char 			DriverVersion[256]; 	/* Vendor use */
    char 			OptionROMVersion[256]; 	/* Vendor use  - i.e. hardware boot ROM*/
	char 			FirmwareVersion[256];	/* Vendor use */
	HBA_UINT32 		VendorSpecificID;		/* Vendor specific */
    HBA_UINT32 		NumberOfPorts;
	char			DriverName[256];		/* Binary path and/or name of driver file. */
} HBA_ADAPTERATTRIBUTES, *PHBA_ADAPTERATTRIBUTES;

/* 4.2.8	Port Attributes */
typedef struct HBA_PortAttributes {
    HBA_WWN 		NodeWWN;
	HBA_WWN 		PortWWN;
	HBA_UINT32 		PortFcId;
	HBA_PORTTYPE 	PortType; 		/*PTP, Fabric, etc. */
	HBA_PORTSTATE 	PortState;
	HBA_COS 		PortSupportedClassofService;
	HBA_FC4TYPES	PortSupportedFc4Types;
	HBA_FC4TYPES	PortActiveFc4Types;
	char			PortSymbolicName[256];
	char 			OSDeviceName[256]; 	/* \device\ScsiPort3  */
    HBA_PORTSPEED	PortSupportedSpeed;
	HBA_PORTSPEED	PortSpeed; 
	HBA_UINT32		PortMaxFrameSize;
	HBA_WWN			FabricName;
	HBA_UINT32		NumberofDiscoveredPorts;
} HBA_PORTATTRIBUTES, *PHBA_PORTATTRIBUTES;



/* 4.2.9	Port Statistics */

typedef struct HBA_PortStatistics {
	HBA_INT64		SecondsSinceLastReset;
	HBA_INT64		TxFrames;
	HBA_INT64		TxWords;
   	HBA_INT64		RxFrames;
   	HBA_INT64		RxWords;
	HBA_INT64		LIPCount;
	HBA_INT64		NOSCount;
	HBA_INT64		ErrorFrames;
	HBA_INT64		DumpedFrames;
	HBA_INT64		LinkFailureCount;
	HBA_INT64		LossOfSyncCount;
	HBA_INT64		LossOfSignalCount;
	HBA_INT64		PrimitiveSeqProtocolErrCount;
	HBA_INT64		InvalidTxWordCount;
	HBA_INT64		InvalidCRCCount;
} HBA_PORTSTATISTICS, *PHBA_PORTSTATISTICS;



/* 4.2.10	FCP Attributes */

typedef enum HBA_fcpbindingtype { TO_D_ID, TO_WWN } HBA_FCPBINDINGTYPE;

typedef struct HBA_ScsiId {
	char 			OSDeviceName[256]; 	/* \device\ScsiPort3  */
	HBA_UINT32		ScsiBusNumber;		/* Bus on the HBA */
	HBA_UINT32		ScsiTargetNumber;	/* SCSI Target ID to OS */
	HBA_UINT32		ScsiOSLun;	
} HBA_SCSIID, *PHBA_SCSIID;

typedef struct HBA_FcpId {
	HBA_UINT32 		FcId;
	HBA_WWN			NodeWWN;
	HBA_WWN			PortWWN;
	HBA_UINT64		FcpLun;
} HBA_FCPID, *PHBA_FCPID;

typedef struct HBA_FcpScsiEntry {
	HBA_SCSIID 		ScsiId;
	HBA_FCPID		FcpId;
} HBA_FCPSCSIENTRY, *PHBA_FCPSCSIENTRY;

typedef struct HBA_FCPTargetMapping {
	HBA_UINT32			NumberOfEntries;
	HBA_FCPSCSIENTRY 	entry[1];  	/* Variable length array containing mappings*/
} HBA_FCPTARGETMAPPING, *PHBA_FCPTARGETMAPPING;

typedef struct HBA_FCPBindingEntry {
	HBA_FCPBINDINGTYPE	type;
	HBA_SCSIID		ScsiId;
	HBA_FCPID		FcpId;	/* WWN valid only if type is to WWN, FcpLun always valid */
	HBA_UINT32		FcId;	/* Used only if type is to DID */
} HBA_FCPBINDINGENTRY, *PHBA_FCPBINDINGENTRY;

typedef struct HBA_FCPBinding {
	HBA_UINT32						NumberOfEntries;
	HBA_FCPBINDINGENTRY	entry[1]; /* Variable length array */
} HBA_FCPBINDING, *PHBA_FCPBINDING;

/* 4.2.11	FC-3 Management Atrributes */

typedef enum HBA_wwntype { NODE_WWN, PORT_WWN } HBA_WWNTYPE;

typedef struct HBA_MgmtInfo {
	HBA_WWN 			wwn;
	HBA_UINT32 			unittype;
	HBA_UINT32 			PortId;
	HBA_UINT32 			NumberOfAttachedNodes;
	HBA_UINT16 			IPVersion;
	HBA_UINT16 			UDPPort;
	HBA_UINT8			IPAddress[16];
	HBA_UINT16			reserved;
	HBA_UINT16 			TopologyDiscoveryFlags;
} HBA_MGMTINFO, *PHBA_MGMTINFO;

#define HBA_EVENT_LIP_OCCURRED			1
#define HBA_EVENT_LINK_UP				2
#define HBA_EVENT_LINK_DOWN			3
#define HBA_EVENT_LIP_RESET_OCCURRED		4
#define HBA_EVENT_RSCN				5
#define HBA_EVENT_PROPRIETARY                    	     0xFFFF

typedef struct HBA_Link_EventInfo {
	HBA_UINT32 PortFcId; 	/* Port which this event occurred */
	HBA_UINT32 Reserved[3];
} HBA_LINK_EVENTINFO, *PHBA_LINK_EVENTINFO;

typedef struct HBA_RSCN_EventInfo {
	HBA_UINT32 PortFcId; 	/* Port which this event occurred */
	HBA_UINT32 NPortPage;   /* Reference FC-FS for  RSCN ELS "Affected N-Port Pages"*/
	HBA_UINT32 Reserved[2];
} HBA_RSCN_EVENTINFO, *PHBA_RSCN_EVENTINFO;

typedef struct HBA_Pty_EventInfo {
	HBA_UINT32 PtyData[4];  /* Proprietary data */
} HBA_PTY_EVENTINFO, *PHBA_PTY_EVENTINFO;

typedef struct HBA_EventInfo {
	HBA_UINT32 EventCode;
	union {
	HBA_LINK_EVENTINFO Link_EventInfo;
	HBA_RSCN_EVENTINFO RSCN_EventInfo;
	HBA_PTY_EVENTINFO Pty_EventInfo;
	} Event;
} HBA_EVENTINFO, *PHBA_EVENTINFO;



/* 4.2.12 HBA Library Function Table */

typedef HBA_UINT32  ( * HBAGetVersionFunc)();
typedef HBA_STATUS  ( * HBALoadLibraryFunc)();
typedef HBA_STATUS  ( * HBAFreeLibraryFunc)();
typedef HBA_UINT32  ( * HBAGetNumberOfAdaptersFunc)();
typedef HBA_STATUS  ( * HBAGetAdapterNameFunc)(HBA_UINT32, char*);
typedef HBA_HANDLE 	( * HBAOpenAdapterFunc)(char*);
typedef void	  	( * HBACloseAdapterFunc)(HBA_HANDLE);
typedef HBA_STATUS	( * HBAGetAdapterAttributesFunc)(HBA_HANDLE, PHBA_ADAPTERATTRIBUTES);
typedef HBA_STATUS 	( * HBAGetAdapterPortAttributesFunc)(HBA_HANDLE, HBA_UINT32, PHBA_PORTATTRIBUTES);
typedef HBA_STATUS 	( * HBAGetPortStatisticsFunc)(HBA_HANDLE, HBA_UINT32, PHBA_PORTSTATISTICS);
typedef HBA_STATUS	( * HBAGetDiscoveredPortAttributesFunc)(HBA_HANDLE, HBA_UINT32, HBA_UINT32, PHBA_PORTATTRIBUTES);
typedef HBA_STATUS 	( * HBAGetPortAttributesByWWNFunc)(HBA_HANDLE, HBA_WWN, PHBA_PORTATTRIBUTES);
typedef HBA_STATUS 	( * HBASendCTPassThruFunc)(HBA_HANDLE, void *,  HBA_UINT32,  void *,  HBA_UINT32);
typedef void	 	( * HBARefreshInformationFunc)(HBA_HANDLE);
typedef void	   	( * HBAResetStatisticsFunc)(HBA_HANDLE, HBA_UINT32);
typedef HBA_STATUS 	( * HBAGetFcpTargetMappingFunc) (HBA_HANDLE, PHBA_FCPTARGETMAPPING );
typedef HBA_STATUS 	( * HBAGetFcpPersistentBindingFunc) (HBA_HANDLE, PHBA_FCPBINDING );
typedef HBA_STATUS 	(* HBAGetEventBufferFunc)(HBA_HANDLE, PHBA_EVENTINFO, HBA_UINT32 *);
typedef HBA_STATUS 	(* HBASetRNIDMgmtInfoFunc) (HBA_HANDLE, PHBA_MGMTINFO);
typedef HBA_STATUS 	(* HBAGetRNIDMgmtInfoFunc)(HBA_HANDLE, PHBA_MGMTINFO);
typedef HBA_STATUS 	(* HBASendRNIDFunc) (HBA_HANDLE, HBA_WWN, HBA_WWNTYPE, void *, HBA_UINT32 *);
typedef HBA_STATUS 	(* HBASendScsiInquiryFunc) (HBA_HANDLE,HBA_WWN,HBA_UINT64,HBA_UINT8, HBA_UINT32, void *, HBA_UINT32,void *,HBA_UINT32 );
typedef HBA_STATUS 	(* HBASendReportLUNsFunc) (HBA_HANDLE,	HBA_WWN,void *, HBA_UINT32,void *,HBA_UINT32 );
typedef HBA_STATUS 	(* HBASendReadCapacityFunc) (HBA_HANDLE, HBA_WWN,HBA_UINT64,	void *, HBA_UINT32,void *,HBA_UINT32);


typedef struct HBA_EntryPoints {
	HBAGetVersionFunc						GetVersionHandler;
	HBALoadLibraryFunc                      LoadLibraryHandler;
	HBAFreeLibraryFunc                      FreeLibraryHandler;
	HBAGetNumberOfAdaptersFunc				GetNumberOfAdaptersHandler;
	HBAGetAdapterNameFunc					GetAdapterNameHandler;
	HBAOpenAdapterFunc						OpenAdapterHandler;
	HBACloseAdapterFunc						CloseAdapterHandler;
	HBAGetAdapterAttributesFunc				GetAdapterAttributesHandler;
	HBAGetAdapterPortAttributesFunc			GetAdapterPortAttributesHandler;
	HBAGetPortStatisticsFunc				GetPortStatisticsHandler;
	HBAGetDiscoveredPortAttributesFunc		GetDiscoveredPortAttributesHandler;
	HBAGetPortAttributesByWWNFunc			GetPortAttributesByWWNHandler;
	HBASendCTPassThruFunc					SendCTPassThruHandler;
	HBARefreshInformationFunc				RefreshInformationHandler;
	HBAResetStatisticsFunc					ResetStatisticsHandler;
	HBAGetFcpTargetMappingFunc				GetFcpTargetMappingHandler;
	HBAGetFcpPersistentBindingFunc			GetFcpPersistentBindingHandler;
	HBAGetEventBufferFunc					GetEventBufferHandler;
	HBASetRNIDMgmtInfoFunc					SetRNIDMgmtInfoHandler;
	HBAGetRNIDMgmtInfoFunc					GetRNIDMgmtInfoHandler;
	HBASendRNIDFunc							SendRNIDHandler;
	HBASendScsiInquiryFunc					ScsiInquiryHandler;
	HBASendReportLUNsFunc					ReportLUNsHandler;
	HBASendReadCapacityFunc					ReadCapacityHandler;
} HBA_ENTRYPOINTS, *PHBA_ENTRYPOINTS;

/* Function Prototypes */

HBA_API HBA_UINT32 HBA_GetVersion();

HBA_API HBA_STATUS HBA_LoadLibrary();

HBA_API HBA_STATUS HBA_FreeLibrary();

HBA_API HBA_UINT32 HBA_GetNumberOfAdapters();

HBA_API HBA_STATUS HBA_GetAdapterName(HBA_UINT32 adapterindex, char *adaptername);

HBA_API HBA_HANDLE HBA_OpenAdapter(
	char* adaptername
	);

HBA_API void HBA_CloseAdapter(
	HBA_HANDLE handle
	);

HBA_API HBA_STATUS HBA_GetAdapterAttributes(
	HBA_HANDLE handle, 
	HBA_ADAPTERATTRIBUTES *hbaattributes	
	);

HBA_API HBA_STATUS HBA_GetAdapterPortAttributes(
	HBA_HANDLE handle, 
	HBA_UINT32 portindex,
	HBA_PORTATTRIBUTES *portattributes
	);

HBA_API HBA_STATUS HBA_GetPortStatistics(
	HBA_HANDLE				handle,
	HBA_UINT32				portindex,
	HBA_PORTSTATISTICS			*portstatistics
	);

HBA_API HBA_STATUS HBA_GetDiscoveredPortAttributes(
	HBA_HANDLE handle, 
	HBA_UINT32 portindex,
	HBA_UINT32 discoveredportindex,
	HBA_PORTATTRIBUTES *portattributes
	);

HBA_API HBA_STATUS HBA_GetPortAttributesByWWN(
	HBA_HANDLE handle,
	HBA_WWN PortWWN,
	HBA_PORTATTRIBUTES *portattributes
	);

HBA_API HBA_STATUS HBA_SendCTPassThru(
	HBA_HANDLE handle, 
	void * pReqBuffer,
	HBA_UINT32 ReqBufferSize,
	void * pRspBuffer,  
	HBA_UINT32 RspBufferSize
	);


HBA_API HBA_STATUS HBA_GetEventBuffer(
	HBA_HANDLE handle, 
	PHBA_EVENTINFO EventBuffer, 
	HBA_UINT32 *EventBufferCount);

HBA_API HBA_STATUS HBA_SetRNIDMgmtInfo(
	HBA_HANDLE handle, 
	HBA_MGMTINFO *pInfo);

HBA_API HBA_STATUS HBA_GetRNIDMgmtInfo(
	HBA_HANDLE handle, 
	HBA_MGMTINFO *pInfo);
	
HBA_API HBA_STATUS HBA_SendRNID(
	HBA_HANDLE handle,
	HBA_WWN wwn,
	HBA_WWNTYPE wwntype,
	void * pRspBuffer,
	HBA_UINT32 *RspBufferSize
	);

HBA_API void HBA_RefreshInformation(
	HBA_HANDLE handle);

HBA_API void HBA_ResetStatistics(
	HBA_HANDLE handle,
	HBA_UINT32 portindex
	);

HBA_API HBA_STATUS HBA_GetFcpTargetMapping(
	HBA_HANDLE handle, 
	PHBA_FCPTARGETMAPPING mapping
	);

HBA_API HBA_STATUS HBA_GetFcpPersistentBinding(
	HBA_HANDLE handle, 
	PHBA_FCPBINDING binding
	);

HBA_API HBA_STATUS HBA_SendScsiInquiry (	
	HBA_HANDLE handle,	
	HBA_WWN PortWWN, 
	HBA_UINT64 fcLUN, 
	HBA_UINT8 EVPD, 
	HBA_UINT32 PageCode, 
	void * pRspBuffer, 
	HBA_UINT32 RspBufferSize, 
	void * pSenseBuffer, 
	HBA_UINT32 SenseBufferSize
	);

HBA_API HBA_STATUS HBA_SendReportLUNs (
	HBA_HANDLE handle,
	HBA_WWN portWWN,
	void * pRspBuffer, 
	HBA_UINT32 RspBufferSize,
	void * pSenseBuffer,
	HBA_UINT32 SenseBufferSize
	);

HBA_API HBA_STATUS HBA_SendReadCapacity (
	HBA_HANDLE handle,
	HBA_WWN portWWN,
	HBA_UINT64 fcLUN,
	void * pRspBuffer, 
	HBA_UINT32 RspBufferSize,
	void * pSenseBuffer,
	HBA_UINT32 SenseBufferSize
	);



#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\hotplug4.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Module Name:

   HotPlug4.c

Abstract:

   This is the miniport driver for the Agilent
   PCI to Fibre Channel Host Bus Adapter (HBA). 
   
   This module is specific to the NT 4.0 PCI Hot Plug feature 
   support routines. The PCI Hot Plug implementation is based 
   on Compaq PCI HoT Plug implementation.

Authors:
   Ie Wei Njoo
 
Environment:

   kernel mode only

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/C/HotPlug4.c $

Revision History:

   $Revision: 4 $
   $Date: 10/23/00 5:45p $
   $Modtime::  $

Notes:

--*/

#include "buildop.h"        //LP021100 build switches

#if defined(HP_PCI_HOT_PLUG)

#include "osflags.h"
#include "TLStruct.H"
#include "HotPlug4.h"    // PCI Hot-Plug header file

VOID
RcmcSendEvent(
   IN PCARD_EXTENSION pCard,
   IN OUT PHR_EVENT pEvent
   )
/*++

Routine Description:

   Handles event reporting to PCI Hot Plug rcmc service.
    
Arguments:

   pCard   - Pointer to adapter storage area.
   pEvent  - Pointer to event log record.

Return Value:

   None.

--*/

{
  
   if (pCard->stateFlags & PCS_HPP_SERVICE_READY) 
   {
      if (pCard->rcmcData.healthCallback) 
      {
         if (!pEvent->ulEventId) 
         {
            osDEBUGPRINT((ALWAYS_PRINT, "\t!ulEventId! - assume HR_DD_STATUS_CHANGE_EVENT\n"));
            pEvent->ulEventId = HR_DD_STATUS_CHANGE_EVENT;
         }

         if (!pEvent->ulData1) 
         {
            osDEBUGPRINT( (ALWAYS_PRINT, "\t!ulData1 - assume CBS_HBA_STATUS_NORMAL\n"));
            pEvent->ulData1 = CBS_HBA_STATUS_NORMAL;
         }

         pEvent->ulSenderId = pCard->rcmcData.driverId; 
         pEvent->ulData2 = (ULONG) pCard->IoLBase;
         osDEBUGPRINT( (ALWAYS_PRINT,
            "\tulEventId: %x\tulSenderId: %x\tulData1: %x\tulData2: %x\n",
            pEvent->ulEventId,
            pEvent->ulSenderId,
            pEvent->ulData1,
            pEvent->ulData2));

         pCard->rcmcData.healthCallback (pEvent);
      }
      
      else
         osDEBUGPRINT((ALWAYS_PRINT, "\tRcmcSendEvent: CallBack address is NULL!\n"));
   }
   else
      osDEBUGPRINT((ALWAYS_PRINT, "\tRcmcSendEvent: Service not available!\n"));
}


PCARD_EXTENSION FindExtByPort(
   PPSUEDO_DEVICE_EXTENSION pPsuedoExtension,
   ULONG port
   ) 
/*++

 Routine Description:

   Support routine for Hot-Plug PCI. Find the pCard extension
   for the corresponding port address.

 Arguments:

   pPseudoExtension - Pointer to pseudo adapter storage area.
   port - port address of the HBA.

 Return Value:

   pCard - pointer to the actual pCard.

--*/
{
    UCHAR i;
    PCARD_EXTENSION pCard;

    pCard = 0;
  
    if (port) 
    {
        for (i = 1; i <= pPsuedoExtension->extensions[0]; i++) 
        {
            pCard = (PCARD_EXTENSION) pPsuedoExtension->extensions[i];
            if(port == (ULONG)pCard->IoLBase)
                break;
            else
                pCard = 0;
        }
    }
    return pCard;
}


ULONG
HppProcessIoctl(
   IN PPSUEDO_DEVICE_EXTENSION pPsuedoExtension,
   PVOID pIoctlBuffer,
   IN PSCSI_REQUEST_BLOCK pSrb
   )

/*++

 Routine Description:

   This is routine is called by PseudoStartIo to handle controller
   IOCTLs specific for the support of Hot-Plug PCI

 Arguments:

   pPseudoExtension - Pointer to adapter storage area.
   pIoctlBuffer - Pointer to INOUT IOCTL data buffer.
   pSrb - Pointer to the request to be processed.

 Return Value:

   status - status of IOCTL request (COMPLETED, PENDING, INVALID)

--*/

{
   ULONG status;
   PIOCTL_TEMPLATE pHppIoctl = pIoctlBuffer;
   PCARD_EXTENSION pCard;
   UCHAR i;

   //
   // Set status here so that exceptions need only be handled later
   //

   pHppIoctl->Header.ReturnCode = IOS_HPP_SUCCESS;
   status = IOP_HPP_COMPLETED;

   //
   // Act according to request.
   //

   switch(pHppIoctl->Header.ControlCode) 
   {
      case IOC_HPP_RCMC_INFO: 
      {     // 0x1
         PHPP_RCMC_INFO pRcmcInfo;     // Pointer to Hot Plug RCMC info record
         HR_EVENT event;

         osDEBUGPRINT((ALWAYS_PRINT, "\tIOC_HPP_RCMC_INFO:\n"));
         //
         // Verify that indicated buffer length is adequate
         //    
         if (pHppIoctl->Header.Length < sizeof(HPP_RCMC_INFO)) 
         {
            osDEBUGPRINT((ALWAYS_PRINT, "\tBufferIn: %x\tBufferOut: %x\n",
               pHppIoctl->Header.Length, sizeof(HPP_RCMC_INFO)));
            pHppIoctl->Header.ReturnCode = IOS_HPP_BUFFER_TOO_SMALL;
            break;
         } 
         pRcmcInfo = (PHPP_RCMC_INFO) pHppIoctl->ReturnData;
         //
         // Locate pointer to associated device extension from pool
         //
         pCard = FindExtByPort(pPsuedoExtension, pRcmcInfo->sControllerID.ulIOBaseAddress);
         
         //
         // Did we find the targeted extension?
         //
         
         if (pCard) 
         {
            switch (pRcmcInfo->eServiceStatus) 
            {
            case HPRS_SERVICE_STARTING:
               osDEBUGPRINT((ALWAYS_PRINT, "\tHPRS_SERVICE_STARTING\n"));
               //
               // Verify that Hot Plug unique driver id is supplied.
               //
               if (pRcmcInfo->ulDriverID) 
               {
                  //
                  // Verify that Hot Plug Health driver call-back address was provided.
                  //
                  if (pRcmcInfo->vpCallbackAddress) 
                  {
                     //
                     // Record service data in device extension.
                     //
                     pCard->stateFlags |= PCS_HPP_SERVICE_READY;
                     pCard->rcmcData.driverId = pRcmcInfo->ulDriverID;
                     pCard->rcmcData.healthCallback = pRcmcInfo->vpCallbackAddress;
                     pCard->rcmcData.slot = (UCHAR) pRcmcInfo->ulPhysicalSlot;
                     pCard->rcmcData.controllerChassis = pRcmcInfo->ulCntrlChassis;                  
                  }
                  else  // Call back address not given.
                     pHppIoctl->Header.ReturnCode = IOS_HPP_INVALID_CALLBACK;
               }
               else 
               {     // No id, no Hot Plug service...
                  osDEBUGPRINT((ALWAYS_PRINT, "\tIOS_HPP_INVALID_CONTROLLER\n"));
                  pHppIoctl->Header.ReturnCode = IOS_HPP_INVALID_CONTROLLER; 
               }
               break;

            case HPRS_SERVICE_STOPPING:
               osDEBUGPRINT((ALWAYS_PRINT, "\tHPRS_SERVICE_STOPPING\n"));
               if (pCard->stateFlags & PCS_HPP_SERVICE_READY) 
               {
                  //
                  // Assume that service had been up...
                  //
                  pCard->rcmcData.driverId = 0;
                  pCard->stateFlags &= ~PCS_HPP_SERVICE_READY;
                  pCard->rcmcData.healthCallback = 0;
                  pCard->stateFlags &= ~PCS_HPP_HOT_PLUG_SLOT;
               }
               else 
               {
                  osDEBUGPRINT((ALWAYS_PRINT, "\tIOS_HPP_NO_SERVICE\n"));
                  pHppIoctl->Header.ReturnCode = IOS_HPP_INVALID_SERVICE_STATUS; 
               }
               break;
         
            default:
               osDEBUGPRINT((ALWAYS_PRINT, "\tUnknown case status: %x\n",
                  pRcmcInfo->eServiceStatus)); 
               pHppIoctl->Header.ReturnCode = IOS_HPP_INVALID_SERVICE_STATUS;
            } // end switch on service status  
         } // end if (pCard) 
         else 
         {  // Invalid IO address extension not valid
            osDEBUGPRINT((ALWAYS_PRINT, "\tIOC_HPP_RCMC_INFO: Invalid controller: %x\n",
               pRcmcInfo->sControllerID.ulIOBaseAddress));
            pHppIoctl->Header.ReturnCode = IOS_HPP_INVALID_CONTROLLER; 
         }
         
         break;
      } // end case IOC_HPP_RCMC_INFO:


      case IOC_HPP_HBA_INFO: 
      {     // 0x03, used to be 0x2
         PHPP_CTRL_INFO pHbaInfo;      // Pointer to HBA info record.
         osDEBUGPRINT((ALWAYS_PRINT, "\tIOC_HPP_HBA_INFO:\n"));
      
         //
         // Verify that indicated buffer length is adequate.
         //
         if (pHppIoctl->Header.Length < sizeof(HPP_CTRL_INFO)) 
         {
            osDEBUGPRINT((ALWAYS_PRINT, "\tBufferIn: %x\tBufferOut: %x\n",
               pHppIoctl->Header.Length, sizeof(HPP_CTRL_INFO)));
            pHppIoctl->Header.ReturnCode = IOS_HPP_BUFFER_TOO_SMALL;
            break;
         }  
         pHbaInfo = (PHPP_CTRL_INFO) pHppIoctl->ReturnData;
      
         //
         // Locate pointer to associated device extension from pool.
         //
         pCard = FindExtByPort(pPsuedoExtension, pHbaInfo->sControllerID.ulIOBaseAddress);
      
         //
         // Did we find the targeted extension?
         //
      
         if (pCard) 
         {
            pHbaInfo->eSupportClass = HPSC_MINIPORT_STORAGE;
            pHbaInfo->ulSupportVersion = HPP_VERSION;
      
            pHbaInfo->sController.eBusType = HPPBT_PCI_BUS_TYPE;
            pHbaInfo->sController.sPciDescriptor.ucBusNumber = (UCHAR)pCard->SystemIoBusNumber;
            pHbaInfo->sController.sPciDescriptor.fcDeviceNumber = (UCHAR)pCard->SlotNumber;
            pHbaInfo->sController.sPciDescriptor.fcFunctionNumber = 0;
            pHbaInfo->sController.ulSlotNumber = 0;
      
            pHbaInfo->sController.ulProductID = 
               *((PULONG)(((PUCHAR)pCard->pciConfigData) + 0));      // Use PCI DeviceID and VendorID
      
            osStringCopy(pHbaInfo->sController.szControllerDesc, 
               HBA_DESCRIPTION, HPPStrLen(HBA_DESCRIPTION));
      
            pHbaInfo->sController.asCtrlAddress[0].fValid = TRUE;
            pHbaInfo->sController.asCtrlAddress[0].eAddrType = HPPAT_IO_ADDR;
            pHbaInfo->sController.asCtrlAddress[0].ulStart = (ULONG) pCard->IoLBase;
            pHbaInfo->sController.asCtrlAddress[0].ulLength = pCard->rcmcData.accessRangeLength[0];
      
            pHbaInfo->sController.asCtrlAddress[1].fValid = TRUE;
            pHbaInfo->sController.asCtrlAddress[1].eAddrType = HPPAT_IO_ADDR;
            pHbaInfo->sController.asCtrlAddress[1].ulStart = (ULONG) pCard->IoUpBase;
            pHbaInfo->sController.asCtrlAddress[1].ulLength = pCard->rcmcData.accessRangeLength[1];
      
            pHbaInfo->sController.asCtrlAddress[2].fValid = TRUE;
            pHbaInfo->sController.asCtrlAddress[2].eAddrType = HPPAT_MEM_ADDR;
            pHbaInfo->sController.asCtrlAddress[2].ulStart = (ULONG) pCard->MemIoBase;
            pHbaInfo->sController.asCtrlAddress[2].ulLength = pCard->rcmcData.accessRangeLength[2];
            
            pHbaInfo->sController.asCtrlAddress[3].fValid = FALSE;      // Default
            pHbaInfo->sController.asCtrlAddress[4].fValid = FALSE;      // Default
            if ( pCard->RamLength != 0)
            {
               pHbaInfo->sController.asCtrlAddress[3].fValid = TRUE;
               pHbaInfo->sController.asCtrlAddress[3].eAddrType = HPPAT_MEM_ADDR;
               pHbaInfo->sController.asCtrlAddress[3].ulStart = (ULONG)pCard->RamBase;
               pHbaInfo->sController.asCtrlAddress[3].ulLength = pCard->RamLength;
               if (pCard->RomLength !=0 )
               {
                  pHbaInfo->sController.asCtrlAddress[4].fValid = TRUE;
                  pHbaInfo->sController.asCtrlAddress[4].eAddrType = HPPAT_MEM_ADDR;
                  pHbaInfo->sController.asCtrlAddress[4].ulStart = (ULONG) pCard->RomBase;
                  pHbaInfo->sController.asCtrlAddress[4].ulLength = pCard->RomLength;
               }
            }
            else 
               if ( pCard->RomLength != 0)
               {
                  pHbaInfo->sController.asCtrlAddress[3].fValid = TRUE;
                  pHbaInfo->sController.asCtrlAddress[3].eAddrType = HPPAT_MEM_ADDR;
                  pHbaInfo->sController.asCtrlAddress[3].ulStart = (ULONG) pCard->RomBase;
                  pHbaInfo->sController.asCtrlAddress[3].ulLength = pCard->RomLength;
               }
      
            pHbaInfo->sController.asCtrlAddress[5].fValid = FALSE;
         }
         else 
         {  // Invalid IO address
            osDEBUGPRINT((ALWAYS_PRINT, "\tIOC_HPP_HBA_INFO: Invalid controller: %x\n",
               pHbaInfo->sControllerID.ulIOBaseAddress));
            pHppIoctl->Header.ReturnCode = IOS_HPP_INVALID_CONTROLLER;
         }
   
         break;
      } // end case IOC_HPP_HBA_INFO
   
   
      case IOC_HPP_HBA_STATUS:  
      {     // 0x2, used to be 0x3
         PHPP_CTRL_STATUS pHbaStatus;
   
         //
         // Verify that indicated buffer length is adequate.
         //
         if (pHppIoctl->Header.Length < sizeof(HPP_CTRL_STATUS)) 
         {
            osDEBUGPRINT((ALWAYS_PRINT, "\tBufferIn: %x\tBufferOut: %x\n",
               pHppIoctl->Header.Length, sizeof(HPP_CTRL_STATUS)));
            pHppIoctl->Header.ReturnCode = IOS_HPP_BUFFER_TOO_SMALL;
            break;
         }
   
         pHbaStatus = (PHPP_CTRL_STATUS) pHppIoctl->ReturnData;
   
         pCard = FindExtByPort(pPsuedoExtension, pHbaStatus->sControllerID.ulIOBaseAddress);
   
         if (pCard) 
         {
            pHbaStatus->ulStatus = pCard->stateFlags;
   //       osDEBUGPRINT((ALWAYS_PRINT, "\tstateFlags: %x\n", pCard->stateFlags));
         }
         else 
         {  // Invalid IO address
            osDEBUGPRINT((ALWAYS_PRINT, "\tIOC_HPP_RCMC_INFO: Invalid controller: %x\n",
               pHbaStatus->sControllerID.ulIOBaseAddress));
            pHppIoctl->Header.ReturnCode = IOS_HPP_INVALID_CONTROLLER;
         }
         break;
      } // end case IOC_HPP_HBA_STATUS
   
   
      case IOC_HPP_SLOT_TYPE:  
      {     // 0x4
         PHPP_CTRL_SLOT_TYPE pSlotType;
   
         osDEBUGPRINT((ALWAYS_PRINT, "\tIOC_HPP_SLOT_TYPE\n"));
   
         if (pHppIoctl->Header.Length < sizeof(HPP_CTRL_SLOT_TYPE)) 
         {
            osDEBUGPRINT((ALWAYS_PRINT, "\tBufferIn: %x\tBufferOut: %x\n",
               pHppIoctl->Header.Length, sizeof(HPP_CTRL_SLOT_TYPE)));
            pHppIoctl->Header.ReturnCode = IOS_HPP_BUFFER_TOO_SMALL;
            break;
         }
   
         pSlotType = (PHPP_CTRL_SLOT_TYPE) pHppIoctl->ReturnData;
   
         pCard = FindExtByPort(pPsuedoExtension, pSlotType->sControllerID.ulIOBaseAddress);
   
         if (pCard) 
         {
            osDEBUGPRINT((ALWAYS_PRINT, "\teSlotType: %x\n", pSlotType->eSlotType));
   
            if (pSlotType->eSlotType == HPPST_HOTPLUG_PCI_SLOT) 
            {
               pCard->stateFlags |= PCS_HPP_HOT_PLUG_SLOT;
            }
            else 
            {
               osDEBUGPRINT((ALWAYS_PRINT, "\tIOC_HPP_SLOT_TYPE: Reset HOT_PLUG_SLOT\n"));
               pCard->stateFlags &= ~PCS_HPP_HOT_PLUG_SLOT; 
            }
         } // end if (pCard) 
   
         else 
         {  // Invalid IO address
            osDEBUGPRINT((ALWAYS_PRINT, "\tIOC_HPP_RCMC_INFO: Invalid controller: %x\n",
               pSlotType->sControllerID.ulIOBaseAddress));
            pHppIoctl->Header.ReturnCode = IOS_HPP_INVALID_CONTROLLER; 
         }
         break;
      } // end case IOC_HPP_SLOT_TYPE
   
   
      case IOC_HPP_SLOT_EVENT: 
      {     // 0x6
         PHPP_SLOT_EVENT            pSlotEvent;
         HR_EVENT rcmcEvent =    {0,0,0,0};
         BOOLEAN rcmcEventFlag =    FALSE;
   
         osDEBUGPRINT((ALWAYS_PRINT, "\tIOC_HPP_SLOT_EVENT:  "));
   
         // Verify that indicated buffer length is adequate.
   
         if (pHppIoctl->Header.Length < sizeof(HPP_SLOT_EVENT)) 
         {
            osDEBUGPRINT((ALWAYS_PRINT, "\tBufferIn: %x\tBufferOut: %x\n",
               pHppIoctl->Header.Length, sizeof(HPP_SLOT_EVENT)));
            pHppIoctl->Header.ReturnCode = IOS_HPP_BUFFER_TOO_SMALL;
            break;
         }
   
         pSlotEvent = (PHPP_SLOT_EVENT) pHppIoctl->ReturnData;
   
         pCard = FindExtByPort(pPsuedoExtension, pSlotEvent->sControllerID.ulIOBaseAddress);
   
         if (pCard) 
         {
            if (pCard->stateFlags & PCS_HPP_SERVICE_READY) 
            {
               osDEBUGPRINT((ALWAYS_PRINT, "\tPCS_HPP_SERVICE_READY.\n"));
   
               if (pCard->stateFlags & PCS_HPP_HOT_PLUG_SLOT) 
               {
                  osDEBUGPRINT((ALWAYS_PRINT, "\tPCS_HPP_HOT_PLUG_SLOT.\n"));
   
                  switch (pSlotEvent->eSlotStatus) 
                  {
                  case HPPSS_NORMAL_OPERATION:
   
                     if ((pCard->controlFlags & ~LCS_HBA_TIMER_ACTIVE) ||
                        (pCard->stateFlags & PCS_HPP_POWER_DOWN)) 
                     {
                        pHppIoctl->Header.ReturnCode = IOS_HPP_HBA_BUSY;
                     }
                     else 
                     {
                        osDEBUGPRINT((ALWAYS_PRINT, "\tHPPSS_NORMAL_OPERATION\n"));
                        //
                        // Let timer init controller and report results to Hot Plug rcmc.
                        //
                        osDEBUGPRINT((ALWAYS_PRINT, "\tUNFAIL Flags Set\n"));
                        PCS_SET_UNFAIL(pCard->stateFlags);
                        pCard->controlFlags |= LCS_HPP_POWER_UP; 
                     }
                     break;
   
                  case HPPSS_SIMULATED_FAILURE:
   
                     osDEBUGPRINT((ALWAYS_PRINT, "\tHPPSS_SIMULATED_FAILURE\n"));
                     if (pCard->stateFlags & PCS_HBA_FAILED) 
                     {
                        osDEBUGPRINT((ALWAYS_PRINT, "\tSlot already failed\n"));
                     }
                     else if (pCard->controlFlags & ~LCS_HBA_TIMER_ACTIVE) 
                     {
                        pHppIoctl->Header.ReturnCode = IOS_HPP_HBA_BUSY;
                     }
                     else if (pCard->stateFlags & PCS_HBA_EXPANDING) 
                     {
                        pHppIoctl->Header.ReturnCode = IOS_HPP_HBA_EXPANDING;
                     }
                     else 
                     {
                        // Change for TL code, ignore the PCS_HBA_CACHE_IN_USE flag.
                        HOLD_IO(pCard);
                        // Set to fail....
                        PCS_SET_USER_FAIL(pCard->stateFlags);
                        // Complete outstanding SP requests with reset status.
                        ScsiPortCompleteRequest(pCard,
                              SP_UNTAGGED,
                              SP_UNTAGGED,
                              SP_UNTAGGED,
                              SRB_STATUS_BUS_RESET);
   
                        pCard->controlFlags |= LCS_HBA_FAIL_ACTIVE;
                     }
   
                     break;
   
                  case HPPSS_POWER_FAULT: 
   
                     // Set state flags to power-fault
                     PCS_SET_PWR_FAULT(pCard->stateFlags);
                     // Let timer know about this....
                     pCard->controlFlags |= LCS_HPP_POWER_FAULT;
                     break;
   
                  case HPPSS_POWER_OFF_WARNING:
   
                     osDEBUGPRINT((ALWAYS_PRINT, "\tHPPSS_POWER_OFF_WARNING\n"));
                     if (pCard->stateFlags & PCS_HBA_EXPANDING) 
                     {
                        pHppIoctl->Header.ReturnCode = IOS_HPP_HBA_EXPANDING;
                     }
                     else if (pCard->controlFlags & ~LCS_HBA_TIMER_ACTIVE) 
                     {
                        pHppIoctl->Header.ReturnCode = IOS_HPP_HBA_BUSY;
                     }
                     else if (!(pCard->stateFlags & PCS_HPP_POWER_DOWN)) 
                     {
                        // Change for TL code, ignore PCS_HBA_CACHE_IN_USE.
                        HOLD_IO(pCard);
                        // Set physical flags to stall io at the active controller.
                        PCS_SET_PWR_OFF(pCard->stateFlags);
                        // Complete outstanding SP requests with reset status.
                        ScsiPortCompleteRequest(pCard,
                              SP_UNTAGGED,
                              SP_UNTAGGED,
                              SP_UNTAGGED,
                              SRB_STATUS_BUS_RESET);
   
                        // Set control flag to schedule timer based maintenance for
                        // the powered down controller.  
                        pCard->controlFlags |= LCS_HPP_POWER_DOWN;
                     
                        // The original SDK model disable the HBA interrupt 
                        // in HotPlugFailController in timer context.
                        // But it seems that this is the better place since
                        // the PCI power maight be turned off already by the time
                        // the timer kicks in.
   
                        //
                        // Shut down all interrupts on the adapter. 
                        //
                     #ifdef __REGISTERFORSHUTDOWN__
                     if (!pCard->AlreadyShutdown)
                        fcShutdownChannel(&pCard->hpRoot);
                     pCard->AlreadyShutdown++;
                     #else
                        fcShutdownChannel(&pCard->hpRoot);
                     #endif   
                        
                     }
                     break;
   
                  case HPPSS_POWER_OFF:
   
                     osDEBUGPRINT((ALWAYS_PRINT, "\tHPPSS_POWER_OFF\n"));
   
                     // Verify that we received a prior power off warning.  If not, we
                     // are in fault state.
   
                     if (!(pCard->stateFlags & PCS_HPP_POWER_DOWN)) 
                     {
                        // This is a fault condition....  Schedule event.
                        osDEBUGPRINT((ALWAYS_PRINT, "\tHPPSS_POWER_OFF: FAULT\n"));
                        PCS_SET_PWR_FAULT(pCard->stateFlags);
                        pCard->controlFlags |= LCS_HPP_POWER_FAULT;
                     } 
   
                     break;
   
                  case HPPSS_POWER_ON_WARNING:
   
                     // This warning is not needed or acted upon.
                     osDEBUGPRINT((ALWAYS_PRINT, "\tHPPSS_POWER_ON_WARNING\n"));
   
                     break;
   
                  case HPPSS_RESET:
                  case HPPSS_POWER_ON:
   
                     osDEBUGPRINT((ALWAYS_PRINT, "\tHPPSS_POWER_ON:\n"));
   
                     // Complete outstanding SP requests with reset status.
                     ScsiPortCompleteRequest(pCard,
                        SP_UNTAGGED,
                        SP_UNTAGGED,
                        SP_UNTAGGED,
                        SRB_STATUS_BUS_RESET);
   
                     PCS_SET_UNFAIL(pCard->stateFlags);
                     PCS_SET_PWR_ON(pCard->stateFlags);
                     
                     // Reset Countdown for returning SRB_STATUS_BUSY in StartIo.
                     pCard->IoHeldRetTimer = 0; 
                     
                     // Set Logical Flag to schedule power-up operations...
                     pCard->controlFlags |= LCS_HPP_POWER_UP;
   
                     // Not able to guess results of power-on process, so event will
                     // be handled by timer.
   
                     break;
   
                  case HPPSS_RESET_WARNING:  // Not implemented by service
                     break;
   
                  default:
                     pHppIoctl->Header.ReturnCode = IOS_HPP_BAD_REQUEST;
                     break;
   
                  } // end switch (pSlotEvent->eSlotStatus)
   
               } // end if for hot-plug slot
   
               else 
               {        // Not hot-plug slot
                  osDEBUGPRINT((ALWAYS_PRINT, "\tNot Hot-Plug slot\n"));
                  pHppIoctl->Header.ReturnCode = IOS_HPP_NOT_HOTPLUGABLE; 
               }
   
            } // end if (pCard->stateFlags & PCS_HPP_SERVICE_READY) 
   
            else 
            {
               osDEBUGPRINT((ALWAYS_PRINT, "\tService not started\n"));
               pHppIoctl->Header.ReturnCode = IOS_HPP_NO_SERVICE; 
            }
   
         } // end if (pCard) 
   
         else 
         {  // Invalid IO address
            osDEBUGPRINT((ALWAYS_PRINT, "\tInvalid IO address: %x\n",
               pSlotEvent->sControllerID.ulIOBaseAddress));
            pHppIoctl->Header.ReturnCode = IOS_HPP_INVALID_CONTROLLER; 
         }
   
         if (rcmcEventFlag) 
         {
            RcmcSendEvent(pCard, &rcmcEvent);
         }
   
         break;
   
      } // end case IOC_HPP_SLOT_EVENT:
   
      case IOC_HPP_PCI_CONFIG_MAP: 
      {
         PHPP_PCI_CONFIG_MAP pPciConfig;
         ULONG j;
   
         osDEBUGPRINT((ALWAYS_PRINT, "\tIOC_HPP_PCI_CONFIG_MAP.\n"));
         //
         // Verify that indicated buffer length is adequate.
         //
   
         if (pHppIoctl->Header.Length < sizeof(HPP_PCI_CONFIG_MAP)) 
         {
            osDEBUGPRINT((ALWAYS_PRINT, "\tBufferIn: %x\tBufferOut: %x\n",
               pHppIoctl->Header.Length, sizeof(HPP_PCI_CONFIG_MAP)));
            pHppIoctl->Header.ReturnCode = IOS_HPP_BUFFER_TOO_SMALL;
            break;
         }
   
         pPciConfig = (PHPP_PCI_CONFIG_MAP) &pHppIoctl->ReturnData;
   
         pCard = FindExtByPort(pPsuedoExtension, pPciConfig->sControllerID.ulIOBaseAddress);
   
         if (pCard) 
         {
            pPciConfig->ulPciConfigMapVersion = HPP_VERSION;
            pPciConfig->ulNumberOfPciDevices = 1;
   
            pPciConfig->sDeviceInfo[0].sPciDescriptor.ucBusNumber = (UCHAR)pCard->SystemIoBusNumber;
            pPciConfig->sDeviceInfo[0].sPciDescriptor.fcDeviceNumber = (UCHAR)pCard->SlotNumber;
            pPciConfig->sDeviceInfo[0].sPciDescriptor.fcFunctionNumber = 0;
            pPciConfig->sDeviceInfo[0].ucBaseAddrVerifyCount = pCard->rcmcData.numAccessRanges;
   
            // 
            // The pCard->rcmcData values are set in FindAdapter.C
            // 
   
            for (j = 0; j < pCard->rcmcData.numAccessRanges; j++) 
            {
               pPciConfig->sDeviceInfo[0].ulBaseAddrLength[j] = pCard->rcmcData.accessRangeLength[j];
            }
            
            // Adopted fron the Hot Plug SDK, may need to change ulNumberOfRanges value, 
            // this is not NUMBER_ACCESS_RANGES.
            //
            pPciConfig->sDeviceInfo[0].ulNumberOfRanges = 2;
            
            // These ranges are adopted from Hot Plug SDK, 
            // may need to change these values.
            //
            pPciConfig->sDeviceInfo[0].sPciConfigRangeDesc[0].ucStart = 6; 
            pPciConfig->sDeviceInfo[0].sPciConfigRangeDesc[0].ucEnd = 63;
            pPciConfig->sDeviceInfo[0].sPciConfigRangeDesc[1].ucStart = 4;
            pPciConfig->sDeviceInfo[0].sPciConfigRangeDesc[1].ucEnd = 5;
   
         } // end if (pCard) 
         
         else 
         {  // Invalid IO address
            osDEBUGPRINT((ALWAYS_PRINT, "\tInvalid IO address: %x\n",
               pPciConfig->sControllerID.ulIOBaseAddress));
            pHppIoctl->Header.ReturnCode = IOS_HPP_INVALID_CONTROLLER; 
         }
   
         break;
      }
   
      case IOC_HPP_DIAGNOSTICS:
      default:
         pHppIoctl->Header.ReturnCode = IOS_HPP_BAD_REQUEST;
         break;
   
   } // end switch
   
   return (status);
} // end HppProcessIoctl


BOOLEAN
PsuedoInit(
   IN PVOID pPsuedoExtension
   )

/*++

Routine Description:

    This function is called by the system during initialization to
    prepare the controller to receive requests.  In this case, we are
    dealing with a virtual controller that is utilized to receive and
    process side-band requests to all installed Hot Plug controllers.
   NT does not currently support IOCTL requests (other than INQ) 
   to controllers that do not posesse configured LUNS, so we introduced 
   the pseudo device to allow access to these adapters.

Arguments:

    pPsuedoExtension - Pointer to the psuedo device extension.

Return Value:

    TRUE

--*/

{
   ULONG i;
   PPSUEDO_DEVICE_EXTENSION pPsuedoExt = pPsuedoExtension;
   PCARD_EXTENSION pDevExt;

   osDEBUGPRINT((ALWAYS_PRINT,"PsuedoInit:Enter function...\n"));

   //
   // Set current Hot-Plug version.
   //

   pPsuedoExt->hotplugVersion = SUPPORT_VERSION_10;

   for (i = 1; i <= pPsuedoExt->extensions[0]; i++) 
   {
      pDevExt = (PCARD_EXTENSION) pPsuedoExt->extensions[i];
      pDevExt->pPsuedoExt = pPsuedoExt;
   }

   return TRUE;
} // end PsuedoInit()


BOOLEAN PsuedoStartIo(
   IN PVOID HwDeviceExtension,
   IN PSCSI_REQUEST_BLOCK pSrb
   )

/*++

  Routine Description:

  This routine is called by the system to start a request on the adapter.

  Arguments:

  HwDeviceExtension - Address of adapter storage area.
  pSrb - Address of the request to be started.

  Return Value:

  TRUE - The request has been started.
  FALSE - The controller was busy.

  --*/

{
   PPSUEDO_DEVICE_EXTENSION pPsuedoExtension = HwDeviceExtension;
   PLU_EXTENSION pLunExtension;
   ULONG i;
   ULONG tmp;
   UCHAR status;
   UCHAR tid = 0;

// osDEBUGPRINT((ALWAYS_PRINT, "PsuedoStartIo: Enter Routine:\n"));

   switch (pSrb->Function) 
   {
      case SRB_FUNCTION_RESET_BUS:
         status = SRB_STATUS_SUCCESS;
         break;

      case SRB_FUNCTION_EXECUTE_SCSI:
         switch (pSrb->Cdb[0]) 
         {
            case SCSIOP_TEST_UNIT_READY:
               osDEBUGPRINT((ALWAYS_PRINT, "\tSCSIOP_TEST_UNIT_READY:\n"));
               status = SRB_STATUS_SUCCESS;
               break;

            case SCSIOP_READ_CAPACITY:
               osDEBUGPRINT((ALWAYS_PRINT, "\tSCSIOP_TEST_UNIT_READY:\n"));
   
               //
               // Get logical unit extension.
               //
               pLunExtension = ScsiPortGetLogicalUnit(pPsuedoExtension,
                  pSrb->PathId,
                  pSrb->TargetId,
                  pSrb->Lun);

               if (pLunExtension) 
               {
                  ULONG blockSize = 0;
                  ULONG numberOfBlocks = 0;

                  //
                  // Get blocksize and number of blocks from identify data.
                  //
                  REVERSE_BYTES(
                     &((PREAD_CAPACITY_DATA) pSrb->DataBuffer)->BytesPerBlock,
                     &blockSize
                     );

                  REVERSE_BYTES(
                     &((PREAD_CAPACITY_DATA) pSrb->DataBuffer)->LogicalBlockAddress,
                     &numberOfBlocks);
                  status = SRB_STATUS_SUCCESS;
               }
               else 
               {
                  status = SRB_STATUS_ERROR;
               }

               break;

            case SCSIOP_INQUIRY:
               osDEBUGPRINT((ALWAYS_PRINT, "\tSCSIOP_INQUIRY:\n"));
               osDEBUGPRINT((ALWAYS_PRINT, "\tLUN: %x  TID: %x\n", pSrb->Lun, pSrb->TargetId));

               //
               // Only respond at logical unit 0;
               //
               if (pSrb->Lun != 0) 
               {
                  //
                  // Indicate no device found at this address.
                  //
                  status = SRB_STATUS_SELECTION_TIMEOUT;
                  break;
               }

               //
               // Check if this is for one of the known controllers.
               //
               if (pSrb->TargetId >= 1) 
               {
                  //
                  // Indicate no device found at this address.
                  //
                  status = SRB_STATUS_SELECTION_TIMEOUT;
                  break;
               }

               //
               // Zero INQUIRY data structure.
               //
               for (i = 0; i < pSrb->DataTransferLength; i++) 
               {
                  ((PUCHAR) pSrb->DataBuffer)[i] = 0;
               }

               //
               // Set to funky device type to hide from windisk.
               //
               ((PINQUIRYDATA) pSrb->DataBuffer)->DeviceType = DEVICE_QUALIFIER_NOT_SUPPORTED;

               //
               // Fill in vendor identification fields.
               //
               tid = pSrb->TargetId + 0x30;

               osDEBUGPRINT((ALWAYS_PRINT, "\tSCSIOP_INQUIRY: tid: %x lun: %c\n", pSrb->TargetId, tid));

               ((PINQUIRYDATA) pSrb->DataBuffer)->VendorId[0] = 'H';
               ((PINQUIRYDATA) pSrb->DataBuffer)->VendorId[1] = 'o';
               ((PINQUIRYDATA) pSrb->DataBuffer)->VendorId[2] = 't';
               ((PINQUIRYDATA) pSrb->DataBuffer)->VendorId[3] = 'P';
               ((PINQUIRYDATA) pSrb->DataBuffer)->VendorId[4] = 'l';
               ((PINQUIRYDATA) pSrb->DataBuffer)->VendorId[5] = 'u';
               ((PINQUIRYDATA) pSrb->DataBuffer)->VendorId[6] = 'g';
               ((PINQUIRYDATA) pSrb->DataBuffer)->VendorId[7] = ' ';

               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[0]  = 'P';
               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[1]  = 'S';
               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[2]  = 'E';
               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[3]  = 'U';
               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[4]  = 'D';
               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[5]  = 'O';
               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[6]  = ' ';
               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[7]  = ' ';
               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[8]  = ' ';
               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[9]  = ' ';
               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[10] = ' ';
               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[11] = ' ';
               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[12] = ' ';
               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[13] = ' ';
               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[14] = ' ';
               ((PINQUIRYDATA) pSrb->DataBuffer)->ProductId[15] = ' ';

               tmp = pPsuedoExtension->hotplugVersion;

               for (i = 0; i < 4; i++) 
               {
                  ((PINQUIRYDATA) pSrb->DataBuffer)->ProductRevisionLevel[i] = (UCHAR) tmp + 0x30;
                  tmp >>= 8;
               }

               status = SRB_STATUS_SUCCESS;
               break;

            case SCSIOP_VERIFY:

               //
               // Just return success.
               //
               status = SRB_STATUS_SUCCESS;
               break;

            default:
               osDEBUGPRINT((ALWAYS_PRINT, "\tpSrb->Cdb[0]: %x\n", pSrb->Cdb[0]));
               status = SRB_STATUS_INVALID_REQUEST;
               break;

         } // end switch (pSrb->Cdb[0])

      break;

      //
      // Issue FLUSH/DISABLE if shutdown command.
      //

      case SRB_FUNCTION_SHUTDOWN:
         osDEBUGPRINT((ALWAYS_PRINT, "\tSRB_FUNCTION_SHUTDOWN\n"));
         osDEBUGPRINT((ALWAYS_PRINT, "\tpPsuedoExtension: %x\n", pPsuedoExtension));
         status = SRB_STATUS_SUCCESS;
         break;

      case SRB_FUNCTION_FLUSH:
         //
         // Just return success.
         //
         status = SRB_STATUS_SUCCESS;
         break;

      case SRB_FUNCTION_IO_CONTROL: 
      {
         PIOCTL_TEMPLATE pIoctlBuffer;

//       osDEBUGPRINT((ALWAYS_PRINT, "\tSRB_FUNCTION_IO_CONTROL\n"));
         pIoctlBuffer = (PIOCTL_TEMPLATE) pSrb->DataBuffer;

         //
         // Status is returned mainly in 2 fields to the calling thread.
         // These 2 fields determine if other status fields are valid to
         // check. If the request is not a valid request for this driver
         // then the Header.ReturnCode is not modified and the
         // pSrb->SrbStatus is set to SRB_STATUS_INVALID_REQUEST.  If
         // the request is valid for this driver then pSrb->SrbStatus
         // is always returned as SRB_STATUS_SUCCESS and the
         // Header.ReturnCode contains information concerning the
         // status of the particular request.
         //

         if (osStringCompare(pIoctlBuffer->Header.Signature, CPQ_HPP_SIGNATURE)) 
         {
            if (HppProcessIoctl(pPsuedoExtension, pIoctlBuffer, pSrb) == IOP_HPP_ISSUED) 
            {
               status = SRB_STATUS_PENDING;
            }
            else 
            {
               status = SRB_STATUS_SUCCESS;
            }
         }
         else 
         {
            status = SRB_STATUS_INVALID_REQUEST;
         }

         break;
      }

      default:
         osDEBUGPRINT((ALWAYS_PRINT, "\tFunction: %x\n", pSrb->Function));
         status = SRB_STATUS_INVALID_REQUEST;

   } // end switch

   //
   // Indicate to system that the controller can take another request
   // for this device.
   //
   ScsiPortNotification(NextLuRequest,
      pPsuedoExtension,
      pSrb->PathId,
      pSrb->TargetId,
      pSrb->Lun);
   
   //
   // Check if SRB should be completed.
   //

   if (status != SRB_STATUS_PENDING) 
   {
      //
      // Set status in SRB.
      //
      pSrb->SrbStatus = status;

      //
      // Inform system that this request is complete.
      //
      ScsiPortNotification(RequestComplete,
         pPsuedoExtension,
         pSrb);
   }

   return TRUE;
  
}  // end PseudoStartIo()


ULONG
PsuedoFind(
   IN OUT PVOID pDeviceExtension,
   IN OUT PVOID pContext,
   IN PVOID pBusInformation,
   IN PCHAR pArgumentString,
   IN OUT PPORT_CONFIGURATION_INFORMATION pConfigInfo,
   OUT PBOOLEAN pAgain
   )

/*++

Routine Description:

   This routine is called by the SCSI port driver to find the
   controllers on the system's PCI buses.  The function fills out
   the controller's resource requirements in the port configuration
   information and begins the initialization process for the controller.


Arguments:

   pPseudoExtension - pointer to the miniport driver's per-controller
                      storage area
   pContext - pointer  to the context value passed to ScsiPortInitialize()
   pBusInformation - pointer to bus type specific information
   pArgumentString - pointer to null-terminated ASCII string
   pConfigInfo - pointer to SCSI port configuration information


Return Values:

   pPseudoExtension - Minport driver's per-controller storage area
   pContext - Context value passed to ScsiPortInitialize()
   pConfigInfo - pointer to SCSI port configuration information
   pAgain - Indicates to call function again to find more controllers.

   Function Return Values:

   SP_RETURN_FOUND - Indicates a host adapter was found and the configuration
                     information was successfully determined.

   SP_RETURN_ERROR - Indicates a host adapter was found but an error occurred
                     obtaining the configuration information.

   SP_RETURN_NOT_FOUND - Indicates no host adapter was found for the supplied
                         configuration information.

   SP_RETURN_BAD_CONFIG - Indicates the supplied configuration information
                          was invalid.

-- */

{
   PPSUEDO_DEVICE_EXTENSION pPsuedoExtension;
   PHOT_PLUG_CONTEXT pHotPlugContext = (PHOT_PLUG_CONTEXT) pContext;
   UCHAR i;

   UNREFERENCED_PARAMETER(pBusInformation);
   UNREFERENCED_PARAMETER(pArgumentString);

   pPsuedoExtension = (PPSUEDO_DEVICE_EXTENSION) pDeviceExtension;
   osDEBUGPRINT((ALWAYS_PRINT, "\nPsuedoFind:  Enter function...\n"));
   *pAgain = FALSE;

   //
   // We will be called once for every PCI bus found on the system....  
   // We want to return a device only once.
   //

   if (((PHOT_PLUG_CONTEXT) pContext)->psuedoDone)
      return (SP_RETURN_NOT_FOUND);

   //
   // Copy known logical device extensions to pseudo extension
   //
   for (i = 0; i <= pHotPlugContext->extensions[0]; i++)
      pPsuedoExtension->extensions[i] = pHotPlugContext->extensions[i];

   //
   // Now put psuedo extension at the end of the list
   //
   pPsuedoExtension->extensions[pHotPlugContext->extensions[0]+1] = (ULONG) pPsuedoExtension;

   //
   // Supply required device info
   //
   pConfigInfo->MaximumTransferLength = 0x400;
   pConfigInfo->NumberOfPhysicalBreaks = 0;
   pConfigInfo->NumberOfBuses = 1;
   pConfigInfo->ScatterGather = FALSE;
   pConfigInfo->Master = FALSE;
   pConfigInfo->Dma32BitAddresses = FALSE;
   pConfigInfo->MaximumNumberOfTargets = 1;
   pConfigInfo->CachesData = FALSE;
   pConfigInfo->InitiatorBusId[0] = (UCHAR) INITIATOR_BUS_ID;
   ((PHOT_PLUG_CONTEXT) pContext)->psuedoDone = TRUE;
   return (SP_RETURN_FOUND);

} // end PseudoFind()


BOOLEAN
PsuedoResetBus(
   IN PVOID HwDeviceExtension, 
   IN ULONG PathId 
   )

/*++

Routine Description:

   This routine resets the controller and completes outstanding requests.

Arguments:

   HwDeviceExtension - Address of adapter storage area.
   PathId - Indicates adapter to reset.

Return Value:

   TRUE

--*/

{
   osDEBUGPRINT((ALWAYS_PRINT, "PsuedoResetBus: Enter function...\n"));
   return TRUE;
}


VOID
HotPlugFailController(
   PCARD_EXTENSION pCard
   ) 

/*++

Routine Description:

   Fails active controller
    
Arguments:

   pCard  - Pointer to active controller device extension.

Return Value:

   Nothing

--*/

{
   agRoot_t * phpRoot = &pCard->hpRoot;
   HR_EVENT rcmcEvent = {0, 0, 0, 0 };

   osDEBUGPRINT((ALWAYS_PRINT, "\tHotPlugFailController: Enter\n"));

   // We need to actually disable the Tachyon TL HBA and 
   // Shut down all interrupts on the adapter.
   //

   fcShutdownChannel(phpRoot);

   //
   // Send event notification of failure with status corresponding to
   // physical_HBA status flags.
   //
   // Note:  if we are handling a simple power-off, the event sent will
   // indicate normal.  There are no currently defined messages for
   // power related issues.  For now....let's not send the normal case,
   // as the set Not Ready message will be removed in the Hot Plug UI.
   //
   
   rcmcEvent.ulEventId = HR_DD_STATUS_CHANGE_EVENT;
   RCMC_SET_STATUS(pCard->stateFlags, rcmcEvent.ulData1);

   //
   // It seems that the Intel version of Hot Plug software always 
   // requires event to be sent.
   //

// if (rcmcEvent.ulData1 != CBS_HBA_STATUS_NORMAL) 
// {
      // Send Hot Plug rcmc event.
      osDEBUGPRINT((ALWAYS_PRINT, "\tCall RcmcSendEvent\n"));
      RcmcSendEvent(pCard, &rcmcEvent);
// } 

   //
   // Clear fail control bit so the Timer will not call
   // this routine again.
   //

   osDEBUGPRINT((ALWAYS_PRINT, "\tClear FAIL_ACTIVE controlFlags\n"));
   pCard->controlFlags &= ~LCS_HBA_FAIL_ACTIVE;
   osDEBUGPRINT((ALWAYS_PRINT, "\tHotPlugFailController: Exit\n"));

}


VOID
HotPlugInitController(
   PCARD_EXTENSION pCard
   )

/*++

Routine Description:

   Initializes controller 
    
Arguments:

   pCard  - Pointer to active controller device extension.

Return Value:

   Nothing

--*/

{
   agRoot_t * phpRoot = &pCard->hpRoot;
   ULONG   return_value;
   
   osDEBUGPRINT((ALWAYS_PRINT, "\tEnter HotPlugInitController Slot: %d\n", pCard->rcmcData.slot));

   // 
   // Re-Initilaize the HBA.
   //
   return_value = fcInitializeChannel(  phpRoot,
                                         fcSyncInit,
                                         agTRUE, // sysIntsActive
                                         pCard->cachedMemoryPtr,
                                         pCard->cachedMemoryNeeded,
                                         pCard->dmaMemoryUpper32,
                                         pCard->dmaMemoryLower32,
                                         pCard->dmaMemoryPtr,
                                         pCard->dmaMemoryNeeded,
                                         pCard->nvMemoryNeeded,
                                         pCard->cardRamUpper,
                                         pCard->cardRamLower,
                                         pCard->RamLength ,
                                         pCard->cardRomUpper,
                                         pCard->cardRomLower,
                                         pCard->RomLength,
                                         pCard->usecsPerTick );

   if (return_value != fcInitializeSuccess) 
   {
      // Re-initializing HBA failed.
      pCard->controlFlags |= LCS_HBA_FAIL_ACTIVE;     
      #ifdef _DEBUG_EVENTLOG_
      LogEvent(   pCard, 
                  NULL,
                  HPFC_MSG_INITIALIZECHANNELFAILED,
                  NULL, 
                  0, 
                  "%xx", return_value);
      #endif
      osDEBUGPRINT((ALWAYS_PRINT, "\tHotPlugInitController: fcInitializeChannel FAILED error code : %x.\n", 
         return_value ));
   }
   else
   {
      // Re-initializing HBA successfull.
      osDEBUGPRINT((ALWAYS_PRINT, "\tHotPlugInitController OK.\n"));
      // Clear LCS_HBA_INIT startup bit so Timer will not call again.
      osDEBUGPRINT((ALWAYS_PRINT, "\tClear LCS_HBA_INIT startup control\n"));
      pCard->controlFlags &= ~LCS_HBA_INIT;
   }

   osDEBUGPRINT((ALWAYS_PRINT, "\tHotPlugInitController : Exit\n"));
   #ifdef _DEBUG_EVENTLOG_
   {
   LogHBAInformation(pCard);
   }
   #endif

}


VOID
HotPlugReadyController(
   PCARD_EXTENSION pCard
   )

/*++

Routine Description:

   Readies controller for system use
    
Arguments:

   pCard  - Pointer to active controller device extension.

Return Value:

   Nothing

--*/

{
   HR_EVENT rcmcEvent = {0,0,0,0};
   UCHAR    targetId;
   PLU_EXTENSION pLunExtension;

   osDEBUGPRINT((ALWAYS_PRINT, "\tHotPlugReadyController : Enter Slot %d\n", pCard->rcmcData.slot));

   ScsiPortCompleteRequest(pCard,
      SP_UNTAGGED,
      SP_UNTAGGED,
      SP_UNTAGGED,
      SRB_STATUS_BUS_RESET);

   //
   // Clear ready control bits, so the timer routine will not call again.
   //
   pCard->controlFlags &= ~LCS_HBA_READY_ACTIVE;

   //
   // Although Tachyon TL does not have cache, just enable the flag
   // to indicate that cache is safe to be enable.
   //

   // Commented out, avoid unnecessary complication.
   // pCard->stateFlags |= PCS_HBA_CACHE_IN_USE;

   pCard->stateFlags &= ~PCS_HBA_OFFLINE;

   osDEBUGPRINT((ALWAYS_PRINT, "\tNotify ready to port driver\n"));

   ScsiPortNotification(NextRequest, pCard, NULL);

   #ifndef YAM2_1
   for (targetId = 0; targetId < MAXIMUM_TID; targetId++) 
   #else
   for (targetId = 0; targetId < gMaximumTargetIDs; targetId++) 
   #endif
   {
      pLunExtension = ScsiPortGetLogicalUnit(pCard, 0, targetId, 0);
      if (pLunExtension) 
      {
         ScsiPortNotification(NextLuRequest, pCard, 0, targetId, 0); 
      }
   }

   // Send Hot Plug rcmc event. 
   rcmcEvent.ulEventId = HR_DD_STATUS_CHANGE_EVENT;
   RCMC_SET_STATUS(pCard->stateFlags, rcmcEvent.ulData1);
   RcmcSendEvent(pCard, &rcmcEvent);

   osDEBUGPRINT((ALWAYS_PRINT, "\tHotPlugReadyController : Exit\n"));

}


BOOLEAN
HotPlugTimer(
   PCARD_EXTENSION pCard
   )
/*++

Routine Description:

   Handles all Hot-Plug related state transitions and monitoring 
   responsibilities. This routine is called by the Timer routine.

Arguments:

   pCard - Address of adapter storage area.

Return Value:

   TRUE - PCI Hot Plug related activities were done.
   FALSE - No PCI Hot Plug task to do, normal operation.

--*/

{
   BOOLEAN  hotPlugTask = FALSE;
   ULONG controlFlags = pCard->controlFlags;
   ULONG stateFlags = pCard->stateFlags;

   if ( (pCard->stateFlags & PCS_HPP_POWER_DOWN) && !(pCard->stateFlags & PCS_HBA_FAILED) ) 
   {
      hotPlugTask = TRUE;
      osDEBUGPRINT((ALWAYS_PRINT, 
         "\nHotPlugTimer slot [%d] reports ResetDetected: IoHeldRetTimer = %d\n", 
         pCard->rcmcData.slot, pCard->IoHeldRetTimer ));
      
      // Increment countdown for returning SRB_STATUS_BUSY in StartIo.
      pCard->IoHeldRetTimer++;   
   
      //
      // This is different from the Hot Plug SDK, we only inform ResetDetected
      // if the PCI slot power is down.
      //
      ScsiPortNotification(ResetDetected, pCard, NULL);
   }  

   if (controlFlags & LCS_HBA_FAIL_ACTIVE) 
   {
      hotPlugTask = TRUE;
      osDEBUGPRINT((ALWAYS_PRINT, "\tTimer calling HotPlugFailController\n"));
      HotPlugFailController(pCard);
   }
   else 
      if (controlFlags & LCS_HBA_INIT) 
      {
         hotPlugTask = TRUE;
         osDEBUGPRINT((ALWAYS_PRINT, "\tHotPlugInitController requested - Slot %d\n", pCard->rcmcData.slot));
         HotPlugInitController(pCard);
      }
      else 
         if (pCard->controlFlags & LCS_HBA_READY_ACTIVE) 
         {
            hotPlugTask = TRUE;
            osDEBUGPRINT((ALWAYS_PRINT, "\tHotPlugReadyController requested - Slot %d\n", pCard->rcmcData.slot));
            HotPlugReadyController(pCard);
         } 

   if ( hotPlugTask == TRUE)
      osDEBUGPRINT((ALWAYS_PRINT, "\tHotPlugTimer TRUE on Slot: %x in controlFlags: %x, out controlFlags: %x, stateFlags: %x\n",
         pCard->rcmcData.slot, controlFlags, pCard->controlFlags, pCard->stateFlags));

   return hotPlugTask;
  
} // end HotPlugTimer


ULONG
HPPStrLen(
   IN PUCHAR p
   ) 
/*++

Routine Description:

   This routine determines string length

Arguments:

   p - Pointer to string

Return Value:

   ULONG length - length of string

--*/
{
   PUCHAR tp = p;
   ULONG length = 0;

   while (*tp++)
      length++;

   return length;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\hotplug4.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Module Name:

   HotPlug4.H

Abstract:

   This is the miniport driver for the Agilent 
   PCI to Fibre Channel Host Bus Adapter (HBA). 
   
   This module is specific to the NT 4.0 PCI Hot Plug feature 
   support routine header file. 

Authors:
   Ie Wei Njoo
 
Environment:

   kernel mode only

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/H/HotPlug4.H $

Revision History:

   $Revision: 3 $
   $Date: 9/07/00 11:16a $
   $Modtime::  $

Notes:

--*/

#ifndef __HOTPLUG_H__
#define __HOTPLUG_H__


// The BYTE, WORD, DWORD, INT, STATIC definitions are used by 
// the PCI Hot-Plug SDK header file.

#ifndef BYTE
#define BYTE unsigned char
#endif

#ifndef WORD
#define WORD unsigned short
#endif

#ifndef DWORD
#define DWORD unsigned long
#endif

#ifndef INT
#define INT int
#endif

#ifndef STATIC
#if DBG
#define STATIC
#else
#define STATIC static
#endif
#endif

#include "hppif3p.h"        // PCI Hot-Plug SDK header file

typedef struct _IOCTL_TEMPLATE {
   SRB_IO_CONTROL Header;
   UCHAR               ReturnData[1];
}IOCTL_TEMPLATE, *PIOCTL_TEMPLATE;

#define RET_VAL_MAX_ITER          30       // 30 second default wait while returning
                                           // SRB_STATUS_BUSY in StartIo
typedef struct _HOT_PLUG_CONTEXT {
   ULONG     extensions[MAX_CONTROLLERS];
   BOOLEAN   psuedoDone;
} HOT_PLUG_CONTEXT, *PHOT_PLUG_CONTEXT;

//
// Function prototypes for PCI Hot Plug support routines
//

VOID
RcmcSendEvent(
    IN PCARD_EXTENSION pCard,
    IN OUT PHR_EVENT pEvent
    );

PCARD_EXTENSION FindExtByPort(
    PPSUEDO_DEVICE_EXTENSION pPsuedoExtension,
    ULONG port
    );

ULONG
HppProcessIoctl(
    IN PPSUEDO_DEVICE_EXTENSION pPsuedoExtension,
    PVOID pIoctlBuffer,
    IN PSCSI_REQUEST_BLOCK pSrb
    );

BOOLEAN
PsuedoInit(
    IN PVOID pPsuedoExtension
    );

BOOLEAN PsuedoStartIo(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK pSrb
    );

ULONG
PsuedoFind(
    IN OUT PVOID pDeviceExtension,
    IN OUT PVOID pContext,
    IN PVOID pBusInformation,
    IN PCHAR pArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION pConfigInfo,
    OUT PBOOLEAN pAgain
    );

BOOLEAN
PsuedoResetBus(
    IN PVOID HwDeviceExtension,
    IN ULONG PathId
    );

VOID
HotPlugFailController(
    PCARD_EXTENSION pCard
    );

VOID
HotPlugInitController(
    PCARD_EXTENSION pCard
    );

VOID
HotPlugReadyController(
    PCARD_EXTENSION pCard
    );

BOOLEAN 
HotPlugTimer(
    PCARD_EXTENSION pCard
    );

ULONG
HPPStrLen(
    IN PUCHAR p
    ) ;

#endif // #define __HOTPLUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\hpfcctl.h ===
/*++

Copyright (c) 2000 Agilent Technologies

Module Name:

   hpfcctl.h

Abstract:

Authors:

Environment:

   kernel mode only

Notes:

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/H/hpfcctl.h $


Revision History:

   $Revision: 3 $
   $Date: 9/07/00 11:29a $
   $Modtime:: 8/31/00 3:31p            $

Notes:


--*/

#ifndef _HPFCCTL_
#define _HPFCCTL_

//#ifndef bit8
//#define bit8 unsigned char
//#endif

//#ifndef bit16
//#define bit16 unsigned short
//#endif

//#ifndef bit32
//#define bit32 unsigned int
//#endif

/* IOCTL Signature */
#define HP_FC_IOCTL_SIGNATURE "HHBA5100"

/* List of Control Codes */
#define HP_FC_IOCTL_GET_DRIVER_INFO			1
#define HP_FC_IOCTL_GET_CARD_CONFIG			2
#define HP_FC_IOCTL_GET_DEVICE_CONFIG		3
#define HP_FC_IOCTL_GET_LINK_STATISTICS		4
#define HP_FC_IOCTL_GET_DEVICE_STATISTICS	5
#define HP_FC_IOCTL_LINK_RESET				6
#define HP_FC_IOCTL_DEVICE_RESET			7
#define HP_FC_IOCTL_REG_READ				8
#define HP_FC_IOCTL_REG_WRITE				9

/* Data structure for Control Code HP_FC_IOCTL_GET_DRIVER_INFO */
#define MAX_HP_FC_DRIVER_NAME_SIZE			16
#define MAX_HP_FC_DRIVER_DESC_SIZE			64

typedef struct hpFcDriverInformation_s {
	os_bit8		DriverName[MAX_HP_FC_DRIVER_NAME_SIZE];
	os_bit8		DriverDescription[MAX_HP_FC_DRIVER_DESC_SIZE];
	os_bit16	MajorRev;
	os_bit16	MinorRev;
} hpFcDriverInformation_t;

/* Data structure for Control Code HP_FC_IOCTL_GET_CARD_CONFIG */
typedef struct hpFcCardConfiguration_s {
	os_bit8		PCIBusNumber;
	os_bit8		PCIDeviceNumber;
	os_bit8		PCIFunctionNumber;
	os_bit32	PCIBaseAddress0;
	os_bit32	PCIBaseAddress0Size;
	os_bit32	PCIBaseAddress1;
	os_bit32	PCIBaseAddress1Size;
	os_bit32	PCIBaseAddress2;
	os_bit32	PCIBaseAddress2Size;
	os_bit32	PCIBaseAddress3;
	os_bit32	PCIBaseAddress3Size;
	os_bit32	PCIBaseAddress4;
	os_bit32	PCIBaseAddress4Size;
	os_bit32	PCIBaseAddress5;
	os_bit32	PCIBaseAddress5Size;
	os_bit32	PCIRomBaseAddress;
	os_bit32	PCIRomSize;
	os_bit8		NodeName[8];
	os_bit8		PortName[8];
	os_bit8		Topology;
	os_bit8		HardAddress;
	os_bit32	NportId;
} hpFcCardConfiguration_t;

/* Possible definitions for Topology */
#define HP_FC_TOPO_UNKNOWN		0
#define HP_FC_POINT_TO_POINT	1
#define HP_FC_FABRIC			2
#define HP_FC_PRIVATE_LOOP		3
#define HP_FC_PUBLIC_LOOP		4

/* Data structures for Control Code HP_FC_IOCTL_GET_DEVICE_CONFIG */
typedef	struct hpFcNPortCmnParam_s {
    os_bit32 FC_PH_Version__BB_Credit;
    os_bit32 Common_Features__BB_Recv_Data_Field_Size;
    os_bit32 N_Port_Total_Concurrent_Sequences__RO_by_Info_Category;
    os_bit32 E_D_TOV;
} hpFcNPortCmnParam_t;

typedef	struct hpFcNPortClassParam_s {
    os_bit32 Class_Validity__Service_Options__Initiator_Control_Flags;
    os_bit32 Recipient_Control_Flags__Receive_Data_Size;
    os_bit32 Concurrent_Sequences__EE_Credit;
    os_bit32 Open_Sequences_per_Exchange;
} hpFcNPortClassParam_t;

typedef struct hpFcDeviceConfiguration_s {
	SCSI_ADDRESS	DeviceAddress;
	os_bit8			NodeName[8];
	os_bit8			PortName[8];
	os_bit32		NportId;
	os_bit8			HardAddress;
	os_bit8			Present;
	os_bit8			LoggedIn;
	os_bit32		ClassOfService;
	os_bit32		MaxFrameSize;
	os_bit8			Lun[8];         //Store the FCP Lun data
	hpFcNPortCmnParam_t CmnParams;
	hpFcNPortClassParam_t Class1Params;
	hpFcNPortClassParam_t Class2Params;
	hpFcNPortClassParam_t Class3Params;
} hpFcDeviceConfiguration_t;

/* Data structure for Control Code HP_FC_IOCTL_GET_LINK_STATISTICS */
typedef	struct hpFcLinkStatistics_s {
	os_bit8		LinkState;
	os_bit32	LinkDownCount;
	os_bit32	ResetCount;
} hpFcLinkStatistics_t;

/* Data structure for Control Code HP_FC_IOCTL_LINK_RESET */
typedef struct hpFcDeviceStatistics_s {
	SCSI_ADDRESS	DeviceAddress;
	os_bit32		LoginRetries;
	os_bit32		ReadsRequested;
	os_bit32		ReadsCompleted;
	os_bit32		ReadsFailed;
	os_bit32		BytesReadUpper32;
	os_bit32		BytesReadLower32;
	os_bit32		WritesRequested;
	os_bit32		WritesCompleted;
	os_bit32		WritesFailed;
	os_bit32		BytesWrittenUpper32;
	os_bit32		BytesWrittenLower32;
	os_bit32		NonRWRequested;
	os_bit32		NonRWCompleted;
	os_bit32		NonRWFailures;
} hpFcDeviceStatistics_t;

/* Data structure for Control Code HP_FC_IOCTL_DEVICE_RESET */
typedef struct hpFcDeviceReset_s {
	SCSI_ADDRESS	DeviceAddress;
} hpFcDeviceReset_t;

/* Data structure for Control Code HP_FC_IOCTL_REG_READ */
typedef struct hpFcRegRead_s {
	os_bit32	RegOffset;
	os_bit32	RegData;
} hpFcRegRead_t;

/* Data structure for Control Code HP_FC_IOCTL_REG_WRITE */
typedef struct hpFcRegWrite_s {
	os_bit32	RegOffset;
	os_bit32	RegData;
} hpFcRegWrite_t;

/* Return Codes */
#define HP_FC_RTN_OK					0
#define HP_FC_RTN_FAILED				1
#define HP_FC_RTN_BAD_CTL_CODE			2
#define HP_FC_RTN_INSUFFICIENT_BUFFER	3
#define HP_FC_RTN_INVALID_DEVICE		4

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\hppif3p.h ===
/**********************************************************************
// Compaq Confidential

  Author:       Compaq Computer Corporation.
        Systems Engineering -- System Software Development (NT Dev)
        Copyright 1996-98 Compaq Computer Corporation.
        All rights reserved.

  Date:         1 August 1996 

  File:         HPPIF3P.H   Hot Plug Interface MINIPORT Defs

  Purpose:      This file contains all miniport specific information necessary
                to interface to a hot plug device driver.
                
                  This file details the data structures and Application Programming 
                Interfaces (APIs) for PCI Hot Plug support running in a Windows 
                NT 4.0 server.  These data structures and APIs are used between 
                the Adapter Card drivers and the PCI Hot Plug Service for NT 4.0.  
                These files are considered vital to maintaining the Compatibility 
                of the PCI Hot Plug Functionality.

  Revision History:
   11/4/97        mib       Split into hppifio (IOCTLs) and hppifevt (Event) Defs
    06/11/98            Added PCS_HBA_OFFLINE_PENDING for cpqarray
  Version: 1.2

***********************************************************************/

#ifndef _HPPIF3P_H_
#define _HPPIF3P_H_

#include "hppifio.h"        // defines for driver hotplug interfaces
#include <ntddscsi.h>       // Scsi Miniport Interface (See SDK)

#pragma pack(1)


//**********************************************************************
//            DEFINES FOR MINIPORT DRIVERS
//**********************************************************************

// NIC Controller Status Defines

#define NIC_STATUS_NORMAL             0x00
#define NIC_STATUS_MEDIA_FAILURE      0x01
#define NIC_STATUS_ADAPTER_CHECK      0x02

#define NIC_STATUS_USER_SIMULATED_FAILURE  0x10
#define NIC_STATUS_POWER_OFF_PENDING       0x20
#define NIC_STATUS_POWER_OFF               0x30
#define NIC_STATUS_POWER_OFF_FAULT         0x40
#define NIC_STATUS_POWER_ON_PENDING        0x50
#define NIC_STATUS_POWER_ON           0x60
#define NIC_STATUS_POWER_FAULT             0x70



// IOCTL defines supporting Compaq Hot Plug PCI for SCSI Miniport

//#define HPP_BASE_SCSI_ADDRESS_DEFAULT    0x0004d008

#define CPQ_HPP_SIGNATURE                  "CPQHPP"
#define CPQ_HPP_TIMEOUT                         180

// Defines for completion codes
#define IOP_HPP_ISSUED                0x1
#define IOP_HPP_COMPLETED             0x2
#define IOP_HPP_CMDBUILT              0x3
#define IOP_HPP_NONCONTIGUOUS         0x4
#define IOP_HPP_ERROR                 0x5

// IOCTL control codes

#define IOC_HPP_RCMC_INFO           0x1
#define IOC_HPP_HBA_STATUS          0x2
#define IOC_HPP_HBA_INFO            0x3
#define IOC_HPP_SLOT_TYPE           0x4
#define IOC_HPP_SLOT_EVENT          0x5
#define IOC_HPP_PCI_CONFIG_MAP      0x6
#define IOC_HPP_DIAGNOSTICS         0x7

// IOCTL Status

#define IOS_HPP_SUCCESS                 0x0000
#define IOS_HPP_BUFFER_TOO_SMALL        0x2001
#define IOS_HPP_INVALID_CONTROLLER      0x2002
#define IOS_HPP_INVALID_BUS_TYPE        0x2003
#define IOS_HPP_INVALID_CALLBACK        0x2004
#define IOS_HPP_INVALID_SLOT_TYPE       0x2005
#define IOS_HPP_INVALID_SLOT_EVENT      0x2006
#define IOS_HPP_NOT_HOTPLUGABLE         0x2007
#define IOS_HPP_NO_SERVICE              0x2008
#define IOS_HPP_HBA_FAILURE             0x2009
#define IOS_HPP_INVALID_SERVICE_STATUS  0x200a
#define IOS_HPP_HBA_BUSY                0x200b
#define IOS_HPP_NO_DIAGNOSTICS          0x200c



// Health Driver Status Codes

#define CBS_HBA_FAIL_MESSAGE_COUNT     0x8 // Number of failure health messages.
                                                   // This must be updated if messages are
                                           // added or removed.
                                           // This is a compile time check.

#define CBS_HBA_STATUS_NORMAL          0x0000
#define CBS_HBA_STATUS_FAILED          0x1001
#define CBS_HBA_POWER_FAULT            0x1002
#define CBS_HBA_CABLE_CHECK            0x1003
#define CBS_HBA_MEDIA_CHECK            0x1004
#define CBS_HBA_USER_FAILED            0x1005
#define CBS_HBA_FAILED_CACHE_IN_USE    0x1006
#define CBS_HBA_PWR_FAULT_CACHE_IN_USE 0x1007

//Compaq reserves values 0x1010 and 0x1011

// IOCTL buffer data structures

typedef struct _HPP_RCMC_INFO_BUFFER {
    SRB_IO_CONTROL  IoctlHeader;
    HPP_RCMC_INFO   RcmcInfo;
} HPP_RCMC_INFO_BUFFER, *PHPP_RCMC_INFO_BUFFER;

typedef struct _HPP_CTRL_INFO_BUFFER {
    SRB_IO_CONTROL  IoctlHeader;
    HPP_CTRL_INFO   CtrlInfo;
} HPP_CTRL_INFO_BUFFER, *PHPP_CTRL_INFO_BUFFER;

typedef struct _HPP_CTRL_STATUS_BUFFER {
    SRB_IO_CONTROL  IoctlHeader;
    HPP_CTRL_STATUS CtrlStatus;
} HPP_CTRL_STATUS_BUFFER, *PHPP_CTRL_STATUS_BUFFER;

typedef struct _HPP_CTRL_SLOT_TYPE_BUFFER {
    SRB_IO_CONTROL      IoctlHeader;
    HPP_CTRL_SLOT_TYPE  CtrlSlotType;
} HPP_CTRL_SLOT_TYPE_BUFFER, *PHPP_CTRL_SLOT_TYPE_BUFFER;

typedef struct _HPP_SLOT_EVENT_BUFFER {
    SRB_IO_CONTROL      IoctlHeader;
    HPP_SLOT_EVENT      SlotEvent;
} HPP_SLOT_EVENT_BUFFER, *PHPP_SLOT_EVENT_BUFFER;

typedef struct _HPP_PCI_CONFIG_MAP_BUFFER {
    SRB_IO_CONTROL      IoctlHeader;
    HPP_PCI_CONFIG_MAP  PciConfigMap;
} HPP_PCI_CONFIG_MAP_BUFFER, *PHPP_PCI_CONFIG_MAP_BUFFER;

// Physical Controller State flags:
//
// Flags utilized to maintain controller state for Hot-Plug
//___________________________________________________________________________ 

// state flags 

#define PCS_HBA_OFFLINE       0x00000001 // Adaptor has been taken off-line
#define PCS_HBA_FAILED        0x00000002 // Adaptor is considered faulted
#define PCS_HBA_TEST          0x00000004 // Adaptor is being tested
#define PCS_HBA_CABLE_CHECK   0x00000008 // Failure due to cable fault
#define PCS_HBA_MEDIA_CHECK   0x00000010 // Failure due to media fault
#define PCS_HBA_EXPANDING     0x00000020 // Indicates that one or more LUNS is expanding
#define PCS_HBA_USER_FAILED   0x00000040 // Indicates user failed slot
#define PCS_HBA_CACHE_IN_USE  0x00000080 // Lazy write cache active
#define PCS_HPP_HOT_PLUG_SLOT 0x00000400 // Slot is Hot-Plugable
#define PCS_HPP_SERVICE_READY 0x00000800 // RCMC service is running
#define PCS_HPP_POWER_DOWN    0x00001000 // Normal power down on slot
#define PCS_HPP_POWER_LOST    0x00002000 // Slot power was lost
#define PCS_HBA_EVENT_SUBMIT  0x0000100     // Stall IO while AEV req submitted
#define PCS_HBA_IO_QUEUED     0x0000200     // IO is queuing.  
#define PCS_HBA_UNFAIL_PENDING 0x00010000 // Return error until PCS_HBA_OFFLINE is reset

//Macros related to Hot Plug Support

// The below defined macro can be used to determine active controller
// state.  Its use would be appropriate when deciding whether to
// handle a request via the startio entry point.

#define PCS_HBA_NOT_READY(FLAGS) (FLAGS & (PCS_HBA_FAILED       |   \
                          PCS_HBA_TEST         |     \
                          PCS_HBA_OFFLINE      |     \
                          PCS_HBA_EVENT_SUBMIT |     \
                          PCS_HPP_POWER_DOWN))

// Note that the following set does *not* flip the offline bit. It is the
// responsibility  of the initialization routine to bring a controller
// online if startup is successful.

#define PCS_SET_UNFAIL(FLAGS)        (FLAGS &= ~(PCS_HBA_FAILED      |   \
                             PCS_HBA_USER_FAILED))

#define PCS_SET_PWR_OFF(FLAGS)       (FLAGS |= (PCS_HPP_POWER_DOWN |     \
                            PCS_HBA_OFFLINE))

#define PCS_SET_PWR_FAULT(FLAGS)     (FLAGS |= (PCS_HPP_POWER_DOWN |     \
                            PCS_HPP_POWER_LOST |     \
                            PCS_HBA_OFFLINE))


#define PCS_SET_PWR_ON(FLAGS)        (FLAGS &= ~(PCS_HPP_POWER_DOWN |    \
                             PCS_HPP_POWER_LOST))

#define PCS_SET_USER_FAIL(FLAGS)     (FLAGS |= (PCS_HBA_FAILED      |    \
                            PCS_HBA_USER_FAILED |    \
                            PCS_HBA_OFFLINE))

#define PCS_SET_VERIFY(FLAGS)        (FLAGS |= (PCS_HBA_OFFLINE))

#define PCS_SET_CABLE_CHECK(FLAGS)   (FLAGS |= (PCS_HBA_FAILED      |    \
                            PCS_HBA_OFFLINE))

#define PCS_SET_ADAPTER_CHECK(FLAGS) (FLAGS |= (PCS_HBA_FAILED |    \
                            PCS_HBA_OFFLINE))

#define PCS_SET_MEDIA_CHECK(FLAGS)   (FLAGS |= (PCS_HBA_MEDIA_CHECK |    \
                            PCS_HBA_OFFLINE))

#define PCS_SET_TEST(FLAGS)          (FLAGS |= (PCS_HBA_TEST |      \
                            PCS_HBA_OFFLINE))

#define PCS_SET_NO_TEST(FLAGS)       (FLAGS &= ~(PCS_HBA_TEST |          \
                            PCS_HBA_OFFLINE))

// The following macro is used by the array driver to set the status member
// of the RCMC event structure.

#define RCMC_SET_STATUS(FLAGS, EVENTCODE)  \
if (FLAGS & PCS_HPP_POWER_LOST) {          \
  if (FLAGS & PCS_HBA_CACHE_IN_USE) {      \
    EVENTCODE = CBS_HBA_PWR_FAULT_CACHE_IN_USE; \
  } else {                       \
    EVENTCODE = CBS_HBA_POWER_FAULT;       \
  }                              \
} else if (FLAGS & PCS_HBA_MEDIA_CHECK) {  \
  EVENTCODE = CBS_HBA_MEDIA_CHECK;         \
} else if (FLAGS & PCS_HBA_CABLE_CHECK) {  \
  EVENTCODE = CBS_HBA_CABLE_CHECK;         \
} else if (FLAGS & PCS_HBA_USER_FAILED) {  \
  EVENTCODE = CBS_HBA_USER_FAILED;         \
} else if (FLAGS & PCS_HBA_FAILED) {       \
  if (FLAGS & PCS_HBA_CACHE_IN_USE) {      \
    EVENTCODE = CBS_HBA_FAILED_CACHE_IN_USE;    \
  } else {                       \
    EVENTCODE = CBS_HBA_STATUS_FAILED;          \
  }                              \
} else {                         \
  EVENTCODE = CBS_HBA_STATUS_NORMAL;       \
}


// Logical Controller State Flags:
//
// Flags utilized to signal driver internal procedures relevant to the
// maintenance of Hot-Plug.
//___________________________________________________________________________

// control flags

#define LCS_HBA_FAIL_ACTIVE  0x00000001 // Fail active controller
#define LCS_HBA_READY_ACTIVE 0x00000002 // Un-Fail active controller
#define LCS_HBA_TEST         0x00000004 // Perform tests on controller
#define LCS_HBA_OFFLINE      0x00000008 // Take adaptor off-line
#define LCS_HBA_TIMER_ACTIVE 0x00000010 // Timer routine running
#define LCS_HBA_INIT         0x00000020 // Used for power-up
#define LCS_HBA_IDENTIFY     0x00000040 // Send Indentify command
#define LCS_HBA_READY        0x00000080 // Free controller 
#define LCS_HBA_GET_EVENT    0x00000100 // Send async event req
#define LCS_HBA_HOLD_TIMER   0x00000200    // Don't process timer now
#define LCS_HBA_CHECK_CABLES 0x00000400    // Verify cables are secure
#define LCS_HPP_STOP_SERVICE 0x00001000    // Request stop of RCMC Service
#define LCS_HPP_SLOT_RESET   0x00002000    // Service reseting slot power


#define LCS_HPP_POWER_DOWN  LCS_HBA_FAIL_ACTIVE // Put adaptor in Hot-Plug
                            // Stall 

#define LCS_HPP_POWER_FAULT LCS_HBA_FAIL_ACTIVE // Send power-fault event

// The followimg macro is used in the array driver to setup the sequence of
// events required to initialize a powered-up controller to working
// condition.  Bits are flipped by each process until they are clear.

#define LCS_HPP_POWER_UP (LCS_HBA_INIT               |    \
               LCS_HBA_READY_ACTIVE)



//
// SRB Return codes.
// 

#define RETURN_BUSY                     0x00 // default value
#define RETURN_NO_HBA                   0x01
#define RETURN_ABORTED                  0x02
#define RETURN_ABORT_FAILED             0x03
#define RETURN_ERROR                    0x04
#define RETURN_INVALID_PATH_ID          0x05
#define RETURN_NO_DEVICE                0x06
#define RETURN_TIMEOUT                  0x07
#define RETURN_COMMAND_TIMEOUT          0x08
#define RETURN_MESSAGE_REJECTED         0x09
#define RETURN_BUS_RESET                0x0A
#define RETURN_PARITY_ERROR             0x0B
#define RETURN_REQUEST_SENSE_FAILED     0x0C
#define RETURN_DATA_OVERRUN             0x0D
#define RETURN_UNEXPECTED_BUS_FREE      0x0E
#define RETURN_INVALID_LUN              0x0F
#define RETURN_INVALID_TARGET_ID        0x10
#define RETURN_BAD_FUNCTION             0x11
#define RETURN_ERROR_RECOVERY           0x12
#define RETURN_PENDING                  0x13


#pragma pack()
#endif                  /* End of #ifndef _HPPIF3P_H_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\i21285.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/I21285.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 7/20/00 2:33p   $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures
  specific to the Intel 21285 StrongARM SA-110 to PCI Bridge

Reference Documents:

  21285 Core Logic for SA-110 Microprocessor
    Datasheet - September 1998

--*/

#ifndef __I21285_H__
#define __I21285_H__

/*+
PCI Configuration Mapping
-*/

typedef struct I21285_Config_s
               I21285_Config_t;

struct I21285_Config_s
       {
         os_bit32 DeviceID_VendorID;
         os_bit32 Status_Command;
         os_bit32 ClassCode_RevisionID;
         os_bit32 BIST_HeaderType_LatencyTimer_CacheLineSize;
         os_bit32 CSR_Memory_Base_Address;
         os_bit32 CSR_IO_Base_Address;
         os_bit32 SDRAM_Base_Address;
         os_bit32 reserved_1;
         os_bit32 reserved_2;
         os_bit32 reserved_3;
         os_bit32 CardBus_CIS_Pointer;
         os_bit32 SubsystemID_SubsystemVendorID;
         os_bit32 Expansion_ROM_Base_Address;
         os_bit32 reserved_CapPtr;
         os_bit32 reserved_4;
         os_bit32 MaxLat_MinGnt_InterruptPin_InterruptLine;
         os_bit8  reserved_5[0x70-0x40];
         os_bit32 PMCapabilities_PMCapabilityIdentifier;
         os_bit32 Data_reserved_PMControlAndStatus;
       };

#define I21285_Config_DeviceID_MASK                                                  (os_bit32)0xFFFF0000
#define I21285_Config_DeviceID_21285                                                 (os_bit32)0x10650000

#define I21285_Config_VendorID_MASK                                                  (os_bit32)0x0000FFFF
#define I21285_Config_VendorID_Intel                                                 (os_bit32)0x00001011

#define I21285_Config_Status_MASK                                                    (os_bit32)0xFFFF0000

#define I21285_Config_Status_Parity_Error                                            (os_bit32)0x80000000
#define I21285_Config_Status_Signaled_System_Error                                   (os_bit32)0x40000000
#define I21285_Config_Status_Received_Master_Abort                                   (os_bit32)0x20000000
#define I21285_Config_Status_Received_Target_Abort                                   (os_bit32)0x10000000
#define I21285_Config_Status_Signaled_Target_Abort                                   (os_bit32)0x08000000

#define I21285_Config_Status_DEVSEL_Timing_MASK                                      (os_bit32)0x06000000
#define I21285_Config_Status_DEVSEL_Timing_Medium                                    (os_bit32)0x02000000

#define I21285_Config_Status_Data_Parity_Error_Detected                              (os_bit32)0x01000000
#define I21285_Config_Status_Fast_Back_To_Back_Capable                               (os_bit32)0x00800000
#define I21285_Config_Status_UDF_Supported                                           (os_bit32)0x00400000
#define I21285_Config_Status_66MHz_Capable                                           (os_bit32)0x00200000

#define I21285_Config_Command_MASK                                                   (os_bit32)0x0000FFFF
#define I21285_Config_Command_Fast_Back_To_Back_Enable                               (os_bit32)0x00000200
#define I21285_Config_Command_SERR_Enable                                            (os_bit32)0x00000100
#define I21285_Config_Command_Wait_Cycle_Control                                     (os_bit32)0x00000080
#define I21285_Config_Command_Parity_Error_Response                                  (os_bit32)0x00000040
#define I21285_Config_Command_VGA_Palette_Snoop_Enable                               (os_bit32)0x00000020
#define I21285_Config_Command_Memory_Write_And_Invalidate_Enable                     (os_bit32)0x00000010
#define I21285_Config_Command_Special_Cycle_Enable                                   (os_bit32)0x00000008
#define I21285_Config_Command_Master_Enable                                          (os_bit32)0x00000004
#define I21285_Config_Command_Memory_Space_Enable                                    (os_bit32)0x00000002
#define I21285_Config_Command_IO_Space_Enable                                        (os_bit32)0x00000001

#define I21285_Config_ClassCode_MASK                                                 (os_bit32)0xFFFFFF00
#define I21285_Config_ClassCode_BaseClassCode_MASK                                   (os_bit32)0xFF000000
#define I21285_Config_ClassCode_BaseClassCode_SHIFT                                  (os_bit32)0x18
#define I21285_Config_ClassCode_SubClassCode_MASK                                    (os_bit32)0x00FF0000
#define I21285_Config_ClassCode_SubClassCode_SHIFT                                   (os_bit32)0x10
#define I21285_Config_ClassCode_ProgIF_MASK                                          (os_bit32)0x0000FF00
#define I21285_Config_ClassCode_ProgIF_SHIFT                                         (os_bit32)0x08

#define I21285_Config_RevisionID_MASK                                                (os_bit32)0x000000FF
#define I21285_Config_RevisionID_SHIFT                                               (os_bit32)0x00

#define I21285_Config_BIST_MASK                                                      (os_bit32)0xFF000000
#define I21285_Config_BIST_SHIFT                                                     (os_bit32)0x18
#define I21285_Config_HeaderType_MASK                                                (os_bit32)0x00FF0000
#define I21285_Config_HeaderType_SHIFT                                               (os_bit32)0x10
#define I21285_Config_LatencyTimer_MASK                                              (os_bit32)0x0000FF00
#define I21285_Config_LatencyTimer_SHIFT                                             (os_bit32)0x08
#define I21285_Config_CacheLineSize_MASK                                             (os_bit32)0x000000FF
#define I21285_Config_CacheLineSize_SHIFT                                            (os_bit32)0x00

#define I21285_Config_CapPtr_MASK                                                    (os_bit32)0x000000FF
#define I21285_Config_CapPtr_SHIFT                                                   (os_bit32)0x00

#define I21285_Config_SubsystemID_MASK                                               (os_bit32)0xFFFF0000
#define I21285_Config_SubsystemVendorID_MASK                                         (os_bit32)0x0000FFFF

#define I21285_Config_MaxLat_MASK                                                    (os_bit32)0xFF000000
#define I21285_Config_MaxLat_SHIFT                                                   (os_bit32)0x18

#define I21285_Config_MinGnt_MASK                                                    (os_bit32)0x00FF0000
#define I21285_Config_MinGnt_SHIFT                                                   (os_bit32)0x10

#define I21285_Config_InterruptPin_MASK                                              (os_bit32)0x0000FF00
#define I21285_Config_InterruptPin_SHIFT                                             (os_bit32)0x08

#define I21285_Config_InterruptLine_MASK                                             (os_bit32)0x000000FF
#define I21285_Config_InterruptLine_SHIFT                                            (os_bit32)0x00

#define I21285_Config_PMCapabilities_MASK                                            (os_bit32)0xFFFF0000
#define I21285_Config_PMCapabilities_PME_Asserted_From_D3_Cold                       (os_bit32)0x80000000
#define I21285_Config_PMCapabilities_PME_Asserted_From_D3_Hot                        (os_bit32)0x40000000
#define I21285_Config_PMCapabilities_PME_Asserted_From_D2                            (os_bit32)0x20000000
#define I21285_Config_PMCapabilities_PME_Asserted_From_D1                            (os_bit32)0x10000000
#define I21285_Config_PMCapabilities_PME_Asserted_From_D0                            (os_bit32)0x08000000
#define I21285_Config_PMCapabilities_PME_D2_Supported                                (os_bit32)0x04000000
#define I21285_Config_PMCapabilities_PME_D1_Supported                                (os_bit32)0x02000000
#define I21285_Config_PMCapabilities_DSI_Required                                    (os_bit32)0x00200000
#define I21285_Config_PMCapabilities_Aux_Power_Source                                (os_bit32)0x00100000
#define I21285_Config_PMCapabilities_PME_Clock                                       (os_bit32)0x00080000
#define I21285_Config_PMCapabilities_PM_Version_MASK                                 (os_bit32)0x00070000
#define I21285_Config_PMCapabilities_PM_Version_SHIFT                                (os_bit32)0x10

#define I21285_Config_PMCapabilityIdentifier_NextItemPtr_MASK                        (os_bit32)0x0000FF00
#define I21285_Config_PMCapabilityIdentifier_NextItemPtr_SHIFT                       (os_bit32)0x08

#define I21285_Config_PMCapabilityIdentifier_CapID_MASK                              (os_bit32)0x000000FF
#define I21285_Config_PMCapabilityIdentifier_CapID_SHIFT                             (os_bit32)0x00
#define I21285_Config_PMCapabilityIdentifier_CapID_PM                                (os_bit32)0x00000001

#define I21285_Config_Data_MASK                                                      (os_bit32)0xFF000000
#define I21285_Config_Data_SHIFT                                                     (os_bit32)0x18

#define I21285_Config_PMControlAndStatus_MASK                                        (os_bit32)0x0000FFFF
#define I21285_Config_PMControlAndStatus_PME_Status                                  (os_bit32)0x00008000
#define I21285_Config_PMControlAndStatus_Data_Scale_MASK                             (os_bit32)0x00006000
#define I21285_Config_PMControlAndStatus_Data_Scale_SHIFT                            (os_bit32)0x0D
#define I21285_Config_PMControlAndStatus_Data_Select_MASK                            (os_bit32)0x00001E00
#define I21285_Config_PMControlAndStatus_Data_Select_SHIFT                           (os_bit32)0x09
#define I21285_Config_PMControlAndStatus_PME_En                                      (os_bit32)0x00000100
#define I21285_Config_PMControlAndStatus_Power_State_MASK                            (os_bit32)0x00000003
#define I21285_Config_PMControlAndStatus_Power_State_D0                              (os_bit32)0x00000000
#define I21285_Config_PMControlAndStatus_Power_State_D1                              (os_bit32)0x00000001
#define I21285_Config_PMControlAndStatus_Power_State_D2                              (os_bit32)0x00000002
#define I21285_Config_PMControlAndStatus_Power_State_D3                              (os_bit32)0x00000003

/*+
PCI Control and Status Registers
-*/

typedef struct I21285_PCI_CSR_s
               I21285_PCI_CSR_t;

struct I21285_PCI_CSR_s
       {
         os_bit8  reserved_1[0x30-0x00];
         os_bit32 Outbound_Interrupt_Status;
         os_bit32 Outbound_Interrupt_Mask;
         os_bit8  reserved_2[0x40-0x38];
         os_bit32 Inbound_FIFO;
         os_bit32 Outbound_FIFO;
         os_bit8  reserved_3[0x50-0x48];
         os_bit32 Mailbox_0;
         os_bit32 Mailbox_1;
         os_bit32 Mailbox_2;
         os_bit32 Mailbox_3;
         os_bit32 Doorbell;
         os_bit32 Doorbell_Setup;
         os_bit32 ROM_Write_Byte_Address;
         os_bit8  reserved_4[0x80-0x6C];
       };

#define I21285_PCI_CSR_Outbound_Interrupt_Status_Outbound_Post_List_Interrupt        (os_bit32)0x00000008
#define I21285_PCI_CSR_Outbound_Interrupt_Status_Doorbell_Interrupt                  (os_bit32)0x00000004

#define I21285_PCI_CSR_Outbound_Interrupt_Mask_Outbound_Post_List_Interrupt          (os_bit32)0x00000008
#define I21285_PCI_CSR_Outbound_Interrupt_Mask_Doorbell_Interrupt                    (os_bit32)0x00000004

#define I21285_PCI_CSR_ROM_Write_Byte_Address_MASK                                   (os_bit32)0x00000003
#define I21285_PCI_CSR_ROM_Write_Byte_Address_SHIFT                                  (os_bit32)0x00

/*+
SA-110 Control and Status Registers
-*/

typedef struct I21285_SA110_CSR_s
               I21285_SA110_CSR_t;

struct I21285_SA110_CSR_s
       {
         os_bit8  reserved_01[0x080-0x000];
         os_bit32 DMA_Channel_1_Byte_Count;
         os_bit32 DMA_Channel_1_PCI_Address;
         os_bit32 DMA_Channel_1_SDRAM_Address;
         os_bit32 DMA_Channel_1_Descriptor_Pointer;
         os_bit32 DMA_Channel_1_Control;
         os_bit32 DMA_Channel_1_DAC_Address;
         os_bit8  reserved_02[0x0A0-0x098];
         os_bit32 DMA_Channel_2_Byte_Count;
         os_bit32 DMA_Channel_2_PCI_Address;
         os_bit32 DMA_Channel_2_SDRAM_Address;
         os_bit32 DMA_Channel_2_Descriptor_Pointer;
         os_bit32 DMA_Channel_2_Control;
         os_bit32 DMA_Channel_2_DAC_Address;
         os_bit8  reserved_03[0x0F8-0x0B8];
         os_bit32 CSR_Base_Address_Mask;
         os_bit32 CSR_Base_Address_Offset;
         os_bit32 SDRAM_Base_Address_Mask;
         os_bit32 SDRAM_Base_Address_Offset;
         os_bit32 Expansion_ROM_Base_Address_Mask;
         os_bit32 SDRAM_Timing;
         os_bit32 SDRAM_Address_And_Size_Array_0;
         os_bit32 SDRAM_Address_And_Size_Array_1;
         os_bit32 SDRAM_Address_And_Size_Array_2;
         os_bit32 SDRAM_Address_And_Size_Array_3;
         os_bit32 Inbound_Free_List_Head_Pointer;
         os_bit32 Inbound_Post_List_Tail_Pointer;
         os_bit32 Outbound_Post_List_Head_Pointer;
         os_bit32 Outbound_Free_List_Tail_Pointer;
         os_bit32 Inbound_Free_List_Count;
         os_bit32 Outbound_Post_List_Count;
         os_bit32 Inbound_Post_List_Count;
         os_bit32 SA110_Control;
         os_bit32 PCI_Address_Extension;
         os_bit32 Prefetchable_Memory_Range;
         os_bit32 XBus_Cycle_Arbiter;
         os_bit32 XBus_IO_Strobe_Mask;
         os_bit32 Doorbell_PCI_Mask;
         os_bit32 Doorbell_SA110_Mask;
         os_bit8  reserved_04[0x160-0x158];
         os_bit32 UARTDR;
         os_bit32 RXSTAT;
         os_bit32 H_UBRLCR;
         os_bit32 M_UBRLCR;
         os_bit32 L_UBRLCR;
         os_bit32 UARTCON;
         os_bit32 UARTFLG;
         os_bit32 reserved_05;
         os_bit32 IRQStatus;
         os_bit32 IRQRawStatus;
         os_bit32 IRQEnable_IRQEnableSet;
         os_bit32 IRQEnableClear;
         os_bit32 IRQSoft;
         os_bit8  reserved_06[0x200-0x194];
         os_bit32 SA110_DAC_Address_1;
         os_bit32 SA110_DAC_Address_2;
         os_bit32 SA110_DAC_Control;
         os_bit32 PCI_Address_31_Alias;
         os_bit8  reserved_07[0x280-0x210];
         os_bit32 FIQStatus;
         os_bit32 FIQRawStatus;
         os_bit32 FIQEnable_FIQEnableSet;
         os_bit32 FIQEnableClear;
         os_bit32 FIQSoft;
         os_bit8  reserved_08[0x300-0x294];
         os_bit32 Timer1Load;
         os_bit32 Timer1Value;
         os_bit32 Timer1Control;
         os_bit32 Timer1Clear;
         os_bit8  reserved_09[0x320-0x310];
         os_bit32 Timer2Load;
         os_bit32 Timer2Value;
         os_bit32 Timer2Control;
         os_bit32 Timer2Clear;
         os_bit8  reserved_10[0x340-0x330];
         os_bit32 Timer3Load;
         os_bit32 Timer3Value;
         os_bit32 Timer3Control;
         os_bit32 Timer3Clear;
         os_bit8  reserved_11[0x360-0x350];
         os_bit32 Timer4Load;
         os_bit32 Timer4Value;
         os_bit32 Timer4Control;
         os_bit32 Timer4Clear;
         os_bit8  reserved_12[0x800-0x370];
       };

#define I21285_SA110_CSR_DMA_Channel_n_Byte_Count_End_Of_Chain                       (os_bit32)0x80000000

#define I21285_SA110_CSR_DMA_Channel_n_Byte_Count_Direction_MASK                     (os_bit32)0x40000000
#define I21285_SA110_CSR_DMA_Channel_n_Byte_Count_Direction_PCI_To_SDRAM             (os_bit32)0x00000000
#define I21285_SA110_CSR_DMA_Channel_n_Byte_Count_Direction_SDRAM_To_PCI             (os_bit32)0x40000000

#define I21285_SA110_CSR_DMA_Channel_n_Byte_Count_Interburst_Delay_MASK              (os_bit32)0x3F000000
#define I21285_SA110_CSR_DMA_Channel_n_Byte_Count_Interburst_Delay_SHIFT             (os_bit32)0x18

#define I21285_SA110_CSR_DMA_Channel_n_Byte_Count_MASK                               (os_bit32)0x00FFFFFF
#define I21285_SA110_CSR_DMA_Channel_n_Byte_Count_SHIFT                              (os_bit32)0x00

#define I21285_SA110_CSR_DMA_Channel_n_SDRAM_Address_Control_MASK                    (os_bit32)0x80000000
#define I21285_SA110_CSR_DMA_Channel_n_SDRAM_Address_Control_Next_Descriptor         (os_bit32)0x00000000
#define I21285_SA110_CSR_DMA_Channel_n_SDRAM_Address_Control_DAC_Address             (os_bit32)0x80000000

#define I21285_SA110_CSR_DMA_Channel_n_SDRAM_Address_MASK                            (os_bit32)0x0FFFFFFF
#define I21285_SA110_CSR_DMA_Channel_n_SDRAM_Address_SHIFT                           (os_bit32)0x00

#define I21285_SA110_CSR_DMA_Channel_n_Descriptor_Pointer_MASK                       (os_bit32)0x0FFFFFF0
#define I21285_SA110_CSR_DMA_Channel_n_Descriptor_Pointer_SHIFT                      (os_bit32)0x00

#define I21285_SA110_CSR_DMA_Channel_n_Control_SDRAM_Read_Length_MASK                (os_bit32)0x00070000
#define I21285_SA110_CSR_DMA_Channel_n_Control_SDRAM_Read_Length_1_DWORD             (os_bit32)0x00000000
#define I21285_SA110_CSR_DMA_Channel_n_Control_SDRAM_Read_Length_2_DWORD             (os_bit32)0x00010000
#define I21285_SA110_CSR_DMA_Channel_n_Control_SDRAM_Read_Length_4_DWORD             (os_bit32)0x00020000
#define I21285_SA110_CSR_DMA_Channel_n_Control_SDRAM_Read_Length_8_DWORD             (os_bit32)0x00030000
#define I21285_SA110_CSR_DMA_Channel_n_Control_SDRAM_Read_Length_16_DWORD            (os_bit32)0x00040000

#define I21285_SA110_CSR_DMA_Channel_n_Control_PCI_Read_Length_MASK                  (os_bit32)0x00008000
#define I21285_SA110_CSR_DMA_Channel_n_Control_PCI_Read_Length_8_DWORDS              (os_bit32)0x00000000
#define I21285_SA110_CSR_DMA_Channel_n_Control_PCI_Read_Length_16_DWORDS             (os_bit32)0x00008000

#define I21285_SA110_CSR_DMA_Channel_n_Control_Interburst_Delay_Prescale_MASK        (os_bit32)0x00000300
#define I21285_SA110_CSR_DMA_Channel_n_Control_Interburst_Delay_Prescale_4           (os_bit32)0x00000000
#define I21285_SA110_CSR_DMA_Channel_n_Control_Interburst_Delay_Prescale_8           (os_bit32)0x00000100
#define I21285_SA110_CSR_DMA_Channel_n_Control_Interburst_Delay_Prescale_16          (os_bit32)0x00000200
#define I21285_SA110_CSR_DMA_Channel_n_Control_Interburst_Delay_Prescale_32          (os_bit32)0x00000300

#define I21285_SA110_CSR_DMA_Channel_n_Control_Chain_Done                            (os_bit32)0x00000080

#define I21285_SA110_CSR_DMA_Channel_n_Control_PCI_Read_Type_MASK                    (os_bit32)0x00000060
#define I21285_SA110_CSR_DMA_Channel_n_Control_PCI_Read_Type_Memory_Read             (os_bit32)0x00000000
#define I21285_SA110_CSR_DMA_Channel_n_Control_PCI_Read_Type_Memory_Read_Line        (os_bit32)0x00000020
#define I21285_SA110_CSR_DMA_Channel_n_Control_PCI_Read_Type_Memory_Read_Multiple_10 (os_bit32)0x00000040
#define I21285_SA110_CSR_DMA_Channel_n_Control_PCI_Read_Type_Memory_Read_Multiple_11 (os_bit32)0x00000060

#define I21285_SA110_CSR_DMA_Channel_n_Control_Initial_Descriptor_In_Register        (os_bit32)0x00000010

#define I21285_SA110_CSR_DMA_Channel_n_Control_Channel_Error                         (os_bit32)0x00000008

#define I21285_SA110_CSR_DMA_Channel_n_Control_Channel_Transfer_Done                 (os_bit32)0x00000004

#define I21285_SA110_CSR_DMA_Channel_n_Control_Channel_Enable                        (os_bit32)0x00000001

#define I21285_SA110_CSR_CSR_Base_Address_Mask_MASK                                  (os_bit32)0x0FFC0000
#define I21285_SA110_CSR_CSR_Base_Address_Mask_128B                                  (os_bit32)0x00000000
#define I21285_SA110_CSR_CSR_Base_Address_Mask_512KB                                 (os_bit32)0x00040000
#define I21285_SA110_CSR_CSR_Base_Address_Mask_1MB                                   (os_bit32)0x000C0000
#define I21285_SA110_CSR_CSR_Base_Address_Mask_2MB                                   (os_bit32)0x001C0000
#define I21285_SA110_CSR_CSR_Base_Address_Mask_4MB                                   (os_bit32)0x003C0000
#define I21285_SA110_CSR_CSR_Base_Address_Mask_8MB                                   (os_bit32)0x007C0000
#define I21285_SA110_CSR_CSR_Base_Address_Mask_16MB                                  (os_bit32)0x00FC0000
#define I21285_SA110_CSR_CSR_Base_Address_Mask_32MB                                  (os_bit32)0x01FC0000
#define I21285_SA110_CSR_CSR_Base_Address_Mask_64MB                                  (os_bit32)0x03FC0000
#define I21285_SA110_CSR_CSR_Base_Address_Mask_128MB                                 (os_bit32)0x07FC0000
#define I21285_SA110_CSR_CSR_Base_Address_Mask_256MB                                 (os_bit32)0x0FFC0000

#define I21285_SA110_CSR_CSR_Base_Address_Offset_MASK                                (os_bit32)0x0FFC0000
#define I21285_SA110_CSR_CSR_Base_Address_Offset_SHIFT                               (os_bit32)0x00

#define I21285_SA110_CSR_SDRAM_Base_Address_Mask_Window_Disable                      (os_bit32)0x80000000

#define I21285_SA110_CSR_SDRAM_Base_Address_Mask_MASK                                (os_bit32)0x0FFC0000
#define I21285_SA110_CSR_SDRAM_Base_Address_Mask_256KB                               (os_bit32)0x00000000
#define I21285_SA110_CSR_SDRAM_Base_Address_Mask_512KB                               (os_bit32)0x00040000
#define I21285_SA110_CSR_SDRAM_Base_Address_Mask_1MB                                 (os_bit32)0x000C0000
#define I21285_SA110_CSR_SDRAM_Base_Address_Mask_2MB                                 (os_bit32)0x001C0000
#define I21285_SA110_CSR_SDRAM_Base_Address_Mask_4MB                                 (os_bit32)0x003C0000
#define I21285_SA110_CSR_SDRAM_Base_Address_Mask_8MB                                 (os_bit32)0x007C0000
#define I21285_SA110_CSR_SDRAM_Base_Address_Mask_16MB                                (os_bit32)0x00FC0000
#define I21285_SA110_CSR_SDRAM_Base_Address_Mask_32MB                                (os_bit32)0x01FC0000
#define I21285_SA110_CSR_SDRAM_Base_Address_Mask_64MB                                (os_bit32)0x03FC0000
#define I21285_SA110_CSR_SDRAM_Base_Address_Mask_128MB                               (os_bit32)0x07FC0000
#define I21285_SA110_CSR_SDRAM_Base_Address_Mask_256MB                               (os_bit32)0x0FFC0000

#define I21285_SA110_CSR_SDRAM_Base_Address_Offset_MASK                              (os_bit32)0x0FFC0000
#define I21285_SA110_CSR_SDRAM_Base_Address_Offset_SHIFT                             (os_bit32)0x00

#define I21285_SA110_CSR_Expansion_ROM_Base_Address_Mask_Window_Disable              (os_bit32)0x80000000

#define I21285_SA110_CSR_Expansion_ROM_Base_Address_Mask_MASK                        (os_bit32)0x00F00000
#define I21285_SA110_CSR_Expansion_ROM_Base_Address_Mask_1MB                         (os_bit32)0x00000000
#define I21285_SA110_CSR_Expansion_ROM_Base_Address_Mask_2MB                         (os_bit32)0x00100000
#define I21285_SA110_CSR_Expansion_ROM_Base_Address_Mask_4MB                         (os_bit32)0x00300000
#define I21285_SA110_CSR_Expansion_ROM_Base_Address_Mask_8MB                         (os_bit32)0x00700000
#define I21285_SA110_CSR_Expansion_ROM_Base_Address_Mask_16MB                        (os_bit32)0x00F00000

#define I21285_SA110_CSR_SDRAM_Timing_Refresh_Interval_MASK                          (os_bit32)0x003F0000
#define I21285_SA110_CSR_SDRAM_Timing_Refresh_Interval_SHIFT                         (os_bit32)0x10

#define I21285_SA110_CSR_SDRAM_Timing_SA110_Prime                                    (os_bit32)0x00002000

#define I21285_SA110_CSR_SDRAM_Timing_Parity_Enable                                  (os_bit32)0x00001000

#define I21285_SA110_CSR_SDRAM_Timing_Command_Drive_Time_MASK                        (os_bit32)0x00000800
#define I21285_SA110_CSR_SDRAM_Timing_Command_Drive_Time_Same_Cycle                  (os_bit32)0x00000000
#define I21285_SA110_CSR_SDRAM_Timing_Command_Drive_Time_1_Cycle                     (os_bit32)0x00000800

#define I21285_SA110_CSR_SDRAM_Timing_Row_Cycle_Time_MASK                            (os_bit32)0x00000700
#define I21285_SA110_CSR_SDRAM_Timing_Row_Cycle_Time_4_Cycles                        (os_bit32)0x00000100
#define I21285_SA110_CSR_SDRAM_Timing_Row_Cycle_Time_5_Cycles                        (os_bit32)0x00000200
#define I21285_SA110_CSR_SDRAM_Timing_Row_Cycle_Time_6_Cycles                        (os_bit32)0x00000300
#define I21285_SA110_CSR_SDRAM_Timing_Row_Cycle_Time_7_Cycles                        (os_bit32)0x00000400
#define I21285_SA110_CSR_SDRAM_Timing_Row_Cycle_Time_8_Cycles                        (os_bit32)0x00000500
#define I21285_SA110_CSR_SDRAM_Timing_Row_Cycle_Time_9_Cycles                        (os_bit32)0x00000600
#define I21285_SA110_CSR_SDRAM_Timing_Row_Cycle_Time_10_Cycles                       (os_bit32)0x00000700

#define I21285_SA110_CSR_SDRAM_Timing_CAS_Latency_MASK                               (os_bit32)0x000000C0
#define I21285_SA110_CSR_SDRAM_Timing_CAS_Latency_2_Cycles                           (os_bit32)0x00000080
#define I21285_SA110_CSR_SDRAM_Timing_CAS_Latency_3_Cycles                           (os_bit32)0x000000C0

#define I21285_SA110_CSR_SDRAM_Timing_RAS_To_CAS_Delay_MASK                          (os_bit32)0x00000030
#define I21285_SA110_CSR_SDRAM_Timing_RAS_To_CAS_Delay_2_Cycles                      (os_bit32)0x00000020
#define I21285_SA110_CSR_SDRAM_Timing_RAS_To_CAS_Delay_3_Cycles                      (os_bit32)0x00000030

#define I21285_SA110_CSR_SDRAM_Timing_Last_Data_To_Refresh_MASK                      (os_bit32)0x0000000C
#define I21285_SA110_CSR_SDRAM_Timing_Last_Data_To_Refresh_2_Cycles                  (os_bit32)0x00000000
#define I21285_SA110_CSR_SDRAM_Timing_Last_Data_To_Refresh_3_Cycles                  (os_bit32)0x00000004
#define I21285_SA110_CSR_SDRAM_Timing_Last_Data_To_Refresh_4_Cycles                  (os_bit32)0x00000008
#define I21285_SA110_CSR_SDRAM_Timing_Last_Data_To_Refresh_5_Cycles                  (os_bit32)0x0000000C

#define I21285_SA110_CSR_SDRAM_Timing_Row_Precharge_Time_MASK                        (os_bit32)0x00000003
#define I21285_SA110_CSR_SDRAM_Timing_Row_Precharge_Time_1_Cycle                     (os_bit32)0x00000000
#define I21285_SA110_CSR_SDRAM_Timing_Row_Precharge_Time_2_Cycles                    (os_bit32)0x00000001
#define I21285_SA110_CSR_SDRAM_Timing_Row_Precharge_Time_3_Cycles                    (os_bit32)0x00000002
#define I21285_SA110_CSR_SDRAM_Timing_Row_Precharge_Time_4_Cycles                    (os_bit32)0x00000003

#define I21285_SA110_CSR_SDRAM_Address_And_Size_Array_n_Base_MASK                    (os_bit32)0x0FF00000
#define I21285_SA110_CSR_SDRAM_Address_And_Size_Array_n_Base_SHIFT                   (os_bit32)0x00

#define I21285_SA110_CSR_SDRAM_Address_And_Size_Array_n_Address_Multiplex_MASK       (os_bit32)0x00000070
#define I21285_SA110_CSR_SDRAM_Address_And_Size_Array_n_Address_Multiplex_SHIFT      (os_bit32)0x04

#define I21285_SA110_CSR_SDRAM_Address_And_Size_Array_n_Size_MASK                    (os_bit32)0x00000007
#define I21285_SA110_CSR_SDRAM_Address_And_Size_Array_n_Size_Disabled                (os_bit32)0x00000000
#define I21285_SA110_CSR_SDRAM_Address_And_Size_Array_n_Size_1MB                     (os_bit32)0x00000001
#define I21285_SA110_CSR_SDRAM_Address_And_Size_Array_n_Size_2MB                     (os_bit32)0x00000002
#define I21285_SA110_CSR_SDRAM_Address_And_Size_Array_n_Size_4MB                     (os_bit32)0x00000003
#define I21285_SA110_CSR_SDRAM_Address_And_Size_Array_n_Size_8MB                     (os_bit32)0x00000004
#define I21285_SA110_CSR_SDRAM_Address_And_Size_Array_n_Size_16MB                    (os_bit32)0x00000005
#define I21285_SA110_CSR_SDRAM_Address_And_Size_Array_n_Size_32MB                    (os_bit32)0x00000006
#define I21285_SA110_CSR_SDRAM_Address_And_Size_Array_n_Size_64MB                    (os_bit32)0x00000007

#define I21285_SA110_CSR_Inbound_Free_List_Head_Pointer_MASK                         (os_bit32)0x0FFFFFFC
#define I21285_SA110_CSR_Inbound_Free_List_Head_Pointer_SHIFT                        (os_bit32)0x00

#define I21285_SA110_CSR_Inbound_Post_List_Head_Pointer_MASK                         (os_bit32)0x0FFFFFFC
#define I21285_SA110_CSR_Inbound_Post_List_Head_Pointer_SHIFT                        (os_bit32)0x00

#define I21285_SA110_CSR_Outbound_Post_List_Head_Pointer_MASK                        (os_bit32)0x0FFFFFFC
#define I21285_SA110_CSR_Outbound_Post_List_Head_Pointer_SHIFT                       (os_bit32)0x00

#define I21285_SA110_CSR_Outbound_Free_List_Head_Pointer_MASK                        (os_bit32)0x0FFFFFFC
#define I21285_SA110_CSR_Outbound_Free_List_Head_Pointer_SHIFT                       (os_bit32)0x00

#define I21285_SA110_CSR_Inbound_Free_List_Count_MASK                                (os_bit32)0x0000FFFF
#define I21285_SA110_CSR_Inbound_Free_List_Count_SHIFT                               (os_bit32)0x00

#define I21285_SA110_CSR_Outbound_Post_List_Count_MASK                               (os_bit32)0x0000FFFF
#define I21285_SA110_CSR_Outbound_Post_List_Count_SHIFT                              (os_bit32)0x00

#define I21285_SA110_CSR_Inbound_Post_List_Count_MASK                                (os_bit32)0x0000FFFF
#define I21285_SA110_CSR_Inbound_Post_List_Count_SHIFT                               (os_bit32)0x00

#define I21285_SA110_CSR_SA110_Control_PCI_Central_Function                          (os_bit32)0x80000000

#define I21285_SA110_CSR_SA110_Control_XCS_Direction_MASK                            (os_bit32)0x70000000
#define I21285_SA110_CSR_SA110_Control_XCS_Direction_SHIFT                           (os_bit32)0x1C

#define I21285_SA110_CSR_SA110_Control_ROM_Tristate_Time_MASK                        (os_bit32)0x0F000000
#define I21285_SA110_CSR_SA110_Control_ROM_Tristate_Time_SHIFT                       (os_bit32)0x18

#define I21285_SA110_CSR_SA110_Control_ROM_Burst_Time_MASK                           (os_bit32)0x00F00000
#define I21285_SA110_CSR_SA110_Control_ROM_Burst_Time_SHIFT                          (os_bit32)0x14

#define I21285_SA110_CSR_SA110_Control_ROM_Access_Time_MASK                          (os_bit32)0x000F0000
#define I21285_SA110_CSR_SA110_Control_ROM_Access_Time_SHIFT                         (os_bit32)0x10

#define I21285_SA110_CSR_SA110_Control_ROM_Width_MASK                                (os_bit32)0x0000C000
#define I21285_SA110_CSR_SA110_Control_ROM_Width_Byte_Width                          (os_bit32)0x0000C000
#define I21285_SA110_CSR_SA110_Control_ROM_Width_Word_Width                          (os_bit32)0x00004000
#define I21285_SA110_CSR_SA110_Control_ROM_Width_Dword_Width                         (os_bit32)0x00008000

#define I21285_SA110_CSR_SA110_Control_Watchdog_Enable                               (os_bit32)0x00002000

#define I21285_SA110_CSR_SA110_Control_I2O_List_Size_MASK                            (os_bit32)0x00001C00
#define I21285_SA110_CSR_SA110_Control_I2O_List_Size_256_Entries                     (os_bit32)0x00000000
#define I21285_SA110_CSR_SA110_Control_I2O_List_Size_512_Entries                     (os_bit32)0x00000400
#define I21285_SA110_CSR_SA110_Control_I2O_List_Size_1K_Entries                      (os_bit32)0x00000800
#define I21285_SA110_CSR_SA110_Control_I2O_List_Size_2K_Entries                      (os_bit32)0x00000C00
#define I21285_SA110_CSR_SA110_Control_I2O_List_Size_4K_Entries                      (os_bit32)0x00001000
#define I21285_SA110_CSR_SA110_Control_I2O_List_Size_8K_Entries                      (os_bit32)0x00001400
#define I21285_SA110_CSR_SA110_Control_I2O_List_Size_16K_Entries                     (os_bit32)0x00001800
#define I21285_SA110_CSR_SA110_Control_I2O_List_Size_32K_Entries                     (os_bit32)0x00001C00

#define I21285_SA110_CSR_SA110_Control_PCI_Not_Reset                                 (os_bit32)0x00000200

#define I21285_SA110_CSR_SA110_Control_Discard_Timer_Expired                         (os_bit32)0x00000100

#define I21285_SA110_CSR_SA110_Control_DMA_SDRAM_Parity_Error                        (os_bit32)0x00000040

#define I21285_SA110_CSR_SA110_Control_PCI_SDRAM_Parity_Error                        (os_bit32)0x00000020

#define I21285_SA110_CSR_SA110_Control_SA110_SDRAM_Parity_Error                      (os_bit32)0x00000010

#define I21285_SA110_CSR_SA110_Control_Received_SERR                                 (os_bit32)0x00000008

#define I21285_SA110_CSR_SA110_Control_Assert_SERR                                   (os_bit32)0x00000002

#define I21285_SA110_CSR_SA110_Control_Initialize_Complete                           (os_bit32)0x00000001

#define I21285_SA110_CSR_PCI_Address_Extension_PCI_IO_Upper_Address_Field_MASK       (os_bit32)0xFFFF0000
#define I21285_SA110_CSR_PCI_Address_Extension_PCI_IO_Upper_Address_Field_SHIFT      (os_bit32)0x00

#define I21285_SA110_CSR_PCI_Address_Extension_PCI_Memory_Bit_31_MASK                (os_bit32)0x00008000
#define I21285_SA110_CSR_PCI_Address_Extension_PCI_Memory_Bit_31_SHIFT               (os_bit32)0x0F

#define I21285_SA110_CSR_Prefetchable_Memory_Range_Base_Address_MASK                 (os_bit32)0x7FF00000
#define I21285_SA110_CSR_Prefetchable_Memory_Range_Base_Address_SHIFT                (os_bit32)0x00

#define I21285_SA110_CSR_Prefetchable_Memory_Range_Mask_MASK                         (os_bit32)0x0007FF00
#define I21285_SA110_CSR_Prefetchable_Memory_Range_Mask_SHIFT                        (os_bit32)0x00

#define I21285_SA110_CSR_Prefetchable_Memory_Range_Prefetch_Length_MASK              (os_bit32)0x0000001C
#define I21285_SA110_CSR_Prefetchable_Memory_Range_Prefetch_Length_1_DWORD           (os_bit32)0x00000000
#define I21285_SA110_CSR_Prefetchable_Memory_Range_Prefetch_Length_2_DWORDS          (os_bit32)0x00000004
#define I21285_SA110_CSR_Prefetchable_Memory_Range_Prefetch_Length_4_DWORDS          (os_bit32)0x00000008
#define I21285_SA110_CSR_Prefetchable_Memory_Range_Prefetch_Length_8_DWORDS          (os_bit32)0x0000000C
#define I21285_SA110_CSR_Prefetchable_Memory_Range_Prefetch_Length_16_DWORDS         (os_bit32)0x00000010
#define I21285_SA110_CSR_Prefetchable_Memory_Range_Prefetch_Length_32_DWORDS         (os_bit32)0x00000014

#define I21285_SA110_CSR_Prefetchable_Memory_Range_Prefetch_Type_MASK                (os_bit32)0x00000002
#define I21285_SA110_CSR_Prefetchable_Memory_Range_Prefetch_Type_Read_Line           (os_bit32)0x00000000
#define I21285_SA110_CSR_Prefetchable_Memory_Range_Prefetch_Type_Read_Multiple       (os_bit32)0x00000002

#define I21285_SA110_CSR_Prefetchable_Memory_Range_Prefetch_Range_Enable             (os_bit32)0x00000001

#define I21285_SA110_CSR_XBus_Cycle_Arbiter_PCI_Interrupt_Request                    (os_bit32)0x80000000

#define I21285_SA110_CSR_XBus_Cycle_Arbiter_XBus_Chip_Select_MASK                    (os_bit32)0x70000000
#define I21285_SA110_CSR_XBus_Cycle_Arbiter_XBus_Chip_Select_SHIFT                   (os_bit32)0x1C

#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Interrupt_Input_Level_MASK               (os_bit32)0x0F000000
#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Interrupt_Input_Level_SHIFT              (os_bit32)0x18

#define I21285_SA110_CSR_XBus_Cycle_Arbiter_PCI_Arbiter                              (os_bit32)0x00800000

#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Priority_21285_MASK                      (os_bit32)0x00000010
#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Priority_21285_Low                       (os_bit32)0x00000000
#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Priority_21285_High                      (os_bit32)0x00000010

#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Priority_Requests_MASK                   (os_bit32)0x0000000F

#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Strobe_Shift_Divisor_MASK                (os_bit32)0x00003000
#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Strobe_Shift_Divisor_1                   (os_bit32)0x00000000
#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Strobe_Shift_Divisor_2                   (os_bit32)0x00001000
#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Strobe_Shift_Divisor_3                   (os_bit32)0x00002000
#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Strobe_Shift_Divisor_4                   (os_bit32)0x00003000

#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Device_n_Cycle_Length_MASK               (os_bit32)0x00000E00
#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Device_n_Cycle_Length_SHIFT              (os_bit32)0x09

#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Device_2_Cycle_Length_MASK               (os_bit32)0x000001C0
#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Device_2_Cycle_Length_SHIFT              (os_bit32)0x06

#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Device_1_Cycle_Length_MASK               (os_bit32)0x00000038
#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Device_1_Cycle_Length_SHIFT              (os_bit32)0x03

#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Device_0_Cycle_Length_MASK               (os_bit32)0x00000007
#define I21285_SA110_CSR_XBus_Cycle_Arbiter_Device_0_Cycle_Length_SHIFT              (os_bit32)0x00

#define I21285_SA110_CSR_XBus_IO_Stobe_Mask_Device_n_Strobe_Mask_MASK                (os_bit32)0xFF000000
#define I21285_SA110_CSR_XBus_IO_Stobe_Mask_Device_n_Strobe_Mask_SHIFT               (os_bit32)0x18

#define I21285_SA110_CSR_XBus_IO_Stobe_Mask_Device_2_Strobe_Mask_MASK                (os_bit32)0x00FF0000
#define I21285_SA110_CSR_XBus_IO_Stobe_Mask_Device_2_Strobe_Mask_SHIFT               (os_bit32)0x10

#define I21285_SA110_CSR_XBus_IO_Stobe_Mask_Device_1_Strobe_Mask_MASK                (os_bit32)0x0000FF00
#define I21285_SA110_CSR_XBus_IO_Stobe_Mask_Device_1_Strobe_Mask_SHIFT               (os_bit32)0x08

#define I21285_SA110_CSR_XBus_IO_Stobe_Mask_Device_0_Strobe_Mask_MASK                (os_bit32)0x000000FF
#define I21285_SA110_CSR_XBus_IO_Stobe_Mask_Device_0_Strobe_Mask_SHIFT               (os_bit32)0x00

#define I21285_SA110_CSR_UARTDR_Data_MASK                                            (os_bit32)0x000000FF
#define I21285_SA110_CSR_UARTDR_Data_SHIFT                                           (os_bit32)0x00

#define I21285_SA110_CSR_RXSTAT_Overrun_Error                                        (os_bit32)0x00000004
#define I21285_SA110_CSR_RXSTAT_Parity_Error                                         (os_bit32)0x00000002
#define I21285_SA110_CSR_RXSTAT_Frame_Error                                          (os_bit32)0x00000001

#define I21285_SA110_CSR_H_UBRLCR_Data_Size_Select_MASK                              (os_bit32)0x00000060
#define I21285_SA110_CSR_H_UBRLCR_Data_Size_Select_8_Bits                            (os_bit32)0x00000060
#define I21285_SA110_CSR_H_UBRLCR_Data_Size_Select_7_Bits                            (os_bit32)0x00000040
#define I21285_SA110_CSR_H_UBRLCR_Data_Size_Select_6_Bits                            (os_bit32)0x00000020
#define I21285_SA110_CSR_H_UBRLCR_Data_Size_Select_5_Bits                            (os_bit32)0x00000000

#define I21285_SA110_CSR_H_UBRLCR_Enable_FIFO                                        (os_bit32)0x00000010

#define I21285_SA110_CSR_H_UBRLCR_Stop_Bit_Select                                    (os_bit32)0x00000008

#define I21285_SA110_CSR_H_UBRLCR_Stop_Odd_Even_Select_MASK                          (os_bit32)0x00000004
#define I21285_SA110_CSR_H_UBRLCR_Stop_Odd_Even_Select_Even                          (os_bit32)0x00000004
#define I21285_SA110_CSR_H_UBRLCR_Stop_Odd_Even_Select_Odd                           (os_bit32)0x00000000

#define I21285_SA110_CSR_H_UBRLCR_Parity_Enable                                      (os_bit32)0x00000002

#define I21285_SA110_CSR_H_UBRLCR_Break                                              (os_bit32)0x00000001

#define I21285_SA110_CSR_M_UBRLCR_High_Baud_Rate_Divisor_MASK                        (os_bit32)0x0000000F
#define I21285_SA110_CSR_M_UBRLCR_High_Baud_Rate_Divisor_SHIFT                       (os_bit32)0x00

#define I21285_SA110_CSR_L_UBRLCR_Low_Baud_Rate_Divisor_MASK                         (os_bit32)0x000000FF
#define I21285_SA110_CSR_M_UBRLCR_Low_Baud_Rate_Divisor_SHIFT                        (os_bit32)0x00

#define I21285_SA110_CSR_UARTCON_IrDA_0_Encoding_MASK                                (os_bit32)0x00000004
#define I21285_SA110_CSR_UARTCON_IrDA_0_Encoding_3_16ths_Of_115000bps                (os_bit32)0x00000004
#define I21285_SA110_CSR_UARTCON_IrDA_0_Encoding_3_16ths_Of_Bit_Rate_Period          (os_bit32)0x00000000

#define I21285_SA110_CSR_UARTCON_SIREN_HP_SIR_Enable                                 (os_bit32)0x00000002

#define I21285_SA110_CSR_UARTCON_UART_Enable                                         (os_bit32)0x00000001

#define I21285_SA110_CSR_UARTFLG_Transmit_FIFO_Status_Busy                           (os_bit32)0x00000020

#define I21285_SA110_CSR_UARTFLG_Receive_FIFO_Status_Empty                           (os_bit32)0x00000010

#define I21285_SA110_CSR_UARTFLG_Transmitter_Busy                                    (os_bit32)0x00000008

#define I21285_SA110_CSR_TimerNLoad_MASK                                             (os_bit32)0x00FFFFFF

#define I21285_SA110_CSR_TimerN_FCLK_IN_FREQUENCY_PER_MICROSECOND                    (os_bit32)50
#define I21285_SA110_CSR_TimerN_FCLK_IN_FREQUENCY                                    (I21285_SA110_CSR_TimerN_FCLK_IN_FREQUENCY * 1000000)
#define I21285_SA110_CSR_TimerN_FCLK_IN_FREQUENCY_DIV_16                             (I21285_SA110_CSR_TimerN_FCLK_IN_FREQUENCY / 16)
#define I21285_SA110_CSR_TimerN_FCLK_IN_FREQUENCY_DIV_256                            (I21285_SA110_CSR_TimerN_FCLK_IN_FREQUENCY / 256)

#define I21285_SA110_CSR_TimerNControl_Prescaler_MASK                                (os_bit32)0x0000000C
#define I21285_SA110_CSR_TimerNControl_Prescaler_FCLK_IN                             (os_bit32)0x00000000
#define I21285_SA110_CSR_TimerNControl_Prescaler_FCLK_IN_DIV_16                      (os_bit32)0x00000004
#define I21285_SA110_CSR_TimerNControl_Prescaler_FCLK_IN_DIV_256                     (os_bit32)0x00000008
#define I21285_SA110_CSR_TimerNControl_Prescaler_IRQ_IN_I_N                          (os_bit32)0x0000000C

#define I21285_SA110_CSR_TimerNControl_Mode_MASK                                     (os_bit32)0x00000040
#define I21285_SA110_CSR_TimerNControl_Mode_Wrap_To_00FFFFFF                         (os_bit32)0x00000000
#define I21285_SA110_CSR_TimerNControl_Mode_Wrap_To_Load_Value                       (os_bit32)0x00000040

#define I21285_SA110_CSR_TimerNControl_Enable                                        (os_bit32)0x00000080

/*+
Address Map Partitioning
-*/

#define I21285_Address_Map_SDRAM                                                     (os_bit32)0x00000000
#define I21285_Address_Map_SDRAM_Array_0_Mode_Register                               (os_bit32)0x40000000
#define I21285_Address_Map_SDRAM_Array_1_Mode_Register                               (os_bit32)0x40004000
#define I21285_Address_Map_SDRAM_Array_2_Mode_Register                               (os_bit32)0x40008000
#define I21285_Address_Map_SDRAM_Array_3_Mode_Register                               (os_bit32)0x4000C000
#define I21285_Address_Map_XBus_XCS0                                                 (os_bit32)0x40010000
#define I21285_Address_Map_XBus_XCS1                                                 (os_bit32)0x40011000
#define I21285_Address_Map_XBus_XCS2                                                 (os_bit32)0x40012000
#define I21285_Address_Map_XBus_NoCS                                                 (os_bit32)0x40013000
#define I21285_Address_Map_ROM                                                       (os_bit32)0x41000000
#define I21285_Address_Map_CSR_Space                                                 (os_bit32)0x42000000
#define I21285_Address_Map_SA110_Cache_Flush                                         (os_bit32)0x50000000
#define I21285_Address_Map_Outbound_Write_Flush                                      (os_bit32)0x78000000
#define I21285_Address_Map_PCI_IACK_Special_Space                                    (os_bit32)0x79000000
#define I21285_Address_Map_PCI_Type_1_Configuration                                  (os_bit32)0x7A000000
#define I21285_Address_Map_PCI_Type_0_Configuration                                  (os_bit32)0x7B000000
#define I21285_Address_Map_PCI_Type_0_Configuration_Address_Generation               (os_bit32)0x00C00000
#define I21285_Address_Map_PCI_Type_0_Configuration_Address_Spacing                  (os_bit32)0x00000800
#define I21285_Address_Map_PCI_Type_0_Configuration_Address_Limit                    (os_bit32)0x00010000
#define I21285_Address_Map_PCI_IO_Space                                              (os_bit32)0x7C000000
#define I21285_Address_Map_PCI_IO_Space_Offset_MASK                                  (os_bit32)0x0000FFFF
#define I21285_Address_Map_PCI_Memory_Space                                          (os_bit32)0x80000000
#define I21285_Address_Map_PCI_Memory_Space_Offset_MASK                              (os_bit32)0x7FFFFFFF

#endif /* __I21285_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\hppifio.h ===
/**********************************************************************
// Compaq Confidential

  Author:       Compaq Computer Corporation.
        Systems Engineering -- System Software Development (NT Dev)
        Copyright 1996-98 Compaq Computer Corporation.
        All rights reserved.

  Date:         1 August 1996 

  File:         HPPIFIO.H   - Hot Plug Interface IOCTLs Defs

  Purpose:      This file contains all the hot plug IOCTL specific information 
                  necessary to interface to a hot plug device driver.
                
                  This file details the data structures and Application Programming 
                Interfaces (APIs) for PCI Hot Plug support running in a Windows 
                NT 4.0 server.  These data structures and APIs are used between 
                the Adapter Card drivers and the PCI Hot Plug Service for NT 4.0.  
                These files are considered vital to maintaining the Compatibility 
                of the PCI Hot Plug Functionality.

  Created:        11/4/97        Split off of hppif3p

  Version: 1.0
***********************************************************************/

#ifndef _HPPIFIO_H_
#define _HPPIFIO_H_

#include "hppifevt.h"  // Hot Plug Event Messages.

#pragma pack(1)



//**********************************************************************
//                  IOCTL DEFINITIONS         
//**********************************************************************

//====================================================================
//                      Common Defines & Structs
//====================================================================/

//
// Security defines
//

#define HPP_SECURITY_SIGNATURE  0x53505058      // Service Stop security flag 
                            // "HPPS"


//
// Hot Plug OIDs
// Each OID for NICs is relative to a base address value.
// The offset for the specific OID is added to the base value 
// to get the specific OID address value.
//
// The following is a list of OIDs which HPP compliant 
// drivers must respond to.  
//
// These offset values are also used to construct the Completion Codes.
// Each IOCTL has a specific family of completion codes.
//
// *** CAUTION ***
// Always update the 'HPP_IOCTL_COUNT' when adding/deleting IOCTLs.
//
//      Name                                    Offset          Get     Set
//--------------------------------------------------------------------------
#define HPP_IOCTL_RCMC_INFO_OFFSET              0x01    //      X       X
#define HPP_IOCTL_CONTROLLER_INFO_OFFSET        0x02    //      X
#define HPP_IOCTL_CONTROLLER_STATUS_OFFSET      0x03    //      X
#define HPP_IOCTL_SLOT_TYPE_OFFSET              0x04    //      X       X
#define HPP_IOCTL_SLOT_EVENT_OFFSET             0x05    //      X       X
#define HPP_IOCTL_PCI_CONFIG_MAP_OFFSET         0x06    //      X
#define HPP_IOCTL_STOP_RCMC_OFFSET              0x07    //              X
#define HPP_IOCTL_RUN_DIAGS_OFFSET              0x08    //              X

#define HPP_IOCTL_COUNT                         0x08


//
// Completion Codes.
// The following completion codes are defined from the 
// the driver IOCTLS.
//
// Completion codes are broken into families.  Each IOCTL will
// have its own family of completion codes.  This allows for easier
// debug at the cost of some extra code.
//
// The generic form of the completion codes is as follows:
//      0xrrrrIICC
//        --------
//        |   |  |
//        |   |  +-- CC == Individual Completion Code.
//        |   +----- II == IOCTL Offset (see above)
//        +--------- rrrr == Reserved at this time.
//
// Each IOCTL is assigned a specific family code.  All completion
// codes are defined relative to the IOCTL.
//
//  IOCTL               Offset:
//--------------------------------------------------------------------------
//  Service Info        0x000001xx
//  Controller Info     0x000002xx
//  Controller Status   0x000003xx
//  Slot Type           0x000004xx
//  Slot Status         0x000005xx
//  PCI Config Space    0x000006xx
//  Stop RCMC           0x000007xx



//
// Successful completion.  All IOCTLs will return success (HPP_SUCCESS)
// unless something fails.
//


#define HPP_SUCCESS                             0x00000000
#define HPP_INSUFICIENT_BUFFER_SPACE            0x00000001
#define HPP_INVALID_CONTROLLER                  0x00000002

#define HPP_INVALID_SERVICE_STATUS              0x00000101
#define HPP_INVALID_DRIVER_ID                   0x00000102
#define HPP_INVALID_CALLBACK_ADDR               0x00000103

#define HPP_INVALID_SLOT_TYPE                   0x00000401

#define HPP_INVALID_SLOT_EVENT                  0x00000501
#define HPP_INVALID_SIMULATED_FAILURE           0x00000502

#define HPP_DIAGS_NOT_SUPPORTED                      0x00000801



//----------------------------------------------------------------------
// Structure Name:      PCI Device/Function number
//
// Description:         Describes a PCI device.
//                      This is a general purpose PCI definition.
//                      It is used by many of the following requests.
//
// Example:             PCI_DESC        PciDescription
//
//                              PciDescription.ucBusNumber
//                              PciDescription.ucPCIDevFuncNum
//                              PciDescription.fcFunctionNumber
//                              PciDescription.fcDeviceNumber
//
// Note:                This structure is used by many IOCTLs.
//---------------------------------------------------------------------

typedef struct  _pci_descriptor
{
  UCHAR ucBusNumber;            // PCI Bus # (0-255)
  union
  {
    struct
    {
      UCHAR fcDeviceNumber:5;   // PCI Device # (0-31)
      UCHAR fcFunctionNumber:3; // PCI Function # (0-7)
    };
    UCHAR   ucPciDevFuncNum;    // Combined Dev and Func #
  };
} PCI_DESC, *PPCI_DESC;




//----------------------------------------------------------------------
// Structure Name:      HPP Controller Identification
//
// Description:         Specifies which controller an IOCTL is referring
//                      to.  HPP IOCTLs can be sent to any driver instance
//                      for any controller (for SCSI miniport).
//
// Note:                This structure is used by many IOCTLs.
//---------------------------------------------------------------------

typedef enum _hpp_controller_id_method
{
    // COMPAQ RESERVES VALUES 0x0 - 0x4 
   HPCID_PCI_DEV_FUNC = 0x5,      // 5 --  req PciDescriptor field
   HPCID_IO_BASE_ADDR = 0x6     // 6 --  req IOBaseAddress field
} E_HPP_CTRL_ID_METHOD;


typedef struct  _hpp_controller_id
{
  E_HPP_CTRL_ID_METHOD eController;             // Controller Selection
  union
  {
    struct
    {
      PCI_DESC  sPciDescriptor;                 // Used if 'eController'
      USHORT    reserved;                       // is set to: 'PCIDevFunc'
    };
    ULONG ulIOBaseAddress;                      // Used if 'eController'
  };                                            // is set to: 'IOBaseAddress'
} HPP_CTRL_ID, *PHPP_CTRL_ID;


//
// Common 'Template' header which can be applied to all
// Hot Plug PCI IOCTLs.
//

typedef struct  _hpp_common_header              // Get          Set
{                                               // -------------------
   ULONG           ulCompletionStatus;               // Output       Output
   HPP_CTRL_ID     sControllerID;                    // Input        Input
} HPP_HDR, *PHPP_HDR;


//====================================================================
//              SPECIFIC IOCTL: STRUCTS
//====================================================================/

//----------------------------------------------------------------------
// Structure Name:      HPP Service Info
//
// Description:         Called by the HPP RCMC to get or set
//                      the HPP's status.
//                      Service will notify when it starts and stops.
//
//                      IOCTL:          HPP_IOCTL_RCMC_INFO_OFFSET
//
//---------------------------------------------------------------------


//
// Service status information.
// The service will call the driver and notify it of
// Service Start and Stop.
//

typedef enum _hpp_rcmc_status
{
   HPRS_UNKNOWN_STATUS,    // 0
   HPRS_SERVICE_STARTING,  // 1
   HPRS_SERVICE_STOPPING,  // 2
} E_HPP_RCMC_STATUS;





// Callback prototype for service async messaging.

typedef 
ULONG 
(*PHR_CALLBACK) (
    PHR_EVENT pEvent
    );

typedef struct _hpp_rcmc_info                           // Get          Set
{                                                       // ------------------
   ULONG                   ulCompletionStatus;     // Output       Output
   HPP_CTRL_ID             sControllerID;          // Input        Input
   E_HPP_RCMC_STATUS       eServiceStatus;         // Output       Input
   ULONG                   ulDriverID;             // Output       Input
   PHR_CALLBACK             vpCallbackAddress;      // Output       Input
   ULONG                   ulCntrlChassis;         // Output       Input
   ULONG                   ulPhysicalSlot;         // Output       Input
} HPP_RCMC_INFO, *PHPP_RCMC_INFO;


//----------------------------------------------------------------------
// Structure Name:      HPP Controller Info
//
// Description:         Called by the HPP RCMC to get 
//                      configuration information of the all controllers
//                      controlled by the instance of the driver.
//
//
//                      IOCTL:          HPP_IOCTL_CONTROLLER_INFO_OFFSET
//
//---------------------------------------------------------------------

//
// Defines for the Support Version
//
//      Version information:
//      0xrrrrMMmm
//      ----------
//          | |  |
//          | |  +-- Minor Version information
//          | +----- Major Version information
//          +------- Currently reserved
//
// The RCMC service will consider minor revisions within the same
// Major version compatible (i.e. all structures are the same size,
// etc.).  If the service encounters an unknown Major Version
// it should consider the interface incompatible.
//

#define SUPPORT_VERSION_10      0x00000100              // Version 1.00


//
// Description of the various support classes
//

typedef enum _hpp_support_class
{
   HPSC_UNKNOWN_CLASS = 0,             // 0
   HPSC_MINIPORT_NIC = 1,              // 1
   HPSC_MINIPORT_STORAGE = 3,          // 3
   HPSC_GNR_MONOLITHIC   = 5,              // 5
   //COMPAQ RESERVES VALUES 0x2, 0x4, 0x6 TO 0xF
} E_HPP_SUPPORT_CLASS;



typedef enum    _hpp_bus_type           // Duplicates of the NT definition
{                                       // Copied from MINIPORT.H
   HPPBT_EISA_BUS_TYPE = 2,
   HPPBT_PCI_BUS_TYPE  = 5,
} E_HPP_BUS_TYPE;


// NIC Miniport
typedef struct _nic_miniport_class_config_info
{
   ULONG   ulPhyType;
   ULONG   ulMaxMediaSpeed;
} NICM_CLASS_CONFIG_INFO, *PNICM_CLASS_COFNIG_INFO;


//
// Address descriptors.
// Used to describe either an IO or Memory Address used
// by the controller.
//

typedef enum    _hpp_addr_type
{
   HPPAT_UNKNOWN_ADDR_TYPE,                // 0
   HPPAT_IO_ADDR,                          // 1 -- IO Port Address
   HPPAT_MEM_ADDR,                         // 2 -- Memory Address
} E_HPP_ADDR_TYPE;

typedef struct  _hpp_ctrl_address_descriptor
{
//IWN   BOOLEAN         fValid;                 // TRUE iff entry is valid
   UCHAR           fValid;                 // TRUE iff entry is valid    E_HPP_ADDR_TYPE eAddrType;              // IOAddress or Memory
   E_HPP_ADDR_TYPE eAddrType;              // IOAddress or Memory
   ULONG           ulStart;                // Starting address
   ULONG           ulLength;               // Length of addresses
} HPP_CTRL_ADDR, *PHPP_CTRL_ADDR;



//
// Definition of the Controller configuration.
//

typedef struct _hpp_controller_config_info
{
   E_HPP_BUS_TYPE  eBusType;               // PCI or EISA
   PCI_DESC        sPciDescriptor;         // Bus #, DevFunc
   ULONG           ulSlotNumber;           // EISA or PCI slot num
   ULONG           ulProductID;            // 32-Bit EISA ID,
                                                     // PCI Vendor or Device ID
   HPP_CTRL_ADDR   asCtrlAddress [16];     // IO/Memory Address
   ULONG           ulIRQ;                  // Controller Interrupt
   UCHAR           szControllerDesc [256]; // Text description
   NICM_CLASS_CONFIG_INFO  sNICM;               // NIC Miniport
} HPP_CTRL_CONFIG_INFO, *PHPP_CTRL_CONFIG_INFO;


//
// Information returned by the Controller Configuration Query.
//

typedef struct _hpp_controller_info                     // Get          Set
{                                                       // ----------------
   ULONG                   ulCompletionStatus;     // Output       Output
   HPP_CTRL_ID             sControllerID;          // Input        N/A
   E_HPP_SUPPORT_CLASS     eSupportClass;          // Output       N/A
   ULONG                   ulSupportVersion;       // Output       N/A
   HPP_CTRL_CONFIG_INFO    sController;            // Output       N/A
} HPP_CTRL_INFO, *PHPP_CTRL_INFO;




//----------------------------------------------------------------------
// Structure Name:      HPP Controller Status
//
// Description:         Called by the HPP RCMC to determine the status
//                      information of the all controllers controlled 
//                      by the instance of the driver.
//
//                      IOCTL:          HPP_IOCTL_CONTROLLER_STATUS_OFFSET
//
//---------------------------------------------------------------------

//
// Information returned by the Controller Status Query.
// Each support class will return different information.
// 

//HOT PLUG DRIVER STATUS Defines

#define HPP_STATUS_NORMAL                       0x00
#define HPP_STATUS_ADAPTER_CHECK           0x01
#define HPP_STATUS_LINK_FAILURE                 0x02
#define HPP_STATUS_MEDIA_FAILURE           0x03


#define HPP_STATUS_USER_SIMULATED_FAILURE  0x10
#define HPP_STATUS_POWER_OFF_FAULT              0x40
#define HPP_STATUS_ADAPTER_BUSY                 0x50



typedef struct _hpp_controller_status           // Get          Set
{                                               // -------------------
   ULONG           ulCompletionStatus;     // Output       Output
   HPP_CTRL_ID     sControllerID;          // Input        N/A
   ULONG           ulStatus;               // Output       N/A
} HPP_CTRL_STATUS, *PHPP_CTRL_STATUS;


//----------------------------------------------------------------------
// Structure Name:      HPP Controller Slot Type
//
// Description:         Called by the HPP RCMC to get or set
//                      what type of slot the controller is installed in.
//
//                      Can also be used to query slot information.
//
//                      IOCTL:          HPP_IOCTL_SLOT_TYPE_OFFSET
//
//---------------------------------------------------------------------

//
// Controller slot type definition
//

typedef enum    _hpp_slot_type
{
   HPPST_UNKNOWN_SLOT,             // 0
   HPPST_NORMAL_SLOT,              // 1 -- Could PCI or EISA
   HPPST_HOTPLUG_PCI_SLOT,         // 2 -- PCI only
} E_HPP_SLOT_TYPE;


typedef struct _hpp_controller_slot_type        // Get          Set
{                                               // -------------------
   ULONG           ulCompletionStatus;     // Output       Output
   HPP_CTRL_ID     sControllerID;          // Input        Input
   E_HPP_SLOT_TYPE eSlotType;              // Output       Input
} HPP_CTRL_SLOT_TYPE, *PHPP_CTRL_SLOT_TYPE;



//----------------------------------------------------------------------
// Structure Name:      HPP Controller Slot Event
//
// Description:         Called by the HPP Service to get or set
//                      the Controller's slot status.
//                                           
//
//                      IOCTL:          HPP_IOCTL_SLOT_EVENT_OFFSET
//
//---------------------------------------------------------------------

//
// Each of the following are mutually exclusive.  If two 
// status events occur simultaneously, the service will serialize
// them to the drivers.
//

typedef enum    _hpp_slot_status
{
   HPPSS_UNKNOWN,          // 0

   HPPSS_NORMAL_OPERATION, // 1    // Restore from Simulated Failure
   HPPSS_SIMULATED_FAILURE,// 2    // Enter Simulated Failure Mode

   HPPSS_POWER_FAULT,      // 3    // Power fault occured, error!!!!

   HPPSS_POWER_OFF_WARNING,// 4    // Power On/Off conditions
   HPPSS_POWER_OFF,        // 5
   HPPSS_POWER_ON_WARNING, // 6
   HPPSS_POWER_ON,         // 7
   //The following defines are for the SCSI miniport drivers
   HPPSS_RESET_WARNING,    // 8    // PCI level slot reset
   HPPSS_RESET,            // 9  
    // Compaq reserves A to F
} E_HPP_SLOT_STATUS;


typedef struct _hpp_slot_event                          // Get          Set
{                                                       // -------------------
   ULONG                   ulCompletionStatus;     // Output       Output
   HPP_CTRL_ID             sControllerID;          // Input        Input
   E_HPP_SLOT_STATUS       eSlotStatus;            // Output       Input
} HPP_SLOT_EVENT, *PHPP_SLOT_EVENT;


//----------------------------------------------------------------------
// Structure Name:      HPP PCI Configuration Map
//
// Description:         Called by the HPP Service to get the
//                      device's PCI configuration map.
//
//                      IOCTL:          HPP_IOCTL_PCI_CONFIG_MAP_OFFSET
//
//---------------------------------------------------------------------



//
// Defines for the Map Version
//
//      Version information:
//      0xrrrrMMmm
//      ----------
//          | |  |
//          | |  +-- Minor Version information
//          | +----- Major Version information
//          +------- Currently reserved
//
// The RCMC service will consider minor revisions within the same
// Major version compatible (i.e. all structures are the same size,
// etc.).  If the service encounters an unknown Major Version
// it should consider the interface incompatible.
//



#define HPP_CONFIG_MAP_VERSION_10       0x00000100      // Version 1.00




typedef struct _hpp_pci_config_range
{
   UCHAR   ucStart;        // Start Offset of PCI config space.
   UCHAR   ucEnd;          // Ending Offset of PCI config space.
   ULONG   ulControlFlags; // RCMC flags, not for driver's use.

   ULONG   ulReserved [4]; // Reserved